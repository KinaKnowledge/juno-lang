
(create_css_entry ".juno-editable div:focus"
  [[`outline `none]])
          
(defmacro progc (`& forms)
   `(try
       (progn
          ,@forms)
       (catch Error (e)
          (log e.message)))
   {
     `description: (+ "<br><br>This macro wraps the provided forms in a try-catch, and returns the "
                      "last value if no errors, like progn, or if an error occurs, logs to the "
                      "console.  Simple help for debugging.   <br>Example<br> ")



       `tags: ["debug" "error" "catch" "handler" "progn" "eval"]
       `usage: ["forms:*"]
   })

(defun_sync reverse_string (text)
   (join "" (-> (split_by "" text) `reverse))
   {
       description: "Given a string, returns the characters in reverse order."
       usage: ["text:string"]
       tags: ["string" "text" "reverse" "modify" ]
   })

(defun_sync last_n_chars (n text)
   (if (is_string? text)
       (-> text `substr (* -1 n))
       nil)
   {
       description: "For a given string, returns the last n characters as a string."
       usage: ["n:number" "text:string"]
       tags: ["string" "text" "last" "amount" "end" "tail"]
   })

(defun_sync last_n (n arr)
   (if (is_array? arr)
       (-> arr `slice (* -1 n))
       nil)
   {
       description: "For a given array, returns the last n elements as an array."
       usage: ["n:number" "arr:array"]
       tags: ["array" "list" "text" "last" "amount" "end" "tail"]
   })
                          
;; verbs for our editing command language

(defmacro get_selection ()
   `(-> window `getSelection))

(defun_sync get_range (selection index)
   (if selection
      (-> selection `getRangeAt (or index 0))
      (progn
         (log "selection is nil")
         nil)))

(defmacro remove_all_ranges (selection)
   `(-> ,#selection `removeAllRanges))

(defmacro collapse_to_start (selection)
   `(-> ,#selection `collapseToStart))

(defmacro collapse_to_end (selection)
   `(-> ,#selection `collapseToEnd))

(defun_sync select_element (elem)
   (progn
      (defvar sel (get_selection))
      (if sel
         (-> sel `selectAllChildren elem)
         (progn
            (log "unable to get_selection for " (element_to_lisp elem))
            nil))))

(defun_sync move_to_point (point_obj)
   (progc
      (when point_obj.selection
         (focus_to (if (== point_obj.pos_type 1)
                       point_obj.pos_node
                       point_obj.pos_node.parentElement))
         (defvar selection (get_selection))
         (remove_all_ranges selection)
         (-> selection `addRange point_obj.range))))
         
(defun_sync move_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `move dir (or granularity "character"))))))

(defun_sync extend_from_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `extend dir (or granularity "character")))))
   {
     `description: nil
     })

(defun point_for (root_element)
   (let
      ((selection (get_selection))
       (selrange (get_range selection))
       (selected_node selrange.startContainer)
       (offset selrange.startOffset)
       (position (progn
                    (if (== selrange.startContainer.nodeType 3)
                        (progn
                           (get_cursor_position selrange.startContainer.parentElement))
                        selrange.endOffset)))
       (current_element selected_node)
       (path []))
      (while (and (not (eq current_element nil))
                  (not (== current_element root_element)))
         (progn
            (prepend path current_element)
            (= current_element current_element.parentElement)))
      { dom_path: path
        position: position
        pos_type: selected_node.nodeType
        pos_node: selected_node
        selection: selection
        range: selrange
        })
   {
     `description: (div { contenteditable: "true"
                          tabindex: "0" }
                     (div {} "Given a reference to a placed DOM element, returns an object that contains the contextual details of the current cursor position and selection.")
                     (div {} (h4 {} "Layout of Return Object"))
                     (pre { style: "min-height: 2.4ch;" }
                          (span { style: "font-size: 15.4px;" }
                                "{ dom_path: path\n  position: position\n  pos_type: selected_node.nodeType\n  pos_node: selected_node\n  selection: selection\n  range: selrange\n}"))
                     (div {} (br {})) (div {} (br {})))

     `usage: ["element:Element"]
     `tags: ["DOM" "UI" "editor"]

   })

(defun_sync select_node_at_point ()
   (let
      ((selection (get_selection))
       (selrange (get_range selection)))
      (if (== selrange.startContainer.nodeType 3)
         (-> selection `selectAllChildren selrange.startContainer.parentElement)
         (-> selection `selectAllChildren selrange.startContainer))))
       
      
(defun_sync get_text_around_point (point)
   (let
      ((text [])
       (elem nil))
      (progc
         (when point
            (cond 
               (== point.pos_type 1)
               (progn
                  (= elem point.pos_node))
               (== point.pos_type 3)
               (progn
                  (= elem point.pos_node.parentElement))))
         (when elem
            (push text
               (-> elem.innerText `substr 0 point.position))
            (push text
               (-> elem.innerText `substr point.position)))
         text))
   {
       description: (+ "<br><br>Given a point object, returns an array that can contain up to two "
                       "strings.  The first value, at position 0, is the element text prior to the "
                       "point\'s position. The second value is the text of the element after the point\'s "
                       "position. ")
       usage: ["point_object:object"]
       tags: ["DOM" "point" "edit" "selection" "editor" "select"]
   })
         
            
               
(defun_sync point_tag_path (point)
   (for_each (c point.dom_path)
      (progn
         (if (== 1 c.nodeType)
             c.tagName
             "text")))
   {
       `description: "Given a point object, returns the tag names that comprise the path to the point."
       `usage: ["point:object"]
       `tags: ["point" "editor" "DOM" "selection" "select"]
   })



(defun insert_elem_at_point (elem under_root)
      (try
         (let
            ((selection (get_selection))
             (selrange (-> selection `getRangeAt 0))
             (parent_element (if (== selrange.startContainer.nodeType 3)  ;; text node
                                 selrange.startContainer.parentElement
                                 selrange.startContainer))
             (offset selrange.startOffset)
             (remaining_text nil))
            ;; extend it from the current point
            
            (-> selrange `setEndBefore parent_element.nextSibling)
            (= remaining_text (-> selrange `toString))
            (-> selection `deleteFromDocument)
            (= selection (get_selection))
            (remove_all_ranges selection)
            (-> selection `addRange selrange)
            (-> parent_element `append elem remaining_text)
            (collapse_to_start selection))
         (catch Error (e)
            (log (+ "ERROR: insert_elem_at_point:" e.message)))))


(defun_sync point_under_element_tag? (tag_name point)
   (contains? tag_name (point_tag_path point))
   {
     description: (+ "Returns true if the provided editor point is in a DOM tree containing "
                     "the provided tagname, otherwise false. ")

       usage: ["tag_name:string" "point:object"]
       tags: ["editor" "point" "cursor" "DOM" "tree" "element"]
   })

(defun wait_for_editor (content)
   (if (get_control_by_name "Description Editor")
       (alert_box (dtext "Open Editor")
                  (dtext "There can be only one description editor open at a time."))
       (new Promise
          (fn (resolve reject)
             (let
                ((result nil)
                 (name "Description Editor")
                 (deditor (DOM_editor { rules: [ `*markdown_rules* ] `content: content `name: name })))
                (defglobal $ed_rval nil)
                (place_control `right deditor)
                (while (and (get_control_by_id deditor.options.id)
                            (is_nil? $ed_rval))
                   (progn
                      (sleep 1)))
                (when (get_control_by_id deditor.options.id)
                   (log "wait_for_editor: was able to get the control by id again.")
                   (console.log "wait_for_editor: was able to get the control by id again!")
                   (debug))
                   ;(destroy_control deditor))
                (resolve `(+ ,@$ed_rval))))))
   {
     description: (+ "<br><br>The `wait_for_editor` function is a support function for the "
                     "`DOM_editor` and `text_editor` integration, specifically around facilitating "
                     "the description editing process.  ")

   })


(defun edit_description_text (control)
   (let
      ((ctl (or (and control
                     (== control.type "text_editor"))
                (if (== (prop *last_focus* `type) "text_editor")
                    *last_focus*
                    nil))))
      (if ctl
         (let
            ((pos (-> ctl `get_selection))
             (select_pos nil)
             (parent_pos nil)
             (editor ctl.editor)
             (new_text nil)
             (content nil)
             (thing_we_are_in nil)
             (ok_to_proceed true)
             (error_content (div
                              (dtext "To use the Description Text Editor, the description field must be in one of the following forms:")
                              (br)
                              (code "description: nil")
                              (br)
                              (code "description: (+ \"content\")")))
             (text nil))
            
            (select_to_current_form editor)
            (= select_pos (-> ctl `get_selection))
            (= text (-> ctl `get_selected_text))
            
            (= thing_we_are_in (read_lisp text { suppress_throw_on_error: true } ))
            (cond
               (is_array? thing_we_are_in)
               (progn
                  (= parent_pos (find_last_paren editor select_pos.start))
                  (-> editor.selection `clearSelection)
                  (-> editor.selection `setSelectionAnchor parent_pos.start.row parent_pos.start.column)
                  (-> editor.selection `selectTo parent_pos.end.row (+ parent_pos.end.column 0))
                  (= thing_we_are_in (read_lisp (-> ctl `get_selected_text) { suppress_throw_on_error: true } ))
                  
                  (if (and (prop thing_we_are_in `description)
                           (>= select_pos.start.row parent_pos.start.row)
                           (<= select_pos.end.row parent_pos.end.row)
                           (== (eval (prop thing_we_are_in `description)) (eval (read_lisp text)))
                           )
                      (progn
                          (-> editor.selection `clearSelection)
                          (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                          (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column)))
                      (progn
                         (= ok_to_proceed false)
                         (alert_box (dtext "Edit Description Text")
                                    error_content))))
               (and (is_object? thing_we_are_in)
                    (contains? "description:" (trim (-> editor.session `getLine pos.start.row)))
                    (contains? "description" (keys thing_we_are_in))
                    (== thing_we_are_in.description (quote "=:nil")))
               (progn
                  (-> editor `clearSelection)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  (= select_pos (-> editor.session `getAWordRange pos.start.row pos.end.column))
                  (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                  (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column 0))
                  
                  (= text "")
                  (= select_pos pos))
               else
               (progn
                  (= ok_to_proceed false)
                  (alert_box (dtext "Edit Description Text")
                             error_content)))
            (when ok_to_proceed
               (progc
                  (= content  (unpack_description (or (eval (read_lisp (or text ""))) "Empty") { `edit_mode: true })))
               (-> ctl `set_read_only true)
               (= pos (-> ctl `get_selection))
               (= new_text (wait_for_editor content))
               (console.log "edit_description_text: back from wait for editor" (get_by_id "body"))
              
               (-> ctl `set_read_only false)
               ;(log "edit_description_text: new_text: " new_text)
               (when (and new_text
                          (second new_text))
                  (= new_text (pretty_print new_text))
                  (console.log "edit_description_text: inserting text:" (get_by_id "body"))
                  (-> (-> editor `getSession) `replace pos new_text)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  ;; slow it down so we can watch the fitment..
                  (sleep 0.3)
                  (select_to_current_form ctl.editor)
                  (sleep 0.2)
                  (indent_editor_selection  ctl.editor)
                  (sleep 0.1))))
         (alert_box (dtext "Edit Description Text")
                    (dtext "The control being used must be a text editor type."))))
   { 
     `description: (+ "This function provides an ability to edit the description text of a function "
                      "for easier documentation.  When invoked, if not provided with a specific "
                      "text_editor control, will use the *last_focus* control if it is a text editor "
                      "type.   The current cursor position of the editor it is being invoked on will "
                      "be examined, and if it meets certain criteria, the description text will be "
                      "gathered and the description editor pane will pop up providing the user the "
                      "ability to edit the text in a fashion more amenable for writing "
                      "documentation.  <br>Once completed with the description edits, the user can "
                      "press the short cut key for get_as_wordwrap_text (default is bound to Alt-X) or "
                      "select the \"Get As Wordwrap Text\" menu item from the control menu.  This will "
                      "close the editor and place the contents of the description editor into the "
                      "source code in the appropriate position and form. <br>If the contents of the "
                      "description editor are not to be saved back to the text editor, just close the "
                      "editor, either from the menu or by pressing <br>Alt-D<br> (or the command "
                      "currently associated with the Close Control Command).  See (show_key_bindings) "
                      "in the REPL for a table of current globally defined key bindings. <br>#### "
                      "Qualifying formats of the Description Field to be Edited<br>The description "
                      "field must either have a value of nil (empty).  In this case, the description "
                      "editor will be empty of content when opened.  In this case the field entry "
                      "would look like:<br>```{\n   description: nil \n}```<br><br>If the description "
                      "field is already populated with content, it will need to be in the form "
                      "of: <br>```{\n   description: (+ \"Content Line\" \"more content\" "
                      "\"...\")\n}```<br><br>This is the format that the Description editor will place "
                      "into the source code when complete.<br>#### Other Notes<br>When the Description "
                      "Editor is invoked and while the user is editing text, the text_buffer that it "
                      "is being invoked on is placed into read only mode and so cannot be modified "
                      "until the Description Editor is closed. ")

      `usage: ["control:?object"]
      `tags: ["editor" "description" "metadata" "meta" ] })

(defparameter *markdown_rules*
   {
     meta: {
         name: "markdown"
         description: "Simple implementation of a subset of markdown for documentation. To be used with the DOM Editor"
     }
     reload_rules:{
         on_event: `keydown
         key_sequence: "Alt-L"
         handle_event: true
         control_menu: true
         description: "Reloads the markdown rule set.  This can be used after any changes have been made to the rule set."
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (notify (+ "Reloading Rules: " ctl.name))
                     (-> ctl `reload_rules)))
         
     }
     get_as_wordwrap_text:{
         on_event: `keydown
         key_sequence: "Alt-X"
         handle_event: true
         control_menu: true
         description: (+ "Used with the text editor, will collect the DOM buffer contents and "
                         "place the contents in the description text of the edited function. "
                         "NOTE: this will close the DOM editor. ")
         qualifier: (fn (point ctl)
                       (progn
                          true))
         exec: (fn (point ctl event)
                  (if (and ctl
                             (== ctl.type "DOM_editor"))
                      (try
                         (progn
                            (-> ctl `save)
                            (defglobal $ed_rval (for_each (line (word_wrap (join "" (DOM_to_markdown  (-> ctl `get)))))
                                                   (if (ends_with? " " line)
                                                       line
                                                       (+ line " "))))
                            (destroy_control ctl))
                         (catch Error (e)
                            (progn
                               (notify "ERROR: " e.message)
                               (console.error e))))
                      (progn
                         (notify (+ "TYPE: " ctl.type)))))
     }
     get_as_markdown_text:{
         on_event: `keydown
         key_sequence: "Alt-R"
         handle_event: true
         control_menu: true
         description: "Copies the DOM buffer contents to the clipboard as markdown text."
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (-> ctl `save)
                     (sleep 0.1)
                     (copy_text_to_clipboard
                        (pretty_print
                           (for_each (line (word_wrap (join "" (DOM_to_markdown  (-> ctl `get)))))
                              (if (ends_with? " " line)
                                  line
                                  (+ line " ")))))))
     }
     copy_as_quoted:{
         on_event: `keydown
         key_sequence: "Alt-Shift-Q"
         handle_event: true
         control_menu: true
         description: "Copies the contents of the DOM buffer or selection as a quoted lisp structure"
         qualifier: (fn (point ctl)
                       (not (blank? (-> (get_selection) `toString))))
         exec: (fn (point ctl event)
                  (progn
                     (if (not (blank? (-> (get_selection) `toString)))
                         (copy_text_to_clipboard (pretty_print (-> (get_selection) `toString)))
                         (copy_text_to_clipboard (pretty_print (-> ctl `get))))
                     (notify "Copied as quoted DOM to clipboard")))
     }
     on_blank:{
         on_event: `keyup
         key_sequence: "Backspace"
         control_menu: false
         handle_event: false
         qualifier: (fn (point ctl)
                       (progn
                          (defvar text (prop (-> ctl `get_root_element) `innerText))
                          (or (blank? text)
                              (== text "\n"))))
         exec: (fn (point ctl event)
                  (progn
                     (doc_exec `insertHTML "<div>Enter text!</div>")
                     (move_point `backward `character)
                     (select_node_at_point)))
     }
     insert_pre:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keyup
         control_menu: true
         context_menu: true
         description: "Inserts a <pre> element into the DOM buffer at the location of the cursor (point)."
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "```"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-P"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: false       ;; we don't care about handling the event
         
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are already in a pre
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     (doc_exec `insertHTML "<pre style='min-height: 2.4ch'></pre><div ><br></div>" true)
                     (move_to_point point)
                     (move_point `forward `character)))
         
     }
     ;; the next two rules implement the handling of newlines in the preformatted text node
     ;; the keydown acts to cancel the default behavior of the event 
     ;; the keyup then performs the correct newline behavior for insertion of newlines
     insert_return_in_pre_down:{
         on_event: `keydown   ;; intercept the enter key in PRE tags to ignore any action on Enter
         key_sequence: "Enter"
         control_menu: false
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                        (progn
                           (point_under_element_tag? "PRE" point)))
         handle_event: true
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_return_in_pre_up:{
         on_event: `keyup   ;; intercept the enter key in PRE tags to add a newline vs. a new element
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                       (progn
                          false))
         handle_event: true
         control_menu: false
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_header: {
         on_event: `keyup
         prior_text_sequence: "# "
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point)))
         handle_event: true
         remove_if_prior: true
         control_menu: true
         exec: (fn (point ctl event)
                  (progc
                     (let 
                        ((preceeding_text (aif (prop (get_text_around_point point) 0)
                                               (last (split_by " " it))
                                               ""))
                         (hash_details (first (scan_str (new RegExp "[#]+$") preceeding_text)))
                         (num_hashes (if hash_details
                                         (length (prop hash_details 0))
                                         0))
                         ;; add one because our rule triggered so it deleted one and the space
                         (tag_name (+ "H" (clamp (+ num_hashes 1) 1 5)))
                         (point nil))
                        
                        ;; since we have asked the editor to remove the matching text we are going to 
                        ;; remove the remaining and use that as a way to compute the Heading element we
                        ;; will add
                        (when (> num_hashes 0)
                           (for_each (c (range num_hashes))
                              (extend_from_point `backward `character))
                           (doc_exec `delete nil))
                        (doc_exec `insertHTML (+ "<" tag_name ">Heading</" tag_name ">"))
                        (move_point `backward `character)
                        (= point (point_for (-> ctl `get_root_element)))
                        (select_node_at_point)
                        )))
     }  
      insert_section:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keydown
         
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "%SCT"    
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-S"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: true       ;; we don't care about handling the event
         control_menu: true
         context_menu: true
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are in a pre tag
         description: "Inserts a details section into the DOM buffer at the cursor (point)"
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     (defvar insert_point point)
                     (doc_exec `insertHTML "<br><details tabindex=0 open><summary>Summary Text</summary><div>Detail Text</div></details>" true)
                     (move_to_point insert_point)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (select_node_at_point)
                     ))
     }
      insert_horizontal_rule:{
          on_event: `keyup
          handle_event: true
          control_menu: true
          context_menu: true
          remove_if_prior: true
          prior_text_sequence: "---"    ;; when three dashes 
          qualifier: (fn (point ctl)
                        (progn
                           (not (point_under_element_tag? "PRE" point))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      (doc_exec `insertHTML "<hr/>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
      insert_tab:{
          on_event: `keydown
          handle_event: true
          control_menu: false
          remove_if_prior: false
          key_sequence: "Tab"
          ;prior_text_sequence: ""    ;; when three dashes 
          qualifier: (fn (point ctl)
                        (progn
                           (point_under_element_tag? "PRE" point)))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      (if (point_under_element_tag? "PRE" point)
                          (doc_exec `insertText "\t"))
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
       wrap_text_in_code_tag:{
          on_event: `keydown
          handle_event: true
          control_menu: true
          context_menu: true
          key_sequence: "Ctrl-Alt-C"
          remove_if_prior: true
          description: "Wraps the selected text in a code tag."
          qualifier: (fn (point ctl)
                        (progn
                           (sleep 0.001)
                           (and (not (point_under_element_tag? "PRE" point))
                                (not (blank? (-> (get_selection) `toString))))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      
                      (defvar text (-> (get_selection) `toString))
                      (doc_exec `insertHTML (+ "<code>" text "</code>"))
                      (select_node_at_point)
                      (collapse_to_end (get_selection))
                      (move_point `forward `character)
                      ;(doc_exec `insertHTML "<code>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
   })

(defun_sync flex_row (`& args)
   (apply div { `style: "padding: 5px; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
          args)
   {
     `description: (+ "<br><br>Shorthand function for creating a flex element with a flex direction "
                      "row and justify-content to flex-start, align-items to the flex-start position. ")

   })


(defcontrol DOM_editor ()
   ((starter  (div { } "Enter text"))
    
    (root_elem (div { `contenteditable: true `tabindex: 0 }
                    starter))
    (document_view (div {  `class: "juno-editable" `style: "height: calc(100% - 0px); overflow: scroll; background: var(--editor-bg-color);  line-height: 1.5em; font-size: 1.1em;  padding: 5px; margin-top: 0px;margin-bottom: 0px"} 
                        root_elem))
       
    (position_elem (div { `style: "padding: 5px;color: darkblue;" } ))
    (depth_elem (div { `style: "padding: 5px; color: green;" } ))
    (path_elem (div { `style: "padding: 5px; " } ))
    (key_history_elem (div { `style: "padding: 5px;" }))
    (text_around_elem (div { `style: "padding: 5px;" }))
    (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" }
                               (if options.read_only
                                  "RO"
                                  "")))
    (status_elem (div { `style: "max-height: 40px; overflow: auto; border-bottom: 1px solid var(--main-accent-line-hover); padding: 5px; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
                      position_elem
                      depth_elem
                      path_elem
                      text_around_elem
                      key_history_elem))
    (debug_offset_height "55px")
    (debug_elem (div { `style: (+ " padding: 5px; overflow:scroll; height: calc(100% - " debug_offset_height ");") } ))
    (debug_container_elem (div { `style: "height: calc(100% - 10px); overflow: hidden;" }
                               status_elem
                               debug_elem))
    (sview (if options.debug
               (split_view_horizontal document_view  debug_container_elem)
               { 
                 `view: document_view 
                 }))
    (content_view (div { `style: "background: var(--control-bg-color); overflow: hidden; width: 100%; height: 100%;" }
                       sview.view))
    (on_resize (fn (self)
                  (progc
                     (= debug_offset_height (+ 45 (Math.max 5 control_status.offsetHeight)))
                     
                     (set_style [["height" (+ "calc(100% - " debug_offset_height "px)")]] debug_elem)
                     (if (not options.debug) 
                         (set_style [["height" (+ "calc(100% - " control_status.offsetHeight "px)")]] document_view))
                     )))
                     
    (rules nil) 
    (rule_set_name nil)
    (rules_menu [])
    (rules_context_menu [])
    (collection_timer nil)
    (key_sequence_rules { keyup: {} keydown: {} })
    (prior_text_rules { keyup: {} keydown: {} })
    (post_text_rules { keyup: {}  keydown: {} })
    (load_rule (fn (name rule)
                  (let
                     ((lookup_rule (+ { name: (or name "Unnamed Rule") `remove_if_prior: (or rule.remove_if_prior false) }
                                      (if (is_function? rule.qualifier)
                                         { `qualifier: rule.qualifier }
                                         {})
                                      { `text_sequence: rule.prior_text_sequence }
                                      (if (is_function? rule.exec)
                                          { `exec: rule.exec }
                                          { `exec: (eval `(fn ()
                                                             (notify (+ "Rule " ,#name " has no exec rule")))) })
                                      (if rule.handle_event
                                         { `handle_event: true }
                                         {})))
                      (rule_desc nil))
                     (when rule.prior_text_sequence
                        (make_path [ rule.on_event rule.prior_text_sequence ] prior_text_rules lookup_rule))
                     (when rule.key_sequence
                        (make_path [ rule.on_event rule.key_sequence ] key_sequence_rules lookup_rule))
                     
                     ;; if the rules are in a menu, see if they have a key sequence
                     (when (and (or rule.control_menu rule.context_menu)
                                rule.key_sequence)
                        (set_path [ rule_set_name name ] *key_bindings*
                                  {
                                    `description: (or rule.description "No Description")
                                    `exec: nil
                                    `mac: (or rule.key_sequence_mac rule.key_sequence)
                                    `win: (or rule.key_sequence_win rule.key_sequence)
                                  }))
                     (when (or rule.control_menu rule.context_menu)
                        (= rule_desc
                           [{ `text: (from_key name)
                                    `path: [ rule_set_name name ]
                                    `exec: (eval `(fn (e)
                                                     (try
                                                        (progn
                                                           (defvar rule ,#rule)
                                                           (defvar ctl_id ,#id)
                                                           (defvar ctl (get_control_by_id ctl_id))
                                                           (console.log "DOM_editor: load_rule: " ctl.options (get_by_id "body"))
                                                           (when (and ctl
                                                                      (prop  ctl `root_elem))
                                                              (focus_to (-> ctl `root_elem))
                                                              (defvar current_point (-> ctl `current_point))
                                                              (when current_point
                                                                 (move_to_point current_point))
                                                              (if (is_function? rule.qualifier)
                                                                  (if (rule.qualifier current_point ctl)
                                                                      (progn
                                                                         (rule.exec current_point ctl nil)))
                                                                  (rule.exec current_point ctl nil))))
                                                        (catch Error (e)
                                                           (progn
                                                              (log "dom_editor: load_rule: error on eval: " e.message)
                                                              (console.error "dom_editor: load_rule: error on eval: " e))))))
                                    } ])
                        (when rule.control_menu
                           (push rules_menu
                              rule_desc))
                        (when rule.context_menu
                           (push rules_context_menu
                              rule_desc))))))
    
    (load_rules (fn ()
                   (progn
                      (cond
                         (is_array? options.rules)
                         (= rules (resolve_path options.rules Environment.context.scope))
                         (is_function? options.rules)
                         (= rules (-> options `rules self)))
                      
                       (= rule_set_name (or rules.meta.name))
                       
                       (if (or (not (is_string? rule_set_name))
                               (blank? rule_set_name))
                           (notify "dom_editor: rules must have a meta object and name key to activate key shortcuts"))
                       
                       ;; make sure we have an entry in key bindings
                       ;; reset the path since the rules are sourced from the 
                       ;; provided object.  We will load keybindings with 
                       ;; the kes 
                       (set_path [ rule_set_name ] *key_bindings* {})
                       
                       ;; clear out our registries..
                       
                       (= rules_menu [])
                       (= rules_context_menu [])
                       (= key_sequence_rules { keyup: {} keydown: {} })
                       (= prior_text_rules { keyup: {} keydown: {} })
                       (= post_text_rules { keyup: {} keydown: {} })
                       
                       ;; and build up the rules...
                       (when rules
                          (for_each (pset (pairs rules))
                             (destructuring_bind (name rule)
                                pset
                                (unless (== name "meta")   ;; the meta rule is the description for the rule bundle and is not evaluated
                                   (load_rule name rule))))))))
    (active_rules (fn ()
                     prior_text_rules))
    (current_point nil)
    (last_event_context nil)
    (render (fn ()
               content_view))
    (set_filename (fn (fname)
                     (if (is_string? fname)
                         (progn
                            (set_prop options
                               `filename
                               fname)
                            (set_prop options
                               `path
                               (conj [ `filesystem ] (split_by "/" fname)))
                            (set_prop title_span
                               `innerText
                               (get_editor_file_basename self)))
                         (notify "Require a string for the filename"))))
    (save_as (fn ()
                (let
                   ((fname (wait_for_file_selection true)))
                   (when (not (blank? fname))
                      (set_filename fname)
                      (request_save)))))
    (on_focus (fn (self)
                (progc
                   (focus_to root_elem)
                   (when current_point
                      (move_to_point current_point)))))
    
               
    (process_rules_for_event (fn (event)
                                (let
                                   ((text (get_text_around_point current_point))
                                    (on_event event.type)
                                    (rule_result nil)
                                    (results [])
                                    (prior_text_sequence (or text.0 ""))
                                    (next_text_sequence text.1)
                                    (key_sequence (clone (key_history))))
                                   
                                   ;; spaces show up as character code 160, so we need to move it to space to make
                                   ;; any matches succeed that are terminated by a space
                                   ;; note that this could probably be changed in the get_text_around_point function
                                   ;; but that needs to be thought through...
                                   
                                   (when (and (is_string? text.0)
                                              (== (-> (last_n_chars 1 text.0) `charCodeAt) 160))
                                       (set_prop text 
                                          0
                                          (+ (chop text.0) " ")))
                                   
                                   ;; next find the rule to eval if any...
                                   ;; from the most specific to the least
                                   (for_each (n [ 3 2 1 ])
                                      (progn 
                                         (aif (resolve_path [ on_event (join " " (last_n n key_sequence)) ] key_sequence_rules)
                                              (when (= rule_result (qualify_and_run it `key_sequence event))
                                                 (push results rule_result)
                                                 (break)))))
                                   (for_each (n [ 4 3 2 1 ])
                                      (progc
                                         (when (>= (length text.0) n) 
                                            (aif (resolve_path [ on_event (last_n_chars n text.0) ] prior_text_rules)
                                                (when (= rule_result (qualify_and_run it `prior_text event))
                                                   (push results rule_result)
                                                   (break))))))
                                   rule_result)))
     ;; when a rule is identified by process_rules_for_event as matching
     ;; the qualify_and_run function will make check to see if it is qualified
     ;; to run and then run the rule 
    (qualify_and_run (fn (rule identified_by event)
                        (progc
                           (defvar qualified? 
                              (if (is_function? rule.qualifier)
                                  (-> rule `qualifier current_point self) ;; only run it if qualifier returns true
                                  true)) ;; otherwise default run it since no qualifier
                           (if qualified?
                              (progn
                                 (when rule.handle_event
                                    (handle_event event))
                                 (when (and rule.remove_if_prior
                                            (== identified_by "prior_text"))
                                    
                                    ;; remove the text that qualified it
                                    ;; however we can delete the complete element if we are at the same position (offset) 
                                    ;; in the current element being edited as the length of the text sequence to remove.
                                    (if (> current_point.position (length rule.text_sequence))
                                        (progn   ;; just extend the selection backward and remove the text..
                                           (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (= current_point (point_for root_elem)))
                                        (progn ;; in this case we will remove the whole node that contains the trigger text
                                               ;; so we need to move backward to the prior node so the rule works consistently.
                                            (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (move_point `backward `character)
                                           (= current_point (point_for root_elem)))))
                                 (when (== identified_by `key_sequence)
                                    (= key_history_acc []))
                                 ;; then call the rule!
                                 (try
                                    (-> rule `exec current_point self)
                                    (catch Error (e)
                                       (progn
                                          (log "dom_editor: caught error: " e.message e)
                                          (console.error "dom_editor: caught error on rule evaluation: " e.message e))))
                                 true)
                              false))))
    (key_history_acc [])
    (key_history_length 4)
    (key_history (function ()
                    key_history_acc))
    (is_dirty? false)
    (add_to_key_history (function (key)
                           (progn
                              (unless (contains? key (list "Shift" "Alt" "Ctrl" "Command")) ;; don't grab just the special key downs
                                 (push key_history_acc key)
                                 (while (> key_history_acc.length key_history_length)
                                    (take key_history_acc))))))
    (key_down_event (fn (event)
                       (progc
                          (let
                             ((status (point_for root_elem))
                              (key event.key))
                             
                             
                             (cond
                               
                                (and options.close_on_escape 
                                  (== key "Escape"))
                               (progn
                                  (log "DOM Editor:Escape pressed!")
                                  (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                               else
                               (progn
                                  (add_to_key_history (get_key_code event))
                                  (= last_event_context (process_rules_for_event event))
                                  (when (> __VERBOSITY__ 0) 
                                     (log "last_event_context: " last_event_context))
                                  key))))))
    
    (key_up_event (fn (event)
                      (progc
                         (let
                            ((status (point_for root_elem))
                             (key event.key)
                             (path_comps (for_each (c status.dom_path)
                                            (progn
                                               (if (== 1 c.nodeType)
                                                   c.tagName
                                                   "text")))))
                            (= current_point status)
                            (= last_event_context (process_rules_for_event event))
                            
                            (when (or (and (== key.length 1)
                                            (not event.metaKey)
                                            (not event.ctrlKey))
                                       (or (== key "Backspace")
                                           (== key "Enter")))
                                (when (not is_dirty?)
                                   (add_class "juno-needs-save" title_span))
                                (= is_dirty? true))
                            
                            (set_prop position_elem
                               `innerText
                               status.position)
                            (set_prop depth_elem
                               `innerText (length status.dom_path))
                            ;(-> path_elem `replaceChildren
                            ;  (div { } (join ":" (key_history))))
                            (set_prop key_history_elem
                               `innerText
                               (join ":" (key_history)))
                            (set_prop text_around_elem
                               `innerText
                               (join ":" (get_text_around_point status)))
                            (-> path_elem `replaceChildren
                               (div { } (for_each (name path_comps)
                                       (span {`style: "padding-right: 5px" } name))))
                            
                            (set_prop view
                               `scrollTop 0)      
                            (when collection_timer
                               (clearTimeout collection_timer))
                            (= collection_timer
                               (setTimeout
                                  (fn ()
                                     (progn
                                        (when (and (not options.path)
                                                   (not options.filename))
                                           (= is_dirty? false)
                                           (remove_class "juno-needs-save" title_span)
                                           (set_prop options
                                              `content
                                              (element_to_lisp root_elem { use_ns: `html } )))))
                                  1000))
                               
                            (-> debug_elem `replaceChildren
                               (pre (pretty_print (element_to_lisp root_elem))))
                            ))))
    (control_bar_elements [ locked_span ])
    (cut_selection (fn ()
                      (let
                         ((selection (get_selection))
                          (selrange (-> selection `getRangeAt 0))
                          (copytext (-> selrange `toString)))
                         (when (not (blank? copytext))
                            (-> navigator.clipboard `writeText copytext)
                            (doc_exec `delete nil)))))
    (copy_selection (fn ()
                       (let
                          ((selection (get_selection))
                           (selrange (-> selection `getRangeAt 0))
                           (copytext (-> selrange `toString)))
                          (when (not (blank? copytext))
                             (-> navigator.clipboard `writeText copytext)))))
    
    (paste_selection (fn ()
                        (let
                           ((text (-> navigator.clipboard `readText)))
                           (notify "Pasting text")
                           (doc_exec `insertText text))))
    (request_save (function ()
                        (progn
                           (if (or options.path options.filename)
                              (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] })
                              (-> self `on_save_complete)))))
    (nseval (if (not (blank? options.path_namespace))   
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))
    (menu_items (fn ()
                   (conj rules_menu
                      [["Copy contents as Lisp Structure" (fn (e) (copy_text_to_clipboard (pretty_print (as_lisp (-> self `get)))))]
                       (if options.filename
                          [(+ "Save " (get_editor_file_basename self)) (fn (e) (request_save))]
                          [])
                       ["Save as..." (fn (e) (save_as)) ]
                       (if options.read_only
                                [ (dtext "Allow Editing" ) (fn () (-> self `set_read_only false)) ]
                                [ (dtext "Set Read-Only Mode") (fn () (-> self `set_read_only true)) ])])))
    (set_name (fn (new_name force)
                 (progn
                    (when (and (not (blank? new_name))
                               (not (== (get_control_by_name new_name) self)))
                       (set_prop options
                          `name
                          (if force
                             new_name
                             (compute_name_for_control new_name)))
                       (set_prop self
                          `name
                          options.name)
                       (dispatch_event { command: "editor_change"
                                         source: self.id
                                         args: [ { `option: "name" `value: options.name } ] }))
                    (set_prop title_span
                       `innerText
                       options.name)
                    options.name)))
    (check_for_unhandled_elements (fn (elem)
                                     (let
                                        ((elem_type nil))
                                        (cond
                                           (is_element? elem)
                                           (progn
                                              (= elem_type elem.tagName)
                                              (cond
                                                 (and (== elem_type "IMG")
                                                      (not (get_attribute elem "_handled")))
                                                 (progn
                                                    (set_attribute elem "_handled" "true")
                                                    (wrap_in_resizable elem))
                                                 else
                                                 (when (> elem.children.length 0)
                                                    (for_each (c elem.children)
                                                       (check_for_unhandled_elements c)))))))))
    (saved_content nil)
    (set_read_only (fn (read_only?)
                              (progn
                                 (set_prop options
                                    `read_only
                                    read_only?)
                                 (if read_only?
                                    (progc
                                       (= saved_content (element_to_lisp root_elem))
                                       (log (pretty_print saved_content))
                                       (remove_attribute root_elem `contenteditable)
                                       (set_prop locked_span
                                          `innerText
                                          (dtext "RO")))
                                    (progc
                                       (when saved_content
                                          (log (pretty_print saved_content))
                                          (set_prop saved_content.1
                                             `contenteditable true)
                                          (-> root_elem `replaceWith (eval saved_content))
                                          (= root_elem document_view.children.0)
                                          (check_for_unhandled_elements root_elem)
                                          (focus_to root_elem)
                                          ;(set_attribute root_elem `contenteditable true)
                                          (set_prop locked_span
                                             `innerText
                                             (dtext ""))))))))
    (error_state false)      
    (on_destroy (fn ()
                                                   (progn
                                   (cond
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" } 
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         response)
                                      else
                                      true))))
    (init_context_menu (fn ()
                          (attach_context_menu
                             content_view
                             (fn (event)
                                (let
                                   ()
                                   (conj rules_context_menu
                                      (if (> rules_context_menu.length 0)
                                          [["--" nil]]
                                          [])
                                      [
                                       (if (is_clipboard_allowed?)
                                           [{
                                              text: "Cut"
                                              path: [`global `cut ]
                                              exec: cut_selection }]
                                           [])
                                       (if (is_clipboard_allowed?)
                                           [{
                                              text: "Copy"
                                              path: [`global `copy ]
                                              exec: copy_selection
                                              }]
                                           [])
                                       (if (is_clipboard_allowed?)
                                           [ {
                                               text: "Paste"
                                               path: [`global `paste ]
                                               exec: paste_selection }]
                                           [])
                                       ]))))))
    (on_initialize (fn ()
                      (progc
                         (let
                            ((remote_content nil)
                             (is_fresh false)
                             (load_error false)
                             (extension nil))
                            
                            (cond
                               options.filename
                               (progn
                                  (try
                                     (progn
                                        (= remote_content (fetch (+ "/files/" options.filename)))
                                        (cond
                                           (== remote_content.status 200)
                                           (progn
                                              (= remote_content (-> remote_content `text))
                                              (when options.on_load
                                                 (try
                                                    (= remote_content (-> options `on_load remote_content self))
                                                    (catch Error (e)
                                                       (progn
                                                          (alert_box "Invalid Content"
                                                                     (+ "Cannot mount content: " e.message))
                                                          (= load_error true))))))
                                           (== remote_content.status 404)
                                           (progn
                                              (= remote_content "")
                                              (notify (+ "New file: " options.filename))
                                              (= is_fresh true)
                                              (when options.on_load
                                                 (try
                                                    (= remote_content (-> options `on_load nil self))
                                                    (catch Error (e)
                                                       (progn
                                                          (alert_box "Invalid Content"
                                                                     (+ "Cannot mount content: " e.message))
                                                          (= load_error true))))))
                                           remote_content
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": " remote_content.statusText))
                                           else
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": received nil response from the fetch operation.")))
                                        (set_filename options.filename)
                                        ;(log "remote_content: " remote_content)
                                        (when (and remote_content (not is_fresh))
                                           (= remote_content (eval (JSON.parse remote_content)))
                                           (-> root_elem `replaceWith remote_content)
                                           (= root_elem document_view.children.0)))
                                     (catch Error (e)
                                        (progn
                                           (log "DOM_editor: cannot set remote content: " remote_content)
                                           (alert_box (+ "Unable to open: " options.filename " - " e.message))
                                           (= error_state true)))))
                               (is_array? options.path)
                               (progn
                                  (defvar content (resolve_path options.path nseval.global_ctx.scope))
                                  (if (eq nil content)
                                      (progn
                                         (= content (or options.content
                                                        starter))
                                         (= is_fresh true)
                                         (make_path options.path nseval.global_ctx.scope root_elem))
                                      (progn
                                         (when (not (is_element? content))
                                            (= content (try
                                                          (eval content)
                                                          (catch Error (e)
                                                             (progn
                                                                (alert_box "Evaluation Error"
                                                                           (+ "The content cannot be read: " e.message ".  Please check the source."))
                                                                (= error_state true))))))
                                         (-> root_elem `replaceWith content)
                                         (= root_elem document_view.children.0))))
                               options.content
                               (progn
                                  (defvar tmp (if (is_element? options.content)
                                                  options.content
                                                  (eval options.content)))
                                  (if (and (is_array? options.content)
                                           (== (length options.content) 0))
                                      (= is_fresh true))
                                      
                                  (when (is_element? tmp)
                                     (-> root_elem `replaceWith tmp)
                                     (= root_elem document_view.children.0))))
                            
                            (set_name (cond
                                         (and (is_string? options.name)
                                              (not (== "DOM Editor" options.name))) ;;
                                         options.name
                                         (is_array? options.path)
                                         (last options.path)
                                         else
                                         "Untitled"))
                            
                            ;; load_rules will setup the mapping between 
                            ;; the provided rule set for the editor and 
                            ;; the key bindings and menus
                                          
                            (try
                               (load_rules)
                               (catch Error (e)
                                  (log "Error on load_rules: " e.message)))
                            ;(log "loaded rules: key_sequence_rules: " key_sequence_rules)
                            ;(log "loaded rules: prior_text_rules: " prior_text_rules)
                            
                            
                            (attach_event_listener content_view
                               `keyup
                               (fn (e) (key_up_event e)))
                            
                            (attach_event_listener content_view
                               `keydown
                               (fn (e)
                                  (key_down_event e)))
                            (if options.read_only
                                (set_read_only true))
                            
                            (attach_event_listener content_view
                               `paste
                               (fn (e)
                                  (progc
                                     (log "new paste event: " 
                                        (object_methods e.clipboardData)
                                        e.clipboardData.types)
                                     (setTimeout (fn ()
                                                    (check_for_unhandled_elements root_elem))
                                                 50))))
                                  
                            (init_context_menu)
                                       
                            (progc
                               (set_attribute root_elem
                                  `tabindex 0))
                            ;(set_style [["height" "100%"]] root_elem)
                            (set_style [["overflow" "hidden"] [ "height" "calc(100% - 2px);"]] view)
                            (if options.hide_control_bar
                               (-> self `show_control_bar false))
                            
                            (check_for_unhandled_elements root_elem)
                            (log "DOM_Editor: options: " options)
                            (setTimeout (fn ()
                                           (progn
                                              (cond
                                                 error_state  ;; unable to initialize - so remove ourselves
                                                 (destroy_control self)
                                                 (and (or options.content
                                                          options.filename)
                                                      (not is_fresh))
                                                 (progn
                                                    (log "selecting root elem")
                                                    (select_element root_elem)
                                                    (collapse_to_start (get_selection)))
                                                 else
                                                 (progn
                                                    (log "Selecting starter")
                                                    (select_element starter)))))
                                        100))))))
   {
       control_bar: true
       expose: [[`active_rules active_rules]
                [`reload_rules load_rules]
                [`save request_save]
                [`copy_selection copy_selection]
                [`cut_selection cut_selection]
                [`paste_selection paste_selection]
                [`current_point (fn ()
                                   current_point) ]
                [`editor {} ]  ;; just to indicate we are an editor type component
                [`get (fn ()
                         (element_to_lisp root_elem)) ]
                [`root_elem (fn ()
                               root_elem) ]
                [`set_read_only  set_read_only]
                [`needs_save? (function ()
                                 is_dirty?)]
                [`on_save_complete (function (event_obj)
                                      (progn
                                         (remove_class "juno-needs-save" title_span)
                                         (= is_dirty? false)))]
                [`get_root_element (fn () root_elem)]]
   })




(defun wrap_in_resizable (elem)
   (let
      ((move_state nil)
       (just_enable (== (get_attribute elem.parentElement "initializer") "wrap_in_resizable"))
       (expander_elem (if just_enable
                          elem.parentElement.children.1
                          (div { `style: "position: absolute; right: 0px; bottom: -10px; width: 15px; height: 15px; cursor: nwse-resize; background: tranparent;" }
                           "")))
                          
       (full_block (div { `style: "z-index: 8; width: 100%; height: 100%; position: absolute; top:0px; left: 0px;" }))
       (dims nil)
       (resize_mode false)
       (elem_dims {
           `width: elem.offsetWidth
           `height: elem.offsetHeight
       })
       (initial_ratio (/ elem.offsetWidth elem.offsetHeight))
       (max_dims {
                  `width: 0
                  `height: 0
                  })
       (body_element nil)
       
       (block_on (fn (e)
                    (progn
                       (= dims (-> frame `getBoundingClientRect))
                       (= body_element (get_by_id "body"))
                       (= max_dims {
                                     `width: (prop body_element `offsetWidth)
                                     `height: (prop body_element `offsetHeight) })
                       (-> body_element `appendChild full_block)
                       (= move_state {
                                       mx: e.pageX
                                       my: e.pageY
                                       fx: dims.right
                                       fy: dims.top
                                       w: dims.width
                                       h: dims.height
                                       }))))
       
       (end_drag (fn (e)
                    (progn
                       (= move_state nil)
                       (= resize_mode false)
                       (if (is_function? elem.resize)
                           (-> elem `resize))
                       (-> full_block `remove))))       
       (handle_drag (fn (e)
                      (when (and move_state
                                 (== e.buttons 1))
                         (when resize_mode
                            (set_style [["height" (+ "" (Math.min (- max_dims.height 30) (+ dims.height (- e.pageY move_state.my))) "px")]]
                                       frame)
                            (set_style [["width" (+ "" (* initial_ratio frame.offsetHeight) "px") ]] frame)
                            (set_style [["height" (+ "" frame.offsetHeight "px")]
                                        ["width" (+ "" frame.offsetWidth "px") ]] elem)
                            ))))
                                   
       (frame (if just_enable
                  elem.parentElement
                  (div { `initializer: "wrap_in_resizable" `class: "juno-shadow-on-hover" `style: (+ "padding: 0px;position: relative; display: inline-block; border: 1px solid transparent; width:" elem_dims.width "px; height: " elem_dims.height "px;") }))))
      
     
      (attach_event_listener expander_elem
         `mousedown
         (fn (e)
            (progn
               (= resize_mode true)
               (block_on e))))
      
      
      (attach_event_listener full_block
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mousemove
                             handle_drag)
      (attach_event_listener full_block
                             `mousemove
                             handle_drag)
      
      ;; if we have a control, initialize it if it needs it since it is 
      ;; now mounted on the DOM
      (set_style [["position" "relative"]
                  ["display" "inline-block"]] frame)
      (unless just_enable
         (-> elem `replaceWith frame)
         (-> frame `append elem)
         (-> frame `append expander_elem))
      true)
   {
     `description: (+ "<br><br>Given an element, will wrap it in a resizable element that preserves "
                      "aspect ratio. The provided element will be replaced with the wrapped element.  "
                      "The element will have a transparent handle on the lower right side that when "
                      "hovered over, will indicate that the element can be resized. ")

       `usage: ["element:Element"]
       `tags: ["DOM" "element" "UI" "resize" ]
   })
   
(create_css_entry ".juno-shadow-on-hover:hover"
   (from_style_text "box-shadow: 2px 3px 8px 0px #00000040;border-color: var(--main-accent-line-hover);"))      

(create_css_entry ".juno-shadow-on-hover"
   (from_style_text "border: 1px solid transparent;"))      


(defun DOM_to_markdown (quoted_dom _acc _ctx)
   (let
      ((acc (or _acc []))
       (ctx (new_ctx _ctx))
       (process_children (fn (children)
                            (progn
                               (for_each (child (or children []))
                                  (DOM_to_markdown child acc ctx)))))
       (tag nil))
      ;(log "DOM_to_markdown: " (getf_ctx ctx `tag) (getf_ctx ctx `in_pre))
      (cond
         (is_array? quoted_dom)
         (progn
            (= tag (if (is_reference? (first quoted_dom))
                       (first quoted_dom)
                       nil))
            (if (not (eq nil ctx.parent))
                (= ctx (new_ctx ctx)))
            (setf_ctx ctx `tag tag)
            ;(log "quoted_dom: " (is_reference? (first quoted_dom)) (getf_ctx ctx `tag) (pretty_print quoted_dom))
            
            ;; below are the rules to encode or handle certain elements in specific ways
            (cond
               (and tag
                  (== tag (quote div)))
               (progn 
                  (unless (or (blank? (prop quoted_dom 2))
                              (and (is_string? (prop quoted_dom 2))
                                   (blank? (trim (prop quoted_dom 2)))))
                     ;(log "DOM to markdown: " (pretty_print quoted_dom))
                     (push acc "<br>")
                     (process_children (rest quoted_dom)))
                  ;(push acc "<br>")
                  )
               (and tag
                  (== tag (quote pre)))
               (progn
                  (setf_ctx ctx `in_pre true)
                  ;(log "pre: " (pretty_print quoted_dom))
                  (defvar higher_acc acc)
                  (= acc [])
                  (push acc "```")
                  (process_children (rest quoted_dom))
                  (push acc "```<br>")
                  (push higher_acc (join "" acc))
                  (= acc higher_acc))
               (and tag
                  (== tag (quote hr))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (push acc "<br>---<br>"))
               (and tag
                  (starts_with? (+ "=:" "h") tag)
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (defvar higher_acc acc)
                  (= acc [])
                  (push acc (+ "<br>" 
                               (join "" (for_each (r (range (int (-> tag `substr 3))))
                                                                                      "#"))))
                  (process_children (rest quoted_dom))
                  (push acc "<br>")
                  (push higher_acc (join " " acc))
                  (= acc higher_acc))
               (and tag
                  (== tag (quote p))
                  (is_object? (second quoted_dom))
                  (blank? (prop quoted_dom 2))
                  (not (getf_ctx ctx `in_pre)))
               true ; ignore blank paragraphs 
               (and tag
                  (== tag (quote code))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (unless (blank? (prop quoted_dom 2))
                     (push acc (+ "`" (prop (eval quoted_dom) `innerText) "`"))))
             
               else  
               (process_children (rest quoted_dom))))
         (is_string? quoted_dom)
         (progn
            ;(log "adding from " (getf_ctx ctx `tag) quoted_dom)
            (push acc quoted_dom)))
      acc))
      
      



(place_control `right (DOM_editor { rules: [ `*markdown_rules* ] `filename: "doc/test_1." `hide_control_bar: false debug: false }))

(place_control `right (DOM_editor { rules: [ `*markdown_rules* ] `filename: "working/looper.lisp" `hide_control_bar: false debug: true }))


(place_control `right (DOM_editor { rules: [ `*markdown_rules* ] `path: [ `*dom_buf* ] `hide_control_bar: false debug: true }))

(place_control `right (DOM_editor { rules: [ `*markdown_rules* ] `path: [ `*dom_buf2* ] `hide_control_bar: false debug: true }))

*dom_buf*
*markdown_rules*