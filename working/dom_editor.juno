
(create_css_entry ".juno-editable div:focus"
  [[`outline `none]])
          
(defmacro progc (`& forms)
   `(try
       (progn
          ,@forms)
       (catch Error (e)
          (log e.message)))
   {
       `description: (+ "This macro wraps the provided forms in a "
                        "try-catch, and returns the last value if "
                        "no errors, like progn, or if an error "
                        "occurs, logs to the console.  Simple "
                        "help for debugging.")
       `tags: ["debug" "error" "catch" "handler" "progn" "eval"]
       `usage: ["forms:*"]
   })

(defun_sync reverse_string (text)
   (join "" (-> (split_by "" text) `reverse))
   {
       description: "Given a string, returns the characters in reverse order."
       usage: ["text:string"]
       tags: ["string" "text" "reverse" "modify" ]
   })

(defun_sync last_n_chars (n text)
   (if (is_string? text)
       (-> text `substr (* -1 n))
       nil)
   {
       description: "For a given string, returns the last n characters as a string."
       usage: ["n:number" "text:string"]
       tags: ["string" "text" "last" "amount" "end" "tail"]
   })

(defun_sync last_n (n arr)
   (if (is_array? arr)
       (-> arr `slice (* -1 n))
       nil)
   {
       description: "For a given array, returns the last n elements as an array."
       usage: ["n:number" "arr:array"]
       tags: ["array" "list" "text" "last" "amount" "end" "tail"]
   })
                          
;; verbs for our editing command language

(defmacro get_selection ()
   `(-> window `getSelection))

(defun_sync get_range (selection index)
   (if selection
      (-> selection `getRangeAt (or index 0))
      (progn
         (log "selection is nil")
         nil)))

(defmacro remove_all_ranges (selection)
   `(-> ,#selection `removeAllRanges))

(defmacro collapse_to_start (selection)
   `(-> ,#selection `collapseToStart))

(defmacro collapse_to_end (selection)
   `(-> ,#selection `collapseToEnd))

(defun_sync select_element (elem)
   (progn
      (defvar sel (get_selection))
      (if sel
         (-> sel `selectAllChildren elem)
         (progn
            (log "unable to get_selection for " (element_to_lisp elem))
            nil))))

(defun_sync move_to_point (point_obj)
   (progc
      (when point_obj.selection
         (focus_to (if (== point_obj.pos_type 1)
                       point_obj.pos_node
                       point_obj.pos_node.parentElement))
         (defvar selection (get_selection))
         (remove_all_ranges selection)
         (-> selection `addRange point_obj.range))))
         
(defun_sync move_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `move dir (or granularity "character"))))))

(defun_sync extend_from_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `extend dir (or granularity "character"))))))

(defun point_for (root_element)
   (let
      ((selection (get_selection))
       (selrange (get_range selection))
       (selected_node selrange.startContainer)
       (offset selrange.startOffset)
       (position (progn
                    (if (== selrange.startContainer.nodeType 3)
                        (progn
                           (get_cursor_position selrange.startContainer.parentElement))
                        selrange.endOffset)))
       (current_element selected_node)
       (path []))
      (while (and (not (eq current_element nil))
                  (not (== current_element root_element)))
         (progn
            (prepend path current_element)
            (= current_element current_element.parentElement)))
      { dom_path: path
        position: position
        pos_type: selected_node.nodeType
        pos_node: selected_node
        selection: selection
        range: selrange
        }))

(defun_sync select_node_at_point ()
   (let
      ((selection (get_selection))
       (selrange (get_range selection)))
      (if (== selrange.startContainer.nodeType 3)
         (-> selection `selectAllChildren selrange.startContainer.parentElement)
         (-> selection `selectAllChildren selrange.startContainer))))
       
      
(defun_sync get_text_around_point (point)
   (let
      ((text [])
       (elem nil))
      (progc
         (when point
            (cond 
               (== point.pos_type 1)
               (progn
                  (= elem point.pos_node))
               (== point.pos_type 3)
               (progn
                  (= elem point.pos_node.parentElement))))
         (when elem
            (push text
               (-> elem.innerText `substr 0 point.position))
            (push text
               (-> elem.innerText `substr point.position)))
         text))
   {
       description: (+ "Given a point object,returns an array that can "
                       "contain up to two strings.  The first value, at position "
                       "0, is the element text pior to the point's position. "
                       "The second value is the text of the element after "
                       "the point's position.")
       usage: ["point_object:object"]
       tags: ["DOM" "point" "edit" "selection" "editor" "select"]
   })
         
            
               
(defun_sync point_tag_path (point)
   (for_each (c point.dom_path)
      (progn
         (if (== 1 c.nodeType)
             c.tagName
             "text")))
   {
       `description: "Given a point object, returns the tag names that comprise the path to the point."
       `usage: ["point:object"]
       `tags: ["point" "editor" "DOM" "selection" "select"]
   })



(defun insert_elem_at_point (elem under_root)
      (try
         (let
            ((selection (get_selection))
             (selrange (-> selection `getRangeAt 0))
             (parent_element (if (== selrange.startContainer.nodeType 3)  ;; text node
                                 selrange.startContainer.parentElement
                                 selrange.startContainer))
             (offset selrange.startOffset)
             (remaining_text nil))
            ;; extend it from the current point
            
            (-> selrange `setEndBefore parent_element.nextSibling)
            (= remaining_text (-> selrange `toString))
            (-> selection `deleteFromDocument)
            (= selection (get_selection))
            (remove_all_ranges selection)
            (-> selection `addRange selrange)
            (-> parent_element `append elem remaining_text)
            (collapse_to_start selection))
         (catch Error (e)
            (log (+ "ERROR: insert_elem_at_point:" e.message)))))


(defun_sync point_under_element_tag? (tag_name point)
   (contains? tag_name (point_tag_path point))
   {
       description: (+ "Returns true if the provided editor point is in a "
                        "DOM tree containing the provided tagname, otherwise false.")
       usage: ["tag_name:string" "point:object"]
       tags: ["editor" "point" "cursor" "DOM" "tree" "element"]
   })

(defparameter *markdown_rules*
   {
     reload_rules:{
         on_event: `keydown
         key_sequence: "Alt-L"
         handle_event: true
         menu: true
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (notify (+ "Reloading Markdown Rules: " ctl.name))
                     (-> ctl `reload_rules)))
         
     }
     
     on_blank:{
         on_event: `keyup
         key_sequence: "Backspace"
         menu: false
         handle_event: false
         qualifier: (fn (point ctl)
                       (progn
                          (defvar text (prop (-> ctl `get_root_element) `innerText))
                          (or (blank? text)
                              (== text "\n"))))
         exec: (fn (point ctl event)
                  (progn
                     (doc_exec `insertHTML "<div>Enter text!</div>")
                     (move_point `backward `character)
                     (select_node_at_point)))
     }
     insert_pre:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keyup
         menu: true
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "```"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-P"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: false       ;; we don't care about handling the event
         
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are already in a pre
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     ;(move_to_point point)
                     (doc_exec `insertHTML "<pre style='min-height: 2.4ch;'></pre><div ><br></div>" true)
                     (move_to_point point)
                     (move_point `forward `character)))
         
     }
     ;; the next two rules implement the handling of newlines in the preformatted text node
     ;; the keydown acts to cancel the default behavior of the event 
     ;; the keyup then performs the correct newline behavior for insertion of newlines
     insert_return_in_pre_down:{
         on_event: `keydown   ;; intercept the enter key in PRE tags to ignore any action on Enter
         key_sequence: "Enter"
         menu: false
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                        (progn
                           (point_under_element_tag? "PRE" point)))
         handle_event: true
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_return_in_pre_up:{
         on_event: `keyup   ;; intercept the enter key in PRE tags to add a newline vs. a new element
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                       (progn
                          false))
         handle_event: true
         menu: false
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_header: {
         on_event: `keyup
         prior_text_sequence: "# "
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point)))
         handle_event: true
         remove_if_prior: true
         menu: true
         exec: (fn (point ctl event)
                  (progc
                     (let 
                        ((preceeding_text (aif (prop (get_text_around_point point) 0)
                                               (last (split_by " " it))
                                               ""))
                         (hash_details (first (scan_str (new RegExp "[#]+$") preceeding_text)))
                         (num_hashes (if hash_details
                                         (length (prop hash_details 0))
                                         0))
                         ;; add one because our rule triggered so it deleted one and the space
                         (tag_name (+ "H" (clamp (+ num_hashes 1) 1 5)))
                         (point nil))   
                        
                        ;; since we have asked the editor to remove the matching text we are going to 
                        ;; remove the remaining and use that as a way to compute the Heading element we
                        ;; will add
                        (when (> num_hashes 0)
                           (for_each (c (range num_hashes))
                              (extend_from_point `backward `character))
                           (doc_exec `delete nil))
                        (doc_exec `insertHTML (+ "<" tag_name ">Heading</" tag_name ">"))
                        (move_point `backward `character)
                        (= point (point_for (-> ctl `get_root_element)))
                        (select_node_at_point)
                        )))
     }  
      insert_section:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keydown
         
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "%SCT"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-S"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: true       ;; we don't care about handling the event
         menu: true
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are in a pre tag
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     (defvar insert_point point)
                     (doc_exec `insertHTML "<br><details tabindex=0 open><summary>Summary Text</summary>Detail Text</details>" true)
                     (move_to_point insert_point)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (select_node_at_point)
                     ))
     }
      insert_horizontal_rule:{
          on_event: `keyup
          handle_event: true
          menu: true
          remove_if_prior: true
          prior_text_sequence: "---"    ;; when three dashes 
          qualifier: (fn (point ctl)
                        (progn
                           (not (point_under_element_tag? "PRE" point))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      (doc_exec `insertHTML "<hr/>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
   })

(defun_sync flex_row (`& args)
   (apply div { `style: "padding: 5px; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
          args))


(defcontrol DOM_editor ()
   ((starter  (div { } "Start Typing!"))
    (root_elem (div { `contenteditable: true `tabindex: 0 }
                    starter))
    (document_view (div {  `class: "juno-editable" `style: "height: calc(100% - 5px); overflow: scroll; background: var(--editor-bg-color);  line-height: 1.5em; font-size: 1.1em;  padding: 5px; margin-top: 0px;margin-bottom: 0px"} 
                        root_elem))
        
    (position_elem (div { `style: "padding: 5px;color: darkblue;" } ))
    (depth_elem (div { `style: "padding: 5px; color: green;" } ))
    (path_elem (div { `style: "padding: 5px; " } ))
    (key_history_elem (div { `style: "padding: 5px;" }))
    (text_around_elem (div { `style: "padding: 5px;" }))
    (status_elem (div { `style: "border-bottom: 1px solid var(--main-accent-line-hover); padding: 5px; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
                      position_elem
                      depth_elem
                      path_elem
                      text_around_elem
                      key_history_elem))
    (debug_offset_height "10px")
    (debug_elem (div { `style: (+ " padding: 5px; overflow:scroll; height: calc(100% - " debug_offset_height ");") } ))
    (debug_container_elem (div { `style: "height: calc(100% - 10px); overflow: hidden;" }
                               status_elem
                               debug_elem))
    (sview (if options.debug
               (split_view_horizontal document_view  debug_container_elem)
               { 
                 `view: document_view 
                 }))
    (content_view (div { `style: "background: var(--control-bg-color); overflow: hidden; width: 100%; height: 100%;" }
                       sview.view))
    (rules nil) 
    (rules_menu [])
    (collection_timer nil)
    (key_sequence_rules { keyup: {} keydown: {} })
    (prior_text_rules { keyup: {} keydown: {} })
    (post_text_rules { keyup: {}  keydown: {} })
    (load_rule (fn (name rule)
                  (let
                     ((lookup_rule (+ { name: (or name "Unnamed Rule") `remove_if_prior: (or rule.remove_if_prior false) }
                                      (if (is_function? rule.qualifier)
                                         { `qualifier: rule.qualifier }
                                         {})
                                      { `text_sequence: rule.prior_text_sequence }
                                      (if (is_function? rule.exec)
                                          { `exec: rule.exec }
                                          { `exec: (eval `(fn ()
                                                             (notify (+ "Rule " ,#name " has no exec rule")))) })
                                      (if rule.handle_event
                                         { `handle_event: true }
                                         {}))))
                     (when rule.prior_text_sequence
                        (make_path [ rule.on_event rule.prior_text_sequence ] prior_text_rules lookup_rule))
                     (when rule.key_sequence
                        (make_path [ rule.on_event rule.key_sequence ] key_sequence_rules lookup_rule))
                     (when rule.menu
                        (push rules_menu
                           [(from_key name)
                            (eval `(fn (e)
                                      (progn
                                         (defvar rule ,#rule)
                                         (when (prop *last_focus* `root_elem)
                                            (focus_to (-> *last_focus* `root_elem))
                                            (defvar current_point (-> *last_focus* `current_point))
                                            (log "current_point: " current_point)
                                            (when current_point
                                               (move_to_point current_point))
                                            (if (is_function? rule.qualifier)
                                                (if (rule.qualifier current_point *last_focus*)
                                                    (rule.exec current_point *last_focus* nil))
                                                (rule.exec current_point *last_focus* nil))))))])))))
                                   
    (load_rules (fn ()
                   (progn
                      (cond 
                         (is_array? options.rules)
                         (= rules (resolve_path options.rules Environment.context.scope))
                         (is_function? options.rules)
                         (= rules (-> options `rules self)))
                      (= rules_menu [])
                      (= key_sequence_rules { keyup: {} keydown: {} })
                      (= prior_text_rules { keyup: {} keydown: {} })
                      (= post_text_rules { keyup: {} keydown: {} })
                      (when rules
                         (for_each (pset (pairs rules))
                            (destructuring_bind (name rule)
                               pset
                               (load_rule name rule)))))))
    (active_rules (fn ()
                     prior_text_rules))
    (current_point nil)
    (last_event_context nil)
    (render (fn ()
               content_view))
    (set_filename (fn (fname)
                     (if (is_string? fname)
                         (progn
                            (set_prop options
                               `filename
                               fname)
                            (set_prop options
                               `path
                               (conj [ `filesystem ] (split_by "/" fname)))
                            (set_prop title_span
                               `innerText
                               (get_editor_file_basename self)))
                         (notify "Require a string for the filename"))))
    (save_as (fn ()
                (let
                   ((fname (wait_for_file_selection true)))
                   (when (not (blank? fname))
                      (set_filename fname)
                      (request_save)))))
    (on_focus (fn (self)
                (progc
                   (focus_to root_elem)
                   (when current_point
                      (move_to_point current_point)))))
                      
               
    (process_rules_for_event (fn (event)
                                (let
                                   ((text (get_text_around_point current_point))
                                    (on_event event.type)
                                    (prior_text_sequence (or text.0 ""))
                                    (next_text_sequence text.1)
                                    (key_sequence (clone (key_history))))
                                   
                                   ;; spaces show up as character code 160, so we need to move it to space to make
                                   ;; any matches succeed that are terminated by a space
                                   ;; note that this could probably be changed in the get_text_around_point function
                                   ;; but that needs to be thought through...
                                   
                                   (when (and (is_string? text.0)
                                              (== (-> (last_n_chars 1 text.0) `charCodeAt) 160))
                                       (set_prop text 
                                          0
                                          (+ (chop text.0) " ")))
                                   
                                   ;; next find the rule to eval if any...
                                   ;; from the most specific to the least
                                   (for_each (n [ 3 2 1 ])
                                      (progn 
                                         (aif (resolve_path [ on_event (join " " (last_n n key_sequence)) ] key_sequence_rules)
                                              (when (qualify_and_run it `key_sequence event)
                                                 (break)))))
                                   (for_each (n [ 4 3 2 1 ])
                                      (progc
                                         (when (>= (length text.0) n) 
                                            (aif (resolve_path [ on_event (last_n_chars n text.0) ] prior_text_rules)
                                                (when (qualify_and_run it `prior_text event)
                                                   (break)))))))))
     ;; when a rule is identified by process_rules_for_event as matching
     ;; the qualify_and_run function will make check to see if it is qualified
     ;; to run and then run the rule 
    (qualify_and_run (fn (rule identified_by event)
                        (progc
                           (defvar qualified? 
                              (if (is_function? rule.qualifier)
                                  (-> rule `qualifier current_point self) ;; only run it if qualifier returns true
                                  true)) ;; otherwise default run it since no qualifier
                           (if qualified?
                              (progn
                                 (when rule.handle_event
                                    (handle_event event))
                                 (when (and rule.remove_if_prior
                                            (== identified_by "prior_text"))
                                    
                                    ;; remove the text that qualified it
                                    ;; however we can delete the complete element if we are at the same position (offset) 
                                    ;; in the current element being edited as the length of the text sequence to remove.
                                    (if (> current_point.position (length rule.text_sequence))
                                        (progn   ;; just extend the selection backward and remove the text..
                                           (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (= current_point (point_for root_elem)))
                                        (progn ;; in this case we will remove the whole node that contains the trigger text
                                               ;; so we need to move backward to the prior node so the rule works consistently.
                                            (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (move_point `backward `character)
                                           (= current_point (point_for root_elem)))))
                                 (when (== identified_by `key_sequence)
                                    (= key_history_acc []))
                                 ;; then call the rule!
                                 (-> rule `exec current_point self)
                                 true)
                              false))))
    (key_history_acc [])
    (key_history_length 4)
    (key_history (function ()
                    key_history_acc))
    (is_dirty? false)
    (add_to_key_history (function (key)
                           (progn
                              (unless (contains? key (list "Shift" "Alt" "Ctrl" "Command")) ;; don't grab just the special key downs
                                 (push key_history_acc key)
                                 (while (> key_history_acc.length key_history_length)
                                    (take key_history_acc))))))
    (key_down_event (fn (event)
                       (progc
                          (let
                             ((status (point_for root_elem))
                              (key event.key))
                             (when (or (and (== key.length 1)
                                            (not event.metaKey))
                                       (or (== key "Backspace")
                                           (== key "Enter")))
                                (when (not is_dirty?)
                                    (add_class "juno-needs-save" title_span))
                                (= is_dirty? true))
                             
                                
                             (cond
                               (== key "Escape")
                               (progn
                                  (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                               else
                               (progn
                                  (add_to_key_history (get_key_code event))
                                  (= last_event_context (process_rules_for_event event))
                                  key))))))
    
    (key_up_event (fn (event)
                      (progc
                         (let
                            ((status (point_for root_elem))
                             (key event.key)
                             (path_comps (for_each (c status.dom_path)
                                            (progn
                                               (if (== 1 c.nodeType)
                                                   c.tagName
                                                   "text")))))
                            (= current_point status)
                            (= last_event_context (process_rules_for_event event))
                            
                            
                            
                            (set_prop position_elem
                               `innerText
                               status.position)
                            (set_prop depth_elem
                               `innerText (length status.dom_path))
                            ;(-> path_elem `replaceChildren
                            ;  (div { } (join ":" (key_history))))
                            (set_prop key_history_elem
                               `innerText
                               (join ":" (key_history)))
                            (set_prop text_around_elem
                               `innerText
                               (join ":" (get_text_around_point status)))
                            (-> path_elem `replaceChildren
                               (div { } (for_each (name path_comps)
                                       (span {`style: "padding-right: 5px" } name))))
                                  
                            (when collection_timer
                               (clearTimeout collection_timer))
                            (= collection_timer
                               (setTimeout
                                  (fn ()
                                     (progn
                                        (when (and (not options.path)
                                                   (not options.filename))
                                           (= is_dirty? false)
                                           (remove_class "juno-needs-save" title_span)
                                           (set_prop options
                                              `content
                                              (element_to_lisp root_elem { use_ns: `html } )))))
                                  1000))
                               
                            (-> debug_elem `replaceChildren
                               (pre (JSON.stringify (element_to_lisp root_elem) "\n" 2)))
                            ))))
    
    (request_save (function ()
                        (progn
                           (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] }))))
    (nseval (if (not (blank? options.path_namespace))   
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))
    (menu_items (fn ()
                   (conj rules_menu
                      [["Copy contents as Lisp Structure" (fn (e) (copy_text_to_clipboard (pretty_print (as_lisp (-> self `get)))))]
                       (if options.filename
                          [(+ "Save " (get_editor_file_basename self)) (fn (e) (request_save))]
                          [])
                       ["Save as..." (fn (e) (save_as)) ]])))
    (set_name (fn (new_name force)
                 (progn
                    (when (and (not (blank? new_name))
                               (not (== (get_control_by_name new_name) self)))
                       (set_prop options
                          `name
                          (if force
                             new_name
                             (compute_name_for_control new_name)))
                       (set_prop self
                          `name
                          options.name)
                       (dispatch_event { command: "editor_change"
                                         source: self.id
                                         args: [ { `option: "name" `value: options.name } ] }))
                    (set_prop title_span
                       `innerText
                       options.name)
                    options.name)))
    (error_state false)      
    (on_destroy (fn ()
                                (progn
                                   (cond
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" } 
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         response)
                                      else
                                      true))))
    (on_initialize (fn ()
                      (progc
                         (let
                            ((remote_content nil)
                             (is_fresh false)
                             (extension nil))
                            (cond
                               options.filename
                               (progn
                                  (try
                                     (progn
                                        (= remote_content (fetch (+ "/files/" options.filename)))
                                        (cond
                                           (== remote_content.status 200)
                                           (= remote_content (-> remote_content `text))
                                           (== remote_content.status 404)
                                           (progn
                                              (= remote_content "")
                                              (notify (+ "New file: " options.filename))
                                              (= is_fresh true))
                                           remote_content
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": " remote_content.statusText))
                                           else
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": received nil response from the fetch operation.")))
                                        (set_filename options.filename)
                                        ;(log "remote_content: " remote_content)
                                        (when (and remote_content (not is_fresh))
                                           (= remote_content (eval (JSON.parse remote_content)))
                                           (-> root_elem `replaceWith remote_content)
                                           (= root_elem document_view.children.0)))
                                     (catch Error (e)
                                        (progn
                                           (log "DOM_editor: cannot set remote content: " remote_content)
                                           (alert_box (+ "Unable to open: " options.filename " - " e.message))
                                           (= error_state true)))))
                               (is_array? options.path)
                               (progn
                                  (defvar content (resolve_path options.path nseval.global_ctx.scope))
                                  (if (eq nil content)
                                      (progn
                                         (= content (or options.content
                                                        starter))
                                         (= is_fresh true)
                                         (make_path options.path nseval.global_ctx.scope root_elem))
                                      (progn
                                         (when (not (is_element? content))
                                            (= content (eval content)))
                                         (-> root_elem `replaceWith content)
                                         (= root_elem document_view.children.0))))
                               options.content
                               (progn
                                  (-> root_elem `replaceWith (if (is_element? options.content)
                                                                 options.content
                                                                 (eval options.content)))
                                  (= root_elem document_view.children.0)))
                            (set_name (cond 
                                         (and (is_string? options.name)
                                              (not (== "DOM Editor" options.name))) ;; 
                                         options.name
                                         (is_array? options.path)
                                         (last options.path)
                                         else
                                         "Untitled"))
                                          
                            (try
                               (load_rules)
                               (catch Error (e)
                                  (log "Error on load_rules: " e.message)))
                            ;(log "loaded rules: key_sequence_rules: " key_sequence_rules)
                            ;(log "loaded rules: prior_text_rules: " prior_text_rules)
                            
                            
                            (attach_event_listener content_view
                               `keyup
                               (fn (e) (key_up_event e)))
                            
                            (attach_event_listener content_view
                               `keydown
                               (fn (e)
                                  (key_down_event e)))
                            (set_attribute root_elem
                               `contenteditable "true")
                            (set_attribute root_elem
                               `tabindex 0)
                            (set_style [["height" "100%"]] root_elem)
                            (if options.hide_control_bar
                               (-> self `show_control_bar false))
                            
                            (setTimeout (fn ()
                                           (progn
                                              (cond
                                                 error_state  ;; unable to initialize - so remove ourselves
                                                 (destroy_control self)
                                                 (and (or options.content
                                                          options.filename)
                                                      (not is_fresh))
                                                 (progn
                                                    (select_element root_elem)
                                                    (collapse_to_start (get_selection)))
                                                 else
                                                 (progn
                                                    (select_element starter)))))
                                        100))))))
   {
       control_bar: true
       expose: [[`active_rules active_rules]
                [`reload_rules load_rules]
                [`save request_save]
                [`current_point (fn ()
                                   current_point) ]
                [`editor {} ]  ;; just to indicate we are an editor type component
                [`get (fn ()
                         (element_to_lisp root_elem)) ]
                [`root_elem (fn ()
                               root_elem) ]
                [`needs_save? (function ()
                                 is_dirty?)]
                [`on_save_complete (function (event_obj)
                                      (progn
                                         (remove_class "juno-needs-save" title_span)
                                         (= is_dirty? false)))]
                [`get_root_element (fn () root_elem)]]
   })



(defun DOM_to_markdown (quoted_dom _acc _ctx)
   (let
      ((acc (or _acc []))
       (ctx (new_ctx _ctx))
       (process_children (fn (children)
                            (progn
                               (for_each (child (or children []))
                                  (DOM_to_markdown child acc ctx)))))
       (tag nil))
      ;(log "DOM_to_markdown: " (getf_ctx ctx `tag) (getf_ctx ctx `in_pre))
      (cond
         (is_array? quoted_dom)
         (progn
            (= tag (if (is_reference? (first quoted_dom))
                       (first quoted_dom)
                       nil))
            (if (not (eq nil ctx.parent))
                (= ctx (new_ctx ctx)))
            (setf_ctx ctx `tag tag)
            (log "quoted_dom: " (is_reference? (first quoted_dom)) (getf_ctx ctx `tag) (rest quoted_dom))
            (cond
               (and tag
                  (== tag (quote div)))
               (progn 
                  (process_children (rest quoted_dom))
                  (push acc "<br>"))
               (and tag
                  (== tag (quote pre)))
               (progn
                  (setf_ctx ctx `in_pre true)
                  (push acc "```")
                  (process_children (rest quoted_dom))
                  (push acc "```<br>"))
               (and tag
                  (== tag (quote hr))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (push acc "---")
                  (push acc "<br>"))
               (and tag
                  (starts_with? (+ "=:" "h") tag)
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (push acc (join "" (for_each (r (range (int (-> tag `substr 3))))
                                        "#")))
                  (push acc " ")
                  (process_children (rest quoted_dom))
                  (push acc "<br>"))
                  
               
               (and tag
                  (not (getf_ctx ctx `in_pre)))
               (process_children (rest quoted_dom))))
         (is_string? quoted_dom)
         (progn
            (log "adding from " (getf_ctx ctx `tag) quoted_dom)
            (push acc quoted_dom)))
      acc))
      
      



(place_control `right (DOM_editor { rules: [ `*markdown_rules* ] `filename: "doc/test_1.juno" `hide_control_bar: true debug: true }))

(set_key_binding "global" "open_meta_editor"
                 {
                   `win: "Alt-M"
                   `mac: "Alt-M"
                   `exec: (fn () (place_control `right (meta_editor)))
                  `description: "Opens the meta editor"
                   })

(defcontrol meta_editor ()
   ((meta_struct (or options.content
                           {
                             description: ""
                             name: "Unnamed"
                             type: "unknown"
                             namespace: (current_namespace)
                             usage: []
                             tags: []
                             }))
    (usage (for_each (arg (or meta_struct.usage []))
              (progn
                 (defvar comps (split_by ":" arg))
                 (cond
                    (and (> comps.length 1)
                         (starts_with? "?" (second comps)))
                    [comps.0 (-> comps.1 `substr 1) true ]
                    (> comps.length 1)
                    [comps.0 comps.1 false ]
                    (== comps.length 1)
                    [comps.0 "" false ]))))
    
    (starter_span (div {  `tabindex: 0 `contenteditable: true  } (dtext "Enter text")))
    (desc (if (> meta_struct.description.length 0)
              (unpack_description meta_struct.description)
              starter_span))
    (name_editable (if options.allow_name_edits
                       true
                       true))
    (dlist_type_id (gen_id "types"))
    (dlist_types (datalist { `id: dlist_type_id }
                           (option `AsyncFunction)
                           (option `Function)
                           (option `object)
                           (option `string)
                           (option `number)
                           (option `boolean)
                           (option `array)))
    
    (symbol_type_elem (input { `class: `juno-editable `list: dlist_type_id `title: "Type" `tabindex: 0 `placeholder: "Type" `style: "font-size: 0.9em; width: 150px; padding: 5px;  font-weight: bold" `value: meta_struct.type }))
    (save_button (button (dtext "Save")))
    (monofont  "font-family: var(--main-mono-space);")
    (close_button (button (dtext "Close")))
    (new_arg_button (button { `style: "min-width: 30px; margin-left: 10px; margin-top: 10px; padding: 5px; "  `title: (dtext "Add New Argument") } "+"))
    (title_span (span { `style: "font-weight: bold; margin-right: 15px;" } options.name))
    (description_editor (DOM_editor { rules: [ `*markdown_rules* ] 
                                      hide_control_bar: true  } ))
    (description_section (details { `open: true  `style:"flex-grow: 1;" }
                                  (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Description"))
                                  (div { `style: "height: calc(100% - 30px); width: 100%;" } 
                                       description_editor.view)))
    (namespace_elem (span { `class: "juno-namespace" `style: "font-weight: bold;"} meta_struct.namespace))
    (name_edit_span (span (+ {} 
                             (if name_editable
                                { `contenteditable: true }
                                {})
                             { `class: "juno-editable" `tabindex: 0 `style: "font-weight: bold;" }) 
                          meta_struct.name))
    (tag_selection (tag_selector { `on_change: (fn (tags)
                                                  (progn
                                                     (set_prop meta_struct
                                                        `tags
                                                        tags)
                                                     (refresh_output))) }
                                 meta_struct.tags))
    (last_usage_elem nil)
    (refresh_usage (fn ()
                     (progn 
                        (= last_usage_elem nil)
                        (-> usage_elem `replaceChildren
                           (div { 
                                  `style: "line-height: 1.5em; font-size: 1.0em;  padding: 5px; max-width: 500px;" }
                                  (map (fn (arg idx total)
                                          (progn
                                             (log "idx: " idx total (as_lisp arg))
                                             (defvar pe (make_pair_editor arg idx total))
                                             (if (== idx (- total 1))
                                                 (= last_usage_elem pe.children.0))
                                             (-> pe `prepend (button { `style: "background: #FF000020; padding: 5px;"
                                                                       `remove_path: (join "~" [ `usage idx ]) } "-"))
                                             pe))
                                       usage)
                                  (if (== usage.length 0)
                                      [ 
                                       (div { } new_arg_button "Press + to add arguments") ]
                                      new_arg_button)
                                  ))
                        (when last_usage_elem 
                           (setTimeout (fn ()
                                          (focus_to last_usage_elem)
                                          20))))))
    
    (make_pair_editor (fn (arg idx total)
                         (pair_editor arg
                                      { `style: "border: 1px inset #ffffff;"
                                        `placeholder_0: "ArgName"
                                        `placeholder_1: "ArgType"
                                        `list_1: dlist_type_id
                                        `additional_elements: [ (checkbox (+ { `checkbox: { `path: (join "~" [ idx "2" ]) }}
                                                                             (if arg.2
                                                                                { `value: true }
                                                                                {}))
                                                                          "Optional")
                                                              ]
                                        `path: [ idx ]
                                        `on_change: (fn (path value)
                                                       (progn
                                                          
                                                          (make_path path usage value)
                                                          (cond
                                                              (and (== path.1 "2")
                                                                   (== value "false"))
                                                               (set_path path usage false)
                                                              (and (== path.1 "2")
                                                                   (== value "true"))
                                                              (set_path path usage true)
                                                              (== path.1 "2")
                                                              (set_path path usage false))
                                                          (log "pe: on_change: " path usage value)
                                                          (set_prop
                                                             meta_struct
                                                             `usage (map (fn (vals)
                                                                            (if (== vals.2 true)
                                                                                (+ vals.0 ":?" vals.1)
                                                                                (+ vals.0 ":" vals.1)))
                                                                            usage))
                                                          (show_updated_help)))
                                                          
                                                          
                                                         
                                        })))
    (usage_elem (div { `style: "min-height: 40px;" } ))
    (usage_section (details { `open: true  }
                            (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Usage"))
                                 usage_elem))
    (tag_section (details { `open: true }
                          (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Tags"))
                                tag_selection))
    (rendered_content_elem (div { `class: "juno-control" } "Live View"))
    
    (main_view (div { `class: "juno-control"  `style: "display: flex; flex-direction: column; align-items: stretch; padding-top: 5px; margin-left: 5px; min-height: 50%" } 
                    (h3 { `style: "display: flex; justify-content: space-between; align-items: center; " } 
                        (span (span { `style: "color: var(--namespace-color); " } meta_struct.namespace ) "/" name_edit_span)
                           symbol_type_elem)
                    (hr { `style: "light-hr" })
                    usage_section
                    description_section
                    tag_section
                    dlist_types))
    
    ;; output display: how the content is rendered in the output pane (lower)
    ;; mode 0 is the rendered display
    ;; mode 1 is a lisp view
    ;; mode 2 is a json view
    ;; mode 3 is a debug mode
    (output_display_modes [ "As Rendered" "Lisp" "JSON" "Debug" ])
    (output_display_mode 0) 
    (set_output_display_mode (fn (mode)
                                (try
                                   (progn
                                      (= output_display_mode (clamp mode
                                                                    0
                                                                    (max_index output_display_modes)))
                                      (refresh_output))
                                   (catch Error (e)
                                      (log_error e)))))
    
    (emit_as_formatted_lisp (fn ()
                               (let
                                  ((out (process_out)))
                                  (when (and (is_string? out.description)
                                             (> out.description.length 30))
                                     (set_prop out
                                        `description
                                        `(+ ,@(word_wrap out.description))))
                                  (pretty_print out))))
    (copy_as_formatted_lisp (fn ()
                               (progn
                                  (copy_text_to_clipboard (emit_as_formatted_lisp))
                                  (notify "Copied as lisp text to clipboard"))))
    (process_out (fn ()
                    (let
                       ((output (clone meta_struct)))
                       
                       (set_prop output
                          `usage (for_each (arg_desc usage)
                                    (if arg_desc.2
                                       (+ arg_desc.0 ":?" arg_desc.1)
                                       (+ arg_desc.0 ":" arg_desc.1))))
                       output)))
    (ok_grab_focus true)
    (on_blur (fn ()
                (= ok_grab_focus true)))
    (on_focus (fn (e)
                 (when ok_grab_focus
                    (= ok_grab_focus false)
                    ;(focus_to description_elem)
                    )))
    (table_regex (new RegExp "(^[a-zA-Z0-9?]+:[a-zA-Z0-9]+[ ]*-[ ]*)(.+)"))
    (show_updated_help (fn ()
                          (-> rendered_content_elem
                                    `replaceChildren 
                                    (div { `style: "background: var(--editor-bg-color); padding: 5px;" } 
                                         (format_help meta_struct)))))
    (process_current (fn (elem)
                        (let
                           ((content nil)
                            (live_content nil))
                           
                           (cond
                              true 
                              (progn
                                 (= live_content (join "" (DOM_to_markdown (-> description_editor `get))))
                                 ;; split into an array with roughly 80 column formatting for injection into source
                                 (if (> (length live_content) 60)
                                     (= live_content (flatten 
                                                        (conj [ (quote +) ]
                                                              (for_each (line (word_wrap live_content 80))
                                                                 (+ line " " ))))))
                                 (set_prop meta_struct
                                          `description live_content)
                                 ;(log "process_current: usage: " usage)
                                 (try 
                                    (progn 
                                       true) ;(log "Meta Struct: " meta_struct))
                                    (catch Error (e)
                                       (log "ERROR: " e.message)))
                                 
                                 (refresh_output))))))
    
    (sview (split_view_horizontal  main_view  rendered_content_elem  ))
    
    (content_view (div { `class: "juno-control" `style: "width: calc(100% - 2px); height: calc(100% - 2px); overflow: hidden; border-bottom: 3px solid black;" } 
                       sview.view))
    (select_name_edit_span (fn ()
                              (let
                                 ((selection (-> window `getSelection))
                                  (mrange nil))
                                 (try
                                    (progn
                                       (-> selection `removeAllRanges)
                                       (= mrange (new Range))
                                       (-> mrange `selectNodeContents name_edit_span)
                                       (-> selection `addRange mrange)
                                       true)
                                    (catch Error (e)
                                       (log "ERROR: " e.message))))))
    (control_bar_elements [(div { `style: "display:inline-block; float: right" } save_button close_button) ])
    (selection nil)
    (refresh_output (fn ()
                       (cond
                          (== output_display_mode 0)
                          (show_updated_help)
                          (== output_display_mode 1)
                          (-> rendered_content_elem
                             `replaceChildren (pre (as_lisp (process_out))))
                          (== output_display_mode 2)
                          (-> rendered_content_elem
                             `replaceChildren (pre (JSON.stringify (process_out) "\n" 2)))
                          (== output_display_mode 3)
                          (-> rendered_content_elem
                             `replaceChildren (pre "DESCRIPTION")))))
    (on_initialize (fn (intf)
                   (progn
                      (when true
                         (= initialized true)
                         (log "on_initialize: usage: " usage)
                         (-> sview `initialize)
                         (set_prop options
                            `name
                            (+ "Meta Editor - " meta_struct.name))
                         (set_prop title_span
                            `innerText
                             (+ name_edit_span.innerText
                                  " - Meta Editor"))
                         
                         (attach_event_listener view
                            `keydown
                            (fn (e)
                               (cond
                                  (== e.key "Enter")
                                  (progn
                                     (process_current))
                                  (== e.key "Escape")
                                  (progn
                                     (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                                  
                                 
                                     )))
                         
                         
                         (-> description_editor `initialize)
                         ;; cancel or manage certain key events on the name...
                         (attach_event_listener name_edit_span
                            `keydown
                            (fn (e)
                               (cond
                                  (== e.key "Enter")
                                  (handle_event e)
                                  (== e.key "Escape")
                                  (progn
                                     (handle_event e)
                                     ;(focus_to description_elem)
                                     )
                                  (== e.key " ")
                                  (handle_event e))))
                         (attach_event_listener name_edit_span
                            `keyup
                            (fn (e)
                               (progn
                                  (cond
                                     (blank? name_edit_span.innerText)
                                     (progn
                                        (set_prop name_edit_span
                                           `innerText
                                           (dtext "Unnamed"))
                                        (select_name_edit_span))
                                     else
                                     (set_prop meta_struct
                                        `name
                                        name_edit_span.innerText))
                                  (set_prop title_span
                                     `innerText
                                     (+ name_edit_span.innerText
                                  " - Meta Editor")))))
                                  
                         (attach_event_listener name_edit_span
                            `focus
                            (fn (e)
                               (select_name_edit_span)))
                         (attach_event_listener usage_elem
                            `click
                            (fn (e)
                               (progn
                                  (aif (getAttribute e.srcElement `remove_path)
                                       (progn
                                          (log "remove: " (getAttribute e.srcElement `remove_path))
                                          (-> usage `splice (last (split_by "~" it)) 1)
                                          (refresh_usage))))))
                         (refresh_usage)
                         (attach_event_listener new_arg_button
                            `click
                            (fn ()
                               (progn
                                  (push usage
                                     ["" "" false])
                                  (refresh_usage))))
                         (attach_event_listener close_button
                            `click
                            (fn (e)
                               (progn
                                  (if options.on_close
                                     (-> options `on_close self))
                                  (destroy_control self))))
                         
                         (attach_event_listener symbol_type_elem
                            `change
                            (fn (e)
                               (set_prop meta_struct
                                  `type
                                  (if (blank? symbol_type_elem.value)
                                      (dtext "Unknown")
                                      symbol_type_elem.value))))))))
   (menu_items (fn (menu_title)
                   (progn
                      ;(log "menu_args?" menu_title)
                      [[(dtext "Copy as formatted lisp") (fn () (copy_as_formatted_lisp))]
                       ["Set Display Mode"
                        [["Rendered View" (fn () (set_output_display_mode 0))]
                         ["Lisp" (fn () (set_output_display_mode 1))]
                         ["JSON" (fn () (set_output_display_mode 2))]
                         ["Debug" (fn () (set_output_display_mode 3))]]]])))
    (render (fn ()
                content_view)))
   {
     control_bar: true
     expose: [["get" process_out]
              ["set_output_display_mode" set_output_display_mode]]
     })



