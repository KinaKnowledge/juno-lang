
  
          
(defmacro progc (`& forms)
   `(try
       (progn
          ,@forms)
       (catch Error (e)
          (log e.message)))
   {
       `description: (+ "This macro wraps the provided forms in a "
                        "try-catch, and returns the last value if "
                        "no errors, like progn, or if an error "
                        "occurs, logs to the console.")
       `tags: ["debug" "error" "catch" "handler" "progn" "eval"]
       `usage: ["forms:*"]
   })

(defun_sync reverse_string (text)
   (join "" (-> (split_by "" text) `reverse))
   {
       description: "Given a string, returns the characters in reverse order."
       usage: ["text:string"]
       tags: ["string" "text" "reverse" "modify" ]
   })

(defun_sync last_n_chars (n text)
   (if (is_string? text)
       (-> text `substr (* -1 n))
       nil)
   {
       description: "For a given string, returns the last n characters as a string."
       usage: ["n:number" "text:string"]
       tags: ["string" "text" "last" "amount" "end" "tail"]
   })

(defun_sync last_n (n arr)
   (if (is_array? arr)
       (-> arr `slice (* -1 n))
       nil)
   {
       description: "For a given array, returns the last n elements as an array."
       usage: ["n:number" "arr:array"]
       tags: ["array" "list" "text" "last" "amount" "end" "tail"]
   })
                          
;; verbs for our command language

(defmacro get_selection ()
   `(-> window `getSelection))

(defun_sync get_range (selection index)
   (-> selection `getRangeAt (or index 0)))

(defmacro remove_all_ranges (selection)
   `(-> ,#selection `removeAllRanges))

(defmacro collapse_to_start (selection)
   `(-> ,#selection `collapseToStart))

(defmacro collapse_to_end (selection)
   `(-> ,#selection `collapseToEnd))

(defun_sync select_element (elem)
   (-> (get_selection) `selectAllChildren elem))

(defun_sync move_to_point (point_obj)
   (progc
      (log "move_to_point: " point_obj)
      (when point_obj.selection
         (focus_to (if (== point_obj.pos_type 1)
                       point_obj.pos_node
                       point_obj.pos_node.parentElement))
         (defvar selection (get_selection))
         (remove_all_ranges selection)
         (-> selection `addRange point_obj.range))))
         
(defun_sync move_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `move dir (or granularity "character"))))))

(defun_sync extend_from_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `extend dir (or granularity "character"))))))

(defun point_for (root_element)
   (let
      ((selection (get_selection))
       (selrange (get_range selection))
       (selected_node selrange.startContainer)
       (offset selrange.startOffset)
       (position (progn
                    (if (== selrange.startContainer.nodeType 3)
                        (progn
                           (get_cursor_position selrange.startContainer.parentElement))
                        selrange.endOffset)))
       (current_element selected_node)
       (path []))
      (while (and (not (eq current_element nil))
                  (not (== current_element root_element)))
         (progn
            (prepend path current_element)
            (= current_element current_element.parentElement)))
      { dom_path: path
        position: position
        pos_type: selected_node.nodeType
        pos_node: selected_node
        selection: selection
        range: selrange
        }))

(defun_sync select_node_at_point ()
   (let
      ((selection (get_selection))
       (selrange (get_range selection)))
      (if (== selrange.startContainer.nodeType 3)
         (-> selection `selectAllChildren selrange.startContainer.parentElement)
         (-> selection `selectAllChildren selrange.startContainer))))
       
      
      

(defun_sync get_text_around_point (point)
   (let
      ((text [])
       (elem nil))
      (progc
         (when point
            (cond 
               (== point.pos_type 1)
               (progn
                  (= elem point.pos_node))
               (== point.pos_type 3)
               (progn
                  (= elem point.pos_node.parentElement))))
         (when elem
            (push text
               (-> elem.innerText `substr 0 point.position))
            (push text
               (-> elem.innerText `substr point.position)))
         text))
   {
       description: (+ "Given a point object,returns an array that can "
                       "contain up to two strings.  The first value, at position "
                       "0, is the element text pior to the point's position. "
                       "The second value is the text of the element after "
                       "the point's position.")
       usage: ["point_object:object"]
       tags: ["DOM" "point" "edit" "selection" "editor" "select"]
   })
         
            
               
(defun_sync point_tag_path (point)
   (for_each (c point.dom_path)
      (progn
         (if (== 1 c.nodeType)
             c.tagName
             "text")))
   {
       `description: "Given a point object, returns the tag names that comprise the path to the point."
       `usage: ["point:object"]
       `tags: ["point" "editor" "DOM" "selection" "select"]
   })

(defun nc (node)
   (pre (as_lisp (element_to_lisp node))))

(defun insert_elem_at_point (elem under_root)
      (try
         (let
            ((selection (get_selection))
             (selrange (-> selection `getRangeAt 0))
             (parent_element (if (== selrange.startContainer.nodeType 3)  ;; text node
                                 selrange.startContainer.parentElement
                                 selrange.startContainer))
             (offset selrange.startOffset)
             (remaining_text nil))
            ;; extend it from the current point
            (log "insert_elem_at_point: " (nc parent_element))
            (-> selrange `setEndBefore parent_element.nextSibling)
            (= remaining_text (-> selrange `toString))
            (-> selection `deleteFromDocument)
            (= selection (get_selection))
            (remove_all_ranges selection)
            (-> selection `addRange selrange)
            (-> parent_element `append elem remaining_text)
            (collapse_to_start selection))
         (catch Error (e)
            (log (+ "ERROR: insert_elem_at_point:" e.message)))))


(defun_sync point_under_element_tag? (tag_name point)
   (contains? tag_name (point_tag_path point))
   {
       description: (+ "Returns true if the provided editor point is in a "
                        "DOM tree containing the provided tagname, otherwise false.")
       usage: ["tag_name:string" "point:object"]
       tags: ["editor" "point" "cursor" "DOM" "tree" "element"]
   })

(defglobal `markdown_rules
   {
     insert_pre:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keyup
         
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "```"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-P"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: false       ;; we don't care about handling the event
         
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are already in a pre
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     ;(move_to_point point)
                     (doc_exec `insertHTML "<pre style='min-height: 2.4ch;'></pre><div ><br></div>" true)
                     (move_to_point point)
                     (move_point `forward `character)))
         
     }
     ;; the next two rules implement the handling of newlines in the preformatted text node
     ;; the keydown acts to cancel the default behavior of the event 
     ;; the keyup then performs the correct newline behavior for insertion of newlines
     insert_return_in_pre_down:{
         on_event: `keydown   ;; intercept the enter key in PRE tags to ignore any action on Enter
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                       (point_under_element_tag? "PRE" point))
         handle_event: true
         exec: (fn (point ctl event)
                  (progc
                     true))
     }
     insert_return_in_pre_up:{
         on_event: `keyup   ;; intercept the enter key in PRE tags to add a newline vs. a new element
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                       (point_under_element_tag? "PRE" point))
         handle_event: true
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_header: {
         on_event: `keyup
         prior_text_sequence: "# "
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point)))
         handle_event: true
         remove_if_prior: true
         exec: (fn (point ctl event)
                  (progc
                     (let 
                        ((preceeding_text (aif (prop (get_text_around_point point) 0)
                                               (last (split_by " " it))
                                               ""))
                         (hash_details (first (scan_str (new RegExp "[#]+$") preceeding_text)))
                         (num_hashes (if hash_details
                                         (length (prop hash_details 0))
                                         0))
                         ;; add one because our rule triggered so it deleted one and the space
                         (tag_name (+ "H" (clamp (+ num_hashes 1) 1 5)))
                         (point nil))   
                        
                        ;; since we have asked the editor to remove the matching text we are going to 
                        ;; remove the remaining and use that as a way to compute the Heading element we
                        ;; will add
                        (when (> num_hashes 0)
                           (for_each (c (range num_hashes))
                              (extend_from_point `backward `character))
                           (doc_exec `delete nil))
                        (doc_exec `insertHTML (+ "<" tag_name ">Heading</" tag_name ">"))
                        (move_point `backward `character)
                        (= point (point_for (-> ctl `get_root_element)))
                        (select_node_at_point)
                        )))
     }  
     
   })


(defcontrol DOM_editor ()
   ((starter  (or options.content
                  (div { } "Start Typing!")))
    (root_elem (div { `class: "juno-editable" tabindex: 0 `contenteditable: true `style: "background: var(--editor-bg-color);  height: calc(100% - 20px); min-height: 150px; line-height: 1.5em; font-size: 1.1em;  padding: 5px; margin-top: 10px;margin-bottom: 10px;" }
                    (or options.content
                       starter)))
    (position_elem (div { `style: "padding: 5px;color: darkblue;" } ))
    (depth_elem (div { `style: "padding: 5px; color: green;" } ))
    (path_elem (div { `style: "padding: 5px; " } ))
    (status_elem (div { `style: "padding: 5px; display: none; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
                      position_elem
                      depth_elem
                      path_elem))
    (debug_elem (div { `style: "padding: 5px" } ))
    (content_view (div { `style: "background: var(--control-bg-color); overflow: hidden; width: 100%; height: 100%;" }
                       status_elem
                       root_elem
                       debug_elem))
    (collection_timer nil)
    (key_sequence_rules { keyup: {} keydown: {} })
    (prior_text_rules { keyup: {} keydown: {} })
    (post_text_rules { keyup: {}  keydown: {} })
    (load_rule (fn (name rule)
                  (let
                     ((lookup_rule (+ { name: (or name "Unnamed Rule") `remove_if_prior: (or rule.remove_if_prior false) }
                                      (if (is_function? rule.qualifier)
                                         { `qualifier: rule.qualifier }
                                         {})
                                      { `text_sequence: rule.prior_text_sequence }
                                      (if (is_function? rule.exec)
                                          { `exec: rule.exec }
                                          { `exec: (eval `(fn ()
                                                             (notify (+ "Rule " ,#name " has no exec rule")))) })
                                      (if rule.handle_event
                                         { `handle_event: true }
                                         {}))))
                     (when rule.prior_text_sequence
                        (make_path [ rule.on_event rule.prior_text_sequence ] prior_text_rules lookup_rule))
                     ;(when rule.post_text_sequence
                      ;  (make_path [ rule.on_event rule.post_text_sequence ] post_text_rules lookup_rule))
                     (when rule.key_sequence
                        (make_path [ rule.on_event rule.key_sequence ] key_sequence_rules lookup_rule)))))
    (load_rules (fn ()
                   (when (is_object? options.rules)
                      (for_each (pset (pairs options.rules))
                         (destructuring_bind (name rule)
                            pset
                            (load_rule name rule))))))
    (active_rules (fn ()
                     prior_text_rules))
    (current_point nil)
    (last_event_context nil)
    (render (fn ()
               content_view))
    
    (process_rules_for_event (fn (event)
                                (let
                                   ((text (get_text_around_point current_point))
                                    (on_event event.type)
                                    (prior_text_sequence (or text.0 ""))
                                    (next_text_sequence text.1)
                                    (key_sequence (clone (key_history))))
                                   
                                   ;; spaces show up as character code 160, so we need to move it to space to make
                                   ;; any matches succeed that are terminated by a space
                                   ;; note that this could probably be changed in the get_text_around_point function
                                   ;; but that needs to be thought through...
                                   
                                   (when (and (is_string? text.0)
                                              (== (-> (last_n_chars 1 text.0) `charCodeAt) 160))
                                       (set_prop text 
                                          0
                                          (+ (chop text.0) " ")))
                                   
                                   ;; next find the rule to eval if any...
                                   ;; from the most specific to the least
                                   (for_each (n [ 3 2 1 ])
                                      (progn 
                                         (aif (resolve_path [ on_event (join " " (last_n n key_sequence)) ] key_sequence_rules)
                                              (when (qualify_and_run it `key_sequence event)
                                                 (break)))))
                                   (for_each (n [ 4 3 2 1 ])
                                      (progc
                                         (when (>= (length text.0) n) 
                                            (aif (resolve_path [ on_event (last_n_chars n text.0) ] prior_text_rules)
                                                (when (qualify_and_run it `prior_text event)
                                                   (break)))))))))
     ;; when a rule is identified by process_rules_for_event as matching
     ;; the qualify_and_run function will make check to see if it is qualified
     ;; to run and then run the rule 
    (qualify_and_run (fn (rule identified_by event)
                        (progc
                           (defvar qualified? 
                              (if (is_function? rule.qualifier)
                                  (-> rule `qualifier current_point self) ;; only run it if qualifier returns true
                                  true)) ;; otherwise default run it since no qualifier
                           (if qualified?
                              (progn
                                 (when rule.handle_event
                                    (handle_event event))
                                 (when (and rule.remove_if_prior
                                            (== identified_by "prior_text"))
                                    ;(log "removing prior text sequence: " current_point.position rule.text_sequence range (length rule.text_sequence))
                                    ;; remove the text that qualified it
                                    ;; however we can delete the complete element if we are at the same position (offset) 
                                    ;; in the current element being edited as the length of the text sequence to remove.
                                    (if (> current_point.position (length rule.text_sequence))
                                        (progn   ;; just extend the selection backward and remove the text..
                                           (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (= current_point (point_for root_elem)))
                                        (progn ;; in this case we will remove the whole node that contains the trigger text
                                               ;; so we need to move backward to the prior node so the rule works consistently.
                                            (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (move_point `backward `character)
                                           (= current_point (point_for root_elem)))))
                                 ;; then call the rule!
                                 (-> rule `exec current_point self)
                                 true)
                              false))))
    (key_history_acc [])
    (key_history_length 4)
    (key_history (function ()
                    key_history_acc))
    (add_to_key_history (function (key)
                           (progn
                              (unless (contains? key (list "Shift" "Alt" "Ctrl" "Command")) ;; don't grab just the special key downs
                                 (push key_history_acc key)
                                 (while (> key_history_acc.length key_history_length)
                                    (take key_history_acc))))))
    (key_down_event (fn (event)
                       (progc
                          (let
                             ((status (point_for root_elem))
                              (key event.key))
                             (add_to_key_history (get_key_code event))
                             (= last_event_context (process_rules_for_event event))
                             key))))
    
    (key_up_event (fn (event)
                      (progc
                         (let
                            ((status (point_for root_elem))
                             (key event.key)
                             (path_comps (for_each (c status.dom_path)
                                            (progn
                                               (if (== 1 c.nodeType)
                                                   c.tagName
                                                   "text")))))
                            (= current_point status)
                            (= last_event_context (process_rules_for_event event))
                            ;(log "last_event_context: " last_event_context)
                            (cond
                               (== key "Escape")
                               (progn
                                  (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                               else
                               (progn
                                  (set_prop position_elem
                                     `innerText
                                     status.position)
                                  (set_prop depth_elem
                                     `innerText (length status.dom_path))
                                  (-> path_elem `replaceChildren
                                     (div { } (join ":" (get_text_around_point current_point))))
                                  ;(-> path_elem `replaceChildren
                                   ;  (div { } (for_each (name path_comps)
                                    ;         (span {`style: "padding-right: 5px" } name))))
                                  ))
                            (when collection_timer
                               (clearTimeout collection_timer))
                            (= collection_timer
                               (setTimeout
                                  (fn ()
                                     (set_prop options
                                        `content
                                        (element_to_lisp root_elem)))
                                  1000))
                               
                            (-> debug_elem `replaceChildren
                               (pre (JSON.stringify (element_to_lisp root_elem) "\n" 2)))
                            ))))
    (to_json (function ()
                `(DOM_editor ,#(element_to_lisp root_elem) ,#options)))
    
    (on_initialize (fn ()
                      (progc
                         (load_rules)
                         (log "loaded rules: key_sequence_rules: " key_sequence_rules)
                         (log "loaded rules: prior_text_rules: " prior_text_rules)
                         (log "loaded rules: post_text_rules: " post_text_rules)
                         (attach_event_listener root_elem
                            `keyup
                            (fn (e) (key_up_event e)))
                         
                         (attach_event_listener content_view
                            `keydown
                            (fn (e)
                               (key_down_event e)))
                         
                         (setTimeout (fn () 
                                        (if options.content
                                           (progn
                                              (select_element options.content)
                                              (collapse_to_start (get_selection)))
                                           (select_element starter))) 100))
                         )))
   {
       control_bar: true
       expose: [[`active_rules active_rules]
                [`get_root_element (fn () root_elem)]]
   })

;(place_control `right (DOM_editor (div { } "Whoa what is this?")))

(set_key_binding "global" "open_meta_editor"
                 {
                   `win: "Alt-M"
                   `mac: "Alt-M"
                   `exec: (fn () (place_control `right (defglobal *ed* (DOM_editor { rules: markdown_rules }))))
                  `description: "Opens the meta editor"
                   })
