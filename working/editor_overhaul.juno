;; editor overhaul buffer

(defun evaluate_and_replace_at_point (options)
   (let
      ((ctl *last_focus*))
      (cond
         (== ctl.type "text_editor")
         (progn
            (focus_to_editor ctl)
            (eval_selected_text_in_place ctl
                                         (+ {} 
                                            (if (not (eq nil options.discard_nil_values))
                                                { discard_nil_values: options.discard_nil_values }
                                                { discard_nil_values: true })
                                            (if options.append
                                                { append: true }
                                                {}))))))
   {
       `description: (+ "Using the control in *last_focus*, calls the eval_selected_text_in_place function "
                        "with the provided options.  The result of the evaluation will be placed into "
                        "the focused editor, either as replaceement text or appended text.<br>"
                        "#### Options<br>"
                        "discard_nil_values:boolean - If true any nil values will not be placed into "
                        "the editor.  If false, the user will be prompted to place nil values into "
                        "the text.  The default is true.<br>"
                        "append:boolean - If true, the result of the evaluation will be appended into "
                        "the editor at the point of the cursor, or if text is selected in the editor, "
                        "after the selection.<br>")
       `usage: ["options:object"]
       `tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })
                                                
(set_key_binding "global"
                 "evaluate_and_replace_at_point"
                 {
                   mac: "Command-R"
                   win: "Alt-R"
                   description: "Evaluate the selected text, or text prior to the form and replace with the results if not nil"
                   exec: (fn ()
                            (evaluate_and_replace_at_point))
                   })

(set_key_binding "global"
                 "evaluate_and_append_at_point"
                 {
                   mac: "Command-Shift-R"
                   win: "Alt-R"
                   description: "Evaluate the selected text, or text prior to the form and append with the results if not nil"
                   exec: (fn ()
                            (evaluate_and_replace_at_point { `append: true }))
                   })


(defun unpack_description (description options)
   (let
      ((table_regex (new RegExp "(^[a-zA-Z\\(\\)0-9?_*\\-]+):([a-z\\(\\) A-Z0-9]+)[ ]*-[ ]*(.+)"))
       (header_regex (new RegExp "^([#]{1,6})[ ]+(.+)"))
       (desc (progn
                (defvar tmp (eval (or description "")))
                (if (and (is_object? tmp)
                         (not (is_array? tmp)))
                    tmp.description
                    tmp)))
       (rr (new RegExp "<-" `g))
       (subsections [])
       (segments (split_by "<br>" (or desc "")))
       (table_section nil)
       (header_section nil)
       (header_tag nil)
       (header_size_lookup [nil h1 h2 h3 h4 h5 h6]) ;; pos 0 will never be found, hence nil
       (current_seg 0)
       (total_segs (length segments)))
       (for_each (seg segments)
          (progn
             (inc current_seg)
             (when (is_string? seg)
                (= seg (replace rr "\\u{279C}"  seg))
                (map (fn (comp i)
                        (if (== 1 (% i 2))
                            (push subsections
                               (if options.wrap_fn
                                  (try
                                     (progn
                                        (-> options `wrap_fn comp current_seg total_segs))
                                     (catch Error (e)
                                        (pre "Error in wrap_fn call 1: " e.message)))
                                  (pre comp)))
                            (push subsections
                               (if options.wrap_fn
                                  (try
                                     (-> options `wrap_fn comp current_seg total_segs)
                                     (catch Error (e)
                                        (p "Error in wrap_fn call 2: " e.message)))
                                  (progn
                                     (cond
                                        (and (not options.edit_mode)
                                                  (progn
                                                     (= table_section (scan_str table_regex comp))
                                                     (> (length table_section) 0)))
                                        (for_each (tbl_row table_section)
                                           (div { `style: "display: flex; align-items: flex-end; flex-wrap: wrap; gap: 16px; border-bottom: 1px solid var(--main-accent-line);" }
                                                (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.1)
                                                (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.2)
                                                (div { `style: "align-self: flex-start; padding: 5px; flex-grow: 1; flex-basis: 400px;"} tbl_row.3)))
                                        (== comp "---")
                                        (progn
                                           (hr))
                                        (progn
                                           (= header_section (scan_str header_regex comp))
                                           (> (length header_section) 0))
                                        (progn
                                           (= header_section (first header_section)) ;; pull it out of the array to make it easier to work with
                                           (= header_tag (or (prop header_size_lookup (length (prop header_section 1)))
                                                             "h5"))
                                           (header_tag 
                                            (prop header_section `2)))
                                              
                                        else
                                        (p comp)))))))
                     (split_by "```" seg)))))
       (div (+ { `class: "juno-editable" }
               (if options.edit_mode
                  { `contenteditable: true }
                  {}))
          subsections))
    {
       `usage: ["description:text"]
       `description: "Given a marked up description text, builds the output format for the browser."
       `tags: [ `usage `help `assist `formatted `markup ]
   })

(defun wait_for_editor (content)
   (if (get_control_by_name "Description Editor")
       (alert_box (dtext "Open Editor")
                  (dtext "There can be only one description editor open at a time."))
       (new Promise
          (fn (resolve reject)
             (let
                ((result nil)
                 (name "Description Editor")
                 (deditor (DOM_editor { rules: [ `*markdown_rules* ] `content: content `name: name })))
                (defglobal $ed_rval nil)
                (place_control `right deditor)
                (while (and (get_control_by_id deditor.options.id)
                            (is_nil? $ed_rval))
                   (progn
                      (sleep 1)))
                (if (get_control_by_id deditor.options.id)
                    (destroy_control deditor))
                (resolve `(+ ,@$ed_rval)))))))


(defun_sync find_last_paren (editor pos)
   (try
      (let
         ((pos (or pos (-> editor `getCursorPosition)))
          (stream (indirect_new TokenIterator editor.session pos.row pos.column))
          (done false)
          (depth 0)
          (t nil)
          (comps nil)
          (calc_depth (function (val)
                          (progn
                            (= comps (split_by "" val))
                            (while (> comps.length 0)
                              (progn
                                 (= t (pop comps))          
                               (cond 
                                  (or (== t ")")
                                      (== t "]")
                                      (== t "}"))
                                  (inc depth)
                                  (or (== t "(")
                                      (== t "[")
                                      (== t "{"))
                                  (dec depth)))))))
          (start nil)
          (token nil))
         (while (and (not done)
                     (not start))
            (progn
               (= token (-> stream `getCurrentToken))
               (when (== token.type "keyword")
                  (calc_depth token.value))
               
               (if (eq token nil)
                   (progn
                      (= done true)
                      (break))
                   (progn
                      (if (and (== token.type "keyword")
                               (or (== token.value.0 "(")
                                   (== token.value.0 "[")
                                   (== token.value.0 "{")))
                          (progn
                             (if (<= depth 0)
                                 (progn
                                    (= start { row: (-> stream `getCurrentTokenRow)
                                                   column: (-> stream `getCurrentTokenColumn) })
                                    (= done true)
                                    (break)))))))
                       
               (= token (-> stream `stepBackward))))
         (when start
            (-> editor.session `getBracketRange start)))
      (catch Error (e)
         (progn
            (console.error e)
            nil))))

(defun_sync select_to_current_form (editor pos)
  (if editor
    (let
        ((rng (-> editor `getSelectionRange))
         (already_selected? (if (and (== rng.start.row rng.end.row)
                                     (== rng.start.column rng.end.column))
                                false
                                true))
         (cpos (or pos 
                   (if already_selected?
                      (progn
                         (-> editor `navigateTo rng.start.row rng.start.column)
                         (-> editor `getCursorPosition))
                      (-> editor `getCursorPosition)))))
      (when cpos
        (= rng (find_last_paren editor cpos))
        (when rng
          (-> editor.selection `clearSelection)
          (-> editor.selection `setRange rng)))
      rng)
    nil)
  {
   description: (+ "Given an editor and an optional position { row column }, if possible, "
                   "selects the innermost current form (expression) in the editor and "
                   "returns the range.")
   usage: ["editor:object" "pos:?object"]
   tags: ["editor" "selection" "form" "lisp" "editing" ]
   })

(defun_sync select_root_form (editor pos)
   (if (and (is_object? editor)
            (is_object? pos))
       (let
          ((last_selection nil)
           (idx 0)
           (current_selection nil))
          ;; start with the current position
          (= current_selection (find_last_paren editor pos))
          (console.log "select_start: " current_selection)
          (while (and (< idx 1000)
                      current_selection
                      (or (eq nil last_selection)
                          (not (and (== last_selection.start.column current_selection.start.column)
                                    (== last_selection.start.row current_selection.start.row)
                                    (== last_selection.end.column current_selection.end.column)
                                    (== last_selection.end.row current_selection.end.row)))))
             (progn
                (inc idx)
                (= last_selection current_selection)
                (= current_selection (find_last_paren editor current_selection.start))
                (console.log "select_root_form: idx: " idx current_selection pos)
                ))
          
          (aif current_selection
             {
               `start_row: it.start.row
               `start_col: it.start.column
               `end_row: it.end.row
               `end_col: it.end.column
               })))
   {
     `usage: ["editor:object" "pos:object"]
     `description: "Given an editor and a position, returns the determined root form for the position."
     `tags: ["selection" "editor" "root" "form" "position"]
     })

(defun select_to_root_form (editor pos)
   (if editor
       (let
          ((cpos (-> editor `getCursorPosition))
           (pos (if pos
                    (select_root_form editor pos)
                     (select_root_form editor cpos))))
          (when pos
             (-> editor.selection `clearSelection)
             (-> editor.selection `setSelectionAnchor pos.start_row pos.start_col)
             (-> editor.selection `selectTo pos.end_row (+ pos.end_col 1))
             true))
       (throw TypeError "editor must be provided to select_to_root_form"))
   {
       description: (+ "Given an editor and an optional position, will select the complete form (to a depth of 0) if possible. "
                        "If given a position object with a row and column value, the function will use that instead.  If "
                        "succesful, the value true will be returned.  If no editor is provided, the function will throw a "
                        "TypeError.")
       usage: ["editor:object" "pos:?object"]
       tags: ["editor" "selection" "form" "lisp" "editing"]
   })


            

 
(defun edit_description_text_v1 ()
   (let
      ((ctl (if (== *last_focus*.type "text_editor")
                *last_focus*
                nil)))
      (when ctl
         (let
            ((pos (-> ctl `get_selection))
             (editor ctl.editor)
             (text nil)
             (new_text nil)
             (content nil)
             (empty_mode false)
             (start_pos (clone pos))
             (new_pos nil)
             (end_pos nil))
            (log "pos is: " pos)
            (if (and (== pos.start.row pos.end.row)
                     (== pos.start.column pos.end.column))
                (progn
                   (select_to_current_form ctl.editor)
                   (= new_pos (-> ctl `get_selection))
                   (log "new_pos is: " new_pos)
                   (when (< new_pos.end.row pos.end.row)
                       (= empty_mode true)
                       (-> editor `clearSelection)
                       (-> editor `navigateTo pos.end.row pos.end.column)
                       (= text ""))))
                   
            (if (not empty_mode)
               (= text (-> ctl `get_selected_text)))
            (log "text is: " text)
         
            (= text (eval (read_lisp text)))
            ;(log "text evaled is: " text)
            (progc
               (= content  (unpack_description text { `edit_mode: true })))
            (log "content is: " content)
            
            (-> ctl `set_read_only true)
            (= pos (-> ctl `get_selection))
            (= new_text (wait_for_editor content))
            (-> ctl `set_read_only false)
            (log "edit_description_text: new_text: " new_text)
            (when (and new_text
                       (second new_text))
               (= new_text (pretty_print new_text))
              
               (-> (-> editor `getSession) `replace pos new_text)
               (-> editor `navigateTo pos.end.row pos.end.column)
               (sleep 0.3)
               (select_to_current_form ctl.editor)
               (sleep 0.2)
               (indent_editor_selection  ctl.editor)
               (sleep 0.1)
            )
            
            ;(select_to_current_form ctl.editor)
        
            ;(-> editor `navigateTo pos.end.row pos.end.column)
            
            )))
   {
     `description: (+ "This function provides an ability to edit the description text of a function "
                      "for easier documentation.  When invoked, if not provided with a specific "
                      "text_editor control, will use the *last_focus* control if it is a text editor "
                      "type.   The current cursor position of the editor it is being invoked on will "
                      "be examined, and if it meets certain criteria, the description text will be "
                      "gathered and the description editor pane will pop up providing the user the "
                      "ability to edit the text in a fashion more amenable for writing "
                      "documentation.  <br>Once completed with the description edits, the user can "
                      "press the short cut key for get_as_wordwrap_text (default is bound to Alt-X) or "
                      "select the \"Get As Wordwrap Text\" menu item from the control menu.  This will "
                      "close the editor and place the contents of the description editor into the "
                      "source code in the appropriate position and form. <br>If the contents of the "
                      "description editor are not to be saved back to the text editor, just close the "
                      "editor, either from the menu or by pressing <br>Alt-D<br> (or the command "
                      "currently associated with the Close Control Command).  See (show_key_bindings) "
                      "in the REPL for a table of current globally defined key bindings. ")

     `usage: []
     })
      

(set_key_binding `global
                 `set_description_text
                 {
                   win: "Alt-E"
                   mac: "Command-E"
                   description: "Edit the description text in the DOM editor"
                   exec: (fn () (edit_description_text))
                   })

{ 
  `description: (+ "Given a control with an editor, the selected text is evaluated using the "
                   "editors evaluator.  The evaluated selection is replaced with the "
                   "result.<br>#### Options<br>append:boolean - If true, the selected value isn\'t "
                   "replaced but the result of the evaluation is placed into the editor at the "
                   "cursor\'s position.<br>discard_nil_values:boolean - If true, a nil value "
                   "(undefined or nil) will not be placed into the editor\'s text.  Otherwise, if a "
                   "nil value is returned the user will be prompted to place the nil result in the "
                   "buffer, or discard it.<br>evaluator:function - An optional \'evaluator\' function "
                   "can be passed to be used as the evaluator instead of the controls default "
                   "evaluator.<br>as_json:boolean - If true, the result will be placed as formatted "
                   "JSON into the editor.  The default is to place the result in formatted Juno "
                   "notation.<br>my_opt:test - If this is true, then cool!<br>another_thing - "
                   "Yay!<br>#### Examples<br><br><br><br><br>```This is some fixed text.\nAnd some "
                   "more.\nAdditional formatted code.\n```<br><br><br><br><br><br><br><br><br><br>OK "
                   "some regular text. <br>And were back with some more items  ")


 }

             
(defun edit_description_text ()
   (let
      ((ctl (if (== *last_focus*.type "text_editor")
                *last_focus*
                nil)))
      (when ctl
         (let
            ((pos (-> ctl `get_selection))
             (select_pos nil)
             (parent_pos nil)
             (editor ctl.editor)
             (new_text nil)
             (content nil)
             (thing_we_are_in nil)
             (ok_to_proceed true)
             (error_content (div
                              (dtext "To use the Description Text Editor, the description field must be in one of the following forms:")
                              (br)
                              (code "description: nil")
                              (br)
                              (code "description: (+ \"content\")")))
             (text nil))
            
            (select_to_current_form editor)
            (= select_pos (-> ctl `get_selection))
            (= text (-> ctl `get_selected_text))
            
            (= thing_we_are_in (read_lisp text { suppress_throw_on_error: true } ))
            (cond
               (is_array? thing_we_are_in)
               (progn
                  (= parent_pos (find_last_paren editor select_pos.start))
                  (-> editor.selection `clearSelection)
                  (-> editor.selection `setSelectionAnchor parent_pos.start.row parent_pos.start.column)
                  (-> editor.selection `selectTo parent_pos.end.row (+ parent_pos.end.column 0))
                  (= thing_we_are_in (read_lisp (-> ctl `get_selected_text) { suppress_throw_on_error: true } ))
                  
                  (if (and (prop thing_we_are_in `description)
                           (>= select_pos.start.row parent_pos.start.row)
                           (<= select_pos.end.row parent_pos.end.row)
                           (== (eval (prop thing_we_are_in `description)) (eval (read_lisp text)))
                           )
                      (progn
                          (-> editor.selection `clearSelection)
                          (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                          (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column)))
                      (progn
                         (= ok_to_proceed false)
                         (alert_box (dtext "Edit Description Text")
                                    error_content))))
               (and (is_object? thing_we_are_in)
                    (contains? "description:" (trim (-> editor.session `getLine pos.start.row)))
                    (contains? "description" (keys thing_we_are_in))
                    (== thing_we_are_in.description (quote "=:nil")))
               (progn
                  (-> editor `clearSelection)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  (= select_pos (-> editor.session `getAWordRange pos.start.row pos.end.column))
                  (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                  (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column 0))
                  
                  (= text "")
                  (= select_pos pos))
               else
               (progn
                  (= ok_to_proceed false)
                  (alert_box (dtext "Edit Description Text")
                             error_content)))
            (when ok_to_proceed
               (progc
                  (= content  (unpack_description (or (eval (read_lisp (or text ""))) "Empty") { `edit_mode: true })))
               (-> ctl `set_read_only true)
               (= pos (-> ctl `get_selection))
               (= new_text (wait_for_editor content))
               (-> ctl `set_read_only false)
               ;(log "edit_description_text: new_text: " new_text)
               (when (and new_text
                          (second new_text))
                  (= new_text (pretty_print new_text))
                  
                  (-> (-> editor `getSession) `replace pos new_text)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  (sleep 0.3)
                  (select_to_current_form ctl.editor)
                  (sleep 0.2)
                  (indent_editor_selection  ctl.editor)
                  (sleep 0.1)
                  )
               ))))
   { 
     `description: (+ "This function provides an ability to edit the description text of a function "
                      "for easier documentation.  When invoked, if not provided with a specific "
                      "text_editor control, will use the *last_focus* control if it is a text editor "
                      "type.   The current cursor position of the editor it is being invoked on will "
                      "be examined, and if it meets certain criteria, the description text will be "
                      "gathered and the description editor pane will pop up providing the user the "
                      "ability to edit the text in a fashion more amenable for writing "
                      "documentation.  <br>Once completed with the description edits, the user can "
                      "press the short cut key for get_as_wordwrap_text (default is bound to Alt-X) or "
                      "select the \"Get As Wordwrap Text\" menu item from the control menu.  This will "
                      "close the editor and place the contents of the description editor into the "
                      "source code in the appropriate position and form. <br>If the contents of the "
                      "description editor are not to be saved back to the text editor, just close the "
                      "editor, either from the menu or by pressing <br>Alt-D<br> (or the command "
                      "currently associated with the Close Control Command).  See (show_key_bindings) "
                      "in the REPL for a table of current globally defined key bindings. <br>#### "
                      "Qualifying formats of the Description Field to be Edited<br>The description "
                      "field must either have a value of nil (empty).  In this case, the description "
                      "editor will be empty of content when opened.  In this case the field entry "
                      "would look like:<br>```{\n   description: nil \n}```<br><br>If the description "
                      "field is already populated with content, it will need to be in the form "
                      "of: <br>```{\n   description: (+ \"Content Line\" \"more content\" "
                      "\"...\")\n}```<br><br>This is the format that the Description editor will place "
                      "into the source code when complete.<br>#### Other Notes<br>When the Description "
                      "Editor is invoked and while the user is editing text, the text_buffer that it "
                      "is being invoked on is placed into read only mode and so cannot be modified "
                      "until the Description Editor is closed. ")

      `usage: ["control:?object"]
      `tags: ["editor" "description" "metadata" "meta" ] })
                       
            
        
            
 (edit_description_text_v1)                      

(defun eval_selected_text_in_place (ctl options)
   (progc
      (let
         ((text nil)
          (pos nil)
          (editor (cond
                      (== ctl.type "text_editor")
                      ctl.editor
                      else
                      (throw TypeError "eval_selected_text_in_place: no text editor for provided control")))
          (selection nil)  ;; range to replace with results
          (evaluator nil)
          (result nil))
         (= pos (-> ctl `get_selection))
         (if (and (== pos.start.row pos.end.row)
                  (== pos.start.column pos.end.column))
             (select_to_current_form ctl.editor))
         ;; we should have an actual selection now if we didn't...
         (= selection (-> ctl `get_selection))
         (= text (-> ctl `get_selected_text))
         (if (blank? text)
             (progn 
                (-> ctl `display_context_message (dtext "Nothing to evaluate at the cursor position")))
             (progn
                (= evaluator
                   (cond
                      (is_function? ctl.get_evaluator)
                      (-> ctl `get_evaluator)
                      options.evaluator_id
                      (progn
                         (aif (prop (get_control_by_id options.evaluator_id)
                                    `evaluate)
                              it
                              nil))))
                (if (is_function? evaluator)
                    (progn
                       (alert_on_error (dtext "Evaluation Error")
                                       (= result (evaluator text false true true)))
                       (if (and (eq nil result)
                                (or options.discard_nil_values
                                    (== "discard" (request_user_choice 
                                                     (+ (dtext "The evaluation result is")
                                                        " "
                                                        (as_lisp result)
                                                        ".  "
                                                        (dtext "Insert or discard the result?"))
                                                     [[(dtext "Insert") "ok"] 
                                                      [(dtext "Discard") "discard"]]
                                                     {
                                                       `no_cancel_button: true
                                                       }))))
                           nil
                           (progn
                              (= result
                                 (cond
                                    (is_object? result)
                                    (if options.as_json
                                       (JSON.stringify result nil 2)
                                       (+ "" (pretty_print (as_lisp result))))
                                    (is_string? result)
                                    result
                                    else
                                    (+ "" (pretty_print (as_lisp result)))))
                              (try
                                 (progn
                                    (if options.append
                                       (progn
                                          (-> editor.selection `clearSelection)
                                          (-> editor `navigateTo pos.end.row pos.end.column)
                                          (set_prop pos.start
                                             `row pos.end.row
                                             `column pos.end.column)
                                          (-> (-> editor `getSession) `replace pos result))
                                       (-> (-> editor `getSession) `replace selection result)))
                                 (catch Error (e)
                                    (progn
                                       (-> (-> editor `getSession) `replace selection text)
                                       (-> ctl `display_context_message (+ "Error on replace: " e.message))
                                       (log (+ (dtext "Couldn't replace text in editor") ":" (prop ctl.options `name) ": " e.message))
                                       (log e)))))))
                    (alert_box (dtext "Evaluation Error")
                               (+ (dtext "No evaluator found for the control")
                                  " "
                                  ctl.options.name)))))))
   {
     description: (+ "Given a control with an editor, the selected text is evaluated " 
                     "using the editors evaluator.  The evaluated selection is replaced with the result."  
                     "<br>#### Options<br>"
                     "append:boolean - If true, the selected value isn't replaced but the result of the "
                     "evaluation is placed into the editor at the cursor's position.<br>"
                     "discard_nil_values:boolean - If true, a nil value (undefined or nil) will not be "
                     "placed into the editor's text.  Otherwise, if a nil value is returned the user "
                     "will be prompted to place the nil result in the buffer, or discard it.<br>"
                     "evaluator:function - An optional 'evaluator' function can be passed to be used " 
                     "as the evaluator instead of the controls default evaluator.<br>"
                     "as_json:boolean - If true, the result will be placed as formatted JSON into the "
                     "editor.  The default is to place the result in formatted Juno notation.<br>")
                     
     usage: ["control:object" "options:?object"]
     tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })


(defun get_primary_editor_in_group (controls)
   (let
      ((primaries (reduce (editor (or controls []))
                      (when (not (-> editor `get_linked))
                         editor))))
      (first primaries)))

(defun get_editors_for_filename (filename)
   (when (is_string? filename)
      (reduce (control (current_controls))
         (when (and control
                    control.editor
                    control.options.filename
                    (== control.options.filename filename))
            control))))
   

(defun rename_editor_group (path)
   (try 
      (let
         ((editors (get_editors_for_path path))
          (primary_id nil)
          (primary (reduce (editor (or editors []))
                      (when (not (-> editor `get_linked))
                         editor))))
         (assert (not (> primary.length 1)) "rename_editor_group: multiple primary editors. This is a bug.")
         (= primary (first primary))  ;; take the primary editor or nil 
         (cond 
            (== editors.length 0)
            true ;; nothing for us to do
            (== editors.length 1)
            (progn
               (-> (first editors) `set_unlinked)
               (-> (first editors) `set_name (-> (first editors) `group_name) true))
            else
            (progn
               (unless primary                ;; unless we already have a primary...
                  (= primary (take editors))) ;; take the first editor and make it the primary
               (= primary_id primary.options.id)
               (-> primary `set_name (-> primary `group_name) true)
               (-> primary `set_unlinked)
               (for_each (editor editors)
                  (when (not (== editor primary))
                     (-> editor `set_linked primary.options.id)
                     (-> editor `set_name (-> primary `group_name)))))))
      (catch Error (e)
         (log "rename_editor_group: error: " e.message))))

(defun clone_text_editor_control (editor_control)
   (let
      ((id editor_control.options.id)
       (new_name (if editor_control.group_name
                     (-> editor_control `group_name))))
      (declare (function text_editor)
               (global text_editor))
      (assert new_name "clone_text_editor_control: unable to get group name of the editor to clone")
      (when (and editor_control.editor id)
         (alert_on_error "Unable to clone the editor"
                         (text_editor (+ {} ;; start options 
                                         editor_control.options ;; take existing options..
                                         { `id: (gen_id "text_editor")
                                           `clone_with_editor_id: id }))))))


(defun display_pos_details (control)
   (when control.get_position_detail
      (let
         ((update_timer nil)
          (pos nil)
          (opts { `columns: [ "pointer" "idx" "row" "column" ] })
          (ctable (dtable [] opts))
          (update (fn ()
                     (progn
                        (= pos (-> control `get_position_detail))
                        (defvar nctable (dtable (map (fn (row idx tlen)
                                                        [(if (== pos.idx idx)
                                                             "->" "")
                                                         idx
                                                         row.row
                                                         row.column])
                                                     pos.history)
                                                opts))
                        (-> ctable `replaceWith nctable)
                        (= ctable nctable))))
                                          
          (view (floating_div
                   (div { }
                        ctable)
                   {
                       `on_close: (fn ()
                                     (progn
                                        (log "clearing timer")
                                      (clearInterval update_timer)))
                   })))
          (= update_timer
             (setInterval update 1000))
          true)))
         


(defun text_editor (options)
   (aif (and (not options.clone_with_editor_id)
             (get_control_by_name options.name))
        it
        (let
           ((options (+ {}  ;; default is an empty code editing buffer for lisp
                         { mode: "juno" 
                           id: (generate_id "text_editor")   ;; id can be provided and will overide this generated ID 
                           content: "" }
                         (if (is_object? options)
                            options
                            (progn
                               (notify "Invalid options object provided to editor - check config")))))
            (resize_observer nil)
            (group_name nil)
            (intf {})
            (initialized false)
            (config_value (function (key default_value)
                             (or (prop options key)
                                 (resolve_path [ `editor key ] *env_config*)
                                 default_value)))
            (buffer_commands_button (commands_button options.id))
            (evaluator_span (span { `class: "juno-evaluator" `title: (dtext "Name of the evaluator assigned to this buffer") } "-"))
            (nav_back_button (button { `title: (dtext "Step Backward In Position History") `style: "float: right" } "<"))
            (nav_forward_button (button { `disabled: true `title: (dtext "Step Foreward In Position History") `style: "float: right" } ">"))
            ;; if we have a namespace in options use that for referencing paths 
            (nseval (if (not (blank? options.namespace))   
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))  
            (is_dirty? false)
            (col_pos_span (span { `title: "Position (Row Column)" `style: "float: right;margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } "[0 0]"))
            (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" } 
                               (if options.read_only
                                        "RO"
                                        "")))
            (mode "-")
            (mode_span (span { `class: "juno-mode" `title: "Current Editing Mode" `style: "float: right; margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } mode))
            (title_span (span { `class: "juno-title" } options.name))
            (control_bar (or options.control_bar
                             (div { `class: "juno-buffer-bar" }
                                  buffer_commands_button
                                  title_span
                                  (span { `title: "Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } nseval.namespace)
                                  evaluator_span
                                  locked_span
                                  nav_forward_button
                                  nav_back_button
                                  mode_span
                                  col_pos_span)))
            (parent_view nil)
            (context_clear_timer nil)
            (display_context_message (function (value)
                                        (if (and (blank? value)
                                                 context_clear_timer)
                                            nil
                                            (progn
                                               (when context_clear_timer
                                                  (clearTimeout context_clear_timer))
                                               (= context_clear_timer nil)
                                               (when (not (blank? value))
                                                  (= context_clear_timer (setTimeout (fn () (= context_clear_timer nil)) 3000)))  ;; delay for clearing the message to quickly if a blank comes in
                                               (cond
                                                  (is_element? value)
                                                  (-> help_context_elem
                                                     `replaceChildren value)
                                                  else
                                                  (-> help_context_elem
                                                     `replaceChildren (span { `style: "display: inline-block; text-overflow: ellipsis; width: 100%; overflow: hidden" } (+ "" value))))))))
            (check_observer (fn ()
                               (when (not (== view.parentElement parent_view))
                                  (-> resize_observer `disconnect)
                                  (-> resize_observer `observe view.parentElement)
                                  (= parent_view view.parentElement))))
            
            (help_context_elem (div { `class: "juno-help-context" } ""))
            (context_bar (div { `class: "juno-context-bar" }
                              help_context_elem))
            (offset_depth 46)
            (editor_div (div { `class: "opacity-0" `style: (+ "height: calc(100% - " offset_depth  "px); width: 100%; overflow: hidden;font-family:var(--main-mono-space);") }))
            
            (view (div { `control_id: options.id `style: "overflow: hidden; height: calc(100% - 10px); display: inline-block; width: inherit;" }
                       control_bar
                       editor_div
                       context_bar))
            (evaluator nil)
            (perform_resize (fn ()
                               (when view.parentElement
                                  (check_observer)
                                  (html/set_style [["width" "calc(100% - 2px)"];           (+ "" (- (prop view.parentElement `offsetWidth) 2) "px")]
                                                   ["height" (+ "" (- (prop view.parentElement `offsetHeight) 2) "px")]]
                                                  view)
                                  (set_style [["height" (+ "calc(100% - " (+ (Math.max 0 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] editor_div)
                                  (when editor
                                     (-> editor `resize)))))
            
            (editor nil)  ;; the editor object
            (set_read_only (fn (read_only?)
                              (progn
                                 (-> editor `setReadOnly read_only?)
                                 (if read_only?
                                    (set_prop locked_span
                                       `innerText 
                                       (dtext "RO"))
                                    (set_prop locked_span
                                       `innerText 
                                       (dtext ""))))))
            (set_evaluator (fn (evaluator_function)
                              (when (is_function? evaluator_function)
                                 (= evaluator evaluator_function)
                                 (dispatch_event { command: "editor_change"
                                                   source: options.id
                                                   args: [ { `option: "evaluator" `value: evaluator_function } ] })
                                 (aif (get_keybinding "editor" "evaluate_selection")
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (-> editor.commands `addCommand
                                         {
                                           `name: "evaluate_selection"
                                           `bindKey: { `win: "Shift-Enter" `mac: "Shift-Enter" }
                                           `exec: evaluate_selection
                                           })))))
            (set_mode (fn (mode_name)
                         (progn
                            (defvar identifier_regex (new RegExp "[A-Za-z*+0-9_\\$\\u00A2-\\uFFFF]+"))
                            (set_prop options
                               `mode
                               mode_name)
                            (cond
                               (== options.mode "juno")
                               (progn
                                  (console.log "mode to juno")
                                  (-> editor.session `setMode "ace/mode/juno")
                                  (-> editor `setOptions {
                                                           `enableBasicAutocompletion:  [{ identifierRegexps: [ identifier_regex ]
                                                                                                             getCompletions: (fn (editor session pos prefix callback)
                                                                                                                                (get_juno_autocompletions editor session pos prefix callback)) }]
                                                           enableLiveAutocompletion: true
                                                           enableSnippets: true
                                                           }))
                               (== options.mode "javascript")
                               (progn
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })
                                  (-> editor.session `setMode "ace/mode/javascript"))
                               (== options.mode "css")
                               (progn
                                  (-> editor.session `setMode "ace/mode/css")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true }))
                               options.mode
                               (progn
                                  (-> editor.session `setMode options.mode)
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })))
                            
                            (set_prop mode_span
                               `innerText
                               options.mode)
                            (dispatch_event { command: "editor_change"
                                              source: options.id
                                              args: [ { `option: "mode" `value: options.mode } ] })
                            (when options.on_mode_set
                               (options.on_mode_set mode_name)))))
            
            (set_theme (fn (theme_name)
                          (progn
                             (-> editor `setTheme (+ "ace/theme/" theme_name))
                             (set_prop options
                                `theme
                                theme_name)
                             (dispatch_event { command: "editor_change"
                                               source: options.id
                                               args: [ { `option: "theme" `value: theme_name } ] })
                             (when options.on_theme_set
                                (options.on_theme_set theme_name)))))
            
            (set_overscroll (fn (state)
                                    (if state
                                       (progn
                                          (-> editor `setOption `scrollPastEnd true)
                                          (set_prop options
                                             `overscroll
                                             true)
                                          true)
                                       (progn
                                          (-> editor `setOption `scrollPastEnd false)
                                          (set_prop options
                                             `overscroll
                                             false)
                                          false))))
            
            (set_name (fn (new_name force)
                              (progn
                                 ;; if we are not already called the new name go ahead and process the new name
                                 (when (and (not (blank? new_name))
                                            (not (== (get_control_by_name new_name) intf)))
                                    (set_prop options
                                       `name
                                       (if force
                                          new_name
                                          (compute_name_for_control new_name)))
                                    (set_prop intf
                                       `name
                                       options.name)
                                    (dispatch_event { command: "editor_change"
                                                      source: options.id
                                                      args: [ { `option: "name" `value: options.name } ] }))
                                 (set_prop title_span
                                    `innerText
                                    options.name)
                                 options.name)))
            
            (evaluate_selection (function (editor)
                                   (let
                                      ((rval nil)
                                       (copytext (if options.repl_mode
                                                     (-> editor `getValue)
                                                     (-> editor `getCopyText))))
                                      (if (blank? copytext)
                                          (if (not options.repl_mode)
                                              (display_context_message (dtext "Please highlight text to evaluate")))
                                          (try
                                             (progn
                                                (= rval (evaluator copytext nil (not options.repl_mode)))
                                                (-> rval `then
                                                   (function (val)
                                                      (progn
                                                         (try
                                                            (and options.on_evaluation
                                                               (-> options `on_evaluation copytext val))
                                                            (catch Error (e)
                                                               (log_error (+ "" options.name ": Received error from on_evaluation")
                                                                          e)))
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof val Error)
                                                                           (display_context_message (+ (subtype val)
                                                                                                       (if val.message (+ ":" val.message)
                                                                                                           "")))
                                                                           (is_function? val)
                                                                           (display_context_message (+ "<- " (subtype val)))
                                                                           else
                                                                           (progn
                                                                              (defvar chopped (as_lisp val))
                                                                              (if (> chopped.length 200)
                                                                                  (= chopped (+ (-> chopped `substr 0 200) "...")))
                                                                              (display_context_message (+ "<- " chopped)))))
                                                                     100)))
                                                   (function (e)
                                                      (progn
                                                         (notify "Failure on evaluation")
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof e Error)
                                                                           (display_context_message (+ (subtype e)
                                                                                                       (if e.message (+ ":" e.message)
                                                                                                           "")))
                                                                           else
                                                                           (display_context_message "Evaluation Failure")))
                                                                     100)))))
                                             (catch Error (e)
                                                (progn
                                                   (notify (+ (dtext "Unhandled error") ": " e.message ))
                                                   (console.error e))))))))
            
            (font_size (config_value `font_size 14))
            (increase_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.min 200 (+ font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (decrease_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.max 1 (- font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (select_form_root (fn ()
                                 (progn
                                    (select_to_root_form editor)
                                    nil)))
            (evaluate_root_form (fn ()
                                   (let
                                      ((cpos (current_position)))
                                      (select_form_root)
                                      (evaluate_selection editor)
                                      (sleep 0.02)
                                      (-> editor.selection `clearSelection)
                                      (-> editor `navigateTo cpos.row cpos.column)
                                      )))
            
            (select_current_form (fn ()
                                    (select_to_current_form editor)))
            (get_selected_text (function ()
                                  (-> editor `getSelectedText)))
            (get_selection_object (function ()
                              (-> editor.selection `getRange)))
            (get_lines (function (from to)
                          (-> editor.selection `getLines from to)))
            (is_selected? (function ()
                             (progn
                                (defvar rng (get_selection_object))
                                (not (and (== rng.start.row rng.end.row)
                                          (== rng.start.column rng.end.column))))))
            (last_bracket_match nil)
            (active_lisp_operator nil) ;; the last active lisp operator
           
            (find_active_lisp_operator (function ()
                                          (let
                                             ((new_op nil)
                                              (rnge (or (-> editor.session `getBracketRange (-> editor `getCursorPosition))
                                                        (find_last_paren editor)))
                                              (usage nil))
                                             (if rnge
                                                (progn
                                                   (= last_bracket_match rnge)
                                                   (= new_op (first (split_by *whitespace_regexp* (-> editor.session `getTextRange last_bracket_match))))
                                                   
                                                   (when (not (== new_op active_lisp_operator))
                                                      (= active_lisp_operator new_op)
                                                      (= usage (decorative_usage active_lisp_operator))
                                                      (if usage
                                                         (-> help_context_elem
                                                            `replaceChildren usage)
                                                         (-> help_context_elem `replaceChildren))
                                                      (when usage
                                                         (dispatch_event { `command: "display_usage" `source: options.id `args: [active_lisp_operator] }))
                                                      (when options.on_new_lisp_operator
                                                         (options.on_new_lisp_operator active_lisp_operator))))
                                                (progn
                                                   (= active_lisp_operator nil)
                                                   (-> help_context_elem
                                                      `replaceChildren)
                                                   (when options.on_new_lisp_operator
                                                      (options.on_new_lisp_operator nil)))))))
            
            (indent_row (function (row_number options)
                           (indent_editor_line editor row_number options)))
            
            (indent_current_row (function (editor)
                                   (when (== *last_focus* intf)
                                      (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                         (if (not (is_selected?))
                                             (progn
                                                (defvar row_number (prop (-> editor `getCursorPosition)
                                                                         `row))
                                                (console.log "tab: start: single line: " row_number)
                                                (indent_row row_number { `apply: true }))
                                             (indent_editor_selection editor))))))
            
            (bind_key (fn (key_command func)
                         (aif (get_keybinding "editor" key_command)
                              (progn
                                 (-> editor.commands `addCommand
                                    (to_ace_keybinding key_command it func))))))
            
            ;; signal ready for saving
            (request_save (function ()
                             (progn
                                (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] }))))
            
            ;; handle the results of the save
            (save_complete (function (event_obj)
                              (progn
                                 (if options.create_mode
                                    (delete_prop options `create_mode))
                                 (display_context_message (+ "Saved " (cond
                                                                         (and (== event_obj.args.0.type "path")
                                                                              (is_array? event_obj.args.0.target))
                                                                         (join "~" event_obj.args.0.target)
                                                                         (== event_obj.args.0.type "filename")
                                                                         event_obj.args.0.target)))
                                 (log "editor: save_complete: " (clone event_obj))
                                 (remove_class "juno-needs-save" title_span)
                                 (delete_prop options `create_mode)
                                 (= is_dirty? false)
                                 (when options.on_save
                                    (-> options `on_save intf)))))
            (split_editor (fn (dir)
                             (let
                                ((new_editor nil))
                             (cond
                                (== dir "vertical")
                                (progn
                                   (= new_editor (clone_text_editor_control intf))
                                   (alert_on_error "Unable to split"
                                                   (container_view_operation "split_right" intf new_editor)))
                                (== dir "horizontal")
                                (progn
                                   (= new_editor (clone_text_editor_control intf))
                                   (alert_on_error "Unable to split"
                                                   (container_view_operation "split_below" intf new_editor)))
                                else
                                (alert_box "Invalid Split Request" "Split commands  must be vertical or horizontal")))))
            ;; position tracking 
            (max_history_length (if (is_number? options.max_history_length)
                                    options.max_history_length
                                    40))
            (position_history [])
            (position_history_idx 0)
            (current_position (fn ()
                                  (-> editor `getCursorPosition)))
            (set_cursor_position (fn (pos)
                                    (progn
                                       (-> editor `navigateTo pos.row pos.column)
                                       (-> editor `scrollToLine pos.row true nil)
                                       (focus_to_editor intf))))
            (update_position (function ()
                                (when editor
                                   (defvar current_pos (-> editor `getCursorPosition))
                                   
                                   (set_prop col_pos_span
                                      `innerText
                                      (+ "[" current_pos.row " " current_pos.column "]"))
                                   (set_prop options `cursor_position current_pos)
                                   
                                   ;; record our position history so we can go back 
                                   ;; if we are less then 8 rows difference, then 
                                   ;; update it, otherwise push it onto the stack
                                   (try
                                      (progn
                                         (when (isNaN position_history_idx)
                                             (log "text_editor: update_position: position_history_idx isNaN!")
                                             (= position_history_idx (- position_history.length 1))
                                             (set_disabled nav_forward_button))
                                         (defvar last_pos (prop position_history position_history_idx))
                                         (when (eq nil last_pos)
                                            (log "last_pos is nil! and it shouldn't be: " position_history_idx))
                                         (if (> (Math.abs (- current_pos.row (prop last_pos `row)))
                                                8)
                                            (progn
                                               (inc position_history_idx)
                                               (-> position_history `splice position_history_idx 0 current_pos)
                                               ;(log "update_position: recorded position" position_history_idx (prop last_pos `row) (Math.abs (- current_pos.row (prop last_pos `row))))
                                               (when (> position_history.length max_history_length)
                                                  (take position_history)
                                                  (= position_history_idx (clamp position_history_idx 0 (- position_history.length 1)))))
                                            (progn
                                               (-> position_history `splice position_history_idx 1 current_pos))))
                                      (catch Error (e)
                                         (log "ERROR " options.name  " on position history update: " e.message)))
                                   
                                   
                                   )))
            (go_backward_in_position (fn ()
                                        (progn
                                           (= position_history_idx (Math.max 0 (- position_history_idx 1)))
                                           (set_enabled nav_forward_button)
                                           (set_cursor_position (prop position_history position_history_idx)))))
            (go_forward_in_position (fn ()
                                        (progn
                                           (= position_history_idx (Math.min (- position_history.length 1) (+ position_history_idx 1)))
                                           (when (== position_history_idx (- position_history.length 1))
                                              (set_disabled nav_forward_button))
                                           (set_cursor_position (prop position_history position_history_idx)))))
                                           
            (on_focus (fn ()
                         (progn
                            (when (not (== *last_focus* intf))
                               (focus_to intf.editor))
                            (setq *last_focus* intf)
                            (add_class "juno-focused" control_bar))))
            
            (orig_bindings nil)
            (build_key_bindings (fn (editor)
                                   (progn
                                      (console.log "building_key_bindings")
                                      ;; we need to remove any keybinding that interferes with our globals and then
                                      ;; rebuild to the right scope
                                      (= orig_bindings (clone (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor)))
                                      ;(defglobal *orig_key_bindings* orig_bindings)
                                      (when options.on_save
                                         (bind_key "on_save" request_save))
                                      (bind_key "increase_font_size" increase_font_size)
                                      (bind_key "decrease_font_size" decrease_font_size)
                                      (bind_key "select_form_root" select_form_root)
                                      (bind_key "select_current_form" select_current_form)
                                      (bind_key "indent_current_row" indent_current_row)
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (bind_key "evaluate_root_form" evaluate_root_form)
                                      (bind_key "evaluate_selected_in_place" (fn (editor)
                                                                                (progn
                                                                                   (setTimeout (fn ()
                                                                                                  (try
                                                                                                     (progn
                                                                                                        (defvar rval (eval_selected_text_in_place (get_control_by_editor editor)))
                                                                                                        true)
                                                                                                     (catch Error (e)
                                                                                                        (display_context_message "Error on evaluation: " e.message))))
                                                                                               10)
                                                                                   true)))
                                      
                                      (when (is_array? options.commands)
                                         (for_each (command options.commands)
                                            (do
                                               (console.log "optional commands: " command.name command)
                                               (-> editor.commands `addCommand
                                                  (to_ace_keybinding command.name command)))))
                                      true)))
            
            (linked_editor_name nil)
            (linked_editor nil)
            (data_type nil)
            (data_type_defaults { String: "" 
                                     array:[] 
                                     object: {} })
            ;; based on the contents of the options object set the editor's content 
            (set_content (fn ()
                            (let
                               ((content nil))
                               (if options.data_type
                                  (if (eq undefined (prop data_type_defaults options.data_type))
                                      (throw TypeError (+ "Invalid data_type specified: must be either: " (join ", " (keys data_type_defaults))))))
                               (cond
                                  ;; do we have a filename?
                                  (and (is_string? options.filename)
                                       is_served?)
                                  (try
                                     (progn
                                        ;(log "text_editor: requesting file: " options.filename)
                                        (if options.create_mode
                                           (= content "")
                                           (= content (-> (fetch (+ "/files/" options.filename)) `text)))
                                        
                                        (if (is_string? content)
                                            (progn
                                               
                                               (-> editor `setValue content -1))
                                            (progn
                                               (-> editor `setValue "")
                                               (= content "")
                                               (display_context_message (+ "NOTICE: unable to fetch file: " options.filename " (editor set to local value)"))))
                                        (set_prop options 
                                           `path
                                           (conj [ `filesystem ] (split_by "/" options.filename))))
                                        
                                     (catch Error (e)
                                        (progn
                                           (-> editor `setValue "")
                                           (= content content)
                                           (display_context_message (+ "ERROR on fetching: " options.filename " (editor set to local value)  " e.message))
                                           (log "Error on fetching file: " options.filename ": " e)
                                           (set_prop options 
                                              `path
                                              (conj [ `filesystem ] (split_by "/" options.filename))))))
                                  
                                  ;; if we are given a filename, but we are not online we can't edit it
                                  ;; if we have previous content we can edit off line, but with a notice to the user 
                                  (and (is_string? options.filename)
                                       options.content)
                                  (progn
                                     (-> editor `setValue options.content -1)
                                     (= content options.content)
                                     (alert_box "Warning: Using cached content"
                                                (div { `style: "" }
                                                     (dtext "The application isn't online, so the specified content cannot be fetched.")
                                                     (dtext "The last stored value is being used, but this may not match the remote content.")
                                                     (br)
                                                     (dtext "Information loss could occur if this editor's contents are subsequently saved to the server.")
                                                     (dtext "Be careful!")))
                                     (set_prop options 
                                           `path
                                           (conj [ `filesystem ] (split_by "/" options.filename)))
                                     (display_context_message (+ "Warning: Cached value of an online file")))
                                  (is_array? options.path)
                                  (progn
                                     (= content (resolve_path options.path nseval.global_ctx.scope))
                                     (when (eq nil content)
                                        (= content (or options.content 
                                                       (and options.data_type
                                                            (prop data_type_defaults options.data_type))
                                                       ""))
                                        (make_path options.path nseval.global_ctx.scope content)
                                        (display_context_message (+ "New path: " (join "~" options.path) " with content type " (sub_type content))))
                                     (if (not (== "String" (sub_type content)))
                                         (-> editor `setValue (pretty_print content))
                                         (-> editor `setValue content -1)))
                                  (is_string? options.content)
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue content -1))
                                  (or (is_object? options.content)
                                      (is_array? options.content))
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue (pretty_print content))))
                               (assert (is_value? content) "assertion failure: content is not set in set_content")
                               (= data_type
                                  (sub_type content))
                               (set_prop options
                                  `data_type
                                  data_type)
                               ;; at this point content should be loaded and displayed and 
                               ;; data_type should be properly set for the content that
                               ;; is being edited
                               options)))
            (set_display_control_bar (fn (state)
                                        (progn
                                           (if state
                                              (remove_class "juno-display-none" control_bar)
                                              (add_class "juno-display-none" control_bar))
                                           (perform_resize))))
            (set_evaluator_control (fn (control)
                                      (if control.evaluate
                                         (progn
                                            (set_evaluator control.evaluate)
                                            (set_prop options
                                               `evaluator_id
                                               control.options.id)
                                            (if control.name
                                               (set_prop evaluator_span
                                                  `innerText
                                                  (+ "⭢ " control.name)))))))
            (menu_items (fn ()
                                [(if options.path
                                  [(+ (dtext "Save to") " " (last options.path))
                                   (fn (e) (request_save))]
                                  [])
                                 [(dtext "Split Vertically") 
                                  (fn (e)
                                     (split_editor `vertical)) ]
                                 [(dtext "Split Horizontally")
                                  (fn (e)
                                     (split_editor `horizontal))]
                                 [(dtext "Select Evaluator")
                                   (fn (e)
                                      (progn
                                         (aif (select_evaluator)
                                              (progn
                                                 (set_evaluator_control it)
                                                 (notify (+ (dtext "Evaluator set to ") it.options.name))))))]
                                 
                                 [(dtext "Increase Font Size") increase_font_size]
                                 [(dtext "Decrease Font Size") decrease_font_size]
                                 [(dtext "Go") 
                                  [[(dtext "Step Backward In Position History")
                                    go_backward_in_position]
                                   [(dtext "Step Forward In Position History")
                                    go_forward_in_position]]]
                                 (if (-> editor `getReadOnly)
                                     [ (dtext "Allow Editing" ) (fn () (-> intf `set_read_only false)) ]
                                     [ (dtext "Set Read-Only Mode") (fn () (-> intf `set_read_only true)) ])
                                 [(dtext "Set Edit Mode")
                                  [["Juno" (fn () (-> intf `set_mode "juno"))]
                                   ["Javascript" (fn () (-> intf `set_mode "javascript")) ]
                                   ["Text" (fn () (-> intf `set_mode "text"))]
                                   ["CSS" (fn () (-> intf `set_mode "css"))]
                                   ["JSON" (fn () (-> intf `set_mode "json"))]]]
                                 [(dtext "Set Editor Theme") 
                                  (for_each (theme *editor_themes*)
                                         [theme  (fn () (-> intf `set_theme theme))])]]))

            ;; main initialization routine
            (initialize_editor (fn ()
                                  (when (not initialized)
                                     (let
                                        ((comps nil)
                                         (content nil)
                                         (start_time (time_in_millis))
                                         (extension nil))
                                        (setq initialized true)
                                        (setq parent_view view.parentElement)
                                        (setq editor
                                           (ace.edit editor_div))
                                        
                                        ;(log "initialize_editor: " options.mode " options: " (clone options))
                                        
                                        ;; ensure that the Ace language tools extension is loaded
                                        
                                        (defglobal LangTools (-> ace `require "ace/ext/language_tools"))
                                        
                                        ;; if we are not explicitly told to link to another editor...
                                        ;; we need to check to ensure we are not editing a path or file that is already
                                        ;; open by another editor.
                                        
                                        ;; is there already an editor with the same path or filename?
                                        ;; if so, become a linked editor to it
                                        
                                        (when (not options.clone_with_editor_id)
                                           (cond
                                              (and options.path
                                                 (> (get_editors_for_path options.path) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path options.path)))
                                                 (assert primary "initialize_editor: BUG: multiple editors for path but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))
                                              (and options.filename
                                                 (> (get_editors_for_filename options.filename) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path (get_editors_for_filename options.filename))))
                                                 (assert primary "initialize_editor: BUG: multiple editors for filename but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))))
                                           
                                           
                                        ;; are we a cloned editor?
                                        
                                        (when options.clone_with_editor_id
                                           (let ((control_to_clone (get_control_by_id options.clone_with_editor_id))
                                                 (new_session nil))
                                              (if (eq nil control_to_clone)
                                                  (log "editor: cannot find editor to clone, id: " options.clone_with_editor_id))
                                              (when (and control_to_clone
                                                         control_to_clone.editor)
                                                 (= new_session (clone_edit_session control_to_clone.editor.session))
                                                 (= linked_editor control_to_clone.options.id)
                                                 (= linked_editor_name control_to_clone.options.name)
                                                 (-> editor `setSession new_session))))

                                        ;; behavior setup for the actual editor component
                                        (when options.on_focus
                                           (-> editor `on `focus options.on_focus))
                                        (when options.on_blur
                                           (-> editor `on `blur options.on_blur))
                                        (when options.read_only
                                           (-> editor `setReadOnly true))
                                        (when options.on_click
                                           (-> editor `on `click options.on_click))
                                        (unless linked_editor
                                           (-> editor.session `setUseSoftTabs true)
                                           (-> editor.session `setUseWorker true)
                                           (-> editor.session `setUseSoftTabs true))
                                        
                                        (-> editor `setShowFoldWidgets true)
                                        
                                        ;; set the extension if we haven't been given a specific option mode
                                        ;; if we have filename use that to determine what the mode is
                                        
                                        (when (and (eq nil options.mode)
                                                   (is_string? options.filename))
                                           (= comps (split_by "." options.filename))
                                           (when (> comps.length 1)
                                              (= extension (edit_mode_for_extension (last comps)))
                                              (set_prop options
                                                 `mode
                                                 extension)))
                                        
                                        (set_mode options.mode)
                                        
                                        ;; set the theme for the new editor
                                        (cond
                                           (is_string? options.theme)
                                           (setTimeout (fn () (progn
                                                              (-> intf `set_theme options.theme)
                                                              (remove_class "opacity-0" editor_div))) 50)
                                           else
                                           (aif (resolve_path [ `editor `default_theme ] *env_config*)
                                                (setTimeout (fn ()
                                                               (progn
                                                                  (-> intf `set_theme it)
                                                                  (remove_class "opacity-0" editor_div))) 50)))
                                        
                                        ;; build the key bindings
                                        (build_key_bindings editor)
                                        
                                        (-> editor `setOptions {
                                                                 `showFoldWidgets: true
                                                                 `cursorStyle: "wide"
                                                                 `firstLineNumber: (or options.first_line_number 0)
                                                                 `useSoftTabs: true
                                                                 `highlightActiveWord: true
                                                                 })
                                        
                                        ;; if this editor is primary, and not linked to another editor,
                                        ;; get the content from the specified source or path
                                        (if (not linked_editor)
                                            (set_content))
                                               
                                        (cond 
                                           (and options.clone_with_editor_id
                                              (get_control_by_id options.clone_with_editor_id))
                                           (progn
                                              (defvar primary (get_control_by_id options.clone_with_editor_id))
                                              (when primary.group_name
                                                 (set_prop options
                                                    `group_name
                                                    (-> primary `group_name))))
                                           (eq nil options.group_name)
                                           (set_prop options
                                              `group_name
                                              (or options.group_name 
                                                          options.name
                                                          (and (is_array? options.path)
                                                               (last options.path))
                                                          (and (is_string? options.filename)
                                                               (last (split_by "/" options.filename)))
                                                          "Untitled Buffer")))
                                        
                                        (set_name options.group_name)
                                        
                                        ;; set up the default font size
                                        
                                        (if (eq nil font_size)
                                            (= font_size (parseInt (-> editor `getFontSize)))
                                            (-> editor `setFontSize font_size))
                                        
                                        (set_prop options
                                           `font_size
                                           font_size)
                                        
                                        ;; default to overscoll mode, but TODO: this should be an global default
                                        (unless (== options.overscroll false)
                                           (-> editor `setOption `scrollPastEnd true))
                                        
                                        ;; load up the token iterator extension...
                                        (defglobal TokenIterator (prop (-> ace `require "ace/token_iterator") `TokenIterator))
                                        
                                        ;; set up change events for hints and contexual help
                                        
                                        (-> editor `on `change (function (val)
                                                                  (progn
                                                                     (add_class "juno-needs-save" title_span)
                                                                     (= is_dirty? true)
                                                                     (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                                                        (when (not linked_editor)
                                                                           (handle_lisp_format_event val editor))
                                                                        (find_active_lisp_operator))
                                                                     (when (not linked_editor)
                                                                        (dispatch_event { command: "editor_change"
                                                                                          source: options.id
                                                                                          args: [ val ] }))
                                                                     ;(update_position)
                                                                     (when options.on_change
                                                                        (options.on_change editor val)))))
                                        ;; resize
                                        (-> editor `resize true)
                                        ;; reset the undo manager now that th content is loaded
                                        
                                        (unless options.clone_with_editor_id
                                           (try
                                              (aif (-> editor.session `getUndoManager)
                                                   (-> it `reset))
                                              (catch Error (e)
                                                 (log "ERROR on undo manager:" e message))))
                                        
                                        ;; expose the editor in our interface
                                        (set_prop intf `editor editor)
                                        
                                        (when (is_object? options.on_mode_set)
                                           (options.on_mode_set options.mode))
                                        
                                        ;; signal our mode change
                                        
                                        (dispatch_event { command: "editor_change"
                                                          source: options.id
                                                          args: [ { `option: "mode" `value: options.mode } ] })
                                        
                                        ;; scroll speed of the editor
                                        (cond
                                           (is_number? options.scroll_speed)
                                           (set_scroll_speed intf options.scroll_speed)
                                           (is_number? (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                           (progn
                                              ;(log "setting scroll speed: " (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                              (set_scroll_speed intf (resolve_path [ `editor `scroll_speed ] *env_config* )))
                                           else
                                           (set_scroll_speed intf 5))  ;; default scroll speed is 5
                                        
                                        (set_prop options
                                           `scroll_speed
                                           (-> editor `getScrollSpeed))
                                        
                                        ;; when we are linked move to our current position of the other editor
                                        (when linked_editor
                                           (defvar pos (-> (prop (get_control_by_id linked_editor) `editor)
                                                           `getCursorPosition))
                                           (-> editor `navigateTo  pos.row pos.column)
                                           (-> editor `scrollToLine pos.row true nil))
                                        
                                        (push position_history
                                           (-> editor `getCursorPosition))
                                        
                                        (when options.on_initialized
                                           (options.on_initialized intf))
                                        (attach_event_listener view
                                           `keyup
                                           (function (e)
                                              (progn
                                                 (update_position))))
                                        
                                        (if (== options.display_control_bar false)
                                            (set_display_control_bar false))
                                        
                                        (attach_event_listener nav_forward_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_forward_in_position))))
                                        
                                        (attach_event_listener nav_back_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_backward_in_position))))
                                        
                                        ;; setup the evaluator if it is ready
                                        (setTimeout (fn ()
                                                       (let
                                                          ((count 10)
                                                           (evaluator_control nil))
                                                          ;; unless we have been explicitly given an evaluator, use the system repl
                                                          (if options.evaluator_id
                                                             (progn
                                                                (= evaluator_control (get_control_by_id options.evaluator_id))
                                                                (while (and (> count 0)
                                                                            (not evaluator_control))
                                                                   (progn
                                                                      (sleep 1)
                                                                      (dec count)
                                                                      (= evaluator_control (get_control_by_id options.evaluator_id))))
                                                                (if evaluator_control
                                                                   (set_evaluator_control evaluator_control)
                                                                   (notify "Unable to set evalator control for the buffer - id not found")))
                                                             (when *system_repl*
                                                                (display_context_message (+ "Evaluator for this buffer is " (prop *system_repl* `name)))
                                                                (set_evaluator_control *system_repl*)))))
                                                    100)
                                        ;(log "initialize_editor: " (clone options.name) (+ ": (" (last_n_chars 5 options.id) "): initialization complete:") (clone options))
                                        intf)))))
           
           (declare (function compute_name_for_control select_evaluator)
                    (global compute_name_for_control select_evaluator))
           (if (not (is_symbol? `$ace_editor))
               (throw TypeError "$ace_editor symbol not found, and is required for this editor."))
           
           (set_style [["height" (+ "calc(100% - " (+ (Math.max 12 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] 
                      editor_div )
           
           (= resize_observer (new ResizeObserver perform_resize))
           (= intf
              {
                `view: view
                `editor: editor  ;; control must be initialized before the editor can be used
                `set: (fn (text)
                         (-> editor `setValue text))
                `get: (fn (text)
                         (-> editor `getValue))
                `get_selection: get_selection_object
                `get_selected_text: get_selected_text
                `get_last_bracket_match: (fn ()
                                            last_bracket_match)
                `is_selected?: is_selected?
                `group_name: (fn ()
                                  options.group_name)
                `type: `text_editor
                `can_hide?: (fn ()
                               (progn
                                  ;(log "editor: can_hide? " (get_editors_for_path options.path) "<= 1 can hide" options.path)
                                  (< (length (get_editors_for_path options.path)) 2)))
                
                `set_display_control_bar: set_display_control_bar
                `on_destroy: (fn ()
                                (progn
                                   (cond
                                      (and options.path
                                         (> (length (get_editors_for_path options.path)) 1)
                                         (-> intf `get_linked))
                                      true  ;; in this case we are a linked editor so we are only really removing a view, not the primary editor control
                                      (not is_dirty?)
                                      true
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" } 
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         ;(log (+ "editor: " options.name ": user response: ") response)
                                         response))))
                `destroy: (fn ()
                             (when editor
                                
                                (defvar others_and_me (if options.path
                                                          (get_editors_for_path options.path)
                                                          []))
                                (defvar my_path (clone options.path))
                                ;(log "editor: " options.name ": got destroy..dispatching event: others and me: " others_and_me.length (< others_and_me.length 2))
                                ;(log "editor: remaining editors for path: " (each (get_editors_for_path options.path) `options))
                                (dispatch_event { `command: "destroy_control" `source: options.id `args: [  ]  })
                                (-> editor `destroy)
                                (= editor nil)
                                ;; effectively de-register ourselves from the group of editors
                                (set_prop options
                                   `path
                                   nil
                                   `group_name
                                   nil
                                   `filename
                                   nil)   
                                (= intf nil)
                                (when my_path
                                   (rename_editor_group my_path))))
                `set_evaluator: (fn (new_evaluator)
                                   (when (is_function? new_evaluator)
                                      (set_evaluator new_evaluator)))
                `set_evaluator_control: set_evaluator_control
                `get_evaluator: (fn ()
                                   evaluator)
                `needs_save?: (fn ()
                                (and (not options.repl_mode)
                                     is_dirty?))
                `set_mode: set_mode
                `get_mode: (fn ()
                              options.mode)
                `set_theme: set_theme
                `set_overscroll: set_overscroll
                `split_vertical: (fn ()
                                    (split_editor `vertical))
                `split_horizontal: (fn ()
                                     (split_editor `horizontal))
                `display_context_message: display_context_message
                `get_evaluator: (fn ()
                                   evaluator)
                `get_position_detail: (fn ()
                                         { current: (-> editor `getCursorPosition)
                                           idx: position_history_idx
                                           history: position_history
                                         })
                `step_backward_in_pos_history: go_backward_in_position
                `step_forward_in_pos_history: go_forward_in_position
                `resize: (fn ()
                            (perform_resize))
                `bind_key: bind_key
                `key_bindings: (fn ()
                                  (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor))
                `save: (function ()
                          (request_save))
                `on_save_complete: (function (event_obj)
                                      (save_complete event_obj))
                `increase_font_size: increase_font_size
                `decrease_font_size: decrease_font_size
                `menu_items: menu_items
                `get_active_lisp_operator: (fn ()
                                              (find_active_lisp_operator))
                `set_read_only: set_read_only
                `get_current_pos: (fn ()
                                     (current_position))
                `set_editor_option: (fn (editor_option_name value)
                                       (when (is_string? editor_option_name)
                                          (-> editor `setOption editor_option_name value)))
                `options: options
                `set_evaluator_control: set_evaluator_control 
                `on_focus: (if options.disallow_control_focus
                              nil
                              on_focus)
                `name: options.name
                `set_name: set_name
                `get_linked: (fn ()
                                options.clone_with_editor_id)
                `set_linked: (fn (id)
                                (set_prop options
                                   `clone_with_editor_id
                                   id))
                `set_unlinked: (function ()
                                  (progn
                                     (= linked_editor nil)
                                     (delete_prop options
                                                  `clone_with_editor_id)
                                     options))
                
                `toJSON: (function ()
                            (progn
                               (set_prop options
                                  `content
                                  (-> editor `getValue))
                            `(text_editor ,#options)))
                `initialize: (fn ()
                                (when view.parentElement
                                   (console.log "editor: performing initialization")
                                   (-> resize_observer `observe view.parentElement)
                                   (try
                                      (initialize_editor)
                                      (catch Error (e)
                                         (log "ERROR on init: " e.message))))) }))))              
  
(defun select_evaluator ()
  (let
      ((idx -1)
       (dups (new Set))
       (new_name nil)
       (selected_idx nil)
       (available (reduce (control (flatten (control_tree $root_controls)))
                          (when control.evaluate
                            (if (-> dups `has (or control.name "Untitled"))
                              (progn
                               (= new_name (+ (or control.name "Untitled")
                                             "-" idx))
                               (-> dups `add new_name)
                               [ (inc idx) new_name
                                 control ])
                              (progn
                               (-> dups `add control.name)
                               [ (inc idx) control.name control ])))))
       (selection_box (select { }
                              (map (fn (v)
                                     (option { `value: v.0 } v.1))
                                     (or available [])))))
    (= selected_idx
       (request_user_input (dtext "Select an available evaluator")
                           nil
                           { input: selection_box }))
    (when selected_idx
        (prop (prop available selected_idx) 2))))
