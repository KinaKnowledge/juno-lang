; editor overhaul buffer




(defun evaluate_and_replace_at_point (options)
   (let
      ((ctl *last_focus*))
      (cond
         (== ctl.type "text_editor")
         (progn
            (focus_to_editor ctl)
            (eval_selected_text_in_place ctl
                                         (+ {} 
                                            (if (not (eq nil options.discard_nil_values))
                                                { discard_nil_values: options.discard_nil_values }
                                                { discard_nil_values: true })
                                            (if options.append
                                                { append: true }
                                                {}))))))
   {
       `description: (+ "Using the control in `*last_focus*`, calls the eval_selected_text_in_place function "
                        "with the provided options.  The result of the evaluation will be placed into "
                        "the focused editor, either as replaceement text or appended text.<br>"
                        "The link is http://kinaknowledge.com."
                        "<br>### Options<br>"
                        "discard_nil_values:boolean - If true any nil values will not be placed into "
                        "the editor.  If false, the user will be prompted to place nil values into "
                        "the text.  The default is true.<br>"
                        "append:boolean - If true, the result of the evaluation will be appended into "
                        "the editor at the point of the cursor, or if text is selected in the editor, "
                        "after the selection.<br>")
       `usage: ["options:object"]
       `tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })
{ name: "inline-link"  ;;\\\\((\\\\b(https?|ftp|file):\\\\/\\\\/[-A-Z0-9+&@#\\\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\\\/%=~_|])[ ]?[\"]?([a-z 0-9\\\\w]+)?\"]?\\)
                       regex: (new RegExp "\\\\[([ 'a-z 0-9 \\\\-]+)\\\\][ ]?" `gi)
                       exec: (fn (value full_regex_match)
                                (when false 
                                   (log "link match: " full_regex_match)
                                   (if full_regex_match.1
                                      (a (+ { `_target: "_blank" `href: (-> full_regex_match.2 `substr 1) }
                                            (if full_regex_match.3
                                               { `title: (-> full_regex_match.4 `substring 1 (- (length full_regex_match.4) 2)) }
                                               {}))
                                         (-> full_regex_match.1 `substring 1 (- (length full_regex_match.1) 1 )))
                                      "BAD LINK"))) }                                                
(set_key_binding "global"
                 "evaluate_and_replace_at_point"
                 {
                   mac: "Command-R"
                   win: "Alt-R"
                   description: "Evaluate the selected text, or text prior to the form and replace with the results if not nil"
                   exec: (fn ()
                            (evaluate_and_replace_at_point))
                   })

(set_key_binding "global"
                 "evaluate_and_append_at_point"
                 {
                   mac: "Command-Shift-R"
                   win: "Alt-R"
                   description: "Evaluate the selected text, or text prior to the form and append with the results if not nil"
                   exec: (fn ()
                            (evaluate_and_replace_at_point { `append: true }))
                   })


(-> ace.config `set `basePath "/files/js_lib")

;; the global keyword_mapper routes to the currently focused
;; editor for the local keyword_mapper to that editor and the
;; environment it might be connected to

(defun_sync keyword_mapper (token)
   (progn
      (defvar details nil)
      (defvar rval
         (cond
            (and *last_focus*
               (prop *last_focus* `keyword_mapper))
            (-> *last_focus* `keyword_mapper token)
            (contains? token *formatting_rules*.keywords)
            "keyword"
            (progn
               (setq details
                     (first (meta_for_symbol token true)))
               details.type)
            (lowercase details.type)
            else
            "identifier"))      
      rval))


(defun unpack_description (description options)
   (let
      ((header_size_lookup [nil h1 h2 h3 h4 h5 h6])
       (regex_list [{ name: "code"
                       regex: (new RegExp "(`[a-z A-z0-9*?_%!\\-@\\$\\(\\)]+`)" `g)
                       exec: (fn (value full_regex_result)
                                (progc
                                   (defvar rval (code {} (-> value `substr 1 (- (length value) 2))))
                                   ;(log "code: value: " (-> value `substr 1 (- (length value) 2)) "rval: "  (as_lisp (element_to_lisp rval)))
                                   rval))}
                    { name: "table" 
                      regex: (new RegExp "(^[`a-zA-Z\\(\\)0-9?_*\\-]+):([`*a-z\\(\\) A-Z0-9]+)[ ]*-[ ]*(.+)")
                      exec: (fn (match_text tbl_row)
                               (progn
                                  ;(log "table: " match_text)
                                  (if options.edit_mode
                                     [(+ tbl_row.1 ":" tbl_row.2 "-") (process_regex tbl_row.3)]
                                     (when (not (blank? match_text))
                                        (div { `style: "display: flex; align-items: flex-end; flex-wrap: wrap; gap: 16px; border-bottom: 1px solid var(--main-accent-line);" }
                                             (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.1)
                                             (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.2)
                                             (div { `style: "align-self: flex-start; padding: 5px; flex-grow: 1; flex-basis: 400px;"} (process_regex tbl_row.3))))))) }
                     { name: "header" 
                       regex: (new RegExp "^([#]{1,6})[ ]+(.+)")
                       exec: (fn (value full_regex_result)
                                (progn
                                   (defvar header_section (first full_regex_result)) ;; pull it out of the array to make it easier to work with
                                   (defvar header_tag (or (prop header_size_lookup (length (prop full_regex_result 1)))
                                                     h5))
                                   (header_tag
                                      (prop full_regex_result `2)))) }
                     { name: "link"
                       regex: (new RegExp "(\\\\b(https?|ftp|file):\\\\/\\\\/[-A-Z0-9+&@#\\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\\\/%=~_|])" `ig)
                       exec: (fn (value full_regex_match)
                                (progn
                                   ;(log "link match: " value full_regex_match)
                                   (if value
                                      (a { `_target: "_blank" `href: value }
                                         value)
                                      "BAD LINK"))) }
                     { name: "horizontal_line" 
                       regex: (new RegExp "^(---[ ]*)$" `g)
                       exec: (fn (value)
                                (progn
                                   (hr))) }
                      ])
       (pre_section nil)
       (process_regex (fn (text_section)
                         (let
                            ((results [])
                             (replacement nil)
                             (ctext text_section)
                             (idx ctext.length)
                             (overlap_key nil)
                             (overlap_struct nil)
                             (split_list [])
                             (action_list [])
                             (overlaps {})
                             (acc [])
                             (comps nil))
                            ;(log "process_regex: -> " text_section)
                            (for_each (cmd regex_list)
                               (progn
                                  (= comps (scan_str cmd.regex ctext))
                                  (for_each (comp comps)
                                     (push split_list 
                                        { comp: comp
                                          pos: comp.index
                                          length: comp.0.length
                                          cmd: cmd
                                           }))))
                            ;; now we have a list of the changes to be made to the text chunk 
                            ;(log "split_list: " split_list)
                            (for_each (r1 split_list)
                               (for_each (r2 split_list)
                                  (unless (== r1 r2)
                                      (if (> r1.length r2.length)
                                          (= overlap_struct [[r1.pos (+ r1.pos r1.length)] [r2.pos (+ r2.pos r2.length)]])
                                          (= overlap_struct [[r2.pos (+ r2.pos r2.length)] [r1.pos (+ r1.pos r1.length)]]))
                                      (unless (prop overlaps (as_lisp overlap_struct))
                                         (when (apply range_overlap? overlap_struct)
                                            (set_prop overlaps
                                               (as_lisp overlap_struct)
                                               { 
                                                 parent: (if (> r1.length r2.length)
                                                             r1
                                                             r2)
                                                 child: (if (> r1.length r2.length)
                                                             r2
                                                             r1)
                                                 }))))))
                            (= action_list (reduce (action split_list)
                                              (progn
                                                 (defvar remove false)
                                                 (for_each (v (values overlaps))
                                                    (if (and (== action.pos v.child.pos)
                                                             (== action.length v.child.length))
                                                       (= remove true)))
                                                 (unless remove
                                                    action))))
                                              
                            (= split_list (reverse (sort action_list { `key: [`pos] })))
                            (if (> split_list.length 0)
                                (progn
                                   (for_each (action split_list)
                                      (progn
                                         (defvar end_of_insert (+ action.pos action.comp.0.length)) ;; point of the ctext buffer *after* the splice
                                         (defvar diff (- idx end_of_insert))   ;; text remaining from the end of the match to the idx point(which starts at the end of the ctext segment)
                                         ;(log "*" action.pos end_of_insert idx)
                                         (push acc (-> ctext `substr  end_of_insert diff)) ;; push that into our accumulator (it will be in reverse order)
                                         (push acc (-> action.cmd `exec action.comp.0 action.comp))
                                         (= idx action.pos)))  ;; update our tail end
                                   ;; if we have any remaining text, push it in to the accumulator as it will have no edits
                                   (when (> idx 0)
                                      ;(log "idx is greater than 0: " idx (-> ctext `substr 0 idx))
                                      (push acc (-> ctext `substr 0 idx))))
                                   (push acc text_section)) ;; nothing to update
                            (reverse acc))))
       (desc (progn
                (defvar tmp (eval (or description "")))
                (cond 
                   (is_element? tmp)
                   tmp
                   (and (is_object? tmp)
                        (not (is_array? tmp))
                        (is_string? tmp.description))
                   tmp.description
                   (is_string? tmp)
                   tmp
                   else  ;; not for us
                   tmp)))
       (rr (new RegExp "<-" `g))
       (subsections [])
       (segments (if (is_string? desc)
                     (split_by "```" desc)
                     []))
       (table_section nil)
       (idx -1)
       (header_section nil)
       (header_tag nil)
       (header_size_lookup [nil h1 h2 h3 h4 h5 h6]) ;; pos 0 will never be found, hence nil
       (current_seg 0)
       (total_segs (length segments)))
      (if (is_string? desc)
         (div (+ { `class: "juno-editable" }
                 (if options.edit_mode
                    { `contenteditable: true }
                    {}))
              (for_each (segment segments)
                 (progn
                    (inc idx)
                    (if (== 1 (% idx 2))
                        (pre segment)
                        (for_each (section (split_by "<br>" segment))
                           (progn
                              ;(log (hr))
                              ;(log "unpack_description: section: " section)
                              (div (process_regex section))))))))
         desc))
   {
     ;usage: ["text:string" "options:object"]
     description: (+ "<br><br>Provided a text string as a primary argument, the function will convert "
                     "the text content to a DOM element structure based on a set of default rules, or "
                     "user provided rules.  A DOM element will be returned which can be placed in the "
                     "DOM.<br><br>#### Options   <br><br>This function takes the following "
                     "options:<br>edit_mode:boolean -If true, the returned DOM element will be "
                     "editable; a `contenteditable` attribute will be placed in element "
                     "returned.<br>regex_list:array -If provided, each segment of text that is not "
                     "allocated to a `PRE` element will be evaluated by the regex rules.  When a "
                     "match is found, the associated exec function of the rule will be called with "
                     "the form `(fn (value full_regex_result))` where the `value` is the matched text "
                     "value, and the `full_regex_result` is the full returned regex structure from "
                     "the `scan_str` function.  The return value of the function, typically an "
                     "Element type will replace the matched text.    ")
     })
  
 
    
(defglobal *color_index*
   [ `#817
    `#a35
    `#c66
    `#e94
    `#ed0
    `#9d5
    `#4d8
    `#2cb
    `#0bc
    `#09c
    `#36b
    `#639 ]
   {
     `description: (+ "<br><br>The color index  `*color_index*`  is an array of 12 colors that are in "
                      "12-bit form and provide an easy way to provide distinct colors for data "
                      "visualizations and other applications.   <br>From: "
                      "https://iamkate.com/data/12-bit-rainbow/     <br>By Kate Rose Morley  "
                      "<br><br>---<br><br>  To view them in the REPL:  ``````<br> ")
 })

(unpack_description (prop *desctests* 0))

     })

(defglobal *desctests*
   [ (+ "The text_editor control provides a means for editing text based buffers, and "
                      "can either be used for editing local in-memory content or, for remote files "
                      "when the application is served via HTTP.   The editor can be split into "
                      "multiple views of the same content, provides theming, and color coded markup "
                      "capabilities.  Additionally, key sequences can be used either in the scope of "
                      "the editor, or via global scope.  It can adapt well to being a sub-control, and "
                      "has a large number of options to enable higher fidelity between serialization "
                      "and deserialization cycles.        <br>---<br>    This control serves as a "
                      "wrapper around a third party library, the Ace Editor.  The control abstracts "
                      "certain Ace editor functionality as part of the control\'s interface.     "
                      "<br>#### Ace Editor    <br>    The underlying text editor library used for this "
                      "control is the Ace Editor.  The documentation for this library is available "
                      "here:  https://ace.c9.io/  .  Certain underlying functions have been elevated "
                      "and exposed at the top level control interface for purposes of the design and "
                      "implementation of the text_editor control.  Direct access to the Ace editor "
                      "instance and its functionality is via the  `editor`  key in the control\'s "
                      "interface. Since this control uses a third party library underneath, any "
                      "underlying state not captured directly in the controls options object will be "
                      "lost when serialized.  A project objective is to build out the interface for "
                      "this control toward a more idiomatic and \"lisp-like\" interface.   The exposed "
                      "functionality should be expected to be able to save state and restore, unless "
                      "otherwise noted.      <br>#### Modes   <br>    The editor operates in a \"mode\", "
                      "which allows for specific behaviors relevant for the type and purpose of the "
                      "content being edited.  There are several modes that are prebuilt into the "
                      "editor: Juno/Lisp, Javascript, CSS, and plain text.  Additional modes can be "
                      "constructed and made available to the environment that then can be utilized by "
                      "the text_editor control.  Modes can be selected at creation time and during "
                      "run-time.    The mode is indicated visually by the \"Current Editing Mode\" title "
                      "bar text, located to the far right on the default title bar.  The  "
                      "`(get_mode)`   function can be used in the control\'s interface, which is called "
                      "with zero arguments.  The mode can be changed by the user in the control\'s "
                      "command menu, where the user can select via the Set Edit Mode sub menu.   The "
                      "Controls interface exposes the   `set_mode`   function, where a string that is "
                      "equal to the mode name is given as an argument.  The names of the built-in "
                      "modes are as follows:    ```[ `juno `javascript `text `css `json ]```<br>   "
                      "Each element in the array can be used to supply set_mode.  Presently, the only "
                      "custom mode is Juno, which calls back into the Lisp environment for context    "
                      " <br>### Launch Options   <br>    Options provided to the function allow for "
                      "modification of behaviors and specific functionality to be enabled or disabled "
                      "at the time of the controls creation.  " )
    (+ "The color index  `*color_index*`  is an array of 12 colors that are in "
                      "12-bit form and provide an easy way to provide distinct colors for data "
                      "visualizations and other applications.   From:  "
                      "https://iamkate.com/data/12-bit-rainbow/     By Kate Rose Morley   <br>---<br> "
                      " To view them in the REPL:  ``````<br>   ")
     (+ "Given a control with an editor, the selected text is evaluated using the "
                   "editors evaluator.  The evaluated selection is replaced with the "
                   "result.<br>#### Options<br>append:boolean - If true, the selected value isn\'t "
                   "replaced but the result of the evaluation is placed into the editor at the "
                   "cursor\'s position.<br>discard_nil_values:boolean - If true, a nil value "
                   "(undefined or nil) will not be placed into the editor\'s text.  Otherwise, if a "
                   "nil value is returned the user will be prompted to place the nil result in the "
                   "buffer, or discard it.<br>evaluator:function - An optional `evaluator` function "
                   "can be passed to be used as the evaluator instead of the controls default "
                   "evaluator.<br>as_json:boolean - If true, the result will be placed as formatted "
                   "JSON into the editor.  The default is to place the result in formatted Juno "
                   "notation.<br>my_opt:test - If this is true, then cool!<br>another_thing - "
                   "Yay!<br>#### Examples<br><br><br><br><br>```This is some fixed text.\nAnd some "
                   "more.\nAdditional formatted code.\n```<br><br><br><br><br><br><br><br><br><br>OK "
                   "some regular text. <br>And were back with some more items  ")
     (+ "<br><br>Provided a text string as a primary argument, the function will convert "
                     "the text content to a DOM element structure based on a set of default rules, or "
                     "user provided rules.  A DOM element will be returned which can be placed in the "
                     "DOM.<br><br>#### Options   <br><br>This function takes the following "
                     "options:<br>edit_mode:boolean -If true, the returned DOM element will be "
                     "editable; a `contenteditable` attribute will be placed in element "
                     "returned.<br>regex_list:array -If provided, each segment of text that is not "
                     "allocated to a `PRE` element will be evaluated by the regex rules.  When a "
                     "match is found, the associated exec function of the rule will be called with "
                     "the form `(fn (value full_regex_result))` where the `value` is the matched text "
                     "value, and the `full_regex_result` is the full returned regex structure from "
                     "the `scan_str` function.  The return value of the function, typically an "
                     "Element type will replace the matched text.    ")
     (+ "<br><br>Provided a text string as a primary argument, the function will convert "
                     "the text content to a DOM element structure based on a set of default rules, or "
                     "user provided rules.  A DOM element will be returned which can be placed in the "
                     "DOM.<br><br>#### Options   <br><br>This function takes the following "
                     "options:<br>edit_mode:boolean -If true, the returned DOM element will be "
                     "editable; a `contenteditable` attribute will be placed in element "
                     "returned.")])
     
(defun new_buffer (options)
  (let
      ((options (cond
                   (is_array? options)
                   { `path: options `mode: "juno"}
                   (is_object? options)
                   (+ (if options.filename
                          {}
                          { `mode: `juno })
                      options)  ;; if options has mode specified and we don't have a filename, it will override the default juno mode
                   (is_string? options)
                   { `path: [ options ] `mode: "juno" }
                   else
                   { `mode: "juno" }))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (new_control nil)
       (symbol_data (if options.path
                        { `path: options.path `namespace: (or options.namespace (current_namespace)) }
                        (symbol_chooser "Select a symbol to edit" options.mode)))
       (extension (cond 
                     options.filename
                     (last (split_by "." options.filename))
                     (== options.mode "dom")
                     "dom"
                     else
                     "juno"))
       (target_ns symbol_data.namespace)
       (target_env nil))
      (log "new_buffer: for: " options target_ns extension symbol_data)
      
    (when target_ns
      (= target_env (-> Environment `get_namespace_handle symbol_data.namespace)))
    (when (and target_env (eq nil (resolve_path symbol_data.path target_env.global_ctx.scope)))
       (make_path symbol_data.path target_env.global_ctx.scope ""))
    
    (when symbol_data.path
       (= new_control
          (if (== extension `dom)
              (DOM_editor (+ { rules: [ `*markdown_rules* ] `hide_control_bar: false debug: false } options))
              (text_editor (+ { name: (last symbol_data.path) namespace: target_ns path: symbol_data.path mode: options.mode } options ))))
      (cond
         (is_top_control? target_container)
         (container_view_operation "split_right" 
                                   (first (-> target_container `controls))
                                   new_control)
         else
         (swap_control target_container 
                       new_control))
      (sleep 0.1)
      (set_focus_to new_control)))
  {
      `description: (+ "Opens a new editor, if possible, in the currently focused control.  If necessary, it may "
                       "split the view to the right for the new editor.  If no options are provided, the user "
                       "will be prompted for a symbol to edit.  Options can be: <br>"
                       "string: is considered a symbol name and the function will open or create the " 
                       "specified symbol in the current namespace global context.<br>"
                       "array: is considered a path to access, and if the path is present will open the path.  If not, "
                       "will attempt to create the final value in the path as a string for editing.<br>"
                       "object: if an object, the object can contain:<br>"
                       "  path: array: the path to the symbol to be edited.  If the final path segment doesn't exist "
                       "it will create it.<br>"
                       "  namespace: string: the namespace to use for accessing the provided path.<br>"
                       "  mode: the mode to open the editor in. The default mode is Juno.<br>")
      `tags: ["editor" "edit" "buffer" "control"]
      `usage: ["options:object?"]
  })



(defun edit_file (options)
   (let
      ((options (cond 
                   (and (is_object? options)
                        options.filename)
                   options
                   (and (is_object? options)
                        options.create_mode)
                   (+ {} 
                      options
                      { filename: (wait_for_file_selection true) })
                   else
                    (progn
                       {
                           filename: (wait_for_file_selection)
                       })))
       (symbol_path (cond
                       (is_array? options.path)
                       options.path
                       (is_string? options.filename)
                       (conj ["filesystem"] (split_by "/" options.filename))))
       (rval nil)
       
       (data_to_save (or options.initial_data ""))
       (acc []))
      (if (eq options.filename nil)
          (return nil))
      (if (eq nil extension)
          (log (+ "edit_file: extension for " options.filename "is nil: assuming .juno")))
      
      (assert (and symbol_path options.filename) "Invalid options to edit_file")
      
      ;; if we are given a create mode, make the shell of a file
      (if (and options.create_mode
               (> (length data_to_save) 0) )
         (try
            (progn
               (= rval (http/send_files "/save_file" (http/data_to_file options.filename data_to_save "text/plain")))
               (if (and rval
                        (== rval.rval "OK"))
                   (log "Created empty file: " options.filename)
                   (throw Error rval.message)))
            (catch Error (e)
               (progn
                  (alert_box (dtext "Unable to Create File")
                             (+ "" options.filename ": "
                                e.message))
                  (set_prop options
                             `filename
                             nil)))))
            
      (if (eq options.filename nil)
          (return nil))
      
      (if (and (starts_with? "filesystem" symbol_path)
               (eq nil (resolve_path symbol_path Environment.global_ctx.scope)))
          (progn
             (for_each (comp (chop symbol_path))
                (progn
                   (push acc comp)
                   (set_path acc Environment.global_ctx.scope {})))
             (push acc (last symbol_path))
             (set_path acc Environment.global_ctx.scope "")))
      (set_prop options
         `path
         symbol_path)
      (alert_on_error "File Open Error"
                      (new_buffer options)))
   {
       `description: (+ "If provided an options object with a filename key and file path value, "
                        "the function will attempt to fetch and present that file for editing. "
                        "If an error is encountered, the error will be presented to the user "
                        "in a popup window and nil returned.  If called with no options, the "
                        "function will prompt the user to select a file via a file_tree_browser "
                        "control.  If create_mode is true in the options, then a new file "
                        "creation will be attempted and an editor returned for that.  If a "
                        "new file cannot be created, the user will be warned and nil will "
                        "be returned.")
       `usage: ["options:object"]
       `tags: ["DOM" "ui" "file" "edit" "open"]
   })




(defun wait_for_editor (content)
   (if (get_control_by_name "Description Editor")
       (alert_box (dtext "Open Editor")
                  (dtext "There can be only one description editor open at a time."))
       (new Promise
          (fn (resolve reject)
             (let
                ((result nil)
                 (name "Description Editor")
                 (deditor (DOM_editor { rules: [ `*markdown_rules* ] `content: content `name: name })))
                (defglobal $ed_rval nil)
                (place_control `right deditor)
                (while (and (get_control_by_id deditor.options.id)
                            (is_nil? $ed_rval))
                   (progn
                      (sleep 1)))
                (if (get_control_by_id deditor.options.id)
                    (destroy_control deditor))
                (resolve `(+ ,@$ed_rval)))))))


(defun_sync find_last_paren (editor pos options)
   (try
      (let
         ((pos (or pos (-> editor `getCursorPosition)))
          (stream (indirect_new TokenIterator editor.session pos.row pos.column))
          (done false)
          (opts (or options {}))
          (bracket_qualifier (if (and opts
                                      (is_function? opts.bracket_qualifier))
                                 opts.bracket_qualifier
                                 (function (token)
                                    (== token.type "keyword"))))
          (depth 0)
          (t nil)
          (comps nil)
          (calc_depth (function (val)
                          (progn
                            (= comps (split_by "" val))
                            (while (> comps.length 0)
                              (progn
                                 (= t (pop comps))          
                               (cond 
                                  (or (== t ")")
                                      (== t "]")
                                      (== t "}"))
                                  (inc depth)
                                  (or (== t "(")
                                      (== t "[")
                                      (== t "{"))
                                  (dec depth)))))))
          (start nil)
          (token nil))
         (while (and (not done)
                     (not start))
            (progn
               (= token (-> stream `getCurrentToken))
               (when (bracket_qualifier token)
                  (calc_depth token.value))
               
               (if (eq token nil)
                   (progn
                      (= done true)
                      (break))
                   (progn
                      (if (and  (bracket_qualifier token)
                               (or (== token.value.0 "(")
                                   (== token.value.0 "[")
                                   (== token.value.0 "{")))
                          (progn
                             (if (<= depth 0)
                                 (progn
                                    (= start { row: (-> stream `getCurrentTokenRow)
                                                   column: (-> stream `getCurrentTokenColumn) })
                                    (= done true)
                                    (break)))))))
                       
               (= token (-> stream `stepBackward))))
         (when start
            (-> editor.session `getBracketRange start)))
      (catch Error (e)
         (progn
            (console.error e)
            nil))))


(defun set_edit_mode (control mode_name)
   (let
      ((target_mode (if (is_string? mode_name)
                        (last (split_by "/" mode_name))
                        nil))
       (control (if (and (is_control? control)
                         control.editor
                         (is_function? control.set_mode))
                    control
                    (throw TypeError "set_edit_mode: invalid control provided"))))
      (unless target_mode
         (throw TypeError "set_edit_mode: invalid mode - must be a string"))
      
      (-> control `set_mode mode_name))
   {
     description: (+ "If the provided control is a editor control and given a mode name such "
                     "as `juno` or `markdown`,  will set that control\'s editor to the given editor "
                     "mode if possible. ")
     tags: [`control `editor `mode `ui `modes]
     usage: ["control:object" "mode_name:string"]
   })

(defun is_clipboard_allowed? ()
   (== "granted" (prop (-> navigator.permissions `query { name: "clipboard-write" }) `state)))

(defun_sync select_to_current_form (editor pos options)
  (if editor
    (let
        ((rng (-> editor `getSelectionRange))
         (already_selected? (if (and (== rng.start.row rng.end.row)
                                     (== rng.start.column rng.end.column))
                                false
                                true))
         (cpos (or pos 
                   (if already_selected?
                      (progn
                         (-> editor `navigateTo rng.start.row rng.start.column)
                         (-> editor `getCursorPosition))
                      (-> editor `getCursorPosition)))))
      (when cpos
        (= rng (find_last_paren editor cpos options))
        (when rng
          (-> editor.selection `clearSelection)
          (-> editor.selection `setRange rng)))
      rng)
    nil)
  {
   description: (+ "Given an editor and an optional position { row column }, if possible, "
                   "selects the innermost current form (expression) in the editor and "
                   "returns the range.")
   usage: ["editor:object" "pos:?object"]
   tags: ["editor" "selection" "form" "lisp" "editing" ]
   })



(defun_sync select_root_form (editor pos options)
   (if (and (is_object? editor)
            (is_object? pos))
       (let
          ((last_selection nil)
           (idx 0)
           (current_selection nil))
          ;; start with the current position
          
          (= current_selection (find_last_paren editor pos options))
          
          (while (and (< idx 1000)
                      current_selection
                      (or (eq nil last_selection)
                          (not (and (== last_selection.start.column current_selection.start.column)
                                    (== last_selection.start.row current_selection.start.row)
                                    (== last_selection.end.column current_selection.end.column)
                                    (== last_selection.end.row current_selection.end.row)))))
             (progn
                (inc idx)
                (= last_selection current_selection)
                (= current_selection (find_last_paren editor current_selection.start options))
                (when options
                   (log "select_root_form: idx: " idx current_selection pos))
                ))
          
          (aif current_selection
             {
               `start_row: it.start.row
               `start_col: it.start.column
               `end_row: it.end.row
               `end_col: it.end.column
               })))
   {
     `usage: ["editor:object" "pos:object"]
     `description: "Given an editor and a position, returns the determined root form for the position."
     `tags: ["selection" "editor" "root" "form" "position"]
     })

(defun select_to_root_form (editor pos)
   (if editor
       (let
          ((cpos (-> editor `getCursorPosition))
           (pos (if pos
                    (select_root_form editor pos)
                     (select_root_form editor cpos))))
          (when pos
             (-> editor.selection `clearSelection)
             (-> editor.selection `setSelectionAnchor pos.start_row pos.start_col)
             (-> editor.selection `selectTo pos.end_row (+ pos.end_col 1))
             true))
       (throw TypeError "editor must be provided to select_to_root_form"))
   {
       description: (+ "Given an editor and an optional position, will select the complete form (to a depth of 0) if possible. "
                        "If given a position object with a row and column value, the function will use that instead.  If "
                        "succesful, the value true will be returned.  If no editor is provided, the function will throw a "
                        "TypeError.")
       usage: ["editor:object" "pos:?object"]
       tags: ["editor" "selection" "form" "lisp" "editing"]
   })


            
(defun_sync select_css_rule (editor pos)
   (let
      ((cpos (or pos
                 (-> editor `getCursorPosition)))
       (rng  (select_to_current_form editor cpos { 
                                       bracket_qualifier: (function (token)
                                                             (progn
                                                                (starts_with? "paren" token.type)))
                                       }))
       (stream nil)  ;; we will need to extend to grab the selectors
       (start nil)
       (token nil))
      (when rng
         (= stream (indirect_new TokenIterator editor.session rng.start.row rng.start.column))
         (= token (-> stream `getCurrentToken))
         (= token (-> stream `stepBackward))
         (while (and token
                     (and (not (starts_with? "paren" token.type))
                          (not (== "comment" token.type))))
            (progn
               (= token (-> stream `stepBackward))))
              
         (-> stream `stepForward)
         (= start { row: (-> stream `getCurrentTokenRow)
                    column: (-> stream `getCurrentTokenColumn) })
         (-> editor.selection `setSelectionAnchor start.row start.col)
         (-> editor `getSelectionRange))))

 

(defun evaluate_css_rule_text (text)
   (when (is_string? text)
      (let
         ((comps (split_by "{" text))
          (selector (first comps))
          (body_text (join " " (split_by "\n" (join " " (rest comps))))))
         (if (> selector.length 0)
             (progn
                (= selector (join " " (split_by "\n" (trim selector))))
                (if (ends_with? "}" body_text)
                    (= body_text (chop body_text)))
                (create_css_entry selector
                   (from_style_text body_text)))
             (notify "Cannot determine selector")))))
                
            

(defun evaluate_css_rule (editor pos)
   (let
      ((rng (select_css_rule editor pos))
       (text nil))
      (if rng
         (progn
            (= text (-> editor `getCopyText))
            (evaluate_css_rule_text text)))))


(set_key_binding `global
                 `set_description_text
                 {
                   win: "Alt-E"
                   mac: "Command-E"
                   description: "Edit the description text in the DOM editor"
                   exec: (fn () (edit_description_text))
                   })

{ 
  `description: (+ "Given a control with an editor, the selected text is evaluated using the "
                   "editors evaluator.  The evaluated selection is replaced with the "
                   "result.<br>#### Options<br>append:boolean - If true, the selected value isn\'t "
                   "replaced but the result of the evaluation is placed into the editor at the "
                   "cursor\'s position.<br>discard_nil_values:boolean - If true, a nil value "
                   "(undefined or nil) will not be placed into the editor\'s text.  Otherwise, if a "
                   "nil value is returned the user will be prompted to place the nil result in the "
                   "buffer, or discard it.<br>evaluator:function - An optional \'evaluator\' function "
                   "can be passed to be used as the evaluator instead of the controls default "
                   "evaluator.<br>as_json:boolean - If true, the result will be placed as formatted "
                   "JSON into the editor.  The default is to place the result in formatted Juno "
                   "notation.<br>my_opt:test - If this is true, then cool!<br>another_thing - "
                   "Yay!<br>#### Examples<br><br><br><br><br>```This is some fixed text.\nAnd some "
                   "more.\nAdditional formatted code.\n```<br><br><br><br><br><br><br><br><br><br>OK "
                   "some regular text. <br>And were back with some more items  ")


 }

             
(defun edit_description_text (control)
   (let
      ((ctl (or (and control
                     (== control.type "text_editor"))
                (if (== *last_focus*.type "text_editor")
                    *last_focus*
                    nil))))
      (if ctl
         (let
            ((pos (-> ctl `get_selection))
             (select_pos nil)
             (parent_pos nil)
             (editor ctl.editor)
             (new_text nil)
             (content nil)
             (thing_we_are_in nil)
             (ok_to_proceed true)
             (error_content (div
                              (dtext "To use the Description Text Editor, the description field must be in one of the following forms:")
                              (br)
                              (code "description: nil")
                              (br)
                              (code "description: (+ \"content\")")))
             (text nil))
            
            (select_to_current_form editor)
            (= select_pos (-> ctl `get_selection))
            (= text (-> ctl `get_selected_text))
            
            (= thing_we_are_in (read_lisp text { suppress_throw_on_error: true } ))
            (cond
               (is_array? thing_we_are_in)
               (progn
                  (= parent_pos (find_last_paren editor select_pos.start))
                  (-> editor.selection `clearSelection)
                  (-> editor.selection `setSelectionAnchor parent_pos.start.row parent_pos.start.column)
                  (-> editor.selection `selectTo parent_pos.end.row (+ parent_pos.end.column 0))
                  (= thing_we_are_in (read_lisp (-> ctl `get_selected_text) { suppress_throw_on_error: true } ))
                  
                  (if (and (prop thing_we_are_in `description)
                           (>= select_pos.start.row parent_pos.start.row)
                           (<= select_pos.end.row parent_pos.end.row)
                           (== (eval (prop thing_we_are_in `description)) (eval (read_lisp text)))
                           )
                      (progn
                          (-> editor.selection `clearSelection)
                          (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                          (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column)))
                      (progn
                         (= ok_to_proceed false)
                         (alert_box (dtext "Edit Description Text")
                                    error_content))))
               (and (is_object? thing_we_are_in)
                    (contains? "description:" (trim (-> editor.session `getLine pos.start.row)))
                    (contains? "description" (keys thing_we_are_in))
                    (== thing_we_are_in.description (quote "=:nil")))
               (progn
                  (-> editor `clearSelection)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  (= select_pos (-> editor.session `getAWordRange pos.start.row pos.end.column))
                  (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                  (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column 0))
                  
                  (= text "")
                  (= select_pos pos))
               else
               (progn
                  (= ok_to_proceed false)
                  (alert_box (dtext "Edit Description Text")
                             error_content)))
            (when ok_to_proceed
               (progc
                  (= content  (unpack_description (or (eval (read_lisp (or text ""))) "Empty") { `edit_mode: true })))
               (-> ctl `set_read_only true)
               (= pos (-> ctl `get_selection))
               (= new_text (wait_for_editor content))
               (-> ctl `set_read_only false)
               ;(log "edit_description_text: new_text: " new_text)
               (progc
                  (when (and new_text
                             (second new_text))
                     (= new_text (pretty_print new_text))
                     
                     (-> (-> editor `getSession) `replace pos new_text)
                     (sleep 0.1)
                     ;(-> editor `navigateTo pos.start.row pos.start.column)
                     ;; slow it down so we can watch the fitment..
                     (sleep 0.3)
                     (select_to_current_form ctl.editor)
                     (sleep 0.3)
                     (indent_editor_selection  ctl.editor)
                     (sleep 0.1)))))
         (alert_box (dtext "Edit Description Text")
                    (dtext "The control being used must be a text editor type."))))
   { 
     `description: (+ "<br><br>This function provides an ability to edit the description text of a "
                      "function for easier documentation.  When invoked, if not provided with a "
                      "specific text_editor control, will use the `*last_focus*` control if it is a "
                      "text editor type.   The current cursor position of the editor it is being "
                      "invoked on will be examined, and if it meets certain criteria, the description "
                      "text will be gathered and the description editor pane will pop up providing the "
                      "user the ability to edit the text in a fashion more amenable for writing "
                      "documentation.   <br>Once completed with the description edits, the user can "
                      "press the short cut key for `get_as_wordwrap_text` (default is bound to Alt-X) "
                      "or select the \"Get As Wordwrap Text\" menu item from the control menu.  This "
                      "will close the editor and place the contents of the description editor into the "
                      "source code in the appropriate position and form.  If the contents of the "
                      "description editor are not to be saved back to the text editor, just close the "
                      "editor, either from the menu or by pressing  `Alt-D`  (or the command currently "
                      "associated with the Close Control Command).  See `(show_key_bindings)` in the "
                      "REPL for a table of current globally defined key bindings.<br><br>#### "
                      "Qualifying formats of the Description Field to be Edited  <br><br> The "
                      "description field must either have a value of nil (empty).  In this case, the "
                      "description editor will be empty of content when opened.  In this case the "
                      "field entry would look like: ```{\n   description: nil \n}```<br><br> If the "
                      "description field is already populated with content, it will need to be in the "
                      "form of:  ```{\n  description: (+ \"Content Line\" \"more content\" "
                      "\"...\")\n}```<br><br> This is the format that the Description editor will place "
                      "into the source code when complete.<br><br>---<br><br><br>#### Other Notes "
                      "<br><br> When the Description Editor is invoked and while the user is editing "
                      "text, the text_editor that it is being invoked on is placed into read only mode "
                      "and so cannot be modified until the Description Editor is closed. ")



      `usage: ["control:?object"]
      `tags: ["editor" "description" "metadata" "meta" ] })
                       

(defun process_tree_symbols (tree prefix _ctx)
   (let
      ((is_root (eq nil _ctx))
       (rval nil)
       (_ctx (or _ctx {
                        acc: []
                        allocations: (new Set)
                        symbols: (new Set)
                        keywords: (new Set)
                        literals: (new Set)
                        globals: (new Set)
                        global_detail: {}
                        }))
       (symbol nil)
       (global_details nil)
       (allocator nil)
       (allocations nil)
       (sort_token (fn (t)
                      (progn
                         (= symbol (desym_ref t))
                         (unless (== symbol prefix)
                            (cond
                               (is_array? t)
                               (process_tree_symbols t prefix _ctx)
                               
                               (contains? symbol *formatting_rules*.keywords)
                               (-> _ctx.keywords `add symbol)
                               
                               (progn
                                  (= global_details (meta_for_symbol symbol true) )
                                  (> (length global_details) 0))
                               (progn
                                  (-> _ctx.globals `add symbol))
                               
                               (is_reference? t)
                               (-> _ctx.symbols `add (desym_ref t))
                               (or ;(is_string? t)
                                  (is_number? t)
                                  (== true t)
                                  (== false t)
                                  (== "nil" (desym_ref t)))
                               (-> _ctx.literals `add (+ "" t)))))))
       (format_token (fn (token)
                        {
                            `value: token.name
                            `score: 0
                            `meta: (if (== token.type "arg")
                                       "local"
                                       token.type)
                        })))
      (cond
         (and (is_array? tree)
              (> tree.length 0))
         (progn
            (= allocator (prop *formatting_rules*.allocating_forms (desym_ref (prop tree 0))))
            (if (is_function? allocator)
                 (progn
                    (= allocations (allocator tree))
                    (for_each (allocation allocations)
                       (progn
                          (= symbol (desym_ref allocation))
                          (unless (or (== symbol prefix)
                                      (== symbol "\"&\""))
                             (-> _ctx.allocations
                                `add symbol))))))
                    
            (for_each (`t tree)
               (progn
                  (sort_token t))))
         (is_object? tree)
         (progn
            (for_each (pset (pairs tree))
               (progn
                  (-> _ctx.literals 
                     `add pset.0)   ;; the key
                  (sort_token pset.1))))
         else
         (sort_token tree))
      
      (when is_root
         (= rval {
             allocations: (to_array _ctx.allocations)
             symbols: (to_array _ctx.symbols)
             keywords: (to_array _ctx.keywords)
             literals: (to_array _ctx.literals)
             globals: (to_array _ctx.globals)
             }))
      rval)
   {
       `usage: ["tree:*"]
       `description: (+ "Given a JSON structure, such as produced by the reader, returns an object containing the various determined types of the provided structure:<br>"
                        "allocations:array - All locally allocated symbols<br>"
                        "symbols:array - All identified symbols<br>"
                        "keywords:array - All keywords used in the structure"
                        "literals:array - All identified literals (i.e. not a symbol)"
                        "globals:array - All referenced globals")
       `tags: ["editor" "usage" "scope" "structure" ]
   })
            
(defun make_autocompletion_scores (analysis_object sorted_globals)
   (let
      ((result_set [])
       (keywords (try (compiler `[ true ] { `special_operators: true `env: Environment } )
                    (catch Error (e)
                       (progn
                          (log "error on compiler: " e.message)
                          (new Set)))))
       (included (new Set))
       (score 0))
      (for_each (r (sort analysis_object.allocations))
         (progn
            (-> included `add r)
            (cond
               (contains? r analysis_object.globals)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local (shadowed global)" })
               else
               (push result_set
                  { `value: r `score: (inc score) `meta: "local" }))))
      (for_each (r (sort analysis_object.symbols))
         (cond
            (contains? r analysis_object.allocations)
            true ;; we already placed it 
            else
            (progn
               (-> included `add r)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local?" } ))))
      (for_each (r (sort analysis_object.keywords))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "keyword" })))
      (for_each (r (sort analysis_object.globals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "global" })))
      (for_each (r (sort analysis_object.literals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "literal" })))
      (for_each (r (sort (to_array keywords)))
         (if (not (-> included `has r))
             (progn
                (-> included `add r)
                (push result_set
                   { `value: r `score: (inc score) `meta: "keyword" }))))
      
      (for_each (r (or sorted_globals (sort (to_array (all_globals)))))
         (if (not (-> included `has r))
             (push result_set
                { `value: r `score: (inc score) `meta: "global" })))
      result_set)
   {
       `usage: ["analysis_object:object"]
       `description: (+ "Given the output of process_tree_symbols, returns a result_set to be provided to the Ace autocomplete callback for "
                        "suggestions for autocomplete.")
       `tags: ["editor" "analysis" "autocomplete" "session" "Ace"]
   })



(defun get_juno_autocompletions (editor session pos prefix callback sorted_symbols)
   (let
      ((root_form (select_root_form editor pos))
       (collect_error (fn (e)
                         true))
       (text_data (+ "" (-> editor.session `getTextRange (new ace.Range root_form.start_row root_form.start_col root_form.end_row root_form.end_col)) ")"))
       (tokens (reader text_data { `suppress_throw_on_error: true on_error: collect_error  } )))
      (console.log "get_juno_autocompletions: tokens ->: " tokens) 
      (= tokens (make_autocompletion_scores (process_tree_symbols tokens prefix) sorted_symbols))
      (console.log "get_juno_autocompletions: tokens <-: " tokens) 
      (callback null tokens))
   {
       `usage: ["editor:object" "session:object" "pos:object" "prefix:text" "callback:fn" ]
       `description: "Internally used by the editor for autocompletion."
       `tags: ["ace" "editor" "autocomplete" ]
   })        
            
 (edit_description_text_v1)                      

(defun eval_selected_text_in_place (ctl options)
   (progc
      (let
         ((text nil)
          (pos nil)
          (editor (cond
                      (== ctl.type "text_editor")
                      ctl.editor
                      else
                      (throw TypeError "eval_selected_text_in_place: no text editor for provided control")))
          (selection nil)  ;; range to replace with results
          (evaluator nil)
          (result nil))
         (= pos (-> ctl `get_selection))
         (if (and (== pos.start.row pos.end.row)
                  (== pos.start.column pos.end.column))
             (select_to_current_form ctl.editor))
         ;; we should have an actual selection now if we didn't...
         (= selection (-> ctl `get_selection))
         (= text (-> ctl `get_selected_text))
         (if (blank? text)
             (progn 
                (-> ctl `display_context_message (dtext "Nothing to evaluate at the cursor position")))
             (progn
                (= evaluator
                   (cond
                      (is_function? ctl.get_evaluator)
                      (-> ctl `get_evaluator)
                      options.evaluator_id
                      (progn
                         (aif (prop (get_control_by_id options.evaluator_id)
                                    `evaluate)
                              it
                              nil))))
                (if (is_function? evaluator)
                    (progn
                       (alert_on_error (dtext "Evaluation Error")
                                       (= result (evaluator text false true true)))
                       (if (and (eq nil result)
                                (or options.discard_nil_values
                                    (== "discard" (request_user_choice 
                                                     (+ (dtext "The evaluation result is")
                                                        " "
                                                        (as_lisp result)
                                                        ".  "
                                                        (dtext "Insert or discard the result?"))
                                                     [[(dtext "Insert") "ok"] 
                                                      [(dtext "Discard") "discard"]]
                                                     {
                                                       `no_cancel_button: true
                                                       }))))
                           nil
                           (progn
                              (= result
                                 (cond
                                    (is_object? result)
                                    (if options.as_json
                                       (JSON.stringify result nil 2)
                                       (+ "" (pretty_print (as_lisp result))))
                                    (is_string? result)
                                    result
                                    else
                                    (+ "" (pretty_print (as_lisp result)))))
                              (try
                                 (progn
                                    (if options.append
                                       (progn
                                          (-> editor.selection `clearSelection)
                                          (-> editor `navigateTo pos.end.row pos.end.column)
                                          (set_prop pos.start
                                             `row pos.end.row
                                             `column pos.end.column)
                                          (-> (-> editor `getSession) `replace pos result))
                                       (-> (-> editor `getSession) `replace selection result)))
                                 (catch Error (e)
                                    (progn
                                       (-> (-> editor `getSession) `replace selection text)
                                       (-> ctl `display_context_message (+ "Error on replace: " e.message))
                                       (log (+ (dtext "Couldn't replace text in editor") ":" (prop ctl.options `name) ": " e.message))
                                       (log e)))))))
                    (alert_box (dtext "Evaluation Error")
                               (+ (dtext "No evaluator found for the control")
                                  " "
                                  ctl.options.name)))))))
   {
     description: (+ "Given a control with an editor, the selected text is evaluated " 
                     "using the editors evaluator.  The evaluated selection is replaced with the result."  
                     "<br>#### Options<br>"
                     "append:boolean - If true, the selected value isn't replaced but the result of the "
                     "evaluation is placed into the editor at the cursor's position.<br>"
                     "discard_nil_values:boolean - If true, a nil value (undefined or nil) will not be "
                     "placed into the editor's text.  Otherwise, if a nil value is returned the user "
                     "will be prompted to place the nil result in the buffer, or discard it.<br>"
                     "evaluator:function - An optional 'evaluator' function can be passed to be used " 
                     "as the evaluator instead of the controls default evaluator.<br>"
                     "as_json:boolean - If true, the result will be placed as formatted JSON into the "
                     "editor.  The default is to place the result in formatted Juno notation.<br>")
                     
     usage: ["control:object" "options:?object"]
     tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })


(defun get_primary_editor_in_group (controls)
   (let
      ((primaries (reduce (editor (or controls []))
                      (when (not (-> editor `get_linked))
                         editor))))
      (first primaries)))

(defun get_editors_for_filename (filename)
   (when (is_string? filename)
      (reduce (control (current_controls))
         (when (and control
                    control.editor
                    control.options.filename
                    (== control.options.filename filename))
            control))))
   


(defun rename_editor_group (path)
   (try 
      (let
         ((editors (get_editors_for_path path))
          (primary_id nil)
          (primary (reduce (editor (or editors []))
                      (when (not (-> editor `get_linked))
                         editor))))
         (assert (not (> primary.length 1)) "rename_editor_group: multiple primary editors. This is a bug.")
         (= primary (first primary))  ;; take the primary editor or nil 
         (cond 
            (== editors.length 0)
            true ;; nothing for us to do
            (== editors.length 1)
            (progn
               (-> (first editors) `set_unlinked)
               (-> (first editors) `set_name (-> (first editors) `group_name) true))
            else
            (progn
               (unless primary                ;; unless we already have a primary...
                  (= primary (take editors))) ;; take the first editor and make it the primary
               (= primary_id primary.options.id)
               (-> primary `set_name (-> primary `group_name) true)
               (-> primary `set_unlinked)
               (for_each (editor editors)
                  (when (not (== editor primary))
                     (-> editor `set_linked primary.options.id)
                     (-> editor `set_name (-> primary `group_name)))))))
      (catch Error (e)
         (log "rename_editor_group: error: " e.message))))

(defun clone_text_editor_control (editor_control)
   (let
      ((id editor_control.options.id)
       (new_name (if editor_control.group_name
                     (-> editor_control `group_name))))
      (declare (function text_editor)
               (global text_editor))
      (assert new_name "clone_text_editor_control: unable to get group name of the editor to clone")
      (when (and editor_control.editor id)
         (alert_on_error "Unable to clone the editor"
                         (text_editor (+ {} ;; start options 
                                         editor_control.options ;; take existing options..
                                         { `id: (gen_id "text_editor")
                                           `clone_with_editor_id: id }))))))

(defun symbol_map_for_buffer (source_name source debug?)
   (let
      ((symbol_locations {}))
      (log (+ "symbol_map_for_buffer: running: " source_name))
      (reader source
         { source_name: source_name
           suppress_throw_on_error: true 
           verbose: debug?
           symbol_receiver: (fn (syms)
                               (= symbol_locations syms)) })
      symbol_locations)
      {
        description: (+ "Given a source file name and a source text, returns an object "
                        "containing the symbols defined and used by the source text and their locations "
                        "in the source text.  <br>The output format is an object:<br>source_name:string "
                        "- The name of the provided source file<br>symbols:object - An object with keys "
                        "corresponding to the discovered symbols, each with an array with 4 components: "
                        "`[ row column operator_chain position_chain ]`.  Row and column are the "
                        "location of the symbol instance in the file.  The operator chain is the chain "
                        "of operators (or keys) leading up to the root of the form the symbol appears "
                        "in.  The position chain is the offsets within the forms, with each period `.` "
                        "referring to another depth level as constructed via `(`, `[` or `{`.  These "
                        "latter two elements are used by the principal consumer of this functions "
                        "output, `find_symbol_definition` to help determine the source of a particular "
                        "symbol in the editor.<br>")
        usage: ["source_name:string" "source:string"]
        tags: ["symbol" "scope" "define" "allocation" "symbols" "buffer"]
        })





(defvalue *ace_option_description*
   { editor: {
        hScrollBarAlwaysVisible: `boolean
        vScrollBarAlwaysVisible: `boolean
        highlightGutterLine: `boolean
        animatedScroll: `boolean
        showInvisibles: `boolean
        showPrintMargin: `boolean
        printMarginColumn: `number ; (defaults to 80)
        fadeFoldWidgets: `boolean
        showFoldWidgets: `boolean ; (defaults to true)
        showLineNumbers: `boolean ; (defaults to true)
        showGutter: `boolean ;(defaults to true)
        displayIndentGuides: `boolean ; (defaults to true)
        }
      session: {
         firstLineNumber: `number
         overwrite: `boolean
         newLineMode: [ "auto" "unix" "windows" ]
         useSoftTabs: `boolean
         tabSize: `number
         foldStyle: [ "markbegin" "markbeginend" "manual"]
         }
      }
     {
         description: (+ "Object whose keys are the options and the values " 
                         "describe the data type of the option for the text_editor "
                         "control, which uses the Ace editor.")
         tags: ["editor" "options" ]
     })


(function (ctl)
   (try
      (-> (getComputedStyle (-> ctl.view
                                `querySelector ".ace_content"))
          `getPropertyValue "font-family")
      (catch Error (e)
         "")))

(defun editor_options (ctl)
   (let
      ((editor (if (and (is_control? ctl)
                        ctl.editor)
                   ctl.editor
                   (throw TypeError "editor_options: requires a control with an editor as an argument")))
       (to_opts (fn (path)
                   (to_object
                      (for ((opt_name data_type) (pairs (resolve_path path *ace_option_description*)))
                           [(from_mixed_case opt_name)
                                      (or (-> editor `getOption opt_name)
                                          (cond
                                             (is_function? data_type)
                                             (data_type ctl)
                                             (== data_type `boolean)
                                             false
                                             (== data_type `string)
                                             ""
                                             (== data_type `number)
                                             0
                                             else
                                             nil))
                                          ]))))
       (current_value nil))
      
      { editor: (to_opts [ `editor ])
        session: (to_opts [ `session ]) }
         )
   {
     description: (+ "The function `editor_options` processes option keys in `*ace_editor_options*` and "
                     "retrieves the present value, or, if the value is undefined, returns a default "
                     "based on the type value in `*ace_editor_options*.  It handles the conversion of "
                     "mixed case format to snake-case and returns an object that represents the "
                     "current state of editor options listed in the `*ace_editor_options*` "
                     "variable.<br>")
     tags: ["editor" "options"]
   })

(defun show_editor_options (ctl)
   (let
      ((opts (editor_options ctl))
       (dwin nil)
       (set_as_defaults_button (button { } (dtext "Save as Defaults")))
       (close_button (button { `style: "float: right" }  (dtext "Close")))
       (special_paths {})
       (editor ctl.editor)
       (on_change (function (category path val)
                     (try
                        (progn 
                           (cond
                              (== category "editor")
                              (progn 
                                 (-> editor `setOption (to_mixed_case (last path)) val))
                              (== category "session")
                              (-> editor.session `setOption (to_mixed_case (last path)) val))
                           val)
                           (catch Error (e)
                              (progn
                                 (notify (+ "Unable to set option: " (last path) ": " e.message))
                                 nil)))))
       (set_as_defaults (fn ()
                           (try
                              (progn
                                 (unless (resolve_path [ `editor `editor_defaults ] *env_config*)
                                    (make_path [ `editor `editor_defaults ] *env_config* {}))
                                 (unless (resolve_path [ `editor `session_defaults ] *env_config*)
                                    (make_path [ `editor `session_defaults ] *env_config* {}))
                                 (for ((key val) (pairs opts.editor))
                                      (set_path [ `editor `editor_defaults key ] *env_config* val))
                                 (for ((key val) (pairs opts.session))
                                      (set_path [ `editor `session_defaults key ] *env_config* val))
                                 (log *env_config*)
                                 (notify "Set As Editor Defaults"))
                              (catch Error (e)
                                 (notify (+ "Cannot set defaults: " e.message)))))))
                              
      (traverse *ace_option_description*
         (function (val path)
            (if (is_array? val)
                (make_path (conj 
                                 (for_each (pseg path)
                                    (from_mixed_case pseg))
                                 `values)
                           special_paths
                           val))))
      (= dwin (floating_div 
                 (div { `class: "juno-form" } 
                      (h4 (dtext "Options"))
                      (br)
                      (div { `class: "juno-form-data" `style: "flex-grow: 1; overflow-y: auto; overflow-x: auto; "}
                           (h4 (dtext "Editor"))
                           (value_to_dom opts.editor
                                         {
                                           `editable: true
                                           `expand_all: true
                                           `disable_object_toggle: true
                                           `pretty_keys: true
                                           `on_change: (function (path val)
                                                          (on_change `editor path val))
                                           
                                            paths: special_paths.editor
                                         })
                           (hr { `style: "width: 100%;" })
                           (h4 (dtext "Session"))
                           (value_to_dom opts.session
                                         {
                                           `editable: true
                                           `expand_all: true
                                           `disable_object_toggle: true
                                           `pretty_keys: true
                                           `on_change: (function (path val)
                                                          (on_change `session path val))
                                             paths: special_paths.session
                                         }))
                      (div { `style: "margin-top: 10px" }
                           set_as_defaults_button close_button))
                 {
                   `title: "Editor Options"
                   `position: {
                       left: 10
                       top: 10
                       height: (int (/ window.innerHeight 3))
                   }
                   `controls: true
                   }))
      (attach_event_listener set_as_defaults_button
         `click
         (fn ()
            (set_as_defaults)))
      
      (attach_event_listener close_button
         `click
         (fn ()
            (-> dwin `close))))
      {
        `description: (+ "Given an editor control, presents a floating window that allows the "
                         "options listed in `*ace_editor_options*` to be modified for the given editor.  "
                         "This utility also allows the settings to be set as defaults, by setting the "
                         "appropriate path in `*env_config*`.<br> ")
         tags: ["editor" "options" "DOM"]
         usage: ["control:object"]
      })


(defun display_pos_details (control)
   (when control.get_position_detail
      (let
         ((update_timer nil)
          (pos nil)
          (opts { `columns: [ "pointer" "idx" "row" "column" ] })
          (ctable (dtable [] opts))
          (update (fn ()
                     (progn
                        (= pos (-> control `get_position_detail))
                        (defvar nctable (dtable (map (fn (row idx tlen)
                                                        [(if (== pos.idx idx)
                                                             "->" "")
                                                         idx
                                                         row.row
                                                         row.column])
                                                     pos.history)
                                                opts))
                        (-> ctable `replaceWith nctable)
                        (= ctable nctable))))
                                          
          (view (floating_div
                   (div { }
                        ctable)
                   {
                       `on_close: (fn ()
                                     (progn
                                        (log "clearing timer")
                                      (clearInterval update_timer)))
                   })))
          (= update_timer
             (setInterval update 1000))
          true)))
         
;; if given a current pos and form, can also find the local definition
;; otherwise will only return the global definition
(defun find_symbol_definition (symbol symbol_map current_pos root_form)
   (if (and symbol symbol_map)
       (let
          ((locations (resolve_path [`symbols symbol ] symbol_map))
           (def_locs [])
           (prior_sym nil)
           (last_chain nil)
           (in_form? false)
           (tmp [])
           (closest nil)
           (closest_symbol_to_pos nil)
           (calc_dist (fn (pos1 pos2)
                         (let
                            ((total_idx (Math.min pos1.length pos2.length))
                             (deltas 
                                (for_each (idx (range total_idx))
                                   (- (prop pos1 idx)
                                      (prop pos2 idx)))))
                            deltas)))
           (cpos (or current_pos nil))
           (root_form (or root_form nil))
           (prior_loc nil)
           (score 0)
           (top_score 0)
           (last_pos_chain_str nil)
           (last_pos_chain nil))
          
          (when (> __VERBOSITY__ 0)
             (log "find_symbol_definition: " locations cpos root_form))
          (if locations
             (progn
                (for_each (locdata locations)
                   (destructuring_bind (row column op_chain pos_chain)
                      locdata
                      (= prior_sym nil)
                      (= last_chain nil)
                      (= last_pos_chain nil)
                      (= in_form? (and root_form 
                                       (>= row root_form.start_row)
                                       (<= row root_form.end_row)))
                      
                      (when (== row cpos.row)
                         (= closest_symbol_to_pos locdata)
                         (set_prop closest_symbol_to_pos
                            3
                            closest_symbol_to_pos.3))
                       
                             
                      (if (> op_chain.length 1)
                          (= prior_sym (last (but_last op_chain))))
                      
                      (= last_chain (last_n 2 op_chain))
                      (= last_pos_chain (last_n 2 pos_chain))
                      (= last_pos_chain_str (join "." last_pos_chain))
                      (= prior_loc (last def_locs))
                     
                      (when (> __VERBOSITY__ 0) 
                         (log "local_defs: " symbol [row column] prior_sym last_chain last_pos_chain locdata in_form?))
                      (cond
                         (contains? (last op_chain) [list "defun" "defglobal" "defun_sync" "defmacro" "defcontrol" "defparameter" "defvalue"])
                         (push def_locs { row: row col: column `type: "global" `chain: pos_chain } )
                         
                         (and in_form?
                            (contains? (first last_chain) [list `defun `defun_sync `defmacro `defcontrol])
                            (== (last op_chain) symbol)
                            (== (last pos_chain) 2))
                         (push def_locs { row: row col: column `type: "named_function_argument" `chain: pos_chain } )
                         
                         (and in_form?
                            (== (first last_chain) `defcontrol)
                            (== (last last_chain) symbol))
                         (push def_locs { row: row col: column `type: "local_let" `chain: pos_chain } )
                         
                         (and in_form?
                            (== (first last_chain) "let")
                            (== (last last_chain) symbol)
                            (== (first last_pos_chain) 1) ;; in allocation form
                            (not (== prior_loc.row row))  ;; get rid of duplicates that can occur with patterns like (let ((options options))) where options is also an argument
                            (not (== prior_loc.pchain last_pos_chain_str)))
                         (push def_locs { row: row col: column `type: "local_let" `pchain: last_pos_chain_str `chain: pos_chain } )
                         
                         (and in_form?
                            (contains? (first last_chain) (list `fn `function `function* `destructuring_bind))
                            (== (last pos_chain) 1))
                         (push def_locs { row: row col: column `type: "anonymous_function_argument" `chain: pos_chain } )
                         
                         (and in_form?
                            (contains? (last last_chain) [ "defvar" "defconst" ])
                            (== (last pos_chain) 1))
                         (push def_locs { row: row col: column `type: "local_def" `chain: pos_chain } )
                         
                         (and in_form?
                            (== (last last_chain) "catch")
                            (== 2 (last pos_chain)))
                         (push def_locs { row: row col: column `type: "catch_alloc" `chain: pos_chain}))))))
          
          (when (> __VERBOSITY__ 0)
             (log "find_symbol_definition: def_locs: " def_locs)
             (log "find_symbol_definition: current_pos: " closest_symbol_to_pos))
          (if (> def_locs.length 1)
             (for_each (loc def_locs)
                (progn
                   (= score 0)
                   (set_prop loc
                      `tree_dist
                      (if closest_symbol_to_pos
                         (but_last (calc_dist loc.chain closest_symbol_to_pos.3))  ;; remove the last 
                         nil))
                   ;; how long do the paths match up until they don't match?
                   ;; once they don't match, then we deduct the remaining from the score 
                   (for_each (tpos loc.tree_dist)
                      (progn
                         (if (== tpos 0)
                             (inc score)
                             (break))))
                   (if (< score (length loc.tree_dist))
                       (= score (- score (- (length loc.tree_dist) score))))
                   (when (> score top_score)
                      (= top_score score)
                      (= closest loc))))
                   ;(log "top score: " top_score " score: " score loc)))
             (= closest (first def_locs)))
                      
          (when (> __VERBOSITY__ 0)
             (log "closest is: " closest) )
          [closest]))
   {
     description: (+ "Given a symbol name (no binding prefix), a `symbol_map` as produced by "
                     "the function `symbol_map_for_buffer`,  an optional current_pos and an optional "
                     "root_form, if the symbol is present in the provided symbol map object, this "
                     "function will return the location of the symbol definition and type of "
                     "allocation, which could be of the following: <br>global:global scope - The "
                     "symbol\'s definition was found as a global type definition in the file as "
                     "defined via `defun`, `defun_sync`, `defglobal`, `defmacro`, `defcontrol`, "
                     "`defparameter` and `defvalue`.  <br>named_function_argument:local scope - The "
                     "symbol definition was determined to be provided as an argument to a named "
                     "function that the current position is within.  Named functions are defined by "
                     "`defun`, `defun_sync`, `defmacro` and "
                     "`defcontrol`.  <br>anonymous_function_argument:local scope - The symbol\'s "
                     "definition was determined to be provided as an argument to an anonymous "
                     "function.  The operation would be `fn`, `function`, `function*` or "
                     "`destructuring_bind`.<br>local_let:local scope - The symbol was defined as part "
                     "of the let allocation block.<br>local_def:local scope - The symbol was defined "
                     "as using the `defvar`, or `defconst` operators.<br>catch_alloc:local scope - "
                     "The symbol was defined in a catch form.<br>If no root_form or current_pos "
                     "objects are provided to the function, then only global symbols will be "
                     "identified as the function will have no way to determine the local position, "
                     "and hence what is lexically available in scope. ")
     usage: ["symbol:string" "symbol_map:object" "current_pos:object" "root_form:object"]
     tags: ["symbol" "scope" "define" "allocation" "symbols" "buffer"]
     })

(defun go_to_line_number (control)
   (when (and (is_control? control)
              control.editor)
      (aif (request_user_input (dtext "Enter line number") `number)
           (-> control `move_to_position (int it) 0)))
   {
     description: (+ "Given an editor type control such as `text_editor`, presents a dialog "
                     "box asking for a line number to go to and then, once a line number has been "
                     "entered, moves the cursor and editor view to that line.  The position history "
                     "is updated as this function calls the `move_to_position` method if the editor "
                     "interface. ")
     usage: ["control:object"]
     tags: [`editor `line `row `jump `go `position `ui]
   })

(go_to_line_number (get_control_by_name "style.css"))

(defun set_word_wrap (control state wrap_at_column)
   (let
      ((target_editor 
          (cond 
             (and (is_control? control)
                  control.editor)
             control.editor
             (and control.renderer 
                control.session
                control.textInput)
             control
             else
             (throw TypeError "set_word_wrap: invalid control or editor provided"))))
      (cond
         (and (== state true)
              (is_number? wrap_at_column))
         (-> target_editor.session  `setOption `wrap wrap_at_column)
         (== state true)
         (-> target_editor.session `setOption `wrap true)
         else
         (-> target_editor.session `setOption `wrap false))
      (if state
         true
         false))
   {
     description: (+ "Given a control with an editor property, or an Ace editor object "
                     "directly, a state and an optional column number, will enable or disable word "
                     "wrap for the provided object.  If word wrap is turned on, `true` will be "
                     "returned, otherwise `false`. ")
     usage: ["control:object" "state:boolean" "wrap_at_column:number" ]
   })
             
 
(defun init_mode_markdown (control)
      (set_word_wrap control true))

(defun text_editor (options)
   (aif (and (not options.clone_with_editor_id)
             (get_control_by_name options.name))
        it
        (let
           ((options (+ {}  ;; default is an empty code editing buffer for lisp
                        { mode: "juno"
                          id: (generate_id "text_editor")   ;; id can be provided and will overide this generated ID
                          content: "" }
                        (if (is_object? options)
                            options
                            (progn
                               (notify "Invalid options object provided to editor - check config")))))
            (resize_observer nil)
            (group_name nil)
            (intf {})
            (initialized false)
            (config_value (function (key default_value)
                             (or (prop options key)
                                 (resolve_path [ `editor key ] *env_config*)
                                 default_value)))
            (buffer_commands_button (commands_button options.id))
            (evaluator_span (span { `class: "juno-evaluator" `style: "pointer: cursor" `title: (dtext "Name of the evaluator assigned to this buffer") } "-"))
            (nav_back_button (button { `title: (dtext "Step Backward In Position History") `style: "float: right" } "<"))
            (nav_forward_button (button { `disabled: true `title: (dtext "Step Foreward In Position History") `style: "float: right" } ">"))
            ;; if we have a namespace in options use that for referencing paths
            (nseval (if (not (blank? options.namespace))
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))
            (is_dirty? false)
            (col_pos_span (span { `title: "Position (Row Column)" `style: "float: right;margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } "[0 0]"))
            (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" }
                               (if options.read_only
                                  "RO"
                                  "")))
            (wrap_span (span { `style: "width: 25px; min-width: 25px; display: inline-block;float: right; margin-right: 15px;margin-left: 15px;" `title: "Word Wrap" } ""))
            (mode "-")
            (mode_span (span { `class: "juno-mode" `title: "Current Editing Mode" `style: "float: right; margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } mode))
            (title_span (span { `class: "juno-title" } options.name))
            (ns_span (span { `title: "Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } nseval.namespace))
            (control_bar (or options.control_bar
                             (div { `class: "juno-buffer-bar" }
                                  buffer_commands_button
                                  title_span
                                  ns_span
                                  evaluator_span
                                  locked_span
                                  nav_forward_button
                                  nav_back_button
                                  mode_span
                                  col_pos_span
                                  wrap_span)))
            (parent_view nil)
            (context_clear_timer nil)
            (display_context_message (function (value)
                                        (if (and (blank? value)
                                                 context_clear_timer)
                                            nil
                                            (progn
                                               (when context_clear_timer
                                                  (clearTimeout context_clear_timer))
                                               (= context_clear_timer nil)
                                               (when (not (blank? value))
                                                  (= context_clear_timer (setTimeout (fn () (= context_clear_timer nil)) 3000)))  ;; delay for clearing the message to quickly if a blank comes in
                                               (cond
                                                  (is_element? value)
                                                  (-> help_context_elem
                                                     `replaceChildren value)
                                                  else
                                                  (-> help_context_elem
                                                     `replaceChildren (span { `style: "display: inline-block; text-overflow: ellipsis; width: 100%; overflow: hidden" } (+ "" value))))))))
            (check_observer (fn ()
                               (when (not (== view.parentElement parent_view))
                                  (-> resize_observer `disconnect)
                                  (-> resize_observer `observe view.parentElement)
                                  (= parent_view view.parentElement))))
            
            (help_context_elem (div { `class: "juno-help-context" } ""))
            (context_bar (div { `class: "juno-context-bar" }
                              help_context_elem))
            (offset_depth 46)
            (editor_div (div { `class: "opacity-0" `style: (+ "height: calc(100% - " offset_depth  "px); width: 100%; overflow: hidden;font-family:var(--main-mono-space);") }))
            
            (view (div { `control_id: options.id `style: "overflow: hidden; height: calc(100% - 10px); display: inline-block; width: inherit;" }
                       control_bar
                       editor_div
                       context_bar))
            (ns_notifier_id (gen_id "ns_notifier"))
            (name_change_id (gen_id "name_change_notifier"))
            (evaluator nil)
            (perform_resize (fn ()
                               (when view.parentElement
                                  (check_observer)
                                  (html/set_style [["width" "calc(100% - 2px)"];           (+ "" (- (prop view.parentElement `offsetWidth) 2) "px")]
                                                   ["height" (+ "" (- (prop view.parentElement `offsetHeight) 2) "px")]]
                                                  view)
                                  (set_style [["height" (+ "calc(100% - " (+ (Math.max 0 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] editor_div)
                                  (when editor
                                     (-> editor `resize)))))
            
            (editor nil)  ;; the editor object
            (set_read_only (fn (read_only?)
                              (progn
                                 (-> editor `setReadOnly read_only?)
                                 (if read_only?
                                    (set_prop locked_span
                                       `innerText
                                       (dtext "RO"))
                                    (set_prop locked_span
                                       `innerText
                                       (dtext ""))))))
            (set_evaluator (fn (evaluator_function)
                              (when (is_function? evaluator_function)
                                 (= evaluator evaluator_function)
                                 (dispatch_event { command: "editor_change"
                                                   source: options.id
                                                   args: [ { `option: "evaluator" `value: evaluator_function } ] })
                                 (aif (get_keybinding "editor" "evaluate_selection")
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (-> editor.commands `addCommand
                                         {
                                           `name: "evaluate_selection"
                                           `bindKey: { `win: "Shift-Enter" `mac: "Shift-Enter" }
                                           `exec: evaluate_selection
                                           })))))
            (change_evaluator_name (fn (event_obj)
                                      (progn
                                         (log "Received evaluator name change: " event_obj)
                                         (aif (resolve_path [ `args 0 `value ] event_obj)
                                              (set_prop evaluator_span
                                                 `innerText
                                                 it)))))
            (set_mode (fn (mode_name)
                         (progn
                            (defvar identifier_regex (new RegExp "[A-Za-z*+0-9_\\$\\u00A2-\\uFFFF]+"))
                            (set_prop options
                               `mode
                               mode_name)
                            (cond
                               (== options.mode "juno")
                               (progn
                                  (console.log "mode to juno")
                                  (-> editor.session `setMode "ace/mode/juno")
                                  (-> editor `setOptions {
                                                           `enableBasicAutocompletion:  [{ identifierRegexps: [ identifier_regex ]
                                                                                                             getCompletions: (fn (editor session pos prefix callback)
                                                                                                                                (get_juno_autocompletions editor session pos prefix callback sorted_symbols)) }]
                                                           enableLiveAutocompletion: true
                                                           enableSnippets: true
                                                           }))
                               (== options.mode "javascript")
                               (progn
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })
                                  (-> editor.session `setMode "ace/mode/javascript"))
                               (== options.mode "css")
                               (progn
                                  (-> editor.session `setMode "ace/mode/css")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true }))
                               (== options.mode "sh")
                               (progn
                                  (-> editor.session `setMode "ace/mode/sh")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true }))
                               options.mode
                               (progn
                                  (-> editor.session `setMode (+ "ace/mode/" options.mode))
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })
                                  (log "set_mode: looking for: " (+ "init_mode_" options.mode))
                                  (aif (resolve_path [ `context `scope (+ "init_mode_" options.mode) ] Environment ) 
                                       (it intf)))
                               else
                               (progn
                                  (set_prop options
                                     `mode
                                     `text)
                                  (-> editor.session `setMode "ace/mode/text")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })))
                            
                            (set_prop mode_span
                               `innerText
                               options.mode)
                            (dispatch_event { command: "editor_change"
                                              source: options.id
                                              args: [ { `option: "mode" `value: options.mode } ] })
                            (when options.on_mode_set
                               (options.on_mode_set mode_name)))))
            
            (set_theme (fn (theme_name)
                          (progn
                             (-> editor `setTheme (+ "ace/theme/" theme_name))
                             (set_prop options
                                `theme
                                theme_name)
                             (dispatch_event { command: "editor_change"
                                               source: options.id
                                               args: [ { `option: "theme" `value: theme_name } ] })
                             (when options.on_theme_set
                                (options.on_theme_set theme_name)))))
            
            (set_overscroll (fn (state)
                               (if state
                                  (progn
                                     (-> editor `setOption `scrollPastEnd true)
                                     (set_prop options
                                        `overscroll
                                        true)
                                     true)
                                  (progn
                                     (-> editor `setOption `scrollPastEnd false)
                                     (set_prop options
                                        `overscroll
                                        false)
                                     false))))
            
            (set_name (fn (new_name force)
                         (progn
                            ;; if we are not already called the new name go ahead and process the new name
                            (when (and (not (blank? new_name))
                                       (not (== (get_control_by_name new_name) intf)))
                               (set_prop options
                                  `name
                                  (if force
                                     new_name
                                     (compute_name_for_control new_name)))
                               (set_prop intf
                                  `name
                                  options.name)
                               (dispatch_event { command: "editor_change"
                                                 source: options.id
                                                 args: [ { `option: "name" `value: options.name } ] }))
                            (set_prop title_span
                               `innerText
                               options.name)
                            options.name)))
            (refresh_symbol_timer nil)
            (symbol_positions_timer nil)
            (evaluate_selection (function (editor)
                                   (let
                                      ((rval nil)
                                       (copytext (if options.repl_mode
                                                     (-> editor `getValue)
                                                     (-> editor `getCopyText))))
                                      (if (blank? copytext)
                                          (if (not options.repl_mode)
                                              (display_context_message (dtext "Please highlight text to evaluate")))
                                          (try
                                             (progn
                                                (when refresh_symbol_timer
                                                   (clearTimeout refresh_symbol_timer))
                                                (= refresh_symbol_timer (setTimeout (fn () (progn (get_current_symbols) (= refresh_symbol_timer nil))) 5000))
                                                (= rval (evaluator copytext nil (not options.repl_mode) nil { `source_name: (or options.filename options.path) } ))
                                                (-> rval `then
                                                   (function (val)
                                                      (progn
                                                         
                                                         (try
                                                            (and options.on_evaluation
                                                               (-> options `on_evaluation copytext val))
                                                            (catch Error (e)
                                                               (log_error (+ "" options.name ": Received error from on_evaluation")
                                                                          e)))
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof val Error)
                                                                           (display_context_message (+ (subtype val)
                                                                                                       (if val.message (+ ":" val.message)
                                                                                                           "")))
                                                                           (is_function? val)
                                                                           (display_context_message (+ "<- " (subtype val)))
                                                                           else
                                                                           (progn
                                                                              (defvar chopped (as_lisp val))
                                                                              (if (> chopped.length 200)
                                                                                  (= chopped (+ (-> chopped `substr 0 200) "...")))
                                                                              (display_context_message (+ "<- " chopped)))))
                                                                     100)))
                                                   (function (e)
                                                      (progn
                                                         (notify "Failure on evaluation")
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof e Error)
                                                                           (display_context_message (+ (subtype e)
                                                                                                       (if e.message (+ ":" e.message)
                                                                                                           "")))
                                                                           else
                                                                           (display_context_message "Evaluation Failure")))
                                                                     100)))))
                                             (catch Error (e)
                                                (progn
                                                   (notify (+ (dtext "Unhandled error") ": " e.message ))
                                                   (console.error e))))))))
            
            (font_size (config_value `font_size 14))
            (increase_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.min 200 (+ font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (decrease_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.max 1 (- font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (select_form_root (fn ()
                                 (progn
                                    (select_to_root_form editor)
                                    nil)))
            (evaluate_root_form (fn ()
                                      (let
                                         ((cpos (current_position)))
                                         (cond
                                            (== options.mode "juno")
                                            (progn
                                               (select_form_root)
                                               (evaluate_selection editor))
                                            (== options.mode "css")
                                            (progn
                                               (evaluate_css_rule editor))
                                            else
                                            (display_context_message (+ "" options.mode ": " (dtext "No evaluation mechanism for mode" ))))
                                                
                                         (sleep 0.02)
                                         (-> editor.selection `clearSelection)
                                         (-> editor `navigateTo cpos.row cpos.column))))
                                       
            
            (select_current_form (fn ()
                                    (select_to_current_form editor)))
            (get_selected_text (function ()
                                  (-> editor `getSelectedText)))
            (get_selection_object (function ()
                                     (-> editor.selection `getRange)))
            (get_lines (function (from to)
                          (-> editor.selection `getLines from to)))
            (is_selected? (function ()
                             (progn
                                (defvar rng (get_selection_object))
                                (not (and (== rng.start.row rng.end.row)
                                          (== rng.start.column rng.end.column))))))
            (last_bracket_match nil)
            (active_lisp_operator nil) ;; the last active lisp operator
            
            (find_active_lisp_operator (function ()
                                          (let
                                             ((new_op nil)
                                              (rnge (or (-> editor.session `getBracketRange (-> editor `getCursorPosition))
                                                        (find_last_paren editor)))
                                              (usage nil)
                                              (stime (time_in_millis)))
                                             (if rnge
                                                (progn
                                                   (= last_bracket_match rnge)
                                                   (= new_op (first (split_by *whitespace_regexp* (-> editor.session `getTextRange last_bracket_match))))
                                                   
                                                   (when (not (== new_op active_lisp_operator))
                                                      (= active_lisp_operator new_op)
                                                      (= usage (decorative_usage active_lisp_operator nil nil (function (val)
                                                                                                                 (progn
                                                                                                                    (symbol_finder val true)
                                                                                                                    ))))
                                                      (when (> __VERBOSITY__ 0)
                                                         (log "find_active_lisp_operator: " active_lisp_operator " usage is: " usage))
                                                      (if usage
                                                         (-> help_context_elem
                                                            `replaceChildren usage)
                                                         (-> help_context_elem `replaceChildren))
                                                      (when usage
                                                         (dispatch_event { `command: "display_usage" `source: options.id `args: [active_lisp_operator] }))
                                                      (when options.on_new_lisp_operator
                                                         (options.on_new_lisp_operator active_lisp_operator))
                                                      (console.log "find_active_lisp_operator: eval time: " (- (time_in_millis) stime) "ms")))
                                                (progn
                                                   (= active_lisp_operator nil)
                                                   (-> help_context_elem
                                                      `replaceChildren)
                                                   (when options.on_new_lisp_operator
                                                      (options.on_new_lisp_operator nil)))))))
            
            (indent_row (function (row_number options)
                           (indent_editor_line editor row_number options)))
            
            (indent_current_row (function (editor)
                                   (when (or (== *last_focus* intf)
                                             options.repl_mode)
                                      (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                         (if (not (is_selected?))
                                             (progn
                                                (defvar row_number (prop (-> editor `getCursorPosition)
                                                                         `row))
                                                (console.log "tab: start: single line: " row_number)
                                                (indent_row row_number { `apply: true }))
                                             (indent_editor_selection editor))))))
            
            (bind_key (fn (key_command func)
                         (aif (get_keybinding "editor" key_command)
                              (progn
                                 (-> editor.commands `addCommand
                                    (to_ace_keybinding key_command it func))))))
            (get_current_token (fn ()
                                  (let
                                     ((pos (or pos (-> editor `getCursorPosition)))
                                      (stream (indirect_new TokenIterator editor.session pos.row pos.column)))
                                     (-> stream `getCurrentToken))))
            
            (set_wrap_mode (fn (state)
                              (progn 
                                 (set_word_wrap editor state)
                                 (set_prop options
                                    `word_wrap
                                    state)
                                 (if (== (-> editor `getOption `wrap) "off")
                                     (set_prop wrap_span
                                        `innerText "")
                                     (set_prop wrap_span
                                        `innerText (dtext "Wrap"))))))
            ;; keyword mapper support
            (internal_keyword_mapper (function (token)
                               (progn
                                  ;(console.log "editor keyword mapper: " options.name token)
                                  (defvar rval
                                     (if (contains? token *formatting_rules*.keywords)
                                        "keyword"
                                        (symbol_finder token)))
                                  
                                  rval)))
            ;; signal ready for saving
            (request_save (function ()
                             (progn
                                (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] }))))
            
            ;; handle the results of the save
            (save_complete (function (event_obj)
                              (progn
                                 (if options.create_mode
                                    (delete_prop options `create_mode))
                                 (display_context_message (+ "Saved " (cond
                                                                         (and (== event_obj.args.0.type "path")
                                                                              (is_array? event_obj.args.0.target))
                                                                         (join "~" event_obj.args.0.target)
                                                                         (== event_obj.args.0.type "filename")
                                                                         event_obj.args.0.target)))
                                 (log "editor: save_complete: " (clone event_obj))
                                 (remove_class "juno-needs-save" title_span)
                                 (delete_prop options `create_mode)
                                 (= is_dirty? false)
                                 (when options.on_save
                                    (-> options `on_save intf)))))
            (split_editor (fn (dir)
                             (let
                                ((new_editor nil))
                                (cond
                                   (== dir "vertical")
                                   (progn
                                      (= new_editor (clone_text_editor_control intf))
                                      (alert_on_error "Unable to split"
                                                      (container_view_operation "split_right" intf new_editor)))
                                   (== dir "horizontal")
                                   (progn
                                      (= new_editor (clone_text_editor_control intf))
                                      (alert_on_error "Unable to split"
                                                      (container_view_operation "split_below" intf new_editor)))
                                   else
                                   (alert_box "Invalid Split Request" "Split commands  must be vertical or horizontal")))))
            ;; position tracking
            (max_history_length (if (is_number? options.max_history_length)
                                    options.max_history_length
                                    40))
            (position_history [])
            (position_history_idx 0)
            (current_position (fn ()
                                 (-> editor `getCursorPosition)))
            
            (set_cursor_position (fn (pos)
                                    (progn
                                       (-> editor `navigateTo pos.row pos.column)
                                       (-> editor `scrollToLine pos.row true nil)
                                       (focus_to_editor intf))))
            (update_position (function (force?)
                                (when editor
                                   (defvar current_pos (-> editor `getCursorPosition))
                                   
                                   (set_prop col_pos_span
                                      `innerText
                                      (+ "[" current_pos.row " " current_pos.column "]"))
                                   (set_prop options `cursor_position current_pos)
                                   
                                   ;; determine if we have a new lisp operator in lisp mode
                                   (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                      (find_active_lisp_operator))
                                   
                                   ;; record our position history so we can go back
                                   ;; if we are less then 8 rows difference, then
                                   ;; update it, otherwise push it onto the stack
                                   (try
                                      (progn
                                         (when (isNaN position_history_idx)
                                            (log "text_editor: update_position: position_history_idx isNaN!")
                                            (= position_history_idx (- position_history.length 1))
                                            (set_disabled nav_forward_button))
                                         (defvar last_pos (prop position_history position_history_idx))
                                         (when (eq nil last_pos)
                                            (log "last_pos is nil! and it shouldn't be: " position_history_idx))
                                         (if (or force?
                                                 (> (Math.abs (- current_pos.row (prop last_pos `row)))
                                                    8))
                                             (progn
                                                (inc position_history_idx)
                                                (-> position_history `splice position_history_idx 0 current_pos)
                                                (when (> __VERBOSITY__ 0)
                                                   (log "text_editor: update_position: recorded position" position_history_idx (prop last_pos `row) (Math.abs (- current_pos.row (prop last_pos `row)))))
                                                (when (> position_history.length max_history_length)
                                                   (take position_history)
                                                   (= position_history_idx (clamp position_history_idx 0 (- position_history.length 1)))))
                                             (progn
                                                (-> position_history `splice position_history_idx 1 current_pos))))
                                      (catch Error (e)
                                         (log "ERROR " options.name  " on position history update: " e.message)))
                                   
                                   
                                   )))
            (go_backward_in_position (fn ()
                                        (progn
                                           (= position_history_idx (Math.max 0 (- position_history_idx 1)))
                                           (set_enabled nav_forward_button)
                                           (set_cursor_position (prop position_history position_history_idx)))))
            (go_forward_in_position (fn ()
                                       (progn
                                          (= position_history_idx (Math.min (- position_history.length 1) (+ position_history_idx 1)))
                                          (when (== position_history_idx (- position_history.length 1))
                                             (set_disabled nav_forward_button))
                                          (set_cursor_position (prop position_history position_history_idx)))))
            
            (on_focus (fn ()
                         (progn
                            (when (not (== *last_focus* intf))
                               (setTimeout (fn ()
                                              (focus_to intf.editor))
                                           10))
                            (setq *last_focus* intf)
                            (add_class "juno-focused" control_bar))))
            
            (orig_bindings nil)
            (build_key_bindings (fn (editor)
                                   (progn
                                      (console.log "building_key_bindings")
                                      ;; we need to remove any keybinding that interferes with our globals and then
                                      ;; rebuild to the right scope
                                      (= orig_bindings (clone (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor)))
                                      ;(defglobal *orig_key_bindings* orig_bindings)
                                      (when options.on_save
                                         (bind_key "on_save" request_save))
                                      (bind_key "increase_font_size" increase_font_size)
                                      (bind_key "decrease_font_size" decrease_font_size)
                                      (bind_key "select_form_root" select_form_root)
                                      (bind_key "select_current_form" select_current_form)
                                      (bind_key "indent_current_row" indent_current_row)
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (bind_key "evaluate_root_form" evaluate_root_form)
                                      (bind_key "jump_to_local_definition" jump_to_local_definition_command)
                                      (bind_key "evaluate_selected_in_place" (fn (editor)
                                                                                (progn
                                                                                   (setTimeout (fn ()
                                                                                                  (try
                                                                                                     (progn
                                                                                                        (defvar rval (eval_selected_text_in_place (get_control_by_editor editor)))
                                                                                                        true)
                                                                                                     (catch Error (e)
                                                                                                        (display_context_message "Error on evaluation: " e.message))))
                                                                                               10)
                                                                                   true)))
                                      
                                      (when (is_array? options.commands)
                                         (for_each (command options.commands)
                                            (do
                                               ;(console.log "optional commands: " command.name command)
                                               (-> editor.commands `addCommand
                                                  (to_ace_keybinding command.name command)))))
                                      true)))
            
            (linked_editor_name nil)
            (linked_editor nil)
            (data_type nil)
            (data_type_defaults { String: ""
                                  array:[]
                                  object: {} })
            ;; based on the contents of the options object set the editor's content
            (set_content (fn ()
                            (let
                               ((content nil))
                               (if options.data_type
                                  (if (eq undefined (prop data_type_defaults options.data_type))
                                      (throw TypeError (+ "Invalid data_type specified: must be either: " (join ", " (keys data_type_defaults))))))
                               (cond
                                  ;; do we have a filename?
                                  (and (is_string? options.filename)
                                       is_served?)
                                  (try
                                     (progn
                                        ;(log "text_editor: requesting file: " options.filename)
                                        (if options.create_mode
                                           (= content "")
                                           (= content (-> (fetch (+ "/files/" options.filename)) `text)))
                                        
                                        (if (is_string? content)
                                            (progn
                                               
                                               (-> editor `setValue content -1))
                                            (progn
                                               (-> editor `setValue "")
                                               (= content "")
                                               (display_context_message (+ "NOTICE: unable to fetch file: " options.filename " (editor set to local value)"))))
                                        (set_prop options
                                           `path
                                           (conj [ `filesystem ] (split_by "/" options.filename))))
                                     
                                     (catch Error (e)
                                        (progn
                                           (-> editor `setValue "")
                                           (= content content)
                                           (display_context_message (+ "ERROR on fetching: " options.filename " (editor set to local value)  " e.message))
                                           (log "Error on fetching file: " options.filename ": " e)
                                           (set_prop options
                                              `path
                                              (conj [ `filesystem ] (split_by "/" options.filename))))))
                                  
                                  ;; if we are given a filename, but we are not online we can't edit it
                                  ;; if we have previous content we can edit off line, but with a notice to the user
                                  (and (is_string? options.filename)
                                       (or options.content options.content_compressed))
                                  (progn
                                     (if (and (is_symbol? `LZString)
                                              options.content_compressed)
                                         (-> editor `setValue (LZString.decompressFromBase64 options.content_compressed -1))
                                         (-> editor `setValue options.content -1))
                                     (= content options.content)
                                     (alert_box "Warning: Using cached content"
                                                (div { `style: "" }
                                                     (dtext "The application isn't online, so the specified content cannot be fetched.")
                                                     (dtext "The last stored value is being used, but this may not match the remote content.")
                                                     (br)
                                                     (dtext "Information loss could occur if this editor's contents are subsequently saved to the server.")
                                                     (dtext "Be careful!")))
                                     (set_prop options
                                        `path
                                        (conj [ `filesystem ] (split_by "/" options.filename)))
                                     (display_context_message (+ "Warning: Cached value of an online file")))
                                  (is_array? options.path)
                                  (progn
                                     (= content (resolve_path options.path nseval.global_ctx.scope))
                                     (when (eq nil content)
                                        (= content (or options.content
                                                       (and options.data_type
                                                          (prop data_type_defaults options.data_type))
                                                       ""))
                                        (make_path options.path nseval.global_ctx.scope content)
                                        (display_context_message (+ "New path: " (join "~" options.path) " with content type " (sub_type content))))
                                     (if (not (== "String" (sub_type content)))
                                         (-> editor `setValue (pretty_print content))
                                         (-> editor `setValue content -1)))
                                  (is_string? options.content)
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue content -1))
                                  (or (is_object? options.content)
                                      (is_array? options.content))
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue (pretty_print content))))
                               (assert (is_value? content) "assertion failure: content is not set in set_content")
                               (= data_type
                                  (sub_type content))
                               (set_prop options
                                  `data_type
                                  data_type)
                               ;; at this point content should be loaded and displayed and
                               ;; data_type should be properly set for the content that
                               ;; is being edited
                               options)))
            (symbol_finder (function (token want_metadata)
                              (if (and token
                                       cached_symbols)
                                 (let
                                    ((rval nil)
                                     (comps (split_by "/" token))  ;; split the token into namespace and symbol if applicable 
                                     (symbol_namespace (if (> comps.length 1)
                                                           (take comps)
                                                           nil))
                                     (cns (or symbol_namespace
                                              (if evaluator_control 
                                                 (-> evaluator_control `current_namespace)
                                                 nil)))
                                     (token (last comps))
                                     (search_order (if cns
                                                       (reduce_sync (ns (keys cached_symbols) )
                                                              (if (and (not (== ns `core))
                                                                       (not (== ns cns)))
                                                                  ns))
                                                       (keys cached_symbols))))
                                    
                                    (when cns
                                       (= rval (resolve_path [ cns token  ] cached_symbols))
                                       (if rval
                                          (set_prop rval 
                                             `namespace
                                             cns))
                                       (unless rval
                                          (= rval (resolve_path [ `core token  ] cached_symbols))
                                          (if rval
                                             (set_prop rval
                                                `namespace
                                                `core))))
                                    
                                    ;(when (> __VERBOSITY__ 0)
                                     ;  (log "symbol_finder: want_metadata: " want_metadata  " rval from level 1: " token "->" rval))
                                    (when (is_function? rval)
                                       (= rval { `type: (subtype rval) })
                                      (console.log (+ "symbol_finder: received a function back!  Should be an object -> check path in namespace:" cns " for " token " in cached_symbols: ") (resolve_path [ cns token ] cached_symbols)))
                                    (if rval
                                       (progn
                                          (if want_metadata
                                            rval
                                            (progn                                               
                                               (if (is_string? rval.type)
                                                 (= rval (lowercase (prop rval `type)))
                                                 (progn
                                                  (console.error "symbol_finder: .type property for " token " is not a string: " rval.type)
                                                  (= rval "identifier"))))))
                                                  
                                       (progn
                                          (for_each (ns search_order)
                                             (progn
                                                (= rval (resolve_path [ ns token ] cached_symbols))
                                                (when rval
                                                   (set_prop rval
                                                      `namespace ns)
                                                   (break))))
                                          ;(console.log "symbol_finder: search_order:" search_order " rval from level 2: " token "->" rval)
                                          (if rval
                                             (if want_metadata
                                                rval
                                                
                                                (= rval (lowercase (prop rval `type))))
                                             (if want_metadata
                                                (= rval {})
                                                (= rval "identifier")))))
                                    ;(console.log "symbol_finder: <- " cns token "want_metadata: " want_metadata rval)
                                    rval)
                                 (progn
                                    (console.log "symbol_finder: no cached_symbols: returning empty {} / identifier")
                                    (if want_metadata
                                       {}
                                       "identifier")))))
            (jump_to_local_definition (fn (symbol)
                                         (progn
                                            (when (or symbol_map_dirty?
                                                    (eq nil symbol_map))
                                               (= symbol_map (symbol_map_for_buffer (or options.filename options.path) (-> intf `get)))
                                               (= symbol_map_dirty? false))
                                            (if symbol_map
                                               (let
                                                  ((locations (resolve_path [`symbols symbol ] symbol_map))
                                                   (def_locs [])
                                                   (cpos (current_position))
                                                   (root_form (select_root_form editor cpos)))
                                                  (if locations
                                                     (progn
                                                        (= def_locs (find_symbol_definition symbol symbol_map cpos root_form)))
                                                     (progn
                                                        (notify (dtext "No symbol map is available"))))
                                                  (when (> __VERBOSITY__ 0)
                                                     (log "text_editor: jump_to_local_definition: def_locs: " def_locs))
                                                  (cond
                                                     (and (== def_locs.length 1)
                                                          (not (eq nil def_locs.0.row)))
                                                     (progn 
                                                        (set_cursor_position { `row: def_locs.0.row `column: def_locs.0.col })
                                                        (update_position true))
                                                     (== def_locs.length 1)
                                                     (progn
                                                        (notify "Cannot find the definition in the file")
                                                        (log "text_editor: define locations: " def_locs))
                                                     (> def_locs.length 1)
                                                     (progn
                                                        (notify "Ambiguous: multiple positions found"))
                                                     (== def_locs.length 0)
                                                     (progn
                                                        (dispatch_event { command: "open_definition"
                                                                          source: options.id
                                                                          args: [ symbol ] })
                                                        (notify (dtext "No local definition found")))))))))
            (jump_to_local_definition_command (fn (editor)
                                                 (let
                                                    ((token (get_current_token)))
                                                    (if token
                                                       (jump_to_local_definition token.value)))))
                                                    
            (symbol_map_dirty? true)                                                 
            (cached_symbols nil)
            (symbol_map nil)
            (sorted_symbols [])
            (get_current_symbols (fn ()
                                    (let
                                       ((symbol_set (if evaluator_control
                                                        (-> evaluator_control `available_symbols)))
                                        (cns (if evaluator_control
                                                 (-> evaluator_control `current_namespace)))
                                        (in_path nil)
                                        (search_order nil))
                                       (when (== intf nil)
                                          (log_error "text_editor: getting current symbols and shouldn't be since we are destroyed!"))
                                       (when (is_object? symbol_set)
                                          (= cached_symbols symbol_set)
                                          (= search_order
                                             (if cns
                                                (conj [ cns `core ] 
                                                      (reduce_sync (ns (keys cached_symbols) )
                                                         (if (and (not (== ns `core))
                                                                  (not (== ns cns)))
                                                             ns)))
                                                (keys cached_symbols)))
                                          (= sorted_symbols
                                             (flatten
                                                (for_each (ns search_order)
                                                   (progn
                                                      (if (or (== ns cns)
                                                                (== ns `core))
                                                          (= in_path true)
                                                          (= in_path false))
                                                      (for_each (sym (keys (prop cached_symbols ns)))
                                                         (if in_path
                                                             sym
                                                             (+ ns "/" sym))))))))
                                       
                                       (when evaluator_control
                                          (set_prop ns_span
                                             `innerText
                                             (-> evaluator_control `current_namespace))))))
                                       
            (set_display_control_bar (fn (state)
                                        (progn
                                           (if state
                                              (remove_class "juno-display-none" control_bar)
                                              (add_class "juno-display-none" control_bar))
                                           (perform_resize))))
            (evaluator_control nil)  ;;create a convenience handle to this if not evaluated
            (set_evaluator_control (fn (control)
                                      (if control.evaluate
                                         (progn
                                            (when options.evaluator_id
                                               (remove_event_handler options.evaluator_id "evaluator_change" ns_notifier_id)
                                               (remove_event_handler options.evaluator_id "control_name_change" name_change_id))
                                            (= evaluator_control control)
                                            (set_evaluator control.evaluate)
                                            (set_prop options
                                               `evaluator_id
                                               control.options.id)
                                            (register_event_handler options.evaluator_id "evaluator_change" ns_notifier_id get_current_symbols)
                                            (register_event_handler options.evaluator_id "control_name_change" name_change_id change_evaluator_name)
                                            (if control.name
                                               (set_prop evaluator_span
                                                  `innerText
                                                  (+ "⭢ " control.name)))
                                            (get_current_symbols)))))
            (user_select_evaluator (fn (e)
                                      (progn
                                         (aif (select_evaluator)
                                              (progn
                                                 (set_evaluator_control it)
                                                 (display_context_message (+ (dtext "Evaluator set to ") it.options.name))
                                                 (notify (+ (dtext "Evaluator set to ") it.options.name)))))))
            
            (cut_selection (fn ()
                              (when (not (blank? (-> editor `getCopyText)))
                                 (let
                                    ((text (-> editor `getCopyText))
                                     (rng (get_selection_object)))
                                    (-> navigator.clipboard `writeText text)
                                    (-> editor.session `replace rng "")))))
            (copy_selection (fn ()
                               (let
                                  ((text (if (search_focused?)
                                             (= text (prop (search_box_handle) `value))
                                             (= text (-> editor `getCopyText)))))
                                  (log "copy: "(search_focused?) (prop (search_box_handle) `value))
                                  (when (not (blank? text))
                                     (-> navigator.clipboard `writeText text)))))
                              
            (paste_selection (fn ()
                                (cond 
                                   (search_focused?)
                                   (progn
                                      (log "search_focused: " (-> navigator.clipboard `readText))
                                      (set_prop (search_box_handle)
                                                `value
                                                (-> navigator.clipboard `readText)))
                                   else
                                   (let
                                      ((text (-> navigator.clipboard `readText))
                                       (rng (get_selection_object)))
                                      (-> editor.session `replace rng text)))))
            (search_box_handle (function ()
                                  (-> view `querySelector "input.ace_search_field")))
            (search_focused? (function ()
                                (== document.activeElement 
                                   (-> view
                                       `querySelector "input.ace_search_field"))))
            
            (menu_items (fn ()
                           (if (is_object? editor)
                              [(if options.path
                                   [(+ (dtext "Save to") " " (last options.path))
                                    (fn (e) (request_save))]
                                   [])
                               [(dtext "Split Vertically")
                                (fn (e)
                                   (split_editor `vertical)) ]
                               [(dtext "Split Horizontally")
                                (fn (e)
                                   (split_editor `horizontal))]
                               [(dtext "Select Evaluator")
                                user_select_evaluator]
                               
                               [(dtext "Increase Font Size") increase_font_size]
                               [(dtext "Decrease Font Size") decrease_font_size]
                               (if (== (-> editor `getOption `wrap) "off")
                                   [(dtext "Enable Word Wrap") (fn (e) (set_wrap_mode true))]
                                   [(dtext "Disable Word Wrap") (fn (e) (set_wrap_mode false)) ])
                               [(dtext "Options and Preferences")
                                (fn (e)
                                   (show_editor_options intf))]
                               [(dtext "Go")
                                [[{
                                   text: (dtext "Go to line number")
                                   path: [ `global `go_to_line_number ]
                                   }]
                                [{
                                   text: (dtext "Step Backward In Position History")
                                   path: [ `global `go_backward_in_position ]
                                   }]
                                [{
                                   text: (dtext "Step Forward In Position History")
                                   path: [ `global `go_forward_in_position]
                                   }]]]
                                (if (-> editor `getReadOnly)
                                   [ (dtext "Allow Editing" ) (fn () (-> intf `set_read_only false)) ]
                                   [ (dtext "Set Read-Only Mode") (fn () (-> intf `set_read_only true)) ])
                               [(dtext "Set Edit Mode")
                                [["Juno" (fn () (-> intf `set_mode "juno"))]
                                 ["Javascript" (fn () (-> intf `set_mode "javascript")) ]
                                 ["Text" (fn () (-> intf `set_mode "text"))]
                                 ["CSS" (fn () (-> intf `set_mode "css"))]
                                 ["JSON" (fn () (-> intf `set_mode "json"))]
                                 ["Shell" (fn () (-> intf `set_mode "sh"))]]]
                               [(dtext "Set Editor Theme")
                                (for_each (theme *editor_themes*)
                                   [theme  (fn () (-> intf `set_theme theme))])]]
                              (progn
                                 (notify (+ "" options.name ": BUG: no editor anymore"))
                                 []))))
            
            (init_context_menu (fn ()
                                  (let
                                     ()
                                     (attach_context_menu 
                                        view
                                        (fn (event)
                                           (let
                                              ((ctoken (get_current_token)))
                                              ;(log "current token: " ctoken)
                                              (conj
                                                 (cond
                                                    (== options.mode "juno")
                                                    [(if (and ctoken
                                                               (or (== ctoken.type "identifier")
                                                                   (== ctoken.type "asyncfunction")
                                                                   (== ctoken.type "function")))
                                                         [ {
                                                              text: (dtext "Go to symbol definition")
                                                              path: [`editor `jump_to_local_definition ]
                                                              exec: (fn ()
                                                                       (jump_to_local_definition ctoken.value))
                                                          } ]
                                                          [])
                                                     [{
                                                        text: (dtext "Select to root form")
                                                        path: [`editor `select_form_root ]
                                                        exec: (fn ()
                                                                 (select_to_root_form editor))
                                                        }]
                                                     [{
                                                        text: (dtext "Evaluate root form")
                                                        path: [`editor `evaluate_root_form ]
                                                        exec: evaluate_root_form
                                                        }]
                                                     (if (is_clipboard_allowed?)
                                                         [{
                                                            text: (dtext "Copy root form")
                                                            path: [`editor `copy_root_form ]
                                                            exec:  (fn ()
                                                                      (let
                                                                         ((cpos (current_position)))
                                                                         (select_form_root)
                                                                         (-> navigator.clipboard `writeText (-> editor `getCopyText))
                                                                         (sleep 0.02)
                                                                         (-> editor.selection `clearSelection)
                                                                         (-> editor `navigateTo cpos.row cpos.column)))
                                                            }]
                                                         [])
                                                     ["--" nil]
                                                     [{
                                                        text: (dtext "Select current form")
                                                        path: [`editor `select_current_form ]
                                                        exec: select_current_form
                                                        }]
                                                     [{
                                                        text: (dtext "Evaluate selection")
                                                        path: [`editor `evaluate_selection ]
                                                        exec: (fn ()
                                                                 (evaluate_selection editor))
                                                        }]
                                                     ["--" nil]]
                                                    (== options.mode "css")
                                                    [[{
                                                        text: (dtext "Select rule")
                                                        path: [`editor `select_css_rule ]
                                                        exec: (fn ()
                                                                 (select_css_rule editor))
                                                        }]
                                                     [{
                                                         text: (dtext "Evaluate rule")
                                                         path: [`editor `evaluate_root_form ]
                                                         exec: (fn ()
                                                                  (evaluate_root_form))
                                                     }]
                                                     [{
                                                         text: (dtext "Copy rule")
                                                         path: [`editor `copy_css_rule ]
                                                         exec: (fn ()
                                                                  (let
                                                                     ((cpos (current_position)))
                                                                     (select_css_rule editor)
                                                                     (-> navigator.clipboard `writeText (-> editor `getCopyText))
                                                                     (sleep 0.02)
                                                                     (-> editor.selection `clearSelection)
                                                                     (-> editor `navigateTo cpos.row cpos.column)))
                                                     }]
                                                     ["--" nil]]
                                                    else
                                                    [])
                                                 (if (is_clipboard_allowed?)
                                                     [
                                                      [{
                                                         text: "Cut"
                                                         path: [`global `cut ]
                                                         exec: cut_selection }]
                                                      [{
                                                         text: "Copy"
                                                         path: [`global `copy ]
                                                         exec: copy_selection
                                                         }]
                                                      [ {
                                                          text: "Paste"
                                                          path: [`global `paste ]
                                                          exec: paste_selection }]]
                                                     []))))))))
            ;; main initialization routine
            (initialize_editor (fn ()
                                  (when (not initialized)
                                     (let
                                        ((comps nil)
                                         (content nil)
                                         (start_time (time_in_millis))
                                         (extension nil))
                                        (setq initialized true)
                                        (setq parent_view view.parentElement)
                                        (setq editor
                                           (ace.edit editor_div))
                                        
                                        
                                        ;(log "initialize_editor: " options.mode " options: " (clone options))
                                        
                                        ;; ensure that the Ace language tools extension is loaded
                                        (display_context_message "Initializing....")
                                        (sleep 0.01)  ;; update display
                                        (defglobal LangTools (-> ace `require "ace/ext/language_tools"))
                                        
                                        ;; if we are not explicitly told to link to another editor...
                                        ;; we need to check to ensure we are not editing a path or file that is already
                                        ;; open by another editor.
                                        
                                        ;; is there already an editor with the same path or filename?
                                        ;; if so, become a linked editor to it
                                        
                                        (when (not options.clone_with_editor_id)
                                           (cond
                                              (and options.path
                                                 (> (get_editors_for_path options.path) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path options.path)))
                                                 (assert primary "initialize_editor: BUG: multiple editors for path but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))
                                              (and options.filename
                                                 (> (get_editors_for_filename options.filename) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path (get_editors_for_filename options.filename))))
                                                 (assert primary "initialize_editor: BUG: multiple editors for filename but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))))
                                        
                                        
                                        ;; are we a cloned editor?
                                        
                                        (when options.clone_with_editor_id
                                           (let ((control_to_clone (get_control_by_id options.clone_with_editor_id))
                                                 (new_session nil))
                                              (if (eq nil control_to_clone)
                                                  (log "editor: cannot find editor to clone, id: " options.clone_with_editor_id))
                                              (when (and control_to_clone
                                                         control_to_clone.editor)
                                                 (= new_session (clone_edit_session control_to_clone.editor.session))
                                                 (= linked_editor control_to_clone.options.id)
                                                 (= linked_editor_name control_to_clone.options.name)
                                                 (-> editor `setSession new_session))))
                                        
                                        ;; behavior setup for the actual editor component
                                        (when options.on_focus
                                           (-> editor `on `focus options.on_focus))
                                        (when options.on_blur
                                           (-> editor `on `blur options.on_blur))
                                        (when options.read_only
                                           (-> editor `setReadOnly true))
                                        (when options.on_click
                                           (-> editor `on `click options.on_click))
                                        (unless linked_editor
                                           (-> editor.session `setUseSoftTabs true)
                                           (-> editor.session `setUseWorker true)
                                           (-> editor.session `setUseSoftTabs true))
                                        
                                        (-> editor.session `setOption `indentedSoftWrap false)
                                        
                                        
                                        (-> editor `setShowFoldWidgets true)
                                         
                                        ;; expose the editor in our interface
                                        (set_prop intf `editor editor)
                                        
                                        ;; set the extension if we haven't been given a specific option mode
                                        ;; if we have filename use that to determine what the mode is
                                        
                                        (when (and (eq nil options.mode)
                                                   (is_string? options.filename))
                                           (= comps (split_by "." options.filename))
                                           (when (> comps.length 1)
                                              (= extension (edit_mode_for_extension (last comps)))
                                              (set_prop options
                                                 `mode
                                                 extension)))
                                        
                                        (set_mode options.mode)
                                        
                                        ;; set the theme for the new editor
                                        (cond
                                           (is_string? options.theme)
                                           (setTimeout (fn () (progn
                                                              (-> intf `set_theme options.theme)
                                                              (remove_class "opacity-0" editor_div))) 50)
                                           else
                                           (aif (resolve_path [ `editor `default_theme ] *env_config*)
                                                (setTimeout (fn ()
                                                               (progn
                                                                  (-> intf `set_theme it)
                                                                  (remove_class "opacity-0" editor_div))) 50)))
                                        
                                        ;; build the key bindings
                                        (build_key_bindings editor)
                                        
                                        (-> editor `setOptions {
                                                                 `showFoldWidgets: true
                                                                 `cursorStyle: "wide"
                                                                 `firstLineNumber: (or options.first_line_number 0)
                                                                 `useSoftTabs: true
                                                                 `highlightActiveWord: true
                                                                 })
                                        
                                        (when (resolve_path [ `editor `editor_defaults ] *env_config*)
                                              (for ((key val) (pairs (resolve_path [ `editor `editor_defaults ] *env_config*)))
                                                   (try 
                                                      (-> editor `setOption (to_mixed_case key) val)
                                                      (catch Error (e)
                                                         (log (+ "Error: " name ": bad initialization default value for editor in *env_config*:" key ": ") val)))))
                                        
                                       
                                        (when (resolve_path [ `editor `session_defaults ] *env_config*)
                                           
                                           (for ((key val) (pairs (resolve_path [ `editor `session_defaults ] *env_config*)))
                                                (try
                                                   (-> editor.session `setOption (to_mixed_case key) val)
                                                   (catch Error (e)
                                                      (log (+ "Error: " name ": bad initialization default value for editor session in *env_config*:" key ": ") val)))))
                                        
                                        (if options.word_wrap
                                           (set_word_wrap editor options.word_wrap))
                                        
                                        ;; if this editor is primary, and not linked to another editor,
                                        ;; get the content from the specified source or path
                                        (if (not linked_editor)
                                            (set_content))
                                        
                                        (cond
                                           (and options.clone_with_editor_id
                                              (get_control_by_id options.clone_with_editor_id))
                                           (progn
                                              (defvar primary (get_control_by_id options.clone_with_editor_id))
                                              (when primary.group_name
                                                 (set_prop options
                                                    `group_name
                                                    (-> primary `group_name))))
                                           (eq nil options.group_name)
                                           (set_prop options
                                              `group_name
                                              (or options.group_name
                                                 options.name
                                                 (and (is_array? options.path)
                                                      (last options.path))
                                                 (and (is_string? options.filename)
                                                      (last (split_by "/" options.filename)))
                                                 "Untitled Buffer")))
                                        
                                        (set_name options.group_name)
                                        
                                        ;; set up the default font size
                                        
                                        (if (eq nil font_size)
                                            (= font_size (parseInt (-> editor `getFontSize)))
                                            (-> editor `setFontSize font_size))
                                        
                                        (set_prop options
                                           `font_size
                                           font_size)
                                        
                                        ;; default to overscoll mode, but TODO: this should be an global default
                                        (unless (== options.overscroll false)
                                           (-> editor `setOption `scrollPastEnd true))
                                        
                                        ;; load up the token iterator extension...
                                        (defglobal TokenIterator (prop (-> ace `require "ace/token_iterator") `TokenIterator))
                                        
                                        ;; set up change events for hints and contexual help
                                        
                                        (-> editor `on `change (function (val)
                                                                  (progn
                                                                     (when (== intf nil) ;; we've been destroyed so shouldn't be here
                                                                        (log_error "text_editor: " name ": in on change for the editor and we are destroyed!"))
                                                                     (add_class "juno-needs-save" title_span)
                                                                     (= is_dirty? true)
                                                                     (= symbol_map_dirty? true)
                                                                     (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                                                        (when (not linked_editor)
                                                                           (handle_lisp_format_event val editor)))
                                                                        ;(find_active_lisp_operator))
                                                                     (when (not linked_editor)
                                                                        (dispatch_event { command: "editor_change"
                                                                                          source: options.id
                                                                                          args: [ val ] }))
                                                                     
                                                                     (when options.on_change
                                                                        (options.on_change editor val)))))
                                        ;; resize
                                        (-> editor `resize true)
                                        ;; reset the undo manager now that th content is loaded
                                        
                                        (unless options.clone_with_editor_id
                                           (try
                                              (aif (-> editor.session `getUndoManager)
                                                   (-> it `reset))
                                              (catch Error (e)
                                                 (log "ERROR on undo manager:" e message))))
                                        
                                      
                                        
                                       
                                        
                                        ;; signal our mode change
                                        
                                        (dispatch_event { command: "editor_change"
                                                          source: options.id
                                                          args: [ { `option: "mode" `value: options.mode } ] })
                                        
                                        ;; scroll speed of the editor
                                        (cond
                                           (is_number? options.scroll_speed)
                                           (set_scroll_speed intf options.scroll_speed)
                                           (is_number? (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                           (progn
                                              ;(log "setting scroll speed: " (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                              (set_scroll_speed intf (resolve_path [ `editor `scroll_speed ] *env_config* )))
                                           else
                                           (set_scroll_speed intf 5))  ;; default scroll speed is 5
                                        
                                        (set_prop options
                                           `scroll_speed
                                           (-> editor `getScrollSpeed))
                                        
                                        ;; when we are linked move to our current position of the other editor
                                        (when linked_editor
                                           (defvar pos (-> (prop (get_control_by_id linked_editor) `editor)
                                                           `getCursorPosition))
                                           (-> editor `navigateTo  pos.row pos.column)
                                           (-> editor `scrollToLine pos.row true nil))
                                        
                                        (push position_history
                                           (-> editor `getCursorPosition))
                                        
                                        (when options.on_initialized
                                           (options.on_initialized intf))
                                        (attach_event_listener view
                                           `keyup
                                           (function (e)
                                              (progn
                                                 (update_position))))
                                        
                                        (if (== options.display_control_bar false)
                                            (set_display_control_bar false))
                                        
                                        (init_context_menu)
                                        
                                        (attach_event_listener nav_forward_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_forward_in_position))))
                                        
                                        (-> editor `on `click (function (val) (update_position)))
                                        (attach_event_listener nav_back_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_backward_in_position))))
                                        (attach_event_listener col_pos_span
                                           `click
                                           (fn (e)
                                              (go_to_line_number intf)))
                                        (attach_event_listener evaluator_span
                                           `click
                                           user_select_evaluator)
                                        ;; setup the evaluator if it is ready
                                        (setTimeout (fn ()
                                                       (let
                                                          ((count 10)
                                                           (evaluator_control nil))
                                                          (when (== options.mode "juno")
                                                          ;; unless we have been explicitly given an evaluator, use the system repl
                                                          (if options.evaluator_id
                                                             (progn
                                                                (= evaluator_control (get_control_by_id options.evaluator_id))
                                                                (while (and (> count 0)
                                                                            (not evaluator_control))
                                                                   (progn
                                                                      (sleep 1)
                                                                      (dec count)
                                                                      (= evaluator_control (get_control_by_id options.evaluator_id))))
                                                                (if evaluator_control
                                                                   (set_evaluator_control evaluator_control)
                                                                   (notify "Unable to set evalator control for the buffer - id not found")))
                                                             (when *system_repl*
                                                                (display_context_message (+ "Evaluator for this buffer is " (prop *system_repl* `name)))
                                                                (set_evaluator_control *system_repl*))))))
                                                    100)
                                        (display_context_message "Ready")
                                        ;(log "initialize_editor: " (clone options.name) (+ ": (" (last_n_chars 5 options.id) "): initialization complete:") (clone options))
                                        intf)))))
           
           (declare (function compute_name_for_control select_evaluator)
                    (global compute_name_for_control select_evaluator))
           (if (not (is_symbol? `$ace_editor))
               (throw TypeError "$ace_editor symbol not found, and is required for this editor."))
           
           (set_style [["height" (+ "calc(100% - " (+ (Math.max 12 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]]
                      editor_div )
           
           (= resize_observer (new ResizeObserver perform_resize))
           (= intf
              {
                `view: view
                `editor: editor  ;; control must be initialized before the editor can be used
                `set: (fn (text)
                         (-> editor `setValue text))
                `get: (fn (text)
                         (-> editor `getValue))
                
                ;; selection 
                
                `get_selection: get_selection_object
                `get_selected_text: get_selected_text
                `is_selected?: is_selected?
                `cut_selection: cut_selection
                `copy_selection: copy_selection
                `paste_selection: paste_selection 
                
                `group_name: (fn ()
                                options.group_name)
                `type: `text_editor
                `can_hide?: (fn ()
                               (progn
                                  ;(log "editor: can_hide? " (get_editors_for_path options.path) "<= 1 can hide" options.path)
                                  (if (or (is_array? options.path)
                                          (is_string? options.path))
                                      (< (length (get_editors_for_path options.path)) 2)
                                      true)))
                `on_hide: (fn ()
                             (log "text_editor: " options.name ": on_hide is called."))
                `set_display_control_bar: set_display_control_bar
                `on_destroy: (fn ()
                                (progn
                                   (cond
                                      (and options.path
                                         (> (length (get_editors_for_path options.path)) 1)
                                         (-> intf `get_linked))
                                      true  ;; in this case we are a linked editor so we are only really removing a view, not the primary editor control
                                      (not is_dirty?)
                                      true
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" }
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         ;(log (+ "editor: " options.name ": user response: ") response)
                                         response))))
                `destroy: (fn ()
                             (when editor
                                
                                (defvar others_and_me (if options.path
                                                          (get_editors_for_path options.path)
                                                          []))
                                (defvar my_path (clone options.path))
                                (when options.evaluator_id
                                   (remove_event_handler options.evaluator_id "evaluator_change" ns_notifier_id)
                                   (remove_event_handler options.evaluator_id "control_name_change" name_change_id))
                                ;(log "editor: " options.name ": got destroy..dispatching event: others and me: " others_and_me.length (< others_and_me.length 2))
                                ;(log "editor: remaining editors for path: " (each (get_editors_for_path options.path) `options))
                                (dispatch_event { `command: "destroy_control" `source: options.id `args: [  ]  })
                                (-> editor `destroy)
                                (= editor nil)
                                ;; effectively de-register ourselves from the group of editors
                                (set_prop options
                                   `path
                                   nil
                                   `group_name
                                   nil
                                   `filename
                                   nil)
                                (= intf nil)
                                (when my_path
                                   (rename_editor_group my_path))))
                `set_evaluator: (fn (new_evaluator)
                                   (when (is_function? new_evaluator)
                                      (set_evaluator new_evaluator)))
                `set_evaluator_control: set_evaluator_control
                `get_evaluator: (fn ()
                                   evaluator)
                `needs_save?: (fn ()
                                 (and (not options.repl_mode)
                                      is_dirty?))
                `set_mode: set_mode
                `get_mode: (fn ()
                              options.mode)
                `set_theme: set_theme
                `set_overscroll: set_overscroll
                `split_vertical: (fn ()
                                    (split_editor `vertical))
                `split_horizontal: (fn ()
                                      (split_editor `horizontal))
                `display_context_message: display_context_message
                `get_evaluator: (fn ()
                                   evaluator)
                `get_position_detail: (fn ()
                                         { current: (-> editor `getCursorPosition)
                                                   idx: position_history_idx
                                                   history: position_history
                                                   })
                `step_backward_in_pos_history: go_backward_in_position
                `step_forward_in_pos_history: go_forward_in_position
                `resize: (fn ()
                            (perform_resize))
                `bind_key: bind_key
                `key_bindings: (fn ()
                                  (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor))
                `save: (function ()
                          (request_save))
                `on_save_complete: (function (event_obj)
                                      (save_complete event_obj))
                `increase_font_size: increase_font_size
                `decrease_font_size: decrease_font_size
                `menu_items: menu_items
                `get_active_lisp_operator: (fn ()
                                              (find_active_lisp_operator))
                `set_read_only: set_read_only
                `get_current_pos: (fn ()
                                     (current_position))
                `set_editor_option: (fn (editor_option_name value)
                                       (when (is_string? editor_option_name)
                                          (-> editor `setOption editor_option_name value)))
                `options: options
                `set_evaluator_control: set_evaluator_control
                `on_focus: (if options.disallow_control_focus
                              nil
                              on_focus)
                `move_to_position: (fn (row column)
                                      (progn
                                         (set_cursor_position { row: row column: column })
                                         (update_position true)))
                `jump_to_local_definition: (fn (symbol)
                                              (if (is_string? symbol)
                                                 (jump_to_local_definition symbol)))
                `name: options.name
                `set_name: set_name
                `get_linked: (fn ()
                                options.clone_with_editor_id)
                `set_linked: (fn (id)
                                (set_prop options
                                   `clone_with_editor_id
                                   id))
                `set_unlinked: (function ()
                                  (progn
                                     (= linked_editor nil)
                                     (delete_prop options
                                        `clone_with_editor_id)
                                     options))
                `cached_symbols: (function ()
                                    cached_symbols)
                `keyword_mapper: internal_keyword_mapper
                `toJSON: (function ()
                            (progn
                               (if (is_symbol? `LZString)
                                   (set_prop options
                                      `content_compressed
                                      (LZString.compressToBase64 (-> editor `getValue)))
                                   (set_prop options
                                      `content
                                      (-> editor `getValue)))
                               `(text_editor ,#options)))
                `initialize: (fn ()
                                (when view.parentElement
                                   (console.log "editor: performing initialization")
                                   (-> resize_observer `observe view.parentElement)
                                   (try
                                      (initialize_editor)
                                      (catch Error (e)
                                         (log "ERROR on init: " e.message))))) })))
   {
     `description: (+ "<br><br>The text_editor control provides a means for editing text based "
                      "buffers, and can either be used for editing local in-memory content or, for "
                      "remote files when the application is served via HTTP.   The editor can be split "
                      "into multiple views of the same content, provides theming, and color coded "
                      "markup capabilities.  Additionally, key sequences can be used either in the "
                      "scope of the editor, or via global scope.  It can adapt well to being a "
                      "sub-control, and has a large number of options to enable higher fidelity "
                      "between serialization and deserialization cycles.   <br><br>#### Example Usage "
                      "<br>```(text_editor \n   { mode: `juno\n     on_change: (function (editor val)\n  "
                      "          (progn\n                      (log (+ (control_name editor) \": change: "
                      "\" val))))\n     name: \"Test Editor\"\n     evaluator_id: (control_id "
                      "*system_repl*)\n     on_initialized: (fn (control)\n                      (notify "
                      "(+ (control_name control) \": initialized!\")))\n   })```<br><br><br>---<br><br> "
                      "This control serves as a wrapper around a third party library, the Ace Editor.  "
                      "The control abstracts certain Ace editor functionality as part of the control\'s "
                      "interface. <br><br>#### Ace Editor              <br><br>  The underlying text "
                      "editor library used for this control is the BSD licensed Ace Editor.  The "
                      "documentation for this library is available here: "
                      "https://github.com/ajaxorg/ace.  Certain underlying functions have been "
                      "elevated and exposed at the top level control interface for purposes of the "
                      "design and implementation of the text_editor control.  Direct access to the Ace "
                      "editor instance and its functionality is via the `editor` key in the control\'s "
                      "interface. Since this control uses a third party library underneath, any "
                      "underlying state not captured directly in the controls options object will be "
                      "lost when serialized.  A project objective is to build out the interface for "
                      "this control toward a more idiomatic and \"lisp-like\" interface.   The exposed "
                      "functionality should be expected to be able to save state and restore, unless "
                      "otherwise noted.<br><br>#### Modes              <br><br> The editor can be set "
                      "to operate in a certain \"mode\" state. Changing the editing mode enables certain "
                      "functionalities to be \"turned on\", and which is specifically relevant for the "
                      "type and purpose of the content being edited.  There are several modes that are "
                      "prebuilt into the editor: Juno/Lisp, Javascript, CSS, and plain text.  Each of "
                      "these modes provide specific features such as syntax highlighting, suggestion "
                      "rules, and active formatting rules. <br>Modes can be selected at creation time "
                      "and during run-time.    The mode is indicated visually by the \"Current Editing "
                      "Mode\" title bar text, located to the far right on the default title bar.  The  "
                      "`(get_mode)`  function can be used in the control\'s interface, which is called "
                      "with zero arguments.    <br> The mode can be changed by the user in the "
                      "control\'s command menu, where the user can select via the Set Edit Mode sub "
                      "menu.   The Controls interface exposes the  `set_mode`  function, where a "
                      "string that is equal to the mode name is given as an argument.  The names of "
                      "the built-in modes are as follows: ```[ `juno `javascript `text `css `json "
                      "]```<br><br> Each element in the array can be used to "
                      "supply `set_mode`.  <br>Additional modes can be constructed and made available "
                      "to the environment that then can be utilized by the text_editor "
                      "control. Presently, the only custom mode is `juno`, which calls back into the "
                      "Lisp environment for context.   The other modes are standard ACE editor modes "
                      "for their respective content type.  In this environments file structure, mode "
                      "files are found named `js_lib/mode-*`, where all relevant mode-code is found "
                      "with the \"mode-\" prefix.   <br>Mode details can be found on the Ace website, "
                      "https://ace.c9.io/.  <br><br>#### Split Panels           <br><br>Editors can be "
                      "split into multiple views of the same content.  Changes to the content are "
                      "propagated to each view, which is linked to the same content.  This means that "
                      "all changes in one will be reflected in the other editor.  Cursor positions and "
                      "display area can be independent to allow for simultaneous editing of a single "
                      "file in multiple panels.   The mechanism by which this occurs is a shared "
                      "underlying Ace  `Session`  instance.  There are some special characteristics of "
                      "the multi-pane mode.<br>When there are multiple panels open to the same editor, "
                      "and one of the editor panels is hidden, it will not be stored in the holding "
                      "tank, and will be disposed.  Like other controls, when there is only one "
                      "instance open, the control will behave in the standard form.  When hidden, the "
                      "control will be stored, not destroyed.  <br>Additionally, in the multiple-panel "
                      "mode, if the buffer is unsaved, the closing control will not ask if you want to "
                      "save the content, but will instead close.  Once the final view into the content "
                      "is reached, and the editor contained unsaved material, the user will be "
                      "prompted if they want to save or store the contents of the editor.<br>The "
                      "interface command `split_window` allows for programmatic control over this "
                      "functionality.  <br><br>### Launch Options                <br><br>Options "
                      "provided to the function allow for modification of behaviors and specific "
                      "functionality to be enabled or disabled at the time of the controls creation.  "
                      " The anything placed in the options object will be serialized when the "
                      "environment is saved, and so it is important to make sure that values must be "
                      "able to represent themselves in JSON form.   <br>clone_with_editor_id:string "
                      "-When present, the created editor instance will share an editing session with "
                      "the editor with the given id.  The given editor must be a text_editor "
                      "control.   <br>mode:string -Specifies which mode the editor should start in.  "
                      "For this to take effect, the mode must be a defined Ace editor mode (see Modes "
                      "above).  If not provided, the mode is determined by the filename if "
                      "possible.<br>on_mode_set:function -If present, this function is called with the "
                      "mode `(on_mode_set mode_name)` when the mode is changed. <br>on_save:function - "
                      "Called after a document has been saved successfully.  Since an edit session can "
                      "be shared between multiple controls that display different views, saving is "
                      "handled in a centralized way through a shared function, the  "
                      "`save_event_handler` function.  This external function receives a request and "
                      "then alerts all the editor with the same `basename`, which is set in the "
                      "options object by the control by calling their `save_complete` functions.  If "
                      "the editor has an `on_save` function in the options, then that function will be "
                      "called when the save successfully completes.<br>id:string -Specifies the "
                      "specific ID of the editor.  This is generally not required, since controls "
                      "should establish their own IDs, except when being rehydrated, they will need to "
                      "keep the ID they had prior to serialization.<br>namespace:string -Specifies the "
                      "namespace that the buffer should operate in, and reference.  If not specified, "
                      "the current namespace is used.  This is necessary if the path being edited is "
                      "in a different namespace than the current evaluation "
                      "namespace.<br>read_only:boolean -If specified as true, the buffer will start in "
                      "read only mode, and will not allow changes to the editor\'s "
                      "content,.<br>control_bar:Element -When specified, uses the element provided "
                      "with this option as the control bar as opposed to the default control "
                      "bar.  <br>on_theme_set:function -If present, this function will be called with "
                      "the new theme name when a new editor theme is set. <br>overscroll:boolean -If "
                      "true, the editor view will scroll past the final line, allowing for the final "
                      "line to be displayed in the middle regions of the view.   The default is true, "
                      "and this options must be explicitly set to false to disable.<br>filename:string "
                      "-When present, the remote file is retrieved via fetch.  The filename should "
                      "contains the relative path of the file under the root directory of the served "
                      "content.  The URL constructed to get the file is /files/filename where filename "
                      "is a path, such as /src/repl.lisp.  In this example, the final URL requested "
                      "would be of the form: `/files/src/repl.lisp`.  This option is meant to be used "
                      "in with `server_env.juno` package, which provides the HTTP-based services used "
                      "to facilitate editing the file tree of the environment.  If the path and the "
                      "filename are both provided in options. the filename is checked prior to the "
                      "path.  If this option is present, the path is is set by splitting the filename "
                      "by \"/\" and prepending the `filesystem symbol such that the "
                      "path `/src/repl.lisp` will set a path of `[ \"filesystem\" \"src\" \"repl.lisp\" "
                      "]`.  <br>repl_mode:boolean -When set to true, this places the editor into a "
                      "\"REPL\" mode, where when Control-Enter is pressed, the entire editor contents "
                      "will be submitted to the evaluator, if possible.  If no errors are received "
                      "from the evaluator for the submitted text, the contents of the editor will be "
                      "cleared, and placed in the command history structure.  If an error is returned, "
                      "the editor contents are not cleared so as to allow for correction of any "
                      "problems or issues before resubmission.   Note that when placed in REPL mode, "
                      "the editor doesn\'t signal or track if the contents need saving.  The default "
                      "for this option is false.<br>max_history_length:number - The editor keeps track "
                      "of cursor jumps that are larger than 8 rows and stores them in a history array "
                      "that can contain up to `max_cursor_positions`.  The `go_backward_in_position` "
                      "and `go_forward_in_position` functions in the text_editor closure move an index "
                      "back and forth between the stored positions.   ")




     })
  
(defun select_evaluator ()
  (let
      ((idx -1)
       (dups (new Set))
       (new_name nil)
       (selected_idx nil)
       (available (reduce (control (flatten (control_tree $root_controls)))
                          (when control.evaluate
                            (if (-> dups `has (or control.name "Untitled"))
                              (progn
                               (= new_name (+ (or control.name "Untitled")
                                             "-" idx))
                               (-> dups `add new_name)
                               [ (inc idx) new_name
                                 control ])
                              (progn
                               (-> dups `add control.name)
                               [ (inc idx) control.name control ])))))
       (selection_box (select { }
                              (map (fn (v)
                                     (option { `value: v.0 } v.1))
                                     (or available [])))))
    (= selected_idx
       (request_user_input (dtext "Select an available evaluator")
                           nil
                           { input: selection_box }))
    (when selected_idx
        (prop (prop available selected_idx) 2))))

(defun show_editor_keybindings (editor_control)
   (if (is_control? editor_control)
       (let
          ((binding_row (fn (keysequence binding)
                           (tr
                              (td keysequence)
                              (td (or binding.description
                                      (from_key binding.name)))))))
          (table { `style: "width: 100%" }
                 (thead
                    (tr
                       (th "Key Sequence")
                       (th "Description")))
                 (tbody
                    (for_each (bindpair (sort (pairs (editor_key_bindings editor_control.editor))
                                              { `key: [`0] }))
                       (destructuring_bind (keysequence binding)
                          bindpair
                          (cond
                             (is_array? binding)
                             (for_each (bindval binding)
                                (binding_row keysequence bindval))
                             (is_object? binding)
                             (binding_row keysequence binding)
                             else
                             []))))))
       (throw EvalError "show_editor_keybindings: requirs a text_editor control as an argument")))


(defun color_popup (rgb_text position)
   (let
      ((div { `style: (+ "position: absolute; left:" 
                         position.x 
                         "px; top: " 
                         position.y "px; width: 10px; height: 10px;"
                         "background: " rgb_text "; ") }))))


(let
   ((widgets (new ace.LineWidgets))
      
            