

(defun_sync decorative_usage (symbol_data namespace suppress_type)
  (let
      ((val (if (is_string? symbol_data)
                (cond
                   (starts_with? "(" symbol_data)
                   (-> symbol_data `substr 1)
                   (starts_with? "[" symbol_data)
                   (-> symbol_data `substr 1)
                   else
                   symbol_data)
                symbol_data.name))
       (show_type (function ()
                     (span { `style: "margin-left: 15px; font-style: italic" 
                             `class: (+ "juno-type-" (lowercase (or description.type "")))
                             }
                         (cond 
                            description.macro
                            "Macro"
                            description.type
                            (if suppress_type [] 
                                description.type)))))
       (metadata (if (and (is_object? symbol_data)
                          namespace
                          (not symbol_data.require_ns))
                     [list symbol_data]
                     (meta_for_symbol (trim val) true)))
       
       (description (if (is_object? symbol_data)
                        symbol_data
                        (if namespace
                           (first (reduce_sync (v metadata)
                                     (when (== v.namespace namespace)
                                        v)))
                           (first (or metadata [])))))
       (view nil)
       (is_symbol_binding (if (and description.require_ns
                                   (is_array? description.initializer)
                                   (== description.initializer.0 (quote pend_load)))
                              true
                              false))
       (rval nil))
     
      (when (and is_symbol_binding
                 (is_object? description))
       (set_prop description
          `usage
          (prop (first (reduce_sync (v metadata)
                                    (when (== v.namespace description.require_ns)
                                       v)))
                `usage)))
      (= rval
         (cond
            (is_array? description.usage)
            (div { `style: "display: inline-block"} "("
                 (flatten [(span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                           (for_each (arg description.usage)
                              (destructuring_bind (arg_name arg_type arg_needed)
                                 (split_by ":" arg)
                                 (= arg_type (or arg_type ""))
                                 (span { `class: (+ "juno-type-" (if (starts_with? "?" arg_type)
                                                                     (lowercase (or (chop_front arg_type) ""))
                                                                     (lowercase arg_type))
                                                    " juno-arg-name") `title: arg_type
                                                `style: (if (== arg_needed "required") "text-decoration: underline" "") } arg_name ":" arg_type)
                                 ))])
                 ")" (show_type))
            (is_string? description.fn_args)
            (div { `style: "display: inline-block"} "("
                 (span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                 (for_each (arg_name (split_by " " (chop (rest description.fn_args))))
                    (span { `class: "juno-arg-name" } arg_name))
                 ")" (show_type))
            
            else
            nil))
      rval)
  {
    `usage: ["symbol:string|object" "namespace:?string" "suppress_type:?boolean"]
    `description: (+ "Given a symbol name as a string or an object metadata value (as from describe), returns a DOM element of the usage information.  "
                     "If the usage metadata is defined for the symbol it will use that, otherwise "
                     "if the symbol is a function and has fn_args defined, that content will be returned "
                     "in a DOM element.  Used by the editor to display usage information. ")
    `tags: [ `usage `editor `formatting `help `assist ]
    })

(defun unpack_description (description options)
   (let
      ((table_regex (new RegExp "(^[a-zA-Z0-9?_*\\-]+):([a-zA-Z0-9]+)[ ]*-[ ]*(.+)"))
       (desc (progn
                (defvar tmp (eval description))
                (if (and (is_object? tmp)
                         (not (is_array? tmp)))
                    tmp.description
                    tmp)))
       (rr (new RegExp "<-" `g))
       (subsections [])
       (segments (split_by "<br>" desc))
       (table_section nil)
       (current_seg 0)
       (total_segs (length segments)))
       (for_each (seg segments)
          (progn
             (inc current_seg)
             (when (is_string? seg)
                (= seg (replace rr "\\u{279C}"  seg))
                (map (fn (comp i)
                        (if (== 1 (% i 2))
                            (push subsections
                               (if options.wrap_fn
                                  (try
                                     (progn
                                        (-> options `wrap_fn comp current_seg total_segs))
                                     (catch Error (e)
                                        (pre "Error in wrap_fn call 1: " e.message)))
                                  (pre comp)))
                            (push subsections
                               (if options.wrap_fn
                                  (try
                                     (-> options `wrap_fn comp current_seg total_segs)
                                     (catch Error (e)
                                        (p "Error in wrap_fn call 2: " e.message)))
                                  (progn
                                     (= table_section (scan_str table_regex comp))
                                     (if (> (length table_section) 0)
                                         (for_each (tbl_row table_section)
                                            (div { `style: "display: flex; align-items: flex-end; flex-wrap: wrap; gap: 16px; border-bottom: 1px solid var(--main-accent-line);" }
                                                 (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.1)
                                                 (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.2)
                                                 (div { `style: "align-self: flex-start; padding: 5px; flex-grow: 1; flex-basis: 400px;"} tbl_row.3)))
                                         (p comp)))))))
                     (split_by "%%%" seg)))))
       (div { `class: "juno-editable" }
          subsections))
    {
       `usage: ["description:text"]
       `description: "Given a marked up description text, builds the output format for the browser."
       `tags: [ `usage `help `assist `formatted `markup ]
   })


(defun format_help (meta_obj options)
   (let
      ((is_symbol_binding (if (and meta_obj.require_ns
                                   (is_array? meta_obj.initializer)
                                   (== meta_obj.initializer.0 (quote pend_load)))
                              true
                              false))
       (imported_usage (first (if is_symbol_binding
                                  (reduce  (v (meta_for_symbol meta_obj.name true))
                                     (when (== v.namespace meta_obj.require_ns)
                                        v))
                                  [])))
       (elem nil))

      (when imported_usage
         (set_prop meta_obj
            `usage
            (prop imported_usage `usage))
         (set_prop meta_obj
            `tags
            (prop imported_usage `tags)))
            
      (= elem
         (div { `command: (+ "" meta_obj.name)  `style: "width: calc(100% - 20px); padding-bottom: 5px;" }
              (h3 (span { `style: "color: var(--namespace-color); " } meta_obj.namespace ) "/" meta_obj.name
                  (if meta_obj.macro
                     (span { `style: "float: right; margin-right: 20px; " } "Macro")
                     (span { `title: "Type" `style: "float: right" `class: (+ "juno-type-" (lowercase meta_obj.type)) } meta_obj.type)))
              (hr { `class: "LightHR" })
              (cond
                 (and (contains? `unction meta_obj.type)
                      meta_obj.usage)
                 [(h4 "Usage")
                  (decorative_usage meta_obj meta_obj.namespace true)]
                 (contains? `unction meta_obj.type)
                 [(h4 "Arguments")
                  meta_obj.fn_args]
                 else
                 [])
              (if (or meta_obj.description
                      is_symbol_binding)
                  [(h4 "Description")
                   (if is_symbol_binding
                      (p
                         (div { } "This is a bound symbol into " (span { `style: "color: var(--namespace-color); " }  meta_obj.require_ns)
                              " to " (join " " meta_obj.requires) ".  For more information refer to the core/use_symbols macro and to " (join " " meta_obj.requires) ".")
                         (br))
                      (unpack_description meta_obj.description))]
                  [])
              
              (if meta_obj.tags
                 [(h4 "Tags")
                  (for_each (`sym meta_obj.tags)
                     (span { `tabindex: 0 `class: "juno-tag" `style: "" } sym ))]
                 [])
              (if meta_obj.requires
                 [(h4 "Requires")
                  (for_each (`sym (sort meta_obj.requires))
                     (span { `tabindex: 0 `class: (+ "juno-type-" (lowercase (or (prop (describe sym) `type) "")) " juno-requires") } sym ))]
                 [])
              ))
      (cond
         (is_function? options.on_click)
         (attach_event_listener elem
            `click
            (fn (e)
               (-> options `on_click e))))
      elem)
   {
     `description: (+ "Render object definitions to html.  Given a path "
                      "to Environment.definitions, or the output of the "
                      "describe function, returns a DOM element.  If options "
                      "is provided, the if the value for the key 'on_click' "
                      "is a function, when the produced element is clicked "
                      "the click event will be passed to the on_click function "
                      "provided.")
     `usage: ["meta_obj:object" "options:?object"]
     `tags: [`help `? `usage `info `man `manual ]
     })

(defun_sync get_cursor_position (element)
  (javascript | {
                  let position = 0;
                  const isSupported = typeof window.getSelection !== "undefined";
                  if (isSupported) {
                       const selection = window.getSelection();
                       if (selection.rangeCount !== 0) {
                              const range = window.getSelection().getRangeAt(0);
                              const preCaretRange = range.cloneRange();
                              preCaretRange.selectNodeContents(element);
                              preCaretRange.setEnd(range.endContainer, range.endOffset);
                              position = preCaretRange.toString().length;
                              }
                       }
                  return position;
                  } |))

(defun_sync get_caret_coordinates ()
   (javascript | {
                   let x = 0,
                   y = 0;
                   const isSupported = typeof window.getSelection !== "undefined";
                   if (isSupported) {
                                      const selection = window.getSelection();
                                      if (selection.rangeCount !== 0) {
                                                                        const range = selection.getRangeAt(0).cloneRange();
                                                                        range.collapse(true);
                                                                        const rect = range.getClientRects()[0];
                                                                        if (rect) {
                                                                                    x = rect.left;
                                                                                    y = rect.top;
                                                                                    }
                                                                        }
                                      }
                   return { x, y };
                   } | ))

(defun_sync set_end_of_content_editable (content_editable_element)
   (javascript | 
      {
        var range,selection;
    if(document.createRange) //Firefox, Chrome, Opera, Safari, IE 9+
    {
        range = document.createRange();//Create a range (a range is a like the selection but invisible)
        range.selectNodeContents(content_editable_element);//Select the entire contents of the element with the range
        range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start
        selection = window.getSelection();//get the selection object (allows you to change selection)
        selection.removeAllRanges();//remove any selections already made
        selection.addRange(range);//make the range you have just created the visible selection
    }
        } | ))

(defun element_to_lisp (element options)
   (if (is_element? element)
       (let
          ((tag_name (if (is_function? options.tagname_for_element)
                         (-> options `tagname_for_element element)
                         element.tagName))
           (elem_as_lisp (list (+ "=:" (lowercase tag_name))))
           (acc [])
           (nodes nil)
           (ptype nil)
           (val nil)
           (attrib_list (prop element `attributes))
           (attribs {}))
          (for_each (attrib_num (range (length attrib_list)))
             (progn
                (set_prop attribs
                   (resolve_path [ `attributes attrib_num `name ] element)
                   (resolve_path [ `attributes attrib_num `value ] element))))
          (push elem_as_lisp
             attribs)
          (= nodes element.childNodes)
          (for_each (cnum (range (length nodes)))
             (cond 
                (== 3 (resolve_path [ cnum `nodeType ] nodes))
                (push elem_as_lisp
                   (if (is_function? options.on_text)
                       (-> options `on_text (resolve_path [ cnum `nodeValue] nodes) nodes)
                       (resolve_path [ cnum `nodeValue] nodes)))
                (== 1 (resolve_path [ cnum `nodeType ] nodes))
                (push elem_as_lisp
                   (element_to_lisp (resolve_path [ cnum ] nodes) options))))
          (if (is_function? options.on_element_complete)
              (-> options `on_element_complete elem_as_lisp)
              elem_as_lisp))
       [ "UNKNOWN:" element ])
   {
     `description: (+ "Given a DOM element, returns the lisp represenation of the DOM element.<br>"
                      "If provided with an options object, the following keys are applicable:<br>"
                      "tagname_for_element:(fn element) - For every new element encountered in the "
                      "provided tree, will be called with the new element.  The function should "
                      "return a string value to be used for the tagname as opposed to the original "
                      "element tagName value.<br>"
                      "on_text:(fn text nodes) - Will be called on a text node with the text and "
                      "and the sibling nodes.<br>"
                      "on_element_complete:(fn array) - Will be called with the quoted lisp form "
                      "that was constructed.  The function can then manipulate the completed form "
                      "prior to it being placed in the returned lisp form.  Note that this function "
                      "is called for every completed element, not just the final return value.")
     `usage: ["element:element"]
     `tags: ["DOM" "ui" "serialize" "serialization" "view" "element" ]
   })
                
(defun_sync doc_exec (command_name value show_default_ui )
   (-> document `execCommand command_name 
                             (if (== show_default_ui true) true false) 
                             value)
   {
       `description: (+ "Executes document.execCommand with the arguments provided "
                        "on the DOM element currently in focus.<br>"
                        "Returns false if the command is unsupported.  The " 
                        "show_default_ui argument defaults to false.<br>" 
                        "<br>Note that browser support is officially deprecated for the "
                        "execCommand method of document.")
       `tags: ["DOM" "ui" "command" "formatting" "editing" ]
       `resources: ["https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand"]
       `usage:["command_name:string" "value:*" "show_default_ui:?boolean"]
   })
   
(defun_sync max_index (container)
   (Math.max 0 (- (length container) 1))
   {
       description: (+ "Given a container, typically an Array or derivative, "
                       "return the max index value, calculated as length - 1.<br>")
       usage: ["container:array"]
       tags: ["length" "array" "container" "max" "index" "range" "limit"]
   })

(defun checkbox (`& args)
   (let
      ((options (if (and (is_object? args.0)
                      (not (is_element? args.0)))
                 args.0
                 {}))
       (args (if (> (length options) 0)
                 (rest args)
                 args))
       (state (if options.value
                  true
                  false))
       (check_input (input (+ { `type: "checkbox" }
                              (if options.value
                                 { `checked: true }
                                 {})
                              { `style: "padding: 5px; margin-right: 5px;" }
                              (if (is_object? options.checkbox)
                                  options.checkbox
                                  {}))))
       (view (label (+ {}
                       (if (is_object? options.label)
                           options.label
                        {}))
                    check_input
                    args)))
      (attach_event_listener view
         `click
         (fn (e)
            (progn
               (= state (prop check_input `checked))
               (set_prop check_input
                  `value
                  state)
               (set_prop view
                  `value
                  state))))
      (set_prop view
         `value
         state)
      view)
   {
       `description: (+ "Creates a checkbox with a label element and "
                        "returns the label element.  The state of the "
                        "check box input is set to the value property "
                        "of the label, such that when the check box input "
                        "is checked, the value will be true, otherwise "
                        "it will be false.  Event listeners can be "
                        "attached as needed.<br>Example:%%%"
                        "(defconst my_checkbox (checkbox { `value: true } \"Completed\"))\n"
                        "(attach_event_listener my_checkbox\n"
                        "   `click\n"
                        "   (fn (e)\n"
                        "      (log \"State: \" e.srcElement.value)))\n%%%"
                        "<br>"
                        "Options for the checkbox:<br>"
                        "value:boolean - If true the checkbox is checked when first "
                        "presented.<br>"
                        "label:object - If provided, will be used for the attributes of the label element.<br>"
                        "checkbox:object - If provided, will be used for the attributes of the checkbox input "
                        "element.<br>")
       `usage: ["options:?object" "label_contents:string|Element" ]
       `tags: [ "html" "ui" "DOM" "element" "node"]
   })
                
         

(defun pair_editor (pair options)
   (let
      ((pair [ pair.0 pair.1 ])
       (key_elem (input (+ { `tabindex: 0 `class: "juno-editable" }
                           (if options.placeholder_0 
                              { `placeholder: options.placeholder_0 }
                              {})
                           (if options.list_0
                              { `list: options.list_0 }
                              {})
                           (if (is_array? options.path)
                              { `path: (join "~" (conj options.path [ 0 ])) }
                              { path: "0" })
                           { value: (or pair.0 "") 
                             style: "padding: 5px; flex-grow: 1; flex-basis: 100px;" } )))
       (value_elem (input (+ { `tabindex: 0 `class: "juno-editable" }
                             (if options.placeholder_1 
                              { `placeholder: options.placeholder_1 }
                              {})
                             (if options.list_1
                                { `list: options.list_1 }
                                {})
                           (if (is_array? options.path)
                              { `path:  (join "~"  (conj options.path [ 1 ])) }
                              { path: "1" })
                           { value: (or pair.1 "") style: "padding: 5px; flex-grow: 2; flex-basis: 150px;" } )))
       (view (div { `class: "juno-editable" style: (+ "display:flex; align-items: flex-end; flex-wrap: wrap; gap: 16px;"
                                                      (if (is_string? options.style)
                                                          options.style
                                                          ""))
                           }
                  key_elem
                  value_elem
                  (if options.additional_elements
                     options.additional_elements
                     [])))
       (handler (fn (e)
                   (progn
                      (defvar edited_path (get_attribute e.srcElement "path"))
                      (if (and edited_path
                               (is_function? options.on_change))
                         (-> options `on_change (split_by "~" edited_path) e.srcElement.value))))))
      (log "pair editor: " pair)
      (attach_event_listener view
         `keyup
         handler)
      (attach_event_listener view
         `click
         handler)
      view))
                  

(defun dtable (row_data options)
   (table { `style: "width: 100%" }
          (if (is_array? options.columns)
              (thead
                 (for_each (colheader options.columns)
                    (cond 
                       (is_string? colheader)
                       (th { `style: "padding: 5px;" }  colheader)
                       (and (is_object? colheader)
                            colheader.name)
                       (th { `style: "padding: 5px;" }  colheader.name))))
              [])
         (tbody
            (for_each (row (or row_data []))
               (tr
                  (for_each (cell row)
                     (td { `style: "padding: 3px;" } 
                         cell)))))))

(defun meta! ()
   (new Promise 
      (fn (resolve reject)
          (place_control `right 
                         (meta_editor {
                                        `on_close: (fn (intf)
                                                      (resolve (-> intf `get))) })))))
   

;; convenience for debugging
(set_key_binding "global" "open_meta_editor"
                 {
                   `win: "Alt-M"
                   `mac: "Alt-M"
                   `exec: (fn () (meta!))
                   `description: "Opens the meta editor"
                   })
  
(defglobal *status*
   (div (div "down")
        (div "up")
        (div "next")))
(defglobal *monitor*
   (floating_div 
      *status*
      ))

(defun_sync word_wrap (text ncols)
   (let
      ((line_length 0)
       (words (split_by " " text))
       (max_cols (or ncols 80))
       (current_line [])
       (lines []))
      (for_each (word (or words []))
         (cond
            (>= (+ line_length (length word)) max_cols)
            (progn
               (push lines (join " " current_line))   ;; over the limit, push the current line into line
               (= current_line [ word ])   ;; make a new line and add the word to it
               (= line_length (+ (length word) 1))) ;; set the current line length to the word + 1 space
            else
            (progn
               (push current_line word)    ;; otherwise add the word to the current line
               (inc line_length (+ (length word) 1))))) ;;...and update our line length counter
                    
      
      ;; push any remaining last line into the lines accumulator
      (if (> current_line.length 0)
          (push lines (join " " current_line)))
      ;; and return lines
      lines)
   {
       `description: (+ "Given a string of text and an optional column length "
                        "returns an array of lines wrapped at or before the "
                        "column length.  If no column length is provided, "
                        "the default is 80.")
       `usage: ["text:string" "ncols:?number"]
       `tags: ["text" "string" "wrap" "format" ]
   })
      

(defmacro set_attribute (elem attrib value)
   `(-> ,#elem `getAttribute ,#attrib ,#value)
   {
     description: (+ "Given a DOM Element, attribute text and value, sets "
                     "the provided attribute to the value on the element. "
                     "There is no return value.")
     usage: ["element:Element" "attrib:string" "value:string"]
     tags: ["DOM" "attribute" "element" "set" "property"]
   })

(defun tag_selector (options tags)
   (let
      ((sorted_tag_names (sort (keys *tags_to_meta*)))
       (tag_dlist_id (gen_id `tags))
       (tag_dlist (datalist { `id: tag_dlist_id }
                         (for_each (t sorted_tag_names)
                            (option t))))
       (tag_view (div { `style: "display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start;" }))
       (current_tag nil)
       (extra_space (if (is_number? options.extra_space)
                        options.extra_space
                        2))
       (empty_text (or options.empty_text "name?"))
       (tag_content (fn ()
                       (uniq (reduce (text (each tag_view.children `value))
                                (unless (== empty_text text)
                                   text)))))
       
       (focus_to_tag (fn (tag)
                        (try
                           (progn
                              (-> tag `select))
                           (catch Error (e)
                              (log "error: " e.message)))))
       
       (already_have_tag? (fn (text)
                             (let
                                ((found nil))
                                (for_each (elem (or tag_view.children []))
                                   (when (== elem.value text)
                                      (= found elem)
                                      (break)))
                                found)))
       (value_count (fn (text)
                       (let
                          ((count 0))
                          (for_each (elem (or tag_view.children []))
                             (when (== elem.value text)
                                (inc count)))
                          ;(log "Count is: " count text)
                          count)))
       (prune_empties (fn ()
                         (for_each (t (or tag_view.children []))
                            (if (== t.value empty_text)
                                (-> t `remove)))))
       (adjust_size (fn (elem)
                       (try
                          (if (== elem document.activeElement)
                              (progn
                                 (set_style [["width" (+ "" (+  extra_space elem.value.length) "ch")]] elem))
                              (progn
                                 (set_style [["width" (+ "" (+  2 elem.value.length) "ch")]] elem)))
                          (catch Error (e)
                             (log "ERROR: " e.message)))))
       (new_tag (fn (text focus?)
                   (aif (already_have_tag? text)
                       (if focus? 
                          (focus_to_tag it)
                          false)
                       (let
                          ((tag (input { tabindex: 0
                                         class: "juno-editable"
                                         style: "padding: 5px;margin-right: 10px;"   
                                         list: tag_dlist_id
                                         contenteditable: true
                                         value: text }
                                        )))
                          (adjust_size tag)
                          (-> tag_view `append
                             tag)
                          (when focus?
                             (sleep 0.001)
                             (focus_to_tag tag))))))
       
       (view (div { `style: "position: relative;" }
                  tag_dlist
                  tag_view)))
      
      (attach_event_listener tag_view
         `keydown
         (fn (e)  ;; don't allow spaces in tags
            (cond 
               (or (== e.key "Enter")
                   (contains? e.key "/[]{}():;.,<>|\\\\=`~"))
               (handle_event e)
               (and (== e.key " ")
                    (not (== e.srcElement (last tag_view.children))))
               (handle_event e)
               ;; if we are at the end and we have a `blank?` ie. empty_text (default `name?`), release the focus 
               (and (== e.key "Tab")
                    (== e.srcElement (last tag_view.children))
                    (== e.srcElement.value empty_text))
               (progn
                  (if (> (length tag_view.children) 1)
                      (-> e.srcElement `remove)))
               
               ;; if we have a filled out tag, and are on the last tag, create a new one with tab or space is pressed
               (and (or (== e.key "Tab")
                        (== e.key " "))
                    (not e.shiftKey)     
                    (== e.srcElement (last tag_view.children))
                    (> (length e.srcElement.value) 1))
               (progn
                  (handle_event e)
                  (new_tag empty_text true))
               (and (== e.key "Tab")
                    e.shiftKey
                    (== e.srcElement.value empty_text))
               (progn
                  (handle_event e)
                  (let
                     ((prior e.srcElement.previousSibling))
                     (-> e.srcElement `remove)
                     (if prior
                        (focus_to_tag prior))))
               (and (== e.key "Backspace")   ;; remove when tag has no content
                    (== e.srcElement.value empty_text))
               (let
                  ((prior e.srcElement.previousSibling)
                   (next e.srcElement.nextSibling))
                  (handle_event e)
                  (-> e.srcElement `remove)
                  (cond
                     prior
                     (focus_to_tag prior)
                     next
                     (focus_to_tag next)
                     (== (length tag_view.children) 0)
                     (new_tag empty_text true))))))
              
               
                    
      
      (attach_event_listener tag_view
         `keyup
         (fn (e)
            (progn
               (cond
                  (and (== e.key "Backspace") 
                       (blank? e.srcElement.value))
                  (progn
                     (set_prop e.srcElement `value empty_text)
                     (focus_to_tag e.srcElement)))
               (adjust_size e.srcElement)
               (if (> (value_count e.srcElement.value) 1)
                   (add_class "juno-input-error" e.srcElement )
                   (remove_class "juno-input-error" e.srcElement))
               (set_prop e.srcElement
                  `value
                  (lowercase e.srcElement.value))
               (when options.on_change
                  (-> options `on_change (tag_content))))))
      
      (attach_event_listener tag_view
         `focusin
         (fn (e)
            (progn
               (focus_to_tag e.srcElement))))
      
      (attach_event_listener view
         `focusout
         (fn (e)
            (progn
               (adjust_size e.srcElement)
               (when options.on_change
                  (-> options.on_change (tag_content))
               ))))
      
      (if (and (is_array? tags)
               (> tags.length 0))
          (for_each (tag (or tags []))
             (new_tag tag))
          (new_tag empty_text))
      ;(setTimeout (fn () (focus_to_tag tag_view.children.0)) 10)
      view)
   {
     `description: (+ "Creates a simple DOM Element for creating or editing an "
                      "array of tags (unique strings).  Uses the *tags_to_meta* "
                      "object as a dependency to build the data list selections "
                      "for the tags.  Given an initial array of tags, these "
                      "provided tags will be presented, otherwise a new tag "
                      "with the empty text will be generated and displayed as "
                      "a means to start creating a list of tags.<br>"
                      "Options:<br>"
                      "empty_text:string - When a new tag is generated this "
                      "provided text is shown.  The default is 'name?'<br>"
                      "extra_space:number - How many characters to optionally "
                      "pad the input elements, since the width of the elements "
                      "are measured by the 'ch' unit.<br>"
                      "on_change:function - When a change occurs to a tag, "
                      "or when a tag is removed or created, this function " 
                      "is called with an array of strings, representing the "
                      "tag set that the user is editing.<br>")
     `usage: ["options:object" "tags:array"]
     `tags: ["view" "DOM" "tags" "edit" "manage" "tag" "element"]
     })
   
      

(defun process_edit_entry (root_element event action)
   (let
      ((elem event.srcElement)
       (key event.key)
       (new_elem nil)
       (selection nil)
       (code_node nil)
       (sel_node nil)
       (end_node nil)
       (selrange nil)
       (coords (get_caret_coordinates))
       (actual_elem (-> document `elementFromPoint coords.x coords.y))
       (pos (progn
               (= selection (-> window `getSelection))  ;(get_cursor_position actual_elem))
               (= selrange (-> (-> selection `getRangeAt 0) `cloneRange))
               (if (== selrange.startContainer.nodeType 3)
                   (progn
                      (get_cursor_position selrange.startContainer.parentElement))
                   selrange.endOffset)))
                   
       (total_length (length actual_elem.innerText))
       (proper_pos (== actual_elem.parentElement root_element))
       (insert_pre_at_point (fn ()
                               (try
                                  (progn
                                     (= new_elem (pre "CODE HERE"))
                                     (= selrange (-> (-> window `getSelection) `getRangeAt 0))
                                     (= pos selrange.startOffset)
                                     (-> selrange `setEndBefore actual_elem.nextSibling)
                                     (defvar remaining_text (-> selrange `toString))
                                     (log pos "range post: " remaining_text)
                                     (= selection (-> window `getSelection))
                                     (-> selection `removeAllRanges)
                                     (-> selection `addRange selrange)
                                     (-> selection `deleteFromDocument)
                                     (-> selection `collapseToStart)
                                     (-> (prop root_element.children active_child_idx)
                                         `insertAdjacentElement `afterEnd new_elem)
                                     (-> new_elem `insertAdjacentElement `afterEnd
                                        (div { } remaining_text))
                                     (-> selection `selectAllChildren new_elem))
                                  (catch Error (e)
                                     (notify "ERROR: " e.message)))))
       (in_tree (if proper_pos
                    true
                    (progn
                       (defvar tmp actual_elem)
                       (while (and tmp
                                   tmp.parentElement)
                          (progn
                             (= tmp tmp.parentElement)
                             (if (== tmp root_element)
                                 (break))))
                       (== tmp root_element))))
       (active_child_idx (if in_tree
                         (try 
                            (javascript | return Array.prototype.indexOf.call(root_element.children, actual_elem) |)
                            (catch Error (e)
                               (log "ERROR: " e.message)))))
       (total_children (length root_element.children))
       (priors (if (== action "down")
                   (if (== actual_elem.nodeType 3)
                       (-> actual_elem.parentElement.innerText `substr (- pos 2) 2)
                       (-> actual_elem.innerText `substr (- pos 2) 2))
                   (-> actual_elem.innerText `substr (- pos 3) 3)))
       (inner_text nil)
       (added_text nil)
       (clean_up_children (fn ()
                             (map (fn (child idx total)
                                     (if (and (blank? child.innerText)
                                              (and (> idx 1)
                                                   (< idx (- total 1)))
                                              (== child.tagName "DIV"))
                                         (-> child `remove)))))
                    root_element.children)
       (monofont  "font-family: var(--main-mono-space);"))
      (assert (is_element? root_element) "root_element must be an element")
      (cond
         (== actual_elem.tagName "PRE")
         (unless (== actual_elem.parentElement root_element)
            (notify "PRE is too deep!"))
         (and (== action `down)
              in_tree
              (== actual_elem.tagName "SPAN"))
         (try
            (progn
               (= selection (-> window `getSelection))
               (= inner_text actual_elem.innerText)
               (= new_elem actual_elem.parentElement)
               (-> actual_elem `remove)
               (-> selection `removeAllRanges)
               (= selrange (-> document `createRange))
               (-> selrange `selectNodeContents new_elem)
               (-> selection `addRange selrange)
               (-> selection `collapseToStart)
               (doc_exec `insertText inner_text)
               (= actual_elem new_elem)
               (= pos (get_cursor_position actual_elem))
               (notify (+ "SPAN! " actual_elem.innerText)))
            (catch Error (e)
               (log "ERROR: " e.message))))
      
      ;(log action key "---------" priors actual_elem.tagName actual_elem.innerText)
      
      (if (== actual_elem.parentElement root_element)
          (progn
             ;(if (== action `down) (log  (+ "POS: " pos "/" total_length) "ACI: " (+ "" active_child_idx "/" total_children) "Proper: " (== actual_elem.parentElement root_element) (+ "In tree: " in_tree) (pre (as_lisp (element_to_lisp actual_elem))) ))
             (cond
                (and (== key "`")
                     (== action "down")
                     (not (== actual_elem.tagName "PRE"))
                     (or (== priors "``")
                         (== priors "\n`")))
                (progn
                   (handle_event event)
                   ;(doc_exec "insertText" "`")
                   (= selection (-> window `getSelection))
                   (-> selection `modify `extend `backward `character)
                   (-> selection `modify `extend `backward `character)
                   (-> selection `deleteFromDocument)
                   (= selection (-> window `getSelection))
                   (log  "inserting PRE: " selection.anchorNode.nodeType (pre (as_lisp (element_to_lisp selection.anchorNode.parentNode))))
                   (cond
                      (== selection.anchorNode.nodeType 1)
                      (try
                         (progn
                            (log "code_node: A" (element_to_lisp selection.anchorNode))
                            (log " --> focus_node: " (element_to_lisp selection.focusNode))
                            (insert_pre_at_point))
                         (catch Error (e)
                            (log "ERROR: " e.message)))
                      
                      ;; at end of the document
                      (and (== selection.anchorNode.nodeType 3)
                           (>= active_child_idx (- total_children 1)))
                      (try
                         (progn
                            (doc_exec "insertHTML" "<br/>" false)
                            (when (doc_exec "insertHTML" (+ "<pre>CODE HERE</pre>"))
                               (= code_node selection.anchorNode.parentNode)
                               (log "code_node: B " (element_to_lisp code_node) "Proper POS: " (== code_node.parentElement root_element))
                               (= end_node selection.anchorNode.parentNode)
                               (-> selection `selectAllChildren code_node)))
                         (catch Error (e) (log "ERROR: cannot select!" e.message)))
                      ;; inserting in the middle
                      (== selection.anchorNode.nodeType 3)
                      (try
                         (progn
                            (log "Inserting new PRE ELEMENT in middle: " (pre (as_lisp (element_to_lisp (prop root_element.children active_child_idx)))))
                            (= new_elem (pre  "CODE HERE"))
                            (= selrange (-> (-> window `getSelection) `getRangeAt 0))
                            (= pos selrange.startOffset)
                            (-> selrange `setEndBefore actual_elem.nextSibling)
                            (defvar remaining_text (-> selrange `toString))
                            (log pos "range post: " remaining_text)
                            (= selection (-> window `getSelection))
                            (-> selection `removeAllRanges)
                            (-> selection `addRange selrange)
                            (-> selection `deleteFromDocument)
                            (-> selection `collapseToStart)
                            (-> (prop root_element.children active_child_idx)
                                `insertAdjacentElement `afterEnd new_elem)
                            (-> new_elem `insertAdjacentElement `afterEnd
                               (div { } remaining_text))
                            (-> selection `selectAllChildren new_elem)
                            )
                         (catch Error (e)
                            (log "ERROR: " e.message)))))
                
                ;; ignore control effects in code mode
                (and (== action "down")
                     (== actual_elem.tagName "PRE")
                     (or (and (== (get_operating_platform) "mac")
                              event.metaKey)
                         (and (== (get_operating_platform) "win")
                              event.ctrlKey)))
                (cond
                   (or (== key "b")
                       (== key "i"))
                   (handle_event event))
                (and (== action "down")
                     (== actual_elem.tagName "PRE")
                     (== key "ArrowDown")
                     (> pos (- total_length 2)))
                (progn
                   (= selection (-> window `getSelection))
                   (log "leaving pre - selection is: " selection)
                   (when selection
                      (try
                         (progn
                            (= added_text false)
                            (= sel_node selection.anchorNode.parentElement)
                            (cond
                               sel_node.nextSibling
                               (progn
                                 ; (log "existing one - going there" (element_to_lisp sel_node.nextSibling))
                                  (if (and (>= active_child_idx (- total_children 2))
                                           (blank? sel_node.nextSibling.innerText))
                                      (try
                                         (progn
                                            ;(log "making new_elem to move into")
                                            (= new_elem (div { `contenteditable: true tabindex: 0 } (br)))
                                            (-> sel_node.nextSibling `insertAdjacentElement `beforebegin new_elem)
                                            (setTimeout (fn ()
                                                           (progn
                                                              (-> selection `removeAllRanges)
                                                              (= selrange (-> document `createRange))
                                                              (-> selrange `selectNode new_elem)
                                                              (-> selection `addRange selrange)
                                                              true))
                                                        1))
                                         (catch Error (e)
                                            (log "ERROR: " e.message)))
                                      (try
                                         (progn
                                            (when (blank? sel_node.nextSibling.innerText)
                                               (setTimeout (fn ()
                                                              (progn
                                                                 (set_prop sel_node.nextSibling
                                                                    `innerText
                                                                    "-")
                                                                 (-> selection `removeAllRanges)
                                                                 (= selrange (-> document `createRange))
                                                                 (-> selrange `selectNode sel_node.nextSibling)
                                                                 (-> selection `addRange selrange)
                                                                 )) 1))
                                            )
                                         (catch Error (e)
                                            (log "ERROR: " e.message)))))
                               
                               
                               
                               (== nil sel_node.nextSibling)
                               (progn
                                  (= new_elem (div { `contenteditable: true tabindex: 0 } (br)))
                                  (log "at end")
                                  (-> sel_node.parentElement `append new_elem)
                                  (setTimeout (fn ()
                                                 (try
                                                    (progn
                                                       (log "making new element " sel_node.parentElement)
                                                       (-> selection `removeAllRanges)
                                                       (= selrange (-> document `createRange))
                                                       (-> selrange `selectNode new_elem)
                                                       (-> selection `addRange selrange)
                                                       true)
                                                    (catch Error (e)
                                                       (log "ERROR: " e.message))))
                                              1))
                               else
                               (progn
                                  (log "third condition!"))))
                         (catch Error (e)
                            (log "ERROR: " e.message)))))
                (and (== action "down")
                     (== key "Enter")
                     (== actual_elem.tagName "PRE"))
                (progn
                   (handle_event event)
                   (clean_up_children))
                (and (== action "up")
                     (not (== actual_elem.tagName "SPAN"))
                     (not (== actual_elem.tagName "PRE"))
                     (== key "Enter"))
                (progn
                   (doc_exec "insertText" "\n" true))
                (and (== action "up")
                     (== key "Enter")
                     (or (== actual_elem.tagName "PRE")
                         (== actual_elem.tagName "SPAN")))
                (progn
                   (handle_event event)
                   (if (< pos (- total_length 0))
                       (doc_exec "insertHTML" "\n" false)
                       (doc_exec "insertHTML" "\n\n" false))
                   ;(log "Up Enter on Pre or Span" pos total_length (< pos (- total_length 0)))
                   )))
          (progn
             (when (== action `down)
                (= selrange (-> (-> window `getSelection) `getRangeAt 0))
                ;(log action "EVENT not on root element" action (+ "In tree: " in_tree) (pre (as_lisp (element_to_lisp selrange.startContainer))))
                (cond
                   (and (== action "down")
                        (== actual_elem root_element) ;; editing the contents of the root element directly - a no no
                        (== key.length 1))
                   (try
                      (progn
                         (log "making a new div")
                         ;(handle_event event)
                         (= selection (-> window `getSelection))
                         (doc_exec "insertHTML" (+ "<div contenteditable=true>" key "</div>" )false))
                      (catch Error (e)
                         (log "ERROR: " e.message)))
                   (and (== key "Enter")
                        (== action "down"))
                   (progn
                      (handle_event event)
                      ;(log "inserting br" selrange pos selrange.startOffset selrange.endOffset  (pre (as_lisp (element_to_lisp selrange.startContainer))))
                      (when (== selrange.startContainer selrange.endContainer)
                         (try
                            (cond
                               (== selrange.startContainer.nodeType 3)
                               (progn
                                  ;; we need to insert a node at the point
                                  (-> selrange `insertNode (br)))
                               
                               (== selrange.startContainer.nodeType 1)
                               (progn
                                  ;(log "node type 1 - prepending a br and moving after it.")
                                  (handle_event event)
                                  (= new_elem (br))
                                  (-> selrange `insertNode new_elem)
                                  (= selection (-> window `getSelection))
                                  (-> selection `removeAllRanges)
                                  (-> selrange `selectNode new_elem)
                                  (-> selection `addRange selrange)
                                  (-> selection `collapseToEnd)))
                            (catch Error (e)
                               (log "ERROR on br insertion: " e.message)))))))))))
              
(defcontrol meta_editor ()
   ((meta_struct (or options.content
                           {
                             description: ""
                             name: "Unnamed"
                             type: "unknown"
                             namespace: (current_namespace)
                             usage: []
                             tags: []
                             }))
    (usage (for_each (arg (or meta_struct.usage []))
              (progn
                 (defvar comps (split_by ":" arg))
                 (cond
                    (and (> comps.length 1)
                         (starts_with? "?" (second comps)))
                    [comps.0 (-> comps.1 `substr 1) true ]
                    (> comps.length 1)
                    [comps.0 comps.1 false ]
                    (== comps.length 1)
                    [comps.0 "" false ]))))
    
    (starter_span (div {  `tabindex: 0 `contenteditable: true  } (dtext "Enter text")))
    (desc (if (> meta_struct.description.length 0)
              (unpack_description meta_struct.description)
              starter_span))
    (name_editable (if options.allow_name_edits
                       true
                       true))
    (dlist_type_id (gen_id "types"))
    (dlist_types (datalist { `id: dlist_type_id }
                           (option `AsyncFunction)
                           (option `Function)
                           (option `object)
                           (option `string)
                           (option `number)
                           (option `boolean)
                           (option `array)))
                           
    (symbol_type_elem (input { `class: `juno-editable `list: dlist_type_id `title: "Type" `tabindex: 0 `placeholder: "Type" `style: "font-size: 0.9em; width: 150px; padding: 5px;  font-weight: bold" `value: meta_struct.type }))
    (save_button (button (dtext "Save")))
    (monofont  "font-family: var(--main-mono-space);")
    (close_button (button (dtext "Close")))
    (new_arg_button (button { `style: "min-width: 30px; margin-left: 10px; margin-top: 10px; padding: 5px; "  `title: (dtext "Add New Argument") } "+"))
    (title_span (span { `style: "font-weight: bold; margin-right: 15px;" } options.name))
    (description_elem (div { `class: "juno-editable" tabindex: 0 `contenteditable: true `style: "background: var(--editor-bg-color);  min-height: 150px; line-height: 1.5em; font-size: 1.1em;  padding: 5px; margin-top: 10px;margin-bottom: 10px;" } 
                           desc))
    (description_section (details { `open: true   }
                                  (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Description"))
                                  description_elem))
    (namespace_elem (span { `class: "juno-namespace" `style: "font-weight: bold;"} meta_struct.namespace))
    (name_edit_span (span (+ {} 
                             (if name_editable
                                { `contenteditable: true }
                                {})
                             { `class: "juno-editable" `tabindex: 0 `style: "font-weight: bold;" }) 
                          meta_struct.name))
    (tag_selection (tag_selector { `on_change: (fn (tags)
                                                  (progn
                                                     (set_prop meta_struct
                                                        `tags
                                                        tags)
                                                     (refresh_output))) }
                                 meta_struct.tags))
    (last_usage_elem nil)
    (refresh_usage (fn ()
                     (progn 
                        (= last_usage_elem nil)
                        (-> usage_elem `replaceChildren
                           (div { 
                                  `style: "line-height: 1.5em; font-size: 1.0em;  padding: 5px; max-width: 500px;" }
                                  (map (fn (arg idx total)
                                          (progn
                                             (log "idx: " idx total (as_lisp arg))
                                             (defvar pe (make_pair_editor arg idx total))
                                             (if (== idx (- total 1))
                                                 (= last_usage_elem pe.children.0))
                                             (-> pe `prepend (button { `style: "background: #FF000020; padding: 5px;"
                                                                       `remove_path: (join "~" [ `usage idx ]) } "-"))
                                             pe))
                                       usage)
                                  (if (== usage.length 0)
                                      [ 
                                       (div { } new_arg_button "Press + to add arguments") ]
                                      new_arg_button)
                                  ))
                        (when last_usage_elem 
                           (setTimeout (fn ()
                                          (focus_to last_usage_elem)
                                          20))))))
    
    (make_pair_editor (fn (arg idx total)
                         (pair_editor arg
                                      { `style: "border: 1px inset #ffffff;"
                                        `placeholder_0: "ArgName"
                                        `placeholder_1: "ArgType"
                                        `list_1: dlist_type_id
                                        `additional_elements: [ (checkbox (+ { `checkbox: { `path: (join "~" [ idx "2" ]) }}
                                                                             (if arg.2
                                                                                { `value: true }
                                                                                {}))
                                                                          "Optional")
                                                              ]
                                        `path: [ idx ]
                                        `on_change: (fn (path value)
                                                       (progn
                                                          
                                                          (make_path path usage value)
                                                          (cond
                                                              (and (== path.1 "2")
                                                                   (== value "false"))
                                                               (set_path path usage false)
                                                              (and (== path.1 "2")
                                                                   (== value "true"))
                                                              (set_path path usage true)
                                                              (== path.1 "2")
                                                              (set_path path usage false))
                                                          (log "pe: on_change: " path usage value)
                                                          (set_prop
                                                             meta_struct
                                                             `usage (map (fn (vals)
                                                                            (if (== vals.2 true)
                                                                                (+ vals.0 ":?" vals.1)
                                                                                (+ vals.0 ":" vals.1)))
                                                                            usage))
                                                          (show_updated_help)))
                                                          
                                                          
                                                         
                                        })))
    (usage_elem (div { `style: "min-height: 40px;" } ))
    (usage_section (details { `open: true  }
                            (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Usage"))
                                 usage_elem))
    (tag_section (details { `open: true }
                          (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Tags"))
                                tag_selection))
    (rendered_content_elem (div { `class: "juno-control" } "Live View"))
    
    (main_view (div { `class: "juno-control"  `style: "padding-top: 5px; margin-left: 5px; min-height: 50%" } 
                    (h3 { `style: "display: flex; justify-content: space-between; align-items: center; " } (span (span { `style: "color: var(--namespace-color); " } meta_struct.namespace ) "/" name_edit_span)
                           symbol_type_elem)
                    (hr { `style: "light-hr" })
                    usage_section
                    description_section
                    tag_section
                    dlist_types))
    
    ;; output display: how the content is rendered in the output pane (lower)
    ;; mode 0 is the rendered display
    ;; mode 1 is a lisp view
    ;; mode 2 is a json view
    ;; mode 3 is a debug mode
    (output_display_modes [ "As Rendered" "Lisp" "JSON" "Debug" ])
    (output_display_mode 0) 
    (set_output_display_mode (fn (mode)
                                (try
                                   (progn
                                      (= output_display_mode (clamp mode
                                                                    0
                                                                    (max_index output_display_modes)))
                                      (refresh_output))
                                   (catch Error (e)
                                      (log_error e)))))
                                   
    (build_description (fn (content acc)
                          (let
                             ((acc (or acc [])))
                             (assert (is_element? content) "content must be element")
                             (try
                                (for_each (c content.children)
                                   (when (is_element? c)
                                      (cond
                                         (== c.tagName "PRE")
                                         (progn
                                            (push acc "<br>%%%")
                                            (push acc c.innerText)
                                            (push acc "\n%%%<br>"))
                                         (== c.tagName "DIV")
                                         (progn
                                            (push acc c.innerText)
                                            (push acc "<br>"))
                                         else
                                         (log "build_description: no handling: " (sub_type c) c.tagName c.innerText))))
                                (catch Error (e)
                                   (log "ERROR on build_description: " e.message)))
                             acc)))
    (process_out (fn ()
                    (let
                       ((output (clone meta_struct)))
                       (log "process_out: usage: " (as_lisp usage))
                       (set_prop output
                          `usage (for_each (arg_desc usage)
                                    (if arg_desc.2
                                       (+ arg_desc.0 ":?" arg_desc.1)
                                       (+ arg_desc.0 ":" arg_desc.1))))
                       output)))
    (ok_grab_focus true)
    (on_blur (fn ()
                (= ok_grab_focus true)))
    (on_focus (fn (e)
                 (when ok_grab_focus
                    (= ok_grab_focus false)
                    (focus_to description_elem))))
    (table_regex (new RegExp "(^[a-zA-Z0-9?]+:[a-zA-Z0-9]+[ ]*-[ ]*)(.+)"))
    (show_updated_help (fn ()
                          (-> rendered_content_elem
                                    `replaceChildren 
                                    (div { `style: "background: var(--editor-bg-color); padding: 5px;" } 
                                         (format_help meta_struct)))))
    (process_current (fn (elem)
                        (let
                           ((content nil)
                            (live_content nil))
                           (log "process_current: " (== elem description_elem))
                           ;(log "cursor_position: " (get_cursor_position description_elem))
                           (cond
                              true ;(== elem description_elem)
                              (progn
                                 (= live_content (join "" (build_description description_elem)))
                                 ;; split into an array with roughly 80 column formatting for injection into source
                                 (if (> (length live_content) 60)
                                     (= live_content (flatten 
                                                        (conj [ (quote +) ]
                                                              (for_each (line (word_wrap live_content 80))
                                                                 (+ line " " ))))))
                                 (set_prop meta_struct
                                          `description live_content)
                                 ;(log "process_current: usage: " usage)
                                 (try 
                                    (progn 
                                       (log "Meta Struct: " meta_struct))
                                    (catch Error (e)
                                       (log "ERROR: " e.message)))
                                 
                                 (refresh_output))))))
    
    (sview (split_view_horizontal  main_view  rendered_content_elem  ))
    
    (content_view (div { `class: "juno-control" `style: "width: calc(100% - 2px); height: calc(100% - 2px); overflow: hidden; border-bottom: 3px solid black;" } 
                       sview.view))
    (select_name_edit_span (fn ()
                              (let
                                 ((selection (-> window `getSelection))
                                  (mrange nil))
                                 (try
                                    (progn
                                       (-> selection `removeAllRanges)
                                       (= mrange (new Range))
                                       (-> mrange `selectNodeContents name_edit_span)
                                       (-> selection `addRange mrange)
                                       true)
                                    (catch Error (e)
                                       (log "ERROR: " e.message))))))
    (control_bar_elements [(div { `style: "display:inline-block; float: right" } save_button close_button) ])
    (selection nil)
    (refresh_output (fn ()
                       (cond
                          (== output_display_mode 0)
                          (show_updated_help)
                          (== output_display_mode 1)
                          (-> rendered_content_elem
                             `replaceChildren (pre (as_lisp (process_out))))
                          (== output_display_mode 2)
                          (-> rendered_content_elem
                             `replaceChildren (pre (JSON.stringify (process_out) "\n" 2)))
                          (== output_display_mode 3)
                          (-> rendered_content_elem
                             `replaceChildren (pre (JSON.stringify (element_to_lisp description_elem) "\n" 2))))))
    (on_initialize (fn (intf)
                   (progn
                      (when true
                         (= initialized true)
                         (log "on_initialize: usage: " usage)
                         (-> sview `initialize)
                         (set_prop options
                            `name
                            (+ "Meta Editor - " meta_struct.name))
                         (set_prop title_span
                            `innerText
                             (+ name_edit_span.innerText
                                  " - Meta Editor"))
                         (attach_event_listener view
                            `keydown
                            (fn (e)
                               (cond
                                  (== e.key "Enter")
                                  (progn
                                     (handle_event event)
                                     (process_edit_entry description_elem e "down")
                                     true)
                                  
                                  (== e.key "Escape")
                                  (progn
                                     (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                                  else
                                  (progn
                                     ;(console.log "pos: " (get_cursor_position e.srcElement) (pre (as_lisp (element_to_lisp e.srcElement))) e)
                                     (process_edit_entry description_elem e "down")
                                     ))))
                         (attach_event_listener view
                            `keyup
                            (fn (e)
                               (progn
                                  (cond
                                     (== e.key "Enter")
                                     (progn
                                        ;(handle_event event)
                                        (process_edit_entry description_elem e "up"))
                                     else
                                     (process_edit_entry description_elem e "up"))
                                  (process_current)
                                  )))
                         
                         ;; cancel or manage certain key events on the name...
                         (attach_event_listener name_edit_span
                            `keydown
                            (fn (e)
                               (cond
                                  (== e.key "Enter")
                                  (handle_event e)
                                  (== e.key "Escape")
                                  (progn
                                     (handle_event e)
                                     (focus_to description_elem))
                                  (== e.key " ")
                                  (handle_event e))))
                         (attach_event_listener name_edit_span
                            `keyup
                            (fn (e)
                               (progn
                                  (cond
                                     (blank? name_edit_span.innerText)
                                     (progn
                                        (set_prop name_edit_span
                                           `innerText
                                           (dtext "Unnamed"))
                                        (select_name_edit_span))
                                     else
                                     (set_prop meta_struct
                                        `name
                                        name_edit_span.innerText))
                                  (set_prop title_span
                                     `innerText
                                     (+ name_edit_span.innerText
                                  " - Meta Editor")))))
                                  
                         (attach_event_listener name_edit_span
                            `focus
                            (fn (e)
                               (select_name_edit_span)))
                         (attach_event_listener usage_elem
                            `click
                            (fn (e)
                               (progn
                                  (aif (getAttribute e.srcElement `remove_path)
                                       (progn
                                          (log "remove: " (getAttribute e.srcElement `remove_path))
                                          (-> usage `splice (last (split_by "~" it)) 1)
                                          (refresh_usage))))))
                         (refresh_usage)
                         (attach_event_listener new_arg_button
                            `click
                            (fn ()
                               (progn
                                  (push usage
                                     ["" "" false])
                                  (refresh_usage))))
                         (attach_event_listener close_button
                            `click
                            (fn (e)
                               (progn
                                  (if options.on_close
                                     (-> options `on_close self))
                                  (destroy_control self))))
                         (attach_event_listener symbol_type_elem
                            `change
                            (fn (e)
                               (set_prop meta_struct
                                  `type
                                  (if (blank? symbol_type_elem.value)
                                      (dtext "Unknown")
                                      symbol_type_elem.value))))
                         ;(-> rendered_content_elem
                         ;   `replaceChildren (pre (JSON.stringify (element_to_lisp description_elem) "\n" 2)))
                         (= selection (-> window `getSelection))
                         (-> selection `selectAllChildren description_elem)
                         ;(log "description_elem.children: " (element_to_lisp description_elem.children.0))
                         ;(focus_to (get_by_id "starter_span"))
                         ))))
    (menu_items (fn (menu_title)
                   (progn
                      (log "menu_args?" menu_title)
                      [[(dtext "Blank Menu") (fn () (notify "Blank!"))]
                       ["Set Display Mode"
                        [["Rendered View" (fn () (set_output_display_mode 0))]
                         ["Lisp" (fn () (set_output_display_mode 1))]
                         ["JSON" (fn () (set_output_display_mode 2))]]]])))
    (render (fn ()
                content_view)))
   {
     control_bar: true
     expose: [["get" process_out]
              ["set_output_display_mode" set_output_display_mode]]
     })

(defmacro defcontrol (name control_args allocations control_options)
   (let
      ((declared_allocations (each allocations first))
       (required_allocations [(quote render)])
       (user_allocations allocations)
       (meta { `description: (or control_options.description "No description")
               `tags: (or control_options.tags [`control `ui `DOM ])
               `usage: (if (is_array? control_options.usage)
                           (conj control_options.usage
                                 [ "options:object" ])
                           nil) })
       (args (progn
                (cond
                   (is_array? control_args)
                   (conj control_args [ (quote options) ])
                   else
                   (throw SyntaxError "defcontrol: missing/malformed control arguments - check syntax"))))
       (control_options (if (is_object? control_options)
                            control_options
                            {}))
       (control_bar? (if control_options.control_bar
                        true)))            
       (assert name "control name is required: check syntax for defcontrol")
       (if (< (length (reduce (d declared_allocations)
                         (contains? d required_allocations)))
              (length required_allocations))
           (throw SyntaxError "missing required declarations: must have render"))
  ;; ok, now create the form to be returned..
      `(defun ,#name ,#args
          (let
             ((self {})
              (options (or options {}))
              (name (name_control (or options.name ,#(from_key (desym_ref name)))))
              (id (generate_id ,#name))
              (initialized false)
              (title_span (span { `class: "juno-title" } name))
              (command_button (commands_button id))
              (content_view (div { } "uninitialized.."))
              (resize (fn ()
                         (progn
                            (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               (when options.on_resize
                                  (options.on_resize self))
                               ,#(if control_options.render_on_resize
                                     `(do_render)
                                     true)
                               true))))
              ,@user_allocations
              (control_status (if ,#control_bar?
                                  (div { `class: "juno-buffer-bar" }
                                   command_button
                                   (cond 
                                      (is_array? options.additional_elements)
                                      options.additional_elements
                                      else
                                      title_span)
                                   ,#(if (contains? (quote control_bar_elements) declared_allocations)
                                         (progn
                                            (prop (prop allocations (index_of (quote control_bar_elements) declared_allocations)) 1))
                                         []))
                                  nil))
              (do_render (fn ()
                            (let
                               ((new_view (render self)))
                               (if (and new_view
                                        (not (== content_view new_view)))
                                   (-> content_view `replaceChildren new_view))
                               (if _on_render
                                   (_on_render self)))))
              (resize_observer (new ResizeObserver resize))
              (view (control_frame (to_object
                                       [[`id id]
                                        [`events ,#control_options.events ]])
                     (if ,#control_bar?
                         control_status
                         [])
                                content_view))
              (_on_render (fn ()
                             ,#(if (contains? (quote on_render) declared_allocations)
                                `(on_render self)
                                nil)))
                             
              (_on_focus (fn ()                           
                           (progn
                            ,#(if control_bar?
                                `(add_class "juno-focused" control_status)
                                `[])
                            ,#(if (contains? (quote on_focus) declared_allocations)
                                `(on_focus self)))))
              (_on_destroy (fn ()                                     
                             (progn
                              ,#(if (contains? (quote on_destroy) declared_allocations)
                                  `(on_destroy self)
                                  `true))))
              (_to_json (function ()
                           (progn
                              ,#(if (contains? (quote to_json) declared_allocations)
                                    `(to_json)
                                    `[(quote ,#name) ,@control_args options]))))
              (initialize (function ()
                             (progn
                                (when (and view.parentElement
                                           (not initialized))
                                   (= initialized true)
                                   (-> resize_observer `observe view.parentElement)                                   
                                   ,#(if (contains? (quote on_initialize) declared_allocations)
                                         `(on_initialize self)
                                         true)
                                   (do_render))))))
             (set_prop options
                `id id
                `name name)
             ,@(when (is_array? control_options.expose)
                  (for_each (method_set control_options.expose)
                     (destructuring_bind (method_name method_reference)
                        method_set
                     `(set_prop self
                         ,#method_name ,#method_reference))))
             ,#(if (contains? (quote menu_items) declared_allocations)
                   `(set_prop self
                       `menu_items menu_items)
                   [])
             ;; finally set the required self options
             (set_prop self
                `options options
                `name name
                `type ,#(desym_ref name)
                `view view
                `resize resize                
                `initialize initialize
                `toJSON _to_json
                `on_destroy _on_destroy
                `on_focus _on_focus)
             ;; and return the self
             self)
          ,#meta))
   {
       `description: (+ "The macro defcontrol creates a function in the current namespace that implements the specified "
                        "control features passed to the macro.  The macro handles most of the boiler plate for a basic "
                        "control, combining the passed allocations and options to produce a standardized control "
                        "constructor.  The macro is similar in shape to a defun+let form with some differences.<br><br>"
                        "Like the defun macro, the first argument provides the name of the control that it will be used " 
                        "to construct the name and type of the control.  Also similar to defun, the second argument is "
                        "an array containing any arguments for the control.  Note that, mandatorily, an options argument "
                        "will be appended as the last argument of the argument list, so an empty array passed will "
                        "cause the control only to have an options argument.<br><br>"
                        "The next argument is a series of allocation forms that are integrated into a let allocation "
                        "structure, and so should be in the same form as the allocation block of the let operator.  For "
                        "example, ((render (fn () (div { } \"My View\")))) would meet the minimal requirement for a "
                        "control to be constructed.  The caller of this macro can have as many allocation forms as needed "
                        "to implement the required behavior of the emitted control.  To note that there are "
                        "symbols that made available to these provided forms in the evaluation context of the form that "
                        "can be referenced and used by the user provided forms:<br>"
                        "self:object - The interface object returned.<br>"
                        "content_view:Element - The control's view (not including the control_bar.  Effectively the contents of "
                        "the control view.<br>"
                        "do_render:function - Calls the (render) function provided to the macro.  User code can call this "
                        "function when a redraw is required.<br>"
                        "resize:function - A resize function to invoke if a forced resize is required.<br>"
                        "initialized:boolean - This value is true if the function is initialized or false if it hasn't " 
                        "yet been.<br>"
                        "options:object - The options object passed to the control on instantiation.<br>"
                        "<br><br>"
                        "There are multiple functions that are called upon certain events, which allow the caller to build "
                        "customized behavior and hook into the system when needed.  These functions are specified in the "
                        "allocation forms provided to the macro and are all optional except for render:<br>"
                        "render:function - This function returns the DOM structure assigned to content_view and is what is "
                        "drawn in the control's content container.  If the function returns nil, nothing is done.  Can be "
                        "used in conjunction with the on_render below, which acts on the already drawn view.<br>"
                        "on_focus:function - When a focusing event occurs to the control, this function is called with the "
                        "self object of the macro.<br>"
                        "on_render:function - If this function is specified it will act as the render function so as to "
                        "manipulate an already built view, via the content_view in scope symbol, which is the contents of the "
                        "controls view.<br>"
                        "control_bar_elements:array - If the control is specified with the control_bar control_options set to "
                        "true, the Elements in this array will be placed into the control bar after any runtime additional_elements "
                        "provided to the options object.<br>"
                        "menu_items:function - A function that is called on demand that should return an array containing "
                        "pairs of [menu_text menu_function] that implement any command functionality for the menu.<br>"
                        "on_destroy:function - When the control receives a destroy call, this user provided function will be "
                        "called with the self object.<br>"
                        "on_initialize:function - Upon initialization, this function will be called with the self function. It "
                        "should be expected that the initialization should be called only once for a control lifespan.<br>"
                        "to_json:function - This synchronous function call can be used to provide a customization hook "
                        "for the control.  The return value must be a structure that can be serialized into JSON form.<br><br>"
                        "The final object, control_options is meta data and other flags for the macro:<br>"
                        "expose:array - An array of pairs that specify [ `function_handle function_to_call ] that are placed "
                        "on the self interface and provide the API for the control.  In order for a resource in the control "
                        "scope to be accessed, it must be specified in this option, otherwise the function remains effectively "
                        "private to the control.<br>"
                        "usage:array - The argument specification for the macro"
                        "description:string - The description of the control that is registered in the Environment.<br>"
                        "control_bar:boolean - If a control bar is to be displayed on the top of the control, set this to "
                        "true.<br>")
       `usage: ["name:symbol" "control_arguments:array" "allocations:array" "control_options:object"]
       `tags: ["control" "define" "controls" "ui"]
   })

(create_css_entry "div.juno-control"
   (from_style_text "overflow: scroll;
    height: calc(100% - 10px);
    width: calc(100% - 10px);
    background: var(--control-bg-color);
    color: var(--control-color);"))
   
(create_css_entry "div.juno-editable"
    (from_style_text "padding: 5px;
       caret-color: red;"))

(create_css_entry "div.juno-editable:focus"
   [["outline" "none"]
    ["transition" "all .1s ease-in-out"]])
(create_css_entry "span.juno-editable:focus"
   [["outline" "none"]
    ["background" "#FFFFFF10"]
    ["padding-left" "5px"]
    ["padding-right" "5px"]
    ["box-shadow" "1px 1px 6px 2px #00000040;"]
    ["transition" "all .1s ease-in-out"]])

(create_css_entry "input.juno-editable"
   [["transition" "all .1s ease-in-out"]])

(create_css_entry ".juno-editable > pre"
   (from_style_text "font-family: var(--main-mono-space);box-shadow: 1px 1px 6px 2px #00000010; border: 1px solid var(--main-accent-line); background: #FFFFFF20;padding: 5px;"))

(create_css_entry ".juno-tag-empty"
   [["border" "1px dotted var(--main-accent-line-hover);"]])

(create_css_entry "input.juno-editable:focus"
   [["outline" "none"]
    ["box-shadow" "1px 1px 6px 2px #00000040;"]
    ["transition" "all .1s ease-in-out"]])

(create_css_entry ".juno-editable div"
   [["margin-top" "5px"]
    ["margin-bottom" "10px"]])

(create_css_entry "input.juno-input-error"
   (from_style_text "color: darkred; text-decoration: line-through"))