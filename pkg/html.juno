;; Juno HTML Pakage

;; For browser based DOM utilization and manipulation

;; Initializes and loads the html namespace 
;; (c) 2022 Kina
;; Author: Alex Nygren

(when (contains? "html" (namespaces))
  (delete_namespace `html))
(create_namespace `html { `serialize_with_image: false })


(declare (namespace `html))


;; Tag component names sourced from
;; https://developer.mozilla.org/en-US/docs/Web/HTML/Element


(defglobal *DOM_TAGS* [`html `base `head `link `meta `style `title
                       `body `address `article `aside `footer `header
                       `h1 `h2 `h3 `h4 `h5 `h6
                       `main `nav `section
                       `blockquote `dd `div `dl `dt `figcaption `figure
                       `hr `li `menu `ol `p `pre `ul
                       `a `abbr `b `bdi `bdo `br `cite `code `data `dfn `em
                       `i `kbd `mark `q `rp `rt `ruby `s `samp `small `span
                       `strong `sub `time `u `var `wbr
                       `area `audio `img  `track `video
                       `embed `iframe `object `picture `portal `source
                       `svg `math `canvas `noscript `script
                       `del `ins
                       `caption `col `colgroup `table `tbody `td `tfoot
                       `th `thead `tr
                       `button `datalist `fieldset `form `input `label `legend
                       `meter `optgroup `option `output `progress `select `textarea
                       `details `dialog `summary
                       `slot `template ])


(defmacro get_by_id (id)
  `(-> document `getElementById ,#id)
  {
   `description: "Given an id, this macro is shorthand for calling document.getElementById with the passed id"
   `usage: ["id:string"]
   `tags: ["html" "DOM" "id" "find" ]
   })

(defun get_by_tag (tagname)
  (if tagname
    (-> document `querySelectorAll tagname)
    (throw "get_by_tag: invalid tagname provided"))
  {
   `description: "Deprecated: use query_all: Returns all tags in the document matching the provided tagname"
   `usage: ["tagname:string"]
   `tags: ["html" "DOM" "id" "find" ]
   })

(defun query_all (query)
  (if (is_string? query)
    (-> document `querySelectorAll query)
    (throw ReferenceError "query_all: argument must be a string"))
  {
   `description: "Returns all tags in the document matching the provided tagname"
   `usage: ["tagname:string"]
   `tags: ["html" "DOM" "id" "find" ]
   })

(defun append_children (parent children)
  (when (and (is_element? parent)
             (is_array? children))
    (for_each (child children)
              (-> parent `appendChild child)))
  parent)


(defun generate_id (prefix)
  (if (is_string? prefix)
    (+ "" prefix "-" (time_in_millis) "-" (random_int 9999999))
    (+ "control-" (time_in_millis) "-" (random_int 9999999))))


(defmacro getAttribute (elem attrib)  ;; legacy
  `(-> ,#elem `getAttribute ,#attrib))

(defmacro get_attribute (elem attrib)
  `(-> ,#elem `getAttribute ,#attrib))

;(defbinding (html/create_element (document.createElement document.createElement)))

;(defglobal html/create_element (-> document.createElement `bind document)
 ;  {
  ;  `description: "Binding for document.createElement"
   ; `initializer: (quote  (-> document.createElement `bind document))
    ;})

(defun_sync create_element (element_name)
  (-> document `createElement element_name))

;; first create the base constructor function which will be called
;; with the tag to create

(defun_sync append_children (parent children)
  (do
    (for_each (child (or children []))
              (cond
                (is_array? child)
                (append_children parent child)
                (is_element? child)
                (-> parent `appendChild child)                               
                child.view
                (-> parent `appendChild child.view)
                else
                (-> parent `appendChild (-> document `createTextNode (+ "" child)))))
    parent))

(defun_sync create_dom_element (element_name `& args)
  (let
      ((opts (if (and (is_object? args.0)
                      (not (is_array? args.0))
                      (not (is_element? args.0)))
               args.0
               nil))
       (content (if opts
                  (if (> args.length 0)
                    (rest args)
                    [])
                  (or args
                      [])))       
       (elem (-> document `createElement element_name)))
    
    (when opts
      (for_each (pset (pairs opts))
                (do
                  (cond
                    (is_function? pset.1)
                    (set_prop elem
                              pset.0
                              pset.1)
                    else
                    (-> elem `setAttribute pset.0 pset.1)))))
    (when (> content.length 0)
      (for_each (child content)
                (cond
                  (is_element? child)
                  (-> elem `appendChild child)
                  (is_array? child)
                  (append_children elem child)
                  (is_string? child)
                  (-> elem `appendChild (-> document `createTextNode child))
                  else
                  (try
                    (-> elem `appendChild (-> document `createTextNode (+ "" child)))
                    (catch TypeError (e)
                      (-> elem `appendChild (-> document `createTextNode (+ "ERROR: " (subtype child)))))))))
    elem))



;; next create the individual pointers to the create_dom_element function
;; for every tag name in the *DOM_TAG* list create the construction function

(for_each (tagname *DOM_TAGS*)
          (let
              ((bound_fn (-> create_dom_element `bind create_dom_element tagname)))
            ;; use the set_global function directly since we are dynamically creating the symbol names
            (-> Environment `set_global
                tagname
                bound_fn
                {
                 `initializer: `((quote quote) (-> create_element `bind create_dom_element ,#tagname))
                 `description: (+ "The function " tagname " creates a DOM element of type " tagname " and returns the constructed object.")
                 `usage: [ "options:?object" "elem:*" "elemN:*" ]
                 `tags: ["html" "ui" "DOM" "tags" "element" "node"]
                 })))


;; various helper functions 

(defun set_style (style_attributes elem)
  (when (is_element? elem)
    (let ((`current_style (-> elem `getAttribute "style"))
          (`attribs       (or (no_empties (from_style_text current_style)) []))
          (`combined      (pairs
                           (to_object
                            (conj attribs style_attributes))))
          (`newtext
           (join ";"
                 (for_each (`atr combined)
                           (join ": " atr)))))

      (-> elem `setAttribute "style" newtext)
      elem))
  {
   `tags:["ui" "html" "css" "element" "style"]
   `description:"Given a set of style attributes in the [[attribute value]] form, and an element, sets the element style attribute to contain the specified values. Returns the element."
   `usage:["style_attributes:list" "element:Element"]
   })

(defun has_class? (classname elem)
  (if (and elem
           (is_element? elem))
    (-> elem.classList `contains classname)
    false)
  {
   `usage: ["classname:string" "element:Element"]
   `description: "If the provided element has the specified CSS class, returns true, otherwise the function returns false"
   `tags: ["css" "DOM" "class" "ui" "element" "html"]
   })

(defun add_class (class_name `& elems)
  (do
    (defvar `effected [])
    (= elems (flatten elems))
    (when (and (not (eq nil elems))
               (> elems.length 0))
      (= elems (if (or (instanceof elems.0 NodeList)
                       (instanceof elems.0 HTMLCollection)
                       (is_array? elems.0))
                 elems.0
                 elems))
      (for_each (`e elems)
                (do
                  (when e.classList
                    (push effected e)
                    (-> e.classList `add class_name)))))
    effected)
  {
   `usage: ["class_name:string" "element:Element" "element?:Element"]
   `description: "Removes the designated CSS class from the provided element or elements. Returns the list of nodes."
   `tags: ["ui" "html" "css" "class"]
   })

(defun remove_class (class_name `& elems)
  (do
    (defvar `effected [])
    (= elems (flatten elems))
    (when (and (not (eq nil elems))
               (> elems.length 0))
      (= elems (if (or (instanceof elems.0 NodeList)
                       (instanceof elems.0 HTMLCollection)
                       (is_array? elems.0))
                 elems.0
                 elems))
      (for_each (`e elems)
                (do
                  (when e.classList
                    (push effected e)
                    (-> e.classList `remove class_name)))))
    effected)
  {
   `usage: ["class_name:string" "element:Element" "element?:Element"]
   `description: "Removes the designated CSS class from the provided element or elements. Returns the list of nodes."
   `tags: ["ui" "html" "css" "class"]
   })

(defun set_disabled (`& args)
  (when (and args (> (length args) 0))
    (for_each (`elem (flatten args))
              (if elem (-> elem `setAttribute `disabled "true"))))
  { `description: "Given an arbitrary list of Elements, set them to disabled."
   `tags: ["ui" "html" "css"]
   `usage: ["element:Element" "element?:Element"]
   } )

(defun set_enabled (`& args)
  (when (and args (> (length args) 0))
    (for_each (`elem (flatten args))
              (if elem (-> elem `removeAttribute `disabled))))
  { `description: "Given an arbitrary list of Elements, set them to enabled (removes the disabled property from the Element)."
   `tags: ["ui" "html" "css"]
   `usage: ["element:Element" "element?:Element"]
   } )

(defun remove_attribute (elem `& attribs)
  (when (and elem
             (is_element? elem)
             attribs
             (> attribs.length 0))
    (for_each (attrib (flatten attribs))
              (-> elem `removeAttribute attrib)))
  {
   `description: "Provided a target DOM element and 1 or more attributes, removes each attribute from the targeted DOM element."
   `usage: ["element:Element" "attrib0:string" "attribN:string"]
   `tags: [ `ui `html `attribute `delete ]
   })

(defun attach_event_listener (elem event_type handler_function)
  (when elem
    ((jslambda (`elem `event `f) "return elem.addEventListener(event,f);")  elem event_type handler_function))
  {
   `usage:["element:Element" "event_type:string" "handler:function"]
   `description:"Given an element, an event type such as `click, and a function, attaches the provided function as an event handler to the HTML Element."
   `tags:["ui" "events" "HTML" "events" ""]
   })

(defun remove_css_entry (entry_name)
  (do
    (aif (get_by_id (to_key (+ "juno-css-" entry_name)))
      (-> it `remove)))
  {
   `usage:["entry_name:string"]
   `description:"If a class has been created by create_css_entry, use this function to remove the class from the document."
   `tags: ["html" "css" "ui"]
   })

(defun create_css_entry (entry_name css_attribute_list)
  (let
      ((css_attributes (reduce (attrib_set (or css_attribute_list []))
                               (destructuring_bind (attrib val)
                                                   attrib_set
                                                   (when (and (not (blank? attrib))
                                                              (not (blank? val)))
                                                     (+ "" attrib ": " val)))))
       
       
       (head_elem (-> document `querySelector "head"))
       (new_style nil))

    (when head_elem
      (remove_css_entry entry_name)
      (-> head_elem `appendChild
          (= new_style
             (style { `id: (to_key (+ "juno-css-" entry_name )) `type: "text/css" }
                    (+ "" entry_name "{\n  " (join ";\n" css_attributes) " }")))))
    new_style)
  { `usage: ["entry_name:string" "css_attribute_list:array"]
   `description: (+ " Given a name for the class and a list of formatted css attributes "
                    "create and load the CSS object into the DOM.<br> Example: <br><code> "
                    "(create_css_entry 'FilteredSelect:focus-within' "
                    "                  [[`box-shadow '0px 0px 10px 0px rgba(0,0,0,0.75)']])<br>"
                    " </code>")
   `tags: ["html" "css" "ui"]
   } )

(defun css_entry_to_css_format (entry_name css_attribute_list)
  (let
      ((`style (create_element "style"))
       (`css_attributes (map (fn (v)
                               (+ v.0 ": " v.1))
                             css_attribute_list)))
    (+ "" entry_name " {\n   " (join ";\n   " css_attributes) ";\n}")
    )

  { `usage: ["entry_name:string" "css_attribute_list:array"]
   `description: (+ "Given a name for the class and a list of formatted css attributes returns a formatted string in CSS syntax.<br> Example: <br><code>"
                    "(create_css_entry 'FilteredSelect:focus-within'
                                    [['box-shadow' '0px 0px 10px 0px rgba(0,0,0,0.75)']])<br>"
                    "</code>")
   `tags: ["html" "css" "ui" "convert"]
   } )

(defun_sync handle_event (e)
  (progn
   (-> e `preventDefault)
   (-> e `stopPropagation)))

(defun_sync focus_to (elem)
    (aif elem (-> it `focus)))

(defmacro blur_to (elem)
    `(aif ,#elem (-> it `blur)))

(defun file_picker_button (button_text on_selection)
  (let
      ((elem (html/input { type: "file" 
                          value: (or button_text "Open")
                          onchange: (fn (e)
                                      (let
                                          ((items e.srcElement.files)
                                           (status nil))
                                        (when on_selection
                                          (on_selection items)))) })))
    (declare (fn on_selection html/input)
             (global html/input))
    (when (eq nil on_selection)
      (throw "on_selection is required for file_picker_button"))
    elem))

(defun notify (text type on_click)
        (let
            ((type (or type "info"))
             (timer nil)
             (view (div { `style: (+ "z-index: 5; padding: 5px; position: relative; opacity: 0; cursor: pointer; background: #FFFFFF; border: 1px solid #404040; display: inline-block; width: 250px; overflow: auto; height: 50px; text-overflow: ellipses;" 
                                     (cond
                                         (== type "error")
                                         "border-left: 5px solid #bf0a0a;"
                                         (== type "success")
                                         "border-left: 5px solid #95dc95;"
                                         else
                                         "border-left: 5px solid #5489da;")) }
                         (or text "-"))))
            (when (eq nil (get_by_id "lower_right_corner"))
                  (-> (get_by_id "body")
                      `appendChild (div { `id: "lower_right_corner" `style: "position: absolute; right: 50px; bottom: 5px; width: 255px;" } )))
            
            (-> (get_by_id "lower_right_corner") `appendChild view)
            (-> view `animate [{ `background: "#FFFFFF"  `easing: `ease-in }
                               { `background: "#FFF18830"  `opacity: 1    `easing: `ease-out  `offset: 0.1 }
                               { `background: "#FFFFFF" `opacity: 1 `easing: `ease-out } ] 
                           { `duration: 3000 })
            
            (= timer (setTimeout (fn ()
                                   (do 
                                     (-> view `animate [{ `opacity: 0  `easing: `ease-in } ] { `duration: 250 })
                                     (setTimeout (fn () (do
                                                          (-> view `remove)
                                                          (= timer nil)
                                                          (= view nil)))
                                                 250)))                                                   
                            10000))
            (setTimeout (fn ()
                            (set_style [["opacity" 1]] view))
                        200)
            (attach_event_listener view
                 `click
                 (fn (e)
                     (do
                         (when timer (clearTimeout timer))
                         (when view (-> view `remove))
                         (= view nil)
                         (= timer nil)
                         (when on_click
                               (on_click type text)))))
            true)
        {
         `usage: ["text:string" "type?:string" "on_click?:function"]
         `description: (+ "Given a obligatory text string, and an optional type, and on_click function, " 
                          "show an alert for 10 seconds in the lower right hand corner."
                          "<br><br>"
                          "Types are as follows: <br>"
                          "error<br>"
                          "success<br>"
                          "info (default)<br>"
                          "<br>Returns true, but is of no significance.")
         `tags: ["ui" "alerts" "alerting" "message" "notify"]
         })

(defun read_file (file options)
    (new Promise
         (fn (resolve reject)
           (let
               ((reader (new FileReader))                
                (options (+ {}                          
                            {
                             `read_as: "binary"
                             `details: false
                             }
                            options))
                (read_as options.read_as))
             (set_prop reader
                       `onload
                       (function (e)
                                 (progn
                                  (resolve
                                   (cond
                                     options.details
                                     {
                                      `name: file.name
                                      `type: file.type
                                      `size: file.size
                                      `data: reader.result                                     
                                      }
                                     else
                                     reader.result))))
                       `error
                       (function (e)
                                 (reject e)))
             
             (cond
               (or (== read_as "binary")
                   (== read_as "ArrayBuffer"))
               (-> reader `readAsArrayBuffer file)
               (== read_as "text")
               (-> reader `readAsText file)
               (== read_as "binaryString")
               (-> reader `readAsBinaryString file)
               (== read_as "dataURL")
               (-> reader `readAsDataURL file))))))



(defun control_tree (content_list control_lambda _parent)
  (cond
    (is_array? content_list)    
    (reduce (c content_list)
            (control_tree c control_lambda _parent))               
    content_list.view
    (progn
     (when control_lambda
       (control_lambda content_list _parent))
     (= _parent content_list)
     (if content_list.controls
       [ content_list (control_tree (-> content_list `controls) control_lambda _parent) ]
       content_list))
     
    (is_element? content_list)
    { view: content_list }))
                    
(defvalue *frame_count* -1)
(defvalue *view_count* -1)

(defun control_container (content options)
  (let
      ((contained_content nil)
       
       (resize_observer nil)
       (options (or options {}))
       (name (or options.name
                 (and options.root_frame (+ "Frame " (inc *frame_count*)))
                 (+ "view-" (inc *view_count*))))
       (id (or options.id (generate_id "container")))       
       (init_timer nil)
       (view (div { `control_id: id `class: "juno-view-container" } ))
       (initialized false)
       (parent_view nil)
       (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
       (perform_resize (fn ()
                         (when view.parentElement
                           (check_observer)
                           (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 0))
                                (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                             
                             (set_style [[ "width" (+ "" new_width "px") ]
                                         [ "height" (+ "" new_height "px") ]]
                                        view)))))
       (set_content (fn (position new_content) ;; position is discarded but it is essentially 0 since this is a single unit container
                      (let
                          ((new_view nil))
                        (= new_view
                           (cond
                             new_content.view
                             new_content.view

                             (is_element? new_content)
                             new_content
                             
                             else
                             (progn
                              (if new_content 
                                (div { } (as_lisp new_content))
                                (div { `class: "juno-empty-content" } "Set Content")))))
                        (-> view `replaceChildren new_view)
                        (if (not new_content.view)
                          (= contained_content
                             {
                              `view: view
                              })
                          (= contained_content new_content))
                        (perform_resize)
                        (when new_content.initialize
                          (-> new_content `initialize))  ;; initialize if not already
                        view)))
       (initialize (fn ()
                     (progn
                      (when init_timer
                        (clearInterval init_timer)
                        (= init_timer nil))
                      (when (not initialized)
                        (= initialized true))
                      (when view.parentElement
                        (= parent_view view.parentElement)
                        (-> resize_observer `observe view.parentElement)
                        (perform_resize)
                        (console.log "control_container: initializing with: " content)
                        (when content
                          (set_content 0 content))
                        (when (is_function? contained_content.initialize)
                          (-> contained_content `initialize))))))
       (destroy (fn ()
                  (progn
                   (when (is_function? contained_content.destroy)
                     (-> contained_content `destroy)))))
                        
       (intf (new Object)))
    
    (set_prop options
              `name
              name
              `id
              id)
    
    (= resize_observer (new ResizeObserver perform_resize))
    
    (= init_timer (setInterval (fn (e)
                                   (progn
                                    (when view.parentElement
                                      (clearInterval init_timer)
                                      (= init_timer nil)
                                      (initialize))))
                               250))
    
    
    (set_prop intf
              `view view              
              `initialize initialize              
              `set_content set_content
              `name options.name
              `resize: perform_resize
              `menu_items options.menu_items
              `controls (fn () [contained_content])
              `toJSON (function ()
                                 `(control_container ,#contained_content ,#options))
              `type `control_container
              `options options)))

(defun split_view_vertical (content_a content_b options)
  (let
      ((center_width 7)
       (right_margin 5)
       (options (or options { }))
       (id (or options.id (generate_id "split_view_vertical")))
       (center_divider (div { `class: "juno-vertical-dragger"
                              `style: (+ " top: 0px; left: 50%; cursor: col-resize; height: 100%; width: " center_width "px") }))
       (left_container (div { `class: "juno-view-container" }
                            (if content_a.view
                              content_a.view
                              content_a)))
       (right_container (div { `class: "juno-view-container" }
                            (if content_b.view
                              content_b.view
                              content_b)))
       (view_overlay (div { `style: "width: 0%; height: 0%; position: absolute; top: 0px; left; 0px; background: transparent; cursor: col-resize" }))
       (view (div { `control_id: id  `class: "juno-vertical-split-container" `style: "height: calc(100% - 5px); width: 100%;" }
                  left_container
                  center_divider
                  right_container
                  view_overlay
                  ))
       (parent_view nil)
       (drag_status nil)       
       (resize_observer nil)
       (center_pos nil)
       (initialized false)
       (init_timer nil)       
       (lock_ratio (function (state)
                             (when (not drag_status)
                              (if state
                                (set_prop options
                                          `ratio_locked
                                          true)
                                (set_prop options
                                          `ratio_locked
                                          false)))))                                              
       (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
       (perform_resize (fn ()
                         (when view.parentElement
                           (check_observer)
                           (if (isNaN (- (prop view.parentElement `offsetHeight) 5))
                             (progn
                              (console.log "split_view_vertical: cannot get parent height is NAN: " view.parentElement)
                              (setTimeout perform_resize 1000))
                             (let
                                 ((new_height (- (prop view.parentElement `offsetHeight) 5))
                                  (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                               
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               ;; get the center position - set it to the midpoint if we are just initializing
                               (when (== center_pos nil)
                                 (cond
                                   (and options.ratio
                                        (is_number? options.ratio))
                                   (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth))
                                   options.ratio
                                   (throw TypeError "Invalid ratio option: must be a number between 0 and 1")
                                   else
                                   (= center_pos (/ view.offsetWidth 2))))
                               
                               (when (and (== drag_status nil)
                                          (or (isNaN options.ratio)
                                              (isNaN center_pos)))
                                 (console.log "split_view_vertical: options.ratio is NaN: " options.ratio "center_pos: " center_pos)
                                 (set_prop options
                                           `ratio
                                           0.5)
                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth))
                                 (console.log "split_view_horizontal: center_pos now:" center_pos))
                               
                               (when (> center_pos (- new_width 20))
                                 (= center_pos (Math.max 20 (- new_width 20))))
                               
                               (when (and (== drag_status nil)  ;; not doing a drag so we need to preserve the ratio
                                          (is_number? options.ratio))
                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth)))
                               
                               (set_style [["width" (+ (- center_pos center_width) "px") ]]                                         
                                          left_container)
                               (set_style [["width" (+ "" center_width "px") ]] center_divider)
                               (set_style [["width" (+ (- view.offsetWidth center_pos center_width right_margin) "px") ]]
                                          right_container)
                               
                               (set_prop options
                                         `ratio
                                         (/ center_pos view.offsetWidth))
                                        ;(console.log "[" left_container.offsetWidth "<->" right_container.offsetWidth "]")
                               )))))
       (init_drag (fn (e)
                    (when (and (not options.ratio_locked)
                               (== drag_status nil))
                      (= drag_status 1)
                      (set_style [["width" "100%"]
                                  ["height" "100%"]] view_overlay)
                      ;; since our overlay covers the center_divider add a class to indicate activity
                      ;; on the center divider
                      (add_class "juno-active-hover" center_divider))))
       
       (complete_drag (fn (e)
                        (progn
                         (set_style [["width" "0%"]
                                     ["height" "0%"]] view_overlay)
                         (remove_class "juno-active-hover" center_divider)
                         (= drag_status nil)                         
                         (perform_resize))))
       (perform_drag (fn (e)
                       (progn
                        (-> e `preventDefault)
                        (when drag_status                          
                          (if (== e.buttons 0)
                            (complete_drag)
                            (progn
                             (= center_pos (Math.max 20 (Math.min e.offsetX (- view.offsetWidth 20))))))
                          (perform_resize)))))
       (intf {})                                                                    
       (initialize (fn ()
                     (progn
                      (when init_timer
                        (clearInterval init_timer)
                        (= init_timer nil))
                      (console.log "split_view_vertical: initialize called: " initialized)
                      (when (not initialized)                       
                        (= initialized true)
                        (= parent_view view.parentElement)
                        (-> resize_observer `observe view.parentElement)
                        (perform_resize)
                        (console.log "split_view_vertical initialized:" initialized)
                        (when content_a.initialize
                          (-> content_a `initialize))
                        (when content_b.initialize
                          (-> content_b `initialize))))))
       (destroy (fn ()
                  (progn
                   (when (is_function? content_a.destroy)
                     (-> content_a `destroy))
                   (when (is_function? content_b.destroy)
                     (-> content_b `destroy)))))
       (set_content (fn (position new_content)
                      (if (and position new_content
                               (or (== position 0) (== position 1)))
                        (let
                            ((target_container (if (== position 0)
                                                 left_container
                                                 right_container)))
                          (console.log "split_view_vertical: adding new content: " new_content)
                          (if (== position 0)
                            (= content_a new_content)
                            (= content_b new_content))
                          (cond
                            new_content.view ;; we have been given a control
                            (progn                             
                             (-> target_container `replaceChildren new_content.view)
                             (when new_content.initialize
                               (-> new_content `initialize)))
                            (is_element? new_content)                                                         
                            (-> target_container `replaceChildren new_content)
                            else
                            (-> target_container `replaceChildren (pre
                                                                   (JSON.stringify new_content nil 4))))
                          (perform_resize)
                          (console.log "split_view_vertical: added new content: " new_content)
                          true)
                        (throw "set_content: invalid or missing arguments")))))

    ;; set up the events
    (attach_event_listener view_overlay
                           `mousemove
                           (fn (e)
                             (progn
                              (handle_event e)
                              (when drag_status
                                (perform_drag e)))))
                             
    (attach_event_listener view_overlay
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))

    (attach_event_listener center_divider
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))
    (attach_event_listener center_divider
                           `mousedown
                           (fn (e)
                             (progn                              
                              (handle_event e)                              
                              (init_drag e))))

   

    (= resize_observer (new ResizeObserver perform_resize))
    (console.log "split_view_vertical: ready: initialized: " initialized)
    (when true ;options.auto_initialize
      (= init_timer (setInterval (fn (e)
                                   (progn
                                    (when view.parentElement
                                      (clearInterval init_timer)
                                      
                                      (= init_timer nil)
                                      (initialize))))
                                 250)))
    (set_prop options
              `ratio_locked (or options.ratio_locked false)
              `id id
              `name (or options.name
                        (+ "vertical-split-" (inc *view_count*))))
    (set_prop intf
     `view view
     `initialize initialize
     `set_content set_content
     `lock_ratio lock_ratio
     `options options
     `destroy destroy
     `name options.name
     `resize perform_resize
     `type `split_view_vertical
     `controls (fn () [ content_a content_b ])
     `toJSON (function ()
                       `(split_view_vertical ,#content_a ,#content_b ,#options)))
    intf))
                             

(defun split_view_horizontal (content_a content_b options)
  (let
      ((center_height 7)
       (bottom_margin 5)
       (options (or options {}))
       (id (or options.id (generate_id "split_view_horizontal")))
       (center_divider (div { `class: "juno-horizontal-dragger"
                              `style: (+ "cursor: row-resize; width: 100%; height: " center_height "px") }))
       (top_container (div { `class: "juno-view-container" }
                            (if content_a.view
                              content_a.view
                              content_a)))
       (bottom_container (div { `class: "juno-view-container" }
                            (if content_b.view
                              content_b.view
                              content_b)))
       (view_overlay (div { `style: "width: 0%; height: 0%; position: absolute; top: 0px; left; 0px; background: transparent; cursor: row-resize" }))
       (view (div { `control_id: id `class: "juno-horizontal-split-container" `style: "height: calc(100% - 5px); width: 100%;margin: 0px; padding: 0px;" }
                  top_container
                  center_divider
                  bottom_container
                  view_overlay
                 ))
       (drag_status nil)
       (initialized false)
       (resize_observer nil)
       (center_pos nil)
       (initialized false)
       (init_timer nil)
       (lock_ratio (function (state)
                             (when (not drag_status)
                              (if state
                                (set_prop options
                                          `ratio_locked
                                          true)
                                (set_prop options
                                          `ratio_locked
                                          false)))))           
       (parent_view nil)
       (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
       (perform_resize (fn ()
                         (when view.parentElement
                           (check_observer)
                           (if (isNaN (- (prop view.parentElement `offsetHeight) 5))
                             (progn
                              (console.log "split_view_horizontal: cannot get parent height is NAN: " view.parentElement)
                              (setTimeout perform_resize 1000))
                             (let
                                 ((new_height (- (prop view.parentElement `offsetHeight) 5))
                                  (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                               
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               ;; get the center position - set it to the midpoint if we are just initializing
                               (when (== center_pos nil)
                                 (cond
                                   (and options.ratio
                                        (is_number? options.ratio))
                                   (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight))
                                   options.ratio
                                   (throw TypeError "Invalid ratio option: must be a number between 0 and 1")
                                   else
                                   (= center_pos (/ view.offsetHeight 2))))  ;; default is 50% 0.5
                               (when (and (== drag_status nil)
                                          (or (isNaN options.ratio)
                                              (isNaN center_pos)))
                                 (console.log "split_view_horizontal: options.ratio is NaN: " options.ratio "center_pos: " center_pos)
                                 (set_prop options
                                           `ratio
                                           0.5)
                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight))
                                 (console.log "split_view_horizontal: center_pos now:" center_pos))
                               
                               (when (> center_pos (- new_height 40))
                                 (= center_pos (Math.max 20 (- new_height 40))))

                               (when (and (== drag_status nil)  ;; not doing a drag so we need to preserve the ratio
                                          (is_number? options.ratio))
                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight)))
                               
                               (set_style [["height" (+ "" center_pos  "px") ]]
                                          top_container)
                               (set_style [["height" (+ "" center_height "px") ]] center_divider)
                               (set_style [["height" (+ (- view.offsetHeight center_height center_pos 0) "px") ]]                                         
                                          bottom_container)
                               (set_prop options
                                         `ratio
                                         (/ center_pos view.offsetHeight))
                                        ;(console.log "[" top_container.offsetHeight "<|>" bottom_container.offsetHeight "]")
                               )))))
       (init_drag (fn (e)
                    (when (and (not options.ratio_locked)
                               (== drag_status nil))
                      (= drag_status 1)
                      (set_style [["width" "100%"]
                                  ["height" "100%"]] view_overlay)
                      ;; since our overlay covers the center_divider add a class to indicate activity
                      ;; on the center divider
                      (add_class "juno-active-hover" center_divider))))
       
       (complete_drag (fn (e)
                        (progn
                         (set_style [["width" "0%"]
                                     ["height" "0%"]] view_overlay)
                         (remove_class "juno-active-hover" center_divider)
                         (= drag_status nil)                         
                         (perform_resize))))
       (perform_drag (fn (e)
                       (progn
                        (-> e `preventDefault)
                        (when drag_status
                          ;(console.log "view_overlay: center_pos: " center_pos "offsetY: " e.offsetY "movementX: " e.movementY)
                          (if (== e.buttons 0)
                            (complete_drag)
                            (progn
                             (= center_pos (Math.max 20 (Math.min (- e.offsetY center_height 3) (- view.offsetHeight 40))))))
                          (perform_resize)))))
       (intf {})
       (initialize (fn ()
                     (progn
                      (when init_timer
                        (clearInterval init_timer)
                        (= init_timer nil))
                      (when (not initialized)
                        (= initialized true)
                        (= parent_view view.parentElement)
                        (-> resize_observer `observe view.parentElement)
                        (perform_resize)
                        (console.log "split_view_horizontal initialized: " initialized)
                        (when content_a.initialize
                          (-> content_a `initialize))
                        (when content_b.initialize
                          (-> content_b `initialize))))))
       (destroy (fn ()
                  (progn
                   (when (is_function? content_a.destroy)
                     (-> content_a `destroy))
                   (when (is_function? content_b.destroy)
                     (-> content_b `destroy)))))
       (set_content (fn (position new_content)
                      (if (and position new_content
                               (or (== position 0) (== position 1)))
                        (let
                            ((target_container (if (== position 0)
                                                 top_container
                                                 bottom_container)))
                          (if (== position 0)
                            (= content_a new_content)
                            (= content_b new_content))
                          (cond
                            new_content.view ;; we have been given a control
                            (progn                             
                             (-> target_container `replaceChildren new_content.view)
                             (when new_content.initialize
                               (-> new_content `initialize)))
                            (is_element? new_content)                                                         
                            (-> target_container `replaceChildren new_content)
                            else
                            (-> target_container `replaceChildren (pre
                                                                   (JSON.stringify new_content nil 4))))
                          (perform_resize)
                          true)
                        (throw "set_content: invalid or missing arguments")))))
                          
                                                        
    ;; set up the events
    (attach_event_listener view_overlay
                           `mousemove
                           (fn (e)
                             (progn
                              (handle_event e)
                              (when drag_status
                                (perform_drag e)))))
                             
    (attach_event_listener view_overlay
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))

    (attach_event_listener center_divider
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))
    (attach_event_listener center_divider
                           `mousedown
                           (fn (e)
                             (progn                              
                              (handle_event e)                              
                              (init_drag e))))
  
    (= resize_observer (new ResizeObserver perform_resize))
    (console.log "split_view_horizontal: ready: initialized: " initialized)
    (when true ;options.auto_initialize
      (= init_timer (setInterval (fn (e)
                                   (progn
                                    (when view.parentElement
                                      (clearInterval init_timer)
                                      (= init_timer nil)
                                      (initialize))))
                                 250)))
    (set_prop options
              `ratio_locked (or options.ratio_locked false)
              `id id
              `name (or options.name
                        (+ "horizontal-split-" (inc *view_count*))))
    
    (set_prop intf
     `view view
     `initialize initialize
     `options options
     `name options.name
     `resize perform_resize
     `destroy destroy
     `type `split_view_horizontal
     `controls (fn () [ content_a content_b ])
     `toJSON (function ()
                       `(split_view_horizontal  ,#content_a ,#content_b ,#options))
     `lock_ratio lock_ratio
     `set_content (fn (position new_content)
                        (set_content position new_content)))
     
    intf))


(defun tabs (tab_list)
  (let
      ((view nil)       
       (add_tab (fn (name content closable)
                  true))
       (header nil)
       (head_tabs [])
       (body_tabs [])       
       (remove_tab (fn (name)
                     true)))
       
    ;; setup the initial view
    (setq view
          (div { `class: "tabWrap" }
               ;; tab headers
               (setq header
                     (ul { `class: "tabHead" }
                         (map (fn (entry idx)                      
                                (progn
                                 (push head_tabs
                                       (li { `idx: idx }
                                           entry.0
                                           (if entry.2
                                             (span { `style: "float: right" } "x")
                                             [])))
                                 (last head_tabs)))
                              tab_list)))
               (map (fn (entry idx)                      
                      (progn
                       (-> entry.1.classList `add "tabBody")
                       (-> entry.1 `setAttribute "idx" idx)
                       (push body_tabs entry.1)
                       (last body_tabs)))
                    tab_list)))
    (attach_event_listener header
                           `click
                           (fn (e)
                             (let
                                 ((src e.srcElement)
                                  (btab nil)
                                  (idx (-> src `getAttribute "idx")))
                               (for_each (elem header.children)
                                         (cond
                                           (and (== e.srcElement.tagName "LI")
                                                (== elem e.srcElement))
                                           (progn
                                            (-> elem.classList `add "open")
                                            (= btab (prop body_tabs (parseInt (-> src `getAttribute `idx))))
                                            (when btab
                                              (-> btab.classList `add "open")))
                                           (and (== e.srcElement.tagName "LI")
                                                (is_element? elem))
                                           (progn
                                            (-> elem.classList `remove "open")
                                            (= btab (prop body_tabs (parseInt (-> elem `getAttribute `idx))))
                                            (when btab
                                              (-> btab.classList `remove "open"))))))))
                                  
    {
     `view: view
     `add_tab: add_tab
     `remove_tab: remove_tab
     }))
          
 ;; (defglobal tabview (tabs [["Tab 1" (div "Hi this is tab 1") true ] ["Tab 2" (div "This is tab 2") ]]))                


(set_prop (get_by_id "juno-css")
          `textContent
          style_css)
    
(console.log "html is loaded");
(register_feature "html")
(load_pends "html")
true
