;; TODO: SPLIT UP INTO SEPARATE FILES - TOO LARGE 
;; main browser initialization file - initializes the user browser environment
;; after the browser_workspace has setup the underlying environment

(defglobal main_menu_button nil) ;; placeholders 
(defglobal resource_loader_button nil)
(defglobal juno_container nil)
(defglobal repl_editor nil)
(defglobal *scratch* ";; *scratch* buffer\n\n")
(defvalue *key_bindings* {
                           repl:{}
                           editor:{}
                           global:{}
                           active: {}
                           })



(defvalue *main_menu* [])
(defvalue *serialized_controls* [])
(defparameter *tags_to_meta* {})
(defparameter core/$current_control nil)

;; the controls at the top level of the view
(defparameter core/$root_controls [])

(defparameter core/*system_repl* nil)

(console.log "browser_initializer running")

;; the global pointer to the control which has focus
;; nil if there are no focus points or values.

(defparameter core/is_served? (and (not (blank? (resolve_path [ `location `hostname ] window)))
                                   (== (prop (fetch "/files") `status) 200)))
(defparameter filesystem {})
(defparameter *last_focus* nil)
(defparameter *last_top_frame* nil)
(defparameter *app_menu_control* nil)
(defparameter *log_key_events* false)
(defparameter *document_focused* true)

(defparameter *whitespace_regexp* (new RegExp "\\\\s" `g))

(defparameter TokenIterator (function () true)) ;; filled in by the first editor

(defparameter
    *editor_themes*
    (reduce (included_lib (or *env_config*.included_libraries []))
        (aif (starts_with? "theme" included_lib)
            (second (split_by "-" (first (split_by "." included_lib)))))))

(set_prop *key_bindings*.repl          
          `history_next_entry { win: "Ctrl-Alt-n" mac: "Ctrl-Alt-n" }                                                               
          `history_prior_entry { win: "Ctrl-Alt-p" mac: "Ctrl-Alt-p" })

(create_css_entry "td.juno-obj-to-dom-key"
                  [["vertical-align" "top"]
                   ["color" "#881280"]
                   ["text-align" "right"]
                   ["font-weight" "bold"]
                   ["padding-right" "5px"]])


;;(create_css_entry "span.juno-value"
 ;;                 [["display" "inline-block"]])
   
;;(create_css_entry "li.juno-array-item"
;;                  [["list-style" "decimal"]])   
 
;; for determining keycodes
(defun get_operating_platform ()
    (if (contains? "Macintosh" navigator.userAgent)
        "mac"
        "win")
    {
        `usage: []
        `description: (+ "If the browser is running on a Macintosh system, " 
                         "will return mac, otherwise it will return win")
        `tags: ["os" "system" "platform" "architecture" "host" "navigator" ]
    })
      
(defun message (text)
  (div { `style: "border-left: 5px solid darkblue; padding: 5px;" } text))

(defun error_message (text)
  (div { `style: "border-left: 5px solid red; padding: 5px;" } text))

(defun log_error (message error_instance)
  (progn
   (log (error_message message))
   (console.error message)
   (when error_instance
     (when error_instance.messasge
       (error_message error_instance.message))
     (console.error error_instance))))
     


(defun_sync value_to_dom (val options _path)
  (let 
      ((classes "juno-value juno-type-")
       (options (or options {}))
       (new_opts nil)
       (make_input (function ()
                      (let
                         ((dtype (or (and path_opts
                                           (resolve_path [ `type ] path_opts))
                                      (sub_type val)))
                          (input_elem (cond
                                         (and path_opts
                                            (resolve_path [ `values ] path_opts))
                                         select
                                         else
                                         input))
                          (selections (if (== input_elem select)
                                          (for_each (`vset (resolve_path [ `values ] path_opts))
                                             (progn
                                                (if (is_array? vset)
                                                   (option (+ { `value: vset.1 } 
                                                              (if (== vset.1 val)
                                                                  { selected: true }
                                                                  {}))
                                                           vset.0)
                                                   (option 
                                                       (if (== vset val)
                                                           { selected: true }
                                                           {})
                                                       vset))))
                                          [])))
                         (declare (function input_elem))
                         (input_elem (+ (cond
                                         (== dtype "Boolean")
                                         { type: "checkbox" }
                                         (not (== (lowercase dtype) "string"))
                                         { type: dtype }
                                         else
                                         {})
                                      (if options.namespace { `ns: options.namespace } {})
                                      (if (or options.read_only
                                              (and path_opts
                                                 (resolve_path [ `read_only ] path_opts)))
                                          { `disabled: true }
                                          {})
                                      { `lpath: (lpath) `tabindex: 0 `class: (+ classes (lowercase dtype)) }
                                      { `title: (lpath) }
                                      (cond 
                                         (== dtype "Boolean")
                                         (if val
                                            { checked: true }
                                            {})
                                         (== dtype "Date")
                                         { `value: (first (split_by "T" (-> val `toISOString))) }
                                         (not (blank? val))
                                         { `value: val }
                                         else
                                         {}))
                                     selections))))
       (set_displayed_value (function (elem value)
                               (progn
                                  (cond
                                     (is_date? value)
                                     (set_prop elem `value (first (split_by "T" (-> value `toISOString))))
                                     (or (== true value)
                                         (== false value))
                                     (set_prop elem `checked value)
                                     else
                                     (set_prop elem `value value)))))
                                  
                                  
       (elem nil)
       (is_root? (eq nil _path))
       (_path (or _path [] ))
       (path_opts (resolve_path (conj ["paths"] _path) options))
       (lpath (function () (join "~" _path))))
    (declare (function array_to_dom obj_to_dom function_to_dom)
             (global array_to_dom obj_to_dom function_to_dom))
    
    (if path_opts
       (progn
          ;(log "found path_opts: " (lpath) path_opts)
          (= new_opts (clone options))
          (if (and path_opts.read_only
                   (== true path_opts.read_only))
             (set_prop new_opts
                `read_only true)))
       (= new_opts options))
          
    (= elem
       (cond 
         (is_array? val)
         (progn
            (array_to_dom val new_opts _path))
         (is_element? val)
         (progn
          (if val.parentElement
            (details
             (summary (+ {} (if options.namespace
                               { ns: options.namespace }
                               {})
                         { `lpath: (lpath) 
                           `class: (+ classes "view") 
                           `tabindex:0 }) 
                      (+ (sub_type val) " "))
             (span { `tabindex: 0 `style: "font-family: var(--main-app-font)" } "[ RENDERED ELEMENT ]"))
            val))
         (is_regex? val)
         (span (+ {} (if options.namespace
                         { `ns: options.namespace }
                         {})
                  { `lpath: (lpath) 
                    `tabindex: 0  
                    `class: (+ classes "regexp") }) 
               (-> val `toString))
         (and (is_date? val)
              (not options.editable))
         (span (+ {} (if options.namespace
                         { `ns: options.namespace }
                         {})
                  { `lpath: (lpath) 
                    `tabindex: 0  
                    `class: (+ classes "regexp") }) 
               (-> val `toISOString))
         (and (is_string? val)
              (not options.editable))
         (if (starts_with? "=:" val)
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0  `class: (+ classes "symbol") } )
                 (JSON.stringify val))
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0 `class: (+ classes "string") }) 
                 (JSON.stringify val)))
         
         (instanceof val Error)
         (details (summary { `class: (+ classes "error") } 
                           (span { `tabindex: 0 `class: (+ classes "error") `style: "margin-left: 5px; font-style: italic;" } val.name " " val.message))
          (if val.details  ;; there is a details rider on this error from the compiler, print it
              (value_to_dom val.details)
              (progn
                 (defvar tmp (pre { `tabindex: 0 `class: (+ classes "error") }))
                 (set_prop tmp `innerHTML (join "\n" (rest (split_by "\n" val.stack))))
                 tmp)))
         (is_function? val)
         (function_to_dom val options _path)
         (and (is_object? val)
              (not (is_date? val)))
         (obj_to_dom val new_opts _path)
         options.editable
         (make_input)
         else
         (span  (+ {} (if options.namespace { `ns: options.namespace } {}) 
                   { `lpath: (lpath) `tabindex: 0 `class: (+ classes (lowercase (sub_type val))) }) 
               val)))
    (when (and is_root?
               options.editable
               (eq nil options.namespace))
       (attach_event_listener elem
          `change
          (fn (e)
             (let
                ((changed_lpath (get_attribute e.srcElement `lpath))
                 (changed_path (if changed_lpath 
                                   (split_by "~" changed_lpath)))
                 (dtype nil)
                 (new_val nil))
                (when changed_path
                   (= dtype
                      (cond
                         (and options.paths
                            (resolve_path (conj changed_path [`type]) options.paths))
                         (resolve_path (conj changed_path [`type]) options.paths)
                         (get_attribute e.srcElement `type)
                         (get_attribute e.srcElement `type)
                         else
                         "string"))
                   
                   (= new_val 
                      (cond
                         (== dtype "integer")
                         (parseInt e.srcElement.value)
                         (== dtype "Number")
                         (float e.srcElement.value)
                         (or (== dtype "Boolean")
                             (== dtype "checkbox"))
                         (progn
                            (if (prop e.srcElement `checked)
                                true
                                false))
                         (== dtype "Date")
                         (new Date e.srcElement.value)
                         else
                         e.srcElement.value))
                   (cond 
                      (and options 
                         (is_function? options.on_change))
                      (progn
                         (= new_val (-> options `on_change lpath new_val))
                         (cond
                            (eq nil new_val)
                            (progn
                               (set_displayed_value e.srcElement (resolve_path changed_path val))
                               (set_prop e.srcElement `value
                                  (resolve_path changed_path val)))
                            else
                            (progn
                               (set_path changed_path val new_val)
                               (set_displayed_value e.srcElement new_val))))
                      else
                      (set_path changed_path val new_val))
                   (when options.debug
                      (notify (+ "Changed Path: " changed_lpath ": " dtype ": " new_val ))))))))
    elem)
  {
    description: (+ "<br><br>The `value_to_dom` function renders an arbitrary data structure to a "
                    "DOM representation and returns a DOM ready element.  Objects and their "
                    "hierarchies are rendered recursively.  The types that naturally render to the "
                    "DOM are strings, numbers, primitive objects, arrays, RegExp instances, "
                    "functions, Dates, and Booleans.  The log_view control as part of the "
                    "visual_repl control uses this facility for output mode when in `tree` mode, "
                    "which is the default output mode.<br>Additionally if the option `editable` is "
                    "passed, the rendered object will be displayed with appropriate input fields "
                    "which the user can then use to modify the values of the rendered object.  In "
                    "edit mode, data types can be specified using the `paths` option, which allows "
                    "for limiting selection or making certain paths read only.  <br><br>#### Options "
                    " <br><br>editable:boolean -If true, the object values will be rendered with the "
                    "HTML inputs which the user can use to edit.  Upon the `change` event, the value "
                    "of the rendered object will be changed.  <br>on_change:function -If provided, "
                    "this function is called on the change event, and is passed the path and edited "
                    "value `(path new_value)` as arguments.  If the function returns nil, the new "
                    "value isn\'t accepted and the value prior to the change is restored to the input "
                    "field.  Otherwise, the returned value from the function is used as the new "
                    "value for the object, and the corresponding input element displayed value will "
                    "be updated with the `on_change` function\'s returned value.<br>paths:object -The "
                    "`paths` value allows for more control over the display, data type and values of "
                    "the presented input elements.  The paths object is structured to match the "
                    "structure of the provided object, where the leaves of the displayed object look "
                    "for attributes in the path object at the corresponding path.<br>In the "
                    "following example, the `*env_config*` object would be displayed to the REPL "
                    "output, with corresponding input fields being displayed at the leaves of the "
                    "object.  If a parent structure is marked read only, all leaves in the "
                    "corresponding structure are read only as well:```(value_to_dom *env_config* \n  "
                    "           { `editable: true \n                `paths: {\n                   "
                    "`features: {\n                        `read_only: true\n                    }\n   "
                    "                `included_libraries: {\n                        `read_only: "
                    "true\n                    }\n                    `editor:{\n                      "
                    " `extensions_to_mode: {\n                            `read_only: true\n          "
                    "                 }\n                        `default_theme: {\n                  "
                    "                       values: *editor_themes*\n                                "
                    "         }\n                    }\n                    `application: {\n          "
                    "             `global_theme: {\n                            values: (keys "
                    "*global_themes*)\n                        }\n                    }\n              "
                    " }  \n                \n              })```<br><br>The above will display the "
                    "*env_config* as a hierarchical form, with some values being completely "
                    "non-editable, either due to a parent being set to read_only, or the leaf itself "
                    "being declared read only.  Note that the `editable` flag is set to `true`.  All "
                    "paths under the `inlcuded_libraries` and `features` keys are read_only.  "
                    "Specific values for `editor.default_theme` and `application,.global_theme` are "
                    "selection types, not free form text inputs.  <br>When a value is determined to "
                    "be a non-string value, either through the value itself, or a declaration in the "
                    "paths via the `type` key, then the input field will be modified accordingly to "
                    "the type.  For example if a Date type is specified, the a Date value will be "
                    "selected.  Similar for Numbers and Booleans.  <br>The path modifiers are as "
                    "follows<br>read_only:boolean - If true, then the value will not be editable.  "
                    "If this is a containing type, such as an Object or Array, then the children "
                    "within it will be non-editable.<br>type:string - Specifies the type of value "
                    "that is placed at the path. Values can be `Date`, `Boolean`, `Number`.  "
                    "Otherwise the default value will be string, or the detected type of the value "
                    "itself.<br>values:array - If present the input element is presented as a select "
                    "box with the options being the array elements provided in the `values` key.  "
                    "The array format can either be single values, such as `[\"Choice 1\" \"Choice 2\"]` "
                    "or pairs, as in `[[\"Select Value\" nil] [\"Good\" 10] [\"Imperfect\" 5] "
                    "[\"Unacceptable\" 0]]`, where in the latter, the value placed in the target "
                    "object is the second numeric value, and the presented value is the first text "
                    "value.<br><br><br>### Example\n\n <br><br>In the below example, a tester object "
                    "is established, and rendered with `value_to_dom` with an `on_change` function "
                    "as well as paths which show different presentation effects and their "
                    "impacts.  ```(defglobal tester\n   {\n     name: \"\"\n     inspect_date: nil\n    "
                    "count: 0\n     confirmed: true\n     quality: nil\n     })\n \n(value_to_dom \n  "
                    "tester\n   { `editable: true\n     `debug: true\n     `on_change: (function (path "
                    "value)\n                    (progn\n                       ;(log \"on_change: \" "
                    "path value)\n                       (cond\n                          (is_string? "
                    "value)\n                          (uppercase value)\n                         "
                    "(is_number? value)\n                          (if (>= value 0)\n                 "
                    "            value\n                              nil)\n                         "
                    "else\n                          value)))\n     `paths:{\n         `count: {\n      "
                    "      type: \"Number\"\n             read_only: false\n         }\n        "
                    "`inspect_date: {\n             type: \"Date\"\n         }\n         `quality: {\n    "
                    "        `type: \"Number\"\n             `values: [ [\"Select Quality\" nil]\n        "
                    "               [\"Good\" 10 ]\n                        [\"Imperfect\" 5]\n           "
                    "            [\"Unacceptable\" 0] ]\n         }\n     }\n    })```<br><br><br><br> ")
    usage: ["value:*" "options:?object"]
    tags: ["UI" "DOM" "value" "element" "view"]
  }
  )

(defun_sync function_to_dom (val options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (lowercase (subtype val)))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } (-> val `toString)))))
    (assert (is_function? val))
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              (aif (fn_signature val)
                                   (if (== it.type "class")
                                     (+ "class " it.name)                                            
                                     (+ (if (== it.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " it.args)
                                        "))")))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem)
  {
    description: "See value_to_dom for documentation details."
    usage: ["value:*" "options:?object"]
    tags: ["UI" "DOM" "value" "element" "view"]
    })
    
(defun_sync remote_function_to_dom (fdesc options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (cond
                 (== fdesc.type "async")
                 "asyncfunction"
                 (== fdesc.type "sync")
                 "function"
                 else
                 fdesc.type))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } fdesc.body))))
      (assert (is_object? fdesc) "remote_function_to_dom requires an object from fn_signature")
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              
                                   (if (== ftype "class")
                                     (+ "class " fdesc.name)                                            
                                     (+ (if (== fdesc.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " fdesc.args)
                                        "))"))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem)
  {
    description: "See value_to_dom for documentation details."
    usage: ["value:*" "options:?object"]
    tags: ["UI" "DOM" "value" "element" "view"]
    })
                   
       
       
       

(defun_sync array_to_dom (arr options _path)
    (let
        ((total_len arr.length)
         (_path (or _path []))
         (lpath (function () (join "~" _path)))
         (options (or options {}))
         (expanded false)
         (expansion_mode false)
         (detail_elem nil)
         (expansion_elem nil)
         (idx -1)
         (segment_size 10)
         (new_row_elem [])
         (render_array (function ()
                           (ol { `lpath: (lpath) `start: 0 `class: "juno-type-array" } 
                             (progn 
                                (for_each (val arr)
                                    (progn
                                        (inc idx)
                                        (li { `class: "juno-array-item" } 
                                            (value_to_dom val options (conj _path [idx])))))))))
         (row_elem []))
      (assert (is_array? arr))
      (when (or (> _path.length 2)
                (> arr.length (or options.expansion_length 30)))
        (= expansion_mode true))
            
      (= detail_elem 
         (details (+ { `class: "juno-type-array" }
                      (if (and (== _path.length 0)
                              (not expansion_mode))
                      { `open: true }
                      {}))
                 (summary { `lpath: (lpath)  `tabindex: 0 }  "Array [" total_len "] ")
                 (if expansion_mode
                     (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                     (render_array))))
     (when expansion_mode
         (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_array))
                                     (= render_array nil)))))
     detail_elem)
    {
      description: "See value_to_dom for documentation details."
      usage: ["value:*" "options:?object"]
      tags: ["UI" "DOM" "value" "element" "view"]
      })
           
(defun_sync obj_to_dom (obj options _path)
  (let
      ((options (or options {}))
       (classes "juno-value juno-type-")
       (detail_elem nil)
       (expanded false)
       (expansion_elem nil)
       (expansion_mode false)
       (get_pairs (if options.include_prototypes
                    pairs*
                    pairs))
       (render_table (function () 
                         (table
                            (tbody
                             (for_each (keyval (get_pairs obj))
                                       (destructuring_bind (key value)
                                                           keyval
                                                           (tr 
                                                            (td {  `class: "juno-obj-to-dom-key" } key)
                                                            (td { `class: "juno-obj-to-dom-value" } 
                                                                (value_to_dom value options (conj _path [ key ] ))))))))))
       (_path (or _path []))
       (lpath (function () (join "~" _path))))
    (declare (function get_pairs))
    (when (or (eq nil options.visited)
              (< _path.length 2))
           (set_prop options
                     `visited (new Set)))
    
    (if (-> options.visited `has obj)
        (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "[CIRCULAR]")
        (cond
          (== (length obj) 0)
          (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "Object {}")
          else
          (progn
           (-> options.visited `add obj)    
           (when (> _path.length 2)
             (= expansion_mode true))
           (= detail_elem 
              (details (+ {  `class: "juno-obj-to-dom" }
                          (if (== _path.length 0)
                            { `open: true }
                            {}))
                       (summary { `lpath: (lpath) `class: "juno-obj-to-dom" } obj.constructor.name)
                       (if expansion_mode
                         (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                         (render_table))))
           (when expansion_mode
             (attach_event_listener detail_elem
                                    `toggle
                                    (fn (e) 
                                      (unless expanded
                                              (= expanded true)
                                              (-> expansion_elem `replaceWith (render_table))
                                              (= render_table nil)))))
           detail_elem))))
  {
    description: "See value_to_dom for documentation details."
    usage: ["value:*" "options:?object"]
    tags: ["UI" "DOM" "value" "element" "view"]
    })




(defun copy_text_to_clipboard (text)
        (if text
           (let ((temp (textarea { `style: "position: absolute; top: -100px; left: -200px;"  } )))
               (-> (get_by_id "body") `append temp)
               (set_prop temp
                         `value
                         text)
               (-> temp `select)
               (-> temp `setSelectionRange 0 999999)
               (-> document `execCommand "copy")
               (-> temp `remove)
               true
            )
            false)
        { `usage: ["text:string"]
          `description:"Copies the provided textual argument to the system clipboard.  It cannot copy more complex types due to security limitations of browser sandboxed code."
          `tags: ["env" "copy" "clipboard" "ui"]
        } )


(defun_sync get_keybinding (category command)
   (aif (resolve_path [category command] *key_bindings*)
        it
        nil)
   {
       description: (+ "Given a category, such as `editor or `global and a command name, "
                        "returns the object with the defined key binding data or nil")
       usage: ["category:string" "command:string"]
       tags: ["key" "binding" "global" "sequence"]
    })

(defun_sync to_ace_keybinding (name keybinding_object fx_to_call)
   { name: name
     bindKey: { win: keybinding_object.win mac: keybinding_object.mac }
     exec: (or fx_to_call keybinding_object.exec) }
   {
       description: (+ "Given a Juno keybinding object with an exec function or an override "
                       "function as the third argument,  returns a keybinding object in a "
                       "format that can be used with the Ace Editor.")
       usage: ["name:string" "keybinding_object:object" "fx_to_call:function"]
       tags: ["key" "binding" "Ace" "editor" "command"]
   })

(defun_sync editor_key_bindings (editor)
   (if editor
      (resolve_path [`commands `commandKeyBinding ] editor)
      nil)
   {
       `description: "Returns current key bindings for the provided ACE editor object."
       `usage: ["editor:object"]
       `tags: ["bindings" "key" "controls"]
   })



(defun edit_mode_for_extension (ext)
   (or (resolve_path [ `editor `extensions_to_mode ext ] *env_config*)
       ext)
   {
       `description: (+ "Maps a file extension (with no period as a prefix) to an editor mode using the " 
                        "*env_config*~editor~extensions_to_mode lookup object. "
                        "If the file extension is found in the lookup, it will return the value, "
                        "otherwise it will return the provided extension back unchanged.")
       `usage: ["ext:string"]
       `tags: ["extension" "files" "type" "mode" "edit" "editor" ]
   })



(defun log (`& args)
   (progn
      (apply console.log args)
      (aif (-> Environment `get_global "*system_repl*" nil)
           (progn
              (-> it `log (apply div { `style: "display: flex;" } 
                           (for_each (val args)
                              (div { `style: "padding-right: 10px" } (value_to_dom val)))))))
      nil)
   {
       `description: "Logs arguments to the console and the current *system_repl* output.  Returns nil."
       `usage: ["arg0:*" "argN:*"]
       `tags: ["log" "console" "values" "display"]
   })

(defun log_error (error_message error_instance)
   (progn
      (console.error error_message error_instance)
      (aif (-> Environment `get_global "*system_repl*" nil)
           (progn
              (-> it `log_error error_message error_instance)))
      nil)
   {
       `description: "Logs an error message and the error instance to the console and the current *system_repl* output.  Returns nil."
       `usage: ["arg0:*" "argN:*"]
       `tags: ["log" "console" "values" "display"]
   })

(defun_sync clear_log ()
   (aif (and *last_focus*
             (prop *last_focus* `clear_output)
             *last_focus*)
        (progn
           (setTimeout (fn ()
                          (-> it `clear_output))
                       5)
           nil))
   {
     `description: "Clears the REPL that is currently focused."
     `usage: []
     `tags: ["log" "console" "clear" "output" "display"]
     })

(defun_sync decorative_usage (symbol_data namespace suppress_type symbol_lookup)
  (let
      ((val (if (is_string? symbol_data)
                (cond
                   (starts_with? "(" symbol_data)
                   (-> symbol_data `substr 1)
                   (starts_with? "[" symbol_data)
                   (-> symbol_data `substr 1)
                   else
                   symbol_data)
                symbol_data.name))
       (show_type (function ()
                     (span { `style: "margin-left: 15px; font-style: italic" 
                             `class: (+ "juno-type-" (lowercase (or description.type "")))
                             }
                         (cond 
                            description.macro
                            "Macro"
                            description.type
                            (if suppress_type [] 
                                description.type)))))
       (metadata (if (and (is_object? symbol_data)
                          namespace
                          (not symbol_data.require_ns))
                     [list symbol_data]
                     (if symbol_lookup
                        [(symbol_lookup (trim val))]
                        (meta_for_symbol (trim val) true))))
       
       (description (if (is_object? symbol_data)
                        symbol_data
                        (if namespace
                           (first (reduce_sync (v metadata)
                                     (when (== v.namespace namespace)
                                        v)))
                           (first (or metadata [])))))
       (view nil)
       (is_symbol_binding (if (and description.require_ns
                                   (is_array? description.initializer)
                                   (== description.initializer.0 (quote pend_load)))
                              true
                              false))
       (rval nil))
      (console.log "decorative_usage: metadadata: " val metadata)
      (when (and is_symbol_binding
                 (is_object? description))
       (set_prop description
          `usage
          (prop (first (reduce_sync (v metadata)
                                    (when (== v.namespace description.require_ns)
                                       v)))
                `usage)))
      (console.log "decorative_usage:  description: " description)
      (= rval
         (cond
            (is_array? description.usage)
            (div { `style: "display: inline-block"} "("
                 (flatten [(span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                           (for_each (arg description.usage)
                              (destructuring_bind (arg_name arg_type arg_needed)
                                 (split_by ":" arg)
                                 (= arg_type (or arg_type ""))
                                 (span { `class: (+ "juno-type-" (if (starts_with? "?" arg_type)
                                                                     (lowercase (or (chop_front arg_type) ""))
                                                                     (lowercase arg_type))
                                                    " juno-arg-name") `title: arg_type
                                                `style: (if (== arg_needed "required") "text-decoration: underline" "") } arg_name ":" arg_type)
                                 ))])
                 ")" (show_type))
            (is_string? description.fn_args)
            (div { `style: "display: inline-block"} "("
                 (span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                 (for_each (arg_name (split_by " " (chop (rest description.fn_args))))
                    (span { `class: "juno-arg-name" } arg_name))
                 ")" (show_type))
            
            else
            nil))
      rval)
  {
    `usage: ["symbol:string|object" "namespace:?string" "suppress_type:?boolean"]
    `description: (+ "Given a symbol name as a string or an object metadata value (as from describe), returns a DOM element of the usage information.  "
                     "If the usage metadata is defined for the symbol it will use that, otherwise "
                     "if the symbol is a function and has fn_args defined, that content will be returned "
                     "in a DOM element.  Used by the editor to display usage information. ")
    `tags: [ `usage `editor `formatting `help `assist ]
    })

(defun unpack_description (description options)
   (let
      ((header_size_lookup [nil h1 h2 h3 h4 h5 h6])
       (regex_list [{ name: "code"
                       regex: (new RegExp "(`[a-zA-z0-9*?_%!\\-@\\$\\(\\)]+`)" `g)
                       exec: (fn (value full_regex_result)
                                (progc
                                   (defvar rval (code {} (-> value `substr 1 (- (length value) 2))))
                                   ;(log "code: value: " (-> value `substr 1 (- (length value) 2)) "rval: "  (as_lisp (element_to_lisp rval)))
                                   rval))}
                    { name: "table" 
                      regex: (new RegExp "(^[`a-zA-Z\\(\\)0-9?_*\\-]+):([`*a-z\\(\\) A-Z0-9]+)[ ]*-[ ]*(.+)")
                      exec: (fn (match_text tbl_row)
                               (progn
                                  ;(log "table: " match_text)
                                  (if options.edit_mode
                                     [(+ tbl_row.1 ":" tbl_row.2 "-") (process_regex tbl_row.3)]
                                     (when (not (blank? match_text))
                                        (div { `style: "display: flex; align-items: flex-end; flex-wrap: wrap; gap: 16px; border-bottom: 1px solid var(--main-accent-line);" }
                                             (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.1)
                                             (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.2)
                                             (div { `style: "align-self: flex-start; padding: 5px; flex-grow: 1; flex-basis: 400px;"} (process_regex tbl_row.3))))))) }
                     { name: "header" 
                       regex: (new RegExp "^([#]{1,6})[ ]+(.+)")
                       exec: (fn (value full_regex_result)
                                (progn
                                   (defvar header_section (first full_regex_result)) ;; pull it out of the array to make it easier to work with
                                   (defvar header_tag (or (prop header_size_lookup (length (prop full_regex_result 1)))
                                                     h5))
                                   (header_tag
                                      (prop full_regex_result `2)))) }
                     { name: "link"
                       regex: (new RegExp "(\\\\b(https?|ftp|file):\\\\/\\\\/[-A-Z0-9+&@#\\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\\\/%=~_|])" `ig)
                       exec: (fn (value full_regex_match)
                                (progn
                                   ;(log "link match: " value full_regex_match)
                                   (if value
                                      (a { `_target: "_blank" `href: value }
                                         value)
                                      "BAD LINK"))) }
                     { name: "horizontal_line" 
                       regex: (new RegExp "^(---[ ]*)$" `g)
                       exec: (fn (value)
                                (progn
                                   (hr))) }
                      ])
       (pre_section nil)
       (process_regex (fn (text_section)
                         (let
                            ((results [])
                             (replacement nil)
                             (ctext text_section)
                             (idx ctext.length)
                             (overlap_key nil)
                             (overlap_struct nil)
                             (split_list [])
                             (action_list [])
                             (overlaps {})
                             (acc [])
                             (comps nil))
                            ;(log "process_regex: -> " text_section)
                            (for_each (cmd regex_list)
                               (progn
                                  (= comps (scan_str cmd.regex ctext))
                                  (for_each (comp comps)
                                     (push split_list 
                                        { comp: comp
                                          pos: comp.index
                                          length: comp.0.length
                                          cmd: cmd
                                           }))))
                            ;; now we have a list of the changes to be made to the text chunk 
                            ;(log "split_list: " split_list)
                            (for_each (r1 split_list)
                               (for_each (r2 split_list)
                                  (unless (== r1 r2)
                                      (if (> r1.length r2.length)
                                          (= overlap_struct [[r1.pos (+ r1.pos r1.length)] [r2.pos (+ r2.pos r2.length)]])
                                          (= overlap_struct [[r2.pos (+ r2.pos r2.length)] [r1.pos (+ r1.pos r1.length)]]))
                                      (unless (prop overlaps (as_lisp overlap_struct))
                                         (when (apply range_overlap? overlap_struct)
                                            (set_prop overlaps
                                               (as_lisp overlap_struct)
                                               { 
                                                 parent: (if (> r1.length r2.length)
                                                             r1
                                                             r2)
                                                 child: (if (> r1.length r2.length)
                                                             r2
                                                             r1)
                                                 }))))))
                            (= action_list (reduce (action split_list)
                                              (progn
                                                 (defvar remove false)
                                                 (for_each (v (values overlaps))
                                                    (if (and (== action.pos v.child.pos)
                                                             (== action.length v.child.length))
                                                       (= remove true)))
                                                 (unless remove
                                                    action))))
                                              
                            (= split_list (reverse (sort action_list { `key: [`pos] })))
                            (if (> split_list.length 0)
                                (progn
                                   (for_each (action split_list)
                                      (progn
                                         (defvar end_of_insert (+ action.pos action.comp.0.length)) ;; point of the ctext buffer *after* the splice
                                         (defvar diff (- idx end_of_insert))   ;; text remaining from the end of the match to the idx point(which starts at the end of the ctext segment)
                                         ;(log "*" action.pos end_of_insert idx)
                                         (push acc (-> ctext `substr  end_of_insert diff)) ;; push that into our accumulator (it will be in reverse order)
                                         (push acc (-> action.cmd `exec action.comp.0 action.comp))
                                         (= idx action.pos)))  ;; update our tail end
                                   ;; if we have any remaining text, push it in to the accumulator as it will have no edits
                                   (when (> idx 0)
                                      ;(log "idx is greater than 0: " idx (-> ctext `substr 0 idx))
                                      (push acc (-> ctext `substr 0 idx))))
                                   (push acc text_section)) ;; nothing to update
                            (reverse acc))))
       (desc (progn
                (defvar tmp (eval (or description "")))
                (cond 
                   (is_element? tmp)
                   tmp
                   (and (is_object? tmp)
                        (not (is_array? tmp))
                        (is_string? tmp.description))
                   tmp.description
                   (is_string? tmp)
                   tmp
                   else  ;; not for us
                   tmp)))
       (rr (new RegExp "<-" `g))
       (subsections [])
       (segments (if (is_string? desc)
                     (split_by "```" desc)
                     []))
       (table_section nil)
       (idx -1)
       (header_section nil)
       (header_tag nil)
       (header_size_lookup [nil h1 h2 h3 h4 h5 h6]) ;; pos 0 will never be found, hence nil
       (current_seg 0)
       (total_segs (length segments)))
      (if (is_string? desc)
         (div (+ { `class: "juno-editable" }
                 (if options.edit_mode
                    { `contenteditable: true }
                    {}))
              (for_each (segment segments)
                 (progn
                    (inc idx)
                    (if (== 1 (% idx 2))
                        (pre segment)
                        (for_each (section (split_by "<br>" segment))
                           (progn
                              ;(log (hr))
                              ;(log "unpack_description: section: " section)
                              (div (process_regex section))))))))
         desc))
   {
     ;usage: ["text:string" "options:object"]
     description: (+ "<br><br>Provided a text string as a primary argument, the function will convert "
                     "the text content to a DOM element structure based on a set of default rules, or "
                     "user provided rules.  A DOM element will be returned which can be placed in the "
                     "DOM.<br><br>#### Options   <br><br>This function takes the following "
                     "options:<br>edit_mode:boolean -If true, the returned DOM element will be "
                     "editable; a `contenteditable` attribute will be placed in element "
                     "returned.<br>regex_list:array -If provided, each segment of text that is not "
                     "allocated to a `PRE` element will be evaluated by the regex rules.  When a "
                     "match is found, the associated exec function of the rule will be called with "
                     "the form `(fn (value full_regex_result))` where the `value` is the matched text "
                     "value, and the `full_regex_result` is the full returned regex structure from "
                     "the `scan_str` function.  The return value of the function, typically an "
                     "Element type will replace the matched text.    ")
     })

(defun format_help (meta_obj options)
   (let
      ((is_symbol_binding (if (and meta_obj.require_ns
                                   (is_array? meta_obj.initializer)
                                   (== meta_obj.initializer.0 (quote pend_load)))
                              true
                              false))
       (imported_usage (first (if is_symbol_binding
                                  (reduce  (v (meta_for_symbol meta_obj.name true))
                                     (when (== v.namespace meta_obj.require_ns)
                                        v))
                                  [])))
       (elem nil))
      
     
      (when imported_usage
         (set_prop meta_obj
            `usage
            (prop imported_usage `usage))
         (set_prop meta_obj
            `tags
            (prop imported_usage `tags)))
            
            
      (= elem
         (div { `command: (+ "" meta_obj.name)  `style: "width: calc(100% - 20px); padding-bottom: 5px;" }
              (h3 (span { `style: "color: var(--namespace-color); " } meta_obj.namespace ) "/" meta_obj.name
                  (if meta_obj.macro
                     (span { `style: "float: right; margin-right: 20px; " } "Macro")
                     (span { `title: "Type" `style: "float: right" `class: (+ "juno-type-" (lowercase meta_obj.type)) } meta_obj.type)))
              (hr { `class: "LightHR" })
              (cond
                 (and (contains? `unction meta_obj.type)
                      meta_obj.usage)
                 [(h4 "Usage")
                  (decorative_usage meta_obj meta_obj.namespace true)]
                 (contains? `unction meta_obj.type)
                 [(h4 "Arguments")
                  meta_obj.fn_args]
                 else
                 [])
              (if (or meta_obj.description
                      is_symbol_binding)
                  [(h4 "Description")
                   (if is_symbol_binding
                      (p
                         (div { } "This is a bound symbol into " (span { `style: "color: var(--namespace-color); " }  meta_obj.require_ns)
                              " to " (join " " meta_obj.requires) ".  For more information refer to the core/use_symbols macro and to " (join " " meta_obj.requires) ".")
                         (br))
                      (unpack_description meta_obj.description))]
                  [])
              
              (if meta_obj.tags
                 [(h4 "Tags")
                  (for_each (`sym meta_obj.tags)
                     (span { `tabindex: 0 `class: "juno-tag" `style: "" } sym ))]
                 [])
              (if meta_obj.requires
                 [(h3 "Requires")
                  (div {  } 
                       (for_each (`sym (sort meta_obj.requires))
                          (span { `tabindex: 0 `class: (+ "juno-type-" (lowercase (or (prop (describe sym) `type) "")) " juno-requires") `style: "display: inline-block;" } sym )))]
                 [])
              ))
      (cond
         (is_function? options.on_click)
         (attach_event_listener elem
            `click
            (fn (e)
               (-> options `on_click e))))
      elem)
   {
     `description: (+ "Render object definitions to html.  Given a path "
                      "to Environment.definitions, or the output of the "
                      "describe function, returns a DOM element.  If options "
                      "is provided, the if the value for the key 'on_click' "
                      "is a function, when the produced element is clicked "
                      "the click event will be passed to the on_click function "
                      "provided.")
     `usage: ["meta_obj:object" "options:?object"]
     `tags: [`help `? `usage `info `man `manual ]
     })


(defmacro ? (symname)
   `(let
       ((results (describe ,#(if (starts_with? "=:" symname)
                                 (-> symname `substr 2)
                                 symname) true)))
       (for_each (`meta_obj (or results []))
          (format_help meta_obj)
          ))
   {
       `description: "Given a quoted symbol as an argument, the function returns a formatted manual page for the provided symbol."
       `usage: ["name:quoted_symbol"]
       `tags:["help" "assistance" "man" "usage" "info"]
   })

(defun_sync find_last_paren (editor pos)
   (try
      (let
         ((pos (or pos (-> editor `getCursorPosition)))
          (stream (indirect_new TokenIterator editor.session pos.row pos.column))
          (done false)
          (depth 0)
          (t nil)
          (comps nil)
          (calc_depth (function (val)
                          (progn
                            (= comps (split_by "" val))
                            (while (> comps.length 0)
                              (progn
                                 (= t (pop comps))          
                               (cond 
                                  (or (== t ")")
                                      (== t "]")
                                      (== t "}"))
                                  (inc depth)
                                  (or (== t "(")
                                      (== t "[")
                                      (== t "{"))
                                  (dec depth)))))))
          (start nil)
          (token nil))
         (while (and (not done)
                     (not start))
            (progn
               (= token (-> stream `getCurrentToken))
               (when (== token.type "keyword")
                  (calc_depth token.value))
               (if (eq token nil)
                   (progn
                      (= done true)
                      (break))
                   (if (and (== token.type "keyword")
                            (or (== token.value.0 "(")
                                (== token.value.0 "[")
                                (== token.value.0 "{")))
                      (progn
                         (if (<= depth 0)
                             (progn
                                (= start { row: (-> stream `getCurrentTokenRow)
                                               column: (-> stream `getCurrentTokenColumn) })
                                (= done true)
                                (break))))))
                       
               (= token (-> stream `stepBackward))))
         (when start
            (-> editor.session `getBracketRange start)))
      (catch Error (e)
         (progn
            (console.error e)
            nil))))



(defun current_controls (no_subcontrols from_control)
   (let
      ((ctls (uniq (flatten (control_tree (if from_control
                                              [ from_control ]
                                              $root_controls)))))
       (ids nil))
      (if no_subcontrols
         (progn
            (= ids (new Set))
            (reduce (ctl ctls)
               (progn
                  (unless (-> ids `has ctl.options.id)
                     (-> ids `add ctl.options.id)
                     ctl))))
         ctls))
   {
     `usage: ["no_subcontrols:?boolean" "from_control:?control"]
     `description: (+ "Returns an array of all controls in the control tree.  "
                      "If no_subcontrols is true, then composite type contols "
                      "made up of multiple controls will be included in the "
                      "results only as the main control.  Otherwise, the "
                      "subcontrols will also be returned. If from_control "
                      "is a provided control, only controls that are "
                      "contained by that root control will be returned.")
     `tags: ["controls" "active" "tree" "ui"]
     })



(defun all_editor_controls ()
   (reduce (ctl (current_controls))
      (when ctl.editor
         ctl))
   {
       `description: "Returns an array all editor controls in the control_tree."
       `usage: []
       `tags: ["controls" "editors" "active" "ui"]
   })

(defun cascade_resize (top_control)
  (control_tree (or top_control $root_controls)
                (fn (control)
                  (if control.resize
                    (-> control `resize))))
  {
      `usage: ["top_control:?object"]
      `description: (+ "This function invokes the resize methodFor every control " 
                       "in the control tree or from the provided starting control "
                       "and it's child controls.")
      `tags: ["controls" "active" "resize" "ui"]
  })
    

(defun set_global_theme (theme_name options)
   (if (prop *global_themes* theme_name)
       (let
          ((head_elem (-> document `querySelector "head"))
           (existing (get_by_id "juno-css-theme")))
          (if existing
               (-> existing `remove))
          (-> head_elem `append
              (style { `id: "juno-css-theme" `type: "text/css" }
               (prop *global_themes* theme_name)) )
          (set_path [ `application `global_theme ] *env_config* theme_name)
          (when (and (not options.suppress_set_sub_theme)
                     (contains? theme_name *editor_themes*))
             (set_path [ `editor `default_theme ] *env_config* theme_name))
          ;; unless we are told not to, set any controls to the theme
          (unless options.suppress_cascade
              (for_each (control (current_controls))
                        (when (is_function? control.set_theme)
                          (-> control `set_theme theme_name))))
          true)
       (throw ReferenceError "Invalid theme name provided"))
   { `description: (+ "Sets the global theme to the named theme.  Global themes "
                      "values are looked for in *global_themes*.  If a key is found "
                      "in that object, the theme is installed, and the *env_config* "
                      "value is updated to reflect this choice.  Additionally, if an "
                      "editor theme is found with the same name, the default editor "
                      "theme is set as well.  Editor themes are found in the global "
                      "*editor_themes*. <br><br>"
                      "Options are as follows:<br>"
                      "suppress_set_sub_theme:boolean:false:If true, individual control "
                      "themes such as the editor theme setting will not be set as part "
                      "the global theme and will retain their existing settings and "
                      "defaults.<br>"
                      "suppress_cascade:boolean:false:If this value is true, the application "
                      "theme will change, but controls will not be told about it and will "
                      "retain their current settings as they are instantiated with.")
     `tags: ["themes" "environment" "color" "settings"]
     `usage: ["theme_name:string" "options:object"] })

(defun_sync control_name (control)
   (when control
      (prop control.options `name))
   { 
     `usage: ["control:object"]
     `description: (+ "Returns the name of the given control, or nil " 
                      "if the control or the control's name is nil")
     `tags: ["control" "name"]    `
   })

(defun_sync control_id (control)
   (when control
      (prop control.options `id))
   { 
     `usage: ["control:object"]
     `description: (+ "Returns the id of the given control, or nil " 
                      "if the control or the control's name is nil")
     `tags: ["control" "name"]    `
   })

(defun get_control_by_id (id)
  (let
      ((controls (current_controls))
       (ctrl nil))
    (for_each (`control controls)
              (when (== id (and control.options control.options.id))
                (= ctrl control)
                (break)))
    ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the control with the given identifier, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "id" "find" ]
  })

(defun get_control_by_name (name)
  (let
      ((controls (current_controls))
       (ctrl nil))
      (when (is_string? name)
         (for_each (`control controls)
            (progn
               (when (== name control.name)
                  (= ctrl control)
                  (break)))))
      ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the first control with the given name, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "name" "find" ]
  })



(defun select_controls (predicate_func)
  (let
      ((controls (current_controls))
       (acc [])
       (ctrl nil))
    (for_each (`control controls)
        (progn
         (when (predicate_func control)
           (push acc control))))
    acc)
  {
   `description: (+ "Given a predicate function (a function that takes a "
                    "single value and returns a true or false value), tests "
                    "control by passing the control to the predicate and if "
                    "the function returns true, the control will be "
                    "returned in the array.  The function will return all "
                    "controls which tested true.")
   `usage: ["predicate_function:function"]
   `tags: ["selection" "filter" "controls"]
   })



(defun render_control_tree (controls)
   (let
      ((cell_style "border: 1px dashed var(--main-accent-line-hover);")
       (sub_style "border-right: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);")
       (parent_style "border-left: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);"))
      (table { `style: "vertical-align: top; margin: 5px; box-shadow: 1px 1px 4px 1px #00000060; width: calc(100% - 20px);" }
        (cond
           (is_array? controls)
           (for_each (ctl controls)
              (tr { `style: (+ "vertical-align: top;" cell_style) }
               (if (is_function? ctl.controls)
                   [ (td { `control_id: ctl.options.id 
                            style: (+ ""
                                      parent_style
                                      (if (== ctl *last_focus*)
                                          "font-weight: bold; background: var(--control-focused);"
                                          ""))
                            } (or ctl.name (+ "/" ctl.type)))
                    (td { `style: sub_style } (render_control_tree (-> ctl `controls)))]
                   (td { `control_id: ctl.options.id `colspan: 2 
                         `style: (+ "" cell_style (if (== ctl *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) } 
                         (or ctl.name (+ "/" ctl.type))))))
           (is_object? controls)
           (tr { `style: "" }
            (if (is_function? controls.controls)
                [(td { `style: (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "") } controls.name)
                 (td { `control_id: controls.options.id `style: cell_style } (render_control_tree (-> controls `controls)))]
                (td { `control_id: controls.options.id `colspan: 2 
                      `style: (+ "" cell_style (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) }  
                      (or controls.name (+ "/" controls.type))))))))
   {
     usage: ["controls:array"]
     description: (+ "Renders the given controls and their children as a HTML/table " 
                     "representing the hierarchy and the control positions in the tree.")
     tags: [ "ui" "controls" "DOM" "structure" "tree" ]
     })

(defun holding_tank_controls ()
  (aif (get_control_by_name "Holding Tank")
       (-> it `controls)
       [])
  {
      usage: []
      description: "Returns an array of all controls currently stored in the control holding tank."
      tags: ["ui" "controls" "holding" "tank"]
  })

(defun replace_control (target_control new_control)
  (let
      ((tmp (new Object))
       (replaced_keys (new Set)))
    (assert (is_object? target_control) "Invalid object provided for old_control")
    (assert (is_object? new_control) "Invalid object provided for new_control")
    ;; first transfer the old object contents to the new location
    (for_each (k (keys target_control))
              (set_prop tmp
                        k
                        (prop target_control k)))
    
    ;; now tmp has the target_control scope references
    ;; replace the target_control with new values
    (for_each (k (keys new_control))
              (progn
               (-> replaced_keys `add k)
               (set_prop target_control
                         k
                         (prop new_control k))))
    
    ;; now remove any keys that are not in the set from the target_control
    (for_each (k (keys target_control))
              (if (not (-> replaced_keys `has k))
                (remove_prop target_control k)))
    
    ;; the objects should be swapped at this point
    ;; return tmp as the old control
    tmp))



(defun control_for_dom_element (elem)
    (let
        ((control_id nil))
       (assert (is_element? elem) "Invalid element provided")
       (= control_id (-> elem `getAttribute "control_id"))
       (aif (and control_id ;; we have a control_id, so get the control
                 (get_control_by_id control_id))
            it ;; and return it
           (cond
             (eq nil elem.parentElement)
             nil ;; at top (or cannot go up further) so return nil
              
              ;; no control found and we have a parent_element
             else
             (control_for_dom_element elem.parentElement)))))



(defun control_position (control)
    (let
       ((parent_view nil)
        (parent_control_position 0)
        (parent_control nil))
    (assert control.view "target_container isn't a control container")
    (= parent_view control.view.parentElement)
    (when parent_view
        (= parent_control (control_for_dom_element parent_view))
        (when (and parent_control
                   parent_control.controls)
           (map (fn (parental_sub_control idx)
                    (when (== parental_sub_control control)
                        (= parent_control_position idx)))
                (-> parent_control `controls))))
    (aif (and (eq parent_control nil)
              (get_control_by_name "Holding Tank"))
         (if (-> it `has_control? control)
           (= parent_control it)))
      
    {
        `child: control
        `parent: parent_control
        `child_position: parent_control_position
    })
    {
      description: (+ "<br><br>The `control_position` function returns a description object containing "
                      "the provided control (child), the control\'s parent, and the child\'s position in "
                      "the parent control. ")
      usage: ["control:object"]
      tags: ["control" "position" "placement" "controls" "UI" "DOM"]
      })

(defun get_container_for_control (control)
    (let
        ((existing_container nil)
         (pos nil)
         (next_parent nil)
         ;; controls should be in one of these container types
         (valid_containers ["split_view_horizontal" "split_view_vertical" "control_container" ]))
      (assert (and (is_object? control)
                   control.view)
              "Invalid control received")
      (= pos (control_position control))
      
    ;; is the child control (the control passed) a container?
      (cond 
        (and pos.child
           (contains? pos.child.type valid_containers))
        (= existing_container control)
        (and pos.parent
            (contains? pos.parent.type valid_containers))
        (= existing_container pos.parent)
        pos.parent
        (progn
          (while (and pos.parent
                      (not existing_container))
             (progn
                 (= pos (control_position pos.parent))
                 (console.log "pos is now: " pos)
                 (if (and pos.parent
                          (contains? pos.parent.type valid_containers))
                     (= existing_container pos.parent))))))
       
      existing_container))

(defun_sync is_control? (val)
  (and (is_object? val) val.type val.view val.toJSON true)
  {
    usage: "val:object"
    description: "Predicate function which returns true if the provided object tests to be a control."
    tags: ["controls" "ui" "control"]
  })

(defun_sync is_top_control? (control)
  (if (is_control? control)
    (contains? control $root_controls)
    false))

(defun top_frame (control)
  (let
      ((parent nil))
    (declare (local parent))    ;; parent is a global object - shouldn't need to declare this since it has technically already been shadowed
   (assert (is_control? control) "Invalid control provided")
   (= parent (control_position control))
   (while parent.parent
       (= parent (control_position parent.parent)))
   parent.child))

(defun parents_for_control (control)
  (if (and (is_control? control)
           control.view.parentElement)
       (progn
          (defvar parent (control_for_dom_element control.view.parentElement))
          (if (is_top_control? parent)
              [parent]
              (reduce (ctl (flatten [parent (parents_for_control parent)]))
                 ctl)))
       [nil])
  {
   `description: "Given a control, returns an array containing the parent chain, with the last being the top control."
   `usage: ["control:object"]
   `tags: [ `control `controls `position `heirarchy `path]
   })

(defparameter *focus_suppress_timer* nil)

(defun set_focus_to (target_control _controls)
   (unless *focus_suppress_timer*
      (= *focus_suppress_timer* (setTimeout (fn ()
                                               (= *focus_suppress_timer* nil))
                                            50))
      (let
         ((focused_list (query_all ".juno-focused"))
          (controls (or _controls
                        (reduce (c (current_controls))
                           (when c.on_focus
                              c)))))
         ;(debug)
         (for_each (control controls)
            (when (and (or (eq nil target_control)
                           (not (== target_control control)))
                       (is_function? control.on_blur))
               (-> control `on_blur)))
         
         (console.log "set_focus_to: called with: " target_control.options.name)
         ;; remove any focus class markers
         (when (> focused_list.length 0)
            (= focused_list (map (fn (v) v) focused_list))
            (apply remove_class "juno-focused" focused_list))
         (for_each (control controls)
            (when (and (or (eq nil target_control)
                           (not (== target_control control)))
                       (is_function? control.on_blur))
               (-> control `on_blur)))
         (when (not (== *last_focus* target_control))
            (when (and *last_focus*
                       (prop *last_focus* `menu_items))
               (-> *app_menu_control* `remove_menu (or (prop *last_focus* `name)
                                                       "Control"))))
         
         (if target_control
            (progn
               (if target_control.on_focus
                  (-> target_control `on_focus)
                  (focus_to target_control.view))
               (setq *last_focus* target_control)
               (setq core/$current_control *last_focus*)
               (setq *last_top_frame* (top_frame target_control))
               (when target_control.menu_items
                  (-> *app_menu_control* `add_menu [ (or target_control.name
                                                         "Control")
                                                    target_control.menu_items
                                                    "control_menu"])))
            (progn
               true)))))

(defun controls_needing_save ()
   (reduce (c (current_controls))
      (when (and c.needs_save?
                 (-> c `needs_save?))
         c))
  { description: (+ "Examines all current controls and returns any controls who have a needs_save? "
                    "method that returns true.<br> ")
    usage: []
    tags: ["controls"
           "control"
           "save"
           "dirty"
           "editor"
           "buffer"
           "modified"]})

(defun default_focus ()
  (let
      ((found_control nil))
    (control_tree $root_controls
                  (fn (control)
                      (when (and (not found_control)
                                 (is_function? control.on_focus))
                        (= found_control control))))
    (if found_control
      (progn
        (set_focus_to found_control)
        found_control)
      nil)))

(defun commands_button (id)
  (button { `control_id: id
            `class: "juno-command-button"
            `title: (dtext "Commands") } "⋯"))

(defun focus_to_editor (ctl)
   (progn
      (cond
          (and ctl 
             (prop ctl `editor)
             ctl.editor.focus)  
          (progn
             (focus_to (prop ctl `editor))
             (= *last_focus* ctl))
          (and (prop *last_focus* `editor)
               (resolve_path [`editor `focus ] *last_focus*))
          (focus_to (prop *last_focus* `editor)))
      *last_focus*))



(defun swap_control (target_control new_control)
  (let
      ((tmp (new Object))
       (position_details_target nil)
       (position_details_new nil)
       (holding_tank (get_control_by_name "Holding Tank"))
       (replaced_keys (new Set)))
    (assert (is_control? target_control) "Invalid control provided for old_control")
    (assert (is_control? new_control) "Invalid control provided for new_control")
    
    (if (== target_control new_control)
        (progn
           (set_focus_to target_control)
           (if target_control.editor
              (focus_to target_control.editor)))
        (progn
           ;; get their position in the tree
           (= position_details_target (control_position target_control))
           (= position_details_new (control_position new_control))
           (console.log "swap_control: target: " target_control "new: " new_control)))
    
    (cond
        (== target_control new_control)
        nil ;; do nothing 
        
        (== position_details_target.parent holding_tank)   ;; target is in the holding tank so take the old control out and replace with new
        (progn
            (-> holding_tank `remove_control position_details_target.child)
            (-> holding_tank `add_control position_details_new.child)
            (if position_details_new.parent.set_content ;; add the targeted control to the new_controls old location (if not in holding_tank)
              (progn
               (-> position_details_new.parent `set_content position_details_new.child_position position_details_target.child)
               (cascade_resize)
               (set_focus_to position_details_target.child)
               (focus_to_editor))
                position_details_target.child))

        (and (== position_details_target.child holding_tank)   ;; target IS the holding tank so replace the holding tank with the new value and hide the holding tank
             position_details_target.parent.set_content)
        (progn
         (-> holding_tank `remove_control position_details_new.child) ;; ensure the child is removed from the holding tank (if in it)
         (-> position_details_target.parent `set_content position_details_target.child_position position_details_new.child)         
         (-> holding_tank `hide)
         (cascade_resize)
         (set_focus_to position_details_new.child))
        
        (and position_details_target.parent.set_content
             position_details_new.parent.set_content)  ;; controls are both in the tree somewhere so swap their positions
        (progn
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> position_details_new.parent `set_content 
                                             position_details_new.child_position 
                                             position_details_target.child)
            (set_focus_to position_details_new.child)
            (cascade_resize)
            (focus_to_editor)
            target_control)
        
        (and (== position_details_new.child holding_tank)
             (is_function? position_details_target.parent.set_content))
        (progn
         (-> holding_tank `add_control position_details_target.child)
         (set_prop holding_tank.options
                   `in_tree
                   true) ;; otherwise the holding tank, if not initialized, will not mount correctly and place itself somewhere in the dom after initialization
         (-> position_details_target.parent `set_content position_details_target.child_position
             position_details_new.child)
         (-> holding_tank `show)
         (cascade_resize)
         (set_focus_to position_details_new.child)
         (focus_to_editor)
         target_control)
         
        (and (== position_details_new.parent holding_tank)   ;; new control is in the holding tank 
             (is_function? position_details_target.parent.set_content))
        (progn
            (-> holding_tank `remove_control position_details_new.child.options.id)
            (-> holding_tank `add_control position_details_target.child)
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (set_focus_to position_details_new.child)
            (cascade_resize)
            (focus_to_editor)
            position_details_new.child)
        
        (and (eq nil position_details_new.parent)  ;; this is a new control without a parent
             position_details_target.parent.set_content)
        (progn  ;; add to the holding tank the target and put the new in the targets old place..
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> holding_tank `add_control position_details_target.child)
            (cascade_resize)
            (set_focus_to position_details_new.child)
            (focus_to_editor))
        (and (-> holding_tank `has_control? position_details_new.child)
             position_details_target.parent.set_content)
        (progn
           (-> position_details_target.parent `set_content
              position_details_target.child_position
              position_details_new.child)
           ;; remove from the holding tank
           (-> holding_tank `remove_control position_details_new.child)
           (-> holding_tank `add_control position_details_target.child)
           (cascade_resize)
           (set_focus_to position_details_new.child)
           (focus_to_editor))
        
        else
        (progn
            (notify "Unhandled swap condition - see console")
            (log "unhandled swap position: target: " position_details_target "new: " position_details_new)
            nil))))                               




;; container view operation
;; given a command performs an operation on the control structure

;; definitions
;; target_control - the control that is to be impacted with a change 
;; target_control_container - the container of the target_control
;; new_control - an optional new control to be inserted into the control tree
;; options - options for the given command

(defun container_view_operation (command target_control new_control options)
   (let
      ((orig_target target_control)
       (target_control (control_for_dom_element target_control.view)) ;; ensure we have the correct handle to the impaced control since this could be a sub_control given to us
       (position_details nil) ;; the structure that holds the position details of the operation
       (holding_tank (get_control_by_name "Holding Tank"))
       (tmpview nil)
       (confirmed true)
       (new_container nil)
       (split_view_parent nil))
      
      (assert target_control "Unable to find the target control")
      (assert holding_tank "Unable to find the holding tank")
      (= position_details (control_position target_control))
      (console.log "container_view_operation: original_target: " orig_target)
      (console.log "container_view_operation: computed_target: " target_control)
      (console.log "container_view_operation: command: " command "position_details: " position_details "new_control: " new_control)
      (when (and (== position_details.parent nil) ;; top level control
                 (not (== position_details.child holding_tank))
                 (is_top_control? position_details.child))
         (= target_control (first (-> position_details.child `controls)))
         (= position_details (control_position target_control))
         (console.log "container_view_operation: shifted down: target_control was a top control: " position_details))
      ;(log "container_view_operation: options.suppress_destroy_confirm: " options.suppress_destroy_confirm  (and *last_focus* (prop *last_focus* `options)))
      (unless options.suppress_destroy_confirm
         (if (and (== command "destroy")
                  (is_function? target_control.on_destroy))
             (= confirmed (-> target_control `on_destroy))))
      (console.log "container_view_operation: confirmed: " confirmed)
      (if confirmed
          ;; if the parent structure is nil in position_details, then we are at the root
          (cond
             (or (== command "hide")
                 (and (not (resolve_path [ `options `locked ] target_control))
                      (== command "destroy")))
             (progn
                (cond
                   ;; the control is not a root control if it has a parent
                   (or (== position_details.parent.type "split_view_vertical")
                       (== position_details.parent.type "split_view_horizontal"))
                   (progn
                      ;; grab the child control to keep displaying, ie. not the one in the child_position
                      (set_prop position_details
                         `child_to_display
                         (if (== position_details.child_position 0)
                             (second (-> position_details.parent `controls))
                             (first (-> position_details.parent `controls))))
                      
                      ;; we need to know the split views parent since we are going to remove the split view
                      ;; and hoist the remaining child to display into the parent structure in place of the
                      ;; split_view - not an even swap because the existing split_view is retired
                      
                      (= split_view_parent (control_position position_details.parent))
                      (assert split_view_parent.parent.set_content "Unable to set the content of the split view parent")
                      (console.log "container_view_operation: split_view_parent: " split_view_parent)
                      (console.log "container_view_operation: position_details: " position_details)
                      (when (not options.dry_run)
                         ;; elevate the child to keep to the targeted_control container's position in it's parent
                         (-> split_view_parent.parent `set_content split_view_parent.child_position position_details.child_to_display)
                         
                         ;; set the child to hide in non displayed controls
                         (cond
                            (and (== command "hide")
                                 (not (== target_control holding_tank)))
                            (-> holding_tank
                                `add_control
                                target_control)
                            (and (not (resolve_path [ `options `locked ] target_control))
                                 (== command "destroy")
                                 (is_function? target_control.destroy))
                            (progn
                               (when *app_menu_control*
                                  (-> *app_menu_control* `remove_menu target_control.options.name))
                               (-> target_control `destroy)
                               (when (== *last_focus* target_control)
                                  (== *last_focus* nil)))))
                      (cascade_resize)
                      (default_focus)
                      true)
                   (and (not (resolve_path [ `options `locked ] target_control))
                        (== position_details.parent holding_tank)
                        (== command "destroy"))
                   (progn
                      (-> holding_tank `remove_control position_details.child.options.id)
                      (when *app_menu_control*
                         (-> *app_menu_control* `remove_menu position_details.child.options.name))
                      (if (is_function? position_details.child.destroy)
                        (-> position_details.child `destroy))
                      (when (== *last_focus* target_control)
                         (== *last_focus* nil))
                      (default_focus))
                   (and (== command "destroy")
                        (resolve_path [ `options `locked ] target_control))
                   (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                   (== command "destroy")   ;; single control under the root frame so swap if possible with the holding tank
                   (progn
                       (if (> (length (holding_tank_controls)) 0)
                           (progn
                              (set_path_value target_control [`options `temporary ] target_control) ;; mark as temporary
                              (swap_control target_control (last (holding_tank_controls))))
                           (progn
                              (notify "Cannot hide a single control - try replacing."))))
                   else
                   (progn
                      (if (> (length (holding_tank_controls)) 0)
                          (swap_control target_control (last (holding_tank_controls)))
                          (notify "Cannot hide a single control - try replacing"))
                      position_details)))
             
             (== command "replace")
             (progn
                (log "container_view_operation: command is replace: swap: " target_control new_control)
                (swap_control target_control new_control)
                true)
             
             (== command "split_left")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (== command "split_right")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical position_details.child new_control  (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                
                (cascade_resize)
                true)
             (== command "split_above")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (== command "split_below")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal  position_details.child new_control (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (resolve_path [ `options `locked ] target_control)
             (progn
                (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                false)
             ;; otherwise we don't know how to process the command 
             else
             (progn
                (notify (+ "container_view_operation: unknown command: " command))
                position_details))
          (progn
             false))))
  
 
(defmacro place_control(placement `& control_def)
   (let
      ((where_map {
                   `top: "split_above"
                   `below: "split_below"
                   `left: "split_left"
                   `right: "split_right"
                   `replace: "replace"  })
       (where (aif (prop where_map placement)
                   it
                   "split_right")))
       
  `(let
      ((target_container  (control_position (top_frame (default_focus)))))
     (when target_container.child 
       (= target_container (first (-> target_container.child `controls)))
       (container_view_operation ,#where target_container
                                   ,@control_def)))))
              
(defun show_control (control_to_show)
  (let
      ((control_to_show (cond 
                          (and (is_string? control_to_show)
                               (get_control_by_name control_to_show))
                          (get_control_by_name control_to_show)
                          (and (is_string? control_to_show)
                               (get_control_by_id control_to_show))
                          (get_control_by_id control_to_show)
                          (is_control? control_to_show)
                          control_to_show))
       (target_control (if *last_focus*
                         *last_focus*
                           nil)))
    (cond 
       (and target_control control_to_show)
       (progn
          (swap_control target_control control_to_show)
          (set_focus_to control_to_show)
          (sleep 0.1)
          
          true)
       control_to_show
       (progn
          (place_control "right" control_to_show)
          (sleep 0.1)
          (set_focus_to control_to_show)
          true)
       else
       (progn 
          (notify (dtext "The requested control to display wasn't found."))
          false)))
  {
    `description: (+ "Provided a control name, id or the control object itself, "
                     "will display the control, adjusting the layout as needed. "
                     "By default the control referenced by *last_focus* is swapped with the new one, "
                     "but if that isn't possible, the view is split and the new control is placed to "
                     "the right.<br>"
                     "Returns true if successful, otherwise a notification is "
                     "delivered that the control is not found, and false is "
                     "returned.")
    `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
    `usage: ["target:string|object"]
    })



(defun hide_control (target destroy? no_mod_layout)
   (let
      ((control (cond 
                   (and (is_string? target)
                        (get_control_by_name target))
                   (get_control_by_name target)
                   (and (is_string? target)
                        (get_control_by_id target))
                   (get_control_by_id target)
                   (is_control? target)
                   target))
       (confirmed true)
       (swap_target (and no_mod_layout
                         (last (-> (control_holding_tank) `controls)))))
      (declare (function control_holding_tank)
               (global control_holding_tank))
      (cond 
         (and control swap_target)
         (progn
            (if (and destroy?
                     (is_function? control.on_destroy))
                (= confirmed (-> control `on_destroy)))
            (sleep 0.01)
            (when confirmed   
               (swap_control control swap_target)
               (if destroy?
                  (try
                     (container_view_operation "destroy" control nil { `suppress_destroy_confirm: true } )
                     (catch Error (e)
                        (progn
                           (log_error "hide_control: " e.message)
                           (console.error "hide_control: " e)
                           (notify e.message)))))))
         control
          (progn
             (container_view_operation (if destroy? "destroy" "hide") control nil)
             true)
          else
          (progn
             (notify "Control not found")
             false)))
   {
       `description: (+ "Provided a control name, id or the control object itself, "
                        "will hide the control, adjusting the layout as needed. "
                        "Returns true if successful, otherwise a notification is "
                        "delivered that the control is not found, and false is "
                        "returned.  If destroy? is true, the control is removed from "
                        "the tree and destroyed.")
       `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
       `usage: ["target:string|object" "destroy?:?boolean"]
   })

(defun destroy_control (target)
  (hide_control target true)
  {
   `description: (+ "Provided a control name, id or the control object itself, "
                    "will hide the control, adjusting the layout as needed. "
                    "Returns true if successful, otherwise a notification is "
                    "delivered that the control is not found, and false is "
                    "returned. ")
   `tags: ["controls" "control" "display" "destroy" "remove" "holding_tank" "ui"]
   `usage: ["target:string|object"]
   })



(defun process_focus_chain (e originator_container)
   (progn
      (handle_event e)
      (when e.srcElement
         (let
            ((target_control nil)
             (elem e.srcElement)
             (controls (reduce (c (current_controls))
                          (when c.on_focus
                             c)))
             (focused_list (query_all ".juno-focused")))
            
            ;; check for if we have found the target control:
            ;; if the current element is equal to the controls view...
            ;; we found it, otherwise move up to the parent node...
            ;; and check again...until we can't
            (while elem
               (progn
                  (for_each (control controls)
                     (when (== elem control.view)
                        (= target_control control)
                        (break)))
                  (when target_control
                     (break))
                  (= elem elem.parentElement)))
            (console.log "process_focus_chain: setting focus to: " target_control.options.name)
            (set_focus_to target_control controls)))))


(defun menu_tree (items options _path)
  (let
      ((options (either options { `flat_index: 0 }))
       (path (either _path []))
       (disappear_timer nil)
       (os (get_operating_platform))
       (command_map { "Command": "⌘"
                      "Ctrl": (if (== os "mac")
                                     "⌃"
                                     "Ctrl")
                      "Alt": (if (== os "mac")
                                 "⌥"
                                 "Alt")
                      "Shift": "⇧" 
                      "Backslash": (String.fromCharCode 92)
                      "Escape": "Esc"
                      "Slash": "/"
                      })
       (compress_keycodes (fn (keycode)
                             (join " or " (map compress_keycode (split_by "|" keycode)))))
       (compress_keycode (fn (keycode)
                            (join "-" 
                               (for_each (c (split_by "-" keycode))
                                  (aif (prop command_map c)
                                       it
                                       c)))))
                               
       (min_width (+ "min-width: " (or options.min_width 350) "px;"))
       (id (either options.id "cmenu"))  
       (active_menu_item nil)
       (menu_element
        (fn (idx menu_details `& args)
          (let
              ((text menu_details.text)
               (kcode (or menu_details.keycode ""))
               (view (li {  `class: "pure-list-item"                                         
                          `style: (+ (if (> args.length 0)
                                         "position: relative;"
                                         "")
                                     min_width)
                          }
                         (a { 
                             `idx: idx
                             `path: (join "~" (conj path idx))
                             `href: "#"
                             `class: "pure-menu-link" 
                             `style: ""
                             }
                            (if (== args.length 0)
                              [(span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                               (span { `class: "juno-menu-submenu" } kcode)]
                              [(span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                               (span { `class: "juno-menu-submenu" } "❯")]))
                         args))
               (timer nil))
            (if (== args.length 0)
              (progn
                 (attach_event_listener view
                    `mouseenter
                    (fn (e)
                       (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)))
                 view)
              (progn
               (attach_event_listener view
                  `mouseenter
                  (fn (e)
                     (do
                        (= active_menu_item e.srcElement)
                        (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)
                        (add_class "juno-menu-selected" e.srcElement)
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (set_style [["display" "inline-block" ]
                                                      ["position" "absolute"]
                                                      ["top" "0px"]
                                                      ["left" (+ "" e.srcElement.offsetWidth "px") ]]
                                                     view.children.1))
                                       150)))))
               (attach_event_listener view
                  `mouseleave
                  (fn (e)
                     (do
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (progn
                                             (set_style [["display" "none"]] view.children.1)))
                                       150)))))
               
               view)))))
       (view nil))
    
    (= view
       (ul (+ {}
              { `class: (if (> path.length 0)
                             "juno-menu pure-menu-list"
                             "pure-menu-list")
                `style: (+ (if (> path.length 0)
                             "display: none;"
                             "display: inline-block;")
                           "position: relative;")  }
              (if (== path.length 0)
                { `id: id }
                {}))
                     
           (map (fn (item idx)
                  (let
                      ((menu_details {})
                       (struct (if (is_function? item.0)
                                   (item.0)
                                   item.0)))
                      (cond 
                         (is_string? struct)
                         (progn
                            (set_prop menu_details
                               `text struct)
                            (aif (resolve_path [ `global (to_key struct) ] *key_bindings*)
                                 (progn
                                    (set_prop menu_details
                                       `keycode (prop it os))
                                    (set_prop menu_details
                                       `exec (prop it `exec)))))
                         (and (is_object? struct)
                              (is_array? struct.path))
                         (progn
                            (if (resolve_path struct.path *key_bindings*)
                                 (progn
                                    (defvar detail (resolve_path struct.path *key_bindings*))
                                    (set_prop menu_details
                                       `text (or struct.text
                                                detail.description)
                                       `keycode (prop detail os)
                                       `exec detail.exec))
                                 (set_prop menu_details
                                         `text (or (prop struct `text)
                                                   (+ "No Menu Text Found " idx)))))
                         (is_object? struct)
                         (progn
                            (aif (and struct.text
                                      (resolve_path [ `global (to_key struct.text) ] *key_bindings*))
                                 (set_prop menu_details
                                    `text struct.text
                                    `keycode (prop it os)
                                    `exec it.exec)
                                 (set_prop menu_details
                                       `text (or struct.text
                                                (+ "No Menu Text Found " idx)))))
                         else
                         (set_prop menu_details
                            `text (+ "No Menu Text Found " idx)))
                      
                      (set_prop options
                         `flat_index
                         (+ 1 options.flat_index))
                    (when menu_details.keycode
                       (set_prop menu_details
                                 `keycode 
                                 (compress_keycodes menu_details.keycode)))
                    (cond
                      (is_array? item.1)
                      (menu_element options.flat_index menu_details (menu_tree item.1 options (conj path [ idx 1])))
                      (and (== menu_details.text "--") (eq nil item.1))
                      (hr { `class: "LightHR" })
                      (is_function? item.1)
                      (menu_element idx menu_details)
                      (is_string? item.1)
                      (menu_element idx menu_details)
                      else
                      [])))
                items)))
    (if (> path.length 0)      
       view
      (progn
       (attach_event_listener view
                              `click
                              (fn (e)
                                (let
                                    ((path (-> e.srcElement `getAttribute "path"))
                                     (idx (-> e.srcElement `getAttribute "idx"))
                                     (target (if path
                                               (resolve_path (split_by "~" path) items))))
                                  (handle_event e)
                                  (-> view `remove)
                                  (aif (get_by_id "cmenu")
                                       (-> it `remove))
                                  (when (is_function? options.on_select)
                                     (options.on_select path))
                                  (sleep 0.01) ;; disconnect and move to back of the event loop for the call
                                  (when (and target
                                             (is_function? target.1))
                                    (try
                                       (target.1 e target.2)
                                       (catch Error (e)
                                          (log_error "Base Catch: " e.message)
                                          (log_error e))))
                                  )))
       (setTimeout (fn ()
                     (progn
                      (attach_event_listener view
                                             `mouseleave
                                             (function (e)
                                                       (progn
                                                        (when disappear_timer
                                                          (clearTimeout disappear_timer))
                                                        (= disappear_timer (setTimeout (fn ()
                                                                                         (progn
                                                                                          (-> view `remove)
                                                                                          (when (is_function? options.on_select)
                                                                                             (options.on_select nil))
                                                                                          (= disappear_timer nil)))
                                                                                       (or *env_config*.application.menu_timeout
                                                                                           options.menu_timeout
                                                                                           2500))))))
                      (attach_event_listener view
                                             `mouseenter
                                             (function (e)
                                                       (when disappear_timer
                                                         (clearTimeout disappear_timer)
                                                         (= disappear_timer nil))))))
                   700) ;; delay a little before adding the timeout so we don't accidentally hover over it 
       {
        `view: view
        `toJSON: (function ()
                           `(menu_tree ,#items ,#options))
        `type: "menu_tree"
        }))))

(defun make_menu (for_element menu_items options)
  (let
      ((menu_items menu_items)
       (for_element for_element)
       (pos nil)
       (mtree nil)
       (disappear_timer nil)       
                                        
       (view nil))
    (aif (get_by_id "cmenu")
         (-> it `remove))
    (setq mtree
          (menu_tree menu_items options))
    (setq view
          mtree.view)
    (add_class "juno-menu" view)
    (when for_element
      (setq pos
            (-> for_element `getBoundingClientRect))
      (set_style [["top" (+ "" (Math.max 0 pos.bottom) "px") ]
                  ["left" (+ "" (Math.max pos.left 0) "px") ]
                  ["position" "absolute"]
                  ["z-index" "30"]]
                  view)
      (console.log "make_menu: found element at: " pos))
    
     
    (if options.do_not_attach
      view
      (progn       
       (-> (get_by_id "body") `appendChild view)
       (console.log "appended view" view)
       view)))
  {
    description: (+ "The `make_menu` function constructs a pop-up menu DOM structure and "
                    "attaches it to the provided element.  The menu items are constructed from the "
                    "`menu_items` nested array, which follows the standard menu structure.  The "
                    "function, by default, attaches the constructed menu view to the element when "
                    "called, but if the `do_not_attach` option is provided, will only produce and "
                    "return the menu, and not mount it as a child to the provided element.  <br>The "
                    "produced menu always has an id of `cmenu`, and if there is already an element "
                    "attached to the DOM with that ID, it will remove it prior to construction of "
                    "the new menu.<br>The menu is attached to the provided DOM element at the bottom "
                    "left of the element.<br>The return value is the generated menu "
                    "view.<br><br>#### Menu Format   <br><br>All menu structures that are provided "
                    "to this function should follow the format of:```[[\"Menu Item 1 Text\" (fn "
                    "(click_event))]\n [\"--\" nil]\n [\"Menu Item 2 Text\" [[\"Sub Menu 1\" (fn "
                    "(click_event))]\n                      [\"Sub Menu 2\" (fn "
                    "(click_event))]]]]```<br><br><br>Submenus are constructed by a nested array as "
                    "a second argument.<br>If a `--` string is encountered as a first argument and "
                    "nil as a second argument, then a horizontal rule is inserted in the generated "
                    "menu view.<br><br>#### Shortcuts   <br><br>The easiest way to link a short cut "
                    "action to a menu item is to link by name.  This means that the text value in "
                    "position 0 of the descriptor array (e.g. \"Menu Item 1 Text\") is turned into a "
                    "key by the `to_key` function, such that \"Menu Item 1 Text\" becomes "
                    "`menu_item_1_text`, which is then checked against the `*key_bindings*` global "
                    "in the namespace.  If a key binding is found with the key `menu_item_1_text` "
                    "then that key is used as a short cut.  This method helps keep a naming linkage "
                    "between the short cut key entries and the menu item entries.<br>Optionally "
                    "instead of a text item in position 0 of the descriptor array an object can "
                    "instead be present with the following key structure:```{\n  text: \"The displayed "
                    "menu text\"\n  path: [ `global `command ]  ;; in *key_bindings*\n}```<br><br>The "
                    "keycode will come from the linked key code which is dependent on the operating "
                    "platform.<br><br>#### Example   <br>```(let \n   ((b (button \"Right Click!\")))\n "
                    "(attach_event_listener b `contextmenu\n      (fn (right_click_event)\n       "
                    "(progn\n            (handle_event right_click_event)\n            (make_menu b\n  "
                    "                   [[\"Hi There\" (fn (menu_click_event)\n                        "
                    "             (notify (+ \"Hi There: \"\n                                          "
                    "      right_click_event.srcElement.tagName)))]\n                       [\"Good "
                    "Bye!\" (fn (menu_click_event)\n                                       (notify (+ "
                    "\"Good Bye!: \"\n                                                 "
                    "menu_click_event.srcElement.tagName)))]]\n                       {\n             "
                    "          min_width: 250 }))))\n   b)```<br><br><br>#### Options "
                    "<br><br>min_width:number -The minimum width for the menu item.   This setting "
                    "impacts how wide the menu element is.<br>do_not_attach:boolean -If true, the "
                    "menu Element structure is created as a view, but not attached to the target "
                    "element, and is instead just returned.   ")

    usage: ["for_element:Element" "menu_items:array" "options:?object"]
    tags: ["menu" "events" "popup" "UI" "DOM" "contextmenu" "menu-structure"]
    })

(defun_sync get_key_code (e)
  (let
      ((k []))
      (when e.metaKey
         (push k "Command"))
      (when e.ctrlKey
         (push k "Ctrl"))
      (when e.altKey
         (push k "Alt"))
    (when e.shiftKey
      (push k "Shift"))
    (unless (contains? e.key [ "Shift" "Control" "Alt" "Meta" ])      
            ;; normalize to the printed key characters on the keyboard
            (push k (cond 
                       (starts_with? "Key" e.code)
                       (-> e.code `substr 3)
                       (starts_with? "Digit" e.code)
                       (-> e.code `substr 5)
                       else
                       e.code)))
    (if (> k.length 0)
        (join "-" k)
        e.code))
  {
      `description: (+ "Given a key event, returns a text description of the set of characters in a normalized order "
                       "for matching keybinding handlers.  If no modifier keys (Control, Alt, Command, or Shift), returns "
                       "the direct code value from the key event.  If a modifier or modifiers are also pressed, will "
                       "return a composite value with the following order of priority, where if a key with a lower "
                       "prority is pressed, it will appear first in the returned value:<br>"
                       "Command - 0 <br>"
                       "Ctrl - 1<br>"
                       "Alt - 2<br>"
                       "Shift - 3 <br>"
                       "For example if the user is pressing both the Shift and the Control key and the 'A' key, the "
                       "returned value will be \"Ctrl-Shift-A\" as the priority value for 'Control' is 1 and the "
                       "priority value for 'Shift' is 3.  Note that whenever a modifier is pressed, the value of "
                       "the pressed key will be always uppercase as the descriptor.")
      `usage: ["event:Event"]
      `tags: [ "key" "events" "binding" "keycodes" "keyboard"]
  })

(defun attach_context_menu (element menu_gen)
   (progn
      (attach_event_listener element `contextmenu
         (fn (e)
            (progn
               (handle_event e)
               (make_menu element
                          (cond
                             (is_function? menu_gen)
                             (menu_gen e)
                             (is_array? menu_gen)
                             menu_gen)
                          {
                            min_width: 250
                            }))))
      element)
   {
     description: (+ "<br><br>Given a target DOM element and a menu generator function or a menu "
                     "array, attaches a `contextmenu` event listener to the target element.  The menu "
                     "generator argument can either be a function which returns a nested array "
                     "structure in the standard menu format, or a pre-built array with the menu "
                     "structure already generated.  The element that the context menu event listener "
                     "is returned.\n\n<br>If provided a function for the menu_generator argument, the "
                     "contextmenu event is passed to the function when called.  <br>The individual "
                     "menu items will receive the click event from the selected menu items.<br>See "
                     "`make_menu` for more information on the standard menu format.<br><br>#### "
                     "Example:   <br>```(let\n   ((b (button \"Right Click!\")))\n  (attach_context_menu "
                     "\n      b\n      (fn (right_click_event)\n         [[\"Hi There\" (fn "
                     "(menu_click_event)\n                         (notify (+ \"Hi There: \"\n           "
                     "                        right_click_event.srcElement.tagName)))]\n        "
                     "[\"Good Bye!\" (fn (menu_click_event)\n                          (notify (+ \"Good "
                     "Bye!: \"\n                                   "
                     "menu_click_event.srcElement.tagName)))]])))```<br> ")

     usage: ["element:Element" "menu_generator:function|array"]
     tags:["events" "contextmenu" "menu" "context" "event" "DOM" "UI"]
     })

(defun request_user_input (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((user_input (if options.input
                                    options.input
                                    (input (+ {`tabindex: 0 `type: (or type "text") `style: "width: calc(100% - 15px)" }
                                              (if options.placeholder
                                                 { placeholder: options.placeholder }
                                                 {})
                                              (if options.title
                                                 { `title: options.title }
                                                 {})
                                              (if options.class
                                                 { `class: options.class } 
                                                 {})
                                              (if options.value
                                                 { `value: options.value } 
                                                 {})
                                                ))))
                      (completed false)
                      (ok_button (button { `class: "juno-primary" `style: "float:right" } (dtext "OK")))
                      (cancel_button (button { `class: "juno-secondary" }  (dtext "Cancel")))
                      (dwin (dialog { `style: "height: min-content; width: min-content;"   }
                                    (div { `class: "juno-instructions" } prompt)
                                    (br)
                                    user_input
                                    (br)
                                    (div { `class: "pure-button-group juno-control-group" `style: "margin-top: 10px;" `role: "group" }
                                         (if options.no_cancel_button
                                            []
                                            cancel_button)
                                         ok_button)))
                      (rval nil)
                      (get_current_value (fn ()
                                            (cond
                                               user_input.value
                                               user_input.value
                                               (getAttribute user_input `value)
                                               (getAttribute user_input `value)
                                               options.no_cancel_button
                                               true)))
                      (return_value (fn ()
                                       (progn
                                          (= rval (get_current_value))
                                          (cond
                                             (is_function? options.validator)
                                             (if (-> options `validator rval)      
                                                 (clean_up rval) ;; if the validator returns true, ok remove the dialog box
                                                 nil) ;; wait for an appropriate inpit
                                              else
                                              (clean_up rval)))))
                                                     
                                                     
                      (clean_up (fn (val)
                                    (when (not completed)
                                        (= completed true)
                                        (resolve val)
                                        (-> dwin `remove)))))
                     
                     
                     
                     (if (is_function? options.validator)
                         (set_disabled ok_button))
                     
                     (attach_event_listener ok_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (return_value))))
                     ;; don't immediately react to keyup so as not to immediately react
                     ;; in certain scenarios
                     (setTimeout (fn ()
                                    (attach_event_listener user_input
                                       `keyup
                                       (fn (e)
                                          (cond
                                             (== e.key "Enter")
                                             (progn
                                                (handle_event e)
                                                (return_value))
                                             (is_function? options.validator)
                                             (progn
                                                (if (-> options `validator (get_current_value))
                                                    (set_enabled ok_button)
                                                    (set_disabled ok_button)))))))
                                 
                                 250);
                     (attach_event_listener cancel_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (clean_up nil))))
                     
                     (attach_event_listener dwin
                        `close
                        (fn (e)
                           (clean_up nil)))
                     
                     (when options.default_value
                        (set_prop user_input
                           `value
                           options.default_value))
                     
                     (-> juno_container
                        `appendChild dwin)
                     ;(setTimeout (fn ()
                     ;              (place_caret_at_end user_input))
                     ;          50)
                     (when (is_function? dwin.showModal)
                        (-> dwin `showModal)
                        (-> user_input `select)))))
  {
    description: (+ "This function will pause the flow of execution until the user makes a choice, "
                    "selection or input and then will return the result of the user action.  If the "
                    "user presses cancel or presses the Escape key, a return value of nil will be "
                    "returned.<br>"
                    "By default, the user is presented with a text input box in which text can "
                    "entered.  Once the user presses return or clicks the OK button, the value is "
                    "returned.  However, if the `type option is given as an input, the input will "
                    "be of the specified type, such as \"number\" or \"date\". <br>"
                    "Additionally options can be provided for more control over the interaction "
                    "and value presentation.  If provided with a key of \"input\" and an input element, "
                    "the provided input element will be displayed and the final value returned.  "
                    "Other elements can be provided and as long as they either set a value property "
                    "or value attribute on the element, that value will be returned.<br>"
                    "Values can be validated by passing a \"validator\" function.  Upon the user "
                    "pressing a key, the validation function will be called with the "
                    "current value and if the validation function returns true, OK will be enabled, "
                    "or if the user pressed enter, the validated value will be returned to the caller, "
                    "otherwise the OK button will be disabled and the dialog box will not close. "
                    "Note that the validator function is responsible for any prompting of "
                    "or additional notices of how to comply with the validation rules.  This "
                    "could be done by providing a more complicated element structure as an input that is in "
                    "the closure of the validator whose values could be updated.")
    usage: ["prompt:string" "type:string" "options:object"]
    tags: ["user" "input" "request" "collect" "wait" "ui" "DOM"]
    })
                 
(defun request_user_choice (prompt choice_list options)
   (request_user_input prompt nil
                       {
                           `input:(apply select (+ {}
                                                   (if options.class
                                                      { `class: options.class }
                                                      {})
                                                   (if options.style
                                                      { `style: options.style }
                                                      {}))
                                     (for_each (choice choice_list)
                                        (cond
                                           (is_array? choice)
                                           (option (+ { `value: choice.1 } 
                                                      (if (and options.default_value
                                                               (== choice.1 options.default_value))
                                                         { `selected: true }
                                                         {}))
                                                   choice.0)
                                           else
                                           (option (+ {} 
                                                      (if (and options.default_value
                                                               (== choice options.default_value))
                                                         { `selected: true }
                                                         {}))
                                                   choice))))
                           `no_cancel_button: options.no_cancel_button
                       })
   {
       `usage: ["prompt:text" "choice_list:array" "options:object"]
       `description: (+ "This function will pause the flow of execution until the user " 
                        "makes a choice, selection or input and then will return the result " 
                        "of the user action. If the user presses cancel or presses the " 
                        "Escape key, a return value of nil will be returned.<br>"
                        "The choice list can be either an array of simple values, such as " 
                        "strings or numbers, or it can be an array of 2 value arrays (pairs), "
                        "where the first value is the presented text for the choice, and the "
                        "second value is the value of the selection that is returned "
                        "if selected.  Note that all values are stored in the DOM as "
                        "strings, so if non-string numbers are required as values, <br>" 
                        "they must be converted to their required form once returned "
                        "from this function."
                        "#### Example forms for the choice_list argument<br>"
                        "A simple form:"
                        "```[\"First Choice\" \"Second Choice\"]```"
                        "A form with two choices:"
                        "```[[\"First Choice\" 1] [\"Second Choice\" 2]]```"
                        "Note that in the second example the values are numeric, but "
                        "will be returned from the function as a string value.<br>"
                        "#### Options<br>"
                        "The options object can have the following keys:<br>"
                        "default_value:string - The value default selected choice.  This should match "
                        "a specific choice value in the choice_list array.<br>"
                        "class:string - A class name or names to be used for the select element.<br>"
                        "style:string - A semi-colon delimited set of CSS attributes "
                        "to be applied to the select element.<br>"
                        "no_cancel_button:boolean - If true the cancel button will not be displayed.<br>")
       `tags: ["request" "user" "choice" "collect" "wait" "ui" "DOM"]
   })

(defun select_control_by_name (prompt options)
   (let
      ((no_sub_controls (not options.include_sub_controls))
       (controls (current_controls no_sub_controls))
       (prompt (or prompt (dtext "Please Select a Control")))
       (names  (reduce (ctl controls)
                 (let
                    ((name (resolve_path [ `options `name ] ctl)))
                    (progn
                       (cond
                          options.include_specials
                          name
                          (is_function? options.include_if_true)
                          (if (-> options `include_if_true ctl)
                              name
                              nil)
                          (and (not (== ctl (control_holding_tank)))
                               (not (starts_with? "split_view" ctl.type))
                               (not (resolve_path [ `options `root_frame ] ctl)))
                          name)))))
                          
                          
       (name_elems (map (fn (name) 
                           (option name))
                        names))
       
       (dlist_id (gen_id "controls"))
       (dlist (apply datalist { `id: dlist_id } name_elems))
       (selector (input { `list: dlist_id `style: "width: calc(100% - 10px);"} ))
       (value nil))
      (try
         (progn
           (-> (get_by_id `body) `append dlist)
           (= value (request_user_input prompt 
                                        `text 
                                        { input: selector
                                          validator: (fn (v)
                                                        (contains? v names))
                                        })))
         (catch Error (e)
            (progn
               (log "select_control_by_name: error in request_user_input operation: " e.message))))
      (log "selected: " value)
      (-> dlist `remove)
      (get_control_by_name value))
   {
       `description: (+ "Given a prompt and an optional options object, presents a dialog that displays the "
                        "given prompt and allows the user to select or type a control name.  A drop down "
                        "allows the user to select the closest matched to the typed in text.<br>"
                        "The selected control is returned, or nil if the user presses cancel or presses Escape.<br>"
                        "By default no split_views, sub controls (controls contained by other controls) " 
                        "or root controls are displayed, only content controls.<br>"
                        "Options:<br>"
                        "include_specials:boolean - By default false, all controls will be presented.<br>"
                        "include_sub_controls - Include the sub controls.<br>"
                        "include_if_true:function - Predicate function which is passed a control, and if the function "
                        "returns true the control will be included in the selection, otherwise it will not be.")
       `usage: ["prompt:text" "options:object"]
       `tags: ["controls" "select" "choose" "user" "UI" "DOM" ]
   })  


(defun alert_box (message detail)
   (request_user_input (or message "No message provided!") 
                       nil 
                       { `input: (if detail 
                                     (div detail)
                                     (span {})) 
                         `no_cancel_button: true })
   {
     `usage:[ "message:text" "detail:text|Element"]
     `description: "Creates a modal type popup dialog box which pauses the current execution flow until the OK button is clicked. The return value is undefined."
     `tags: ["alert" "popup" "modal" "box" "warn" "ui" "DOM" ]
   })
     
(defmacro alert_on_error (error_title `& forms)
   `(try
       (progn
          ,@forms)
       (catch Error (e)
          (progn
             (alert_box ,#(or error_title (dtext "Error on Operation"))
                         e.message)
             nil)))
   {
       `usage: ["error_title:text" "forms:*"]
       `description: (+ "All provided forms will be wrapped in a progn and the last value of the provided forms returned.  " 
                        "Any uncaught errors in the provided forms will be caught by this macro abd the provided " 
                        "error_title, and exception message presented to the user for acknowledgement.  On a caught error "
                        "nil will be returned to the calling code.")
       `tags: ["alert" "popup" "catch" "errors" "ui" "DOM"]
   })

;; -- Control Events --------
;; event routing is handled by a map that combines the command value and the source value.
;; if an array is found at the value, it will call each function in the array in sequence
;; as each function in the array is an event handler

(defparameter *event_routes* 
   { }
   {
     `description: (+ "The event routing object which contains routes used by dispatch_event. "
                      "<br>Use register_event_handler to add event handlers and " 
                      "remove_event_handler remove handlers. ")
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes"  ]
     })

(defun_sync compute_handler_key (source command)
   (+ (if (is_string? source)
                           (+ "" source )
                           "")
                       (if (is_string? command)
                           (+ "+" command)
                           ""))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given a source and a command, computes the event_handler lookup key for control events."
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" ]
   })


(defun register_event_handler (source command function_id handler_function)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (exists false))
      (if (blank? handler_key)
          (throw TypeError "register_event_handler: one or more of source and command must be specified as strings"))
      (if (blank? function_id)
          (throw TypeError "register_event_handler: function_id is required"))
      (if (blank? handler_function)
          (throw TypeError "register_event_handler: handler_function is required"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
         (set_prop *event_routes*
            handler_key
            (list { `fid: function_id f: handler_function }))
         (progn
            (for_each (handler handlers)
               (if (== handler.fid function_id)
                   (setq exists true)))
            (if exists
               (throw ReferenceError "register_event_handler: function already registered for key")
               (push handlers { fid: function_id f: handler_function }))))
      handler_key)
   {
       `usage: ["source:string" "command:string" "handler_function_id:string" "handler_function:function"]
       `description: (+ "Given a control source id, command string, and a handler function, adds the function to the "
                        "event handler.<br>Either the source id or the command string can be nil, but not both. " 
                        "Omitting one of the specifiers broadens the scope of the events that will be routed "
                        "to the handler function.  For example, if the source id is omitted, but the command "
                        "string is provided, all events that match the command string, regardless of source "
                        "will be routed to the function.  Conversly, if the command string is omitted, but the "
                        "source is provided, all events from that source will trigger the handler function to "
                        "to be called.  Note that there can be multiple handler functions registered for the same "
                        "source id/command combination.<br>"
                        "If the function is determined to be already registered using equality, then "
                        "the function will throw a ReferenceError that the same function is already registered.  "
                        "Returns the computed handler_key.<br>The handler function should be defined in the "
                        "form of (fn (event_obj)), where event_obj will be the event object as transmitted " 
                        "from the source.<br>")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })
    
(defun remove_event_handler (source command handler_function_id)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (idx nil))
      (if (blank? handler_key)
          (throw TypeError "remove_event_handler: one or more of source and command must be specified as strings"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
          true
          (progn
             (if (eq nil handler_function_id) ;; if no handler_function_id is provided, remove all handlers for the events
                 (progn
                    (set_prop *event_routes*
                       handler_key
                       [])
                    true)
                 (progn
                    (map (fn (f i)
                            (if (== f.fid handler_function_id)
                                (setq idx i)))
                         handlers)
                    (when idx
                       (-> handlers `splice idx 1))
                    (if idx
                       true
                       false))))))
   {
       `usage: ["source:string" "command:string" "handler_function_id:string"]
       `description: (+ "Given a control source id, command string, and a handler function, removes the function to the "
                        "event handler.  If the function isn't found in the event handlers using equality, then "
                        "the function will return false, otherwise if successful it will return true.  If no function is "
                        "is provided, then all handlers for the key will be removed.")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })

(defun get_control_event_handlers (source command)
   (prop *event_routes* (compute_handler_key source command))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given an source string and command string, returns an array of all specific matching handlers for the given values."
       `tags: ["events" "controls" "handlers" "dispatch" "routes" ]
   })  
  
(defun remove_all_handlers_for_source (source)
   (let
      ((routes nil))
      (when (not (is_string? source))
         (throw TypeError "source must be a string"))
      (setq routes
         (reduce (key (keys *event_routes*))
            (when (starts_with? (+ "" source "+") key)
               key)))
      (apply delete_prop *event_routes* routes)
      (length routes))
   {
       usage: ["source:string"]
       description: (+ "Given a source identifier, removes all routes associated with that source. "
                       "Returns the number of routes removed.")
       tags: ["events" "controls" "routes" "handlers" "source" "dispatch"]
   })

(defun_sync dispatch_event(event_obj)
   (let
      ((handler_key (compute_handler_key event_obj.source event_obj.command))
       (handlers (when handler_key  ;; check for handlers that match specifically, match only source events, and match only command events
                    (flatten (conj (or (prop *event_routes* handler_key) [])
                                   (or (prop *event_routes* (compute_handler_key event_obj.source nil)) [])
                                   (or (prop *event_routes* (compute_handler_key nil event_obj.command)) []))))))
                    
      (when (> __VERBOSITY__ 0)
         (log "dispatch_event: " event_obj handler_key handlers))
      (if (> handlers.length 0)
           (for_each (handler handlers)
              (try
                 (progn 
                    (-> handler `f event_obj))
                 (catch Error (e)
                    (log (+ "Error on event handler for route: " handler_key ": " e.message))))))
      (when event_obj.error
         (progn
            (log "dispatch_event: error: " event_obj)
            (alert_box (+ ""
                          (from_key event_obj.command)
                          (if event_obj.args.1.message
                             (+ ": " event_obj.args.1.message)
                             ""))
                       (aif (and event_obj.args.0
                                event_obj.args.0.options.filename)
                           (+ "The file " it " was unable to be saved.")))))
      true)
   {
     
     `description: (+ "<br><br>Dispatches received event objects from controls using the "
                      "*event_routes* table.  Routes are determined via compute_handler_key.  If a "
                      "route key resolves to an array, each handler function in the found array in the "
                      "*event_routes* table is called in sequence.  Routes are collected by first "
                      "looking for handlers that act on the source+command, then source, then "
                      "command.<br>The event handler functions are called with the `event_object` as a "
                      "single argument, such as `(my_handler_function event_object)`.<br>Use "
                      "register_event_handler to add event handlers and remove_event_handler remove "
                      "handlers. The function return value shouldn\'t be used. ")

     `usage: ["event_obj:object"]
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
     })
     


(defun get_editors_for_path (path)
   (let
      ((spath (cond
                 (is_array? path)
                 (join "~" path)
                 (is_string? path)
                 path
                 else
                 (throw TypeError "path must be an array or string"))))
      (reduce (ctl (current_controls))
         (when (and ctl.editor
                    ctl.options.path
                    (== (join "~" ctl.options.path) spath))
            ctl)))
   {
       `description: "Returns an array of all controls that are editors and that have the supplied path value."
       `usage: ["path:array|string"]
       `tags: ["controls" "editor" "path"]
   }) 

(defun get_control_by_editor (editor)
   (let
      ((ctls (current_controls true)))
      (first (reduce (ctl ctls)
                (when (== ctl.editor editor)
                   ctl))))
   {
       `description: "Given an editor object, returns the control associated with it."
       `usage: ["editor:object"]
       `tags: ["editor" "control" "find"]
   })

(defun get_editor_file_basename (editor_control)
   (aif (resolve_path [ `options `filename ] editor_control)
        (last (split_by "/" it))
        nil)
   {
       description: (+ "If given a control with an editor which is operating on a file, " 
                        "will return the filename without the directory path for that editor. "
                        "Otherwise, it will return nil")
       usage: [ "editor_control:object"]
       tags: ["editor" "file" "basename" "filename" "path"]
   })

(defun close_file (editor_control)
   (let
      ((closed_focus? false))
      (log "close_file: " (and editor_control (prop editor_control `options)))
      (if (and (is_function? editor_control.on_destroy)
               (-> editor_control `on_destroy))
          (progn
             (for_each (ctl (get_editors_for_path editor_control.options.path))
                (progn
                   (if (not closed_focus?)
                       (= closed_focus? (== ctl *last_focus*)))
                   
                   (try
                      (container_view_operation `destroy ctl nil { `suppress_destroy_confirm: true } )
                      (catch Error (e)
                         (log "close_file error: " e.message)))))
             ;(log "close_file: calling default_focus" closed_focus?)
             (if closed_focus?
                   (default_focus)))
          (notify "Close cancelled."))))

;; when save events are dispatched, this function should be the
;; receiver.  It will get the value from the sending control,
;; attempt to save it, and if successful, will dispatch save_complete to
;; all editors with the specific path

(defun save_event_handler (event_obj)
   (alert_on_error "Unable to save"
       (let
          ((control (get_control_by_id event_obj.source))
           (pathname (when control
                        control.options.path))
           (nseval (if (not (blank? control.options.path_namespace))
                       (-> Environment `get_namespace_handle control.options.path_namespace)
                       Environment))
           (do_remote_save (fn ()
                              
                              (let
                                 ((rval nil))
                                 (= rval (http/send_files "/save_file" (http/data_to_file control.options.filename (or (-> control `get) ""))))
                                 (if (and rval
                                          (== rval.rval "OK"))
                                     (progn
                                        (= rval rval.results)
                                        (log "save_event_handler: saved remote file OK: " (clone rval))
                                        (if (== rval.length 1)
                                            (publish_results (+ { `target: rval.0.filename `type: "filename" } rval.0 ))
                                            (progn
                                               (log "ERROR: got different result for save_file then expected" (clone rval))
                                               (throw TypeError "Got different result for save file then expected"))))
                                     (progn
                                        (log "ERROR: save_event_handler: couldn't remote save: " (clone rval)))
                                        (throw TypeError (or rval.message "Uknown response from server"))))))
           (do_path_save (fn ()
                            (progn
                               (make_path pathname nseval.global_ctx.scope
                                  (-> control `get))
                               (if (not (== (sha1 (as_lisp (-> control `get))) (sha1 (as_lisp (resolve_path pathname nseval.global_ctx.scope)))))
                                   (progn
                                      (log "ERROR: save_event_handler: couldn't save path: values not matching: namespace: " control.options.namespace "path:" pathname )
                                      (throw TypeError "couldn't save to the local path - values not matching for path/namespace"))
                                   (progn
                                      (log "save_event_handler: saved local path OK: " control.options.path_namespace pathname)
                                      (publish_results { `target: pathname `type: "path" `namespace: control.options.path_namespace }))))))
                                   
                               
           (publish_results (fn (results_obj)
                               (let
                                  ((controls_to_notify (get_editors_for_path control.options.path)))
                                  (for_each (ctl controls_to_notify)
                                     (-> ctl `on_save_complete { `command: "save_complete" `source: control.options.id args: [ results_obj ] }))))))
          
          ;; validate we have what we need 
          (cond
             (eq nil control)
             (throw ReferenceError "Source control not found")
             (eq nil control.get)
             (throw TypeError "Source control doesn't have a get method for saving"))
          
          (cond
             (and (is_string? control.options.filename) ;; do we have a filename
                  is_served?)  ;; can we do a save?
             (progn
                (if (contains? "http_client" *env_config*.features)
                    (do_remote_save)
                    (throw ReferenceError "http_client is not a registered feature.")))
             (is_string? control.options.filename)
             (throw Error "Not connected to a server - cannot save the remove file")
             
             control.options.path
             (progn
                (do_path_save))))))
             
             

    
                     


(defun load_js_file (file)
  (let
      ((fdata (try
                (read_file file { `read_as: "text" })
                (catch Error (e)
                  e)))
       (assignment_to nil)
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
       (aif (request_user_input "Enter a name for a reference to the loaded Javascript" "text")
            (do
              (= assignment_to it)              
              (try
                (progn
                 ;(debug)
                 (cond
                   (or (== assignment_to "global")
                       (== assignment_to "script"))
                   (-> (page_header) `append (script { `type: "text/javascript" `charset: "utf-8" }
                                                     (javascript fdata)))
                   else
                   (eval `(defglobal ,#assignment_to (javascript ,#fdata)))))
                (catch Error (e)
                  (do
                    (= error true)
                    (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                    (console.error "ERROR: " e))))                                                    
              (when (not error)
                (log (message (+ "Loaded JS to " assignment_to )))))
            (notify "Entry Cancelled")))
      else
      (progn
       (log "Unable to read the file")
       (console.error fdata)))))

(defun embed_js_orig (name js_text) 
  (progn
   ;(debug)
   (-> (page_header) `append (html/script { `id: name `type: "text/javascript" `charset: "utf-8" }
                                     (javascript js_text)))   
   (eval `(defglobal ,#name (html/get_by_id ,#name)
            {
             `embedded_script: true
             }))))

(defun embed_js (name js_text) 
  (progn
   ;(debug)
   (eval `(-> (page_header) `append (html/script { `id: name `type: "text/javascript" `charset: "utf-8" }
                                     (javascript ,#js_text))))
   (eval `(defglobal ,#name (html/get_by_id ,#name)
            {
             `embedded_script: true
             }))))

(defun embed_js_file (file)
  (let
      ((fdata (try
                (read_file file { `read_as: "text" })
                (catch Error (e)
                  e)))
       (assignment_to nil)
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
       (aif (request_user_input "Enter a name for a reference to the loaded Javascript" "text")
            (do
              (= assignment_to it)              
              (try
                (embed_js_orig assignment_to fdata)                   
                (catch Error (e)
                  (do
                    (= error true)
                    (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                    (console.error "ERROR: " e))))                                                    
              (when (not error)
                (log (message (+ "Loaded JS to " assignment_to )))))
            (notify "Entry Cancelled")))
      else
      (progn
       (log "Unable to read the file")
       (console.error fdata)))))

(defun load_files (files)
  (when (> files.length 0)
    (for_each (file files)
       (do
         (cond
           (== file.type "text/javascript")
           (embed_js_file file)
           (== file.type "text/plain")
           (notify "Text Resource")
           (or (ends_with? file.name ".lisp")
               (ends_with? file.name ".juno"))
           (notify "Loading lisp file"))))))



(defun control_frame (options `& contents)
  (let
      ((has_control_bar? (and (> contents.length 1)
                              (has_class? "juno-buffer-bar" contents.0)))
       (content (if has_control_bar?
                     [(first contents)
                      (div { `class: "juno-view-content" }
                           (rest contents)) ]
                     (div { `class: "juno-view-content" }
                           (rest contents))))
       (elem (div (+ { tabindex: 0 control_id: (or options.id (generate_id "frame"))
                      class: (+  "juno-view-container"
                                  (or options.classes "")) }
                      (if options.style
                        { `style: options.style }
                        {}))
                   content)))
    ;(log "control_frame: has_control_bar: " has_control_bar? contents)
    (when (not has_control_bar?)
      (set_style [["height" "100%" ]] content))
    (when (is_array? options.events)
      (for_each (ev options.events)
                (destructuring_bind (event_type action)
                     ev
                   (console.log "making events: " event_type action)
                   (attach_event_listener elem event_type action))))
    elem)
  {
   `description: (+ "Creates and returns an element representing the external frame "
                    "of a control. The passed contents can contain a buffer bar as a "
                    "first element, which will be identified as such by having a "
                    "juno-buffer-bar class assigned to it. <br>"
                    "The passed contents (excluding the buffer bar) are wrapped in a"
                    "juno-view-content div, and the whole contents, including the optional "
                    "buffer bar element are wrapped in a juno-view-container div.<br><br>"
                    "The options are as follows: <br><br>"
                    "id:string - The assigned id for the control.<br>"
                    "style:string - A string containing css styling attributes that are assigned "
                    "to the juno-view-container div (the encompassing element).<br><br>"
                    "events:array - An array of array values in the form of pairs in the "
                    "form of [event_type:string action:fn] which are attached to the "
                    "juno-view-container element.")
   `usage: ["options:object" "elements:Elements"]
   `tags: ["ui" "controls" "control" "frame" "DOM" "Node" "element" ]
   })

(defun name_control (prefix)
  (let
      ((prefix (or prefix "Unnamed"))
       (name ""))
    (if (get_control_by_name prefix)
      (+ prefix " " (inc *view_count*))
      prefix)))




(defun symbol_browser (options)
   (let
       ((self {})
        (options (or options {}))
        (show_previews (not options.disable_preview))                                
        (id (generate_id "symbol_browser"))
        (name (name_control (or options.name "Symbol Browser")))                  
        (title_span (span { `class: "juno-title" } name))
        (path_span (span { `class: "juno-path" `style: "float: right" } ""))
        (buffer_commands_button (commands_button id))
        (stack [ ])
        (filter_span (span { `style: "margin-left: 8px; margin-right: 8px; font-family: var(--main-mono-space);" } ""))
        (filter_span_container (span { `style: "border-radius: 3px; margin-left: 10px; padding-top: 2px; padding-bottom: 2px; border: 1px solid var(--type-regexp-color);" } 
                                     (span { `style: "padding-left: 10px; padding-right: 10px; background: var(--type-regexp-color); padding-top: 2px; padding-bottom: 2px; color: wheat;" } (+ (dtext "Filter") ":"))
                                     filter_span))
        (olist_style "padding-block-start: 3px; margin-block-start: 0.2em; padding-inline-start: 2px; ")
        (li_style "")
        (control_status (div {  class: "juno-buffer-bar" }
                                buffer_commands_button
                                (cond
                                  (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span)
                                filter_span_container
                                path_span))
        (symbol_struct (symbols_by_namespace))
        (element_for_pos (fn (pos want_parent?)
                           (let
                               ((target_col nil))                                
                             (= target_col (-> cview `querySelector (+ "[pos='" (if pos pos 0) "']")))                             
                             (cond 
                               (and want_parent? target_col)
                               target_col
                               target_col
                               (or (-> target_col `querySelector ".juno-highlighted")
                                   target_col.children.0)))))
        (filter_by_text (fn (pos text)
                            (let
                                ((elems (aif (element_for_pos pos true)
                                             it.children
                                             []))
                                 (elem nil)
                                 (num_found 0)
                                 (elem_bank_found [])
                                 (elem_bank_not_found [])
                                 (target_focus nil)
                                 ;;(remove_class "filtered-hidden" elem) (add_class "filtered-hidden" elem)
                                 (clear_it (blank? text)))
                                (if clear_it
                                    (progn
                                        (remove_class "filtered-hidden" elems)
                                        (focus_to (element_for_pos pos))
                                        false)
                                    (progn
                                        (for_each (idx (range elems.length))
                                            (progn
                                                (= elem (prop elems idx))
                                                (if (starts_with? text elem.innerText)
                                                    (push elem_bank_found elem)
                                                    (push elem_bank_not_found elem))))
                                        (cond
                                            (== elem_bank_found.length 0)
                                            false ;; do nothing
                                            (> elem_bank_found.length 0)
                                            (progn
                                                (console.log "found: " elem_bank_found.length)
                                                (for_each (elem elem_bank_found)
                                                    (remove_class "filtered-hidden" elems))
                                                (for_each (elem elem_bank_not_found)
                                                    (add_class "filtered-hidden" elem))
                                                (focus_to elem_bank_found.0)
                                                true)))))))
                                       
                                
        (filter_state {
                      chars: []
                      col_num: nil
                      })
        (show_filter_state (fn ()
                               (progn
                                   (if (> (length filter_state.chars) 0)
                                       (set_style [["opacity" "1"]] filter_span_container)
                                       (set_style [["opacity" "0"]] filter_span_container))
                                   (set_prop filter_span
                                            `innerText (join "" filter_state.chars)))))
        (clear_selector (fn (update?)
                            (progn
                                (console.log "clear_selector: filter_state: " (as_lisp filter_state))
                                (when filter_state.col_num
                                    (filter_by_text filter_state.col_num ""))
                                (set_prop filter_state
                                          `chars []
                                          `col_num nil)
                                (when update?
                                    (show_filter_state)))))
        (pop_from_selector (fn (pos)
                               (progn
                                   (if (== pos filter_state.col_num)
                                       (progn
                                           (pop filter_state.chars)
                                           (filter_by_text filter_state.col_num (join "" filter_state.chars)))
                                       (clear_selector))
                                   (show_filter_state))))
        (push_into_selector (fn (pos k)
                              (progn
                                  (defvar elems nil)
                                  (cond
                                      (eq nil filter_state.col_num)
                                      (progn
                                         (set_prop filter_state
                                                   `col_num
                                                   pos)
                                         (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                             (push filter_state.chars k)))
                                      (eq pos filter_state.col_num)
                                      (progn
                                          (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                                (push filter_state.chars k)))
                                      else
                                      (progn
                                        (push_into_selector pos k)))
                                  ;; update the displayed state of our filter 
                                  (show_filter_state)
                                  )))
                                                      
                                         
                                         
        (handle_keyup (fn (e)
                        (when (and e.srcElement
                                   (get_attribute e.srcElement "ctype"))
                          (let
                              ((elem e.srcElement)
                               (ctype (get_attribute elem "ctype"))
                               (pos (parseInt (get_attribute elem "pos")))
                               (final_pos stack.length))
                            ;(console.log "pos: " pos "press: " e)                           
                            (cond
                              (and (== e.key "ArrowUp")
                                   e.altKey)
                              (focus_to elem.parentElement.children.0)
                              (== e.key "ArrowUp")
                              (focus_to elem.previousElementSibling)
                              (== e.key "ArrowDown")
                              (focus_to elem.nextElementSibling)
                              (and (== e.key "ArrowLeft")
                                   (>= pos 0))
                              (progn
                                  (aif (element_for_pos (- pos 1))
                                   (focus_to it))
                                  (clear_selector true))
                              (== e.key "ArrowRight")
                              (progn
                                (console.log "moving to the right: " (element_for_pos (+ pos 1)))
                                (aif (element_for_pos (+ pos 1))
                                     (focus_to it)
                                     (focus_to (element_for_pos (+ pos 1) true))) ;; didn't get a standard list, it's probably a value of sort..
                                (clear_selector true))
                              (== e.key "Enter")
                              (progn
                                  (handle_event e)
                                  (handle_click e))
                              (== e.key "Backspace")
                              (pop_from_selector pos)
                              (== e.key "Tab")
                              nil
                              (> e.keyCode 47)
                              (progn
                               (push_into_selector pos e.key)
                               (console.log "filter state: " (as_lisp filter_state))))))))
                                                                                                                              
        (handle_click (fn (e)
                          (when (and e.srcElement 
                                     (get_attribute e.srcElement "ctype"))
                              (console.log "handle_click: " e.srcElement)
                              (let
                                  ((elem e.srcElement)
                                   (ctype (get_attribute elem "ctype"))
                                   (pos (get_attribute elem "pos"))
                                   (final_pos stack.length))
                                  (when pos
                                      (= pos (parseInt pos)))
                                  (clear_selector true)
                                  
                                  (console.log "handle_click: pos: " pos "final_pos:" final_pos ctype elem.innerText stack)
                                  (remove_class "juno-highlighted" e.srcElement.parentElement.children)
                                  (add_class "juno-highlighted" e.srcElement)
                                  (cond
                                     (== ctype "nspace")
                                     (progn
                                         (= stack [])
                                         (render_view e.srcElement.innerText)
                                         
                                         ;; next display the first namespace
                                         (= stack [ elem.innerText ])
                                         (render_view))
                                     (and (== ctype "sym")
                                          (== pos final_pos))
                                     (progn
                                         (push stack elem.innerText)
                                         (console.log "STACK is now: " stack)
                                         (render_view))
                                     (< pos final_pos)
                                     (progn
                                         (= stack (-> stack `slice 0 pos))
                                         (push stack elem.innerText)                                         
                                         (console.log "mid stack click: stack now: " (as_lisp stack) "view children:" (length cview.children) (range cview.children.length))
                                         (for_each (child_num (-> (range cview.children.length) `reverse))
                                            (progn
                                               (console.log "child_num: " child_num (prop cview.children child_num) (parseInt (get_attribute (prop cview.children child_num) `pos)))
                                                (when (> (parseInt (get_attribute (prop cview.children child_num) `pos)) (- stack.length 1))
                                                    (-> (prop cview.children child_num) `remove))))
                                         (render_view))                                         
                                     (== e.srcElement.tagName "LI")
                                     (progn
                                      (push stack  elem.innerText)                                 
                                      (render_view)
                                      ))))))
                            
        (cview (div { `style: "" `class: "juno-symbol-browser" }))
        (has_children? (fn (val)
                           (and (is_object? val)
                                (> (length val) 0))))
        (next_possibles (fn ()
                            (let
                               ((path (conj [ "context" "scope" ] (or (rest stack) [])))
                                (ns (first stack))
                                (idx -1)
                                (val nil))
                            (assert ns "No namespace yet - invalid stack")
                            (= val (resolve_path path (-> Environment `get_namespace_handle ns)))
                            (console.log "next_possibles: namespace:" ns path "value: " val)
                            (when options.on_select
                              (options.on_select ns (rest stack)))                            
                            (cond 
                              (is_function? val)
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   (value_to_dom val))
                              (is_array? val)                                                           
                              (for_each (symb (resolve_path path (-> Environment `get_namespace_handle ns)))
                                 (progn
                                     (inc idx)
                                     (li { `tabindex: 0 `ctype: (if (is_object? symb) "sym" (lowercase (subtype symb)))
                                       `pos: stack.length
                                       `title: (subtype symb)
                                       `class: (+ "juno-list-item " (if (has_children? symb) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb)))
                                      `style: li_style } idx)))
                              (is_object? val)                                                    
                              (for_each (symb (sort (pairs (resolve_path path (-> Environment `get_namespace_handle ns)))
                                                    { `key: [ 0 ] }))
                                 (li { `tabindex: 0 `ctype: (if (is_object? symb.1) "sym" (lowercase (subtype symb.1)))
                                       `pos: stack.length
                                       `title: (subtype symb.1)
                                       `class: (+ "juno-list-item " (if (has_children? symb.1) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb.1))) 
                                       `style: li_style } symb.0))
                                                                                   
                              (is_function? options.render_preview)
                              (let
                                  ((elem (options.render_preview)))
                                (if elem
                                  (if (get_attribute elem "ctype")
                                    elem
                                    (progn
                                     (-> elem `setAttribute `ctype "val")
                                     elem))
                                  (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                       "The render_preview function didn't return an element as expected.  Check call.")))
                              
                              (is_string? val)
                              (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   val)
                              
                              else         
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: 100%;" }
                                 (value_to_dom val))))))

        (render_view (fn (ns_name)
                       (progn
                        (console.log "render_view: stack " stack)
                        (if (> stack.length 1)
                          (set_prop path_span
                                    `innerText (+ "[ "(join " " (rest stack )) " ]"))
                          (set_prop path_span
                                    `innerText ""))                                    
                        (clear_selector true)
                        (cond
                          (== stack.length 0) ;; initial state
                          (progn
                           (-> cview `replaceChildren
                              (ol { `pos: 0 }
                               (for_each (ns (sort (namespaces)))
                                         (li {`tabindex: 0
                                              `ctype: "nspace"
                                              `pos: 0
                                              `class: (+ "juno-list-item juno-namespace" (if (== ns ns_name) " juno-highlighted" ""))
                                              `style: li_style
                                              } ns))))
                           (focus_to (element_for_pos 0)))
                          else
                          (progn
                           (defvar next_elem (next_possibles))
                           (cond
                             (is_array? next_elem)
                             (progn
                                 (-> cview `appendChild
                                    (ol { `pos: stack.length  }
                                         next_elem))                                 
                                 (setTimeout (fn () (focus_to (element_for_pos stack.length))) 10))
                             (is_element? next_elem)
                             (progn
                              (-> cview `appendChild                                 
                                  next_elem)
                              (-> next_elem `setAttribute "pos" stack.length)                              
                              (focus_to next_elem)))
                           
                           (set_prop cview `scrollLeft (+ cview.offsetWidth 20)))))))
                                                                                                                               
                          
        (view (control_frame { `id: id  `events: [[ "click" handle_click]
                                                  [ "keyup" handle_keyup ]] }
                             control_status
                             cview))
        (resize (fn ()
                  (progn                           
                   (let
                       ((new_height (- (prop view.parentElement `offsetHeight) 20))
                        (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                     (set_style [[ "width" (+ "" new_width "px") ]
                                 [ "height" (+ "" new_height "px") ]]
                                view)
                     (when options.on_resize
                       (options.on_resize self))))))
        (resize_observer (new ResizeObserver resize))
        (on_focus (fn ()
                   (progn                  
                    (add_class "juno-focused" control_status ))))
        (initialized false)
        (initialize (fn ()
                      (when (and view.parentElement
                                 (not initialized))
                        (= initialized true)                       
                        (-> resize_observer `observe view.parentElement)
                        (render_view (current_namespace))
                        (push stack (current_namespace))
                        (render_view)
                        (defglobal *sbcview* cview))))   ;; TODO: REMOVE 
        
        (to_json (function ()
                           `[symbol_browser ,#options])))

    
     (set_prop options
               `id id
               `name name)                
     (set_prop self
               `view view
               `options options
               `name name
               `type "symbol_browser"              
               `initialize initialize
               `resize resize
               `toJSON to_json
               `on_focus on_focus)
     self))

(defun symbol_chooser (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((ns nil)
                      (target_path target_path)
                      (set_val (fn (selected_ns selected_path)
                                   (progn 
                                      (console.log "ns: " selected_ns selected_path)
                                      (= ns selected_ns )
                                      (= target_path selected_path)
                                      (cond
                                        (blank? ns)
                                        (set_disabled new_symbol_button)
                                        (not (blank? ns))
                                        (progn
                                         (set_enabled new_symbol_button)
                                         (set_prop new_symbol_button
                                                  `innerText (+ (dtext "New Global Value"))))))))
                                            
                      (new_symbol_button (button { `tabindex: 0 `title: (dtext "Create New Entry") `style: "margin-left: 8px; margin-right: 8px;  font-weight: bold; background: var(--highlight-bg-color);" } (dtext "New")))
                      (path_span (span { `tabindex: 0 `title: (dtext "Click to copy path")  `class: "juno-path" } ""))
                      (symbol_ctl (symbol_browser { 
                                                   `additional_elements: [(span { `class: "juno-title" `style: "color:var(--main-color)" } (dtext "Open A Location"))
                                                                          (span { `title: (dtext "Edit Mode") `class: "juno-mode" } (if type type  ""))
                                                                          new_symbol_button
                                                                          ] 
                                                    `on_select: set_val }))
                      (ok_button (button { `class: "juno-primary" `style: "min-width: 100px; margin-right: 20px; margin-left: 20px; float:right; font-weight: bold;" } "OK"))
                      (cancel_button (button { `style: "margin-left: 20px;" }   "Cancel"))
                      (dwin (dialog { `style: "height: 40%; width: 60%; overflow: hidden; padding: 2px;" }                                                                    
                                    (div { `style: "height: calc(100% - 50px);" }
                                         symbol_ctl.view)
                                    (br)
                                    (div { `class: "juno-button-group pure-button-group" `role: "group" }
                                         cancel_button
                                         ok_button))))
                   (attach_event_listener new_symbol_button
                                          `click
                                          (fn (e)
                                            (progn
                                             (aif (request_user_input (+ "" (dtext "Enter the name to be created in") " " ns) `text)
                                                  (progn
                                                   (-> dwin `remove)
                                                   (-> (-> Environment `get_namespace_handle ns)
                                                       `set_global it "")
                                                   (resolve { `namespace: ns `path: [ it ] }))))))
                   (attach_event_listener ok_button
                                          `click
                                          (fn (e)
                                            (do                                              
                                              (resolve {
                                                  `namespace: ns
                                                  `path: target_path
                                                  })
                                              (-> dwin `remove))))                   
                   (attach_event_listener cancel_button
                                          `click
                                          (fn (e)
                                            (do
                                              (-> dwin `remove)
                                              (resolve nil))))
                   (-> juno_container
                       `appendChild dwin)
                   (set_prop symbol_ctl.options
                      `temporary true)
                   (-> symbol_ctl `initialize)
                   (when (is_function? dwin.showModal)
                     (-> dwin `showModal))))))


(defun make_autocompletion_scores (analysis_object sorted_globals)
   (let
      ((result_set [])
       (keywords (try (compiler `[ true ] { `special_operators: true `env: Environment } )
                    (catch Error (e)
                       (progn
                          (log "error on compiler: " e.message)
                          (new Set)))))
       (included (new Set))
       (score 0))
      (for_each (r (sort analysis_object.allocations))
         (progn
            (-> included `add r)
            (cond
               (contains? r analysis_object.globals)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local (shadowed global)" })
               else
               (push result_set
                  { `value: r `score: (inc score) `meta: "local" }))))
      (for_each (r (sort analysis_object.symbols))
         (cond
            (contains? r analysis_object.allocations)
            true ;; we already placed it 
            else
            (progn
               (-> included `add r)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local?" } ))))
      (for_each (r (sort analysis_object.keywords))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "keyword" })))
      (for_each (r (sort analysis_object.globals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "global" })))
      (for_each (r (sort analysis_object.literals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "literal" })))
      (for_each (r (sort (to_array keywords)))
         (if (not (-> included `has r))
             (progn
                (-> included `add r)
                (push result_set
                   { `value: r `score: (inc score) `meta: "keyword" }))))
      
      (for_each (r (or sorted_globals (sort (to_array (all_globals)))))
         (if (not (-> included `has r))
             (push result_set
                { `value: r `score: (inc score) `meta: "global" })))
      result_set)
   {
       `usage: ["analysis_object:object" "sorted_globals:array"]
       `description: (+ "Given the output of process_tree_symbols, returns a result_set to be provided to the Ace autocomplete callback for "
                        "suggestions for autocomplete.")
       `tags: ["editor" "analysis" "autocomplete" "session" "Ace"]
   })

(defun find_root_forms_for_buffer (buffer_text options)
   (let
      ((lines (split_by "\n" buffer_text))
       (ldat nil)
       (lnum -1)
       (running_depth_for_line 0)
       (new_depth nil)
       (last_line_max_col 0)
       (boundaries nil)
       (depth_positions [])
       (current_root_form nil))
      
      (for_each (line lines)
                (progn
                   (inc lnum)
                   (= ldat (analyze_text_line line))
                   
                   (= boundaries (sort (conj (for_each (o ldat.openers)
                                                [o 1 (prop line o) ])
                                             (for_each (c ldat.closers)
                                                [c -1 (prop line c)]))
                                       { `key: [ 0 ] }))
                   (= last_line_max_col (or (last ldat.closers) (length line)))
                   (for_each (t boundaries)
                      (progn
                         (= running_depth_for_line (+ t.1 running_depth_for_line))
                         (cond
                            (and (eq nil current_root_form)
                                    (== running_depth_for_line 1))
                            (progn
                               (= current_root_form {
                                                      `start_row: lnum
                                                      `start_col: t.0
                                                      `end_row: nil
                                                      `end_col: nil
                                                      }))
                            (and current_root_form
                                 (== running_depth_for_line 0))
                            (progn
                               (set_prop current_root_form
                                  `end_row lnum
                                  `end_col t.0)
                               (push depth_positions current_root_form)
                               (= current_root_form nil)))))))
      (if (and options.flexibility
               current_root_form
               (> running_depth_for_line 0)) ;; most likely unclosed form
          (progn
             (set_prop current_root_form
                `end_row lnum
                `end_col last_line_max_col)
             (push depth_positions current_root_form)
             (= current_root_form nil)))
      depth_positions)
   {
     description: (+ "Given a text value as a string and an optional options object, returns an array of objects, "
                      "each representing the starting and ending positions of each found form.  The returned objects "
                      "have the keys: start_row, start_col, end_row, and end_col, which will be numeric offsets "
                      "from line 0 and column 0 respectively.<br>"
                      "If an options object is given with the key flexibility set to true, then if the final "
                      "form is incomplete, will return the start to final part of the end form.")
     usage: ["text_buffer:string" "options:object"]
     tags: ["forms" "parsing" "syntax" "selection" ]
     })

(defun get_root_form_for_position (buffer_text row column flexibility_mode)
   (let
      ((root_forms (find_root_forms_for_buffer buffer_text { flexibility: (if flexibility_mode true false) } ))
       (target nil))
      (for_each (form (or root_forms []))
         (progn
            (when (and (>= row form.start_row)
                       (<= row form.end_row))
               (cond 
                  (or (and (== form.end_row form.start_row)
                           (>= column form.start_col)
                           (<= column form.end_col))
                  
                      (> (- form.end_row form.start_row) 0))
                  (progn
                     (= target form)
                     (break))))))
      target)
   {
     description: (+ "Given a text buffer, a row number (>= 0) and a column number (>= 0), returns an object that has the "
                     "position values for the enclosing form to a depth of 0.  The object returned has " 
                     "the following layout: <br>"
                     "{ start_row:int end_row:int start_col:int end_col:int }<br>"
                     "All values start at offset 0.")
     tags: ["form" "position" "selection" "text" "lisp"]
     usage: ["buffer_text:string" "row:int" "column:int" "flexibility_mode:?boolean"]
   })


(defun floating_div (contents options)
   (let
      ((close_button (button { `title: (dtext "Close") } "X"))
       (move_state nil)
       (expander_elem (div { `style: "position: absolute; right: 0px; bottom: 0px; width: 15px; height: 15px; cursor: nwse-resize; background: transparent;" }
                           ""))
       (full_block (div { `style: "z-index: 8; width: 100%; height: 100%; position: absolute; top:0px; left: 0px;" }))
       (dims nil)
       (top (cond
               (is_string? options.position.top)
               options.position.top
               (is_number? options.position.top)
               (+ "" options.position.top "px")
               else
               (+ "" (+ 5 (random_int 10)) "px; ")))
       (left (cond
               (is_string? options.position.left)
               options.position.left
               (is_number? options.position.left)
               (+ "" options.position.left "px;")
               else
               (+ "" (+ 45 (random_int 10)) "%; ")))
       (resize_mode false)
       (max_dims {
                  `width: 0
                  `height: 0
                  })
       (body_element nil)
       (block_on (fn (e)
                    (progn
                       (= dims (-> frame `getBoundingClientRect))
                       (= body_element (get_by_id "body"))
                       (= max_dims {
                                     `width: (prop body_element `offsetWidth)
                                     `height: (prop body_element `offsetHeight) })
                       (-> body_element `appendChild full_block)
                       (= move_state {
                                       mx: e.pageX
                                       my: e.pageY
                                       fx: dims.right
                                       fy: dims.top
                                       w: dims.width
                                       h: dims.height
                                       }))))
       (control_bar (div { `class: "juno-buffer-bar" style: "cursor: grab;" }
                 close_button
                 (or options.title "")))
       (end_drag (fn (e)
                    (progn
                       (= move_state nil)
                       (= resize_mode false)
                       (if (is_function? contents.resize)
                           (-> contents `resize))
                       (-> full_block `remove))))       
       (handle_drag (fn (e)
                      (when (and move_state
                                 (== e.buttons 1))
                         (if resize_mode
                            (set_style [["width"  (+ "" (Math.max 300 (Math.min (- max_dims.width 30) (+ dims.width (- e.pageX move_state.mx)))) "px")]
                                        ["height" (+ "" (Math.max 30 (Math.min (- max_dims.height 30) (+ dims.height (- e.pageY move_state.my)))) "px")]]
                                       frame)
                            (set_style [["top"  (+ "" (Math.max 0 (Math.min (- max_dims.height 30) (+ dims.top (- e.pageY move_state.my)))) "px") ]
                                        ["left" (+ "" (Math.max 0 (Math.min (- max_dims.width 30) (+ dims.left (- e.pageX move_state.mx)))) "px") ]]
                                       frame)))))
                                   
       (frame (div { class: "juno-floating-container" 
                     style: (+ "left: " left
                               "top: " top
                                (if (is_string? options.style)
                                    (+ "" options.style ";")
                                    ""))
                                  }
               (control_frame {}
                control_bar
                (cond
                   (and (is_object? contents)
                        contents.view)
                   contents.view
                   (is_element? contents)
                   contents
                   else
                   (value_to_dom contents)))
               expander_elem)))
      
      (attach_event_listener close_button
         `click
         (fn (v)
            (progn
               (when options.on_close
                  (options.on_close))
               (-> frame `remove))))
      
      (attach_event_listener control_bar
         `mousedown
         (fn (e)
            (block_on e)))
      (attach_event_listener expander_elem
         `mousedown
         (fn (e)
            (progn
               (= resize_mode true)
               (block_on e))))
      
      
      (attach_event_listener full_block
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mousemove
                             handle_drag)
      (attach_event_listener full_block
                             `mousemove
                             handle_drag)
      (-> (get_by_id "body") `appendChild frame)
      ;; if we have a control, initialize it if it needs it since it is 
      ;; now mounted on the DOM
      (when contents.initialize
         (-> contents `initialize))
      
      true))

(defun monitor_control_tree ()
   (let
       ((view nil)
        (title_span (span { } "Control Structure"))       
        (update_timer nil))
     (if (get_by_id `control_tree_monitor)
       (notify "Control Tree Already Showing")
       (progn
        (setTimeout (fn ()
                      (set_prop title_span
                                `innerText
                                (dtext "Click to highlight a control")))
                    4000)
        (= view (div { `id: `control_tree_monitor  style: "background: var(--control-bg-color); color: var(--control-color);"}
                     (render_control_tree $root_controls)))
        (attach_event_listener view
                               `click
                               (fn (e)
                                 (let
                                     ((id (-> e.srcElement `getAttribute "control_id"))
                                      (body_element (get_by_id "body"))
                                      (dims nil)
                                      (highlighter nil)
                                      (control (if id (get_control_by_id id))))
                                   (when control
                                     (when control.view
                                       (= dims (-> control.view `getBoundingClientRect))
                                       (console.log "control dims: " control.name dims)
                                       (-> body_element `appendChild
                                           (= highlighter (div { `id: "highlighter" `class: "identification" `style: (+ "z-index: 7; position: absolute; top: " dims.top "px; left: " dims.left "px; width: " (- dims.width 5) "px; height: " (- dims.height 5) "px; border: 3px dashed red;") }
                                                           "")))
                                       (setTimeout (fn ()
                                                     (do 
                                                        (aif (get_by_id "highlighter")
                                                             (-> it `remove))
                                                        (-> highlighter `remove)))
                                                   1000))))))
                                   
        (= update_timer (setInterval (fn ()
                                     (progn                                        
                                        (-> view `replaceChildren (render_control_tree $root_controls))))
                                     1000))
        (floating_div view
                      {  `title: title_span
                         `on_close: (fn ()
                                     (progn
                                      (clearInterval update_timer)))
                       })))))

  

(defun handle_lisp_format_event (val editor)
  (progn    
    (when (and (== (- val.end.row val.start.row) 1)
              (== val.action "insert"))     
       (defvar indent_string (format_lisp_line val.end.row (function (rnum) 
                                                                     (-> editor.session `getLine rnum))))
       (when indent_string
        (-> editor.session `indentRows val.end.row val.end.row indent_string)))))

(defun_sync indent_editor_line (editor row_number options)
  (if (is_number? row_number)
    (let
        ((line (-> editor.session `getLine row_number))
         (orig_line (clone line))
         (indent_string (format_lisp_line row_number
                                          (or options.get_row
                                              (function (rnum) 
                                                        (-> editor.session `getLine rnum))))))
      (console.log "indent_row: " row_number "indent_string: " indent_string line)
      (if indent_string
        (progn
         (setq line (+ "" indent_string (trim line)))
         (console.log "line at " row_number " to be replaced with: " (JSON.stringify line))
         (if options.apply
           (progn
            (-> editor.selection `clearSelection)
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `remove (-> editor.selection `getRange))
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `replace (-> editor.selection `getRange) line)
            (console.log "indent_editor_line: get_line: " (JSON.stringify (-> editor.session `getLine row_number)))
            (-> editor.selection `clearSelection)
            true)
           line))        
        line))
    (throw EvalError "invalid row_number provided to indent_row")))

(defun_sync indent_editor_selection (editor)
  (let
      ((start nil)
       (end nil)
       (selected_range (clone (-> editor.selection `getRange))))
    
    (= start selected_range.start.row)
    (= end selected_range.end.row)
    (console.log "tab: start: selected_range: " (JSON.stringify selected_range))
    (-> editor.selection `clearSelection)
    (-> editor.selection `setSelectionAnchor start 0)
    (-> editor.selection `selectTo end 0)
    (-> editor.selection `selectLineEnd)
    (console.log "tab: start: fully selected_range: " (-> editor.selection `getRange))                                                   
    (defvar lines (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
                            (-> editor.session `getLine row_number)))
    (console.log "tab: lines: pre-change: " (clone lines))
    
    (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
              (progn
               (console.log "tab: [start]: [ " selected_range.start.row selected_range.end.row " ] analyzing row: " row_number ": " (JSON.stringify (prop lines (- row_number start))))
               (set_prop lines
                         (- row_number start)
                         (indent_editor_line editor row_number
                                     { get_row: (function (rnum)
                                                          (progn
                                                           (console.log "get_row: rnum: " rnum " relative: " (- rnum start))
                                                           (cond
                                                             (and (>= rnum start)
                                                                  (< rnum end))
                                                             (prop lines
                                                                   (- rnum start))
                                                             else
                                                             (-> editor.session `getLine rnum)))) ;; not impacted by the change
                                      } ))))
    
    (console.log "tab: adjusted lines: " lines)
    (console.log "tab:     lines joined: " (join "\n" lines))
    (-> editor.session `replace (-> editor.selection `getRange) (join "\n" lines))
    (-> editor.selection `selectLineEnd)
    ;(-> editor.selection `setRange selected_range)
    (console.log "tab: reselected fixed: " (-> editor `getCopyText))))


(defun_sync select_to_current_form (editor pos)
  (if editor
    (let
        ((rng (-> editor `getSelectionRange))
         (already_selected? (if (and (== rng.start.row rng.end.row)
                                     (== rng.start.column rng.end.column))
                                false
                                true))
         (cpos (or pos 
                   (if already_selected?
                      (progn
                         (-> editor `navigateTo rng.start.row rng.start.column)
                         (-> editor `getCursorPosition))
                      (-> editor `getCursorPosition)))))
      (when cpos
        (= rng (find_last_paren editor cpos))
        (when rng
          (-> editor.selection `clearSelection)
          (-> editor.selection `setRange rng)))
      rng)
    nil)
  {
   description: (+ "Given an editor and an optional position { row column }, if possible, "
                   "selects the innermost current form (expression) in the editor and "
                   "returns the range.")
   usage: ["editor:object" "pos:?object"]
   tags: ["editor" "selection" "form" "lisp" "editing" ]
   })
          
           
(defun show_editor_keybindings (editor_control)
   (let
      ((binding_row (fn (keysequence binding)
                       (tr
                          (td keysequence)
                          (td (or binding.description
                                  (from_key binding.name)))))))
      (table { `style: "width: 100%" }
             (thead
                (tr
                   (th "Key Sequence")
                   (th "Description")))
             (tbody
                (for_each (bindpair (sort (pairs (editor_key_bindings editor_control.editor))
                                          { `key: [`0] }))
                   (destructuring_bind (keysequence binding)
                      bindpair
                      (cond
                         (is_array? binding)
                         (for_each (bindval binding)
                            (binding_row keysequence bindval))
                         (is_object? binding)
                         (binding_row keysequence binding)
                         else
                         [])))))))

(defun show_key_bindings ()
   (let
      ((platform (get_operating_platform))
       (default_editor_keys (if (-> Environment `get_global "*orig_key_bindings*" nil)
                                (reduce (entry (values (-> Environment `get_global "*orig_key_bindings*")))
                                   (when (prop entry.bindKey platform)
                                      (to_object
                                         [[`name entry.name]
                                          [`description entry.description]
                                          [ (+ "" platform) (prop entry.bindKey platform) ]])))))
       
                                       
       (categories (reduce (k (keys *key_bindings* ))
                      (unless (== k "active")
                         k)))
       (td_style (function () 
                    { `style: "vertical-align:top; padding: 5px; border-bottom: 1px solid var(--main-accent-line);" } ))
       (table_values  (sort
                           (conj (-> (for_each (category categories)
                                        (for_each (binding (pairs (resolve_path [ category ] *key_bindings*)))
                                           (destructuring_bind (name entry)
                                              binding
                                              [ (prop entry platform)
                                               (from_key name)
                                               (from_key category)
                                               (or (prop entry `description)
                                                   "No Description") ] )))
                                     `flat 1)
                                 
                                 (for_each (binding default_editor_keys)
                                    [(prop binding platform)
                                     (from_key binding.name)
                                     "Editor"
                                     (or (prop binding `description)
                                         "No Description")]))
                           { `key: [`0] }
                            )))
      ;(log "Table values: " table_values)
      (table { `style: "width: 100%" }
         (thead
            (tr { `style: "" }
               (th { `style: "padding: 5px;" } "Key Binding")
               (th { `style: "padding: 5px;" } "Command")
               (th { `style: "padding: 5px;" } "Scope")
               (th { `style: "padding: 5px;" } "Description")))
         (tbody
            (for_each (row table_values)
               (tr { `style: "padding: 5px; " }
                  (td (td_style) row.0)
                  (td (td_style) row.1)
                  (td (td_style) row.2)
                  (td (td_style) row.3))))))
   {
     `description: "Returns a table DOM element of the current key bindings."
     `usage: []
     `tags: ["help" "keys" "bindings" "display" ]
     })

(defun_sync select_root_form (editor pos)
   (if (and (is_object? editor)
            (is_object? pos))
       (let
          ((last_selection nil)
           (idx 0)
           (current_selection nil))
          ;; start with the current position
          (= current_selection (find_last_paren editor pos))
          (while (and (< idx 1000)
                      current_selection
                      (or (eq nil last_selection)
                          (not (and (== last_selection.start.column current_selection.start.column)
                                    (== last_selection.start.row current_selection.start.row)
                                    (== last_selection.end.column current_selection.end.column)
                                    (== last_selection.end.row current_selection.end.row)))))
             (progn
                (inc idx)
                (= last_selection current_selection)
                (= current_selection (find_last_paren editor current_selection.start))
                ))
          
          (aif current_selection
             {
               `start_row: it.start.row
               `start_col: it.start.column
               `end_row: it.end.row
               `end_col: it.end.column
               })
             ))
   {
     `usage: ["editor:object" "pos:object"]
     `description: "Given an editor and a position, returns the determined root form for the position."
     `tags: ["selection" "editor" "root" "form" "position"]
     })

(defun select_to_root_form (editor pos)
   (if editor
       (let
          ((cpos (-> editor `getCursorPosition))
           (pos (if pos
                    (select_root_form editor pos)
                     (select_root_form editor cpos))))
          (when pos
             (-> editor.selection `clearSelection)
             (-> editor.selection `setSelectionAnchor pos.start_row pos.start_col)
             (-> editor.selection `selectTo pos.end_row (+ pos.end_col 1))
             true))
       (throw TypeError "editor must be provided to select_to_root_form"))
   {
       description: (+ "Given an editor and an optional position, will select the complete form (to a depth of 0) if possible. "
                        "If given a position object with a row and column value, the function will use that instead.  If "
                        "succesful, the value true will be returned.  If no editor is provided, the function will throw a "
                        "TypeError.")
       usage: ["editor:object" "pos:?object"]
       tags: ["editor" "selection" "form" "lisp" "editing"]
   })


(defun get_juno_autocompletions (editor session pos prefix callback sorted_symbols)
   (let
      ((root_form (select_root_form editor pos))
       (collect_error (fn (e)
                         true))
       (text_data (+ "" (-> editor.session `getTextRange (new ace.Range root_form.start_row root_form.start_col root_form.end_row root_form.end_col)) ")"))
       (tokens (reader text_data { `suppress_throw_on_error: true on_error: collect_error  } )))
      (console.log "get_juno_autocompletions: tokens ->: " tokens) 
      (= tokens (make_autocompletion_scores (process_tree_symbols tokens prefix) sorted_symbols))
      (console.log "get_juno_autocompletions: tokens <-: " tokens) 
      (callback null tokens))
   {
       `usage: ["editor:object" "session:object" "pos:object" "prefix:text" "callback:fn" "sorted_symbols:array"]
       `description: "Internally used by the editor for autocompletion."
       `tags: ["ace" "editor" "autocomplete" ]
   })  
 
(defun clone_edit_session (session)
   (let
      ((s (new ace.EditSession (-> session `getDocument)
                               (-> session `getMode)))
       (undoManager (-> session `getUndoManager)))
      (-> s `setUndoManager undoManager)
      (-> s `setTabSize (-> session `getTabSize))
      (-> s `setUseSoftTabs (-> session `getUseSoftTabs))
      (-> s `setOverwrite (-> session `getOverwrite))
      (-> s `setBreakpoints (-> session `getBreakpoints))
      (-> s `setUseWrapMode (-> session `getUseWrapMode))
      (-> s `setUseWorker (-> session `getUseWorker))
      (-> s `setWrapLimitRange session.$wrapLimitRange.min session.$wrapLimitRange.max)
      (set_prop s session.$foldData
         (-> session `$cloneFoldData))
      s))

(defun eval_selected_text_in_place (ctl options)
   (progc
      (let
         ((text nil)
          (pos nil)
          (editor (cond
                      (== ctl.type "text_editor")
                      ctl.editor
                      else
                      (throw TypeError "eval_selected_text_in_place: no text editor for provided control")))
          (selection nil)  ;; range to replace with results
          (evaluator nil)
          (result nil))
         (= pos (-> ctl `get_selection))
         (if (and (== pos.start.row pos.end.row)
                  (== pos.start.column pos.end.column))
             (select_to_current_form ctl.editor))
         ;; we should have an actual selection now if we didn't...
         (= selection (-> ctl `get_selection))
         (= text (-> ctl `get_selected_text))
         (if (blank? text)
             (progn 
                (-> ctl `display_context_message (dtext "Nothing to evaluate at the cursor position")))
             (progn
                (= evaluator
                   (cond
                      (is_function? ctl.get_evaluator)
                      (-> ctl `get_evaluator)
                      options.evaluator_id
                      (progn
                         (aif (prop (get_control_by_id options.evaluator_id)
                                    `evaluate)
                              it
                              nil))))
                (if (is_function? evaluator)
                    (progn
                       (alert_on_error (dtext "Evaluation Error")
                                       (= result (evaluator text false true true)))
                       (if (and (eq nil result)
                                (or options.discard_nil_values
                                    (== "discard" (request_user_choice 
                                                     (+ (dtext "The evaluation result is")
                                                        " "
                                                        (as_lisp result)
                                                        ".  "
                                                        (dtext "Insert or discard the result?"))
                                                     [[(dtext "Insert") "ok"] 
                                                      [(dtext "Discard") "discard"]]
                                                     {
                                                       `no_cancel_button: true
                                                       }))))
                           nil
                           (progn
                              (= result
                                 (cond
                                    (is_object? result)
                                    (if options.as_json
                                       (JSON.stringify result nil 2)
                                       (+ "" (pretty_print (as_lisp result))))
                                    (is_string? result)
                                    result
                                    else
                                    (+ "" (pretty_print (as_lisp result)))))
                              (try
                                 (progn
                                    (if options.append
                                       (progn
                                          (-> editor.selection `clearSelection)
                                          (-> editor `navigateTo pos.end.row pos.end.column)
                                          (set_prop pos.start
                                             `row pos.end.row
                                             `column pos.end.column)
                                          (-> (-> editor `getSession) `replace pos result))
                                       (-> (-> editor `getSession) `replace selection result)))
                                 (catch Error (e)
                                    (progn
                                       (-> (-> editor `getSession) `replace selection text)
                                       (-> ctl `display_context_message (+ "Error on replace: " e.message))
                                       (log (+ (dtext "Couldn't replace text in editor") ":" (prop ctl.options `name) ": " e.message))
                                       (log e)))))))
                    (alert_box (dtext "Evaluation Error")
                               (+ (dtext "No evaluator found for the control")
                                  " "
                                  ctl.options.name)))))))
   {
     description: (+ "Given a control with an editor, the selected text is evaluated " 
                     "using the editors evaluator.  The evaluated selection is replaced with the result."  
                     "<br>#### Options<br>"
                     "append:boolean - If true, the selected value isn't replaced but the result of the "
                     "evaluation is placed into the editor at the cursor's position.<br>"
                     "discard_nil_values:boolean - If true, a nil value (undefined or nil) will not be "
                     "placed into the editor's text.  Otherwise, if a nil value is returned the user "
                     "will be prompted to place the nil result in the buffer, or discard it.<br>"
                     "evaluator:function - An optional 'evaluator' function can be passed to be used " 
                     "as the evaluator instead of the controls default evaluator.<br>"
                     "as_json:boolean - If true, the result will be placed as formatted JSON into the "
                     "editor.  The default is to place the result in formatted Juno notation.<br>")
                     
     usage: ["control:object" "options:?object"]
     tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })

(defun evaluate_and_replace_at_point (options)
   (let
      ((ctl *last_focus*))
      (cond
         (== ctl.type "text_editor")
         (progn
            (focus_to_editor ctl)
            (eval_selected_text_in_place ctl
                                         (+ {} 
                                            (if (not (eq nil options.discard_nil_values))
                                                { discard_nil_values: options.discard_nil_values }
                                                { discard_nil_values: true })
                                            (if options.append
                                                { append: true }
                                                {}))))))
   {
       `description: (+ "Using the control in *last_focus*, calls the eval_selected_text_in_place function "
                        "with the provided options.  The result of the evaluation will be placed into "
                        "the focused editor, either as replaceement text or appended text.<br>"
                        "#### Options<br>"
                        "discard_nil_values:boolean - If true any nil values will not be placed into "
                        "the editor.  If false, the user will be prompted to place nil values into "
                        "the text.  The default is true.<br>"
                        "append:boolean - If true, the result of the evaluation will be appended into "
                        "the editor at the point of the cursor, or if text is selected in the editor, "
                        "after the selection.<br>")
       `usage: ["options:object"]
       `tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })
(defun set_scroll_speed (ctl value)
   (if ctl.editor
      (progn
         (-> ctl.editor `setScrollSpeed (clamp value 1 10))
         (set_prop ctl.options
            `scroll_speed
            (clamp value 1 10))
         (-> ctl.editor `getScrollSpeed))
      (progn
         (log "set_scroll_speed: no editor for control: " ctl.name)))

   {
       description: (+ "Sets the scroll speed for the editor by taking a control with an " 
                       "editor and a value between 1 and 10, where 10 will scroll the fastest "
                       "and 1 will be the slowest scroll value.  Default speed is 5.  " 
                       "Return value will be the new scroll speed value.")
       usage: ["control:object" "value:number"]
       tags: ["editor" "scroll" "speed"]
   })

(defmacro defcontrol (name control_args allocations control_options)
   (let
      ((declared_allocations (each allocations first))
       (required_allocations [(quote render)])
       (user_allocations allocations)
       (cname (-> name `substr 2))
       (meta { `description: (or control_options.description "No description")
               `tags: (or control_options.tags [`control `ui `DOM ])
               `usage: (if (is_array? control_options.usage)
                           (conj control_options.usage
                                 [ "options:object" ])
                           nil) })
       (args (progn
                (cond
                   (is_array? control_args)
                   (conj control_args [ (quote options) ])
                   else
                   (throw SyntaxError (+ "defcontrol: " cname ": missing/malformed control arguments - check syntax")))))
       (control_options (if (is_object? control_options)
                            control_options
                            {}))
       (control_bar? (if control_options.control_bar
                        true)))            
       (assert name "control name is required: check syntax for defcontrol")
       (if (< (length (reduce (d declared_allocations)
                         (contains? d required_allocations)))
              (length required_allocations))
           (throw SyntaxError (+ "defcontrol: " cname " missing required declarations: must have render")))
       (cond
          (contains? (quote id) declared_allocations)
          (throw SyntaxError (+ "defcontrol: " cname " cannot declare id - to pass a custom ID to the control, pass id in options when instantiating the control."))
          (contains? (quote initialize) declared_allocations)
          (throw SyntaxError (+ "defcontrol: " cname " cannot declare initialize - use on_initialize")))
       
  ;; ok, now create the form to be returned..
      `(defun ,#name ,#args
          (let
             ((self {})
              (options (or options {}))
              (name (compute_name_for_control (or options.name ,#(from_key (desym_ref name)))))
              (id (or options.id 
                      (generate_id ,#name)))
              (initialized false)
              (title_span (span { `class: "juno-title" } name))
              (set_title (fn (title_text)
                            (set_prop title_span
                               `innerText
                               title_text)))
              (command_button (commands_button id))
              (_parent_view nil)
              (check_observer (fn ()
                         (when (and _parent_view
                                    (not (== view.parentElement _parent_view)))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= _parent_view view.parentElement))))
              (content_view (div { `style: "overflow: hidden; height: 100%; width: 100%; background: var(--control-bg-color); color: var(--control-color);" } "uninitialized.."))
              (resize (fn ()
                         (when view.parentElement
                            (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               (check_observer)
                               (when options.on_resize
                                  (options.on_resize self))
                               ,#(if control_options.render_on_resize
                                     `(do_render)
                                     true)
                               ,#(if (contains? (quote on_resize) declared_allocations)
                                     `(on_resize self)
                                     [])
                               true))))
              ,@user_allocations
              (control_status (if ,#control_bar?
                                  (div { `class: "juno-buffer-bar" }
                                   command_button
                                   (cond 
                                      (is_array? options.additional_elements)
                                      options.additional_elements
                                      else
                                      title_span)
                                   ,#(if (contains? (quote control_bar_elements) declared_allocations)
                                         (progn
                                            (prop (prop allocations (index_of (quote control_bar_elements) declared_allocations)) 1))
                                         []))
                                  nil))
              (do_render (fn ()
                            (let
                               ((new_view (render self)))
                               (if (and new_view
                                        (not (== content_view new_view)))
                                   (-> content_view `replaceChildren new_view))
                               (if _on_render
                                   (_on_render self)))))
              (resize_observer (new ResizeObserver resize))
              (view (control_frame (to_object
                                       [[`id id]
                                        [ `style ,#(or control_options.frame_style nil)]
                                        [`events ,#control_options.events ]])
                     (if ,#control_bar?
                         control_status
                         [])
                     content_view))
              
              (_on_render (fn ()
                             ,#(if (contains? (quote on_render) declared_allocations)
                                `(on_render self)
                                nil)))
                             
              (_on_focus (fn ()                           
                           (progn
                            ,#(if control_bar?
                                `(add_class "juno-focused" control_status)
                                `[])
                            ,#(if (contains? (quote on_focus) declared_allocations)
                                `(on_focus self)))))
                                  ,
              (_on_destroy (fn ()                                     
                             (progn
                              ,#(if (contains? (quote on_destroy) declared_allocations)
                                  `(on_destroy self)
                                  `true))))
              
              (_to_json (function ()
                           (progn
                              ,#(if (contains? (quote to_json) declared_allocations)
                                    `(to_json)
                                    `[(quote ,#name) ,@control_args options]))))
              (initialize (function ()
                             (progn
                                (when (and view.parentElement
                                           (not initialized))
                                   (= initialized true)
                                   (= _parent_view view.parentElement)
                                   (-> resize_observer `observe view.parentElement)                                   
                                   ,#(if (contains? (quote on_initialize) declared_allocations)
                                         `(on_initialize self)
                                         true)
                                   (do_render))))))
             (set_prop options
                `id id
                `name name)
             ,@(when (is_array? control_options.expose)
                  (for_each (method_set control_options.expose)
                     (destructuring_bind (method_name method_reference)
                        method_set
                     `(set_prop self
                         ,#method_name ,#method_reference))))
             ,#(if (contains? (quote menu_items) declared_allocations)
                   `(set_prop self
                       `menu_items menu_items)
                   [])
             ,#(if control_bar?
                  `(set_prop self
                      `show_control_bar 
                      (fn (state)
                         (progn
                            (if state
                               (remove_class "juno-display-none" control_status)
                               (add_class "juno-display-none" control_status))
                            (resize))))
                  `[])
             ;; finally set the required self options
             (set_prop self
                `options options
                `name name
                `type ,#(desym_ref name)
                `view view
                `resize resize                
                `initialize initialize
                `toJSON _to_json
                `on_destroy _on_destroy
                `on_focus _on_focus)
             ;; and return the self
             self)
          ,#meta))
   {
       `description: (+ "The macro defcontrol creates a function in the current namespace that implements the specified "
                        "control features passed to the macro.  The macro handles most of the boiler plate for a basic "
                        "control, combining the passed allocations and options to produce a standardized control "
                        "constructor.  The macro is similar in shape to a defun+let form with some differences.<br><br>"
                        "Like the defun macro, the first argument provides the name of the control that it will be used " 
                        "to construct the name and type of the control.  Also similar to defun, the second argument is "
                        "an array containing any arguments for the control.  Note that, mandatorily, an options argument "
                        "will be appended as the last argument of the argument list, so an empty array passed will "
                        "cause the control only to have an options argument.<br><br>"
                        "The next argument is a series of allocation forms that are integrated into a let allocation "
                        "structure, and so should be in the same form as the allocation block of the let operator.  For "
                        "example, ((render (fn () (div { } \"My View\")))) would meet the minimal requirement for a "
                        "control to be constructed.  The caller of this macro can have as many allocation forms as needed "
                        "to implement the required behavior of the emitted control.  To note that there are "
                        "symbols that made available to these provided forms in the evaluation context of the form that "
                        "can be referenced and used by the user provided forms:<br>"
                        "self:object - The interface object returned.<br>"
                        "content_view:Element - The control's view (not including the control_bar.  Effectively the contents of "
                        "the control view.<br>"
                        "do_render:function - Calls the (render) function provided to the macro.  User code can call this "
                        "function when a redraw is required.<br>"
                        "initialized:boolean - This value is true if the function is initialized or false if it hasn't " 
                        "yet been.<br>"
                        "options:object - The options object passed to the control on instantiation.<br>"
                        "<br><br>"
                        "There are multiple functions that are called upon certain events, which allow the caller to build "
                        "customized behavior and hook into the system when needed.  These functions are specified in the "
                        "allocation forms provided to the macro and are all optional except for render:<br>"
                        "render:function - This function returns the DOM structure assigned to content_view and is what is "
                        "drawn in the control's content container.  If the function returns nil, nothing is done.  Can be "
                        "used in conjunction with the on_render below, which acts on the already drawn view.<br>"
                        "on_focus:function - When a focusing event occurs to the control, this function is called with the "
                        "self object of the macro.<br>"
                        "on_render:function - If this function is specified it will act as the render function so as to "
                        "manipulate an already built view, via the content_view in scope symbol, which is the contents of the "
                        "controls view.<br>"
                        "on_resize:function - A resize function to invoke if a forced resize is required.<br>"
                        "control_bar_elements:array - If the control is specified with the control_bar control_options set to "
                        "true, the Elements in this array will be placed into the control bar after any runtime additional_elements "
                        "provided to the options object.<br>"
                        "menu_items:function - A function that is called on demand that should return an array containing "
                        "pairs of [menu_text menu_function] that implement any command functionality for the menu.<br>"
                        "on_destroy:function - When the control receives a destroy call, this user provided function will be "
                        "called with the self object.<br>"
                        "on_initialize:function - Upon initialization, this function will be called with the self function. It "
                        "should be expected that the initialization should be called only once for a control lifespan.<br>"
                        "to_json:function - This synchronous function call can be used to provide a customization hook "
                        "for the control.  The return value must be a structure that can be serialized into JSON form.<br><br>"
                        "The final object, control_options is meta data and other flags for the macro:<br>"
                        "expose:array - An array of pairs that specify [ `function_handle function_to_call ] that are placed "
                        "on the self interface and provide the API for the control.  In order for a resource in the control "
                        "scope to be accessed, it must be specified in this option, otherwise the function remains effectively "
                        "private to the control.<br>"
                        "usage:array - The argument specification for the macro"
                        "description:string - The description of the control that is registered in the Environment.<br>"
                        "control_bar:boolean - If a control bar is to be displayed on the top of the control, set this to "
                        "true.<br>"
                        "frame_style:string - Any custom style attributes to apply to the control frame.  These "
                        "should be formatted in the CSS manner: eg.  \"overflow: hidden;\"")
       `usage: ["name:symbol" "control_arguments:array" "allocations:array" "control_options:object"]
       `tags: ["control" "define" "controls" "ui"]
   })






(defun recalc_names_for_path (path_to_value)
   (let
      ((ctls (get_editors_for_path path_to_value)))
      (for_each (ctl ctls)
         (when ctl.recalculate_name
            (-> ctl `recalculate_name)))))

;; manages the` destruction of editors that are interested in the same path
;; one of them is the primary, the rest of them will be linked to their ids







(defun get_primary_editor_in_group (controls)
   (let
      ((primaries (reduce (editor (or controls []))
                      (when (not (-> editor `get_linked))
                         editor))))
      (first primaries)))

(defun get_editors_for_filename (filename)
   (when (is_string? filename)
      (reduce (control (current_controls))
         (when (and control
                    control.editor
                    control.options.filename
                    (== control.options.filename filename))
            control)))
   {
   `description: (+ "Given a filename, this function returns an array of all controls that have "
                    "the same filename as specified in the controls options object. ")
   `usage: ["filename:string"]
   `tags: ["groups" "control" "select" "editor" "filename" "file"]
     })
   
(defun get_controls_for_group (group_name)
   (when (is_string? group_name)
      (reduce (control (current_controls))
         (when (and control
                    (is_function? control.group_name)
                    (== (-> control `group_name) group_name))
            control)))
   {
     `description: (+ "Given a group_name, this function returns an array of all controls that have "
                      "the same group_name as returned by group_name function of the control. ")
     `usage: ["group_name:string"]
     `tags: ["groups" "control" "select" "editor"]
     })
   

(defun rename_editor_group (path)
   (try 
      (let
         ((editors (get_editors_for_path path))
          (primary_id nil)
          (primary (reduce (editor (or editors []))
                      (when (not (-> editor `get_linked))
                         editor))))
         (assert (not (> primary.length 1)) "rename_editor_group: multiple primary editors. This is a bug.")
         (= primary (first primary))  ;; take the primary editor or nil 
         (cond 
            (== editors.length 0)
            true ;; nothing for us to do
            (== editors.length 1)
            (progn
               (-> (first editors) `set_unlinked)
               (-> (first editors) `set_name (-> (first editors) `group_name) true))
            else
            (progn
               (unless primary                ;; unless we already have a primary...
                  (= primary (take editors))) ;; take the first editor and make it the primary
               (= primary_id primary.options.id)
               (-> primary `set_name (-> primary `group_name) true)
               (-> primary `set_unlinked)
               (for_each (editor editors)
                  (when (not (== editor primary))
                     (-> editor `set_linked primary.options.id)
                     (-> editor `set_name (-> primary `group_name)))))))
      (catch Error (e)
         (log "rename_editor_group: error: " e.message))))

(defun clone_text_editor_control (editor_control)
   (let
      ((id editor_control.options.id)
       (new_name (if editor_control.group_name
                     (-> editor_control `group_name))))
      (declare (function text_editor)
               (global text_editor))
      (assert new_name "clone_text_editor_control: unable to get group name of the editor to clone")
      (when (and editor_control.editor id)
         (alert_on_error "Unable to clone the editor"
                         (text_editor (+ {} ;; start options 
                                         editor_control.options ;; take existing options..
                                         { `id: (gen_id "text_editor")
                                           `clone_with_editor_id: id }))))))

(defun select_evaluator ()
  (let
      ((idx -1)
       (dups (new Set))
       (new_name nil)
       (selected_idx nil)
       (available (reduce (control (flatten (control_tree $root_controls)))
                          (when control.evaluate
                            (if (-> dups `has (or control.name "Untitled"))
                              (progn
                               (= new_name (+ (or control.name "Untitled")
                                             "-" idx))
                               (-> dups `add new_name)
                               [ (inc idx) new_name
                                 control ])
                              (progn
                               (-> dups `add control.name)
                               [ (inc idx) control.name control ])))))
       (selection_box (select { }
                              (map (fn (v)
                                     (option { `value: v.0 } v.1))
                                     (or available [])))))
    (= selected_idx
       (request_user_input (dtext "Select an available evaluator")
                           nil
                           { input: selection_box }))
    (when selected_idx
        (prop (prop available selected_idx) 2))))

(defun text_editor (options)
   (aif (and (not options.clone_with_editor_id)
             (get_control_by_name options.name))
        it
        (let
           ((options (+ {}  ;; default is an empty code editing buffer for lisp
                        { mode: "juno"
                          id: (generate_id "text_editor")   ;; id can be provided and will overide this generated ID
                          content: "" }
                        (if (is_object? options)
                            options
                            (progn
                               (notify "Invalid options object provided to editor - check config")))))
            (resize_observer nil)
            (group_name nil)
            (intf {})
            (initialized false)
            (config_value (function (key default_value)
                             (or (prop options key)
                                 (resolve_path [ `editor key ] *env_config*)
                                 default_value)))
            (buffer_commands_button (commands_button options.id))
            (evaluator_span (span { `class: "juno-evaluator" `style: "pointer: cursor" `title: (dtext "Name of the evaluator assigned to this buffer") } "-"))
            (nav_back_button (button { `title: (dtext "Step Backward In Position History") `style: "float: right" } "<"))
            (nav_forward_button (button { `disabled: true `title: (dtext "Step Foreward In Position History") `style: "float: right" } ">"))
            ;; if we have a namespace in options use that for referencing paths
            (nseval (if (not (blank? options.namespace))
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))
            (is_dirty? false)
            (col_pos_span (span { `title: "Position (Row Column)" `style: "float: right;margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } "[0 0]"))
            (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" }
                               (if options.read_only
                                  "RO"
                                  "")))
            (mode "-")
            (mode_span (span { `class: "juno-mode" `title: "Current Editing Mode" `style: "float: right; margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } mode))
            (title_span (span { `class: "juno-title" } options.name))
            (ns_span (span { `title: "Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } nseval.namespace))
            (control_bar (or options.control_bar
                             (div { `class: "juno-buffer-bar" }
                                  buffer_commands_button
                                  title_span
                                  ns_span
                                  evaluator_span
                                  locked_span
                                  nav_forward_button
                                  nav_back_button
                                  mode_span
                                  col_pos_span)))
            (parent_view nil)
            (context_clear_timer nil)
            (display_context_message (function (value)
                                        (if (and (blank? value)
                                                 context_clear_timer)
                                            nil
                                            (progn
                                               (when context_clear_timer
                                                  (clearTimeout context_clear_timer))
                                               (= context_clear_timer nil)
                                               (when (not (blank? value))
                                                  (= context_clear_timer (setTimeout (fn () (= context_clear_timer nil)) 3000)))  ;; delay for clearing the message to quickly if a blank comes in
                                               (cond
                                                  (is_element? value)
                                                  (-> help_context_elem
                                                     `replaceChildren value)
                                                  else
                                                  (-> help_context_elem
                                                     `replaceChildren (span { `style: "display: inline-block; text-overflow: ellipsis; width: 100%; overflow: hidden" } (+ "" value))))))))
            (check_observer (fn ()
                               (when (not (== view.parentElement parent_view))
                                  (-> resize_observer `disconnect)
                                  (-> resize_observer `observe view.parentElement)
                                  (= parent_view view.parentElement))))
            
            (help_context_elem (div { `class: "juno-help-context" } ""))
            (context_bar (div { `class: "juno-context-bar" }
                              help_context_elem))
            (offset_depth 46)
            (editor_div (div { `class: "opacity-0" `style: (+ "height: calc(100% - " offset_depth  "px); width: 100%; overflow: hidden;font-family:var(--main-mono-space);") }))
            
            (view (div { `control_id: options.id `style: "overflow: hidden; height: calc(100% - 10px); display: inline-block; width: inherit;" }
                       control_bar
                       editor_div
                       context_bar))
            (ns_notifier_id (gen_id "ns_notifier"))
            (name_change_id (gen_id "name_change_notifier"))
            (evaluator nil)
            (perform_resize (fn ()
                               (when view.parentElement
                                  (check_observer)
                                  (html/set_style [["width" "calc(100% - 2px)"];           (+ "" (- (prop view.parentElement `offsetWidth) 2) "px")]
                                                   ["height" (+ "" (- (prop view.parentElement `offsetHeight) 2) "px")]]
                                                  view)
                                  (set_style [["height" (+ "calc(100% - " (+ (Math.max 0 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] editor_div)
                                  (when editor
                                     (-> editor `resize)))))
            
            (editor nil)  ;; the editor object
            (set_read_only (fn (read_only?)
                              (progn
                                 (-> editor `setReadOnly read_only?)
                                 (if read_only?
                                    (set_prop locked_span
                                       `innerText
                                       (dtext "RO"))
                                    (set_prop locked_span
                                       `innerText
                                       (dtext ""))))))
            (set_evaluator (fn (evaluator_function)
                              (when (is_function? evaluator_function)
                                 (= evaluator evaluator_function)
                                 (dispatch_event { command: "editor_change"
                                                   source: options.id
                                                   args: [ { `option: "evaluator" `value: evaluator_function } ] })
                                 (aif (get_keybinding "editor" "evaluate_selection")
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (-> editor.commands `addCommand
                                         {
                                           `name: "evaluate_selection"
                                           `bindKey: { `win: "Shift-Enter" `mac: "Shift-Enter" }
                                           `exec: evaluate_selection
                                           })))))
            (change_evaluator_name (fn (event_obj)
                                      (progn
                                         (log "Received evaluator name change: " event_obj)
                                         (aif (resolve_path [ `args 0 `value ] event_obj)
                                              (set_prop evaluator_span
                                                 `innerText
                                                 it)))))
            (set_mode (fn (mode_name)
                         (progn
                            (defvar identifier_regex (new RegExp "[A-Za-z*+0-9_\\$\\u00A2-\\uFFFF]+"))
                            (set_prop options
                               `mode
                               mode_name)
                            (cond
                               (== options.mode "juno")
                               (progn
                                  (console.log "mode to juno")
                                  (-> editor.session `setMode "ace/mode/juno")
                                  (-> editor `setOptions {
                                                           `enableBasicAutocompletion:  [{ identifierRegexps: [ identifier_regex ]
                                                                                                             getCompletions: (fn (editor session pos prefix callback)
                                                                                                                                (get_juno_autocompletions editor session pos prefix callback sorted_symbols)) }]
                                                           enableLiveAutocompletion: true
                                                           enableSnippets: true
                                                           }))
                               (== options.mode "javascript")
                               (progn
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })
                                  (-> editor.session `setMode "ace/mode/javascript"))
                               (== options.mode "css")
                               (progn
                                  (-> editor.session `setMode "ace/mode/css")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true }))
                               (== options.mode "sh")
                               (progn
                                  (-> editor.session `setMode "ace/mode/sh")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true }))
                               options.mode
                               (progn
                                  (-> editor.session `setMode options.mode)
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true }))
                               else
                               (progn
                                  (set_prop options
                                     `mode
                                     `text)
                                  (-> editor.session `setMode "ace/mode/text")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })))
                            
                            (set_prop mode_span
                               `innerText
                               options.mode)
                            (dispatch_event { command: "editor_change"
                                              source: options.id
                                              args: [ { `option: "mode" `value: options.mode } ] })
                            (when options.on_mode_set
                               (options.on_mode_set mode_name)))))
            
            (set_theme (fn (theme_name)
                          (progn
                             (-> editor `setTheme (+ "ace/theme/" theme_name))
                             (set_prop options
                                `theme
                                theme_name)
                             (dispatch_event { command: "editor_change"
                                               source: options.id
                                               args: [ { `option: "theme" `value: theme_name } ] })
                             (when options.on_theme_set
                                (options.on_theme_set theme_name)))))
            
            (set_overscroll (fn (state)
                               (if state
                                  (progn
                                     (-> editor `setOption `scrollPastEnd true)
                                     (set_prop options
                                        `overscroll
                                        true)
                                     true)
                                  (progn
                                     (-> editor `setOption `scrollPastEnd false)
                                     (set_prop options
                                        `overscroll
                                        false)
                                     false))))
            
            (set_name (fn (new_name force)
                         (progn
                            ;; if we are not already called the new name go ahead and process the new name
                            (when (and (not (blank? new_name))
                                       (not (== (get_control_by_name new_name) intf)))
                               (set_prop options
                                  `name
                                  (if force
                                     new_name
                                     (compute_name_for_control new_name)))
                               (set_prop intf
                                  `name
                                  options.name)
                               (dispatch_event { command: "editor_change"
                                                 source: options.id
                                                 args: [ { `option: "name" `value: options.name } ] }))
                            (set_prop title_span
                               `innerText
                               options.name)
                            options.name)))
            (refresh_symbol_timer nil)
            (evaluate_selection (function (editor)
                                   (let
                                      ((rval nil)
                                       (copytext (if options.repl_mode
                                                     (-> editor `getValue)
                                                     (-> editor `getCopyText))))
                                      (if (blank? copytext)
                                          (if (not options.repl_mode)
                                              (display_context_message (dtext "Please highlight text to evaluate")))
                                          (try
                                             (progn
                                                (when refresh_symbol_timer
                                                   (clearTimeout refresh_symbol_timer)
                                                   (= refresh_symbol_timer (setTimeout (fn () (progn (get_current_symbols) (= refresh_symbol_timer nil))) 5000)))
                                                (= rval (evaluator copytext nil (not options.repl_mode) nil { `source_name: (or options.filename options.path) } ))
                                                (-> rval `then
                                                   (function (val)
                                                      (progn
                                                         
                                                         (try
                                                            (and options.on_evaluation
                                                               (-> options `on_evaluation copytext val))
                                                            (catch Error (e)
                                                               (log_error (+ "" options.name ": Received error from on_evaluation")
                                                                          e)))
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof val Error)
                                                                           (display_context_message (+ (subtype val)
                                                                                                       (if val.message (+ ":" val.message)
                                                                                                           "")))
                                                                           (is_function? val)
                                                                           (display_context_message (+ "<- " (subtype val)))
                                                                           else
                                                                           (progn
                                                                              (defvar chopped (as_lisp val))
                                                                              (if (> chopped.length 200)
                                                                                  (= chopped (+ (-> chopped `substr 0 200) "...")))
                                                                              (display_context_message (+ "<- " chopped)))))
                                                                     100)))
                                                   (function (e)
                                                      (progn
                                                         (notify "Failure on evaluation")
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof e Error)
                                                                           (display_context_message (+ (subtype e)
                                                                                                       (if e.message (+ ":" e.message)
                                                                                                           "")))
                                                                           else
                                                                           (display_context_message "Evaluation Failure")))
                                                                     100)))))
                                             (catch Error (e)
                                                (progn
                                                   (notify (+ (dtext "Unhandled error") ": " e.message ))
                                                   (console.error e))))))))
            
            (font_size (config_value `font_size 14))
            (increase_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.min 200 (+ font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (decrease_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.max 1 (- font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (select_form_root (fn ()
                                 (progn
                                    (select_to_root_form editor)
                                    nil)))
            (evaluate_root_form (fn ()
                                   (let
                                      ((cpos (current_position)))
                                      (select_form_root)
                                      (evaluate_selection editor)
                                      (sleep 0.02)
                                      (-> editor.selection `clearSelection)
                                      (-> editor `navigateTo cpos.row cpos.column)
                                      )))
            
            (select_current_form (fn ()
                                    (select_to_current_form editor)))
            (get_selected_text (function ()
                                  (-> editor `getSelectedText)))
            (get_selection_object (function ()
                                     (-> editor.selection `getRange)))
            (get_lines (function (from to)
                          (-> editor.selection `getLines from to)))
            (is_selected? (function ()
                             (progn
                                (defvar rng (get_selection_object))
                                (not (and (== rng.start.row rng.end.row)
                                          (== rng.start.column rng.end.column))))))
            (last_bracket_match nil)
            (active_lisp_operator nil) ;; the last active lisp operator
            
            (find_active_lisp_operator (function ()
                                          (let
                                             ((new_op nil)
                                              (rnge (or (-> editor.session `getBracketRange (-> editor `getCursorPosition))
                                                        (find_last_paren editor)))
                                              (usage nil))
                                             (if rnge
                                                (progn
                                                   (= last_bracket_match rnge)
                                                   (= new_op (first (split_by *whitespace_regexp* (-> editor.session `getTextRange last_bracket_match))))
                                                   
                                                   (when (not (== new_op active_lisp_operator))
                                                      (= active_lisp_operator new_op)
                                                      (= usage (decorative_usage active_lisp_operator nil nil (function (val)
                                                                                                                               (progn 
                                                                                                                                  (symbol_finder val true)
                                                                                                                                     ))))
                                                      (console.log "find_active_lisp_operator: usage is: " usage)
                                                      (if usage
                                                         (-> help_context_elem
                                                            `replaceChildren usage)
                                                         (-> help_context_elem `replaceChildren))
                                                      (when usage
                                                         (dispatch_event { `command: "display_usage" `source: options.id `args: [active_lisp_operator] }))
                                                      (when options.on_new_lisp_operator
                                                         (options.on_new_lisp_operator active_lisp_operator))))
                                                (progn
                                                   (= active_lisp_operator nil)
                                                   (-> help_context_elem
                                                      `replaceChildren)
                                                   (when options.on_new_lisp_operator
                                                      (options.on_new_lisp_operator nil)))))))
            
            (indent_row (function (row_number options)
                           (indent_editor_line editor row_number options)))
            
            (indent_current_row (function (editor)
                                   (when (== *last_focus* intf)
                                      (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                         (if (not (is_selected?))
                                             (progn
                                                (defvar row_number (prop (-> editor `getCursorPosition)
                                                                         `row))
                                                (console.log "tab: start: single line: " row_number)
                                                (indent_row row_number { `apply: true }))
                                             (indent_editor_selection editor))))))
            
            (bind_key (fn (key_command func)
                         (aif (get_keybinding "editor" key_command)
                              (progn
                                 (-> editor.commands `addCommand
                                    (to_ace_keybinding key_command it func))))))
            ;; keyword mapper support
            (keyword_mapper (function (token)
                               (progn
                                  (console.log "editor keyword mapper: " options.name token)
                                  (defvar rval
                                     (if (contains? token *formatting_rules*.keywords)
                                        "keyword"
                                        (symbol_finder token)))
                                  
                                  rval)))
            ;; signal ready for saving
            (request_save (function ()
                             (progn
                                (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] }))))
            
            ;; handle the results of the save
            (save_complete (function (event_obj)
                              (progn
                                 (if options.create_mode
                                    (delete_prop options `create_mode))
                                 (display_context_message (+ "Saved " (cond
                                                                         (and (== event_obj.args.0.type "path")
                                                                              (is_array? event_obj.args.0.target))
                                                                         (join "~" event_obj.args.0.target)
                                                                         (== event_obj.args.0.type "filename")
                                                                         event_obj.args.0.target)))
                                 (log "editor: save_complete: " (clone event_obj))
                                 (remove_class "juno-needs-save" title_span)
                                 (delete_prop options `create_mode)
                                 (= is_dirty? false)
                                 (when options.on_save
                                    (-> options `on_save intf)))))
            (split_editor (fn (dir)
                             (let
                                ((new_editor nil))
                                (cond
                                   (== dir "vertical")
                                   (progn
                                      (= new_editor (clone_text_editor_control intf))
                                      (alert_on_error "Unable to split"
                                                      (container_view_operation "split_right" intf new_editor)))
                                   (== dir "horizontal")
                                   (progn
                                      (= new_editor (clone_text_editor_control intf))
                                      (alert_on_error "Unable to split"
                                                      (container_view_operation "split_below" intf new_editor)))
                                   else
                                   (alert_box "Invalid Split Request" "Split commands  must be vertical or horizontal")))))
            ;; position tracking
            (max_history_length (if (is_number? options.max_history_length)
                                    options.max_history_length
                                    40))
            (position_history [])
            (position_history_idx 0)
            (current_position (fn ()
                                 (-> editor `getCursorPosition)))
            (set_cursor_position (fn (pos)
                                    (progn
                                       (-> editor `navigateTo pos.row pos.column)
                                       (-> editor `scrollToLine pos.row true nil)
                                       (focus_to_editor intf))))
            (update_position (function ()
                                (when editor
                                   (defvar current_pos (-> editor `getCursorPosition))
                                   
                                   (set_prop col_pos_span
                                      `innerText
                                      (+ "[" current_pos.row " " current_pos.column "]"))
                                   (set_prop options `cursor_position current_pos)
                                   
                                   ;; record our position history so we can go back
                                   ;; if we are less then 8 rows difference, then
                                   ;; update it, otherwise push it onto the stack
                                   (try
                                      (progn
                                         (when (isNaN position_history_idx)
                                            (log "text_editor: update_position: position_history_idx isNaN!")
                                            (= position_history_idx (- position_history.length 1))
                                            (set_disabled nav_forward_button))
                                         (defvar last_pos (prop position_history position_history_idx))
                                         (when (eq nil last_pos)
                                            (log "last_pos is nil! and it shouldn't be: " position_history_idx))
                                         (if (> (Math.abs (- current_pos.row (prop last_pos `row)))
                                                8)
                                             (progn
                                                (inc position_history_idx)
                                                (-> position_history `splice position_history_idx 0 current_pos)
                                                ;(log "update_position: recorded position" position_history_idx (prop last_pos `row) (Math.abs (- current_pos.row (prop last_pos `row))))
                                                (when (> position_history.length max_history_length)
                                                   (take position_history)
                                                   (= position_history_idx (clamp position_history_idx 0 (- position_history.length 1)))))
                                             (progn
                                                (-> position_history `splice position_history_idx 1 current_pos))))
                                      (catch Error (e)
                                         (log "ERROR " options.name  " on position history update: " e.message)))
                                   
                                   
                                   )))
            (go_backward_in_position (fn ()
                                        (progn
                                           (= position_history_idx (Math.max 0 (- position_history_idx 1)))
                                           (set_enabled nav_forward_button)
                                           (set_cursor_position (prop position_history position_history_idx)))))
            (go_forward_in_position (fn ()
                                       (progn
                                          (= position_history_idx (Math.min (- position_history.length 1) (+ position_history_idx 1)))
                                          (when (== position_history_idx (- position_history.length 1))
                                             (set_disabled nav_forward_button))
                                          (set_cursor_position (prop position_history position_history_idx)))))
            
            (on_focus (fn ()
                         (progn
                            (when (not (== *last_focus* intf))
                               (setTimeout (fn ()
                                              (focus_to intf.editor))
                                           10))
                            (setq *last_focus* intf)
                            (add_class "juno-focused" control_bar))))
            
            (orig_bindings nil)
            (build_key_bindings (fn (editor)
                                   (progn
                                      (console.log "building_key_bindings")
                                      ;; we need to remove any keybinding that interferes with our globals and then
                                      ;; rebuild to the right scope
                                      (= orig_bindings (clone (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor)))
                                      ;(defglobal *orig_key_bindings* orig_bindings)
                                      (when options.on_save
                                         (bind_key "on_save" request_save))
                                      (bind_key "increase_font_size" increase_font_size)
                                      (bind_key "decrease_font_size" decrease_font_size)
                                      (bind_key "select_form_root" select_form_root)
                                      (bind_key "select_current_form" select_current_form)
                                      (bind_key "indent_current_row" indent_current_row)
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (bind_key "evaluate_root_form" evaluate_root_form)
                                      (bind_key "evaluate_selected_in_place" (fn (editor)
                                                                                (progn
                                                                                   (setTimeout (fn ()
                                                                                                  (try
                                                                                                     (progn
                                                                                                        (defvar rval (eval_selected_text_in_place (get_control_by_editor editor)))
                                                                                                        true)
                                                                                                     (catch Error (e)
                                                                                                        (display_context_message "Error on evaluation: " e.message))))
                                                                                               10)
                                                                                   true)))
                                      
                                      (when (is_array? options.commands)
                                         (for_each (command options.commands)
                                            (do
                                               (console.log "optional commands: " command.name command)
                                               (-> editor.commands `addCommand
                                                  (to_ace_keybinding command.name command)))))
                                      true)))
            
            (linked_editor_name nil)
            (linked_editor nil)
            (data_type nil)
            (data_type_defaults { String: ""
                                  array:[]
                                  object: {} })
            ;; based on the contents of the options object set the editor's content
            (set_content (fn ()
                            (let
                               ((content nil))
                               (if options.data_type
                                  (if (eq undefined (prop data_type_defaults options.data_type))
                                      (throw TypeError (+ "Invalid data_type specified: must be either: " (join ", " (keys data_type_defaults))))))
                               (cond
                                  ;; do we have a filename?
                                  (and (is_string? options.filename)
                                       is_served?)
                                  (try
                                     (progn
                                        ;(log "text_editor: requesting file: " options.filename)
                                        (if options.create_mode
                                           (= content "")
                                           (= content (-> (fetch (+ "/files/" options.filename)) `text)))
                                        
                                        (if (is_string? content)
                                            (progn
                                               
                                               (-> editor `setValue content -1))
                                            (progn
                                               (-> editor `setValue "")
                                               (= content "")
                                               (display_context_message (+ "NOTICE: unable to fetch file: " options.filename " (editor set to local value)"))))
                                        (set_prop options
                                           `path
                                           (conj [ `filesystem ] (split_by "/" options.filename))))
                                     
                                     (catch Error (e)
                                        (progn
                                           (-> editor `setValue "")
                                           (= content content)
                                           (display_context_message (+ "ERROR on fetching: " options.filename " (editor set to local value)  " e.message))
                                           (log "Error on fetching file: " options.filename ": " e)
                                           (set_prop options
                                              `path
                                              (conj [ `filesystem ] (split_by "/" options.filename))))))
                                  
                                  ;; if we are given a filename, but we are not online we can't edit it
                                  ;; if we have previous content we can edit off line, but with a notice to the user
                                  (and (is_string? options.filename)
                                       (or options.content options.content_compressed))
                                  (progn
                                     (if (and (is_symbol? `LZString)
                                              options.content_compressed)
                                         (-> editor `setValue (LZString.decompressFromBase64 options.content_compressed -1))
                                         (-> editor `setValue options.content -1))
                                     (= content options.content)
                                     (alert_box "Warning: Using cached content"
                                                (div { `style: "" }
                                                     (dtext "The application isn't online, so the specified content cannot be fetched.")
                                                     (dtext "The last stored value is being used, but this may not match the remote content.")
                                                     (br)
                                                     (dtext "Information loss could occur if this editor's contents are subsequently saved to the server.")
                                                     (dtext "Be careful!")))
                                     (set_prop options
                                        `path
                                        (conj [ `filesystem ] (split_by "/" options.filename)))
                                     (display_context_message (+ "Warning: Cached value of an online file")))
                                  (is_array? options.path)
                                  (progn
                                     (= content (resolve_path options.path nseval.global_ctx.scope))
                                     (when (eq nil content)
                                        (= content (or options.content
                                                       (and options.data_type
                                                          (prop data_type_defaults options.data_type))
                                                       ""))
                                        (make_path options.path nseval.global_ctx.scope content)
                                        (display_context_message (+ "New path: " (join "~" options.path) " with content type " (sub_type content))))
                                     (if (not (== "String" (sub_type content)))
                                         (-> editor `setValue (pretty_print content))
                                         (-> editor `setValue content -1)))
                                  (is_string? options.content)
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue content -1))
                                  (or (is_object? options.content)
                                      (is_array? options.content))
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue (pretty_print content))))
                               (assert (is_value? content) "assertion failure: content is not set in set_content")
                               (= data_type
                                  (sub_type content))
                               (set_prop options
                                  `data_type
                                  data_type)
                               ;; at this point content should be loaded and displayed and
                               ;; data_type should be properly set for the content that
                               ;; is being edited
                               options)))
            (symbol_finder (function (token want_metadata)
                              (if (and token
                                       cached_symbols)
                                 (let
                                    ((rval nil)
                                     (comps (split_by "/" token))
                                     (symbol_namespace (if (> comps.length 1)
                                                           (take comps)
                                                           nil))
                                     (cns (or symbol_namespace
                                              (if evaluator_control 
                                                 (-> evaluator_control `current_namespace)
                                                 nil)))
                                     (token (last comps))
                                     (search_order (if cns
                                                       (reduce_sync (ns (keys cached_symbols) )
                                                              (if (and (not (== ns `core))
                                                                       (not (== ns cns)))
                                                                  ns))
                                                       (keys cached_symbols))))
                                    
                                    (when cns
                                       (= rval (resolve_path [ cns token  ] cached_symbols))
                                       (if rval
                                          (set_prop rval 
                                             `namespace
                                             cns))
                                       (unless rval
                                          (= rval (resolve_path [ `core token  ] cached_symbols))
                                          (if rval
                                             (set_prop rval
                                                `namespace
                                                `core))))
                                    
                                    ;(console.log "symbol_finder: want_metadata: " want_metadata  " rval from level 1: " token "->" rval)
                                    (if (is_function? rval)
                                      (console.error (+ "symbol_finder: received a function back!  Should be an object -> check path in namespace:" cns " for " token " in cached_symbols: ") (resolve_path [ cns token ] cached_symbols)))
                                    (if rval
                                       (progn
                                          (if want_metadata
                                            rval
                                            (progn                                               
                                               (if (is_string? rval.type)
                                                 (= rval (lowercase (prop rval `type)))
                                                 (progn
                                                  (console.error "symbol_finder: .type property for " token " is not a string: " rval.type)
                                                  (= rval "identifier"))))))
                                                  
                                       (progn
                                          (for_each (ns search_order)
                                             (progn
                                                (= rval (resolve_path [ ns token ] cached_symbols))
                                                (when rval
                                                   (set_prop rval
                                                      `namespace ns)
                                                   (break))))
                                          ;(console.log "symbol_finder: search_order:" search_order " rval from level 2: " token "->" rval)
                                          (if rval
                                             (if want_metadata
                                                rval
                                                (= rval (lowercase (prop rval `type))))
                                             (if want_metadata
                                                (= rval {})
                                                (= rval "identifier")))))
                                    ;(console.log "symbol_finder: <- " cns token "want_metadata: " want_metadata rval)
                                    rval)
                                 (progn
                                    (console.log "symbol_finder: no cached_symbols: returning empty {} / identifier")
                                    (if want_metadata
                                       {}
                                       "identifier")))))
            (cached_symbols nil)
            (sorted_symbols nil)
            (get_current_symbols (fn ()
                                    (let
                                       ((symbol_set (if evaluator_control
                                                        (-> evaluator_control `available_symbols)))
                                        (cns (if evaluator_control
                                                 (-> evaluator_control `current_namespace)))
                                        (in_path nil)
                                        (search_order nil))
                                       
                                       (when (is_object? symbol_set)
                                          (= cached_symbols symbol_set)
                                          (= search_order
                                             (if cns
                                                (conj [ cns `core ] 
                                                      (reduce_sync (ns (keys cached_symbols) )
                                                         (if (and (not (== ns `core))
                                                                  (not (== ns cns)))
                                                             ns)))
                                                (keys cached_symbols)))
                                          (= sorted_symbols
                                             (flatten
                                                (for_each (ns search_order)
                                                   (progn
                                                      (if (or (== ns cns)
                                                                (== ns `core))
                                                          (= in_path true)
                                                          (= in_path false))
                                                      (for_each (sym (keys (prop cached_symbols ns)))
                                                         (if in_path
                                                             sym
                                                             (+ ns "/" sym))))))))
                                       
                                       (when evaluator_control
                                          (set_prop ns_span
                                             `innerText
                                             (-> evaluator_control `current_namespace))))))
                                       
            (set_display_control_bar (fn (state)
                                        (progn
                                           (if state
                                              (remove_class "juno-display-none" control_bar)
                                              (add_class "juno-display-none" control_bar))
                                           (perform_resize))))
            (evaluator_control nil)  ;;create a convenience handle to this if not evaluated
            (set_evaluator_control (fn (control)
                                      (if control.evaluate
                                         (progn
                                            (when options.evaluator_id
                                               (remove_event_handler options.evaluator_id "evaluator_change" ns_notifier_id)
                                               (remove_event_handler options.evaluator_id "control_name_change" name_change_id))
                                            (= evaluator_control control)
                                            (set_evaluator control.evaluate)
                                            (set_prop options
                                               `evaluator_id
                                               control.options.id)
                                            (register_event_handler options.evaluator_id "evaluator_change" ns_notifier_id get_current_symbols)
                                            (register_event_handler options.evaluator_id "control_name_change" name_change_id change_evaluator_name)
                                            (if control.name
                                               (set_prop evaluator_span
                                                  `innerText
                                                  (+ "⭢ " control.name)))
                                            (get_current_symbols)))))
            (user_select_evaluator (fn (e)
                                      (progn
                                         (aif (select_evaluator)
                                              (progn
                                                 (set_evaluator_control it)
                                                 (notify (+ (dtext "Evaluator set to ") it.options.name)))))))
            (menu_items (fn ()
                           [(if options.path
                                [(+ (dtext "Save to") " " (last options.path))
                                 (fn (e) (request_save))]
                                [])
                            [(dtext "Split Vertically")
                             (fn (e)
                                (split_editor `vertical)) ]
                            [(dtext "Split Horizontally")
                             (fn (e)
                                (split_editor `horizontal))]
                            [(dtext "Select Evaluator")
                             user_select_evaluator]
                            
                            [(dtext "Increase Font Size") increase_font_size]
                            [(dtext "Decrease Font Size") decrease_font_size]
                            [(dtext "Go")
                             [[(dtext "Step Backward In Position History")
                               go_backward_in_position]
                              [(dtext "Step Forward In Position History")
                               go_forward_in_position]]]
                            (if (-> editor `getReadOnly)
                                [ (dtext "Allow Editing" ) (fn () (-> intf `set_read_only false)) ]
                                [ (dtext "Set Read-Only Mode") (fn () (-> intf `set_read_only true)) ])
                            [(dtext "Set Edit Mode")
                             [["Juno" (fn () (-> intf `set_mode "juno"))]
                              ["Javascript" (fn () (-> intf `set_mode "javascript")) ]
                              ["Text" (fn () (-> intf `set_mode "text"))]
                              ["CSS" (fn () (-> intf `set_mode "css"))]
                              ["JSON" (fn () (-> intf `set_mode "json"))]
                              ["Shell" (fn () (-> intf `set_mode "sh"))]]]
                            [(dtext "Set Editor Theme")
                             (for_each (theme *editor_themes*)
                                [theme  (fn () (-> intf `set_theme theme))])]]))
            
            ;; main initialization routine
            (initialize_editor (fn ()
                                  (when (not initialized)
                                     (let
                                        ((comps nil)
                                         (content nil)
                                         (start_time (time_in_millis))
                                         (extension nil))
                                        (setq initialized true)
                                        (setq parent_view view.parentElement)
                                        (setq editor
                                           (ace.edit editor_div))
                                        
                                        ;(log "initialize_editor: " options.mode " options: " (clone options))
                                        
                                        ;; ensure that the Ace language tools extension is loaded
                                        
                                        (defglobal LangTools (-> ace `require "ace/ext/language_tools"))
                                        
                                        ;; if we are not explicitly told to link to another editor...
                                        ;; we need to check to ensure we are not editing a path or file that is already
                                        ;; open by another editor.
                                        
                                        ;; is there already an editor with the same path or filename?
                                        ;; if so, become a linked editor to it
                                        
                                        (when (not options.clone_with_editor_id)
                                           (cond
                                              (and options.path
                                                 (> (get_editors_for_path options.path) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path options.path)))
                                                 (assert primary "initialize_editor: BUG: multiple editors for path but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))
                                              (and options.filename
                                                 (> (get_editors_for_filename options.filename) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path (get_editors_for_filename options.filename))))
                                                 (assert primary "initialize_editor: BUG: multiple editors for filename but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))))
                                        
                                        
                                        ;; are we a cloned editor?
                                        
                                        (when options.clone_with_editor_id
                                           (let ((control_to_clone (get_control_by_id options.clone_with_editor_id))
                                                 (new_session nil))
                                              (if (eq nil control_to_clone)
                                                  (log "editor: cannot find editor to clone, id: " options.clone_with_editor_id))
                                              (when (and control_to_clone
                                                         control_to_clone.editor)
                                                 (= new_session (clone_edit_session control_to_clone.editor.session))
                                                 (= linked_editor control_to_clone.options.id)
                                                 (= linked_editor_name control_to_clone.options.name)
                                                 (-> editor `setSession new_session))))
                                        
                                        ;; behavior setup for the actual editor component
                                        (when options.on_focus
                                           (-> editor `on `focus options.on_focus))
                                        (when options.on_blur
                                           (-> editor `on `blur options.on_blur))
                                        (when options.read_only
                                           (-> editor `setReadOnly true))
                                        (when options.on_click
                                           (-> editor `on `click options.on_click))
                                        (unless linked_editor
                                           (-> editor.session `setUseSoftTabs true)
                                           (-> editor.session `setUseWorker true)
                                           (-> editor.session `setUseSoftTabs true))
                                        
                                        (-> editor `setShowFoldWidgets true)
                                        
                                        ;; set the extension if we haven't been given a specific option mode
                                        ;; if we have filename use that to determine what the mode is
                                        
                                        (when (and (eq nil options.mode)
                                                   (is_string? options.filename))
                                           (= comps (split_by "." options.filename))
                                           (when (> comps.length 1)
                                              (= extension (edit_mode_for_extension (last comps)))
                                              (set_prop options
                                                 `mode
                                                 extension)))
                                        
                                        (set_mode options.mode)
                                        
                                        ;; set the theme for the new editor
                                        (cond
                                           (is_string? options.theme)
                                           (setTimeout (fn () (progn
                                                              (-> intf `set_theme options.theme)
                                                              (remove_class "opacity-0" editor_div))) 50)
                                           else
                                           (aif (resolve_path [ `editor `default_theme ] *env_config*)
                                                (setTimeout (fn ()
                                                               (progn
                                                                  (-> intf `set_theme it)
                                                                  (remove_class "opacity-0" editor_div))) 50)))
                                        
                                        ;; build the key bindings
                                        (build_key_bindings editor)
                                        
                                        (-> editor `setOptions {
                                                                 `showFoldWidgets: true
                                                                 `cursorStyle: "wide"
                                                                 `firstLineNumber: (or options.first_line_number 0)
                                                                 `useSoftTabs: true
                                                                 `highlightActiveWord: true
                                                                 })
                                        
                                        ;; if this editor is primary, and not linked to another editor,
                                        ;; get the content from the specified source or path
                                        (if (not linked_editor)
                                            (set_content))
                                        
                                        (cond
                                           (and options.clone_with_editor_id
                                              (get_control_by_id options.clone_with_editor_id))
                                           (progn
                                              (defvar primary (get_control_by_id options.clone_with_editor_id))
                                              (when primary.group_name
                                                 (set_prop options
                                                    `group_name
                                                    (-> primary `group_name))))
                                           (eq nil options.group_name)
                                           (set_prop options
                                              `group_name
                                              (or options.group_name
                                                 options.name
                                                 (and (is_array? options.path)
                                                      (last options.path))
                                                 (and (is_string? options.filename)
                                                      (last (split_by "/" options.filename)))
                                                 "Untitled Buffer")))
                                        
                                        (set_name options.group_name)
                                        
                                        ;; set up the default font size
                                        
                                        (if (eq nil font_size)
                                            (= font_size (parseInt (-> editor `getFontSize)))
                                            (-> editor `setFontSize font_size))
                                        
                                        (set_prop options
                                           `font_size
                                           font_size)
                                        
                                        ;; default to overscoll mode, but TODO: this should be an global default
                                        (unless (== options.overscroll false)
                                           (-> editor `setOption `scrollPastEnd true))
                                        
                                        ;; load up the token iterator extension...
                                        (defglobal TokenIterator (prop (-> ace `require "ace/token_iterator") `TokenIterator))
                                        
                                        ;; set up change events for hints and contexual help
                                        
                                        (-> editor `on `change (function (val)
                                                                  (progn
                                                                     (add_class "juno-needs-save" title_span)
                                                                     (= is_dirty? true)
                                                                     (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                                                        (when (not linked_editor)
                                                                           (handle_lisp_format_event val editor))
                                                                        (find_active_lisp_operator))
                                                                     (when (not linked_editor)
                                                                        (dispatch_event { command: "editor_change"
                                                                                          source: options.id
                                                                                          args: [ val ] }))
                                                                     ;(update_position)
                                                                     (when options.on_change
                                                                        (options.on_change editor val)))))
                                        ;; resize
                                        (-> editor `resize true)
                                        ;; reset the undo manager now that th content is loaded
                                        
                                        (unless options.clone_with_editor_id
                                           (try
                                              (aif (-> editor.session `getUndoManager)
                                                   (-> it `reset))
                                              (catch Error (e)
                                                 (log "ERROR on undo manager:" e message))))
                                        
                                        ;; expose the editor in our interface
                                        (set_prop intf `editor editor)
                                        
                                        (when (is_object? options.on_mode_set)
                                           (options.on_mode_set options.mode))
                                        
                                        ;; signal our mode change
                                        
                                        (dispatch_event { command: "editor_change"
                                                          source: options.id
                                                          args: [ { `option: "mode" `value: options.mode } ] })
                                        
                                        ;; scroll speed of the editor
                                        (cond
                                           (is_number? options.scroll_speed)
                                           (set_scroll_speed intf options.scroll_speed)
                                           (is_number? (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                           (progn
                                              ;(log "setting scroll speed: " (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                              (set_scroll_speed intf (resolve_path [ `editor `scroll_speed ] *env_config* )))
                                           else
                                           (set_scroll_speed intf 5))  ;; default scroll speed is 5
                                        
                                        (set_prop options
                                           `scroll_speed
                                           (-> editor `getScrollSpeed))
                                        
                                        ;; when we are linked move to our current position of the other editor
                                        (when linked_editor
                                           (defvar pos (-> (prop (get_control_by_id linked_editor) `editor)
                                                           `getCursorPosition))
                                           (-> editor `navigateTo  pos.row pos.column)
                                           (-> editor `scrollToLine pos.row true nil))
                                        
                                        (push position_history
                                           (-> editor `getCursorPosition))
                                        
                                        (when options.on_initialized
                                           (options.on_initialized intf))
                                        (attach_event_listener view
                                           `keyup
                                           (function (e)
                                              (progn
                                                 (update_position))))
                                        
                                        (if (== options.display_control_bar false)
                                            (set_display_control_bar false))
                                        
                                        (attach_event_listener nav_forward_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_forward_in_position))))
                                        
                                        (-> editor `on `click (function (val) (update_position)))
                                        (attach_event_listener nav_back_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_backward_in_position))))
                                        
                                        
                                        (attach_event_listener evaluator_span
                                           `click
                                           user_select_evaluator)
                                        ;; setup the evaluator if it is ready
                                        (setTimeout (fn ()
                                                       (let
                                                          ((count 10)
                                                           (evaluator_control nil))
                                                          ;; unless we have been explicitly given an evaluator, use the system repl
                                                          (if options.evaluator_id
                                                             (progn
                                                                (= evaluator_control (get_control_by_id options.evaluator_id))
                                                                (while (and (> count 0)
                                                                            (not evaluator_control))
                                                                   (progn
                                                                      (sleep 1)
                                                                      (dec count)
                                                                      (= evaluator_control (get_control_by_id options.evaluator_id))))
                                                                (if evaluator_control
                                                                   (set_evaluator_control evaluator_control)
                                                                   (notify "Unable to set evalator control for the buffer - id not found")))
                                                             (when *system_repl*
                                                                (display_context_message (+ "Evaluator for this buffer is " (prop *system_repl* `name)))
                                                                (set_evaluator_control *system_repl*)))))
                                                    100)
                                        ;(log "initialize_editor: " (clone options.name) (+ ": (" (last_n_chars 5 options.id) "): initialization complete:") (clone options))
                                        intf)))))
           
           (declare (function compute_name_for_control select_evaluator)
                    (global compute_name_for_control select_evaluator))
           (if (not (is_symbol? `$ace_editor))
               (throw TypeError "$ace_editor symbol not found, and is required for this editor."))
           
           (set_style [["height" (+ "calc(100% - " (+ (Math.max 12 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]]
                      editor_div )
           
           (= resize_observer (new ResizeObserver perform_resize))
           (= intf
              {
                `view: view
                `editor: editor  ;; control must be initialized before the editor can be used
                `set: (fn (text)
                         (-> editor `setValue text))
                `get: (fn (text)
                         (-> editor `getValue))
                `get_selection: get_selection_object
                `get_selected_text: get_selected_text
                `is_selected?: is_selected?
                `group_name: (fn ()
                                options.group_name)
                `type: `text_editor
                `can_hide?: (fn ()
                               (progn
                                  ;(log "editor: can_hide? " (get_editors_for_path options.path) "<= 1 can hide" options.path)
                                  (< (length (get_editors_for_path options.path)) 2)))
                
                `set_display_control_bar: set_display_control_bar
                `on_destroy: (fn ()
                                (progn
                                   (cond
                                      (and options.path
                                         (> (length (get_editors_for_path options.path)) 1)
                                         (-> intf `get_linked))
                                      true  ;; in this case we are a linked editor so we are only really removing a view, not the primary editor control
                                      (not is_dirty?)
                                      true
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" }
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         ;(log (+ "editor: " options.name ": user response: ") response)
                                         response))))
                `destroy: (fn ()
                             (when editor
                                
                                (defvar others_and_me (if options.path
                                                          (get_editors_for_path options.path)
                                                          []))
                                (defvar my_path (clone options.path))
                                (when options.evaluator_id
                                   (remove_event_handler options.evaluator_id "evaluator_change" ns_notifier_id)
                                   (remove_event_handler options.evaluator_id "control_name_change" name_change_id))
                                ;(log "editor: " options.name ": got destroy..dispatching event: others and me: " others_and_me.length (< others_and_me.length 2))
                                ;(log "editor: remaining editors for path: " (each (get_editors_for_path options.path) `options))
                                (dispatch_event { `command: "destroy_control" `source: options.id `args: [  ]  })
                                (-> editor `destroy)
                                (= editor nil)
                                ;; effectively de-register ourselves from the group of editors
                                (set_prop options
                                   `path
                                   nil
                                   `group_name
                                   nil
                                   `filename
                                   nil)
                                (= intf nil)
                                (when my_path
                                   (rename_editor_group my_path))))
                `set_evaluator: (fn (new_evaluator)
                                   (when (is_function? new_evaluator)
                                      (set_evaluator new_evaluator)))
                `set_evaluator_control: set_evaluator_control
                `get_evaluator: (fn ()
                                   evaluator)
                `needs_save?: (fn ()
                                 (and (not options.repl_mode)
                                      is_dirty?))
                `set_mode: set_mode
                `get_mode: (fn ()
                              options.mode)
                `set_theme: set_theme
                `set_overscroll: set_overscroll
                `split_vertical: (fn ()
                                    (split_editor `vertical))
                `split_horizontal: (fn ()
                                      (split_editor `horizontal))
                `display_context_message: display_context_message
                `get_evaluator: (fn ()
                                   evaluator)
                `get_position_detail: (fn ()
                                         { current: (-> editor `getCursorPosition)
                                                   idx: position_history_idx
                                                   history: position_history
                                                   })
                `step_backward_in_pos_history: go_backward_in_position
                `step_forward_in_pos_history: go_forward_in_position
                `resize: (fn ()
                            (perform_resize))
                `bind_key: bind_key
                `key_bindings: (fn ()
                                  (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor))
                `save: (function ()
                          (request_save))
                `on_save_complete: (function (event_obj)
                                      (save_complete event_obj))
                `increase_font_size: increase_font_size
                `decrease_font_size: decrease_font_size
                `menu_items: menu_items
                `get_active_lisp_operator: (fn ()
                                              (find_active_lisp_operator))
                `set_read_only: set_read_only
                `get_current_pos: (fn ()
                                     (current_position))
                `set_editor_option: (fn (editor_option_name value)
                                       (when (is_string? editor_option_name)
                                          (-> editor `setOption editor_option_name value)))
                `options: options
                `set_evaluator_control: set_evaluator_control
                `on_focus: (if options.disallow_control_focus
                              nil
                              on_focus)
                `name: options.name
                `set_name: set_name
                `get_linked: (fn ()
                                options.clone_with_editor_id)
                `set_linked: (fn (id)
                                (set_prop options
                                   `clone_with_editor_id
                                   id))
                `set_unlinked: (function ()
                                  (progn
                                     (= linked_editor nil)
                                     (delete_prop options
                                        `clone_with_editor_id)
                                     options))
                `cached_symbols: (function ()
                                    cached_symbols)
                `keyword_mapper: keyword_mapper
                `toJSON: (function ()
                            (progn
                               (if (is_symbol? `LZString)
                                   (set_prop options
                                      `content_compressed
                                      (LZString.compressToBase64 (-> editor `getValue)))
                                   (set_prop options
                                      `content
                                      (-> editor `getValue)))
                               `(text_editor ,#options)))
                `initialize: (fn ()
                                (when view.parentElement
                                   (console.log "editor: performing initialization")
                                   (-> resize_observer `observe view.parentElement)
                                   (try
                                      (initialize_editor)
                                      (catch Error (e)
                                         (log "ERROR on init: " e.message))))) })))
   {
     `description: (+ "<br><br>The text_editor control provides a means for editing text based "
                      "buffers, and can either be used for editing local in-memory content or, for "
                      "remote files when the application is served via HTTP.   The editor can be split "
                      "into multiple views of the same content, provides theming, and color coded "
                      "markup capabilities.  Additionally, key sequences can be used either in the "
                      "scope of the editor, or via global scope.  It can adapt well to being a "
                      "sub-control, and has a large number of options to enable higher fidelity "
                      "between serialization and deserialization cycles.   <br><br>#### Example Usage "
                      "<br>```(text_editor \n   { mode: `juno\n     on_change: (function (editor val)\n  "
                      "          (progn\n                      (log (+ (control_name editor) \": change: "
                      "\" val))))\n     name: \"Test Editor\"\n     evaluator_id: (control_id "
                      "*system_repl*)\n     on_initialized: (fn (control)\n                      (notify "
                      "(+ (control_name control) \": initialized!\")))\n   })```<br><br><br>---<br><br> "
                      "This control serves as a wrapper around a third party library, the Ace Editor.  "
                      "The control abstracts certain Ace editor functionality as part of the control\'s "
                      "interface. <br><br>#### Ace Editor              <br><br>  The underlying text "
                      "editor library used for this control is the BSD licensed Ace Editor.  The "
                      "documentation for this library is available here: "
                      "https://github.com/ajaxorg/ace.  Certain underlying functions have been "
                      "elevated and exposed at the top level control interface for purposes of the "
                      "design and implementation of the text_editor control.  Direct access to the Ace "
                      "editor instance and its functionality is via the `editor` key in the control\'s "
                      "interface. Since this control uses a third party library underneath, any "
                      "underlying state not captured directly in the controls options object will be "
                      "lost when serialized.  A project objective is to build out the interface for "
                      "this control toward a more idiomatic and \"lisp-like\" interface.   The exposed "
                      "functionality should be expected to be able to save state and restore, unless "
                      "otherwise noted.<br><br>#### Modes              <br><br> The editor can be set "
                      "to operate in a certain \"mode\" state. Changing the editing mode enables certain "
                      "functionalities to be \"turned on\", and which is specifically relevant for the "
                      "type and purpose of the content being edited.  There are several modes that are "
                      "prebuilt into the editor: Juno/Lisp, Javascript, CSS, and plain text.  Each of "
                      "these modes provide specific features such as syntax highlighting, suggestion "
                      "rules, and active formatting rules. <br>Modes can be selected at creation time "
                      "and during run-time.    The mode is indicated visually by the \"Current Editing "
                      "Mode\" title bar text, located to the far right on the default title bar.  The  "
                      "`(get_mode)`  function can be used in the control\'s interface, which is called "
                      "with zero arguments.    <br> The mode can be changed by the user in the "
                      "control\'s command menu, where the user can select via the Set Edit Mode sub "
                      "menu.   The Controls interface exposes the  `set_mode`  function, where a "
                      "string that is equal to the mode name is given as an argument.  The names of "
                      "the built-in modes are as follows: ```[ `juno `javascript `text `css `json "
                      "]```<br><br> Each element in the array can be used to "
                      "supply `set_mode`.  <br>Additional modes can be constructed and made available "
                      "to the environment that then can be utilized by the text_editor "
                      "control. Presently, the only custom mode is `juno`, which calls back into the "
                      "Lisp environment for context.   The other modes are standard ACE editor modes "
                      "for their respective content type.  In this environments file structure, mode "
                      "files are found named `js_lib/mode-*`, where all relevant mode-code is found "
                      "with the \"mode-\" prefix.   <br>Mode details can be found on the Ace website, "
                      "https://ace.c9.io/.  <br><br>#### Split Panels           <br><br>Editors can be "
                      "split into multiple views of the same content.  Changes to the content are "
                      "propagated to each view, which is linked to the same content.  This means that "
                      "all changes in one will be reflected in the other editor.  Cursor positions and "
                      "display area can be independent to allow for simultaneous editing of a single "
                      "file in multiple panels.   The mechanism by which this occurs is a shared "
                      "underlying Ace  `Session`  instance.  There are some special characteristics of "
                      "the multi-pane mode.<br>When there are multiple panels open to the same editor, "
                      "and one of the editor panels is hidden, it will not be stored in the holding "
                      "tank, and will be disposed.  Like other controls, when there is only one "
                      "instance open, the control will behave in the standard form.  When hidden, the "
                      "control will be stored, not destroyed.  <br>Additionally, in the multiple-panel "
                      "mode, if the buffer is unsaved, the closing control will not ask if you want to "
                      "save the content, but will instead close.  Once the final view into the content "
                      "is reached, and the editor contained unsaved material, the user will be "
                      "prompted if they want to save or store the contents of the editor.<br>The "
                      "interface command `split_window` allows for programmatic control over this "
                      "functionality.  <br><br>### Launch Options                <br><br>Options "
                      "provided to the function allow for modification of behaviors and specific "
                      "functionality to be enabled or disabled at the time of the controls creation.  "
                      " The anything placed in the options object will be serialized when the "
                      "environment is saved, and so it is important to make sure that values must be "
                      "able to represent themselves in JSON form.   <br>clone_with_editor_id:string "
                      "-When present, the created editor instance will share an editing session with "
                      "the editor with the given id.  The given editor must be a text_editor "
                      "control.   <br>mode:string -Specifies which mode the editor should start in.  "
                      "For this to take effect, the mode must be a defined Ace editor mode (see Modes "
                      "above).  If not provided, the mode is determined by the filename if "
                      "possible.<br>on_mode_set:function -If present, this function is called with the "
                      "mode `(on_mode_set mode_name)` when the mode is changed. <br>on_save:function - "
                      "Called after a document has been saved successfully.  Since an edit session can "
                      "be shared between multiple controls that display different views, saving is "
                      "handled in a centralized way through a shared function, the  "
                      "`save_event_handler` function.  This external function receives a request and "
                      "then alerts all the editor with the same `basename`, which is set in the "
                      "options object by the control by calling their `save_complete` functions.  If "
                      "the editor has an `on_save` function in the options, then that function will be "
                      "called when the save successfully completes.<br>id:string -Specifies the "
                      "specific ID of the editor.  This is generally not required, since controls "
                      "should establish their own IDs, except when being rehydrated, they will need to "
                      "keep the ID they had prior to serialization.<br>namespace:string -Specifies the "
                      "namespace that the buffer should operate in, and reference.  If not specified, "
                      "the current namespace is used.  This is necessary if the path being edited is "
                      "in a different namespace than the current evaluation "
                      "namespace.<br>read_only:boolean -If specified as true, the buffer will start in "
                      "read only mode, and will not allow changes to the editor\'s "
                      "content,.<br>control_bar:Element -When specified, uses the element provided "
                      "with this option as the control bar as opposed to the default control "
                      "bar.  <br>on_theme_set:function -If present, this function will be called with "
                      "the new theme name when a new editor theme is set. <br>overscroll:boolean -If "
                      "true, the editor view will scroll past the final line, allowing for the final "
                      "line to be displayed in the middle regions of the view.   The default is true, "
                      "and this options must be explicitly set to false to disable.<br>filename:string "
                      "-When present, the remote file is retrieved via fetch.  The filename should "
                      "contains the relative path of the file under the root directory of the served "
                      "content.  The URL constructed to get the file is /files/filename where filename "
                      "is a path, such as /src/repl.lisp.  In this example, the final URL requested "
                      "would be of the form: `/files/src/repl.lisp`.  This option is meant to be used "
                      "in with `server_env.juno` package, which provides the HTTP-based services used "
                      "to facilitate editing the file tree of the environment.  If the path and the "
                      "filename are both provided in options. the filename is checked prior to the "
                      "path.  If this option is present, the path is is set by splitting the filename "
                      "by \"/\" and prepending the `filesystem symbol such that the "
                      "path `/src/repl.lisp` will set a path of `[ \"filesystem\" \"src\" \"repl.lisp\" "
                      "]`.  <br>repl_mode:boolean -When set to true, this places the editor into a "
                      "\"REPL\" mode, where when Control-Enter is pressed, the entire editor contents "
                      "will be submitted to the evaluator, if possible.  If no errors are received "
                      "from the evaluator for the submitted text, the contents of the editor will be "
                      "cleared, and placed in the command history structure.  If an error is returned, "
                      "the editor contents are not cleared so as to allow for correction of any "
                      "problems or issues before resubmission.   Note that when placed in REPL mode, "
                      "the editor doesn\'t signal or track if the contents need saving.  The default "
                      "for this option is false.<br>max_history_length:number - The editor keeps track "
                      "of cursor jumps that are larger than 8 rows and stores them in a history array "
                      "that can contain up to `max_cursor_positions`.  The `go_backward_in_position` "
                      "and `go_forward_in_position` functions in the text_editor closure move an index "
                      "back and forth between the stored positions.   ")

     })


(defun compute_name_for_editor (title path_to_value)
   (let
      ((others (get_editors_for_path path_to_value))
       (counter 2))
      ;(log "compute_name_for_editor: # of editors for base title: " title ": " others.length "  path: " path_to_value)
      ;(log "compute_name_for_editor: basename found: " (get_control_by_name title))
      (cond 
         (== others.length 0)
         title
         (not (get_control_by_name title))
         (progn
            ;(log "compute_name_for_editor: returning: " title)
            title)
         else
         (progn
            (while (get_control_by_name (+ title " - " counter ""))
               (inc counter))
            ;(log "compute_name_for_editor: returning: " (+ title " - " counter))
            (+ title " - " counter "")))))

(defun compute_name_for_control (name)
   (if (and (is_string? name)
            (not (blank? name)))
       (let
           ((ctl_exists? (get_control_by_name name))
            (counter 2))
          (cond
             (not ctl_exists?)
             name
             else
             (progn
                (while (get_control_by_name (+ name " - " counter ""))
                   (inc counter))
                (+ name " - " counter "")))))
   {
       `description: (+ "Given a proposed name for a control, if the name isn't " 
                        "used by another control, will return the provided name. "
                        "Otherwise, the function will return a unique non-used "
                        "name by appending a digit, starting with 2 on the control "
                        "name.  The new name will then be returned.")
       `tags: ["control" "name" "ui" "identifier"]
       `usage: ["name:string"]
   })


       

(defcontrol log_view ()
   ((output_container (div { `class: "juno-log-output juno-scrollbar" `style: "scroll-behavior: smooth;" } ))
    (options (or options { `display_options: { include_prototypes: false }}))
    (name (or options.name (name_control "log_view")))
    (parent_view nil)
    (set_show_prototypes (fn (state)
                            (progn
                               (set_prop options.display_options
                                  `include_prototypes
                                  state)
                               (log_message "show prototypes: " options.display_options.include_prototypes))))
    (display_modes [ `tree `juno `json ])
    (set_display_mode (fn (mode)
                         (progn
                            (cond
                               (is_number? mode)
                               (set_prop options.display_options
                                  `display_mode
                                  (clamp mode 0 (max_index display_modes)))
                               (and (is_string? mode)
                                    (> (index_of mode display_modes) -1))
                               (progn
                                  (set_prop options.display_options
                                     `display_mode
                                     (prop display_modes (index_of mode display_modes))))
                               else
                               (throw TypeError (+ "invalid display_mode - need string or number - got: " mode)))
                            (log_message "set display mode: " (prop display_modes options.display_options.display_mode)))))
    
    (render (fn ()
               ;(div { `tabindex: 0  `style: "background: white; color: var(--control-color); overflow: hidden; margin: 0px; padding: 0px; height: inherit; width: 100%;" }
               output_container))
    (set_display_command_button
       (fn (state)
          (progn
             (if state
                (remove_class "juno-display-none" command_button)
                (add_class "juno-display-none" command_button)))))
    (on_initialize (fn ()
                      (try
                         (progn
                            (= parent_view view.parentElement)
                            (set_style [["display" "block"]
                                        ["background" "var(--log-result-bg-color)"]
                                        ["height" "100%"]
                                        ["width" "100% ;"]
                                        ] content_view)
                            
                            (when (eq nil (prop options `display_options))
                               (set_prop options
                                  `display_options
                                  { include_prototypes: false display_mode: 0 }))
                            (when (eq nil (resolve_path [ `display_options `display_mode ] options))
                               (set_path [ `display_options `display_mode ] options 0))
                            (if (eq nil options.display_options.show_timestamps)
                                (set_show_timestamps false)
                                (set_show_timestamps options.display_options.show_timestamps))
                            (if options.hide_command_button
                               (set_display_command_button (not options.hide_command_button))))
                         (catch Error (e)
                            (notify (+ "Error: " e.message))))))
    ;; override the default resize (typically we use on_resize )
    (resize (fn ()
               (let
                  ((new_height (- (prop view.parentElement `offsetHeight) 5))
                   (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                  (when (and hide_state
                             (> new_height 5))
                     (= hide_state false)
                     (set_prop output_container
                        `scrollTop
                        1000000)
                     (set_prop view
                        `scrollTop
                        0)))))
    (content_height 0)
    (add_result (fn (result command_text error_state)
                   (progn
                      (assert initialized "log_view not initialized")
                      (defvar appended_element nil)
                      ;; unless we are at the bottom do the scroll
                      (unless (== options.smooth_scroll_mode false)
                         (when (< output_container.scrollTop (- content_height 350))
                            (set_style [[`scroll-behavior `default]] output_container)
                            (set_prop output_container `scrollTop content_height))
                         (set_style [[`scroll-behavior `smooth]] output_container))
                      
                      (when (not (eq nil command_text))
                         
                         (-> output_container
                            `append
                            (if (> command_text.length 100)
                                (details {  class: "juno-result" }
                                         (summary { `tabindex: 0 `class: "juno-code-value" } (+ (-> command_text `substr 0 100) "..."))
                                         (pre { `tabindex: 0 `class: "juno-code-value" }
                                              command_text))
                                (div {  class: "juno-result" }
                                     (pre { `tabindex: 0 `class: "juno-code-value" }
                                          command_text)))))
                      
                      (-> output_container
                         `append
                         (= appended_element
                            (div { `class: "juno-log-message"
                                   `style: (+ " margin-top: 0px; font-family: var(--main-mono-space); "
                                              (if (eq nil command_text)
                                                  "border-top: 1px solid #00000020; padding: 5px;"
                                                  "border-left: 3px solid #0167835e; padding: 5px; margin-bottom: 5px; border-bottom: 1px solid transparent;")) }
                              (value_to_dom result options.display_options))))
                      
                      (= content_height (sum (each output_container.children `offsetHeight)))
                      
                      (setTimeout (fn ()
                                     (progn
                                        ;(notify (+ "oc: " (+ content_height 540)))
                                        (set_prop output_container
                                           `scrollTop
                                           (+ content_height 540))
                                        (sleep 0.01)
                                        (when (> appended_element.parentElement.children.length
                                                 (or options.max_log_lines
                                                    *env_config*.application.max_log_lines
                                                    10))
                                           (-> (first appended_element.parentElement.children)
                                               `remove))))
                                  100)
                      (set_prop view
                         `scrollTop
                         0)
                      
                      result)))
    (set_max_log_lines (fn (val)
                          (when (is_number? val)
                             (set_prop options
                                `max_log_lines
                                val)
                             ;(while (> output_container.children.length options.max_log_lines)
                             ; (-> (first output_container.children)
                             ;    `remove))
                             true)))
    (set_show_timestamps (fn (state)
                            (if state
                               (progn
                                  (= ts_hidden_state "")
                                  (set_prop options.display_options
                                     `show_timestamps true)
                                  (when view  ;; surround in try catch in case we aren't completely ready
                                     (try
                                        (apply remove_class "juno-display-none" (or (-> view `querySelectorAll ".juno-timestamp") []))
                                        (catch Error (e)
                                           nil))))
                               
                               (progn
                                  (set_prop options.display_options
                                     `show_timestamps false)
                                  (= ts_hidden_state "juno-display-none")
                                  (when view
                                     (try
                                        (apply add_class "juno-display-none" (-> view `querySelectorAll ".juno-timestamp"))
                                        (catch Error (e)
                                           nil)))))))
    (set_smooth_scroll_mode (fn (state)
                               (if state
                                  (progn
                                     (set_prop options
                                        `smooth_scroll_mode true)
                                     (set_style [[`scroll-behavior `smooth]] output_container))
                                  (progn
                                     (set_prop options
                                        `smooth_scroll_mode false)
                                     (set_style [[`scroll-behavior `default]] output_container)))))
    
    (menu_items (fn ()
                   [[(dtext "Clear Log")
                     (fn ()
                        (-> output_container `replaceChildren))]
                    [(dtext "Set Max Log Lines")
                     (fn ()
                        (aif (request_user_input (+ (dtext "Enter the number of log lines to keep") ":") `number { `default_value: (or options.max_log_lines
                                                           *env_config*.application.max_log_lines) })
                             (set_max_log_lines it)))]
                    [(+ (dtext "Display Mode") "...")
                     [[(dtext "Tree")
                       (fn ()
                          (set_display_mode 0))]
                      [(dtext "Juno")
                       (fn ()
                          (set_display_mode 1))]
                      [(dtext "JSON")
                       (fn ()
                          (set_display_mode 2))]]]
                    
                    [(if (blank? ts_hidden_state)
                         (dtext "Hide Timestamps")
                         (dtext "Show Timestamps"))
                     (fn ()
                        (if (blank? ts_hidden_state)
                            (set_show_timestamps false)
                            (set_show_timestamps true)))]
                    (if (== options.smooth_scroll_mode false)
                        [(dtext "Turn On Smooth Scrolling")
                         (fn ()
                            (set_smooth_scroll_mode true))]
                        [(dtext "Turn Off Smooth Scrolling")
                         (fn ()
                            (set_smooth_scroll_mode false))])
                    [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                     (fn ()
                        (set_show_prototypes (not options.display_options.include_prototypes)))]]))
    (hide_state nil)
    (ts_hidden_state "")
    (on_hide (fn ()
                (progn
                   (= hide_state true))))
    
    (on_focus (fn ()
                 (progn
                    (= hide_state false)
                    (add_class "juno-focused" control_status)))) ;; we know that is the command bar
    
    (log_message (fn (highlight_color `& args)
                    (progn
                       (defvar display_mode (or options.display_options.display_mode 0))
                       (add_result (div { tabindex: 0 style: (+ "display: flex; justify-content: flex-start; align-items: flex-start; " (if (is_string? highlight_color) (+ "background: " highlight_color) "")) }
                                        (div { class: (+ "juno-timestamp " ts_hidden_state) `timestamp: (time_in_millis)  } (formatted_date (new Date)))
                                        (div { style: "display: flex; justify-content: flex-start; align-items: flex-start; " }
                                             (for_each (v args)
                                                (cond
                                                   (is_string? v)
                                                   (div { `tabindex: 0 `class: "juno-value juno-type-string" `style: "display: inline-block; padding-left: 10px" } v)
                                                   (is_number? v)
                                                   (div { `tabindex: 0 `class: "juno-value juno-type-number" `style: "display: inline-block; padding-left: 10px" } v)
                                                   (or (== v true) (== v false))
                                                   (div { `tabindex: 0 `class: "juno-value juno-type-boolean" `style: "display: inline-block; padding-left: 10px" } v)
                                                   else
                                                   (div { `tabindex: 0 `class: "juno-value" `style: "display: inline-block; padding-left: 10px" }
                                                        (cond
                                                           true ;(== display_mode 0)
                                                           (value_to_dom v)
                                                           (== display_mode 1)
                                                           (pre (pretty_print v))
                                                           (== display_mode 2)
                                                           (pre (JSON.stringify v nil 2))))))))
                                   nil nil)
                       nil)))
    (log_standard (fn (`& args)
                     (try
                        (apply log_message nil args)
                        (catch Error (e)
                           (log "Error: " e.message)))))
    (log_problem (fn (error_message error_instance)
                    (log_message "#FF404010" error_message error_instance))))
   {
     expose: [[`set_show_timestamps set_show_timestamps]
              [`set_show_prototypes set_show_prototypes]
              [`clear (function ()
                         (-> output_container `replaceChildren))]
              [`set_display_command_button set_display_command_button]
              [`set_display_mode set_display_mode]
              [`display_mode (function ()
                                (prop display_modes options.display_options.display_mode))]
              [`display_modes (function ()
                                 display_modes)]
              [`set_smooth_scroll_mode set_smooth_scroll_mode]
              [`output_container output_container]
              [`control_bar control_status]
              [`append add_result]
              [`log_message log_standard ]
              [`log_error log_problem ]]
     frame_style: "overflow: hidden;"
     control_bar: true
     usage: ["options:object"]
     
     })


(defun process_remote_eval_result (result display_mode)
   (if (is_object? result)
       (try
          (let
             ((is_system_error? (== "FAIL" result.rval))
              (is_compiler_error? (and (resolve_path [ `result 0 `error ] result)
                                       (resolve_path [ `result 0 `message ] result)))
              (process_tree (fn (quoted_lisp)
                               (progn
                               (try
                                  (cond
                                     (and (is_array? quoted_lisp)
                                          (== quoted_lisp.0 (quote javascript)))
                                     (progn
                                        (if (== display_mode `tree)
                                            (remote_function_to_dom
                                               (set_prop (fn_signature quoted_lisp.1)
                                                         `body
                                                         quoted_lisp.1))
                                            quoted_lisp))
                                     
                                     (and (== display_mode `tree)
                                          (is_array? quoted_lisp)
                                          (== quoted_lisp.0 (quote new))
                                          (contains? quoted_lisp.1 [(quote RegExp)]))
                                     (try
                                        (eval quoted_lisp)
                                        (catch Error (e)
                                           quoted_lisp))
                                     (is_array? quoted_lisp)
                                     (for_each (val quoted_lisp)
                                        (process_tree val))
                                     (is_object? quoted_lisp)
                                     (to_object
                                        (for_each (val (pairs quoted_lisp))
                                           [val.0 (process_tree val.1)]))
                                     else
                                     quoted_lisp)
                                  (catch Error (e)
                                     (progn
                                        (log "ERROR: " e)
                                        e.message)))))))
            ;(log "process_remote_eval_result: "  is_system_error? "display_mode: " display_mode ": result: " result)
             (cond
                (and (or (== display_mode `juno)
                         (== display_mode `json))
                     (contains? result.result_type ["Function" "AsyncFunction"]))
                `(javascript ,#result.result.body)
                    
                (or (== display_mode `juno)
                    (== display_mode `json))
                (process_tree (if (is_string? result.result)
                                  (read_lisp result.result)
                                  result.result))
                (and is_system_error?
                   (is_array? result.result))
                (progn
                   (log "system_error: array")
                   (for_each (r result.result)
                      (div { `style: "border-left: 5px solid red; padding: 5px;" }
                           (+ r.error ": " r.message)
                           (value_to_dom r))))
                (and is_system_error?
                   (is_object? result))
                (progn
                   (div { `style: "border-left: 5px solid red; padding: 5px;" }
                        (+ result.result_type ": " result.message)
                        (value_to_dom result)))
                
                is_compiler_error?
                (progn
                   (notify (+ "Error: " is_compiler_error?))
                   (div { `style: "border-left: 5px solid red; padding: 5px;" }
                        (if (== (length result.result) 1)
                            (value_to_dom result.result.0)
                            (value_to_dom result.result))))
                
                (ends_with? "unction" result.result_type)
                (progn
                   (remote_function_to_dom result.result))
                (and result.needs_eval
                   (== display_mode `juno))
                (as_lisp (read_lisp result.result))
                (and result.needs_read
                   (== display_mode `juno))
                (as_lisp (read_lisp result.result))
                result.needs_eval  ;; if json form returned and is a local compile
                (eval_struct (read_lisp result.result))
                result.needs_read  ;; if juno form returned and is a local compile `
                (read_lisp result.result)
                (is_string? result.result)
                (try 
                   (progn
                      (process_tree (read_lisp result.result)))
                   (catch Error (e)
                      (progn
                         (log "Error on result: " e.message result)
                      result.result)))
                else
                result.result))
          (catch Error (e)
             (list e.message result)))
       ;(log "process_remote_eval_result: returning: " result)
       result))


(defun create_remote_evaluator(options)
   (new Promise 
      (fn (resolve_fn reject_fn)
        (let
           ((repl_ws nil)
            (url (or options.url (+ "ws://" window.location.host "/connect_repl")))
            (name (or options.name "remote"))
            (remote_command_timeout (or options.timeout 120000)) ;; 2 minute default
            (requests {})
            (process_mode `eval)
            (active_ns nil)
            (on_message (or options.on_message
                            (fn (message)
                               (log (+ name ": message: ") message))))
            (request_id 0)
            (is_initial_open? true)
            (send_wait (fn (lisp_text opts)
                          (let
                             ((rval nil))
                             (assert (and (instanceof repl_ws WebSocket)
                                          (== repl_ws.readyState repl_ws.OPEN))
                                     "Websocket is not open")
                             ;(clog "ws-> ")
                             (try
                                (= rval (new Promise
                                             (fn (resolve reject)
                                                (let
                                                   ((my_request_id (inc request_id))
                                                    (timer nil))
                                                   (= timer (setTimeout (fn ()
                                                                           (progn
                                                                              (log "timeout occurred")
                                                                              (reject { `rval: "FAIL" `message: (+ "Timeout on request id: " my_request_id) })))
                                                                        remote_command_timeout))
                                                   ;; set the request id in request object, and then wait to resolve the promise until results are returned, or a timeout occurs
                                                   (set_prop requests
                                                      my_request_id
                                                      (list resolve reject timer))
                                                   (try
                                                      (http/send_to_ws repl_ws
                                                                       { `command: "eval"
                                                                         `req_id: request_id
                                                                         `args: [ lisp_text ] })
                                                      (catch Error (e)
                                                         (progn
                                                            (notify (+ "send_wait: error: " e.message))
                                                            (log "ERROR on send_to_ws: " e))))
                                                   true))))
                                (catch Error (e)
                                   (log (+ "Error on send_wait: " e))))
                             rval)))
            (process_result (fn (result)
                               (cond
                                  (== process_mode "display")
                                  (process_remote_eval_result result `tree)
                                  (== process_mode "eval")
                                  (eval_struct (process_remote_eval_result result `juno))
                                  (== process_mode "quoted")
                                  (process_remote_eval_result result `juno))))
            (setup_connection
               (fn ()
                  (http/create_websocket
                     url
                     {
                       `on_message: (fn (event)
                                       (try
                                          (let
                                             ((data nil)
                                              (pdata nil)
                                              (resolver nil))
                                             
                                             (try
                                                (= data (JSON.parse event.data))
                                                (catch Error (e)
                                                   (progn
                                                      (log "Unable to parse json data: " e.message)
                                                      (= data event.data))))
                                             (if options.debug
                                                (log (+ name ": <-")  data))
                                             (if (and (is_object? data)
                                                      data.ws_id)
                                                 (set_prop intf
                                                    `ws_id
                                                    data.ws_id))
                                             (cond
                                                (and (is_object? data)
                                                     data.req_id)
                                                (progn
                                                   (if (prop requests data.req_id)
                                                       (progn
                                                          (= pdata (prop requests data.req_id))
                                                          (remove_prop requests data.req_id)
                                                          (clearTimeout (third pdata)) ;; remove the timeout
                                                          (if (== data.rval "OK")
                                                              (progn
                                                                 (= resolver (first pdata))
                                                                 (resolver data nil))
                                                              (progn
                                                                 (= resolver (first pdata)) ;; we will resolve the promise and handle the error in our remote eval result function.
                                                                 (resolver data true))))
                                                       (progn
                                                          ;; received a request but it is not tied to a request we made, could be a log message
                                                          (if (== data.rval "OK")
                                                              (on_message data)))))
                                                (and (is_object? data)
                                                     data.result)
                                                (progn
                                                   (on_message data))
                                                else
                                                (if options.debug
                                                   (log (+ "" name ": unknown response: ")  data))))
                                          (catch Error (e)
                                             (log "Unable to process received message: " e.message))))
                       `on_open: (fn (event)
                                    (progn
                                       (defvar ns_change_result nil)
                                       (if options.debug
                                          (log (+ "Connected to Remote REPL: " options.remote_repl)))
                                       (try
                                          (when active_ns
                                             (= ns_change_result (prop (send_wait (+ "(use_ns " active_ns ")")) `result))
                                             (if ns_change_result
                                                (= active_ns ns_change_result)
                                                (log (+ "Namespace set to: " (JSON.parse active_ns)))
                                                (log "Unable to set namespace")))
                                          (catch Error (e)
                                             (log "Unable to set to active namespace: " e)))
                                       (when is_initial_open?
                                          (= is_initial_open? false)
                                          (resolve_fn intf))))
                       
                       `on_close: (fn (event)
                                     (progn
                                        (if options.on_close
                                           (options.on_close event intf)
                                           (log (+ name ": socket closed")))))
                       `on_error: (fn (event)
                                     (progn
                                        (if options.on_error
                                           (options.on_error event intf)
                                           (log (+ name ": error on WS:" event)))))
                       })))
           (intf {}))
        (= repl_ws (setup_connection))
        (= intf
           {
             process_mode: (function ()
                              process_mode)
             set_process_mode: (function (mode)
                                  (cond
                                     (== mode `display)
                                     (= process_mode `display)
                                     (== mode `eval)
                                     (= process_mode `eval)
                                     (== mode `quoted)
                                     (= process_mode `quoted)
                                     else
                                     (throw Error "invalid return mode")))
             evaluate: (fn (val)
                          (progn
                             (defvar result (send_wait val))
                             (process_result result)))
             url: (fn ()
                     url)
             on_message: on_message
             eval: (fn (quoted_lisp)
                      (progn
                         (defvar result (send_wait (as_lisp quoted_lisp)))
                         (process_result result)))
             ws: repl_ws
             close: (fn ()
                       (-> repl_ws `close))
             open?: (fn ()
                       (== (prop repl_ws `readyState) 1))
             state: (fn ()
                       (prop repl_ws `readyState))
             connect: setup_connection
             })))))


(defun process_stack_trace (result)
   (try
      (let
         ((first_anon nil)
          (line_num nil)
          (col_num nil)
          (src (or result.result.compiled
                   result.compiled))
          (buffer []))
         (for_each (message (split_by "\n" result.stack))
            (when (eq nil first_anon)
               (for_each (m (split_by "," message))
                  (when (and (eq nil first_anon)
                             (starts_with? " <anonymous>" m))
                     (= first_anon (rest (split_by ":" m)))
                     (break)))))
         (defglobal *ll* result)
         (if (not (blank? first_anon))
             (progn
                (= line_num (parseInt (first first_anon)))
                (= col_num (parseInt (second first_anon)))
                (push buffer
                   (+ "Line: " (- line_num 3) " Column: " col_num))
                
                (when src
                   (= src (split_by "\n" src))
                   (map (fn (v idx)
                           (when (and (> idx (- line_num 5))
                                      (< idx (+ line_num 5)))
                              (if (== idx (- line_num 3))
                                  (progn
                                     (push buffer
                                        (+ " -> " (pad_left idx 5 " ") ": " v))
                                     (push buffer
                                        (+ "    " "       " (pad_left "^" col_num " "))))
                                  (push buffer
                                     (+ "    " (pad_left idx 5 " ") ": " v)))))
                        src))
                (join "\n" buffer))
             (progn
                "Unable to find source line")))
      (catch Error (e)
         (progn
            "Unable to process stack trace: unknown structure"))))

(defglobal *repl_counter* 0)

(defun visual_repl (options)
  (let
      ((options (or options {}))
       (name (progn
                (cond
                   (and options.name
                      (get_control_by_name options.name))
                   (progn
                      (inc *repl_counter*)
                      (+ options.name " - " *repl_counter*))
                   else
                   (progn
                      (inc *repl_counter*)
                      (+ "Visual REPL - " *repl_counter*)))))
       (resize_observer nil)
       (id (or options.id (generate_id "repl")))
       (namespace_span  (span { `title: "REPL Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } (current_namespace)))
       (display_mode_span (span { `title: (dtext "Display Mode") `class: "juno-mode" style: "float: right;"} "INIT"))
       (location_span (span { `title: "Location" `style: "float: right; display:inline-block; padding-left: 10px; padding-right: 10px;" } 
                          (if options.remote_repl
                                   "Connecting"
                                   "Browser")))
       (control_button (commands_button id));  { `title: "REPL Commands" } "⋯"))
       (title_span (span { `class: "juno-title"  `style: "cursor: pointer;"} name))
       (show_prototype_details_button (button { `title: (dtext "Show Object Prototype Detail") } "P"))
       (path_span (span { `tabindex: 0 `title: (dtext "Click to copy focused path")  `class: "juno-path" } ""))
       (current_env Environment)
       (error_state nil)
       (reopen_button (button { `title: (dtext "Connect/Disconnect") `class: "juno-button-on" style: "float: right;" `tabindex: 0 `disabled: true }
                              "-"))
       (set_reopen_button_state (fn (state)
                                   (cond
                                      (== state 2) ;; allow reconnect
                                      (progn
                                         (set_enabled reopen_button)
                                         (set_attribute reopen_button `title "Reconnect")
                                         (remove_class "juno-button-on" reopen_button))
                                      (== state 1) ;; connecting
                                      (progn
                                         (set_disabled reopen_button)
                                         (add_class "juno-button-on" reopen_button))
                                      else ;; connected state
                                      (progn
                                         (set_attribute reopen_button `title "Disconnect")
                                         (set_enabled reopen_button)
                                         ;(remove_class "juno-button-on" reopen_button)
                                         ))))
       
       (remote_command_timeout 120000) ;; 2 minute default
       (initialized false)       
       (intf nil)       
       (toggle_prototype_detail (function ()
                                          (progn                                           
                                           (set_prop options.display_options
                                                     `include_prototypes
                                                     (not options.display_options.include_prototypes))
                                           (set_prop output_control.options.display_options                                                     
                                                     `include_prototypes options.display_options.include_prototypes)
                                           (if options.display_options.include_prototypes
                                             (add_class "juno-button-on" show_prototype_details_button)
                                             (remove_class "juno-button-on" show_prototype_details_button)))))
       (output_control (progn
                          (log_view { `display_options: (or options.display_options { `show_timestamps: false } )
                                                         `hide_command_button: true
                                                         `additional_elements: [ control_button 
                                                                                 title_span 
                                                                                 show_prototype_details_button 
                                                                                 namespace_span 
                                                                                 path_span
                                                                                 display_mode_span 
                                                                                 location_span
                                                                                 (if options.remote_repl reopen_button [])] 
                                                         `id: id })))
       (history (if (is_array? options.history)
                  options.history
                  []))
       (rename (fn (new_name)
                  (if (is_string? new_name)
                      (cond
                         (get_control_by_name new_name)
                         (throw Error (+ "control with name '" new_name "' already exists"))
                         else
                         (try
                            (progn
                               (set_prop options `name
                                  new_name)
                               (set_prop title_span
                                  `innerHTML
                                  new_name)
                               (set_prop intf
                                  `name
                                  new_name)
                               (= name new_name)
                               (dispatch_event { command: "control_name_change"
                                                 source: options.id
                                                 args: [ { `option: "name" `value: name } ] }))
                            (catch Error (e)
                               (progn
                                  (log  (+ "Unable to rename: " e.message)))))))))
      (prompt_rename (fn ()
                        (aif (request_user_input (+ (dtext "Rename") ": " intf.name)
                                            `text)
                             (rename it))))
      (clog (fn (`& args)
               (progn
                  (apply console.log args)
                 
                  (-> intf `log (apply div { `style: "display: flex;" }
                                       (for_each (val args)
                                          (div { `style: "padding-right: 10px" } (value_to_dom val)))))
                  nil)))
       (push_history (fn (lisp_text)
                       (progn
                        (push history
                                lisp_text)
                        (= history_idx history.length)
                        (when (> history.length (or options.max_history_size
                                                    50))
                          (take history)))))
       (history_idx 0) 
       (history_prior_entry (fn ()
                              (when (> history.length 0)
                                 (dec history_idx)
                                 (when (or (< history_idx 0)
                                           (>= history_idx history.length))
                                    (= history_idx history.length))
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (-> input_container `set (prop history history_idx)))
                               )))
       (history_next_entry (fn ()
                              (when (> history.length 0)
                                 (inc history_idx)
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (progn
                                        (if (>= history_idx history.length)
                                            (= history_idx 0))
                                        (-> input_container `set (prop history history_idx)))))))
       (clear_output (fn ()
                       (-> output_control `clear)))
       (clear_history (fn ()
                        (progn
                         (= history [])
                         (= history_idx 0))))
       
       (repl_key_bindings (function ()
                                    (map (function (kb)
                                             (destructuring_bind (command_name bindings)
                                                 kb                                                                                                                  
                                                 { name: command_name
                                                   mac: (prop bindings `mac)
                                                   win: (prop bindings `win)
                                                  exec: (function (editor)
                                                                  (-> intf command_name editor)) }))                                                                                                                                                                  
                                         (or (pairs *key_bindings*.repl) []))))
       (repl_ws nil)
       (request_id 0)
       (requests {})
       (remote_host nil)
       (cached_symbols {})
       (busy_with_cache_update false)
       (available_symbols (fn ()
                             (progn
                                (while busy_with_cache_update
                                   (sleep 0.2))
                                (= busy_with_cache_update true)
                                (if options.remote_repl
                                   (let
                                      ((result (try
                                                  (send_wait "(symbols_by_namespace { include_meta: true })")
                                                  (catch Error (e)
                                                     (progn
                                                        (log "ERROR on available_symbols: remote: " e)
                                                        nil)))))
                                      (if result
                                         (progn
                                            (try 
                                               (= result (read_lisp result.result))
                                               (catch Error (e)
                                                  (log "ERROR on available_symbols update: " result)))
                                            (= busy_with_cache_update false)
                                            result)
                                         (progn
                                            (= busy_with_cache_update false)
                                            {})))
                                   (progn
                                      (= busy_with_cache_update false)
                                      (symbols_by_namespace { include_meta: true }))))))
       (open_remote_evaluator 
          (fn ()
             (if options.remote_repl
                (progn
                   (= repl_ws
                      (http/create_websocket
                         options.remote_repl
                         {
                           `on_message: (fn (event)
                                           (try
                                              (let
                                                 ((data nil)
                                                  (pdata nil)
                                                  (resolver nil))
                                                 
                                                 (try
                                                    (= data (JSON.parse event.data))
                                                    (catch Error (e)
                                                       (progn
                                                          (clog "Unable to parse json data: " e.message)
                                                          (= data event.data))))
                                                 (if options.debug
                                                    (clog "remote: <-" data))
                                                 (if (and (is_object? data)
                                                          data.ws_id)
                                                     (set_prop intf
                                                        `ws_id
                                                        data.ws_id))
                                                 (cond
                                                    (and (is_object? data)
                                                         data.req_id)
                                                    (progn
                                                       (if (prop requests data.req_id)
                                                           (progn
                                                              (= pdata (prop requests data.req_id))
                                                              (remove_prop requests data.req_id)
                                                              (clearTimeout (third pdata)) ;; remove the timeout
                                                              (if (== data.rval "OK")
                                                                  (progn
                                                                     (= resolver (first pdata))
                                                                     (resolver data nil))
                                                                  (progn
                                                                     (= resolver (first pdata)) ;; we will resolve the promise and handle the error in our remote eval result function.
                                                                     (resolver data true))))
                                                           (progn
                                                              ;; received a request but it is not tied to a request we made, could be a log message
                                                              (if (== data.rval "OK")
                                                                  (clog "ASYNC: " data.result)
                                                                  (clog data.message)))))
                                                    (and (is_object? data)
                                                         data.result
                                                         data.is_log)
                                                    (clog (pretty_print (read_lisp data.result)))
                                                    (and (is_object? data)
                                                         data.result)
                                                    (progn
                                                       (-> output_control `log_message (process_remote_eval_result data (-> output_control `display_mode))))
                                                    else
                                                    (clog data)))
                                              (catch Error (e)
                                                 (clog "Unable to process received message: " e.message))))
                           `on_open: (fn (event)
                                        (progn
                                           (defvar active_ns nil)
                                           (clog (+ "Connected to Remote REPL: " options.remote_repl))
                                           (set_reopen_button_state 0)
                                           (try
                                              (progn
                                                 (= remote_host (prop (send_wait "(hostname)") `result))
                                                 (cond 
                                                    (is_string? remote_host)
                                                    (progn
                                                       (= remote_host (chop_front (chop remote_host)))
                                                       (set_prop location_span
                                                          `innerHTML remote_host))
                                                    else
                                                    (clog "ERROR: received invalid response for hostname: " remote_host))
                                                 (= active_ns (prop (send_wait (+ "(use_ns " namespace_span.innerText ")")) `result))
                                                 (if active_ns 
                                                    (clog (+ "Namespace set to: " (JSON.parse active_ns)))
                                                    (clog "Unable to set namespace")))
                                              (catch Error (e)
                                                 (clog "Unable to determine remote hostname: " e)))))
                           `on_close: (fn (event)
                                         (progn
                                            (clog "Interface is now closed")
                                            (set_reopen_button_state 2)))
                           `on_error: (fn (event)
                                         (progn
                                            (set_reopen_button_state 2)
                                            (clog "Error on WS:" event)))
                           }))
                   (defglobal *repl_ws* repl_ws)))))
       (send_wait (fn (lisp_text opts)
                     (let
                        ((rval nil))
                        (assert (and (instanceof repl_ws WebSocket)
                                     (== repl_ws.readyState repl_ws.OPEN))
                                "Websocket is not open")
                        ;(clog "ws-> ")
                       (try
                          (= rval (new Promise 
                                       (fn (resolve reject)
                                          (let
                                             ((my_request_id (inc request_id))
                                              (timer nil))
                                             (= timer (setTimeout (fn ()
                                                                     (progn
                                                                        (clog "timeout occurred")
                                                                        (reject { `rval: "FAIL" `message: (+ "Timeout on request id: " my_request_id) })))
                                                                  remote_command_timeout))
                                             ;; set the request id in request object, and then wait to resolve the promise until results are returned, or a timeout occurs
                                             (set_prop requests
                                                my_request_id
                                                (list resolve reject timer))
                                             (try 
                                                (http/send_to_ws repl_ws
                                                                 { `command: "eval"
                                                                   `req_id: my_request_id
                                                                   `args: [ lisp_text ] })
                                                (catch Error (e)
                                                   (progn
                                                      (notify (+ "send_wait: error: " e.message))
                                                      (clog "ERROR on send_to_ws: " e))))
                                             true))))
                             (catch Error (e)
                                (log (+ "Error on send_wait: " e))))
                       rval)))
                                                
       

       (evaluator (fn (lisp_text no_eval no_clear no_log opts)
                    (let
                        ((result nil)
                         (processed_result nil)
                         (current_ns (prop namespace_span `innerText))
                         (display_mode (-> output_control `display_mode))
                         (compiled_metadata nil)
                         (compiled_source nil)
                         (compl_complete (fn (compilation_results)
                                            (progn
                                               (= compiled_metadata compilation_results.0)
                                               (= compiled_source compilation_results.1)))))
                        (setq error_state nil)
                        (setq compiled_source nil)
                        (setq compiled_metadata nil)
                        (if options.remote_repl
                         (progn
                            (try
                               (progn
                                  (= result (send_wait lisp_text)))
                               (catch Error (e)
                                  (do
                                     (= error_state true)
                                     (when e.message
                                        (notify (+ "Remote Error: " e.message))))))
                            (when (is_object? result)
                               (if (not (== result.namespace current_ns))
                                   (dispatch_event {
                                                     command: "evaluator_change"
                                                     source: id
                                                     args: [{ set: "namespace" value: result.namespace }]
                                                    }))
                               (set_prop namespace_span
                                  `innerText
                                  (or result.namespace "Unknown!")))
                            (cond 
                               (== display_mode "juno")
                               (= processed_result (pre (pretty_print (process_remote_eval_result result display_mode))))
                               (== display_mode "json")
                               (= processed_result (pre (JSON.stringify (process_remote_eval_result result display_mode) nil 2)))
                               else
                               (= processed_result (process_remote_eval_result result display_mode)))
                            ;; set the results to be returned to the caller 
                            ;; they will not be dressed up in Elements if tree mode
                            (when (and (is_object? result)
                                       (is_string? result.result))
                               (set_prop result
                                  `result
                                  (read_lisp result.result)))
                            
                            (unless no_log
                               (-> output_control `append processed_result lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set ""))
                            (= result
                               (cond
                                  (is_array? result)
                                  result
                                  (is_object? result)
                                  result.result
                                  else
                                  result)))
                            
                         (progn
                            (setq current_env (-> Environment `get_namespace_handle (current_namespace)))
                            (try
                               (= result (if no_eval
                                             lisp_text
                                             (-> current_env `evaluate lisp_text {} (+ { `throw_on_error: true `on_compilation_complete: compl_complete } (if opts opts {})))))
                               (catch Error (ex)
                                  (do
                                     (= error_state true)
                                     (console.error "ERROR: " ex)
                                     (notify (+ (sub_type ex) ": " ex.message))
                                     (when  ex.details
                                        (log "Caught error: " ex.details)
                                        (when compiled_source
                                           (set_prop ex.details
                                              `compiled
                                              compiled_source
                                              `compiled_metadata
                                              compiled_metadata
                                              `stack 
                                              ex.stack)
                                           (set_prop ex.details
                                                     `problem_buffer
                                                     (pre (process_stack_trace ex.details))))
                                           
                                        (when (and ex.details.expanded_source
                                                   (== display_mode "tree"))
                                           (set_prop ex.details
                                              `expanded_source
                                              (pre ex.details.expanded_source)
                                              `compiled
                                              (pre ex.details.compiled))))
                                        (= result ex.details))))
                            (console.log "<-" result)
                            (cond 
                               (== display_mode "juno")
                               (= result (pre (pretty_print result)))
                               (== display_mode "json")
                               (= result (pre (JSON.stringify result nil 2))))
                            (set_prop namespace_span
                               `innerText
                               (current_namespace))
                            (unless no_log
                               (-> output_control `append result lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set ""))))
                            
                      result)))
       (input_container_name (+ (gen_id "visual_repl") "-input"))
       (input_container (text_editor 
                                  {
                                   mode: "juno"                                                                                                                             
                                   on_change: (function (editor val)
                                                        (progn
                                                         true))
                                   name: input_container_name
                                   theme: options.theme
                                   id: id
                                   evaluator_id: id
                                   disallow_control_focus: true
                                   clone_with_editor_id: options.clone_with_editor_id
                                   repl_mode: true
                                   display_control_bar: false
                                   on_evaluation: (fn (lisp_text results)
                                                     (push_history lisp_text))
                                   commands: (repl_key_bindings)
                                   on_initialized: (fn (control)
                                                       (when initialized
                                                          (try
                                                             (-> control.editor `focus)
                                                             (catch Error (e)
                                                                (log "error on focus: " e.message)))))
                                                       }))

       (sview (split_view_horizontal
                                 output_control
                                 input_container
                                 { `ratio: (or options.ratio 0.7) `id: id } ))  ;; 80/20 top-bottom
       
       (view sview.view)
       (non_whitespace_regex (new RegExp "\\\\s"))
       (on_focus (fn ()
                   (progn
                    ;(-> input_container.editor `focus) ;; bring focus to the repl
                    (add_class "juno-focused" output_control.control_bar )
                    (set_prop intf
                       `editor
                       (resolve_path [ `editor_container `editor ] intf)))))
       (on_blur (fn ()
                  (progn
                   true)))
       (destroy (fn ()
                  (if options.locked
                     (throw EvalError (+ "" options.name " is marked as locked and cannot be destroyed"))
                     (progn
                        (if options.remote_repl
                            (try
                               (progn
                                  (log "remote_repl state: " repl_ws.readyState)
                                  (when (== repl_ws.readyState repl_ws.OPEN)
                                     (log "remote_repl: closing open connection on destroy. ")
                                     (-> repl_ws `close))
                                  (log "remote_repl state: clean up complete."))
                               (catch Error (e)
                                  (log "remote_repl: couldn't close the socket: " e.message))))
                           
                        (-> input_container `destroy)))))
       (modes { `tree: 0 `juno: 1 `json: 2 } )
       (set_display_mode (fn (mode)
                            (let
                               ((modenum (cond
                                            (is_string? mode)
                                            (or (prop modes (lowercase mode)) 0)
                                            (is_number? mode)
                                            mode
                                            else 
                                            0)))
                               (-> output_control `set_display_mode modenum)
                               (set_prop options.display_options `display_mode modenum)
                               (set_prop display_mode_span
                                  `innerText (-> output_control `display_mode)))))
       (menu_items (fn ()
                     [[(dtext "Clear Output Log")
                       (function ()
                                 (clear_output))]
                      [(dtext "Clear REPL History")
                       (function ()
                                 (clear_history))]
                      [(dtext "Rename")
                       prompt_rename ]
                      [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                       (function ()
                                 (toggle_prototype_detail))]
                      
                      
                      [(if output_control.options.display_options.show_timestamps
                         (dtext "Hide Timestamps")
                         (dtext "Show Timestamps"))
                       (function ()
                                 (progn
                                    (if output_control.options.display_options.show_timestamps
                                       (-> output_control `set_show_timestamps false)
                                       (-> output_control `set_show_timestamps true))
                                    (set_prop options.display_options
                                              `show_timestamps
                                              output_control.options.display_options.show_timestamps)))]
                      [(dtext "Set Max Log Lines")
                       (fn ()
                         (aif (request_user_input (+ (dtext "Enter the number of log lines to keep") ":") `number { `default_value: (or options.max_log_lines
                                                                                                                                        *env_config*.application.max_log_lines) })
                              (-> output_control `set_max_log_lines it)))]
                      [(+ (dtext "Set Display Mode") "...")
                       [[(dtext "Tree")
                         (fn ()
                            (set_display_mode `tree))]
                        [(dtext "Juno")
                         (fn ()
                            (set_display_mode `juno))]
                        [(dtext "JSON")
                         (fn ()
                            (set_display_mode `json))]]]
                      (if (== output_control.options.smooth_scroll_mode false)
                          [(dtext "Turn On Smooth Scrolling")
                           (fn ()
                              (-> output_control `set_smooth_scroll_mode true))]
                          [(dtext "Turn Off Smooth Scrolling")
                            (fn ()
                               (-> output_control `set_smooth_scroll_mode false))])
                      [(dtext "Set Editor Theme") (for_each (theme *editor_themes*)
                                                            [theme  (fn ()
                                                                      (progn
                                                                       (set_prop options `theme theme)
                                                                       (-> input_container `set_theme theme)))])]]))
       (initialize (fn ()
                     (progn
                      (if initialized
                        false
                        (progn
                         (= initialized true)
                         (console.log "repl initializing")
                         (try
                            (-> output_control `initialize)
                            (catch Error (e)
                               (notify e.message)))
                         (when (eq nil options.display_options)
                           (set_prop options
                                     `display_options
                                     { `include_prototypes: false 
                                       `show_timestamps: output_control.options.display_options.show_timestamps 
                                       `display_mode: (or output_control.options.display_options.display_mode 0)
                                     }))
                         
                         (if options.display_options.include_prototypes
                           (add_class "juno-button-on" show_prototype_details_button))
                         (try
                            (if options.remote_repl
                               (progn
                                  (clog  (html/div { `style: "display: flex padding: 5px" }                
                                                                       (html/span { `style: "font-weight: bold; display: inline-block;" } "connecting to: ")
                                                                       (html/span { `style: "display: inline-block; margin-left: 10px;" }
                                                                                  options.remote_repl )))
                                  
                                  (open_remote_evaluator)))
                            (catch Error (e)
                               (clog "Cannot open remote REPL: " e.message)))
                         (unless options.remote_repl
                            (-> output_control `append (html/div { `style: "display: flex padding: 5px" }
                                                                 (html/span { `style: "font-weight: bold; display: inline-block;" } "Juno REPL")
                                                                 (html/span { `style: "display: inline-block; margin-left: 10px;" }
                                                                            "Version: " Environment.build_version   ))))
                         (set_prop reopen_button
                            `innerHTML
                            "&#9211;")
                         (attach_event_listener reopen_button
                            `click
                            (fn (e)
                               (progn
                                  ;(clog "repl readyState: " (prop repl_ws `readyState))
                                  (cond
                                     (== (prop repl_ws `readyState) 1)
                                     (progn 
                                        (-> repl_ws `close))
                                     else
                                     (progn
                                        (set_reopen_button_state 1)
                                        (open_remote_evaluator))))))
                         (attach_event_listener title_span
                            `click
                            prompt_rename)
                         ;; set the computed name
                         (set_prop options
                            `name
                            name)
                         (log output_control.options)
                         (setTimeout (fn ()
                                        (set_prop display_mode_span
                                           `innerText (-> output_control `display_mode)))
                                     100)
                         ;; become the system_repl if none is yet defined
                         (if (eq nil *system_repl*)
                             (progn
                                (= *system_repl* intf)
                                (set_prop options
                                   `locked true)
                                (setTimeout (fn ()
                                               (progn
                                                  (-> input_container `display_context_message (+ "*system_repl* / REPL Mode: Press Shift-Enter to evaluate editor contents"))))
                                            250))
                             (setTimeout (fn ()
                                            (-> input_container `display_context_message "REPL Mode: Press Shift-Enter to evaluate editor contents")
                                            250)))
                         true))))))

       (attach_event_listener output_control.output_container
                           `focusin
                           (function (e)
                             (progn
                              (handle_event e)
                              (console.log "output-control: focus: " (-> e.srcElement `getAttribute "lpath") e.srcElement)
                              (aif (-> e.srcElement `getAttribute "lpath")
                                   (progn
                                    (set_prop path_span
                                             `innerText
                                             (+ "[ " (join " "
                                                           (for_each (v (split_by "~" it))
                                                                     (cond (> (length (scan_str non_whitespace_regex v)) 0)
                                                                           (+ "\"" v "\"")
                                                                           (isNaN (new Number v))
                                                                           (+ "`" v)
                                                                           else
                                                                           v)))
                                                           " ]"))
                                    (console.log "setting path span:: " it))
                                   (progn
                                    (console.log "clearing path span")
                                    (set_prop path_span
                                             `innerText
                                             ""))))))
     
    (attach_event_listener show_prototype_details_button
                           `click
                           (fn (e)
                             (progn
                              (handle_event e)
                              (toggle_prototype_detail))))
    
    (attach_event_listener path_span
                           `click
                           (fn (e)
                             (progn
                              (copy_text_to_clipboard path_span.innerText)
                              (notify (+ (dtext "Copied") " " path_span.innerText)))))

    ;; by changing the split_view type value, we prevent this control from being split or
    ;; controls being swapped
    
    (set_prop sview
              `type
              "REPL_split")
    (set_prop output_control
       `on_focus
       nil)
    (set_prop options
              `id
              id)
                   
    (= intf {
             `view: view
             `options: options
             `name: name             
             `editor_container: input_container             
             `editor: nil ;; will be filled in on initialization 
             `history_next_entry: history_next_entry
             `history_prior_entry: history_prior_entry
             `command_history: (function ()
                                        history)
             `clear_history: (function ()
                                       (clear_history))
             `clear_output: clear_output             
             `set_display_mode: set_display_mode
             `initialize: initialize
             `websocket: (function ()
                            repl_ws)
             `available_symbols: available_symbols
             `current_namespace: (function ()
                                    namespace_span.innerText)
             `rename: rename
             `destroy: destroy
             `on_hide: (fn ()
                         (when (is_function? output_control.on_hide)
                            (-> output_control `on_hide)))
             `type: "visual_repl"
             `resize: (fn ()
                       (-> sview `resize))
             `menu_items: menu_items                           
             `on_focus: on_focus
             `on_blur: on_blur           
             `set_theme: (fn (theme_name)
                           (when (contains? theme_name *editor_themes*)
                             (set_prop options `theme theme_name)
                             (-> input_container `set_theme theme_name)))
             `toJSON: (function ()
                                (progn
                                 (set_prop options
                                           `history
                                           [(quote quotel) history])
                                `(visual_repl ,#(or options { `ratio: sview.options.ratio } ))))
             `controls: (fn () [ input_container output_control])
             `output_container: output_control.view
             `log: (fn (val)
                     (-> output_control `log_message val))
             `log_error: (fn (error_message error)
                            (-> output_control `log_error error_message error))
             `evaluate: (fn (lisp_text no_eval no_clear no_log options)
                          (evaluator lisp_text no_eval no_clear no_log options))
             })
    intf))   

(defun set_repl_display_mode (mode ctl)
   (if (is_string? mode)
       (progn
          (cond
             (and (is_control? ctl)
                  (is_function? ctl.set_display_mode))
             (-> ctl `set_display_mode mode)
             (and *last_focus*
                (is_function? (prop *last_focus* `set_display_mode)))
             (-> *last_focus* `set_display_mode mode)
             else
             (throw EvalError "invalid control for mode set"))
          mode)
       (throw TypeError "invalid mode specified - must be a string"))
   {
     `description: (+ "<br><br>Given a mode and an optional target REPL control (or any control that "
                      "has the `set_display_mode` interface method) will set the output display mode "
                      "to the provided mode.<br>Valid mode values are "
                      "either:```tree\njuno\njson```<br><br>If no control argument is given, the control "
                      "that `*last_focus*` is pointing at is used, if it supports the "
                      "`set_display_mode` interface method.<br>The function will return the given mode "
                      "if successful, or throw an error when the mode is not a valid string, or the "
                      "control doesn\'t support the operation. ")
     `usage: ["mode:string" "ctl:?object"]
     `tags: ["REPL" "display" "mode" "output" "format"]
   })


(defcontrol unsaved_controls ()
   ((handle_button_event (fn (elem)
                            (aif (and elem.parentElement
                                      (-> elem.parentElement `getAttribute "for_control_id"))
                                 (progn
                                    (cond
                                       (== elem.innerText (dtext "View"))
                                       (swap_control self (get_control_by_id it))
                                       (== elem.innerText (dtext "Close Control"))
                                       (container_view_operation "destroy" (get_control_by_id it)))))))
    (get_ctls (fn ()
                 (sort (controls_needing_save)
                       { `key: [`options `name] })))
    (ctls (get_ctls))
    (render (fn ()
               (div { `style: "height: 100%; overflow: auto;" } 
                 (dtable (for_each (control (or ctls []))
                            [(or control.name "!") 
                             (from_key control.type) 
                             (or control.options.filename
                                (and control.options.path
                                   (as_lisp control.options.path)))
                             (if (and control.needs_save?
                                               (-> control `needs_save?))
                                          (dtext "Yes")
                                          "")
                             (div { `for_control_id: control.options.id }
                                      (button { `tabindex: 0 } (dtext "View"))
                                      (button { `tabindex: 0 `style: "margin-left: 25px;" } (dtext "Close")))
                             ])
                         {
                             `columns: [(dtext "Name") (dtext "Type") (dtext "Path/File") (dtext "Save Needed?") (dtext "Actions")]
                         }))))
    (on_destroy (fn (self)
                   (progn
                      (clearInterval check_timer)
                      true)))
    (check_timer nil)
    (on_initialize (fn (self)
                      (progn
                         (= check_timer (setInterval 
                                           (fn (v)
                                              (progn
                                                 (defvar new_ctls (get_ctls))
                                                 (when (not (== (sha1 (as_lisp new_ctls))
                                                              (sha1 (as_lisp ctls))))
                                                     (= ctls (get_ctls))
                                                     (set_title (+ "" (length ctls) " Unsaved Controls"))
                                                     (if (== ctls.length 0)
                                                         (destroy_control self)
                                                         (do_render)))))
                                              2500))
                         (set_prop options
                            `temporary true)
                         (set_title (+ "" (length ctls) " Unsaved Controls"))
                         (attach_event_listener view
                            `click
                            (fn (e)
                               (progn
                                  (handle_event e)
                                  (handle_button_event e.srcElement))))
                         self))))
   {
       `control_bar: true
       `usage: []
   })

(defun toggle_unsaved_controls_table ()
   (aif (get_control_by_name "Unsaved Controls")
        (destroy_control it)
        (place_control `top (unsaved_controls))))

;; singleton - if it already exists, just return the control
;; otherwise make it 
(defun control_holding_tank (initial_controls options)
   (aif (get_control_by_name "Holding Tank")
        it
        (let
           ((my_controls (if (and initial_controls
                                  (is_array? initial_controls))
                             (to_object
                                (reduce (control initial_controls)
                                   (when control.options.id
                                      [control.options.id control])))
                             {}))
            (options (or options {}))
            (intf {})
            (name (or options.name
                      "Holding Tank"))
            (initialized false)
            (id (or options.id (generate_id "holding_tank")))
            (title_span (span { `class: "juno-title" } (dtext "Holding Tank") " - " (dtext "non-displayed controls")))
            (buffer_commands_button (commands_button id))
            (control_status (div {  `class: "juno-buffer-bar" }
                                 buffer_commands_button
                                 (cond (is_array? options.additional_elements)
                                    options.additional_elements
                                    else
                                    title_span
                                    )))
            (perform_resize (fn ()
                               (when view.parentElement
                                  (when (not initialized)
                                     (initialize))
                                  (render_view))))
            (resize_observer nil)
            (add_control (fn (control)
                            (when (not (== control intf))
                               (assert (and control.type control.options.id) "Invalid control provided")
                               (set_prop my_controls
                                  control.options.id
                                  control)
                               ;(log "control_holding_tank: " control.options.name  "can_hide?" (and control.can_hide? (-> control `can_hide?)))
                               (if (and (not (resolve_path [ `options `locked ] control))
                                        (or (== control.type "empty_control")  ;; don't store the empty controls since they are placeholders
                                            control.options.temporary          ;; or if the control is marked temporary
                                            (and control.can_hide?       ;; does the control want to be hidden?
                                               (not (-> control `can_hide?)))))
                                   (progn
                                      (when *app_menu_control*
                                         (-> *app_menu_control* `remove_menu control.options.name))
                                      (remove_control control.options.id)
                                      (if control.destroy
                                         (-> control `destroy))
                                      (when (== *last_focus* control)
                                         (== *last_focus* nil))
                                      (default_focus))
                                   (progn  ;; control is going to storage - call on_hide if it has it
                                      (when (is_function? control.on_hide)
                                         (-> control `on_hide))))
                               (render_view)
                               control)
                            ))
            (remove_control (fn (id)
                               (if (is_object? id)
                                   (aif (prop my_controls id.options.id)
                                        (progn
                                           (remove_prop my_controls id.options.id)
                                           (render_view)))
                                   (aif (prop my_controls id)
                                        (progn
                                           (remove_prop my_controls id)
                                           (render_view))
                                        (notify "The requested control wasn't found")))))
            (first_button nil)
            (render_view (fn ()
                            (progn
                               (= first_button nil)
                               (-> control_view
                                  `replaceChildren
                                  (table { `tabindex: 0 `style: "width: 100%" }
                                         (thead
                                            (th (dtext "Name")) (th (dtext "Type")) (th (dtext "Needs Save?")) (th (dtext "Actions")))
                                         (tbody
                                            (for_each (control (values my_controls))
                                               (tr
                                                  (td control.name)
                                                  (td control.type)
                                                  (td (if (and control.needs_save?
                                                               (-> control `needs_save?))
                                                          (dtext "Yes")
                                                          ""))
                                                  
                                                  (td { `for_control_id: control.options.id }
                                                      (progn
                                                         (defvar b (button { `tabindex: 0 } (dtext "View")))
                                                         (if (not first_button)
                                                             (= first_button b))
                                                         b)
                                                      (button { `tabindex: 0 `style: "float: right" } (dtext "Close Control")))))))))))
            (handle_button_event (fn (elem)
                                    (aif (and elem.parentElement
                                              (-> elem.parentElement `getAttribute "for_control_id"))
                                         (progn
                                            (console.log "holding_tank: button_event: " elem.innerText elem)
                                            (cond
                                               (== elem.innerText (dtext "View"))
                                               (swap_control intf (get_control_by_id it))
                                               (== elem.innerText (dtext "Close Control"))
                                               (container_view_operation "destroy" (get_control_by_id it)))))))
            
            (initialize (fn ()
                           (when (and view.parentElement
                                      (not initialized))
                              (= initialized true)
                              (-> resize_observer `observe view.parentElement)
                              (console.log "holding_tank: in initialization: " options view.parentElement)
                              (if options.in_tree
                                 (progn
                                    (console.log "holding_tank: in tree and setting view up to block..and calling render")
                                    (set_style [["display" "block"]] view)
                                    (render_view)
                                    (focus_to first_button))
                                 (-> (get_by_id "body")
                                     `append view)))))
            (dirty_controls_interval nil)
            (num_dirties 0)
            (num_dirties_button (button { `id: "num_dirties_button" 
                                          `title: (dtext "Click to toggle unsaved controls panel")
                                          `style: "font-size: 0.9em; font-weight: bold; padding: 4px; min-width: 25px; text-align: center; border-radius: 20px; background: #A01010; color: white; position: absolute; top: 2px; right: 20px;" }
                                  0))
            (before_unload_listener (function (e)
                                       (progn
                                          (-> e `preventDefault)
                                          (set_prop e `returnValue (+ "There are " num_dirties " items that require saves. Are you sure you want to quit?"))
                                          e)))
            (on_focus (fn ()
                         (progn
                            (add_class "juno-focused" control_status ))))
            (control_view (div { `style: "overflow: scroll; margin: 0px; padding: 0px; height: 100%; width: 100%;background: var(--control-bg-color);" }))
            (show (fn ()
                     (let
                        ((root_control (if *last_focus*
                                           (top_frame *last_focus*)
                                           (prop $root_controls 1)))
                         (current_parent (if view.parentElement
                                             (control_position (control_for_dom_element view))
                                             { `child: intf `parent: nil `child_position: 0 }))
                         (target_control (if root_control.controls
                                             (first (-> root_control `controls)))))
                        (console.log "holding_tank: show: " root_control "current_parent: " current_parent "target_control: " target_control)
                        (console.log "holding_tank: do I have a parent_element: " (parents_for_control intf))
                        (cond
                           (eq current_parent.parent nil)
                           (progn
                              (set_prop options
                                 `in_tree
                                 true)
                              (set_style [["display" "block"]] view)
                              (container_view_operation "split_below" target_control intf { `ratio: 0.7 })
                              (set_focus_to intf)
                              (focus_to first_button))
                           current_parent.parent
                           (progn
                              (set_style [["display" "block"]] view)
                              (set_prop options
                                 `in_tree
                                 true)
                              (set_focus_to intf)
                              (focus_to first_button))))))
            (hide (fn ()
                     (progn
                        (console.log "holding_tank: hide: " view.parentElement)
                        (when view.parentElement
                           (container_view_operation "hide" intf)
                           (remove_prop options
                              `in_tree)
                           (set_style [["display" "none"]] view)
                           (-> (get_by_id "body")
                               `append view)))))
            
            
            (view (div { `tabindex: 0 `control_id: id `style: "display: none;  overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                       control_status
                       control_view)))
           
           (attach_event_listener view
              `click
              (fn (e)
                 (when (== e.srcElement.tagName "BUTTON")
                    (handle_button_event e.srcElement))))
           
           (attach_event_listener num_dirties_button
              `click
              (fn (e)
                 (toggle_unsaved_controls_table)))
                      
           (attach_event_listener view
              `keyup
              (fn (e)
                 (when (== e.key "Escape")
                    (hide))))
           
           (set_prop options
              `id id
              `name name)
           (= dirty_controls_interval
              (setInterval (fn ()
                              (let
                                 ((dirties (try
                                              (reduce (c (current_controls))
                                                 (if (and c.needs_save?
                                                          (-> c `needs_save?))
                                                     c))
                                              (catch Error (e)
                                                 (progn
                                                    (when dirty_controls_interval
                                                       (clearInterval dirty_controls_interval))
                                                    (log_error "dirty_controls_interval: stopping due to error: " e)
                                                    [])))))
                                 (set_prop num_dirties_button
                                    `innerText (+ "" dirties.length))
                                 (cond
                                    (and (> dirties.length 0)
                                         (== num_dirties 0))
                                     (progn
                                        (= num_dirties dirties.length)
                                        (if (not num_dirties_button.parentElement)
                                            (-> (get_by_id "page-header") `append
                                                     num_dirties_button))
                                        (addEventListener `beforeunload before_unload_listener { capture: true }))
                                     (and (== dirties.length 0)
                                          (> num_dirties 0))
                                     (progn
                                        (= num_dirties 0)
                                        (-> num_dirties_button `remove)
                                        (removeEventListener `beforeunload before_unload_listener { capture: true })))))
                           2000))

           (= resize_observer (new ResizeObserver perform_resize))
           
           (= intf
              {
                `view: view
                `type: "holding_tank"
                `id: id
                `name: options.name
                `initialize: initialize
                `on_focus: on_focus
                `controls: (fn ()
                              (values my_controls))
                `add_control: add_control
                `has_control?: (fn (thing) (if (is_string? thing)
                                           (prop my_controls thing)
                                           (prop my_controls thing.options.id)))
                `remove_control: remove_control
                `name: options.name
                `hide: hide
                `show: show
                
                `resize: perform_resize
                `options: options
                `toJSON: (function ()
                            `(control_holding_tank ,#(values my_controls)  ,#options ))
                })
           intf))
   {
     `usage: ["initial_controls:array" "options:object"]
     `description: (+ "The control holding tank is a is a singleton control that 'holds' any "
                      "control (except itself) that is currently not displayed.  Once instantiated "
                      "any new instantiations of the control holding tank will return the "
                      "previously instantiated control for the namespace.  All arguments will be "
                      "ignored after the initial instantiation call as the global instance will be "
                      "returned. Controls are added to the holding tank by the container_view_operation "
                      "function which manages the view state.  The holding tank can be checked for a "
                      "control being held by it by calling the has_control? function. ")
     `tags: ["ui" "controls" "hidden" "container" "holding"]
     })

(defun empty_selection_control (options)
   (let
      ((existing_control (last (holding_tank_controls))))
      (if existing_control
         existing_control
     (let
        ((options (or options {
                               `name: "Empty Selection" 
                               }))
         (id (or options.id (generate_id "empty")))
         (title_span (span { `class: "juno-title" } (if options.title options.title "Select Control")))
         (buffer_commands_button (commands_button id))
         (control_status (div {  `class: "juno-buffer-bar" }
                              buffer_commands_button
                              (cond (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span
                                  )))
         (resize_observer nil)         
         (initialized false)
         (parent_view nil)
         (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
         (perform_resize (fn ()
                           (when view.parentElement
                             (check_observer)
                           (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                             
                             (set_style [[ "width" (+ "" new_width "px") ]
                                         [ "height" (+ "" new_height "px") ]]
                                        view)))))
         (initialize (fn ()
                       (when (and view.parentElement
                                  (not initialized))
                         (= initialized true)
                         (= parent_view view.parentElement)
                         (-> resize_observer `observe view.parentElement))))
         (on_focus (fn ()
                   (progn
                     ;; bring focus to the repl
                    (add_class "juno-focused" control_status ))))
         (control_view (div { `class: "juno-empty-content" } ""))
         (view (div { `tabindex: 0 `control_id: id `style: "overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                  control_status
                  control_view)))
                             
        (set_prop options
                  `id
                  id)
        (= resize_observer (new ResizeObserver perform_resize))
        
        
       {
           `view: view
           `type: "empty_control"
           `id: id
           `initialize: initialize
           `on_focus: on_focus
           `name: options.name
           `resize: perform_resize
           `options: options
           `toJSON: (function ()
                      `[empty_selection_control ,#options ])
        }))))

(defun find_common_prefix (candidates match_to)
   (let
      ((result [])
       (subset nil)
       (match_to match_to))
      (cond
         (== (length candidates) 0)
         ""
         (== (length candidates) 1)
         (first candidates)
         
         (not (blank? match_to))
         (progn
            (while (progn
                      (= subset (reduce (c candidates)
                                   (when (starts_with? match_to c)
                                      c)))
                      (and (< subset.length 2)
                           (> match_to.length 0)))
               (= match_to (chop match_to)))
            
            (find_common_prefix subset))
         else
         (progn
            (= candidates (sort candidates))  ;; make sure the candidates are sorted
            (for_each (idx (range (length candidates.0)))
               (if (== (prop (first candidates) idx)
                       (prop (last candidates) idx))
                   (push result (prop (first candidates) idx))
                   (break)))           
            (join "" result)))))

(defun place_caret_at_end (el)
   (progn
      (javascript |
                  el.focus();
                  if (typeof window.getSelection != "undefined"
                             && typeof document.createRange != "undefined") {
                     var range = document.createRange();
                     range.selectNodeContents(el);
                     range.collapse(false);
                     var sel = window.getSelection();
                     sel.removeAllRanges();
                     sel.addRange(range);
                     }
                  | )
      true))




(defun next_hidden_control (backward?)
   (let
      ((candidates (holding_tank_controls))
       (cmd (if backward? 
                last
                first))
       (new_ctl nil))
   (if (> candidates.length 0)
      (progn 
         (= new_ctl (cmd candidates))
         (swap_control *last_focus* new_ctl)
         ;; control will get the on_focus event, but we want to default
         ;; focus into the editor for this operation
         (when new_ctl.editor
            (focus_to new_ctl.editor)))
      (notify (dtext "No controls are in the holding tank."))))
   {
     `usage: ["backward?:boolean"]
     `description: (+ "If backward? is false (default) swap the current control " 
                      "with the last control in the holding tank. Otherwise "
                      "swap with the first control in the holding tank. "
                      "If there are no controls, notifies the user that there are "
                      "no other non-displayed controls to swap to.")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     })

(defun next_displayed_control (backward?)
      (let
      ((next_index nil)
       (displayed_root_control (reduce (ctl (uniq (flatten (control_tree $root_controls))))
                                  (if (and (not (-> (control_holding_tank) `has_control? ctl))
                                           (== ctl.type "control_container"))
                                      ctl)))
       (candidates (reduce (ctl (current_controls true displayed_root_control))
                      (unless (or (-> (control_holding_tank) `has_control? ctl)  ;; we only want controls that are able to take a direct focus
                                  (== ctl.type "control_container")
                                  (== ctl.type "split_view_vertical")
                                  (== ctl.type "split_view_horizontal"))
                         ctl)))
       (dir (if backward? 
                -2
                1))
       (new_ctl nil))
   (if (> candidates.length 0)
      (progn 
         (map (fn (ctl idx)
                 (if (== ctl *last_focus*)
                     (= next_index (% (+ idx dir) (length candidates)))))
              candidates)
         (when next_index
            (= new_ctl (prop candidates next_index))
            (set_focus_to new_ctl)
            ;; control will get the on_focus event, but we want to default
            ;; focus into the editor for this operation if the control has an editor
            (if new_ctl.editor
               (focus_to new_ctl.editor))))
      (notify (dtext "No controls are in the holding tank."))))
   {
     `usage: ["backward?:boolean"]
     `description: (+ "If backward? is false (default) swap the current control " 
                      "with the next control in the displayed control tree. Otherwise "
                      "swap with the first control in the holding tank. "
                      "If there are no controls, notifies the user that there are "
                      "no other non-displayed controls to swap to.")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     })

(defmacro on_key_down_event (e view `& key_to_action_pairs)
   (let
      ((acc []))     
      ;(assert (and e view key_to_action_pairs)
       ;       "Invalid syntax for on_key_down_event")
      (for_each (key_to_action_pair key_to_action_pairs)
                        (destructuring_bind (key action)
                           key_to_action_pair
                           (if (== key "otherwise")
                               (push acc true)
                               (push acc `(== kcode ,#key)))
                           (push acc action)))
      `(attach_event_listener 
          view
          `keydown
          (function (e)
             (let
                ((kcode e.key))
                (cond
                   ,@acc))))))



(defcontrol tree_browser ()
   ((options (or (and (is_object? options)
                          options)
                     (throw SyntaxError "options object is required for tree_browser")))
    (stack [])
    (initial_render false)
    (title_span (span { spellcheck: false `contenteditable: true `tabindex: 0 `style: "caret-color: red; outline: none; display: inline-block; font-size: 1.1em; font-weight: bold; font-family: var(--main-mono-space); min-width: 10px; border: 1px dotted goldenrod; padding-left: 5px; padding-right: 5px" } ""))
    (caps_lock_span (span { `class: "juno-display-none" `style: "margin-left: 20px; padding-top: 2px; padding-left: 5px; padding-right: 5px; padding-bottom: 2px; border-radius: 3px; border: 1px solid var(--main-color); " } (dtext "caps lock")))
    (on_destroy (fn (self)
                  (progn
                   (when options.on_destroy                     
                     (options.on_destroy self))
                   true)))
    (current_pos 0)
    (content_view (div { `style: "" `class: "juno-symbol-browser" }))
    (get_current_stack (fn ()
                           (clone stack)))
    (select_text (dtext (or options.select_text
                            "Press Enter To Open")))
    (ol_for_pos (fn (pos)
                   (let
                      ((target_col nil))
                      (= target_col (-> content_view `querySelector (+ "ol[pos='" (if pos pos 0) "']")))
                      target_col)))
    
    (select_child (fn (ol_elem selected_child_text)
                     (when selected_child_text
                        (for_each (child ol_elem.children)
                           (if (and (is_element? child)
                                    (== (get_attribute child "path_value") selected_child_text))
                               (add_class "juno-selected" child)
                               (remove_class "juno-selected" child))))))
    (path_sep (fn ()
                 (or options.path_separator "/")))
    
    (num_ol_elems (fn ()
                    (length content_view.children)))
                       
    
    (create_ol_at_pos (fn (pos)
                         (try
                            (let
                               ((stack_value_at_pos (prop stack pos))
                                (contents (get_possibles pos)))
                               (ol { `style: (if (not (is_array? contents))
                                                 "width: 100%; max-width: 100%; position: relative;"
                                                 "height: calc(100% - 20px);  position: relative;")
                                            `pos: pos }
                                   contents))
                            (catch Error (e)
                               (log "ERROR: create_ol_at_pos: " pos "" e.message)))))
    
    (find_value (fn (elem key)
                   (let
                      ((v nil))
                      (cond
                         (= v (get_attribute elem key))
                         v
                         elem.parentElement
                         (find_value elem.parentElement key)
                         else
                         nil))))
    
    (get_specifics_for_event (fn (e)
                                (let
                                   ((elem e.srcElement)
                                    (path_value (find_value elem "path_value"))
                                    (pos (int (find_value elem "pos"))))
                                   (set_path_at pos path_value))))
    
    (set_path_at (fn (pos path_value)
                    (when path_value
                       (cond
                          (== pos stack.length) ;; at end
                          (progn
                             (push stack path_value)
                             (render_stack))
                          (< pos stack.length)
                          (progn
                             (= stack (-> stack `slice 0 pos))
                             (push stack path_value)
                             (clear_suffix)
                             (render_stack))
                          else
                          (log "set_path_at: unhandled: " pos path_value)))))
    (is_at_leaf false)
    (was_at_leaf false)
    (at_leaf (fn ()
                (progn 
                   is_at_leaf)))
                   ;(log "at_leaf?: is_at_leaf: " is_at_leaf (not (has_class? "filtered-hidden" instruction_div)))
                   ;(not (has_class? "filtered-hidden" instruction_div)))))
    
    (get_path_components (fn (raw)
                            (let
                               ((text (or title_span.innerText ""))
                                (ps (path_sep)))
                               (if raw
                                  text
                                  (progn
                                     (if (ends_with? ps text)
                                         (= text (chop text)))
                                     (split_by ps text))))))
    (get_suffix (fn ()
                   (let
                      ((comps (get_path_components)))
                      (if (> comps.length stack.length)
                          (last comps)
                          ""))))
    
    (clear_suffix (fn ()
                     (let
                        ((elem (ol_for_pos stack.length))
                         (ps (path_sep)))
                        
                           (set_prop title_span
                              `innerText (+ (join ps stack)
                                            (if (and (> stack.length 0)
                                                     (not (at_leaf)))
                                                ps
                                                "")))
                        (if elem
                            (for_each (c elem.children)
                               (remove_class "filtered-lower-opacity" c))))))
                        
    (get_matches (fn (k highlight?)
                    (let
                       ((num_matches 0)
                        (pos stack.length)
                        (addl (if (blank? k) "" k))
                        (suffix (+ (get_suffix) addl))
                        (matched [])
                        (first_match nil)
                        (not_matched []))
                       (if (< pos 0)
                           []
                           (aif (ol_for_pos pos)
                                (for_each (c it.children)
                                   (progn
                                      (if (and (not (blank? suffix))
                                               (starts_with? suffix c.innerText))
                                          (push matched
                                                c)
                                          (push not_matched
                                                c))))))
                       (= last_matched matched)
                       (when highlight?
                          (for_each (elem not_matched)
                             (add_class "filtered-lower-opacity" elem))
                           (for_each (elem matched)
                              (remove_class "filtered-lower-opacity" elem)))
                       (= first_match matched.0)
                       (when first_match
                          (set_prop first_match.parentElement
                             `scrollTop
                             (- (prop first_match `offsetTop) 10)))
                       matched)))
    
    (get_last_column_values (fn ()
                               (let
                                  ((elem (ol_for_pos stack.length)))
                                  (if elem
                                      (for_each (c elem.children)
                                         (prop c `innerText))
                                      []))))
    
    (matched_as_text (fn (matched)
                        (map (fn (v)
                                v.innerText)
                             matched)))
    (last_suffix nil)
    (caps_lock_timer nil)
    (last_matched [])
    (select_matches (fn (k)
                       (let
                          ((text nil)
                           (in_reverse (== k "Backspace"))
                           (matched nil)
                           (prefix nil)
                           (suffix nil)
                           (exact_match nil)
                           (existing_suffix nil)
                           (ps (path_sep))
                           (last_path nil)
                           (at_leaf? (at_leaf)))                         
                          ;; are we going forward or backwards?
                          ;; if forwards, determine if we pressed a delim key or a regular key
                          ;; if we pressed a delim key, and the final path segment matches an element in the column, push that value to the stack, and redraw the columns and the title_span
                          ;; if we pressed a regular key, find the common prefixes, write that to the title_span,
                          ;; ...and follow the filter process.
                          ;; if we matched to a leaf, display the instruction_div 
                          
                          ;; if backwards, determine if we are at a leaf or not
                          ;; if we are, remove the character from the title_span, pop the stack, find the common prefix, write that to the title_span, follow the filter process
                          ;; if we are not, remove the character, find the common prefix, write that to the title_span and 
                          ;; follow the filter process
                          
                          ;; Filter process:
                          ;; Determine the amount of matched elements at the last path segment
                          ;; if 1 match then append the value to the path and redraw the title and the column selectors
                          ;; if >1 then find the common prefix, and append the common prefix to the title_span
                          ;; ..and highlight the matching values in the column
                          ;; if 0 matches don't append the character since it cannot contribute to narrowing the selection
                         
                          (cond
                             in_reverse
                             (progn 
                                (= was_at_leaf at_leaf?)
                                (when at_leaf? ;; if we are at leaf state, remove the final value from the stack
                                    (pop stack)
                                   
                                    (= is_at_leaf false)
                                    (add_class "filtered-hidden" instruction_div))
                                (if options.allow_non_matches
                                   (run_validations))
                                ;; find the common prefix with one character removed
                                (= existing_suffix (get_suffix))                    
                                (when (not (blank? existing_suffix))
                                   (if options.allow_non_matches
                                      (= prefix (chop existing_suffix))
                                      (= prefix (find_common_prefix (get_last_column_values) (chop existing_suffix)))))
                                (when (== prefix last_suffix)
                                    ;; we had this value last backspace, so we need to go back further
                                    (= prefix "")
                                    (= last_suffix nil))
                                (cond
                                   (and options.allow_non_matches
                                        (blank? prefix))
                                   (progn
                                      (if (blank? last_suffix)
                                          (progn
                                             (pop stack)
                                             (render_stack))
                                          (progn 
                                             (clear_suffix)
                                             (render_title prefix)
                                             true)))
                                   (blank? existing_suffix)  ;; there is no suffix, so pop the stack 
                                   (progn        
                                      (pop stack)
                                      (try
                                         (clear_suffix)
                                         (catch Error (e)
                                            (log "ERROR on clear_suffux: " e.message)))
                                      (try
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR on render stack: " e.message))))
                                   
                                   (blank? prefix)  ;; when no common prefix remove the suffix altogether
                                   ;; we will have to rebuild the title_span explicitly otherwise suffix will be preserved
                                   (progn
                                      (clear_suffix)
                                      (render_stack))
                                      ;; clear all the matches..
                                   (> (length prefix) 0)
                                   (progn
                                      (clear_suffix)
                                      (render_stack prefix true)
                                      (= last_suffix prefix)
                                      (get_matches "" true))
                                   else
                                   ;; just clear the last suffix 
                                   (progn
                                      (= last_suffix nil))))
                                ;; if we were at a leaf, we are no longer so remove the leaf node from the stack
                             
                             (and (not options.allow_non_matches)
                                  (or (== k ps)
                                      (== k "Tab")))
                             (progn
                                (= matched (get_matches "" true))
                                (= last_path (last (get_path_components)))
                                
                               (cond 
                                  ;; if there is only one match 
                                  (and (> (length title_span.innerText) 0)
                                       (== (length matched) 1)
                                       (not (ends_with? ps title_span.innerText)))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))
                                  ;; if there are multiple matches, but in those matches there is an exact match
                                  (and (> (length title_span.innerText) 0)
                                       (== (length (reduce (t (matched_as_text matched))
                                                      (== last_path (first (split_by "\n" t)))))
                                           1))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))))
                                  
                                     
                             else
                             (progn
                                (if options.allow_non_matches
                                   (if (or (== k "Tab")
                                           (== k ps))
                                       (= matched (get_matches "" true))
                                       (= matched (get_matches k true)))
                                   (= matched (get_matches k true)))
                                (= last_matched matched)  
                                (cond                                  
                                   (and (not (== k ps))
                                        (not (== k "Tab"))
                                        (not (> k.length 1))
                                        options.allow_non_matches)
                                   (progn
                                      (= prefix (+ (or (get_suffix) "") k))
                                      (render_title prefix)
                                      (when options.validate_selection
                                        (run_validations)))
                                   (== (length matched) 1)  ;; ok we matched only 1 so go ahead and put it into the stack
                                   (progn
                                      (push stack 
                                            (first (split_by "\n" matched.0.innerText)))
                                      (try 
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR: " e.message))))
                                   
                                   (and ;options.allow_non_matches
                                        (> (length matched) 1)
                                        (or (== k "Tab")
                                            (== k ps)))
                                   (progn
                                      (= prefix (get_suffix))
                                      (= exact_match (first (reduce (v matched)
                                                               (when (== (first (split_by "\n" v.innerText)) prefix)
                                                                  prefix))))
                                      (if exact_match
                                         (progn
                                            (push stack
                                               (first (split_by "\n" matched.0.innerText)))
                                            (try (render_stack)
                                               (catch Error (e)
                                                  (log "ERROR: " e.message))))
                                         (progn
                                            ;; find the common prefix and render title
                                            (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                            ;; subtract suffix
                                            (render_title prefix))))
                                   (> (length matched) 1)  ;; multiple matches, so add the character to the suffix
                                   (progn
                                      ;; find the common prefix and render title
                                      (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                      ;; subtract suffix                                                                            
                                      (render_title prefix)))))
                          (= last_suffix (get_suffix))
                           true)))
                                   
                                ;; if it is a control type type don't display
    (select_button (button { `tabindex: 0 `class: "juno-primary" `style: "font-weight: bold;margin-right: 20px;" } (or options.select_button_text "Select")))
    (instruction_div (span {`style: "float: right; margin-right: 30px; padding-left: 8px; padding-right: 8px; font-weight: bold; color: var(--value-modified-color);"  `class: "filtered-hidden"  } 
                           select_button
                           select_text))
    (prefix_div (span { `style: "font-size: 1.1em; margin-right: 8px;" } (dtext "Select or Type:")))
    (open_selection (fn ()
                       (when (and (not (has_class? "filtered-hidden" instruction_div))
                                  options.on_select
                                  (if options.allow_non_matches
                                     (options.on_select (get_path_components))
                                     (options.on_select stack))))))
    (handle_enter_event (fn (e)
                           (cond
                              (== e.srcElement title_span)
                              (progn
                                 (handle_event e)
                                 (open_selection))
                              else
                              (get_specifics_for_event e))))
   
    (on_initialize (fn (self)
                      (progn
                          (on_key_down_event e view
                             ("Enter" (progn
                                         (handle_enter_event e)))
                                         
                             ("Escape" (progn
                                          (handle_event e)
                                          (destroy_control self)))
                             ("Tab" (progn
                                       (if (or options.allow_non_matches
                                               (not (at_leaf)))
                                           (handle_event e))
                                       (select_matches e.key)))
                             (`otherwise (progn 
                                            (when (== e.srcElement title_span)
                                               (handle_event e)
                                               (if (or (== e.key "CapsLock") 
                                                       (-> e `getModifierState "CapsLock"))
                                                   (progn
                                                      (when caps_lock_timer
                                                         (clearTimeout caps_lock_timer))
                                                      (= caps_lock_timer 
                                                         (setTimeout (fn () (add_class "juno-display-none" caps_lock_span)) 1000))
                                                      (remove_class "juno-display-none" caps_lock_span))
                                                   (add_class "juno-display-none" caps_lock_span))
                                               
                                               (select_matches e.key)
                                               ))))
                         
                         (-> title_span.parentElement
                             `appendChild
                             instruction_div)
                         (-> title_span.parentElement
                            `appendChild
                            caps_lock_span)
                         (-> title_span.parentElement `insertBefore
                             prefix_div title_span)
                         (attach_event_listener select_button
                            `click
                            (fn (e)
                               (progn
                                  (handle_event e)
                                  (open_selection))))
                         (add_class "juno-highlighted" title_span.parentElement)
                         (attach_event_listener content_view
                                                `click
                                                get_specifics_for_event ))))
    
    (get_possibles (fn (pos)
                       (cond 
                          (is_function? options.get_possibles_elem)
                          (-> options `get_possibles_elem pos)
                          (is_function? options.get_possibles)  ;;  returns either a single obj with keys or an array of those objects
                          ;; keys: ctype has_children? title path_value  and view
                          (let
                                ((idx -1)
                                 (val nil)
                                 (filter_text (last (split_by (or options.path_separator "/") title_span.innerText))))
                                (= val (-> options `get_possibles pos self))
                                (if (not (is_array? val))
                                    (progn
                                       ;(remove_class "filtered-hidden"  instruction_div)
                                       (= is_at_leaf true))
                                    (progn
                                       (= is_at_leaf false)
                                       ;(add_class "filtered-hidden" instruction_div) 
                                       ))
                                (if (and options.allow_non_matches
                                         options.validate_selection)
                                    (run_validations)
                                    (if is_at_leaf
                                       (remove_class "filtered-hidden"  instruction_div)
                                       (add_class "filtered-hidden" instruction_div)))
                                    
                                (cond
                                   (is_array? val)
                                   (for_each (obj val)
                                      (progn
                                         (inc idx)
                                         
                                         (li { `tabindex: 0
                                                `ctype: (or obj.ctype "sym" )
                                               `title: obj.title
                                               `class: (+ "juno-list-item " 
                                                          (if obj.has_children? "juno-list-item-has-children " "") 
                                                          (if (and (not (blank? filter_text))
                                                                   (not (starts_with? filter_text obj.path_value)))
                                                              "filtered-lower-opacity"
                                                              ""))
                                               `style: (or obj.style
                                                           "")
                                               `path_value: obj.path_value
                                               } 
                                               (if obj.view 
                                                   obj.view 
                                                   idx))))
                                         
                                   (is_object? val)
                                   (li { `tabindex: 0
                                         `ctype: (or val.ctype "sym" )
                                         `title: val.title
                                         `class: (+ "juno-list-item " (if val.has_children? "juno-list-item-has-children " "") (if val.class val.class ""))
                                         `style:  (+ "height: calc(100% - 20px); " (if val.style val.style ""))
                                         `path_value: (or val.path_value nil)
                                         } (if val.view val.view idx))
                                   (is_string? val)
                                   (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: calc(100% - 50px);" }
                                    val)
                                   else
                                   (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: calc(100% - 50px);" }
                                    (value_to_dom val))))
                           else
                           (div { } "Missing get_possibles function or get_possibles_elem in options"))))
    (run_validations (fn ()
                        (when (and options.allow_non_matches
                                   options.validate_selection)
                           (if (-> options `validate_selection (get_path_components true) (at_leaf) last_matched)
                               (remove_class "filtered-hidden" instruction_div)
                               (add_class "filtered-hidden" instruction_div)))))
                           
                            
    (render_title (fn (new_suffix)
                     (let
                        ((suffix (or new_suffix (get_suffix) ""))
                         (ps (path_sep)))
                        (set_prop title_span
                           `innerText
                           (+ (join ps stack)
                              (cond 
                                 (at_leaf)
                                 ""
                                 (and (blank? suffix)
                                      (> stack.length 0)
                                      (if (and options.allow_non_matches
                                               options.validate_selection)
                                          (not (-> options `validate_selection (get_path_components true) (at_leaf) last_matched))
                                          true))
                                 ps
                                 (== stack.length 0)
                                 (+ "" suffix)
                                 else
                                 (+ ps suffix))))
                        (run_validations)
                        (place_caret_at_end title_span))))
    
    (render_stack (fn (prefix no_rerender)
                     (let
                        ((ol_elem nil)
                         (new_ol_elem nil))
                        
                        (if (or (not no_rerender)
                                was_at_leaf)
                        (when (> (num_ol_elems) stack.length)
                           (try
                           (for_each (pos (range_inc  stack.length (num_ol_elems)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (when ol_elem
                                    (-> ol_elem `remove))))
                           (catch Error (e)
                              (log "Error on: stack render p1: " e.message)))))
                        ;; is the stack already drawn, or do we need to render it?
                        (try
                           (for_each (pos (range (+ stack.length 1)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (if ol_elem
                                    (select_child ol_elem (prop stack pos))
                                    (progn
                                       (= new_ol_elem (create_ol_at_pos pos))
                                       (if new_ol_elem
                                          (-> content_view `append
                                             (create_ol_at_pos pos)))))))
                           (catch Error (e)
                              (log "Error on: stack render p2: " e.message)))
                        (try
                           (render_title prefix)
                           (catch Error (e)
                              (log "Error on render_title: " e.message))))))
    
    (on_render (fn (self broaden)
                       (let
                          ((next_elem nil))
                          ;(render_stack)
                          nil)))
                          
    (render (fn ()
               (if (not initial_render)
                   (progn
                      (= initial_render true)
                      (render_stack)
                      content_view)
                   nil))))
   {
     `control_bar: true
     `expose: [[`get_current_stack get_current_stack]]
     })



(defun file_tree_browser(options)
    (let
       ((create_mode options.create_mode)
        (render_entry (fn (entry)
                         (let
                              ((etype (fn (entry)
                                         (cond
                                                entry.isDirectory "directory"
                                                entry.isFile "file"
                                                entry.isSymlink "symlink")))
                               (rval nil))
                              (= rval
                               {
                                 `has_children?: entry.isDirectory
                                 `path_value: entry.name
                                 `class: (etype entry)
                                 `ctype: "sym"
                                 `view: (div { `style: "display: inline-block; width: 100%;"
                                               `class: (+ "juno-type-file-entry " (etype entry)) }
                                               entry.name
                                               (if entry.isDirectory
                                                    (span { `style: "display: inline-block; float: right" } "▸")
                                                      "")) })
                              ;(log "render_entry: entry rval: " rval rval.view.outerHTML)
                              rval)))
        
        (get_possibles (fn (pos control)
                           (let
                              ((next_values (if (== pos 0)
                                                (http/list_files "/")
                                                (http/list_files (join "/" (-> control `get_current_stack))))))
                              (when (is_array? next_values)
                                 (sort next_values { `key:`name }))
                              (= next_values (clone next_values))
                              (cond
                                 (is_array? next_values)
                                 (for_each (entry next_values)
                                    (render_entry entry))
                                 (instanceof next_values Blob)
                                 {
                                   `has_children?: false
                                   `ctype: "file"
                                   `style: "width: calc(100% - 10px) !important;"
                                   `view: (div { `style: "display: inline-block; width: calc(100% - 50px); height: 100%; overflow: hidden" }
                                               (div { `style: "height: calc(100% - 30px); overflow: scroll;" }
                                                    (pre {} (-> next_values `text)))
                                               (div { `style: "padding: 10px;" }
                                                    []))  ;; placeholder for any additional information about the file
                                   }
                                 else
                                 {
                                   `has_children?: false
                                   `ctype: "file"
                                   `view: (pre {} (sub_type next_values))
                                   }))))
        
        (control (tree_browser (+ { `path_separator: "/"
                                    `render_entry: render_entry
                                    `get_possibles: get_possibles
                                    allow_non_matches: (if create_mode true false)
                                    select_text: (if create_mode
                                                    "Press Enter To Create"
                                                    "Press Enter To Open")
                                    select_button_text: (if create_mode
                                                           "Create"
                                                           "Open")
                                    validate_selection: (fn (path at_leaf matches)
                                                           (try
                                                              (progn
                                                                 ;(log "v:" path  "at_leaf: " at_leaf "# m: " (length matches))
                                                                 (cond
                                                                    at_leaf
                                                                    false
                                                                    (ends_with? "/" path)
                                                                    false
                                                                    (== 0 (length path))
                                                                    false
                                                                    (and (is_array? matches)
                                                                         (== (length matches) 1)
                                                                         (== (first (split_by "\n" (prop (first matches) `innerText)))
                                                                             (last (split_by "/" path))))
                                                                    false
                                                                    else
                                                                    true))
                                                              (catch Error (e)
                                                                 (progn
                                                                    (log "Error: " e.message)
                                                                    false))))
                                    }
                                    (if (is_object? options)
                                        options
                                        {})))))
       
       control))



(defun save_active_buffer (save_all)
  (cond
    save_all
    (for_each (control (select_controls (fn (ctl) (is_function? (prop ctl `save)))))
              (-> control `save))
    (and *last_focus*
         (prop *last_focus* `save))
    (-> *last_focus* `save)
    *last_focus*         
    (notify (+ "" (or (prop *last_focus* `name) "Unnamed") " " (dtext "doesn't have a save method") "."))
    else
    (notify (dtext "There isn't an active control."))))
    
    
(defun split_control (dir)
   (alert_on_error "Unable to perform split"
                   (let
                      ((target *last_focus*))
                      (if (eq nil target)
                          (throw Error "No Focused Control to split"))
                      (cond
                         (and (== dir "vertical")
                              (prop target `split_vertical))
                         (-> target `split_vertical)
                         (and (== dir "horizontal")
                              (prop target `split_horizontal))
                         (-> target `split_horizontal)
                         (and (== dir "vertical")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_right" target (last (-> (control_holding_tank) `controls)))
                         (and (== dir "horizontal")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_below" target (last (-> (control_holding_tank) `controls)))
                         else
                         (notify (+ "No controls to split to" (prop target.options `name) " cannot be split"))))))


(defcontrol line_display ()
   ((menu_items (fn ()
                   [["Test" (fn ()
                               (notify "Notify Test Menu"))]]))
    (current_value (or "Not Set"))
    (set (fn (val)
            (progn
               (= current_value val)
               (do_render))))
    (render (fn ()
               (div { `class: "juno-mono-space" `style: "white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" }
                current_value))))
   {
       `buffer_bar: false
       `expose: [[`set set]]
       `usage: []
   })




(defun build_documentation_datalist ()
   (let
      ((keywords (new Set))
       (dlist_id "documentation_datalist")
       (dlist nil))
      (for_each (pset (pairs *tags_to_meta*))
         (progn
            (-> keywords `add pset.0)
            (-> keywords `add (first (split_by "/" pset.1.0)))
            (for_each (`target pset.1)
               (-> keywords `add (second (split_by "/" target))))))
      (= dlist (datalist { `id: dlist_id } (for_each (keyword (sort (to_array keywords)))
                            (option keyword))))
      (aif (get_by_id dlist_id)
          (-> it `remove))
      (-> (first (get_by_tag "body"))
          `append dlist)))

(defglobal *building_document_index* false)

(defun build_tag_index ()
   (unless *building_document_index*
      (setq *building_document_index* true)
      (let
         ((new_db {})
          (stime (time_in_millis))
          (env nil)
          (is_reindex? (if (== (length (keys *tags_to_meta*)) 0)
                           false
                           true)))
         (for_each (ns (namespaces))
            (progn
               (= env (-> Environment `get_namespace_handle ns))
               (for_each (pset (pairs env.definitions))
                  (destructuring_bind (name def)
                     pset
                     (when def.tags
                        (when is_reindex?
                           (sleep 0.005))
                        (for_each (tag def.tags)
                           (when (and (is_string? tag)
                                      (not (== tag "constructor")))
                              (if (eq nil (prop new_db tag))
                                  (set_prop new_db
                                     tag
                                     []))
                              (assert (prop new_db tag) (+ "Error: tag " tag " should be a place in new_db"))
                              (push (prop new_db tag)
                                    (+ "" ns "/" name)))))))
               ;; add direct links for each global, even if they refer to themself, so they are searchable
               (for_each (name (keys env.context.scope))
                  (progn
                     (if (eq nil (prop new_db name))
                         (set_prop new_db name []))
                     (push (prop new_db name)
                           (+ "" ns "/" name))))))
         (= *tags_to_meta*
            new_db)
         (build_documentation_datalist)
         (if (> __VERBOSITY__ 2)
             (log (+ "build_tag_index: time to index: " (- (time_in_millis) stime) "ms  " (if is_reindex? " (throttled)" ""))))
         (setq *building_document_index* false)))
      
   {
     `description: "Builds or rebuilds the tag index as held in *tags_to_meta* for use by the documentation facility."
     `tags: ["help" "index" "tags" "rebuild" "documentation" ]
     `usage: []
   })

(defun search_documentation_index (search_text target_element)
   (if (and (is_string? search_text)
              (> search_text.length 1)
              (is_element? target_element))
      (let
         ((results_by_ns {})
          (target nil)
          (ns nil)
          (sym nil)
          (not_found (fn () true))
          (comps []))
         ;(log "searching for " search_text)
      ;; do we have tags?
      (when (prop  *tags_to_meta* search_text)
         (for_each (command (prop  *tags_to_meta* search_text))
            (progn
               (= comps (split_by "/" command))
               (= ns (first comps))
               ;(log "ns: " ns comps.1)
               (if (eq nil (prop results_by_ns ns))
                   (set_prop results_by_ns
                      ns
                      {}))
               (set_prop (prop results_by_ns ns)
                         comps.1
                         (resolve_path [ `definitions comps.1 ] (-> Environment `get_namespace_handle ns))))))
      (for_each (ns (namespaces))
         (progn
            (= comps (split_by "/" search_text))
            (if (> comps.length 1)
                (= sym (second comps))
                (= sym (first comps)))
            (unless (resolve_path [ ns sym ] results_by_ns)
               (aif (resolve_path [ `definitions sym ] (-> Environment `get_namespace_handle ns))
                    (progn
                       (make_path [ ns sym ] results_by_ns it)))
               (aif (resolve_path [ `global_ctx `scope sym ] (-> Environment `get_namespace_handle ns))
                    (progn
                       (make_path [ ns sym ] results_by_ns 
                                  {
                                      `name: sym
                                      `description: (+ "Undocumented: " (sub_type it))
                                  }))))))
      (when (> __VERBOSITY__ 0)
         (log "search_documentation_index: results:" results_by_ns))
      
      (try
         (= target
            (div
               (for_each (ns_title (keys results_by_ns))
                  [(details { `open: true `style: "margin-bottom: 10px;"  }
                            (summary { style: "font-size: 1.2em; color: var(--namespace-color); font-weight: bold" } ns_title)
                            (table { `style: "width: 100%;font-size: 1.1em; background: var(--editor-bg-color);" }
                                   (thead
                                      (tr (th { `style: " padding: 5px;" } "Symbol Name") 
                                          (th { `style: "width: 100%; padding: 5px;" } "Description")))
                                   (tbody
                                      (for_each (pset (sort (pairs (prop results_by_ns ns_title))
                                                            { `key: [ 0 ] }))
                                         (destructuring_bind (k meta_obj)
                                            pset
                                            (when k
                                               
                                               (defvar desc "")
                                               (defvar stype (try 
                                                                (or (first (reduce (m (meta_for_symbol k true))
                                                                              (when (and (== m.namespace ns_title)
                                                                                         m.type)
                                                                                 m.type)))
                                                                    (progn
                                                                       (defvar tmp (-> Environment `get_global (+ ns_title "/" k) not_found))
                                                                       (if (== tmp not_found)
                                                                           "undefined"
                                                                           (sub_type tmp))))
                                                                (catch Error (e)
                                                                   "unknown")))
                                               (tr { `style: " vertical-align:top;" }
                                                   (td { `class: (+ "juno-requires " "juno-type-" (lowercase stype))
                                                         `tabindex: 0 
                                                         `title: stype
                                                         `style: "line-height: 1.5em; min-width: 200px; cursor: pointer; border-bottom: 1px solid var(--main-accent-line); padding-bottom: 10px; margin-bottom: 10px; padding-right: 5px; font-weight: bold; text-align: right; vertical-align:top;" } 
                                                       k)
                                                   (td { `style: "line-height: 1.5em; border-bottom: 1px solid var(--main-accent-line); margin-bottom: 10px;vertical-align:top;  padding-bottom: 10px; width: calc(100% - 150px);" }
                                                       (or (and meta_obj.description
                                                                (try 
                                                                   (progn
                                                                      (= desc (prop (unpack_description meta_obj.description) `innerText))
                                                                      (if (> desc.length 150)
                                                                          (= desc (+ (-> desc `substr 0 150) "...")))
                                                                      (div { `style: "" }
                                                                           desc))
                                                                          
                                                                   (catch Error (e)
                                                                      (+ "error: " e.message " - can't unpack description"))))
                                                           "(No Description)")))))))))])))
         (catch Error (e)
            (log "ERROR: " e.message e)))
      (-> target_element `replaceChildren target)
      (setTimeout (fn ()
                     (focus_to target.children.0.children.0))
                  50))
      (log "Inproper args to search_documentation_index: " search_text)))


;; place holder for the control reference by juno_documentation_control
(defun toggle_help_panel ()
   true)

(defcontrol juno_documentation_control ()
   ((definition_view (div { `class: "juno-log-output" `style: "margin-top: 15px; padding: 5px; overflow: scroll; width: calc(100% - 20px);" } "Help Introduction"))
    (search_input (input { `type: "search" `list: "documentation_datalist" `placeholder: (dtext "Search Documentation") `style: "font-weight: bold; display: inline-block; padding: 10px; width: calc(100% - 10px); border: 0px; background: var(--editor-bg-color); color: var(--main-color);" } ))
    (search_bar_elem (div { `style: "display: inline-block; width: calc(100% - 0px);height: 20px;" }
                          search_input))
    (search_result_view (div { `style: "overflow: scroll; height: calc(100% - 10px);  width: calc(100% - 20px); " }
                             (div { `style: "width: 100%; text-align: center; margin-top: 15px; padding: 10px; font-size: 1.2em;" } (dtext "Type Search Text and Press Enter"))))
    (search_view (div { `style: "display: inline-block; height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden; padding: 5px;" 
                        `class: "juno-display-none" } 
                      (div { `style: "display: inline-block; margin-top: 15px; font-weight: bold; padding: 5px; font-size: 1.2em;" }  
                           (dtext "Search Results"))
                      search_result_view))
    (upper_content_view (div { `class: "juno-log-output" `style: "padding: 5px;height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden;" } 
                             search_bar_elem
                             search_view
                             definition_view))
    (content_view (div { `class: "juno-log-output" `style: "padding: 5px;height: calc(100% - 35px); width: calc(100% - 10px); overflow: hidden;" } 
                   upper_content_view))
    (on_resize (fn (self)
                  (progn
                     (set_style [["height" (+ "calc(100% - " search_bar_elem.offsetHeight "px") ]] content_view))))
    (name "Juno Documentation")
    (title_span (span { `style: "font-weight: bold; margin-right: 15px;" } (dtext "Documentation")))
    (back_button (button { `disabled: true } (+ "<" " " (dtext "Go Back"))))
    (pin_button (button { } (dtext "Pin")))
    (history_button (button { } (dtext "History")))
    (pinned? (fn ()
                (or (has_class? "juno-button-on" pin_button)
                    (not (has_class? "juno-display-none" search_view)))))
    (history [])
    (history_max_length 15)
    (current_symbol nil)
    (handle_click (fn (e)
                     (progn
                        (log "requires: " e.srcElement.innerText)
                        (cond
                           (has_class? "juno-requires"  e.srcElement)
                           (progn
                              
                              (show_documentation e.srcElement.innerText))
                           (has_class? "juno-tag" e.srcElement)
                           (progn
                              (-> self `search_by_tag e.srcElement.innerText))))))
    (control_bar_elements [back_button pin_button history_button])
    (render_command_elem (fn (command)
                            (let
                               ((results (describe command true)))
                               (for_each (meta_obj (or results ()))
                                  (format_help meta_obj { `on_click: handle_click } )))))
    
    (render_help (fn (command)
                    (div { `class: "" `style: "overflow-x: hidden;" }
                         (for_each (v (to_array (or (render_command_elem command) [])))
                            (div { `style: "padding: 5px; margin-bottom: 10px; background: var(--editor-bg-color);" }
                                 v)))))
    (search_by_tag (fn (tagname)
                      (progn
                         (set_prop search_input `value tagname)
                         (enable_search)
                         (search_documentation_index tagname search_result_view))))
    (remove_all_priors (fn (command)
                          (progn
                             (for_each (elem (-> history_content_view `querySelectorAll (+ "[command='" command "']")))
                                (try
                                   (if (is_element? elem)
                                       (-> elem.parentElement `remove))
                                   (catch Error (e)
                                      (log "ERROR: on remove: " e.message (sub_type elem)))))
                             (when (contains? command history)  ;; if history contains the command name already, remove it and display it first
                                  (defvar idx (index_of command history))
                                  (if (< idx 0)
                                      (notify "cannot find history item, even though contains? said it was there.")
                                      (-> history `splice idx 1))))))
    
    (message_receiver (fn (event_obj force)
                         (let
                            ((first_arg (let
                                           ((comps (split_by "(" event_obj.args.0)))
                                           (or (second comps)
                                               (first comps))))
                             (num_found_in_history_view 0)
                             (dup_remover {})
                             (new_view nil))
                            
                            ;; deal with recording the history 
                            (when first_arg
                               ;; if there is anything in the history view that matches it, remove it so we can put it back on top
                               (remove_all_priors first_arg)
                               (= num_found_in_history_view (length (to_array (-> history_content_view `querySelectorAll (+ "[command='" first_arg "']")))))
                               (push history
                                  first_arg)
                               (if (pinned?)
                                   (-> history_content_view `prepend (render_help first_arg))
                                   (if (> (length history) 1)
                                       (-> history_content_view `prepend (render_help (prop history (- (length history) 2)))))))
                            
                            ;; if the history is too long, prune it
                            (when (> (length history) history_max_length)
                               (take history)
                               (aif (last history_content_view.children)
                                    (-> it `remove)))
                            
                            (if (> history.length 1)
                               (set_enabled back_button)
                               (set_disabled back_button))
                            ;(log "message_receiver: history: " history "first_arg: " first_arg)
                            (when (or (and force first_arg)
                                      (and first_arg
                                         (not (pinned?))))
                               (= current_symbol first_arg)
                               (-> definition_view `replaceChildren
                                  (render_help current_symbol))))))
    (go_back (fn ()
                (when (> history.length 1)
                   (pop history)
                   (defvar hist_item (pop history))
                   (when hist_item
                      (message_receiver { `args: [ hist_item ] })))))
             
                   
    (handler_function_id (gen_id "hid"))
    (history_mode? (fn ()
                      (has_class? "juno-button-on" history_button)))
    (history_content_view (div { `style: "overflow: scroll; height: calc(100% - 10px); width: calc(100% - 20px;) overflow: scroll;" } ))
    (history_view (div { `class: "juno-log-output" `style: "height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden; padding: 5px;" } 
                       history_content_view))
    (show_documentation (fn (text)
                           (progn
                              (hide_search_view)
                              (message_receiver { `args: [ text ] }))))
    (take_focus (fn ()
                   (focus_to search_input)))
    (split_view nil)
    (show_history (fn (show?)
                       (let
                          ()
                          (if show? ;; update our button
                             (add_class "juno-button-on" history_button)
                             (remove_class "juno-button-on" history_button))
                          (cond
                             (and (history_mode?)
                                  (is_control? split_view))
                             nil ;; already showing
                             (and (history_mode?)
                                  (eq nil split_view))
                             (progn
                                (-> upper_content_view `remove)
                                (= split_view
                                   (split_view_horizontal upper_content_view history_view))
                                (-> content_view
                                   `replaceChildren
                                   split_view.view))
                             (not (history_mode?))
                             (progn
                                (-> split_view.view `remove)
                                (-> split_view `destroy)
                                (= split_view nil)
                                (-> content_view
                                   `replaceChildren
                                   upper_content_view))))))
                             
    (reindex_timer nil)                      
    (is_displayed? (fn ()
                      (progn
                         (defvar ctl_holding_tank (control_holding_tank))
                         (if (->  ctl_holding_tank `has_control? self)
                             false
                             true))))
    (render (fn ()
               (if (not initialized)
                   view)))
    (on_render (fn ()
                  (when current_symbol
                     (-> definition_view `replaceChildren
                        content_view))))
    (enable_search (fn ()
                      (progn
                         (remove_class "juno-display-none" search_view)
                         )))
    
    (hide_search_view (fn ()
                         (progn
                            (add_class "juno-display-none" search_view))))
                           
    (on_initialize (fn (anything_here)
                      (progn
                         
                         (register_event_handler nil "display_usage" handler_function_id message_receiver)
                         (attach_event_listener pin_button
                            `click
                            (fn (e)
                               (if (has_class? "juno-button-on" pin_button)
                                   (remove_class "juno-button-on" pin_button)
                                   (add_class "juno-button-on" pin_button))))
                         (attach_event_listener history_button
                            `click
                            (fn (e)
                               (progn
                                  (show_history (not (history_mode?))))))
                         
                         (attach_event_listener search_input
                            `click
                            (fn (e)
                               (progn
                                  (sleep 0.05)
                                  (if (blank? search_input.value)
                                      (hide_search_view)
                                      (enable_search)))))
                         (attach_event_listener search_input
                            `keydown
                            (fn (e)
                                  (cond
                                     (and (== e.key "Escape")
                                          e.shiftKey)
                                     (progn
                                        (handle_event e)
                                        (toggle_help_panel))
                                     (== e.key "Escape")
                                     (progn
                                        (handle_event e)
                                        (set_prop search_input
                                           `value
                                           "")
                                        (hide_search_view)))))
                         (attach_event_listener search_input
                            `keyup
                            (fn (e)
                               (progn
                                  (when (== e.key "Enter")
                                     (search_documentation_index e.srcElement.value search_result_view))
                                  (if (> (length search_input.value) 0)
                                      (enable_search)
                                      (hide_search_view)))))
                         (attach_event_listener back_button
                            `click
                            (fn (e)
                               (go_back)))
                         (attach_event_listener view`
                            `keyup
                            (fn (e)
                               (cond
                                  (and (== e.key "Enter")
                                       (has_class? "juno-requires" e.srcElement))
                                  (show_documentation e.srcElement.innerText)
                                  (and (== e.key "Enter")
                                       (has_class? "juno-tag" e.srcElement))
                                  (search_by_tag e.srcElement.innerText)
                                  (== e.key "Escape")
                                  (focus_to search_input))))
                         (attach_event_listener search_result_view
                            `click
                            (fn (e)
                               (when (has_class? "juno-requires" e.srcElement)
                                  (show_documentation e.srcElement.innerText))))
                         
                         (build_tag_index)
                         (= reindex_timer
                            (setInterval build_tag_index 60000))
                         anything_here)))
    (on_destroy (fn (anything_here)
                   (progn
                      (remove_event_handler nil "display_usage" handler_function_id)
                      (if reindex_timer
                         (clearInterval reindex_timer))
                      true)))
    (set_pinned (fn (value)
                  
                   (cond
                      (== value current_symbol)
                      (add_class "juno-button-on" pin_button)
                      (is_string? value)
                      (progn
                         (add_class "juno-button-on" pin_button)
                         (message_receiver { args: [ value ] } true))
                      else
                      (add_class "juno-button-on" pin_button))))
    (release_pin (fn ()
                    (remove_class "juno-button-on" pin_button)))
    
    )
   {
     `control_bar: true
     `expose: [[ `set_pinned set_pinned]
               [ `search_by_tag search_by_tag ]
               [ `is_displayed? is_displayed? ]
               [ `take_focus take_focus ]
               [ `get_history (function () (clone history)) ]]
     `usage: []
     })

;; hide the documentation control behind a singleton function

(defun juno_documentation (options)
   (aif (get_control_by_name "Juno Documentation")
        it
        (juno_documentation_control options))
   {
       `tags: ["help" "control" "show" "search" "tags" "documentation" ]
       `usage: ["options:object"]
       `description: "Creates a new documentation control if none exists and return it, otherwise returns the existing documentation control."
   })


(defun toggle_help_panel (focus_to_help?)
   (progn
      (defvar ctl_holding (control_holding_tank))
      (defvar focused *last_focus*)
      (try
         (cond
            (-> ctl_holding `has_control? (juno_documentation))
            (progn
               ((fn () (place_control `right (juno_documentation))))
               (cascade_resize)
               (when (not focus_to_help?)
                  (setTimeout (fn ()
                                 (progn
                                    (focus_to_editor focused))) 5)))
            (get_control_by_name "Juno Documentation")
            (hide_control (juno_documentation))
            else
            (progn
               (defvar ctl (juno_documentation))
               (log "initialized new juno_documentation")
               ((fn () (place_control `right ctl)))
               (when (not focus_to_help?)
                  (setTimeout (fn ()
                                 (progn
                                    (focus_to_editor focused))) 5))))
               
         (catch Error (e)
            (notify (+ "Unable to open help panel: " e.message)))))
   {
     `description: "Shows the documentation panel if it is not displayed."
     `tags: ["help" "show" "documentation" ]
     `usage: []
     })

(defun show_help_panel (focus_to_search)
   (let
      ((ctl (get_control_by_name "Juno Documentation")))
      (cond
         (and ctl (-> ctl `is_displayed?))
         true
         else
         (progn
            (toggle_help_panel true)))
      (if focus_to_search
         (setTimeout (fn () 
                        (progn
                           (= ctl (get_control_by_name "Juno Documentation"))
                           (-> ctl `take_focus)) 20))))
   {
     `description: "Shows the documentation panel if it is not displayed."
     `tags: ["help" "show" "documentation" ]
     `usage: []
     })
        
             
     
  

(defun *help_menu_function* ()
  [["Toggle Documentation" (fn () 
                              (toggle_help_panel)) ]])

(defun tag_selector (options tags)
   (let
      ((sorted_tag_names (sort (keys *tags_to_meta*)))
       (tag_dlist_id (gen_id `tags))
       (tag_dlist (datalist { `id: tag_dlist_id }
                         (for_each (t sorted_tag_names)
                            (option t))))
       (tag_view (div { `style: "display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start;" }))
       (current_tag nil)
       (extra_space (if (is_number? options.extra_space)
                        options.extra_space
                        2))
       (empty_text (or options.empty_text "name?"))
       (tag_content (fn ()
                       (uniq (reduce (text (each tag_view.children `value))
                                (unless (== empty_text text)
                                   text)))))
       
       (focus_to_tag (fn (tag)
                        (try
                           (progn
                              (-> tag `select))
                           (catch Error (e)
                              (log "error: " e.message)))))
       
       (already_have_tag? (fn (text)
                             (let
                                ((found nil))
                                (for_each (elem (or tag_view.children []))
                                   (when (== elem.value text)
                                      (= found elem)
                                      (break)))
                                found)))
       (value_count (fn (text)
                       (let
                          ((count 0))
                          (for_each (elem (or tag_view.children []))
                             (when (== elem.value text)
                                (inc count)))
                          ;(log "Count is: " count text)
                          count)))
       (prune_empties (fn ()
                         (for_each (t (or tag_view.children []))
                            (if (== t.value empty_text)
                                (-> t `remove)))))
       (adjust_size (fn (elem)
                       (try
                          (if (== elem document.activeElement)
                              (progn
                                 (set_style [["width" (+ "" (+  extra_space elem.value.length) "ch")]] elem))
                              (progn
                                 (set_style [["width" (+ "" (+  2 elem.value.length) "ch")]] elem)))
                          (catch Error (e)
                             (log "ERROR: " e.message)))))
       (new_tag (fn (text focus?)
                   (aif (already_have_tag? text)
                       (if focus? 
                          (focus_to_tag it)
                          false)
                       (let
                          ((tag (input { tabindex: 0
                                         class: "juno-editable"
                                         style: "padding: 5px;margin-right: 10px;"   
                                         list: tag_dlist_id
                                         contenteditable: true
                                         value: text }
                                        )))
                          (adjust_size tag)
                          (-> tag_view `append
                             tag)
                          (when focus?
                             (sleep 0.001)
                             (focus_to_tag tag))))))
       
       (view (div { `style: "position: relative;" }
                  tag_dlist
                  tag_view)))
      
      (attach_event_listener tag_view
         `keydown
         (fn (e)  ;; don't allow spaces in tags
            (cond 
               (or (== e.key "Enter")
                   (contains? e.key "/[]{}():;.,<>|\\\\=`~"))
               (handle_event e)
               (and (== e.key " ")
                    (not (== e.srcElement (last tag_view.children))))
               (handle_event e)
               ;; if we are at the end and we have a `blank?` ie. empty_text (default `name?`), release the focus 
               (and (== e.key "Tab")
                    (== e.srcElement (last tag_view.children))
                    (== e.srcElement.value empty_text))
               (progn
                  (if (> (length tag_view.children) 1)
                      (-> e.srcElement `remove)))
               
               ;; if we have a filled out tag, and are on the last tag, create a new one with tab or space is pressed
               (and (or (== e.key "Tab")
                        (== e.key " "))
                    (not e.shiftKey)     
                    (== e.srcElement (last tag_view.children))
                    (> (length e.srcElement.value) 1))
               (progn
                  (handle_event e)
                  (new_tag empty_text true))
               (and (== e.key "Tab")
                    e.shiftKey
                    (== e.srcElement.value empty_text))
               (progn
                  (handle_event e)
                  (let
                     ((prior e.srcElement.previousSibling))
                     (-> e.srcElement `remove)
                     (if prior
                        (focus_to_tag prior))))
               (and (== e.key "Backspace")   ;; remove when tag has no content
                    (== e.srcElement.value empty_text))
               (let
                  ((prior e.srcElement.previousSibling)
                   (next e.srcElement.nextSibling))
                  (handle_event e)
                  (-> e.srcElement `remove)
                  (cond
                     prior
                     (focus_to_tag prior)
                     next
                     (focus_to_tag next)
                     (== (length tag_view.children) 0)
                     (new_tag empty_text true))))))
              
               
                    
      
      (attach_event_listener tag_view
         `keyup
         (fn (e)
            (progn
               (cond
                  (and (== e.key "Backspace") 
                       (blank? e.srcElement.value))
                  (progn
                     (set_prop e.srcElement `value empty_text)
                     (focus_to_tag e.srcElement)))
               (adjust_size e.srcElement)
               (if (> (value_count e.srcElement.value) 1)
                   (add_class "juno-input-error" e.srcElement )
                   (remove_class "juno-input-error" e.srcElement))
               (set_prop e.srcElement
                  `value
                  (lowercase e.srcElement.value))
               (when options.on_change
                  (-> options `on_change (tag_content))))))
      
      (attach_event_listener tag_view
         `focusin
         (fn (e)
            (progn
               (focus_to_tag e.srcElement))))
      
      (attach_event_listener view
         `focusout
         (fn (e)
            (progn
               (adjust_size e.srcElement)
               (when options.on_change
                  (-> options.on_change (tag_content))
               ))))
      
      (if (and (is_array? tags)
               (> tags.length 0))
          (for_each (tag (or tags []))
             (new_tag tag))
          (new_tag empty_text))
      ;(setTimeout (fn () (focus_to_tag tag_view.children.0)) 10)
      view)
   {
     `description: (+ "Creates a simple DOM Element for creating or editing an "
                      "array of tags (unique strings).  Uses the *tags_to_meta* "
                      "object as a dependency to build the data list selections "
                      "for the tags.  Given an initial array of tags, these "
                      "provided tags will be presented, otherwise a new tag "
                      "with the empty text will be generated and displayed as "
                      "a means to start creating a list of tags.<br>"
                      "Options:<br>"
                      "empty_text:string - When a new tag is generated this "
                      "provided text is shown.  The default is 'name?'<br>"
                      "extra_space:number - How many characters to optionally "
                      "pad the input elements, since the width of the elements "
                      "are measured by the 'ch' unit.<br>"
                      "on_change:function - When a change occurs to a tag, "
                      "or when a tag is removed or created, this function " 
                      "is called with an array of strings, representing the "
                      "tag set that the user is editing.<br>")
     `usage: ["options:object" "tags:array"]
     `tags: ["view" "DOM" "tags" "edit" "manage" "tag" "element"]
     })

(defun_sync get_cursor_position (element)
  (javascript | {
                  let position = 0;
                  const isSupported = typeof window.getSelection !== "undefined";
                  if (isSupported) {
                       const selection = window.getSelection();
                       if (selection.rangeCount !== 0) {
                              const range = window.getSelection().getRangeAt(0);
                              const preCaretRange = range.cloneRange();
                              preCaretRange.selectNodeContents(element);
                              preCaretRange.setEnd(range.endContainer, range.endOffset);
                              position = preCaretRange.toString().length;
                              }
                       }
                  return position;
                  } |))

(defun_sync get_caret_coordinates ()
   (javascript | {
                   let x = 0,
                   y = 0;
                   const isSupported = typeof window.getSelection !== "undefined";
                   if (isSupported) {
                                      const selection = window.getSelection();
                                      if (selection.rangeCount !== 0) {
                                                                        const range = selection.getRangeAt(0).cloneRange();
                                                                        range.collapse(true);
                                                                        const rect = range.getClientRects()[0];
                                                                        if (rect) {
                                                                                    x = rect.left;
                                                                                    y = rect.top;
                                                                                    }
                                                                        }
                                      }
                   return { x, y };
                   } | ))

(defun_sync element_to_lisp (element options)
   (if (is_element? element)
       (let
          ((tag_name (if (is_function? options.tagname_for_element)
                         (-> options `tagname_for_element element)
                         element.tagName))
           (ns (if (is_string? options.use_ns)
                   (+ options.use_ns "/")
                   ""))
           (elem_as_lisp (list (+ "=:" ns (lowercase tag_name))))
           (acc [])
           (nodes nil)
           (ptype nil)
           (val nil)
           (attrib_list (prop element `attributes))
           (attribs {}))
          (for_each (attrib_num (range (length attrib_list)))
             (progn
                (set_prop attribs
                   (resolve_path [ `attributes attrib_num `name ] element)
                   (resolve_path [ `attributes attrib_num `value ] element))))
          (push elem_as_lisp
             attribs)
          (= nodes element.childNodes)
          (for_each (cnum (range (length nodes)))
             (cond 
                (== 3 (resolve_path [ cnum `nodeType ] nodes))
                (push elem_as_lisp
                   (if (is_function? options.on_text)
                       (-> options `on_text (resolve_path [ cnum `nodeValue] nodes) nodes)
                       (resolve_path [ cnum `nodeValue] nodes)))
                (== 1 (resolve_path [ cnum `nodeType ] nodes))
                (push elem_as_lisp
                   (element_to_lisp (resolve_path [ cnum ] nodes) options))))
          (if (is_function? options.on_element_complete)
              (-> options `on_element_complete elem_as_lisp)
              elem_as_lisp))
       [ "UNKNOWN:" element ])
   {
     `description: (+ "Given a DOM element, returns the lisp represenation of the DOM element.<br>"
                      "If provided with an options object, the following keys are applicable:<br>"
                      "tagname_for_element:(fn element) - For every new element encountered in the "
                      "provided tree, will be called with the new element.  The function should "
                      "return a string value to be used for the tagname as opposed to the original "
                      "element tagName value.<br>"
                      "use_ns:string - Qualify the emitted tag symbols with the provided namespace.<br> "
                      "on_text:(function text nodes) - Will be called on a text node with the text and "
                      "and the sibling nodes.<br>"
                      "on_element_complete:(function array) - Will be called with the quoted lisp form "
                      "that was constructed.  The function can then manipulate the completed form "
                      "prior to it being placed in the returned lisp form.  Note that this function "
                      "is called for every completed element, not just the final return value.")
     `usage: ["element:element" "options:object"]
     `tags: ["DOM" "ui" "serialize" "serialization" "view" "element" ]
   })




;; verbs for our editing command language

(defmacro get_selection ()
      `(-> window `getSelection))

(defun_sync get_range (selection index)
   (-> selection `getRangeAt (or index 0)))

(defmacro remove_all_ranges (selection)
   `(-> ,#selection `removeAllRanges))

(defmacro collapse_to_start (selection)
   `(-> ,#selection `collapseToStart))

(defmacro collapse_to_end (selection)
   `(-> ,#selection `collapseToEnd))

(defun_sync select_element (elem)
   (-> (get_selection) `selectAllChildren elem))

(defun_sync move_to_point (point_obj)
   (progc
      (when point_obj.selection
         (focus_to (if (== point_obj.pos_type 1)
                       point_obj.pos_node
                       point_obj.pos_node.parentElement))
         (defvar selection (get_selection))
         (remove_all_ranges selection)
         (-> selection `addRange point_obj.range))))
         
(defun_sync move_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `move dir (or granularity "character"))))))

(defun_sync extend_from_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `extend dir (or granularity "character"))))))

(defun point_for (root_element)
   (let
      ((selection (get_selection))
       (selrange (get_range selection))
       (selected_node selrange.startContainer)
       (offset selrange.startOffset)
       (position (progn
                    (if (== selrange.startContainer.nodeType 3)
                        (progn
                           (get_cursor_position selrange.startContainer.parentElement))
                        selrange.endOffset)))
       (current_element selected_node)
       (path []))
      (while (and (not (eq current_element nil))
                  (not (== current_element root_element)))
         (progn
            (prepend path current_element)
            (= current_element current_element.parentElement)))
      { dom_path: path
        position: position
        pos_type: selected_node.nodeType
        pos_node: selected_node
        selection: selection
        range: selrange
        }))

(defun_sync select_node_at_point ()
   (let
      ((selection (get_selection))
       (selrange (get_range selection)))
      (if (== selrange.startContainer.nodeType 3)
         (-> selection `selectAllChildren selrange.startContainer.parentElement)
         (-> selection `selectAllChildren selrange.startContainer))))
       
      
(defun_sync get_text_around_point (point)
   (let
      ((text [])
       (elem nil))
      (progc
         (when point
            (cond 
               (== point.pos_type 1)
               (progn
                  (= elem point.pos_node))
               (== point.pos_type 3)
               (progn
                  (= elem point.pos_node.parentElement))))
         (when elem
            (push text
               (-> elem.innerText `substr 0 point.position))
            (push text
               (-> elem.innerText `substr point.position)))
         text))
   {
       description: (+ "Given a point object,returns an array that can "
                       "contain up to two strings.  The first value, at position "
                       "0, is the element text pior to the point's position. "
                       "The second value is the text of the element after "
                       "the point's position.")
       usage: ["point_object:object"]
       tags: ["DOM" "point" "edit" "selection" "editor" "select"]
   })
         
            
               
(defun_sync point_tag_path (point)
   (for_each (c point.dom_path)
      (progn
         (if (== 1 c.nodeType)
             c.tagName
             "text")))
   {
       `description: "Given a point object, returns the tag names that comprise the path to the point."
       `usage: ["point:object"]
       `tags: ["point" "editor" "DOM" "selection" "select"]
   })



(defun insert_elem_at_point (elem under_root)
      (try
         (let
            ((selection (get_selection))
             (selrange (-> selection `getRangeAt 0))
             (parent_element (if (== selrange.startContainer.nodeType 3)  ;; text node
                                 selrange.startContainer.parentElement
                                 selrange.startContainer))
             (offset selrange.startOffset)
             (remaining_text nil))
            ;; extend it from the current point
            
            (-> selrange `setEndBefore parent_element.nextSibling)
            (= remaining_text (-> selrange `toString))
            (-> selection `deleteFromDocument)
            (= selection (get_selection))
            (remove_all_ranges selection)
            (-> selection `addRange selrange)
            (-> parent_element `append elem remaining_text)
            (collapse_to_start selection))
         (catch Error (e)
            (log (+ "ERROR: insert_elem_at_point:" e.message)))))


(defun_sync point_under_element_tag? (tag_name point)
   (contains? tag_name (point_tag_path point))
   {
       description: (+ "Returns true if the provided editor point is in a "
                        "DOM tree containing the provided tagname, otherwise false.")
       usage: ["tag_name:string" "point:object"]
       tags: ["editor" "point" "cursor" "DOM" "tree" "element"]
   })



(defun DOM_to_markdown (quoted_dom _acc _ctx)
   (let
      ((acc (or _acc []))
       (ctx (new_ctx _ctx))
       (process_children (fn (children)
                            (progn
                               (for_each (child (or children []))
                                  (DOM_to_markdown child acc ctx)))))
       (tag nil))
      ;(log "DOM_to_markdown: " (getf_ctx ctx `tag) (getf_ctx ctx `in_pre))
      (cond
         (is_array? quoted_dom)
         (progn
            (= tag (if (is_reference? (first quoted_dom))
                       (first quoted_dom)
                       nil))
            (if (not (eq nil ctx.parent))
                (= ctx (new_ctx ctx)))
            (setf_ctx ctx `tag tag)
            ;(log "quoted_dom: " (is_reference? (first quoted_dom)) (getf_ctx ctx `tag) (pretty_print quoted_dom))
            
            ;; below are the rules to encode or handle certain elements in specific ways
            (cond
               (and tag
                  (== tag (quote div)))
               (progn 
                  (unless (or (blank? (prop quoted_dom 2))
                              (and (is_string? (prop quoted_dom 2))
                                   (blank? (trim (prop quoted_dom 2)))))
                     ;(log "DOM to markdown: " (pretty_print quoted_dom))
                     (push acc "<br>")
                     (process_children (rest quoted_dom)))
                  ;(push acc "<br>")
                  )
               (and tag
                  (== tag (quote pre)))
               (progn
                  (setf_ctx ctx `in_pre true)
                  ;(log "pre: " (pretty_print quoted_dom))
                  (defvar higher_acc acc)
                  (= acc [])
                  (push acc "```")
                  (process_children (rest quoted_dom))
                  (push acc "```<br>")
                  (push higher_acc (join "" acc))
                  (= acc higher_acc))
               (and tag
                  (== tag (quote hr))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (push acc "<br>---<br>"))
               (and tag
                  (starts_with? (+ "=:" "h") tag)
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (defvar higher_acc acc)
                  (= acc [])
                  (push acc (+ "<br>" 
                               (join "" (for_each (r (range (int (-> tag `substr 3))))
                                           "#"))))
                  (process_children (rest quoted_dom))
                  (push acc "<br>")
                  (push higher_acc (join " " acc))
                  (= acc higher_acc))
               (and tag
                  (== tag (quote p))
                  (is_object? (second quoted_dom))
                  (blank? (prop quoted_dom 2))
                  (not (getf_ctx ctx `in_pre)))
               true ; ignore blank paragraphs 
               (and tag
                  (== tag (quote code))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (unless (blank? (prop quoted_dom 2))
                     (push acc (+ "`" (prop (eval quoted_dom) `innerText) "`"))))
             
               else  
               (process_children (rest quoted_dom))))
         (is_string? quoted_dom)
         (progn
            ;(log "adding from " (getf_ctx ctx `tag) quoted_dom)
            (push acc quoted_dom)))
      acc))

(defparameter *markdown_rules*
   {
     reload_rules:{
         on_event: `keydown
         key_sequence: "Alt-L"
         handle_event: true
         menu: true
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (notify (+ "Reloading Markdown Rules: " ctl.name))
                     (-> ctl `reload_rules)))
         
     }
     get_as_wordwrap_text:{
         on_event: `keydown
         key_sequence: "Alt-X"
         handle_event: true
         menu: true
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (-> ctl `save)
                     (sleep 0.1)
                     (defglobal $ed_rval (for_each (line (word_wrap (join "" (DOM_to_markdown  (-> ctl `get)))))
                                            (if (ends_with? " " line)
                                                line
                                                (+ line " "))))
                     (destroy_control ctl)))
     }
     get_as_markdown_text:{
         on_event: `keydown
         key_sequence: "Alt-R"
         handle_event: true
         menu: true
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (-> ctl `save)
                     (sleep 0.1)
                     (copy_text_to_clipboard
                        (pretty_print
                           (for_each (line (word_wrap (join "" (DOM_to_markdown  (-> ctl `get)))))
                              (if (ends_with? " " line)
                                  line
                                  (+ line " ")))))))
     }
     copy_as_quoted:{
         on_event: `keydown
         key_sequence: "Alt-Shift-Q"
         handle_event: true
         menu: true
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (copy_text_to_clipboard (pretty_print (-> ctl `get)))
                     (notify "Copied as quoted DOM to clipboard")))
     }
     on_blank:{
         on_event: `keyup
         key_sequence: "Backspace"
         menu: false
         handle_event: false
         qualifier: (fn (point ctl)
                       (progn
                          (defvar text (prop (-> ctl `get_root_element) `innerText))
                          (or (blank? text)
                              (== text "\n"))))
         exec: (fn (point ctl event)
                  (progn
                     (doc_exec `insertHTML "<div>Enter text!</div>")
                     (move_point `backward `character)
                     (select_node_at_point)))
     }
     insert_pre:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keyup
         menu: true
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "```"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-P"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: false       ;; we don't care about handling the event
         
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are already in a pre
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     ;(move_to_point point)
                     (doc_exec `insertHTML "<pre style='min-height: 2.4ch;'></pre><div ><br></div>" true)
                     (move_to_point point)
                     (move_point `forward `character)))
         
     }
     ;; the next two rules implement the handling of newlines in the preformatted text node
     ;; the keydown acts to cancel the default behavior of the event 
     ;; the keyup then performs the correct newline behavior for insertion of newlines
     insert_return_in_pre_down:{
         on_event: `keydown   ;; intercept the enter key in PRE tags to ignore any action on Enter
         key_sequence: "Enter"
         menu: false
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                        (progn
                           (point_under_element_tag? "PRE" point)))
         handle_event: true
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_return_in_pre_up:{
         on_event: `keyup   ;; intercept the enter key in PRE tags to add a newline vs. a new element
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                       (progn
                          false))
         handle_event: true
         menu: false
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_header: {
         on_event: `keyup
         prior_text_sequence: "# "
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point)))
         handle_event: true
         remove_if_prior: true
         menu: true
         exec: (fn (point ctl event)
                  (progc
                     (let 
                        ((preceeding_text (aif (prop (get_text_around_point point) 0)
                                               (last (split_by " " it))
                                               ""))
                         (hash_details (first (scan_str (new RegExp "[#]+$") preceeding_text)))
                         (num_hashes (if hash_details
                                         (length (prop hash_details 0))
                                         0))
                         ;; add one because our rule triggered so it deleted one and the space
                         (tag_name (+ "H" (clamp (+ num_hashes 1) 1 5)))
                         (point nil))   
                        
                        ;; since we have asked the editor to remove the matching text we are going to 
                        ;; remove the remaining and use that as a way to compute the Heading element we
                        ;; will add
                        (when (> num_hashes 0)
                           (for_each (c (range num_hashes))
                              (extend_from_point `backward `character))
                           (doc_exec `delete nil))
                        (doc_exec `insertHTML (+ "<" tag_name ">Heading</" tag_name ">"))
                        (move_point `backward `character)
                        (= point (point_for (-> ctl `get_root_element)))
                        (select_node_at_point)
                        )))
     }  
     insert_section:{
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keydown
         
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "%SCT"    
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-S"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: true       ;; we don't care about handling the event
         menu: true
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are in a pre tag
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     (defvar insert_point point)
                     (doc_exec `insertHTML "<br><details tabindex=0 open><summary>Summary Text</summary>Detail Text</details>" true)
                     (move_to_point insert_point)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (select_node_at_point)
                     ))
     }
     insert_horizontal_rule:{
          on_event: `keyup
          handle_event: true
          menu: true
          remove_if_prior: true
          prior_text_sequence: "---"    ;; when three dashes 
          qualifier: (fn (point ctl)
                        (progn
                           (not (point_under_element_tag? "PRE" point))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      (doc_exec `insertHTML "<hr/>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
     wrap_text_in_code_tag:{
          on_event: `keydown
          handle_event: true
          menu: true
          key_sequence: "Ctrl-Alt-C"
          remove_if_prior: true
          qualifier: (fn (point ctl)
                        (progn
                           (and (not (point_under_element_tag? "PRE" point))
                                
                                )))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      
                      (defvar text (-> (get_selection) `toString))
                      (doc_exec `insertHTML (+ "<code>" text "</code>"))
                      (select_node_at_point)
                      (collapse_to_end (get_selection))
                      (move_point `forward `character)
                      ;(doc_exec `insertHTML "<code>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
   })

;; placeholder
(defun wait_for_file_selection ()
   true)
   

(defun wrap_in_resizable (elem)
   (let
      ((move_state nil)
       (just_enable (== (get_attribute elem.parentElement "initializer") "wrap_in_resizable"))
       (expander_elem (if just_enable
                          elem.parentElement.children.1
                          (div { `style: "position: absolute; right: 0px; bottom: -10px; width: 15px; height: 15px; cursor: nwse-resize; background: tranparent;" }
                           "")))
                          
       (full_block (div { `style: "z-index: 8; width: 100%; height: 100%; position: absolute; top:0px; left: 0px;" }))
       (dims nil)
       (resize_mode false)
       (elem_dims {
           `width: elem.offsetWidth
           `height: elem.offsetHeight
       })
       (initial_ratio (/ elem.offsetWidth elem.offsetHeight))
       (max_dims {
                  `width: 0
                  `height: 0
                  })
       (body_element nil)
       
       (block_on (fn (e)
                    (progn
                       (= dims (-> frame `getBoundingClientRect))
                       (= body_element (get_by_id "body"))
                       (= max_dims {
                                     `width: (prop body_element `offsetWidth)
                                     `height: (prop body_element `offsetHeight) })
                       (-> body_element `appendChild full_block)
                       (= move_state {
                                       mx: e.pageX
                                       my: e.pageY
                                       fx: dims.right
                                       fy: dims.top
                                       w: dims.width
                                       h: dims.height
                                       }))))
       
       (end_drag (fn (e)
                    (progn
                       (= move_state nil)
                       (= resize_mode false)
                       (if (is_function? elem.resize)
                           (-> elem `resize))
                       (-> full_block `remove))))       
       (handle_drag (fn (e)
                      (when (and move_state
                                 (== e.buttons 1))
                         (when resize_mode
                            (set_style [["height" (+ "" (Math.min (- max_dims.height 30) (+ dims.height (- e.pageY move_state.my))) "px")]]
                                       frame)
                            (set_style [["width" (+ "" (* initial_ratio frame.offsetHeight) "px") ]] frame)
                            (set_style [["height" (+ "" frame.offsetHeight "px")]
                                        ["width" (+ "" frame.offsetWidth "px") ]] elem)
                            ))))
                                   
       (frame (if just_enable
                  elem.parentElement
                  (div { `initializer: "wrap_in_resizable" `class: "juno-shadow-on-hover" `style: (+ "padding: 0px;position: relative; display: inline-block; border: 1px solid transparent; width:" elem_dims.width "px; height: " elem_dims.height "px;") }))))
      
     
      (attach_event_listener expander_elem
         `mousedown
         (fn (e)
            (progn
               (= resize_mode true)
               (block_on e))))
      
      
      (attach_event_listener full_block
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mousemove
                             handle_drag)
      (attach_event_listener full_block
                             `mousemove
                             handle_drag)
      
      ;; if we have a control, initialize it if it needs it since it is 
      ;; now mounted on the DOM
      (set_style [["position" "relative"]
                  ["display" "inline-block"]] frame)
      (unless just_enable
         (-> elem `replaceWith frame)
         (-> frame `append elem)
         (-> frame `append expander_elem))
      true)
   {
     `description: (+ "<br><br>Given an element, will wrap it in a resizable element that preserves "
                      "aspect ratio. The provided element will be replaced with the wrapped element.  "
                      "The element will have a transparent handle on the lower right side that when "
                      "hovered over, will indicate that the element can be resized.  ")

       `usage: ["element:Element"]
       `tags: ["DOM" "element" "UI" "resize" ]
   })

(defcontrol DOM_editor ()
   ((starter  (div { } "Start Typing!"))
    (root_elem (div { `contenteditable: true `tabindex: 0 }
                    starter))
    (document_view (div {  `class: "juno-editable" `style: "height: calc(100% - 0px); overflow: scroll; background: var(--editor-bg-color);  line-height: 1.5em; font-size: 1.1em;  padding: 5px; margin-top: 0px;margin-bottom: 0px"} 
                        root_elem))
        
    (position_elem (div { `style: "padding: 5px;color: darkblue;" } ))
    (depth_elem (div { `style: "padding: 5px; color: green;" } ))
    (path_elem (div { `style: "padding: 5px; " } ))
    (key_history_elem (div { `style: "padding: 5px;" }))
    (text_around_elem (div { `style: "padding: 5px;" }))
    (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" }
                               (if options.read_only
                                  "RO"
                                  "")))
    (status_elem (div { `style: "max-height: 40px; overflow: auto; border-bottom: 1px solid var(--main-accent-line-hover); padding: 5px; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
                      position_elem
                      depth_elem
                      path_elem
                      text_around_elem
                      key_history_elem))
    (debug_offset_height "55px")
    (debug_elem (div { `style: (+ " padding: 5px; overflow:scroll; height: calc(100% - " debug_offset_height ");") } ))
    (debug_container_elem (div { `style: "height: calc(100% - 10px); overflow: hidden;" }
                               status_elem
                               debug_elem))
    (sview (if options.debug
               (split_view_horizontal document_view  debug_container_elem)
               { 
                 `view: document_view 
                 }))
    (content_view (div { `style: "background: var(--control-bg-color); overflow: hidden; width: 100%; height: 100%;" }
                       sview.view))
    (on_resize (fn (self)
                  (progc
                     (= debug_offset_height (+ 45 (Math.max 5 control_status.offsetHeight)))
                     
                     (set_style [["height" (+ "calc(100% - " debug_offset_height "px)")]] debug_elem)
                     (if (not options.debug) 
                         (set_style [["height" (+ "calc(100% - " control_status.offsetHeight "px)")]] document_view))
                     )))
                     
    (rules nil) 
    (rules_menu [])
    (collection_timer nil)
    (key_sequence_rules { keyup: {} keydown: {} })
    (prior_text_rules { keyup: {} keydown: {} })
    (post_text_rules { keyup: {}  keydown: {} })
    (load_rule (fn (name rule)
                  (let
                     ((lookup_rule (+ { name: (or name "Unnamed Rule") `remove_if_prior: (or rule.remove_if_prior false) }
                                      (if (is_function? rule.qualifier)
                                         { `qualifier: rule.qualifier }
                                         {})
                                      { `text_sequence: rule.prior_text_sequence }
                                      (if (is_function? rule.exec)
                                          { `exec: rule.exec }
                                          { `exec: (eval `(fn ()
                                                             (notify (+ "Rule " ,#name " has no exec rule")))) })
                                      (if rule.handle_event
                                         { `handle_event: true }
                                         {}))))
                     (when rule.prior_text_sequence
                        (make_path [ rule.on_event rule.prior_text_sequence ] prior_text_rules lookup_rule))
                     (when rule.key_sequence
                        (make_path [ rule.on_event rule.key_sequence ] key_sequence_rules lookup_rule))
                     (when rule.menu
                        (push rules_menu
                           [(from_key name)
                            (eval `(fn (e)
                                      (progn
                                         (defvar rule ,#rule)
                                         (when (prop *last_focus* `root_elem)
                                            (focus_to (-> *last_focus* `root_elem))
                                            (defvar current_point (-> *last_focus* `current_point))
                                            (log "current_point: " current_point)
                                            (when current_point
                                               (move_to_point current_point))
                                            (if (is_function? rule.qualifier)
                                                (if (rule.qualifier current_point *last_focus*)
                                                    (rule.exec current_point *last_focus* nil))
                                                (rule.exec current_point *last_focus* nil))))))])))))
                                   
    (load_rules (fn ()
                   (progn
                      (cond 
                         (is_array? options.rules)
                         (= rules (resolve_path options.rules Environment.context.scope))
                         (is_function? options.rules)
                         (= rules (-> options `rules self)))
                      (= rules_menu [])
                      (= key_sequence_rules { keyup: {} keydown: {} })
                      (= prior_text_rules { keyup: {} keydown: {} })
                      (= post_text_rules { keyup: {} keydown: {} })
                      (when rules
                         (for_each (pset (pairs rules))
                            (destructuring_bind (name rule)
                               pset
                               (load_rule name rule)))))))
    (active_rules (fn ()
                     prior_text_rules))
    (current_point nil)
    (last_event_context nil)
    (render (fn ()
               content_view))
    (set_filename (fn (fname)
                     (if (is_string? fname)
                         (progn
                            (set_prop options
                               `filename
                               fname)
                            (set_prop options
                               `path
                               (conj [ `filesystem ] (split_by "/" fname)))
                            (set_prop title_span
                               `innerText
                               (get_editor_file_basename self)))
                         (notify "Require a string for the filename"))))
    (save_as (fn ()
                (let
                   ((fname (wait_for_file_selection true)))
                   (when (not (blank? fname))
                      (set_filename fname)
                      (request_save)))))
    (on_focus (fn (self)
                (progc
                   (focus_to root_elem)
                   (when current_point
                      (move_to_point current_point)))))
    
               
    (process_rules_for_event (fn (event)
                                (let
                                   ((text (get_text_around_point current_point))
                                    (on_event event.type)
                                    (prior_text_sequence (or text.0 ""))
                                    (next_text_sequence text.1)
                                    (key_sequence (clone (key_history))))
                                   
                                   ;; spaces show up as character code 160, so we need to move it to space to make
                                   ;; any matches succeed that are terminated by a space
                                   ;; note that this could probably be changed in the get_text_around_point function
                                   ;; but that needs to be thought through...
                                   
                                   (when (and (is_string? text.0)
                                              (== (-> (last_n_chars 1 text.0) `charCodeAt) 160))
                                       (set_prop text 
                                          0
                                          (+ (chop text.0) " ")))
                                   
                                   ;; next find the rule to eval if any...
                                   ;; from the most specific to the least
                                   (for_each (n [ 3 2 1 ])
                                      (progn 
                                         (aif (resolve_path [ on_event (join " " (last_n n key_sequence)) ] key_sequence_rules)
                                              (when (qualify_and_run it `key_sequence event)
                                                 (break)))))
                                   (for_each (n [ 4 3 2 1 ])
                                      (progc
                                         (when (>= (length text.0) n) 
                                            (aif (resolve_path [ on_event (last_n_chars n text.0) ] prior_text_rules)
                                                (when (qualify_and_run it `prior_text event)
                                                   (break)))))))))
     ;; when a rule is identified by process_rules_for_event as matching
     ;; the qualify_and_run function will make check to see if it is qualified
     ;; to run and then run the rule 
    (qualify_and_run (fn (rule identified_by event)
                        (progc
                           (defvar qualified? 
                              (if (is_function? rule.qualifier)
                                  (-> rule `qualifier current_point self) ;; only run it if qualifier returns true
                                  true)) ;; otherwise default run it since no qualifier
                           (if qualified?
                              (progn
                                 (when rule.handle_event
                                    (handle_event event))
                                 (when (and rule.remove_if_prior
                                            (== identified_by "prior_text"))
                                    
                                    ;; remove the text that qualified it
                                    ;; however we can delete the complete element if we are at the same position (offset) 
                                    ;; in the current element being edited as the length of the text sequence to remove.
                                    (if (> current_point.position (length rule.text_sequence))
                                        (progn   ;; just extend the selection backward and remove the text..
                                           (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (= current_point (point_for root_elem)))
                                        (progn ;; in this case we will remove the whole node that contains the trigger text
                                               ;; so we need to move backward to the prior node so the rule works consistently.
                                            (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (move_point `backward `character)
                                           (= current_point (point_for root_elem)))))
                                 (when (== identified_by `key_sequence)
                                    (= key_history_acc []))
                                 ;; then call the rule!
                                 (-> rule `exec current_point self)
                                 true)
                              false))))
    (key_history_acc [])
    (key_history_length 4)
    (key_history (function ()
                    key_history_acc))
    (is_dirty? false)
    (add_to_key_history (function (key)
                           (progn
                              (unless (contains? key (list "Shift" "Alt" "Ctrl" "Command")) ;; don't grab just the special key downs
                                 (push key_history_acc key)
                                 (while (> key_history_acc.length key_history_length)
                                    (take key_history_acc))))))
    (key_down_event (fn (event)
                       (progc
                          (let
                             ((status (point_for root_elem))
                              (key event.key))
                             (when (or (and (== key.length 1)
                                            (not event.metaKey))
                                       (or (== key "Backspace")
                                           (== key "Enter")))
                                (when (not is_dirty?)
                                    (add_class "juno-needs-save" title_span))
                                (= is_dirty? true))
                             
                             (cond
                               (and options.close_on_escape 
                                  (== key "Escape"))
                               (progn
                                  (log "DOM Editor:Escape pressed!")
                                  (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                               else
                               (progn
                                  (add_to_key_history (get_key_code event))
                                  (= last_event_context (process_rules_for_event event))
                                  key))))))
    
    (key_up_event (fn (event)
                      (progc
                         (let
                            ((status (point_for root_elem))
                             (key event.key)
                             (path_comps (for_each (c status.dom_path)
                                            (progn
                                               (if (== 1 c.nodeType)
                                                   c.tagName
                                                   "text")))))
                            (= current_point status)
                            (= last_event_context (process_rules_for_event event))
                            
                            
                            
                            (set_prop position_elem
                               `innerText
                               status.position)
                            (set_prop depth_elem
                               `innerText (length status.dom_path))
                            ;(-> path_elem `replaceChildren
                            ;  (div { } (join ":" (key_history))))
                            (set_prop key_history_elem
                               `innerText
                               (join ":" (key_history)))
                            (set_prop text_around_elem
                               `innerText
                               (join ":" (get_text_around_point status)))
                            (-> path_elem `replaceChildren
                               (div { } (for_each (name path_comps)
                                       (span {`style: "padding-right: 5px" } name))))
                            
                            (set_prop view
                               `scrollTop 0)      
                            (when collection_timer
                               (clearTimeout collection_timer))
                            (= collection_timer
                               (setTimeout
                                  (fn ()
                                     (progn
                                        (when (and (not options.path)
                                                   (not options.filename))
                                           (= is_dirty? false)
                                           (remove_class "juno-needs-save" title_span)
                                           (set_prop options
                                              `content
                                              (element_to_lisp root_elem { use_ns: `html } )))))
                                  1000))
                               
                            (-> debug_elem `replaceChildren
                               (pre (pretty_print (element_to_lisp root_elem))))
                            ))))
    (control_bar_elements [ locked_span ])
    (request_save (function ()
                        (progn
                           (if (or options.path options.filename)
                              (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] })
                              (-> self `on_save_complete)))))
    (nseval (if (not (blank? options.path_namespace))   
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))
    (menu_items (fn ()
                   (conj rules_menu
                      [["Copy contents as Lisp Structure" (fn (e) (copy_text_to_clipboard (pretty_print (as_lisp (-> self `get)))))]
                       (if options.filename
                          [(+ "Save " (get_editor_file_basename self)) (fn (e) (request_save))]
                          [])
                       ["Save as..." (fn (e) (save_as)) ]
                       (if options.read_only
                                [ (dtext "Allow Editing" ) (fn () (-> self `set_read_only false)) ]
                                [ (dtext "Set Read-Only Mode") (fn () (-> self `set_read_only true)) ])])))
    (set_name (fn (new_name force)
                 (progn
                    (when (and (not (blank? new_name))
                               (not (== (get_control_by_name new_name) self)))
                       (set_prop options
                          `name
                          (if force
                             new_name
                             (compute_name_for_control new_name)))
                       (set_prop self
                          `name
                          options.name)
                       (dispatch_event { command: "editor_change"
                                         source: self.id
                                         args: [ { `option: "name" `value: options.name } ] }))
                    (set_prop title_span
                       `innerText
                       options.name)
                    options.name)))
    (check_for_unhandled_elements (fn (elem)
                                     (let
                                        ((elem_type nil))
                                        (cond
                                           (is_element? elem)
                                           (progn
                                              (= elem_type elem.tagName)
                                              (cond
                                                 (and (== elem_type "IMG")
                                                      (not (get_attribute elem "_handled")))
                                                 (progn
                                                    (set_attribute elem "_handled" "true")
                                                    (wrap_in_resizable elem))
                                                 else
                                                 (when (> elem.children.length 0)
                                                    (for_each (c elem.children)
                                                       (check_for_unhandled_elements c)))))))))
    (saved_content nil)
    (set_read_only (fn (read_only?)
                              (progn
                                 (set_prop options
                                    `read_only
                                    read_only?)
                                 (if read_only?
                                    (progc
                                       (= saved_content (element_to_lisp root_elem))
                                       (log (pretty_print saved_content))
                                       (remove_attribute root_elem `contenteditable)
                                       (set_prop locked_span
                                          `innerText
                                          (dtext "RO")))
                                    (progc
                                       (when saved_content
                                          (log (pretty_print saved_content))
                                          (set_prop saved_content.1
                                             `contenteditable true)
                                          (-> root_elem `replaceWith (eval saved_content))
                                          (= root_elem document_view.children.0)
                                          (check_for_unhandled_elements root_elem)
                                          (focus_to root_elem)
                                          ;(set_attribute root_elem `contenteditable true)
                                          (set_prop locked_span
                                             `innerText
                                             (dtext ""))))))))
    (error_state false)      
    (on_destroy (fn ()
                                                   (progn
                                   (cond
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" } 
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         response)
                                      else
                                      true))))
    (on_initialize (fn ()
                      (progc
                         (let
                            ((remote_content nil)
                             (is_fresh false)
                             (load_error false)
                             (extension nil))
                            (cond
                               options.filename
                               (progn
                                  (try
                                     (progn
                                        (= remote_content (fetch (+ "/files/" options.filename)))
                                        (cond
                                           (== remote_content.status 200)
                                           (progn
                                              (= remote_content (-> remote_content `text))
                                              (when options.on_load
                                                 (try
                                                    (= remote_content (-> options `on_load remote_content self))
                                                    (catch Error (e)
                                                       (progn
                                                          (alert_box "Invalid Content"
                                                                     (+ "Cannot mount content: " e.message))
                                                          (= load_error true))))))
                                           (== remote_content.status 404)
                                           (progn
                                              (= remote_content "")
                                              (notify (+ "New file: " options.filename))
                                              (= is_fresh true)
                                              (when options.on_load
                                                 (try
                                                    (= remote_content (-> options `on_load nil self))
                                                    (catch Error (e)
                                                       (progn
                                                          (alert_box "Invalid Content"
                                                                     (+ "Cannot mount content: " e.message))
                                                          (= load_error true))))))
                                           remote_content
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": " remote_content.statusText))
                                           else
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": received nil response from the fetch operation.")))
                                        (set_filename options.filename)
                                        ;(log "remote_content: " remote_content)
                                        (when (and remote_content (not is_fresh))
                                           (= remote_content (eval (JSON.parse remote_content)))
                                           (-> root_elem `replaceWith remote_content)
                                           (= root_elem document_view.children.0)))
                                     (catch Error (e)
                                        (progn
                                           (log "DOM_editor: cannot set remote content: " remote_content)
                                           (alert_box (+ "Unable to open: " options.filename " - " e.message))
                                           (= error_state true)))))
                               (is_array? options.path)
                               (progn
                                  (defvar content (resolve_path options.path nseval.global_ctx.scope))
                                  (if (eq nil content)
                                      (progn
                                         (= content (or options.content
                                                        starter))
                                         (= is_fresh true)
                                         (make_path options.path nseval.global_ctx.scope root_elem))
                                      (progn
                                         (when (not (is_element? content))
                                            (= content (eval content)))
                                         (-> root_elem `replaceWith content)
                                         (= root_elem document_view.children.0))))
                               options.content
                               (progn
                                  (defvar tmp (if (is_element? options.content)
                                                  options.content
                                                  (eval options.content)))
                                  (when (is_element? tmp)
                                     (-> root_elem `replaceWith tmp)
                                     (= root_elem document_view.children.0))))
                            
                            (set_name (cond
                                         (and (is_string? options.name)
                                              (not (== "DOM Editor" options.name))) ;;
                                         options.name
                                         (is_array? options.path)
                                         (last options.path)
                                         else
                                         "Untitled"))
                                          
                            (try
                               (load_rules)
                               (catch Error (e)
                                  (log "Error on load_rules: " e.message)))
                            ;(log "loaded rules: key_sequence_rules: " key_sequence_rules)
                            ;(log "loaded rules: prior_text_rules: " prior_text_rules)
                            
                            
                            (attach_event_listener content_view
                               `keyup
                               (fn (e) (key_up_event e)))
                            
                            (attach_event_listener content_view
                               `keydown
                               (fn (e)
                                  (key_down_event e)))
                            (if options.read_only
                                (set_read_only true))
                            
                            (attach_event_listener content_view
                               `paste
                               (fn (e)
                                  (progc
                                     (log "new paste event: " 
                                        (object_methods e.clipboardData)
                                        e.clipboardData.types)
                                     (setTimeout (fn ()
                                                    (check_for_unhandled_elements root_elem))
                                                 50))))
                                  
                            
                            (progc
                               (set_attribute root_elem
                                  `tabindex 0))
                            ;(set_style [["height" "100%"]] root_elem)
                            (set_style [["overflow" "hidden"] [ "height" "calc(100% - 2px);"]] view)
                            (if options.hide_control_bar
                               (-> self `show_control_bar false))
                            
                            (check_for_unhandled_elements root_elem)
                            
                            (setTimeout (fn ()
                                           (progn
                                              (cond
                                                 error_state  ;; unable to initialize - so remove ourselves
                                                 (destroy_control self)
                                                 (and (or options.content
                                                          options.filename)
                                                      (not is_fresh))
                                                 (progn
                                                    (select_element root_elem)
                                                    (collapse_to_start (get_selection)))
                                                 else
                                                 (progn
                                                    (select_element starter)))))
                                        100))))))
   {
       control_bar: true
       expose: [[`active_rules active_rules]
                [`reload_rules load_rules]
                [`save request_save]
                [`current_point (fn ()
                                   current_point) ]
                [`editor {} ]  ;; just to indicate we are an editor type component
                [`get (fn ()
                         (element_to_lisp root_elem)) ]
                [`root_elem (fn ()
                               root_elem) ]
                [`set_read_only  set_read_only]
                [`needs_save? (function ()
                                 is_dirty?)]
                [`on_save_complete (function (event_obj)
                                      (progn
                                         (remove_class "juno-needs-save" title_span)
                                         (= is_dirty? false)))]
                [`get_root_element (fn () root_elem)]]
   })

(defun wait_for_editor (content)
   (if (get_control_by_name "Description Editor")
       (alert_box (dtext "Open Editor")
                  (dtext "There can be only one description editor open at a time."))
       (new Promise
          (fn (resolve reject)
             (let
                ((result nil)
                 (name "Description Editor")
                 (deditor (DOM_editor { rules: [ `*markdown_rules* ] `content: content `name: name })))
                (defglobal $ed_rval nil)
                (place_control `right deditor)
                (while (and (get_control_by_id deditor.options.id)
                            (is_nil? $ed_rval))
                   (progn
                      (sleep 1)))
                (if (get_control_by_id deditor.options.id)
                    (destroy_control deditor))
                (resolve `(+ ,@$ed_rval)))))))


(defun edit_description_text (control)
   (let
      ((ctl (or (and control
                     (== control.type "text_editor"))
                (if (== (prop *last_focus* `type) "text_editor")
                    *last_focus*
                    nil))))
      (if ctl
         (let
            ((pos (-> ctl `get_selection))
             (select_pos nil)
             (parent_pos nil)
             (editor ctl.editor)
             (new_text nil)
             (content nil)
             (thing_we_are_in nil)
             (ok_to_proceed true)
             (error_content (div
                              (dtext "To use the Description Text Editor, the description field must be in one of the following forms:")
                              (br)
                              (code "description: nil")
                              (br)
                              (code "description: (+ \"content\")")))
             (text nil))
            
            (select_to_current_form editor)
            (= select_pos (-> ctl `get_selection))
            (= text (-> ctl `get_selected_text))
            
            (= thing_we_are_in (read_lisp text { suppress_throw_on_error: true } ))
            (cond
               (is_array? thing_we_are_in)
               (progn
                  (= parent_pos (find_last_paren editor select_pos.start))
                  (-> editor.selection `clearSelection)
                  (-> editor.selection `setSelectionAnchor parent_pos.start.row parent_pos.start.column)
                  (-> editor.selection `selectTo parent_pos.end.row (+ parent_pos.end.column 0))
                  (= thing_we_are_in (read_lisp (-> ctl `get_selected_text) { suppress_throw_on_error: true } ))
                  
                  (if (and (prop thing_we_are_in `description)
                           (>= select_pos.start.row parent_pos.start.row)
                           (<= select_pos.end.row parent_pos.end.row)
                           (== (eval (prop thing_we_are_in `description)) (eval (read_lisp text)))
                           )
                      (progn
                          (-> editor.selection `clearSelection)
                          (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                          (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column)))
                      (progn
                         (= ok_to_proceed false)
                         (alert_box (dtext "Edit Description Text")
                                    error_content))))
               (and (is_object? thing_we_are_in)
                    (contains? "description:" (trim (-> editor.session `getLine pos.start.row)))
                    (contains? "description" (keys thing_we_are_in))
                    (== thing_we_are_in.description (quote "=:nil")))
               (progn
                  (-> editor `clearSelection)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  (= select_pos (-> editor.session `getAWordRange pos.start.row pos.end.column))
                  (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                  (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column 0))
                  
                  (= text "")
                  (= select_pos pos))
               else
               (progn
                  (= ok_to_proceed false)
                  (alert_box (dtext "Edit Description Text")
                             error_content)))
            (when ok_to_proceed
               (progc
                  (= content  (unpack_description (or (eval (read_lisp (or text ""))) "Empty") { `edit_mode: true })))
               (-> ctl `set_read_only true)
               (= pos (-> ctl `get_selection))
               (= new_text (wait_for_editor content))
               (-> ctl `set_read_only false)
               ;(log "edit_description_text: new_text: " new_text)
               (when (and new_text
                          (second new_text))
                  (= new_text (pretty_print new_text))
                  
                  (-> (-> editor `getSession) `replace pos new_text)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  ;; slow it down so we can watch the fitment..
                  (sleep 0.3)
                  (select_to_current_form ctl.editor)
                  (sleep 0.2)
                  (indent_editor_selection  ctl.editor)
                  (sleep 0.1))))
         (alert_box (dtext "Edit Description Text")
                    (dtext "The control being used must be a text editor type."))))
   { 
     `description: (+ "This function provides an ability to edit the description text of a function "
                      "for easier documentation.  When invoked, if not provided with a specific "
                      "text_editor control, will use the *last_focus* control if it is a text editor "
                      "type.   The current cursor position of the editor it is being invoked on will "
                      "be examined, and if it meets certain criteria, the description text will be "
                      "gathered and the description editor pane will pop up providing the user the "
                      "ability to edit the text in a fashion more amenable for writing "
                      "documentation.  <br>Once completed with the description edits, the user can "
                      "press the short cut key for get_as_wordwrap_text (default is bound to Alt-X) or "
                      "select the \"Get As Wordwrap Text\" menu item from the control menu.  This will "
                      "close the editor and place the contents of the description editor into the "
                      "source code in the appropriate position and form. <br>If the contents of the "
                      "description editor are not to be saved back to the text editor, just close the "
                      "editor, either from the menu or by pressing <br>Alt-D<br> (or the command "
                      "currently associated with the Close Control Command).  See (show_key_bindings) "
                      "in the REPL for a table of current globally defined key bindings. <br>#### "
                      "Qualifying formats of the Description Field to be Edited<br>The description "
                      "field must either have a value of nil (empty).  In this case, the description "
                      "editor will be empty of content when opened.  In this case the field entry "
                      "would look like:<br>```{\n   description: nil \n}```<br><br>If the description "
                      "field is already populated with content, it will need to be in the form "
                      "of: <br>```{\n   description: (+ \"Content Line\" \"more content\" "
                      "\"...\")\n}```<br><br>This is the format that the Description editor will place "
                      "into the source code when complete.<br>#### Other Notes<br>When the Description "
                      "Editor is invoked and while the user is editing text, the text_buffer that it "
                      "is being invoked on is placed into read only mode and so cannot be modified "
                      "until the Description Editor is closed. ")

      `usage: ["control:?object"]
      `tags: ["editor" "description" "metadata" "meta" ] })


(defun handle_app_click_event (e)
  (let
      ((elem e.srcElement)
       (elem_type e.srcElement.tagName)       
       (control_id (get_attribute elem "control_id"))
       (control (if control_id
                  (get_control_by_id control_id)))
       (parents (each (parents_for_control control) `name)))
    (cond
      (and (has_class? "juno-command-button" elem)
           (== elem_type "BUTTON")           
           control)
      ;; a command button was clicked show the menu for the control
      (let
          ((control_menu (conj (if (is_function? control.menu_items)
                                 (-> control `menu_items)
                                 [[]])
                               [[(dtext "Swap") (reduce (other_control (current_controls true))
                                                         (unless (or (== other_control control)
                                                                     (eq nil other_control.name)
                                                                     (contains? other_control.name parents))
                                                                 [other_control.name (fn () (swap_control control other_control)) ]))]
                                [(dtext "Hide") (fn ()
                                                  (hide_control control))]
                                ["--" nil]
                                [(dtext "Close Control")
                                 (fn ()
                                    (destroy_control control))]])))
        (make_menu elem control_menu)))))

      
                                                
(defun app_menu (global_menu_path options)
  (let
      ((view nil)
       (options (either options {}))
       (top_levels [])
       (menu_trees (resolve_path global_menu_path Environment.global_ctx.scope))
       (sticky_items (each menu_trees `0))
       (id (or options.id (generate_id "app_menu")))
       (intf {})
       (menu_trees (or menu_trees []))
       (compute_top_levels (fn ()
                             (progn
                                (defvar headers (each menu_trees `0))
                                (defvar last_focus_name (resolve_path  [ `options `name ] *last_focus*))
                                (= headers (uniq
                                                 (reduce (header_text headers)
                                                    (if (or (contains? header_text sticky_items)
                                                            (and *last_focus* 
                                                               (== last_focus_name  header_text)))
                                                        header_text))))
                                ;(log "compute_top_levels: " (clone headers))
                                ; (if (== nil (get_control_by_name (last headers)))
                                    ;(pop headers))
                                headers)))
       (help_idx nil)
       (add_menu (fn (menu)
                   (let
                       ((existing_idx (index_of menu.0 top_levels)))
                     (if (== existing_idx -1)
                       (push menu_trees
                             menu)
                       (-> menu_trees `splice existing_idx 1 menu))
                     (set_path global_menu_path Environment.context.scope menu_trees)
                     (build_view))))
       (remove_menu (fn (menu_text)
                      (let
                          ((existing_idx (index_of menu_text top_levels)))                           
                        (when (and (> existing_idx -1)
                                   (prop view.children existing_idx))
                          (-> (prop view.children existing_idx)
                              `remove)
                          (-> menu_trees `splice existing_idx 1))
                        (set_path global_menu_path Environment.context.scope menu_trees))))
       (show_sub_menu (fn (e)
                         (let
                            ((idx (-> e.srcElement `getAttribute `idx))
                             (menu_header (if (== e.srcElement.tagName "SPAN")
                                              e.srcElement.parentElement
                                              e.srcElement))
                             (pos (-> menu_header `getBoundingClientRect))
                             (help_menu_function nil)
                             (on_select (fn ()
                                           (when menu_header
                                              (remove_class "juno-menu-selected" menu_header))))
                             (mview nil)
                             (menu nil))
                            (aif (get_by_id "cmenu")
                                 (-> it `remove))
                            (remove_class "juno-menu-selected" menu_header)
                            (when idx
                               (add_class "juno-menu-selected" menu_header)
                               (if (== (parseInt idx) help_idx)
                                   (= help_menu_function *help_menu_function*)
                                   (= help_menu_function nil))
                               (console.log "app_menu: clicked: " idx "help_idx: " help_idx (prop menu_trees (parseInt idx)))
                               (aif (or help_menu_function
                                        (resolve_path [ (parseInt idx) 1 ] menu_trees))
                                    (progn
                                       (cond
                                          help_menu_function
                                          (= menu (menu_tree (it) { `on_select: on_select } ))
                                          (is_function? it)
                                          ;; if the underlying menu is a function, call the function to get..
                                          ;; up to the minute menu contents
                                          (= menu (menu_tree (it (first (prop menu_trees (parseInt idx)))) { `on_select: on_select } ))
                                          ;; other wise it is a standard menu, which may not rehydrate well depending
                                          ;; on how it was created..
                                          else
                                          (= menu (menu_tree it { `on_select: on_select } )))
                                       (= mview (div { `id: `cmenu `class: "juno-menu" `style: " z-index: 30" }
                                                     menu.view))
                                       (set_style [["position" "absolute"]
                                                   ["left" (+ "" (Math.max 0 pos.left 0) "px")]
                                                   ["top" (+ "" (Math.max 0 pos.bottom ) "px") ]]
                                                  mview)
                                       (-> (get_by_id "body") `appendChild
                                           mview))
                                    (progn
                                       (remove_class "juno-menu-selected" menu_header)
                                       (notify "Unable to find menu resource")))))))
       (build_view (fn ()
                       (let
                           ((new_view nil)
                            (header_elem nil))
                         (= top_levels (compute_top_levels))
                         (unless options.disable_help
                                 (push top_levels
                                       "Help")
                                 (= help_idx (- (length top_levels) 1)))
                         
                         (= new_view
                            (ul { `id: id `class: "pure-menu-list" `style: "margin-left: 10px" }
                                (if (> top_levels.length 0)
                                  (map (fn (top_level idx)
                                         (li { `idx: idx  `class: "juno-menu-header juno-main-menu-header" }
                                             (span { `idx: idx `class: "juno-menu-item" } (dtext top_level))))
                                       top_levels)
                                  [])))
                         (map (fn (child)
                                 (progn
                                    (attach_event_listener child
                                       `mouseenter
                                       (fn (e)
                                          (progn
                                             (when (get_by_id "cmenu") ;; if the menu is already showing show the new menu, otherwise don't do anything
                                                (remove_class "juno-menu-selected" new_view.children)
                                                (show_sub_menu e)))))
                                    (attach_event_listener child
                                       `mouseleave
                                       (fn (e)
                                          true))))
                              new_view.children)
                         (attach_event_listener new_view
                                                `click
                                                show_sub_menu)
                                                                        
                         
                         (if view.parentElement
                           (-> view `replaceWith new_view))
                         (= view new_view)
                         view))))
    
    
    (build_view)
    (set_prop options
              `id
              id)
    (set_prop intf
              `view view
              `add_menu add_menu
              `remove_menu remove_menu
              `type "app_menu"
              `toJSON (function ()
                                `(app_menu ,#global_menu_path ,#options)))
    (setq *app_menu_control* intf)
    intf))

(defun app_header (controls options)
  (let
      ((existing_header (-> document `querySelector "header"))
       (intf nil))
    (when (eq existing_header nil)
      (-> (first (get_by_tag "body"))
          `prepend
          (= existing_header (header { `id: "page-header" class: "juno-page-header" }))))
    (when options.app_title
      (-> existing_header `appendChild (span { `class: "juno-header" } options.app_title)))
    (for_each (`elem controls)
              (progn
               (cond
                 elem.view
                 (-> existing_header `appendChild elem.view)
                 (is_element? elem)
                 (-> existing_header `appendChild elem)
                 else
                 (create_dom_element "span" elem))))
    ;(-> existing_header `appendChild (span { `style: "float: right; ")
    (set_prop options
              `id
              (or options.id "app-header"))
   
    (= intf
       {     
        `options: options
        `controls: controls
        `type: "app_header"
        `toJSON: (function ()
                           `(app_header ,#controls ,#options))
        })
    
    intf))


(defun build_starter_environment (opts)
  (if is_served?
    (let
       ((remote_connection nil)
        (remote_id nil)
        (kickstart_result nil)
        (opt (or opts {})))
       (log "Building Starter Environment..")
       (sleep 0.1)
       (try
          (= remote_connection (create_remote_evaluator))
          (catch Error (e)
             (progn
                (alert_box (dtext "Error")
                           (dtext "The system cannot establish a control connection to the host.")))))
       (if (eq nil remote_connection)
           (return nil))
       (unless (-> remote_connection `open?)
          (progn
             (alert_box (dtext "Error")
                        (dtext "Unable to establish a control connection: connection is closed."))
             (return nil)))
       
       ;; validate the environment..
       
       (= kickstart_result (-> remote_connection `evaluate (as_lisp `(sys/system "./scripts/build_browser_env.sh"))))
       (when kickstart_result.success
          (for_each (v (split_by "\n" kickstart_result.stdout))
             (log v))
          (log "Wrote the generator..starting build")
          (log "Removing temporary environment: " (-> remote_connection `evaluate "(undefine `*export_env*)"))
          (-> remote_connection `close)
          (log "building starter environment")
          (floating_div (iframe { width: 500 height: 300
                                  `style: "width: 90%; min-width: 500px; overflow: scroll; border: 0px solid transparent;"
                                  src: (+ "/env/starter.html?theme=" (resolve_path [ `application `global_theme ] *env_config*))} ))))))

(defun rebuild_remote_environment ()
  (if is_served?
    (let
       ((remote_connection nil)
        (remote_id nil)
        (results (pre { }))
        (kickstart_result nil))
       (log "Building remote environment..This may take a few moments.")
       (notify "Logging build messages to the System REPL")
       (sleep 0.1)
       (try
          (= remote_connection (create_remote_evaluator))
          (catch Error (e)
             (progn
                (alert_box (dtext "Error")
                           (dtext "The system cannot establish a control connection to the host.")))))
       (if (eq nil remote_connection)
           (return nil))
       (unless (-> remote_connection `open?)
          (progn
             (alert_box (dtext "Error")
                        (dtext "Unable to establish a control connection: connection is closed."))
             (return nil)))
       
       ;; validate the environment..
       
       (= kickstart_result (-> remote_connection `evaluate (as_lisp `(sys/system "./scripts/rebuild_env.sh"))))
       (notify "Remote build completed - check System REPL output")
       (when kickstart_result.success
          (for_each (v (split_by "\n" kickstart_result.stdout))
             (progn (-> results `append v)
                (-> results `append (br))))
          (log results)
          true))))
    


(defun controls_by_parent ()
    (let
        ((acc [])
         (current { `root: [] })
         (found_control {})
         (control_identity (fn (control)
                                 (and control
                                      (or control.name
                                          control.options.id
                                          "Untitled"))))
         (collect_control (fn (control parent)
                              (when (and control.options.id 
                                         (not (prop found_control control.options.id)))
                                 (when (and parent
                                            (not control.name))
                                     (cond
                                         parent.name
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.name "-" control.type))
                                         parent.type
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.type "-" control.type))))
                                 (cond
                                     (and parent
                                          (not (prop current (control_identity parent))))
                                     (set_prop current 
                                               (control_identity parent)
                                               [ control ])
                                     (and parent
                                          (prop current (control_identity parent)))
                                     (push (prop current (control_identity parent))
                                               control)
                                     (eq nil parent)
                                     (push (prop current `root)
                                               control))
                                 (set_prop found_control
                                           control.options.id
                                           control)))))
        (for_each (controls (or $root_controls []))
           (control_tree controls collect_control))
        current))

(defun all_global_controls (namespace)
   (let
      ((env_handle (if namespace 
                       (-> Environment `get_namespace_handle namespace)
                       nil)))
      (if namespace
          (reduce (pset (pairs env_handle.context.scope))
             (destructuring_bind (symbol_name symbol_value)
                pset
                (if (is_control? symbol_value)
                    symbol_name)))
          (flatten (for_each (namespace (namespaces))
                      (for_each (ctl (all_global_controls namespace))
                         (+ namespace "/" ctl))))))
   {
     `description: (+ "Returns all controls in the global context.  If provided " 
                      "with a namespace, it will return only the controls for "
                      "that namespace, otherwise it will return all controls "
                      "in every namespace in a fully qualified form.")
     `usage: ["namespace:?string"]
     `tags: [`controls `ui `global]
     })



(defun serialize_controls (controls)
  [(quote quote) (JSON.parse (JSON.stringify controls))]
  {
    `description: (+ "<br><br>Given an array of controls, serializes their state to JSON form such "
                     "that their state can be stored.<br>As an example, given the current "
                     "`$root_controls` array, will produce a JSON form:```(serialize_controls "
                     "$root_controls)```<br><br>The returned structure can then be rehydrated using "
                     "the `rehydrate_controls` function.<br><br> ")
    `usage: ["controls:array"]
    `tags: ["controls" "storage" "serialize" "serialization" "dehydration" "save" "state" "application"]
  })



(defun save_control_image (validate_name? options)
  (let
     ((save_as_name *env_config*.export.save_prefix)
      (options (if (is_object? options)
                   options
                   {})))
     (when validate_name?
        (aif (request_user_input (+ (dtext "Enter a name for the saved image.")
                                    " "
                                    (dtext "The file will be saved with this prefix and an .html extension."))
                                 `text
                                 { `default_value: save_as_name })
                (= save_as_name it)))
     
     (when (blank? save_as_name)
        (notify (dtext "Cancelled Save Operation"))
        (return 0))
     
     (log (dtext "Saving Application State to: ") save_as_name)
     (try
        (progn
           (set_focus_to nil)
           (defvar system_repl *system_repl*)
           (defvar results nil)
           (= *system_repl* nil)
           
           (= *serialized_controls* (serialize_controls $root_controls))
           ;[(quote quote) [(quote quote) (JSON.parse (JSON.stringify $root_controls))]])
           (console.log "*serialized_controls*: " *serialized_controls*)
           (= results (save_image (+ { `save_as: save_as_name } options)))
           (= *system_repl* system_repl)
           (log (dtext "Save Application State Results: ") results)
           (log (dtext "Complete"))
           (when (and is_served? validate_name?)
              (-> window `open (+ "/env/" save_as_name ".html") save_as_name))
           results)
        (catch Error (e)
           (progn
              (if validate_name?
                 (alert_box "Save Image Problem" e.message))
              (console.error "Cannot save image: " e)
              (log_error "ERROR on save: " e.message))))))
                 

(defun rehydrate_controls (container serialized_controls)
  (let
      ((control nil))
    (for_each (`serialized_control serialized_controls)
      (progn
       (= control (eval serialized_control))
       (when (and control.view
                  (not control.view.parentElement))
         (-> container
             `append control.view))
       (push $root_controls
             control)
       (when control.initialize
         (-> control `initialize)))))
  {
    description: (+ "<br>Given a DOM element and a JSON structure of serialized controls as produced "
                    "through the `serialize_controls` function, this function will instantiate them "
                    "from their saved state into the DOM structure. ")
    usage: ["conainer:Element" "serialize_controls:array"]
    tags:  ["controls" "storage" "serialize" "serialization" "rehydration" "restore" "state" "application"]
  })



(defun_sync to_indent (str)
    (join "" (for_each (c (range str.length))
                       " ")))

           
(defun_sync juno_format_handler (line tab base_indent)
   "")  ;; we let the control take care of this since it has better visibility to prior lines




(defun new_buffer (options)
  (let
      ((options (cond
                   (is_array? options)
                   { `path: options `mode: "juno"}
                   (is_object? options)
                   (+ (if options.filename
                          {}
                          { `mode: `juno })
                      options)  ;; if options has mode specified and we don't have a filename, it will override the default juno mode
                   (is_string? options)
                   { `path: [ options ] `mode: "juno" }
                   else
                   { `mode: "juno" }))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (new_control nil)
       (symbol_data (if options.path
                        { `path: options.path `namespace: (or options.namespace (current_namespace)) }
                        (symbol_chooser "Select a symbol to edit" options.mode)))
       (extension (cond 
                     options.filename
                     (last (split_by "." options.filename))
                     (== options.mode "dom")
                     "dom"
                     else
                     "juno"))
       (target_ns symbol_data.namespace)
       (target_env nil))
      (log "new_buffer: for: " options target_ns extension symbol_data)
      
    (when target_ns
      (= target_env (-> Environment `get_namespace_handle symbol_data.namespace)))
    (when (and target_env (not (resolve_path symbol_data.path target_env.global_ctx.scope)))
       (console.log "new_buffer: target symbol doesn't exist: creating it")
       (set_path symbol_data.path target_env.global_ctx.scope ""))
    
    (when symbol_data.path
       (= new_control
          (if (== extension `dom)
              (DOM_editor (+ { rules: [ `*markdown_rules* ] `hide_control_bar: false debug: false } options))
              (text_editor (+ { name: (last symbol_data.path) namespace: target_ns path: symbol_data.path mode: options.mode } options ))))
      (cond
         (is_top_control? target_container)
         (container_view_operation "split_right" 
                                   (first (-> target_container `controls))
                                   new_control)
         else
         (swap_control target_container 
                       new_control))
      (sleep 0.1)
      (set_focus_to new_control)))
  {
      `description: (+ "Opens a new editor, if possible, in the currently focused control.  If necessary, it may "
                       "split the view to the right for the new editor.  If no options are provided, the user "
                       "will be prompted for a symbol to edit.  Options can be: <br>"
                       "string: is considered a symbol name and the function will open or create the " 
                       "specified symbol in the current namespace global context.<br>"
                       "array: is considered a path to access, and if the path is present will open the path.  If not, "
                       "will attempt to create the final value in the path as a string for editing.<br>"
                       "object: if an object, the object can contain:<br>"
                       "  path: array: the path to the symbol to be edited.  If the final path segment doesn't exist "
                       "it will create it.<br>"
                       "  namespace: string: the namespace to use for accessing the provided path.<br>"
                       "  mode: the mode to open the editor in. The default mode is Juno.<br>")
      `tags: ["editor" "edit" "buffer" "control"]
      `usage: ["options:object?"]
  })

(defun new_top_level_frame ()
   (let
      ((ctl (empty_selection_control))
       (new_frame (control_container ctl { `root_frame: true } )))
      (push $root_controls
         new_frame)
      (if (> (length (-> (control_holding_tank) `controls)) 0)
          (swap_control ctl (last (-> (control_holding_tank) `controls))))))

(defun new_juno_repl (options)
   (let
      ((name (compute_name_for_control "Juno REPL"))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (remote_repl (if (is_string? options.remote_repl)
                        options.remote_repl)))
      (alert_on_error "REPL Error"
                      (cond
                         (is_top_control? target_container)
                         (container_view_operation "split_right" (first (-> target_container `controls)) (visual_repl { `name: name `remote_repl: remote_repl }))
                         else
                         (swap_control target_container (visual_repl { `name: name `remote_repl: remote_repl })))))
   {
       usage: ["options:?object"]
       description: (+ "Creates a new REPL in the current frame.  If provided with a `control_to_replace "
                       "in options, it will replace that control with the new REPL, with the replaced control "
                       "being put in the holding tank if the replaced control is allowed."
                       "If no target is provided, the function will split the top frame, replacing the " 
                       "currently focused control.")
       tags: [ "REPL" "create" "new" "control"]
   })
 
(defun rename_control (old_name new_name)
   (cond 
      (is_string? old_name)
      (aif (get_control_by_name old_name)
            (if (is_function? it.rename)
                (-> it `rename new_name)
                (throw EvalError (+ "Control " old_name " doesn't have a rename method"))))
      (is_control? old_name)
      (if (-> old_name `rename)
          (-> old_name `rename new_name)
          (throw EvalError (+ "Control " old_name.options.name " doesn't have a rename method"))))
   {
       `description: (+ "Given a control or a name of a control, and a new name, " 
                        "renames the given control to the new name.  If the control "
                        "cannot be renamed, will throw an EvalError indicating that "
                        "it couldn't be renamed.")
       `usage: ["old:string|object" "new_name:string"]
       `tags: [`controls `name `rename `control `id ]
   })  

(defun wait_for_file_selection (create_mode) 
   (new Promise (fn (resolve reject)
                   (let
                       ((selection nil)
                        (target_control (or *last_focus* (default_focus)))
                        (control (file_tree_browser { 
                                                      create_mode: create_mode                          
                                                      on_select: (fn (stack)
                                                                    (progn
                                                                     (= selection (join "/" stack))
                                                                     (if (> stack.length 0)
                                                                       (progn
                                                                        (destroy_control control)))))
                                                                        
                                                     on_destroy: (fn (self)
                                                                    (progn
                                                                     (setTimeout (fn ()
                                                                                    (progn
                                                                                       (set_focus_to target_control)
                                                                                       (resolve selection))
                                                                                    20))
                                                                     true)) })))

                     (place_control `below control)
                     (set_focus_to control))))
   {
       `description: (+ "Opens a file tree browser for selection of a file.  Once the a " 
                        "file is chosen, or the selection is cancelled via escape, then either "
                        "the selected path is returned, or nil if cancelled or closed.<br>If "
                        "the create_mode flag is true, the behavior is modified in the "
                        "selection control where path completions aren't automatically "
                        "used, instead the user must press tab to complete the selection. "
                        "This allows for the user to select a file that may not be "
                        "present on the filesystem for purposes of creation.  By default the "
                        "create_mode flag is set to false.")
       `usage:["create_mode:?boolean"]
       `tags: ["UI" "DOM" "file" "editor" "select" "open"]
   })


(defun file_status (file_path)
   (if (is_string? file_path)
       (let
          ((comps (split_by "/" file_path))
           (fname (pop comps))
           (parent_path (progn
                           (defvar tmp (join "/" comps))
                           (if (blank? tmp)
                               "/"
                               tmp)))
           (results (http/list_files parent_path)))
         (or (first (reduce (r results)
                       (if (== r.name fname)
                           r)))
             nil))
       (throw TypeError "file_status: requires a file_path argument as a string"))
   {
     `description: "Given a path to a file, if the file exists, returns the details, otherwise nil."
     usage: ["file_path:string"]
     tags: ["io" "file" "status" "exist"]
     })
          

(defun edit_file (options)
   (let
      ((options (cond 
                   (and (is_object? options)
                        options.filename)
                   options
                   (and (is_object? options)
                        options.create_mode)
                   (+ {} 
                      options
                      { filename: (wait_for_file_selection true) })
                   else
                    (progn
                       {
                           filename: (wait_for_file_selection)
                       })))
       (symbol_path (cond
                       (is_array? options.path)
                       options.path
                       (is_string? options.filename)
                       (conj ["filesystem"] (split_by "/" options.filename))))
       (rval nil)
       (data_to_save (or options.initial_data ""))
       (acc []))
      (if (eq options.filename nil)
          (return nil))
      (assert (and symbol_path options.filename) "Invalid options to edit_file")
      
      ;; if we are given a create mode, make the shell of a file
      (if (and options.create_mode
               (> (length data_to_save) 0) )
         (try
            (progn
               (= rval (http/send_files "/save_file" (http/data_to_file options.filename data_to_save "text/plain")))
               (if (and rval
                        (== rval.rval "OK"))
                   (log "Created empty file: " options.filename)
                   (throw Error rval.message)))
            (catch Error (e)
               (progn
                  (alert_box (dtext "Unable to Create File")
                             (+ "" options.filename ": "
                                e.message))
                  (set_prop options
                             `filename
                             nil)))))
            
      (if (eq options.filename nil)
          (return nil))
      
      (if (and (starts_with? "filesystem" symbol_path)
               (eq nil (resolve_path symbol_path Environment.global_ctx.scope)))
          (progn
             (for_each (comp (chop symbol_path))
                (progn
                   (push acc comp)
                   (set_path acc Environment.global_ctx.scope {})))
             (push acc (last symbol_path))
             (set_path acc Environment.global_ctx.scope "")))
      (set_prop options
         `path
         symbol_path)
      (alert_on_error "File Open Error"
         (new_buffer options)))
   {
       `description: (+ "If provided an options object with a filename key and file path value, "
                        "the function will attempt to fetch and present that file for editing. "
                        "If an error is encountered, the error will be presented to the user "
                        "in a popup window and nil returned.  If called with no options, the "
                        "function will prompt the user to select a file via a file_tree_browser "
                        "control.  If create_mode is true in the options, then a new file "
                        "creation will be attempted and an editor returned for that.  If a "
                        "new file cannot be created, the user will be warned and nil will "
                        "be returned.")
       `usage: ["options:object"]
       `tags: ["DOM" "ui" "file" "edit" "open"]
   })
       
(defun new_file (filename)
   (cond 
      (and (is_string? filename) (file_status filename))
      (throw Error "new_file: filename already exists!")
      (is_string? filename)
      (edit_file { `filename: filename `create_mode: true })
      else
      (edit_file { `create_mode: true }))
   {
     description: (+ "The function `new_file` creates a new file and opens it up for "
                     "editing.  If provided with a filename it will directly create that file if it "
                     "doesn\'t already exist.  If it already exists, it will throw an error stating "
                     "that the file already exists.  If not filename is provided, it will open up a "
                     "prompt for the file to be selected by the user prior to the create and open "
                     "steps.  ")
     usage: ["filename:?string"]
     tags: ["DOM" "ui" "file" "edit" "open" "create"]
     })

  
;; control behavior for unsaved controls in remote mode
;; if a control that is a buffer is to be saved to a file:
;;  1.  select a file to create
;;  2.  make a new editor with the contents of the old control as a proper file
;;  3.  swap with old control. 
;; if we do not have a host and are running locally, 
;;  1.  Establish an export_as name and save the file to that, but retain the existing editor

(defun handle_save_file (control options)
  (let
      ((fname (when control
                (or (and options.no_prompt
                         (is_string? control.options.filename)
                         control.options.filename)
                    (and options.remote
                       (wait_for_file_selection true))
                    (and (not options.remote)
                         (request_user_input (dtext "Download Buffer To Local File") 
                                             `text
                                             { `placeholder: (dtext "Name Of File")
                                                            `value: (aif (resolve_path [ `options `export_as ] control)
                                                                         it
                                                                         nil) })))))
       (rval nil))
      (declare (function wait_for_file_selection)
               (global wait_for_file_selection))
    
    (when (and (not (blank? fname))
               control
               control.get)
       (cond
          (and options.remote
               fname)
          (progn
             (alert_on_error "Cannot Create File"
                (progn
                   (= rval (http/send_files "/save_file" (http/data_to_file fname (or (-> control `get) ""))))
                   (if (and rval
                            (== rval.rval "OK"))
                       (progn
                          (= rval rval.results)
                          (notify "File saved")
                          (when (== rval.length 1)
                             ;; we made the file, now open a new buffer to it and swap with the old control
                             (edit_file { `filename: fname `control_to_replace: control })))
                       (progn
                          (log "ERROR on file creation: " rval)
                          (throw rval.message))))))
          fname
          (alert_on_error "Cannot Save Locally"
             (= rval (save_locally fname (-> control `get)
                                   "application/text"))
             (when rval
                (set_path_value control [ `options `export_as ] fname)
                (if control.display_context_message
                   (-> control `display_context_message (+ (dtext "Exported as: ") fname))))
             (log "Local save returned: " rval)))))
  {
   `usage: ["control:object" "options:?object"]
   `description: (+ "Given a control and an optional options object, will call the control's "
                    "`get method for the data value, and saves the value returned by the get "
                    "operation.  If the remote option is true and there is no options.filename "
                    "set, the user will be prompted with a chooser.  If the file is to be saved "
                    "locally, the user will be asked for a name to export it as, and the file "
                    "will be downloaded from the browser to the local environment and placed "
                    "in the default download folder of the browser.<br>"
                    "When a file is saved remotely, a new editor is established that is now "
                    "linked to the remote file and further saves for that buffer will be "
                    "defaulted to that filename.  If local, on subsequent saves the user will "
                    "be prompted to confirm the filename, or choose another."
                    "<br>Options are: <br>"
                    "remote:boolean - Attempt to save the file to the hosting server.<br>"
                    "no_prompt:boolean - If a filename is already established via options.filename "
                    "do not prompt for a new filename.")
   `tags: ["save" "file" "control"]
   })    

(defun set_key_binding (scope name desc)
  (let
      ((target (resolve_path [ scope ] *key_bindings*))
       (key_mode (get_operating_platform)))
    (progn
     (set_prop target
               name
               desc)
     (set_prop *key_bindings*.active
               (prop desc key_mode) 
               (prop desc `exec))))
  {
      `description: (+ "Given a scope for the keybinding, a command name key, and a description object, "
                       "establishes the binding in the *key_bindings* and in the environment as active. "
                       "<br>The description object should contain the following keys:<br>"
                       "description:text - A human readable description of what the key binding does.<br>"
                       "exec:fn - The function to execute when the key binding occurs. Some exec entries " 
                       "can be nil if the control has an internal function for the command name.<br>"
                       "mac:text - The key sequence to use on environments running on MacOS<br>"
                       "win:text - The key sequence to use when running on Windows or Linux (or non Mac environments)<br>")
      `usage: ["scope:string" "name:string" "desc:object"]
      `tags: ["keys" "bindings" "settings" "configuration" "config" ]
                       
  })
  
;; the global keyword_mapper routes to the currently focused
;; editor for the local keyword_mapper to that editor and the
;; environment it might be connected to

(defun_sync keyword_mapper (token)
   (progn
      (defvar details nil)
      (defvar rval
         (cond
            (and *last_focus*
               (prop *last_focus* `keyword_mapper))
            (-> *last_focus* `keyword_mapper token)
            (contains? token *formatting_rules*.keywords)
            "keyword"
            (progn
               (setq details
                     (first (meta_for_symbol token true)))
               details.type)
            (lowercase details.type)
            else
            "identifier"))      
      rval))

;; and redirect the core/keyword_mapper entry point
;; from the javascript world..

(use_quoted_initializer
 (defun_sync core/keyword_mapper (token)
   (user/keyword_mapper token)))

(defun gen_file_menu ()
   [["New..." [(if is_served?
                   ["Server File" new_file]
                   [])
               ["Juno REPL" (fn (e) (new_juno_repl))]
               (if is_served? 
                  ["Juno Remote REPL" (fn (e) (new_juno_repl { `remote_repl: (+ "ws://" window.location.host "/connect_repl") }))]
                  [])
               ["--" nil]
               [{ text: "Juno Lisp Editor" 
                  path: [ `global `open_new_buffer ]
                  }
                  (fn (e) (new_buffer { `type: "juno" }))]
               ["Javascript Editor" (fn (e) (new_buffer { `type: "javascript" })) ]
               ["CSS Editor" (fn (e) (new_buffer { `type: "css" })) ]
               ["Text Editor" (fn (e) (new_buffer { `type: "text" })) ]
               ["JSON Editor" (fn (e) (new_buffer { `type: "json" }))]]]
    (if is_served?
       ["Open File" edit_file ]
       [])
    (if (resolve_path [ `get ] *last_focus*) 
        ["--" nil]
        [])
    (cond
       (and is_served?
             *last_focus*
             (resolve_path [ `options `filename ] *last_focus*))
        [{ text: (+ (dtext "Close ") (get_editor_file_basename *last_focus*)) 
           path: [ `global `close_control ] } 
           (fn () (close_file *last_focus*)) ]
        (and *last_focus*
             (resolve_path [ `options `name ] *last_focus*))
        [{ text: (+ (dtext "Close ") (resolve_path [ `options `name ] *last_focus*))
           path: [ `global `close_control ] }
           (fn () 
              (hide_control *last_focus* true true)) ]
        else
        [])
    (if (and *last_focus*
             is_served?
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [{ text: (+ (dtext "Save") " "
                    (or (aif (resolve_path [ `options `filename ] *last_focus*)
                             (last (split_by "/" it)))
                        (resolve_path [ `options `name ] *last_focus*)
                        ""))
           path: [ `global `save_file ] }
         (fn (e) (save_active_buffer))]
        [])
    (if (and *last_focus*
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [(+ (dtext "Save As")
            "...")
         [(if is_served?
              [(dtext "New Server File") (fn (e) (handle_save_file *last_focus* { `remote: true }))]
              [])
          [(dtext "Local File") (fn (e) (handle_save_file *last_focus*))]]]
        [])
    ["--" nil]
    [(+ (dtext "Browser Environment") "...")
     [(if is_served?
        [(dtext "Bundle Application To Host") (fn (e) (save_control_image true)) ]
        [])
     [(dtext "Bundle Application and Download") (fn (e) (save_control_image true { save_locally: true })) ]
     (if is_served?
        [(dtext "Generate Starter Application") build_starter_environment]
        [])
     [(dtext "Import Local File") (fn (e) (-> resource_loader_button `click)) ]]]
    (if is_served?
       [(dtext "Rebuild Host Juno Environment")
        (fn (e) (rebuild_remote_environment))]
       [])
    (if *global_themes*
       ["--" nil]
       [])
    (if *global_themes*
       ["Set Global Theme" (for_each (theme_name (keys *global_themes*))
                              [theme_name (fn ()
                                             (set_global_theme theme_name))])]
       [])]);

(defun gen_layout_menu ()
   (let
      ((menu_acc [])
       (idx 0)
       (holding_tank (get_control_by_name "Holding Tank"))
       (control_to_place (fn ()
                            (if (and (prop *last_focus* `editor) ;; if we are in an editor, (but not repl) split it
                                     (not (== (prop *last_focus* `type) "visual_repl")))
                                (clone_text_editor_control *last_focus*) 
                                (empty_selection_control)))) ;; otherwise pull the last control out of storage
                             
       (root_ctls (new Set)))
      (conj
         ;[["New Frame" (fn ()
                          ;(new_top_level_frame))]]
         (reduce (pset (pairs (controls_by_parent)))
            (destructuring_bind (key controls)
               pset
               (console.log "key: " key "is the holding tank?" (== (get_control_by_name key) holding_tank) controls  )
               (cond
                  (== key "root")
                  (progn
                     (for_each (control controls)
                        (-> root_ctls `add control.name))
                     nil)
                  
                  (and (-> root_ctls `has key)
                       (not (== key "Holding Tank")))
                  [key (for_each (operation ["Split Right" "Split Bottom" "Show" "Hide"])
                          (progn
                             (defvar control (get_control_by_name key))
                             [(dtext operation)
                              (cond
                                 (and (> idx 1)
                                      (== operation "--"))
                                 nil
                                 (== operation "Split Right")
                                 (fn ()
                                    (place_control "right" (control_to_place)))
                                 (== operation "Split Bottom")
                                 (fn ()
                                    (place_control "below" (control_to_place)))
                                 (or (and (== operation "Show")
                                          (-> holding_tank `has_control? control))
                                     (and (== operation "Hide")
                                          (not (-> holding_tank `has_control? control)))
                                     (and (== operation "Close Control")
                                          (-> holding_tank `has_control? control)))
                                 (progn
                                    (when (-> holding_tank `has_control? control)
                                       (inc idx))
                                    (fn ()
                                       (container_view_operation (to_key operation)
                                                                 (get_control_by_name key)
                                                                 nil))))]))]
                  
                  (not (== key "Holding Tank"))
                  [key (for_each (operation ["Split Above" "Split Below" "Split Left" "Split Right"])
                          [(dtext operation) (fn ()
                                  (progn
                                     (console.log key "operation: " operation controls)
                                     (container_view_operation (to_key operation)
                                                               (get_control_by_name key)
                                                               (control_to_place))))])]))))))

(defun gen_controls_menu ()
  (progn
   (defvar holding_tank (get_control_by_name "Holding Tank"))                
   (defvar holding_tank_visible? (if (prop (control_position holding_tank) `parent)
                                     true
                                     false))
   (conj 
        (reduce (control (current_controls))
            (when (and control.on_focus
                       control.options.id)
              (defvar is_displayed? (and (not (== holding_tank control))
                                         (not (-> holding_tank `has_control? control))))
              [(or control.name "Untitled") 
               (reduce (operation ["Show" "Focus" "Hide" "--" "Close Control"])
                       (cond
                         (== control.name "Holding Tank")                              
                         (cond
                           (== operation "Focus")
                           [(dtext "Show")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `show))]
                           (and holding_tank_visible?
                                (== operation "Hide"))
                           [(dtext "Hide")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `hide))]
                           else
                           nil)
                         else
                         [(dtext operation)
                          (cond
                            (and (not is_displayed?)
                                 (== operation "Show"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (show_control it)))
                            (and is_displayed? (== operation "Focus"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (set_focus_to it)))
                            (and is_displayed? (== operation "--"))
                            nil
                            (and is_displayed? (== operation "Hide"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "hide" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id)))))
                            (== operation "Close Control")
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "destroy" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id))))))]))]))
        [[(dtext "Monitor Control Tree") 
          (fn ()
            (progn
             (monitor_control_tree)))  ]])))



(defun user/*initializer* ()
  (let
      ((header nil)       
       (scripts (-> (page_header) `querySelectorAll "script[id]"))                     
       (scratch_editor nil)
       (page_frame nil)
       (control nil)
       (key_mode (get_operating_platform))
       (repl_split nil))
                                                               
    (console.log "user/*initializer is running." )
    
    ;(defglobal main_menu_button (li  { `class: "juno-menu-header" }
     ;                                        (span { `class: "juno-menu-item" `style: "" } "File")))

    (defglobal resource_loader_button (file_picker_button "" load_files))    
    (set_style [["position" "absolute"]
                ["top" "-100px"]
                ["left" "-100px"]
                ["width" "1px"]
                ["height" "1px"]] resource_loader_button)
    
    (-> (get_by_id "body") `appendChild resource_loader_button)
       
    (defvalue $root_controls [])
    
    
    
    ;; the root container which controls are added to..
    (defglobal juno_container
      (div { `style: "height: inherit; width: inherit; position: relative; overflow:hidden;" }))

    
    (set_prop *env_config*.editor
       `extensions_to_mode
       {
         `js: `javascript
         `lisp: `juno
         })
    
    (attach_event_listener juno_container `click
                           (fn (e)
                             (progn
                              (defvar menu (get_by_id `cmenu))
                              (when menu (-> menu `remove)))))
    
    (set_prop *env_config*.export
	      `save_path
	      nil)
            
    (attach_event_listener juno_container
                           `focusin
                           (fn (e)
                             (process_focus_chain e)))

    (-> (get_by_id "body") `appendChild juno_container)

    
    (set_prop *formatting_rules*
       `allocating_forms {
                           `let: (fn (tree)
                                    (progn
                                       (flatten (list (resolve_multi_path [ 1 `* 0 ] tree)))))
                           `defun: (fn (tree)
                                      (progn
                                         (conj (list (resolve_path [ 1 ] tree))
                                               (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defun_sync: (fn (tree)
                                           (progn
                                              (conj (list (resolve_path [ 1 ] tree))
                                                    (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defmacro: (fn (tree)
                                         (progn
                                            (conj (list (resolve_path [ 1 ] tree))
                                                  (flatten (list (resolve_path [ 2 ] tree))))))
                           `function: (fn (tree)
                                         (flatten (list (resolve_path [ 1 ] tree) )))
                           `fn: (fn (tree)
                                   (flatten (list (resolve_path [ 1 ] tree) )))
                           `lambda: (fn (tree)
                                       (flatten (list (resolve_path [ 1 ] tree) )))
                           `destructuring_bind: (fn (tree)
                                                   (progn
                                                      (flatten (list (resolve_path [ 1 ] tree)))))
                           `defvar: (fn (tree)
                                        (flatten (list (prop tree 1))))
                           `for_each: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `for_with: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `reduce: (fn (tree)
                                       (list (resolve_path [ 1 0 ] tree)))
                           `reduce_sync: (fn (tree)
                                            (list (resolve_path [ 1 0 ] tree)))
                           `defglobal: (fn (tree)
                                          (list (prop tree 1)))
                           `defparameter: (fn (tree)
                                             (list (prop tree 1)))
                           
                           })
    
    
    ;; initialize or rehydrate the controls
    (if (== (length *serialized_controls*) 0)
      (progn       
       (console.log "initializing control surface")
       ;; take in the global default theme, but don't impact the setting for the sub themes
       (set_global_theme *env_config*.application.global_theme { `suppress_set_sub_theme: true `suppress_cascade: true })
       (defglobal $repl (visual_repl { `name: "Juno REPL"  `display_options: { `show_timestamps: true }}))
       (try
         (= scratch_editor
            (text_editor { name: "*scratch*" 
                          namespace: "user" 
                          path: [ `*scratch* ] 
                          mode: `juno }))
         (catch Error (e)
           (console.error "error on constructing scratch editor: " e)))

       (push *main_menu*   ;; using a wrapper function allows us to change the menu more dynamically
             [ "File" (fn ()
                         (gen_file_menu))])
                         
       
       (push *main_menu*            
             ["Controls" (fn ()
                        (gen_controls_menu))])
       (push *main_menu*
             ["Layout"
               (fn ()
                  (gen_layout_menu))])
       
       (push $root_controls
             (app_header [(app_menu [ `*main_menu* ])]
                         { `app_title: "Seedling" }))
       (setq page_frame ;; or surface which can be named in the upper right or middle
             (control_container nil {                                     
                                     `root_frame: true
                                     }))

       
       (set_prop *key_bindings*.global
                 "open_new_buffer" { win: "Command-Enter"
                                     mac: "Command-Enter"
                                     description: "New Juno Buffer"
                                     exec: (fn () (new_buffer { type: "juno" }))
                                    }
                 "juno_remote_repl" { win: "Alt-Shift-2"
                                     mac: "Command-Shift-2"
                                     description: "Juno Remote Repl"
                                     exec: (fn (e) (new_juno_repl { `remote_repl: (+ "ws://" window.location.host "/connect_repl") }))
                                    }
                 "juno_repl" { win: "Alt-Shift-1"
                               mac: "Command-Shift-1"
                               description: "Juno REPL"
                               exec: (fn (e) (new_juno_repl))
                               }
                 "save_file" { win: "Ctrl-S"
                               mac: "Command-S"
                               description: "Save File"
                               exec: (fn () (save_active_buffer))                              
                              }
                 "open_file" { win: "Ctrl-O"
                               mac: "Command-O"
                               description: "Open File"
                               exec: (fn () (edit_file))
                              }
                 "server_file" { win: "Ctrl-N"
                               mac: "Command-N"
                               description: "New File"
                               exec: (fn () (new_file))
                              }
                 "toggle_documentation" { win: "Shift-Escape"
                                        mac: "Shift-Escape"
                                        description: "Show Help Panel"
                                        exec: (fn () 
                                                 (toggle_help_panel)) }
                 "search_documentation" { win: "Alt-H"
                                          mac: "Alt-H"
                                          description: "Search Documentation"
                                          exec: (fn () 
                                                  (show_help_panel true)) }
                 
                 
                 "save_environment" { win: "Ctrl-Shift-S"
                                      mac: "Command-Shift-S"
                                      description: "Saves the current state of the application"
                                      exec: (fn () (save_control_image true))
                                     } 
                 "next_hidden_control" { win: "Alt-Shift-Period"
                                         mac: "Command-Shift-Period"
                                         description: "Next Hidden Control"
                                         exec: (fn () (next_hidden_control))
                                         }
                 "go_backward_in_position" {
                                       description: "Go backward in the current editor position history"
                                       win: "Alt-BracketLeft"
                                       mac: "Command-BracketLeft"
                                       exec: (fn ()
                                                (when (prop *last_focus* `step_backward_in_pos_history)
                                                   (-> *last_focus* `step_backward_in_pos_history)))
                                       }
                 "go_forward_in_position" {
                                       description: "Go forward in the current editor position history"
                                       win: "Alt-BracketRight"
                                       mac: "Command-BracketRight"
                                       exec: (fn ()
                                                (when (prop *last_focus* `step_forward_in_pos_history)
                                                   (-> *last_focus* `step_forward_in_pos_history)))
                                       }
                 "prior_hidden_control" { win: "Alt-Shift-Comma"
                                          mac: "Command-Shift-Comma"
                                          description: "Prior Hidden Control"
                                          exec: (fn () (next_hidden_control true))
                                          }
                 "next_displayed_control" { win: "Alt-Period"
                                            mac: "Command-Period"
                                            description: "Next Displayed Control"
                                            exec: (fn () (next_displayed_control))
                                            }
                 "split_vertically" {
                                       win: "Ctrl-Backslash|Alt-3"
                                       mac: "Ctrl-Backslash|Alt-3"
                                       description: "Split the current control to the right"
                                       exec: (fn () (split_control `vertical))
                                      }
                 "split_horizontally" {
                                       win: "Alt-Backslash|Alt-2"
                                       mac: "Alt-Backslash|Alt-2"
                                       description: "Split the current control downward"
                                       exec: (fn () (split_control `horizontal))
                                      }
                  "close_panel" {
                                       win: "Alt-0"
                                       mac: "Alt-0"
                                       description: "Close the currently focused panel and put the control into the holding tank."
                                       exec: (fn () (hide_control *last_focus*))
                                      }
                  "close_control" {
                                       win: "Alt-D"
                                       mac: "Alt-D"
                                       description: "Close (Destroy) the control in the currently focused panel."
                                       exec: (fn () (hide_control *last_focus* true true))
                                      }
                  "evaluate_and_replace_at_point" {
                                                    mac: "Command-R"
                                                    win: "Alt-R"
                                                    description: "Evaluate the selected text, or text prior to the form and replace with the results if not nil"
                                                    exec: (fn ()
                                                             (evaluate_and_replace_at_point))
                                                    }
                  "evaluate_and_append_at_point" {
                                                   mac: "Command-Shift-R"
                                                   win: "Alt-R"
                                                   description: "Evaluate the selected text, or text prior to the form and append with the results if not nil"
                                                   exec: (fn ()
                                                            (evaluate_and_replace_at_point { `append: true }))
                                                   }
                  "edit_description_text" {
                                            win: "Alt-E"
                                            mac: "Command-E"
                                            description: "Edit the description text in the DOM editor"
                                            exec: (fn () (edit_description_text))
                                            }
                  "clear_repl_output" {
                                        win: "Alt-Shift-K"
                                        mac: "Command-Shift-K"
                                        description: "Clears the system repl output pane."
                                        exec: (fn () (-> *system_repl* `clear_output))
                                        })
       ;; the execs are nil because the editor will use the key of the object to assign the correct
       ;; internal function
       
       (set_prop *key_bindings*.editor
                 "evaluate_selection" { win: "Shift-Enter"
                                        mac: "Shift-Enter"
                                        description: "Evaluate the current selected text"
                                        exec: nil
                                       }
                 "on_save" {  description: "Invokes save for the currently focused control"
                              win: "Ctrl-s"
                              mac: "Command-s"
                              exec: nil
                            }
                 "increase_font_size" {
                                       description: "Increase the font size of the current editor"
                                       win: "Ctrl-Shift-="
                                       mac: "Ctrl-Shift-="
                                       exec: nil
                                       }
                 "decrease_font_size" {
                                       description: "Decrease the font size of the current editor"
                                       win: "Ctrl-Shift--"
                                       mac: "Ctrl-Shift--"
                                       exec: nil
                                       }
                 
                 "select_form_root" {
                                     description: "select_form_root"
                                     win: "Ctrl-Shift-Enter"
                                     mac: "Ctrl-Shift-Enter" 
                                     exec: nil }
                 "select_current_form" {
                                        description: "select_current_form"
                                        win: "Ctrl-Enter"
                                        mac: "Ctrl-Enter" 
                                        }
                 "evaluate_root_form" {
                                        description: "Evaluates the current form at the cursor position."
                                        win: "Alt-C"
                                        mac: "Alt-C"
                                        exec: nil
                                        }
                 "indent_current_row" {
                                       description: "Indent the row at the cursor position"
                                       win: "tab"
                                       mac: "tab"
                                       exec: nil
                                       })
       
       
                 
       (-> juno_container
           `append page_frame.view)

       (-> page_frame `initialize)
       
       (-> page_frame `set_content 0
           (split_view_vertical scratch_editor
                                $repl))
       
       (console.log "initializer: *last_top_frame*: " *last_top_frame*)
       
       (push $root_controls page_frame)
       ;; the holding tank contains the controls  that are still needed but not
       ;; presently displayed 
       (push $root_controls (control_holding_tank [] {}))
       
       (-> scratch_editor
           `set_evaluator_control $repl)
       
       (when (blank? (prop *env_config*.export `save_prefix))
         (set_prop *env_config*.export
                   `save_prefix
                   "seedling"))
       
       (-> juno_container
           `append page_frame.view)
       (-> (control_holding_tank) `add_control (juno_documentation))
       (-> page_frame `initialize))
      (progn     
         (console.log "serialized controls: " *serialized_controls*)
         (rehydrate_controls juno_container *serialized_controls*)))
    
    (sleep 0.1)
    (default_focus)
    ;; setup key bindings
    (set_prop *key_bindings*
              `active
              {})  ;; reset out and copy
    (for_each (desc (values (prop *key_bindings* `global)))
       (progn
          (for_each (key_combo (split_by "|" (prop desc key_mode)))
             (set_prop *key_bindings*.active
                key_combo
                (prop desc `exec)))))

     (attach_event_listener juno_container
                           `click
                           (fn (e)
                             (handle_app_click_event e)))
    
    (attach_event_listener (first (get_by_tag `body))
                           `keydown
                           (function (e)
                             (progn                              
                              (defvar kcode (get_key_code e))
                              (when *log_key_events* (log "key_code:" kcode "->" (prop *key_bindings*.active kcode)))
                              ;(console.log "kcode is: " kcode)
                              (aif (prop *key_bindings*.active kcode)
                                   (progn
                                    (handle_event e)
                                    (try 
                                       (it)
                                       (catch Error (e)
                                          (progn
                                             (log_error (+ "Base Catch: " e.message))
                                             (log_error e))))))
                              )))
    
    (attach_event_listener document
       `blur
       (fn (event)
          (progn
             (setq *document_focused* false)
             (dispatch_event { command: "blur"
                               source: "document"
                               args: [ ] }))))
    (attach_event_listener document
       `focus
       (fn (event)
          (progn
             (setq *document_focused* true)
             (dispatch_event { command: "focus"
                               source: "document"
                               args: [ ] }))))
    
    
    
    (notify (+ "Hello " *namespace* ))
    true))






