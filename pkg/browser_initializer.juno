; Seedling IDE Consolidated Source File
; Copyright (c) 2022-2024, Kina, LLC
; 🌱

; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:

; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.

; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.


; TODO: SPLIT UP INTO SEPARATE FILES - TOO LARGE 




(defglobal main_menu_button nil) ;; placeholders 
(defglobal resource_loader_button nil)
(defglobal juno_container nil)
(defglobal repl_editor nil)
(defglobal *scratch* (join "\n" 
                           [ "; *scratch* buffer - Lisp code can be entered here and evaluated" 
                             "; by using Alt-C to evaluate the current lisp form, or selecting a "
                             "; specific form and pressing Shift-Enter.\n\n"]))

;; Repo for this application
(defglobal *public_repo* "https://github.com/KinaKnowledge/juno-lang")

(defvalue *key_bindings* {
                           repl:{}
                           editor:{}
                           global:{}
                           active: {}
                           })

(defvalue *main_menu* [])
(defvalue *serialized_controls* [])
(defparameter *tags_to_meta* {})
(defparameter core/$current_control nil)

;; the controls at the top level of the view
(defparameter core/$root_controls [])

(defparameter core/*system_repl* nil)

(console.log "browser_initializer running")



(defparameter core/is_served? (and (not (blank? (resolve_path [ `location `hostname ] window)))
                                   (== (prop (fetch "/files") `status) 200)))
(defparameter filesystem {})

;; the global pointer to the control which has focus
;; nil if there are no focus points or values.

(defparameter *last_focus* {})   ;; declare as an object type but will be set to nil on startup
(defparameter *last_top_frame* nil)
(defparameter *app_menu_control* nil)
(defparameter *log_key_events* false)
(defparameter *document_focused* true)
(defparameter *ipc_promise_ids* {})
(defparameter *whitespace_regexp* (new RegExp "\\\\s" `g))

(defparameter TokenIterator (function () true)) ;; filled in by the first editor
(defparameter core/*evaluators* {})  ;; remote evaluators

(defparameter *build_window* nil) ;; handle to the build window
(defparameter *system_requires_export* false)
(defparameter *dpi_change_listener* nil)

(defvalue *ace_option_description*
   { editor: {
        hScrollBarAlwaysVisible: `boolean
        vScrollBarAlwaysVisible: `boolean
        highlightGutterLine: `boolean
        animatedScroll: `boolean
        showInvisibles: `boolean
        showPrintMargin: `boolean
        printMarginColumn: `number ; (defaults to 80)
        fadeFoldWidgets: `boolean
        showFoldWidgets: `boolean ; (defaults to true)
        showLineNumbers: `boolean ; (defaults to true)
        showGutter: `boolean ;(defaults to true)
        displayIndentGuides: `boolean ; (defaults to true)
        }
      session: {
         firstLineNumber: `number
         overwrite: `boolean
         newLineMode: [ "auto" "unix" "windows" ]
         useSoftTabs: `boolean
         tabSize: `number
         foldStyle: [ "markbegin" "markbeginend" "manual"]
         }
      }
     {
         description: (+ "Object whose keys are the options and the values " 
                         "describe the data type of the option for the text_editor "
                         "control, which uses the Ace editor.")
         tags: ["editor" "options" ]
     })

(defun prefers_dark_theme? ()
   (if (has_the_keys? [`matchMedia ] window)
      (prop (window.matchMedia "(prefers-color-scheme: dark)") `matches)
      nil)
   {
     `description: (+ "Returns `true` if the user has a dark preference set for a system color "
                      "scheme, `false` if they don\'t. If the browser doesn\'t support the \'matchMedia\' "
                      "function, then `nil` is returned.<br>This function takes no arguments. ")
       `usage: []
       `tags: ["UI" "DOM" "theme" "dark" "light"  "color" "system"]
   })

(defun_sync core/hostname ()
   location.hostname
   {
     description: (+ "If the client is being served via service, as opposed to running "
                     "locally as a file in the browser, this will return the name of the host that is "
                     "named in the `hostname` field of the `location` object of the browser "
                     "environment.  If not served this function will return `nil`. ")
     usage: []
     tags: ["browser" "location" "hostname" "server" "remte" "url" "uri"]
   })

(defun_sync get_app_args ()
   (let
      ((params (prop (new URL window.location) `searchParams))
       (args {}))
      (try
         (for_with (key (-> params `keys))
            (set_prop
               args
               key (-> params `get key)))
         (catch Error (e)
            nil))
      args)
   {
     description: (+ "Called with no arguments, returns the parameters of the URI of the "
                     "browser environment in an object form if possible.  Otherwise an empty object "
                     "is returned.  If the parameters are not in a `key=value` format, then the "
                     "result is an empty object or keys with empty values.")
     usage: []
     tags: ["arguments" "args" "parameters" "URI" "search" "params" "browser" ]
   })

(defun_sync host_details ()
   (+ (or (get_app_args) 
          {})
      {
        hostname: location.hostname
        port: (if location.port
                 (parseInt location.port)
                 nil)
        origin: location.origin
        protocol: location.protocol
        pathname: location.pathname
        app_mode: (if (== "true" (prop (get_app_args) "app_mode"))
                      true
                      false)
        })
   {
     description: (+ "Returns an object containing service location and application arguments "
                     "of the current browser environment.  The returned object will contain the "
                     "hostname, port, origin, protocol, pathname, if the environment is running in "
                     "app_mode, and other arguments provided to the running environment via the URI "
                     "which started it. ")
     usage: []
     tags: ["browser" "location" "hostname" "server" "remte" "url" "uri" "arguments" "args"]
   })

(set_prop *key_bindings*.repl          
          `history_next_entry { win: "Ctrl-Alt-n" mac: "Ctrl-Alt-n" }                                                               
          `history_prior_entry { win: "Ctrl-Alt-p" mac: "Ctrl-Alt-p" })

(defmacro with_lock ((name lock_handle) `& body_forms)
   `(-> navigator.locks `request
       name
       (fn (,#lock_handle)
          (progn
             ,@body_forms)))
   {
     description: (+ "Creates a lock using the WebLock API, and with the provided body forms, "
                     "runs those forms in an implicit `progn` block.  The final form\'s return value "
                     "is returned when the lock completes. <br>### Example```(with_lock (lock)\n "
                     " (do_something_1)\n  (do_something_2))\n```<br><br>In the above the return code "
                     "from `do_something_2` is returned to the caller.<br> ")
     usage: ["name_and_lock_symbol:array" "body_forms:array"]
     tags: [ `execution `lock `synchronization `locking `locks]
   })

(defun make_icon (path_data size color width height stroke_width)
   (let
      ((size (or size 15))
       (width (or width 12))
       (height (or height 10))
       (stroke_width (or stroke_width "1"))
       (path_data (cond 
                     (is_string? path_data)
                     path_data
                     (is_array? path_data)
                     (join " " (flatten path_data))
                     else
                     "M 1 1 L 11 11 M 11 1 L 1 11"))
       (color (or color "var(--main-color)"))
       (vectors (svg { height: size version:"1.1" width: size viewBox:(+"0 0 " width " " height) }
                     (path { d: path_data 
                             fill:"transparent"
                             stroke: color
                             stroke-width: stroke_width
                     } )))
                      
       (container (div { `style: "display: inline-block;" })))
      (set_prop container
         `innerHTML (prop vectors `outerHTML))
      container)
   {
     `description: (+ "Given path data values, either as an array or string, produces an SVG "
                      "based icon within a inline-block div.  Default size is 15 and default color is "
                      "var(--main-color).<br>The values for the path data can either be in array or "
                      "string form and should be in the form of:```directive value "
                      "value```<br><br>Where directive is either `M` for `Move`, or `L` for `Line` and "
                      "is then followed by numeric values signifying `x` and `y` coordinates within "
                      "the bounding box, which has a default size of 12 wide and 10 high.  This can be "
                      "changed via the optional `width` and `height` arguments.<br>An example that "
                      "draws a dark blue downward arrow:```(make_icon [\"M 6 1\" \"L 6 11\" \"L 1 6\" \"M 6 "
                      "11\" \"L 11 6\"] 15 \"darkblue\")```<br><br>The width and height are set at the "
                      "default values, `12` and `10`, respectively.  <br>For finer control, the scale "
                      "can be adjusted.  For example here is the same icon drawn within a 120x100 "
                      "viewbox.  Note that the `stroke_width` parameter is specified as `10` to ensure "
                      "that the line drawn is thick enough to be legible:```(make_icon [\"M 50 0\" \"L 50 "
                      "100\" \"L 0 50\" \"M 50 100\" \"L 100 50\"] 15 \"darkblue\" 120 100 10)```<br><br><br> ")
       `usage: ["path_data:array|string" "size:number|string" "color:?string" "width:?number" "height:?number" "stroke_width:?number"]
       `tags: ["icon" "draw" "path" "svg" "ui"]
   })

(defun_sync element_to_lisp (element options)
   (if (is_element? element)
       (let
          ((tag_name (if (is_function? options.tagname_for_element)
                         (-> options `tagname_for_element element)
                         element.tagName))
           (ns (if (is_string? options.use_ns)
                   (+ options.use_ns "/")
                   ""))
           (elem_as_lisp (list (+ "=:" ns (lowercase tag_name))))
           (acc [])
           (nodes nil)
           (ptype nil)
           (val nil)
           (attrib_list (prop element `attributes))
           (attribs {}))
          (for_each (attrib_num (range (length attrib_list)))
             (progn
                (set_prop attribs
                   (resolve_path [ `attributes attrib_num `name ] element)
                   (resolve_path [ `attributes attrib_num `value ] element))))
          (if (prop element `onclick)
              (set_prop attribs
                 `onclick
                 (prop element `onclick)))
          (when (and (== tag_name "INPUT")
                     (== (prop attribs `type)
                         "checkbox"))
             (if (prop element `checked)
                 (set_prop attribs
                    `is_checked
                    true)
                 (set_prop attribs
                    `is_checked
                    false)))
          (push elem_as_lisp
             attribs)
          (= nodes element.childNodes)
          (for_each (cnum (range (length nodes)))
             (cond 
                (== 3 (resolve_path [ cnum `nodeType ] nodes))
                (push elem_as_lisp
                   (if (is_function? options.on_text)
                       (-> options `on_text (resolve_path [ cnum `nodeValue] nodes) nodes)
                       (resolve_path [ cnum `nodeValue] nodes)))
                (== 1 (resolve_path [ cnum `nodeType ] nodes))
                (progn
                   (unless (has_class?  "juno-non-value" (resolve_path [ cnum ] nodes) `classList )
                      (push elem_as_lisp
                         (element_to_lisp (resolve_path [ cnum ] nodes) options))))))
          (if (is_function? options.on_element_complete)
              (-> options `on_element_complete elem_as_lisp)
              elem_as_lisp))
       [ "UNKNOWN:" element ])
   {
     `description: (+ "Given a DOM element, returns the lisp represenation of the DOM element.<br>"
                      "If provided with an options object, the following keys are applicable:<br>"
                      "tagname_for_element:(fn element) - For every new element encountered in the "
                      "provided tree, will be called with the new element.  The function should "
                      "return a string value to be used for the tagname as opposed to the original "
                      "element tagName value.<br>"
                      "use_ns:string - Qualify the emitted tag symbols with the provided namespace.<br> "
                      "on_text:(function text nodes) - Will be called on a text node with the text and "
                      "and the sibling nodes.<br>"
                      "on_element_complete:(function array) - Will be called with the quoted lisp form "
                      "that was constructed.  The function can then manipulate the completed form "
                      "prior to it being placed in the returned lisp form.  Note that this function "
                      "is called for every completed element, not just the final return value.")
     `usage: ["element:element" "options:object"]
     `tags: ["DOM" "ui" "serialize" "serialization" "view" "element" ]
   })

(defun dimensions (elem)
   (if (is_element? elem)
      (-> elem `getBoundingClientRect)
      (throw TypeError "dimensions requires a DOM element object"))
   {
     description: (+ "Given a DOM element, returns the current geometry of the provided "
                     "element as an object.  <br>If nil or a non-Element is provided, " 
                     "a `TypeError` will be thrown. ")
     usage: ["element:Element"]
     tags: ["bounding" "boundaries" "geometry" "element" "DOM" "element" "dimension"]
     })

(defun file_picker_button (button_text on_selection)
  (let
      ((elem (html/input { type: "file" 
                          value: (or button_text "Open")
                          onchange: (fn (e)
                                      (let
                                          ((items e.srcElement.files)
                                           (status nil))
                                        (when on_selection
                                          (on_selection items)))) })))
    (declare (fn on_selection html/input)
             (global html/input))
    (when (eq nil on_selection)
      (throw "on_selection is required for file_picker_button"))
    elem))

(defun notify (text type on_click)
        (let
            ((type (or type "info"))
             (timer nil)
             (view (div { `class: "juno-notification" 
                          `style: (cond
                                     (== type "error")
                                     "border-left: 10px solid var(--type-error-color);"
                                     (== type "success")
                                     "border-left: 10px solid var(--success-color);"
                                     else
                                     "border-left: 10px solid var(--primary-action-bg-color);") }
                         (or text "-"))))
            (when (eq nil (get_by_id "lower_right_corner"))
                  (-> (get_by_id "body")
                      `appendChild (div { `id: "lower_right_corner" `style: "position: absolute; right: 50px; bottom: 5px; width: 255px;" } )))
            
            (-> (get_by_id "lower_right_corner") `appendChild view)
            (-> view `animate [{ `easing: `ease-in }
                               { `opacity: 1 `easing: `ease-out `offset: 0.1 }
                               { `opacity: 1 `easing: `ease-out } ] 
                           { `duration: 3000 })
            
            (= timer (setTimeout (fn ()
                                   (do 
                                     (-> view `animate [{ `opacity: 0  `easing: `ease-in } ] { `duration: 260 })
                                     (setTimeout (fn () (do
                                                          (-> view `remove)
                                                          (= timer nil)
                                                          (= view nil)))
                                                 250)))                                                   
                            10000))
            (setTimeout (fn ()
                            (set_style [["opacity" 1]] view))
                        200)
            (attach_event_listener view
                 `click
                 (fn (e)
                     (do
                         (when timer (clearTimeout timer))
                         (when view (-> view `remove))
                         (= view nil)
                         (= timer nil)
                         (when on_click
                               (on_click type text)))))
            true)
        {
         `usage: ["text:string" "type?:string" "on_click?:function"]
         `description: (+ "Given a obligatory text string, and an optional type, and on_click function, " 
                          "show an alert for 10 seconds in the lower right hand corner."
                          "<br><br>"
                          "Types are as follows: <br>"
                          "error<br>"
                          "success<br>"
                          "info (default)<br>"
                          "<br>Returns true, but is of no significance.")
         `tags: ["ui" "alerts" "alerting" "message" "notify"]
         })


(defun adjust_element_position (element relative_base)
   (let
      ((dims nil))
      (= dims (-> element `getBoundingClientRect))
      (when (> dims.bottom window.innerHeight)
         (if (is_number? relative_base)
            (set_style [[ "top" (+ "" (- relative_base dims.height) "px") ]] element)
            (set_style [["top" (+ "" (- dims.top dims.height 10) "px") ]] element)))
      (when (> dims.right  window.innerWidth)
         (if (is_number? relative_base)
            (set_style [[ "left" (+ "" (- relative_base dims.width) "px") ]] element)
            (set_style [["left" (+ "" (- window.innerWidth dims.width 5) "px") ]] element)))
      element)
   {
     description: (+ "Given an absolute positioned HTML Element, makes sure that the element "
                     "bottom and right are not partially displayed off screen.  Will adjust the "
                     "elements position if the geometry is determined to be out of bounds.  Returns "
                     "the element. If relative_base is a non-nil number, then the left and top are "
                     "adjusted relative_base to the provided number, vs. an absolute placement.")
     tags: ["ui" "element" "DOM" "position" ]
     usage: ["element:Element" "relative_base:?number"]
   })

(defun editable_element (`& args)
   (let
      ((options (if (and (is_object? args.0)
                         (not (is_element? args.0)))
                    (take args)
                    {}))
       (elem (div { `tabindex: 0 `contenteditable: true `style: (+ "min-width: 20px; display: inline-block;" (or options.style "")) 
                    `class: options.class  } 
                  args))
       (handler (fn (e)
                   (cond
                      (and (not options.multiline) 
                           (== e.key "Enter"))
                      (handle_event e)
                      else
                      (setTimeout (fn ()
                                     (progn
                                        (set_prop elem
                                           `value
                                           (trim elem.innerText))
                                        (when options.on_change
                                           (options.on_change e))))
                            10)))))
      (attach_event_listener elem
                             `keydown
                             handler)
      (log "OPTIONS: " options)
      (set_prop elem `value elem.innerText)
       elem)
   {
       description:(+ "Returns a contenteditable div with an additional value " 
                      "property for the innerText value.  Single line by default, "
                      "setting options.multiline to true will allow for multiple "
                      "line input values. If options.on_change is set as a function "
                      "it will be called with the keydown event.")
       usage: ["options:object" "argsN:*"]
       tags: [`DOM `UI `input `edit `element]
    })


(defun read_text_file (filename)
   (if is_served?
      (LZString.decompressFromBase64 
         (eval `(rblock
                   (LZString.compressToBase64 (read_text_file ,#filename)))))
      (throw EvalError "read_text_file: requires a hosted context"))
   {
     `description: (+ "Given a filename, and on condition of being in a hosted context "
                      "(is_served? will be `true`), will attempt to read the text file on the server "
                      "at the path name provided.  Returns the text or throws an error if the file "
                      "cannot be read. ")
     `usage: ["filename:string"]
     `tags: ["read" "file" "text" "io"]
   })

(defun read_file (file options)
    (new Promise
         (fn (resolve reject)
           (let
               ((reader (new FileReader))                
                (options (+ {}                          
                            {
                             `read_as: "binary"
                             `details: false
                             }
                            options))
                (read_as options.read_as))
             (set_prop reader
                       `onload
                       (function (e)
                                 (progn
                                  (resolve
                                   (cond
                                     options.details
                                     {
                                      `name: file.name
                                      `type: file.type
                                      `size: file.size
                                      `data: reader.result                                     
                                      }
                                     else
                                     reader.result))))
                       `error
                       (function (e)
                                 (reject e)))
             
             (cond
               (or (== read_as "binary")
                   (== read_as "ArrayBuffer"))
               (-> reader `readAsArrayBuffer file)
               (== read_as "text")
               (-> reader `readAsText file)
               (== read_as "binaryString")
               (-> reader `readAsBinaryString file)
               (== read_as "dataURL")
               (-> reader `readAsDataURL file)))))
    {
      `description: (+ "Given a `File` object and an optional options object, reads the file "
                       "and returns the contents.  By default, the file will be read as "
                       "a `binary` type, but the mode can be specified in "
                       "the `options` object.<br><br>#### Options <br><br>read_as:string - The choices "
                       "can be `binary` , `text` , `binaryString` , or as "
                       "a `dataURL` .  <br>details:boolean - If true the details a keyed object will be "
                       "returned with the following properties:<br>`name` : which is the "
                       "filename, <br>`type` : the file type,<br>`size` : the file size "
                       "and,<br>`data` : which contains the contents of the file as read.   ")

    })



(defun control_tree (content_list control_lambda _parent)
  (cond
    (is_array? content_list)    
    (reduce (c content_list)
            (control_tree c control_lambda _parent))               
    content_list.view
    (progn
     (when control_lambda
       (control_lambda content_list _parent))
     (= _parent content_list)
     (if content_list.controls
       [ content_list (control_tree (-> content_list `controls) control_lambda _parent) ]
       content_list))
     
    (is_element? content_list)
    { view: content_list })) 

                    
(defvalue *frame_count* -1)
(defvalue *view_count* -1)

(defun control_container (content options)
  (let
      ((contained_content content)
       (resize_observer nil)
       (options (or options {}))
       (name (or options.name
                 (and options.root_frame (+ "Frame " (inc *frame_count*)))
                 (+ "view-" (inc *view_count*))))
       (id (or options.id (generate_id "container")))       
       (init_timer nil)
       (view (div { `control_id: id `class: "juno-view-container" } ))
       (initialized false)
       (init_count 0)
       (parent_view nil)
       (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                            ;(log "control_container: changing observation: parent view changed: parent now: " (get_attribute view.parentElement `id))
                            
                            (-> resize_observer `disconnect)
                            (-> resize_observer `observe view.parentElement)
                            (= parent_view view.parentElement))))
       (perform_resize (fn ()
                         (when view.parentElement
                            ;(log "control_container: performing resize: parent view is: "  (get_attribute view.parentElement `id))
                            (check_observer)
                            (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 0))
                                (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                               
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)))))
       (set_content (fn (position new_content) ;; position is discarded but it is essentially 0 since this is a single unit container
                      (let
                          ((new_view nil))
                        (= new_view
                           (cond
                             new_content.view
                             new_content.view

                             (is_element? new_content)
                             new_content
                             
                             else
                             (progn
                              (if new_content 
                                (div { } (as_lisp new_content))
                                (div { `class: "juno-empty-content" } "Set Content")))))
                        (-> view `replaceChildren new_view)
                        (if (not new_content.view)
                          (= contained_content
                             {
                              `view: view
                              })
                          (= contained_content new_content))
                        (perform_resize)
                        (when new_content.initialize
                          (-> new_content `initialize))  ;; initialize if not already
                        view)))
       (initialize (fn ()
                     (when (not initialized)
                      (when init_timer
                        (clearInterval init_timer)
                        (= init_timer nil))
                      (when (not initialized)
                        (= initialized true))
                      (when view.parentElement
                        (= parent_view view.parentElement)
                        (-> resize_observer `observe view.parentElement)
                        (perform_resize)
                        (console.log "control_container: " name ": initializing with: " contained_content)
                        (when contained_content
                          (set_content 0 contained_content))
                        (when (is_function? contained_content.initialize)
                          (-> contained_content `initialize))))))
       (destroy (fn ()
                  (progn
                   (when (is_function? contained_content.destroy)
                     (-> contained_content `destroy)))))
                        
       (intf (new Object)))
    
    (set_prop options
              `name
              name
              `id
              id)
    
    (= resize_observer (new ResizeObserver (fn ()
                                              (progn
                                                 (console.log "control_container: " name ": resize observer fired")
                                                 (perform_resize)))))
    
    (= init_timer (setInterval (fn (e)
                                   (progn
                                      (console.log "control_container: resize interval running: timer handle:" init_timer ": count: " init_count)
                                    (when view.parentElement
                                      (clearInterval init_timer)
                                      (initialize))))
                               250))
    
    
    (set_prop intf
              `view view              
              `initialize initialize              
              `set_content set_content
              `name options.name
              `resize_observer resize_observer
              `resize perform_resize
              `menu_items options.menu_item
              `initialized? (fn () initialized)
              `controls (fn () [contained_content])
              `toJSON (function ()
                                 `(control_container ,#contained_content ,#options))
              `type `control_container
              `options options)))

(defun split_view_vertical (content_a content_b options)
  (let
      ((center_width 7)
       (right_margin 5)
       (options (or options { }))
       (id (or options.id (generate_id "split_view_vertical")))
       (center_divider (div { `class: "juno-vertical-dragger"
                              `style: (+ " top: 0px; left: 50%; cursor: col-resize; height: 100%; width: " center_width "px") }))
       (left_container (div { `class: "juno-view-container" }
                            (if content_a.view
                              content_a.view
                              content_a)))
       (right_container (div { `class: "juno-view-container" }
                            (if content_b.view
                              content_b.view
                              content_b)))
       (view_overlay (div { `style: "width: 0%; height: 0%; position: absolute; top: 0px; left; 0px; background: transparent; cursor: col-resize" }))
       (view (div { `control_id: id  `class: "juno-vertical-split-container" `style: "height: calc(100% - 5px); width: 100%;" }
                  left_container
                  center_divider
                  right_container
                  view_overlay
                  ))
       (parent_view nil)
       (drag_status nil)       
       (resize_observer nil)
       (center_pos nil)
       (initialized false)
       (min_size (or options.min_size 20))
       (init_timer nil)
       (lock_ratio (function (state)
                             (when (not drag_status)
                              (if state
                                (progn
                                 (set_prop options
                                          `ratio_locked
                                          true)
                                 (= lock_ratio options.ratio))
                                (set_prop options
                                          `ratio_locked
                                          false)))))
       (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
       (saved_ratio nil)
       (set_show_second_panel (fn (state)
                                 (progn
                                    (console.log "set_show_second_panel: ->  state: " state "options.ratio: " options.ratio " saved_ratio: " saved_ratio)
                                    (set_prop options
                                       `hide_second_panel
                                       (not state))
                                    (cond
                                       state
                                       (progn
                                          (set_prop options
                                             `ratio
                                             (or saved_ratio 0.5))
                                          (= saved_ratio nil))
                                       else
                                       (progn
                                          (if options.ratio 
                                             (= saved_ratio options.ratio))
                                          (set_prop options
                                             `ratio
                                             1)))
                                    (console.log "set_show_second_panel: <-  state: " options.hide_second_panel "options.ratio: " options.ratio " saved_ratio: " saved_ratio)
                                    ;(notify (+ "split_view: show_second_panel: " state ": ratio:" options.ratio " saved: " saved_ratio))
                                    (perform_resize))))
       (perform_resize (fn ()
                         (when view.parentElement
                           (check_observer)
                           (if (isNaN (- (prop view.parentElement `offsetHeight) 5))
                             (progn
                              (console.log "split_view_vertical: cannot get parent height is NAN: " view.parentElement)
                              (setTimeout perform_resize 1000))
                             (let
                                 ((new_height (- (prop view.parentElement `offsetHeight) 5))
                                  (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               ;; get the center position - set it to the midpoint if we are just initializing
                               (when (> view.offsetWidth 0)
                                  (when (== center_pos nil)
                                     (console.log "split_view_vertical: center_pos is nil")
                                     (cond
                                        (and options.ratio
                                           (is_number? options.ratio))
                                        (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth))
                                        options.ratio
                                        (throw TypeError "Invalid ratio option: must be a number between 0 and 1")
                                        else
                                        (= center_pos (/ view.offsetWidth 2))))
                                  
                                  (when (and (== drag_status nil)
                                             (or (isNaN options.ratio)
                                                 (isNaN center_pos)))
                                     (console.log "split_view_vertical: options.ratio is NaN: " options.ratio "center_pos: " center_pos)
                                     (set_prop options
                                        `ratio
                                        0.5)
                                     (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth))
                                     (console.log "split_view_vertical: center_pos now:" center_pos))
                                  
                                  (if options.hide_second_panel
                                     (= center_pos view.offsetWidth)
                                     (progn
                                        ;(console.log "split_view: calculating center_pos:" center_pos options.ratio view.offsetWidth)
                                        (when (and (== drag_status nil)  ;; not doing a drag so we need to preserve the ratio
                                                   (is_number? options.ratio))
                                           (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth)))
                                        
                                        (if (> options.right_panel_max_size 10)
                                            (= center_pos (- new_width 20 options.right_panel_max_size))
                                            (= center_pos (Math.max (+ 20 min_size) (Math.min center_pos (- new_width 20 min_size)))))))
                                  
                                  (set_style [["width" (+ (- center_pos center_width) "px") ]]
                                             left_container)
                                  (set_style [["width" (+ "" center_width "px") ]] center_divider)
                                  (set_style [["width" (+ (- view.offsetWidth center_pos center_width right_margin) "px") ]]
                                             right_container)
                                  
                                  (when (not options.ratio_locked)
                                     (set_prop options
                                        `ratio
                                        (/ center_pos view.offsetWidth)))
                                  ;(console.log "split_view: center_pos: <- " center_pos options.ratio view.offsetWidth)
                                  ;(console.log "[" left_container.offsetWidth "<->" right_container.offsetWidth "]")
                                  ))))))
       (init_drag (fn (e)
                    (when (and (not options.ratio_locked)
                               (== drag_status nil))
                      (= drag_status 1)
                      (set_style [["width" "100%"]
                                  ["height" "100%"]] view_overlay)
                      ;; since our overlay covers the center_divider add a class to indicate activity
                      ;; on the center divider
                      (add_class "juno-active-hover" center_divider))))
       
       (complete_drag (fn (e)
                        (progn
                         (set_style [["width" "0%"]
                                     ["height" "0%"]] view_overlay)
                         (remove_class "juno-active-hover" center_divider)
                         (= drag_status nil)                         
                         (perform_resize))))
       (perform_drag (fn (e)
                       (progn
                        (-> e `preventDefault)
                        (when drag_status                          
                          (if (== e.buttons 0)
                            (complete_drag)
                            (progn
                             (= center_pos (Math.max 20 (Math.min e.offsetX (- view.offsetWidth 20))))))
                          (perform_resize)))))
       (intf {})                                                                    
       (initialize (fn ()
                     (progn
                      (when init_timer
                        (clearInterval init_timer)
                        (= init_timer nil))
                      (console.log "split_view_vertical: initialize called: " initialized) options
                      (when (not initialized)                       
                        (= initialized true)
                        (= parent_view view.parentElement)
                        (-> resize_observer `observe view.parentElement)
                        (perform_resize)
                        (console.log "split_view_vertical initialized:" initialized)
                        (when content_a.initialize
                          (-> content_a `initialize))
                        (when content_b.initialize
                          (-> content_b `initialize))))))
       (destroy (fn ()
                  (progn
                   (when (is_function? content_a.destroy)
                     (-> content_a `destroy))
                   (when (is_function? content_b.destroy)
                     (-> content_b `destroy)))))
       
       (set_right_panel_max_size (fn (val)
                                    (when (is_number? val)
                                       (set_prop options `right_panel_max_size val)
                                       (perform_resize))))
       
       (set_content (fn (position new_content)
                      (if (and position new_content
                               (or (== position 0) (== position 1)))
                        (let
                            ((target_container (if (== position 0)
                                                 left_container
                                                 right_container)))
                          (console.log "split_view_vertical: adding new content: " new_content)
                          (if (== position 0)
                            (= content_a new_content)
                            (= content_b new_content))
                          (cond
                            new_content.view ;; we have been given a control
                            (progn                             
                             (-> target_container `replaceChildren new_content.view)
                             (when new_content.initialize
                               (-> new_content `initialize)))
                            (is_element? new_content)                                                         
                            (-> target_container `replaceChildren new_content)
                            else
                            (-> target_container `replaceChildren (pre
                                                                   (JSON.stringify new_content nil 4))))
                          (perform_resize)
                          (console.log "split_view_vertical: added new content: " new_content)
                          true)
                        (throw "set_content: invalid or missing arguments")))))

    ;; set up the events
    (attach_event_listener view_overlay
                           `mousemove
                           (fn (e)
                             (progn
                              (handle_event e)
                              (when drag_status
                                (perform_drag e)))))
                             
    (attach_event_listener view_overlay
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))

    (attach_event_listener center_divider
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))
    (attach_event_listener center_divider
                           `mousedown
                           (fn (e)
                             (progn                              
                              (handle_event e)                              
                              (init_drag e))))

   

    (= resize_observer (new ResizeObserver perform_resize))
    (console.log "split_view_vertical: ready: initialized: " initialized)
    (when true ;options.auto_initialize
      (= init_timer (setInterval (fn (e)
                                   (progn
                                    (when view.parentElement
                                      (clearInterval init_timer)
                                      
                                      (= init_timer nil)
                                      (initialize))))
                                 250)))
    (set_prop options
              `ratio_locked (or options.ratio_locked false)
              `id id
              `name (or options.name
                        (+ "vertical-split-" (inc *view_count*))))
    (set_prop intf
     `view view
     `initialize initialize
     `set_content set_content
     `set_show_second_panel set_show_second_panel
     `lock_ratio lock_ratio
     `set_min_panel_size (fn (val)
                             (when (is_number? val)
                               (set_prop options `min_size val)
                               (= min_size val)
                               (perform_resize)))
     `set_right_panel_max_size set_right_panel_max_size
     `set_second_panel_max_size set_right_panel_max_size
     `options options
     `destroy destroy
     `name options.name
     `resize perform_resize
     `type `split_view_vertical
     `controls (fn () [ content_a content_b ])
     `toJSON (function ()
                       `(split_view_vertical ,#content_a ,#content_b ,#options)))
    intf)
  {
    description: (+ "The `split_view_vertical` and the `split_view_horizontal` functions "
                    "return a framing control that provides a vertical or horizontal partition "
                    "between two elements or controls.  The ratio of the left side to the right "
                    "side, or top side to the bottom side can be varied using a draggable "
                    "handle. <br><br>#### Options   <br><br>ratio_locked:boolean -When true, the "
                    "ratio between the two panels are non-adjustable and cannot be changed.  "
                    "Defaults to false.<br>ratio:number -Given a value between 0 and 1, the ratio "
                    "determines how wide or hight the first panel is relative to the second panel "
                    "(right or lower).  A ratio of 0.8 results in the first element (left or top) "
                    "being 80% of the available space, while a ratio of 0.1, result in the first "
                    "element taking 10% of the available space of the split panel total area.  "
                    "<br>name:string -The name to be given to the split view.  Note that this is "
                    "typically handled by the control itself to ensure a unique name, and so "
                    "generally doesn\'t need to be set.<br>min_size:number -The minimum size of the "
                    "first panel (left or top) that is allowed. <br>hide_second_panel: When true, "
                    "the second panel is hidden from view and the split_view looks like a "
                    "`control_container`.  This option is defaulted to false.<br><br>#### Interface "
                    "Specifics <br><br>set_second_panel_max_size:function - The maximum size that is "
                    "allowed for the second panel (right or bottom).  This is specified in pixels so "
                    "it should be provided as an integer.  By default there is no limit "
                    "applied.<br>set_min_panel_size:function - Given a number via the signature "
                    "(number) sets the minimum size of the first panel<br>set_content:function - The "
                    "set_content function takes the arguments `(position new_content)`, where "
                    "position is either 0 for first position, or 1 for second position.   The "
                    "content can wither be a control or a DOM "
                    "element.  <br>set_show_second_panel:function - Given a boolean value, if true, "
                    "which is the default, set the secondary panel to visible.  If false, the second "
                    "panel is hidden.<br><br><br><br> ")

    usage: ["content_a:Element|Object" "content_b:Element|Object" "options:object"]
    tags: [ `control `view `split `layout `panel `adjust `partition `ui `DOM]

    })
                             

(defun split_view_horizontal (content_a content_b options)
  (let
      ((center_height 7)
       (bottom_margin 5)
       (options (or options {}))
       (id (or options.id (generate_id "split_view_horizontal")))
       (center_divider (div { `class: "juno-horizontal-dragger"
                              `style: (+ "cursor: row-resize; width: 100%; height: " center_height "px") }))
       (top_container (div { `class: "juno-view-container" }
                            (if content_a.view
                              content_a.view
                              content_a)))
       (bottom_container (div { `class: "juno-view-container" }
                            (if content_b.view
                              content_b.view
                              content_b)))
       (view_overlay (div { `style: "width: 0%; height: 0%; position: absolute; top: 0px; left; 0px; background: transparent; cursor: row-resize" }))
       (view (div { `control_id: id `class: "juno-horizontal-split-container" `style: "height: calc(100% - 0px); width: 100%;margin: 0px; padding: 0px;" }
                  top_container
                  center_divider
                  bottom_container
                  view_overlay
                 ))
       (drag_status nil)
       (initialized false)
       (resize_observer nil)
       (center_pos nil)
       (last_center_pos nil)
       (initialized false)
       (init_timer nil)
       (locked_ratio nil)
       (last_set_ratio nil)
       (min_size (or options.min_panel_size 20))
       (lock_ratio (function (state)
                             (when (not drag_status)
                              (if state
                                (progn
                                 (set_prop options
                                          `ratio_locked
                                          true)
                                 (= lock_ratio options.ratio))
                                (set_prop options
                                          `ratio_locked
                                          false)))))           
       (parent_view nil)
       (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
       (saved_ratio nil)
       (set_show_second_panel (fn (state)
                                 (progn
                                    (console.log "set_show_second_panel: ->  state: " state "options.ratio: " options.ratio " saved_ratio: " saved_ratio)
                                    (set_prop options
                                       `hide_second_panel
                                       (not state))
                                    (cond
                                       state
                                       (progn
                                          (set_prop options
                                             `ratio
                                             (or saved_ratio 0.5))
                                          (= saved_ratio nil))
                                       else
                                       (progn
                                          (if options.ratio 
                                             (= saved_ratio options.ratio))
                                          (set_prop options
                                             `ratio
                                             1)))
                                    (console.log "set_show_second_panel: <-  state: " options.hide_second_panel "options.ratio: " options.ratio " saved_ratio: " saved_ratio)
                                    ;(notify (+ "split_view: show_second_panel: " state ": ratio:" options.ratio " saved: " saved_ratio))
                                    (perform_resize))))
       (perform_resize (fn ()
                         (when view.parentElement
                           (check_observer)
                           (if (isNaN (- (prop view.parentElement `offsetHeight) 5))
                             (progn
                              (console.log "split_view_horizontal: cannot get parent height is NAN: " view.parentElement)
                              (setTimeout perform_resize 1000))
                             (let
                                 ((new_height (- (prop view.parentElement `offsetHeight) 0))
                                  (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                                 
                                 (if (and center_pos
                                          (> center_pos 0)
                                          (> new_height 0))
                                     (= last_center_pos center_pos))
                                
                                 
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               ;; get the center position - set it to the midpoint if we are just initializing
                               (when (> view.offsetWidth 0)
                                  (when (== center_pos nil)
                                     (cond
                                        (and options.ratio
                                           (is_number? options.ratio))
                                        (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight))
                                        options.ratio
                                        (throw TypeError "Invalid ratio option: must be a number between 0 and 1")
                                        else
                                        (= center_pos (/ view.offsetHeight 2))))  ;; default is 50% 0.5
                                  (when (and (== drag_status nil)
                                             (not options.hide_second_panel)
                                             (or (isNaN options.ratio)
                                                 (isNaN center_pos)))
                                     (log "split_view_horizontal: options.ratio is NaN: " options.ratio "center_pos: " center_pos)
                                     (set_prop options
                                        `ratio
                                        0.5)
                                     (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight)))
                                  
                                  
                                  (if options.hide_second_panel
                                     (= center_pos view.offsetHeight)
                                     (progn
                                        (when (and (== drag_status nil)  ;; not doing a drag so we need to preserve the ratio
                                                   (is_number? options.ratio))
                                           (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight)))
                                        
                                        (when (== new_height 0)
                                           (= last_set_ratio
                                              options.ratio))
                                        
                                        (cond
                                           last_set_ratio
                                           (= center_pos (* new_height last_set_ratio))
                                           (> options.lower_panel_max_size 10)
                                           (= center_pos (- new_height 20 options.lower_panel_max_size))
                                           else
                                           (= center_pos (Math.max (+ 20 min_size) (Math.min center_pos (- new_height 20 min_size)))))))
                                  
                                  (set_style [["height" (+ "" center_pos  "px") ]]
                                             top_container)
                                  (set_style [["height" (+ "" center_height "px") ]] center_divider)
                                  (set_style [["height" (+ (- view.offsetHeight center_height center_pos 0) "px") ]]
                                             bottom_container)
                                  (set_prop top_container
                                     `scrollTop 0)
                                  (set_prop bottom_container
                                     `scrollTop 0)
                                  (set_prop view
                                     `scrollTop 0)
                                  (cond
                                     (and (not options.ratio_locked)
                                          last_set_ratio)
                                     (progn
                                        (set_prop options
                                           `ratio
                                           last_set_ratio)
                                        (= last_set_ratio nil))
                                     (not options.ratio_locked)
                                     (set_prop options
                                        `ratio
                                        (/ center_pos view.offsetHeight)))
                                  ;(console.log "[" top_container.offsetHeight "<|>" bottom_container.offsetHeight "]")
                                  ))))))
       (init_drag (fn (e)
                    (when (and (not options.ratio_locked)
                               (== drag_status nil))
                      (= drag_status 1)
                      (set_style [["width" "100%"]
                                  ["height" "100%"]] view_overlay)
                      ;; since our overlay covers the center_divider add a class to indicate activity
                      ;; on the center divider
                      (add_class "juno-active-hover" center_divider))))
       
       (complete_drag (fn (e)
                        (progn
                         (set_style [["width" "0%"]
                                     ["height" "0%"]] view_overlay)
                         (remove_class "juno-active-hover" center_divider)
                         (= drag_status nil)                         
                         (perform_resize))))
       (perform_drag (fn (e)
                       (progn
                        (-> e `preventDefault)
                        (when drag_status
                          ;(console.log "view_overlay: center_pos: " center_pos "offsetY: " e.offsetY "movementX: " e.movementY)
                          (if (== e.buttons 0)
                            (complete_drag)
                            (progn
                             (= center_pos (Math.max 20 (Math.min (- e.offsetY center_height 3) (- view.offsetHeight 40))))))
                          (perform_resize)))))
       (intf {})
       (initialize (fn ()
                     (progn
                      (when init_timer
                        (clearInterval init_timer)
                        (= init_timer nil))
                      (when (not initialized)
                        (= initialized true)
                        (= parent_view view.parentElement)
                        (-> resize_observer `observe view.parentElement)
                        (perform_resize)
                        ;(log "split_view_horizontal initialized: " initialized)
                        (when content_a.initialize
                          (-> content_a `initialize))
                        (when content_b.initialize
                          (-> content_b `initialize))))))
       (destroy (fn ()
                  (progn
                   (when (is_function? content_a.destroy)
                     (-> content_a `destroy))
                   (when (is_function? content_b.destroy)
                     (-> content_b `destroy)))))
       (set_lower_panel_max_size (fn (val)
                                 (when (is_number? val)                                   
                                   (set_prop options `lower_panel_max_size val)                                  
                                   (perform_resize))))
       (set_content (fn (position new_content)
                      (if (and position new_content
                               (or (== position 0) (== position 1)))
                        (let
                            ((target_container (if (== position 0)
                                                 top_container
                                                 bottom_container)))
                          (if (== position 0)
                            (= content_a new_content)
                            (= content_b new_content))
                          (cond
                            new_content.view ;; we have been given a control
                            (progn                             
                             (-> target_container `replaceChildren new_content.view)
                             (when new_content.initialize
                               (-> new_content `initialize)))
                            (is_element? new_content)                                                         
                            (-> target_container `replaceChildren new_content)
                            else
                            (-> target_container `replaceChildren (pre
                                                                   (JSON.stringify new_content nil 4))))
                          (perform_resize)
                          true)
                        (throw "set_content: invalid or missing arguments")))))
                          
                                                        
    ;; set up the events
    (attach_event_listener view_overlay
                           `mousemove
                           (fn (e)
                             (progn
                              (handle_event e)
                              (when drag_status
                                (perform_drag e)))))
                             
    (attach_event_listener view_overlay
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))

    (attach_event_listener center_divider
                           `mouseup
                           (fn (e)
                             (progn
                              (handle_event e)                              
                              (complete_drag))))
    (attach_event_listener center_divider
                           `mousedown
                           (fn (e)
                             (progn                              
                              (handle_event e)                              
                              (init_drag e))))
  
    (= resize_observer (new ResizeObserver perform_resize))
    (console.log "split_view_horizontal: ready: initialized: " initialized)
    (when true ;options.auto_initialize
      (= init_timer (setInterval (fn (e)
                                   (progn
                                    (when view.parentElement
                                      (clearInterval init_timer)
                                      (= init_timer nil)
                                      (initialize))))
                                 250)))
    (set_prop options
              `ratio_locked (or options.ratio_locked false)
              `id id
              `name (or options.name
                        (+ "horizontal-split-" (inc *view_count*))))
    
    (set_prop intf
     `view view
     `initialize initialize
     `options options
     `name options.name
     `resize perform_resize
     `set_min_panel_size (fn (val)
                             (when (is_number? val)
                               (set_prop options `min_size val)
                               (= min_size val)
                               (perform_resize)))
     `set_lower_panel_max_size set_lower_panel_max_size
     `set_second_panel_max_size set_lower_panel_max_size
     `set_show_second_panel set_show_second_panel
     `destroy destroy
     `type `split_view_horizontal
     `controls (fn () [ content_a content_b ])
     `toJSON (function ()
                       `(split_view_horizontal  ,#content_a ,#content_b ,#options))
     `lock_ratio lock_ratio
     `set_content (fn (position new_content)
                        (set_content position new_content)))
     
    intf)
  {
    description: (eval Environment.definitions.split_view_vertical.description)
    usage: ["content_a:Element|Object" "content_b:Element|Object" "options:object"]
    tags: [ `control `view `split `layout `panel `adjust `partition `ui `DOM] 
  })

(defun checkbox (`& args)
   (let
      ((options (if (and (is_object? args.0)
                      (not (is_element? args.0)))
                 args.0
                 {}))
       (args (if (> (length options) 0)
                 (rest args)
                 args))
       (state options.value)
       (check_input (input (+ { `type: "checkbox" }
                              (if options.value
                                 { `checked: true }
                                 {})
                              { `style: "padding: 5px; margin-right: 5px;" }
                              (if (is_object? options.checkbox)
                                  options.checkbox
                                  {}))))
       (view (label (+ {}
                       (if (is_object? options.label)
                           options.label
                        {}))
                    check_input
                    args)))
      (attach_event_listener view
         `click
         (fn (e)
            (progn
               (= state (prop check_input `checked))
               (set_prop view
                  `value
                  state))))
      (set_prop view
         `value
         state)
      view)
   {
       `description: (+ "Creates a checkbox with a label element and "
                        "returns the label element.  The state of the "
                        "check box input is set to the value property "
                        "of the label, such that when the check box input "
                        "is checked, the value will be true, otherwise "
                        "it will be false.  Event listeners can be "
                        "attached as needed.<br>Example:```"
                        "(defconst my_checkbox (checkbox { `value: true } \"Completed\"))\n"
                        "(attach_event_listener my_checkbox\n"
                        "   `click\n"
                        "   (fn (e)\n"
                        "      (log \"State: \" e.srcElement.value)))\n```"
                        "<br>"
                        "Options for the checkbox:<br>"
                        "value:boolean - If true the checkbox is checked when first "
                        "presented.<br>"
                        "label:object - If provided, will be used for the attributes of the label element.<br>"
                        "checkbox:object - If provided, will be used for the attributes of the checkbox input "
                        "element.<br>")
       `usage: ["options:?object" "label_contents:string|Element" ]
       `tags: [ "html" "ui" "DOM" "element" "node"]
   })

(defun_sync doc_exec (command_name value show_default_ui )
   (-> document `execCommand command_name 
                             (if (== show_default_ui true) true false) 
                             value)
   {
       `description: (+ "Executes document.execCommand with the arguments provided "
                        "on the DOM element currently in focus.<br>"
                        "Returns false if the command is unsupported.  The " 
                        "show_default_ui argument defaults to false.<br>" 
                        "<br>Note that browser support is officially deprecated for the "
                        "execCommand method of document.")
       `tags: ["DOM" "ui" "command" "formatting" "editing" ]
       `resources: ["https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand"]
       `usage:["command_name:string" "value:*" "show_default_ui:?boolean"]
   })
   
(defun pair_editor (pair options)
   (let
      ((pair [ pair.0 pair.1 ])
       (key_elem (input (+ { `tabindex: 0 `class: "juno-editable" }
                           (if options.placeholder_0 
                              { `placeholder: options.placeholder_0 }
                              {})
                           (if options.list_0
                              { `list: options.list_0 }
                              {})
                           (if (is_array? options.path)
                              { `path: (join "~" (conj options.path [ 0 ])) }
                              { path: "0" })
                           { value: (or pair.0 "") 
                             style: "padding: 5px; flex-grow: 1; flex-basis: 100px;" } )))
       (value_elem (input (+ { `tabindex: 0 `class: "juno-editable" }
                             (if options.placeholder_1 
                              { `placeholder: options.placeholder_1 }
                              {})
                             (if options.list_1
                                { `list: options.list_1 }
                                {})
                           (if (is_array? options.path)
                              { `path:  (join "~"  (conj options.path [ 1 ])) }
                              { path: "1" })
                           { value: (or pair.1 "") style: "padding: 5px; flex-grow: 2; flex-basis: 150px;" } )))
       (view (div { `class: "juno-editable" style: (+ "display:flex; align-items: flex-end; flex-wrap: wrap; gap: 16px;"
                                                      (if (is_string? options.style)
                                                          options.style
                                                          ""))
                           }
                  key_elem
                  value_elem
                  (if options.additional_elements
                     options.additional_elements
                     [])))
       (handler (fn (e)
                   (progn
                      (defvar edited_path (get_attribute e.srcElement "path"))
                      (if (and edited_path
                               (is_function? options.on_change))
                         (-> options `on_change (split_by "~" edited_path) e.srcElement.value))))))
      (log "pair editor: " pair)
      (attach_event_listener view
         `keyup
         handler)
      (attach_event_listener view
         `click
         handler)
      view))

(defun filter_icon (size element)
   (let
      ((view (or element (div { style: (+ "display: inline-block; width: " size)})))
       (size (or size 20))
       (svg_text 
          (prop (svg { xmlns:"http://www.w3.org/2000/svg"
                        width: (- size 6)
                        height: (- size 6)
                        viewBox:(+ "0 0 " size " " size)
                        fill:"none"
                        stroke:"currentColor"
                        stroke-width:2
                        stroke-linecap:"round"
                        stroke-linejoin:"round"
                        class:"feather feather-filter" }
        (polygon { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" })) `outerHTML)))
      (-> view `insertAdjacentHTML `beforeend svg_text)
      view))

(defun dtable (row_data options)
   (let
      ((search_input (input { `class: "juno-search" title: (or options.title (dtext "Search")) placeholder: (dtext "Search") type: `search } ))
       (filter_button (filter_icon 22 (button {  `title: (dtext "Filter Matching Rows") `style: "width: 35px; padding: 3px;"})))
       (search_results_elem (div { `style: "display: none;padding: 5px;" } "No Data Found"))
       
       (title (or options.title nil))
       (view nil)
       (search_results [])
       (tview nil)
       (set_filter_mode (fn (state)
                           (if state
                              (progn
                                 (if (-> tview `querySelector "td.juno-selected") ;; do we have any selections currently?
                                     (for_items (row (-> tview `querySelectorAll "tr"))
                                        (if (-> row `querySelector ".juno-selected")
                                           (remove_class "juno-display-none" row)
                                           (add_class "juno-display-none" row)))
                                     (for_items (row (-> tview `querySelectorAll "tr.juno-display-none"))
                                               (remove_class "juno-display-none" row)))
                                 (add_class "juno-button-on" filter_button))
                              (progn
                                 (remove_class "juno-button-on" filter_button)
                                 (for_items (row (-> tview `querySelectorAll "tr.juno-display-none"))
                                           (remove_class "juno-display-none" row))))))
                                     
       (reset_search (fn ()
                        (progn
                           (set_prop search_input `value "")
                           (for_items (elem (-> tview `querySelectorAll "td.juno-selected"))
                                (remove_class "juno-selected" elem))
                           (for_items (elem (-> tview `querySelectorAll "tr.juno-display-none"))
                                (remove_class "juno-display-none" elem)))))
       (search_handler (fn (search_data)
                          (let
                             ((found false)
                              (search_data (lowercase search_data))
                              (hide_rows (has_class? "juno-button-on" filter_button))
                              (nothing_found true))
                             (set_style [["display" "none"]] search_results_elem)
                             (if (blank? search_data)
                                (reset_search)
                                (progn
                                   (for_items (elem (-> tview `querySelectorAll "td.juno-selected"))
                                              (remove_class "juno-selected" elem))
                                   (for_items (elem (-> tview `querySelectorAll "tr"))
                                              (remove_class "juno-selected" elem))
                                   (for_items (row (or (-> tview `querySelectorAll "tr") []))
                                              (progc
                                                 ;(log "searching row: " row.tagName row.innerText row.children)
                                                 (= found false)
                                                 (for_items (col row.children)
                                                            (progc
                                                               ;(log "..searching col: " col.innerText (contains? search_data col.innerText))
                                                               (when (contains? search_data (lowercase col.innerText))
                                                                  (add_class "juno-selected" col)
                                                                  (= nothing_found false)
                                                                  (= found true))))
                                                 (if hide_rows
                                                    (if found
                                                       (remove_class "juno-display-none" row)
                                                       (add_class "juno-display-none" row)))))
                                   (when nothing_found
                                      (reset_search)
                                      (set_style [["display" "inline-block"]] search_results_elem))
                                   ))))))
                             
      (= tview
         (table { `style: (or options.table_style "width: 100%") }
                (if (is_array? options.columns)
                    (thead
                       (for_each (colheader options.columns)
                          (cond
                             (is_string? colheader)
                             (th { `style: "padding: 5px;" }  colheader)
                             (and (is_object? colheader)
                                  colheader.name)
                             (th { `style: "padding: 5px;" }  colheader.name))))
                    [])
                (tbody
                   (for_each (row (or row_data []))
                      (tr { `class: "juno-dtable" }
                          (for_each (cell row)
                             (td { `class: "juno-dtable" }
                                 cell)))))))
      (= view 
         (cond 
            options.display_search
            (div { }
                 (div { `style: "padding: 4px; display: flex;" }
                      (if (is_string? options.title)
                          (label { `style: "font-weight: bold; margin-right: 20px;margin-top: 4px;font-size: 1.1em;" } options.title)
                          [])
                      search_input filter_button search_results_elem)
                 tview)
            options.title
            (div { }
                 (div { `style: "padding: 4px; display: flex;" }
                      (if (is_string? options.title)
                          (label { `style: "font-weight: bold; margin-right: 20px;display: inline-block;" } options.title)
                          []))
                 tview)
            else
            tview))
      (attach_event_listener search_input
         `keyup
         (fn (e)
            (when (blank? search_input.value)
               (reset_search))))
      (attach_event_listener search_input
         `search
         (fn (e)
            (if (blank? search_input.value)
                (reset_search)
                (search_handler search_input.value))))
      (attach_event_listener filter_button
         `click
         (fn (e)
            (set_filter_mode (not (has_class? "juno-button-on" filter_button)))))
      (if options.controls
         {
             view:view
             search: search_handler
             reset: reset_search
             options: options
             set_filter_mode: set_filter_mode
         }
         view))
   {
     description: (+ "Given two dimensional row data in the form of nested arrays, and an "
                     "optional options object, returns a DOM structure representing the data in an "
                     "HTMLTable.<br>The row_data should be in the following form:```[[\"Betty Sue\" "
                     "80]\n [\"John Smith\" 75]\n [\"Harvey Jones\" 70]]```<br><br>where the ordered "
                     "structure is by row, then by column.<br><br>#### Options  <br><br>columns:array "
                     "-When provided, the columns array provides the table header information.  If "
                     "the column object contains an array of strings, then the values in the array "
                     "are used for the column names.  If the columns array contains objects, then "
                     "the `name` key will determine the displayed name for the "
                     "column. <br>controls:boolean  - When set to true, a control interface object is "
                     "returned, instead of a DOM Element.  The control interface will have the "
                     "following form:```{ view: DOM Element\n  search: fn(search_data)\n  reset: fn()\n "
                     "options: object\n  set_filter_mode: fn(boolean) "
                     "\n}\n```<br><br>display_search:boolean - When true, the table will present search "
                     "controls on the top, where the user can search, highlight and filter the row "
                     "data of the table.  Default is false.<br>title:string - If present the text "
                     "given in the string will be presented to the upper left of the table itself, "
                     "otherwise no title is displayed.<br><br> ")
     usage: ["row_data:array" "options:object"]
     tags: ["table" "data" "DOM" "ui" "element"]
   })

(defun tabs (tab_list options)
   (let
      ((tab_bar (ul { `class: "juno-tabs" } ))
       (content_container (div { `class: "juno-tab-content-section" } ))
       (view (div { `style: "width: 100%; overflow: hidden; height: calc(100% - 0px);" }
                  (nav { }
                       tab_bar)
                  content_container))
       (add_tab (fn (name content)
                   (progc
                      (-> tab_bar `append
                         (li { `tabindex: 0 data-tab-id: (to_key name) } name))
                      (-> content_container `append
                         (div { class: "juno-tab-content" data-tab-id: (to_key name) }
                              (cond 
                                 (is_element? content.view)
                                 content.view
                                 (is_element? content)
                                 content
                                 else
                                 "Invalid content"))))))
       (remove_tab (fn (pos)
                      (when (is_number? pos)
                         (let
                            ((tab_to_remove (prop tab_bar.children pos))
                             (content_to_remove (prop content_container.children pos))
                             (tab_active? (== pos (active_tab))))
                            
                            (when tab_to_remove
                               (-> tab_to_remove `remove))
                            (when content_to_remove
                                  (-> content_to_remove `remove))
                            (when tab_active?
                               (= pos (clamp (- pos 1) 0 (- (length tab_bar.children) 1)))
                               (activate_tab pos))
                            ))))
       (active_tab (fn ()
                      (let
                         ((idx -1))
                         (for_each (elem tab_bar.children)
                            (progn
                               (inc idx)
                               (when (has_class? "juno-tab-active" elem)
                                  (break))))
                         (if (and (< idx tab_bar.children.length)
                                  (> idx -1))
                             idx
                             nil))))
       (activate_tab_by_source (fn (elem)
                                  (let
                                     ((idx -1))
                                  (for_each (t tab_bar.children)
                                     (progn
                                        (inc idx)
                                        (when (== t elem)
                                           (activate_tab idx)))))))
       (activate_tab (fn (pos)
                        (progc
                            (when (is_number? pos)
                               (= pos (clamp pos 0 (- (length tab_bar.children) 1)))
                               (for_each (elem (-> tab_bar `querySelectorAll ".juno-tab-active"))
                                  (when (is_element? elem)
                                     (remove_class "juno-tab-active" elem)))
                               (add_class "juno-tab-active" (prop tab_bar.children pos))
                               
                               (for_each (elem (-> content_container `querySelectorAll ".juno-tab-active"))
                                  (when (is_element? elem)
                                     (remove_class "juno-tab-active" elem)))
                               (add_class "juno-tab-active" (prop content_container.children pos))))))
       (tab_headers []))
      
      (for ((tab_name content) (or tab_list []))
           (add_tab tab_name content))
      
      (activate_tab (or options.active_tab 0))
      
      (attach_event_listener tab_bar
         `click
         (fn (e)
            (activate_tab_by_source e.srcElement)))
      
      (attach_event_listener tab_bar
         `keydown
         (fn (e)
            (progn
               (when (or (== e.keyCode 32)
                         (== e.keyCode 13))
                  (activate_tab_by_source e.srcElement)))))
      
      {
         `view: view
         `add_tab: add_tab
         `activate_tab: activate_tab
         `remove_tab: remove_tab
         `active_tab: active_tab
         `tab_names: (fn ()
                           (each tab_bar.children `innerText))
      })
   {
     description: (+ "Given an array of pairs containing the name of the tab and the tabs "
                     "content, this function established a view that encapsulates the content and "
                     "displays the content associated with the active tab.  There is an interface "
                     "returned, containing control and accessor methods and a view property which is "
                     "the Element to be mounted to the DOM.<br><br>#### Options "
                     "<br><br>active_tab:number - When given a number representing the tab position, "
                     "the corresponding tab will be activated on start.  By default the first tab is "
                     "the active value.  The value 0 represents the first tab.  <br> ")
     
     })

(defun quick_alert (text display_ms)
   (if (get_default [ `application `quick_alerts `display ] )
      (let
         ((display_elem (div { `id: `quick_alert `class: "juno-centered juno-quick-alert" }
                             text))
          (existing_quick_alert (get_by_id `quick_alert))
          (display_ms (or display_ms (get_default [ `application `quick_alerts `default_display_time ] 1000 ))))
         (declare (number *quick_alert_timer*)
                  (global *quick_alert_timer*))
         
         (if (is_symbol? `*quick_alert_timer*)
             (clearTimeout *quick_alert_timer*)
             (defparameter *quick_alert_timer* nil))
         (if existing_quick_alert
              (-> existing_quick_alert `remove))
         
         (-> (get_by_id `body) `append display_elem)
         
         (= *quick_alert_timer*
            (setTimeout (fn ()
                           (aif (get_by_id `quick_alert)
                                (-> it `remove)))
                        display_ms))))
   {
     description: (+ "The `quick_alert` box takes a string and an optional display time in "
                     "milliseconds which it then uses to show a centered popup box in the middle of "
                     "the display for the specified time. <br>The display of the pop up message can "
                     "be disabled via the default in `*env_config*` under the path [ `application "
                     "`quick_alerts `display ].  The default display time of the message is set via "
                     "the path [ `application `quick_alerts `default_display_time ]. ")
     usage: ["text:string" "display_ms:?number"]
     tags: ["ui" "alert" "popup" "millis" "DOM" "display"]
   })


;; for determining keycodes
(defun get_operating_platform ()
    (if (contains? "Macintosh" navigator.userAgent)
        "mac"
        "win")
    {
        `usage: []
        `description: (+ "If the browser is running on a Macintosh system, " 
                         "will return mac, otherwise it will return win")
        `tags: ["os" "system" "platform" "architecture" "host" "navigator" ]
    })
   

(defun normalize_file_path (target_path _provided_env)
   (let
      ((env_details (if (is_object? _provided_env)
                        _provided_env
                        (aif (http/get "/base_directory")
                         (and it.rval
                            (== it.rval "OK")
                            (prop it `data)))))
       (server_base_directory env_details.base)
       (server_cwd env_details.cwd)
       (is_absolute? (fn (val)
                        (starts_with? "/" val)))
       (is_relative? (fn (val)
                        (not (is_absolute? val))))
       (clean (fn (val)
                 (reduce (v val)
                    (unless (or (blank? v)
                                (== v ".")
                                (== v ".."))
                       v))))
       (target_path (if (blank? target_path)
                        env_details.cwd
                        target_path))
       (target_comps (clean (split_by "/" target_path)))
       (base_comps (clean (split_by "/" env_details.base)))
       (cwd_comps (clean (split_by "/" env_details.cwd)))
       (common_root []))
      
      (cond
         (and (is_absolute? env_details.base)
              (is_absolute? target_path))
         (progn
            (for ((p1 p2) (pairs_from_list (interlace base_comps target_comps)))
                 (if (== p1 p2)
                     (push common_root p1)))
            (if (== common_root.length base_comps.length)
                (+ "/" (join "/" (conj common_root
                                       (slice target_comps common_root.length))))
                nil))
         (is_absolute? env_details.base)
         (progn
            (for ((p1 p2) (pairs_from_list (interlace base_comps cwd_comps)))
                 (if (== p1 p2)
                     (push common_root p1)))
            (if (== common_root.length base_comps.length)
                (+ "/" (join "/" (conj cwd_comps
                                       target_comps)))
                nil))
         (is_relative? env_details.base)
         (progn
            (+ "/" (join "/" target_comps)))
         else
         nil)))
   
(defun load (fname)
   (let
      ((path_details (normalize_file_path fname))
       (load_data nil))
      (declare (function normalize_file_path)
               (global normalize_file_path))
      (if path_details
         (progn
            (= load_data (fetch (+ "/files" path_details)))
            (if (== load_data.status 200)
                (evaluate (-> load_data `text))
                (throw EvalError "load: resource not found")))
         (throw Error "load: not able to connect to server")))
   {
     description: (+ "Given a string representing a path to a server resource will read the "
                     "file and evaluate it in the calling environment.  Note that the file path must "
                     "be expressed relative to the base directory of the server\'s /file service.  "
                     "The `load` function will prefix the `/files` service name to the given path. ")
     usage: ["pathname:string"]
     tags: ["read" "eval" "load" "import"]
   })

(defun message (text)
  (div { `style: "border-left: 5px solid darkblue; padding: 5px;" } text))

(defun error_message (text error)
  (div { `style: "border-left: 5px solid red; padding: 5px;" } 
       text 
       (if (is_error? error)
           (+ " [ " error.message " ]")
           [])))

(defun log_error (message error_instance)
  (progn
   (log (error_message message))
   (console.error message)
   (when error_instance
     (when error_instance.message
       (error_message error_instance.message))
     (console.error error_instance))))
     
(defun is_clipboard_allowed? ()
      (== "granted" (prop (-> navigator.permissions `query { name: "clipboard-write" }) `state)))

(defun attempt_undo ()
   (cond
     (is_function?  (prop *last_focus* `undo))
      (-> *last_focus* `undo)
      else
      (doc_exec `undo ))
   {
     description: (+ "This function attempts to undo the last activity by first attempting to "
                     "call the control\'s undo command, if it has one.  If it doesn\'t, it will call "
                     "`(doc_exec `undo)`.  No return value is provided. ")
     usage: [ ]
     tags: ["undo" "control" "controls" "ui"]
   })

(defun attempt_redo ()
   (cond
      (is_function?  (prop *last_focus* `redo))
      (-> *last_focus* `redo)
      else
      (doc_exec `redo ))
   {
     description: (+ "This function attempts to redo the last activity by first attempting to "
                     "call the control\'s redo command, if it has one.  If it doesn\'t, it will call "
                     "`(doc_exec `redo)`.  No return value is provided. ")
     usage: [ ]
     tags: ["undo" "control" "controls" "ui"]
   })


(defun_sync active_element ()
   document.activeElement
   {
       description: "Returns the element with active focus in the document."
       tags: [ `focus `document `ui `active `element ]
       usage: []
   })

(defun_sync in_iframe? ()
   (not (== window.location window.parent.location ))
   {
       description: "Returns true if evaluation context is in an iframe, otherwise false."
       usage: []
       tags: [ `iframe `ui `document `window `location ]
   })

(defun handle_clipboard_event (command event)
   (let
      ((current_elem (active_element))
       (control nil))
      (declare (function control_for_dom_element)
               (global control_for_dom_element))
      (if (== "HTMLInputElement" (sub_type current_elem))
          (cond
             (== command "paste")
             (progn
                (set_prop current_elem `value (-> navigator.clipboard `readText)))
             else
             (doc_exec command))
          (progn 
             (= control (control_for_dom_element current_elem))
             (unless control
                (= control *last_focus*))
             (if control
                (cond
                   (and (== command "cut")
                        (is_function? control.cut_selection))
                   (-> control `cut_selection event)
                   (and (== command "copy")
                        (is_function? control.copy_selection))
                   (-> control `copy_selection event)
                   (and (== command "paste")
                        (is_function? control.paste_selection))
                   (-> control `paste_selection event)
                   else
                   (log "Handle Clipboard Event: found control, but no handler:" command (prop control `type)))
                (notify "Unable to find paste target")))))
   {
     description: (+ "The `handle_clipboard_event` is setup in the `*initializer*` of the "
                     "application to process events pertaining to the system clipboard.   The "
                     "function handles the mechanics of copy, cut and paste depending on the target "
                     "type.  If the target is part of a control, it will route to the handler for the "
                     "control.  Otherwise, if it is an input type element it will handle directly.    "
                     "<br>The following outlines the interface methods that a control can implement.  "
                     "For each function the event will be passed as an argument, with the definition "
                     "for the receiver being: ```(fn (event))```<br><br>cut_selection:function - "
                     "Called when the cut event is received "
                     "by  `handle_clipboard_event`<br>copy_selection:function - Called when the copy "
                     "event is received by `handle_clipboard_event`  <br>paste_selection:function - "
                     "Called when the paste event is received by "
                     "the `handle_clipboard_event`  function. ")
     usage:["command:string" "event:object"]
     tags: ["events" "ui" "event" "clipboard" "cut" "copy" "paste" "DOM"]
   })



(defmacro get_selection ()
      `(-> window `getSelection))


(defun_sync get_cursor_position (element)
  (javascript | {
                  let position = 0;
                  const isSupported = typeof window.getSelection !== "undefined";
                  if (isSupported) {
                       const selection = window.getSelection();
                       if (selection.rangeCount !== 0) {
                              const range = window.getSelection().getRangeAt(0);
                              const preCaretRange = range.cloneRange();
                              preCaretRange.selectNodeContents(element);
                              preCaretRange.setEnd(range.endContainer, range.endOffset);
                              position = preCaretRange.toString().length;
                              }
                       }
                  return position;
                  } |)
  {
    description:(+ "Returns the cursor offset from 0 in the provided element. ")
    usage: ["element:Element"]
    tags: [ `element `ui `DOM `position `location `cursor ]
  })

(defun_sync get_caret_coordinates ()
   (javascript | {
                   let x = 0,
                   y = 0;
                   const isSupported = typeof window.getSelection !== "undefined";
                   if (isSupported) {
                        const selection = window.getSelection();
                        if (selection.rangeCount !== 0) {
                             const range = selection.getRangeAt(0).cloneRange();
                             range.collapse(true);
                             const rect = range.getClientRects()[0];
                             if (rect) {
                                  x = rect.left;
                                  y = rect.top;
                                  }
                             }
                        }
                   return { x, y };
                   } | )
   {
     description: (+ "Returns an object with the offsets x (for left) and y (for top) offset "
                     "of the cursor in the currently active element. ")
     tags: [ `element `ui `DOM `position `location `cursor ]
     usage: []
   })



;; verbs for our editing command language


(defun_sync get_range (selection index)
   (-> selection `getRangeAt (or index 0)))

(defmacro remove_all_ranges (selection)
   `(-> ,#selection `removeAllRanges))

(defmacro collapse_to_start (selection)
   `(-> ,#selection `collapseToStart))

(defmacro collapse_to_end (selection)
   `(-> ,#selection `collapseToEnd))



(defun_sync select_element (elem)
   (let
      ((range (-> document `createRange))
       (selection nil))
      (-> range `selectNode elem)
      (= selection (get_selection))
      (remove_all_ranges selection)
      (-> selection `addRange range)
      selection))

(defun_sync move_to_point (point_obj)
   (progc
      (when point_obj.selection
         (focus_to (if (== point_obj.pos_type 1)
                       point_obj.pos_node
                       point_obj.pos_node.parentElement))
         (defvar selection (get_selection))
         (remove_all_ranges selection)
         (-> selection `addRange point_obj.range))))

(defun move_to_point_a (point_obj)
   (progc
      (when (and point_obj.selection
                 point_obj.element)
         (set_attribute point_obj.element `contenteditable `true)
         (focus_to point_obj.element)
         (sleep 0.1)
         (select_element point_obj.element)
         (defvar selection (get_selection))
         (collapse_to_start selection)
         ;(remove_all_ranges selection)
         ;(-> selection `addRange point_obj.range)
         (if (== point_obj.pos_type 3)
             (progn
                (collapse_to_start selection)
                (for_each (idx (range point_obj.position))
                   (-> selection `modify `move `right  "character")))
             (collapse_to_start selection)))))     
   
(defun_sync move_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `move dir (or granularity "character"))))))

(defun_sync extend_from_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `extend dir (or granularity "character"))))))

(defun point_for (root_element)
   (let
      ((selection (get_selection))
       (selrange (get_range selection))
       (selected_node selrange.startContainer)
       (offset selrange.startOffset)
       (last_element nil)
       (position (progn
                    (if (== selrange.startContainer.nodeType 3)
                        (progn
                           (get_cursor_position selrange.startContainer.parentElement))
                        selrange.endOffset)))
       (current_element selected_node)
       (path []))
      (while (and (not (eq current_element nil))
                  (not (== current_element root_element)))
         (progn
            (prepend path current_element)
            (when (and (eq nil last_element)
                       (is_element? current_element))
               (= last_element current_element))
            (= current_element current_element.parentElement)))
      { dom_path: path
        position: position
        pos_type: selected_node.nodeType
        pos_node: selected_node
        element: last_element
        selection: selection
        range: selrange
        })
   {
     `description: (+ "Given a reference to a placed DOM element, returns an object " 
                      "that contains the contextual details of the current cursor position and selection."
                      "<br>#### Layout of Return Object<br>"
                      "```"
                      "{ dom_path: path\n  position: position\n  pos_type: selected_node.nodeType\n  pos_node: selected_node\n  selection: selection\n  range: selrange\n}"
                      "```")
     `usage: ["element:Element"]
     `tags: ["DOM" "UI" "editor"]
   })

(defun_sync select_node_at_point ()
   (let
      ((selection (get_selection))
       (selrange (get_range selection)))
      (if (== selrange.startContainer.nodeType 3)
         (-> selection `selectAllChildren selrange.startContainer.parentElement)
         (-> selection `selectAllChildren selrange.startContainer))))
       
      
(defun_sync get_text_around_point (point)
   (let
      ((text [])
       (elem nil))
      (progc
         (when point
            (cond 
               (== point.pos_type 1)
               (progn
                  (= elem point.pos_node))
               (== point.pos_type 3)
               (progn
                  (= elem point.pos_node.parentElement))))
         (when elem
            (push text
               (-> elem.innerText `substr 0 point.position))
            (push text
               (-> elem.innerText `substr point.position)))
         text))
   {
       description: (+ "Given a point object,returns an array that can "
                       "contain up to two strings.  The first value, at position "
                       "0, is the element text pior to the point's position. "
                       "The second value is the text of the element after "
                       "the point's position.")
       usage: ["point_object:object"]
       tags: ["DOM" "point" "edit" "selection" "editor" "select"]
   })
         
            
               
(defun_sync point_tag_path (point)
   (for_each (c point.dom_path)
      (progn
         (if (== 1 c.nodeType)
             c.tagName
             "text")))
   {
       `description: "Given a point object, returns the tag names that comprise the path to the point."
       `usage: ["point:object"]
       `tags: ["point" "editor" "DOM" "selection" "select"]
   })



(defun insert_elem_at_point (elem)
      (try
         (let
            ((selection (get_selection))
             (selrange (-> selection `getRangeAt 0))
             (parent_element (if (== selrange.startContainer.nodeType 3)  ;; text node
                                 selrange.startContainer.parentElement
                                 selrange.startContainer))
             (offset selrange.startOffset)
             (remaining_text nil))
            ;; extend it from the current point
            
            (-> selrange `setEndBefore parent_element.nextSibling)
            (= remaining_text (-> selrange `toString))
            (-> selection `deleteFromDocument)
            (= selection (get_selection))
            (remove_all_ranges selection)
            (-> selection `addRange selrange)
            (-> parent_element `append elem remaining_text)
            (collapse_to_start selection))
         (catch Error (e)
            (log (+ "ERROR: insert_elem_at_point:" e.message)))))


(defun_sync point_under_element_tag? (tag_name point)
   (contains? tag_name (point_tag_path point))
   {
       description: (+ "Returns true if the provided editor point is in a "
                        "DOM tree containing the provided tagname, otherwise false.")
       usage: ["tag_name:string" "point:object"]
       tags: ["editor" "point" "cursor" "DOM" "tree" "element"]
   })



(defmacro activity_box (options `& body_forms)
   `(let
      ((content_id (gen_id "content"))
       (content (div { `id: content_id } 
                     ""))
       (opts (or ,#options {}))
       (dialog_box (dialog opts
                           content))
       (rval nil)
       (set_content (fn (c)
                       (progn
                          (-> content `replaceChildren
                             (if (is_element? c)
                                 c
                                 (div { } c)))
                          (sleep 0.001))))
       (append_content (fn (c)
                          (progn
                             (-> content `append
                                (if (is_element? c)
                                    c
                                    (div { } c)))
                             (sleep 0.001)))))
      (declare (function alert_on_error)
               (global alert_on_error))
      (-> (get_by_id `body) `append dialog_box)
      (-> dialog_box `showModal)
      (= rval
         (alert_on_error "An Error Occured"
            ,@body_forms))
      (-> dialog_box `close)
      rval)
   {
     description: (+ "The activity_box macro sets up a modal dialog box that can show "
                      "progress messages and activity for a series of steps that are provided.  "
                      "Information can either be \'set\' or \'appended\' via the `set_content` or "
                      "`append_content` functions that are available for the forms provided to the "
                      "macro.  Once the provided forms are evaluated, the return value of the last "
                      "form is returned and dialog is closed.  <br>If an error is thrown that is "
                      "uncaught within the provided forms during the evaluation of the form sequence, "
                      "an alert box is shown with the error, and the dialog box is subsequently "
                      "closed.  The return value in this instance should be considered "
                      "undefined.<br><br>#### Content Update Functions <br><br>`set_content`:function "
                      "- Given either a string or an element, replaces the content of the displayed "
                      "dialog box with the provided content. <br>`append_content`: function - Given "
                      "either a string or a DOM Element, appends the provided content to the existing "
                      "content of the dialog box.<br><br><br>#### Options <br><br>If an options object "
                      "is provided, it is passed as the attributes for the dialog box, so it can "
                      "contain keys such as `style`, `class`, etc.  An error will likely be thrown if "
                      "the `open` attribute is set, since the macro sets up the dialog and calls the "
                      "`showModal` function.  <br><br><br>#### Examples <br>```(activity_box  { "
                      "`style:  \"width: 200px; height: 50px;\" }\n   (set_content \"Working on "
                      "it..\")\n   (sleep 1)\n   (set_content (div \"Some more "
                      "work\"))\n   (sleep 2)\n   (append_content (div \"Again..more "
                      "work!!\"))\n   (sleep 2)\n   (+ 2 2))```<br><br>Running the above example will "
                      "display a small dialog box, and demonstrate the two content setting functions "
                      "provided by the macro, returning `4` as the result.<br><br> ")
     usage: ["options:object" "body_forms:*" ]
     tags: ["modal" "dialog" "display" "ui" "DOM"]
   })

(defun_sync value_to_dom (val options _path)
  (let 
      ((classes "juno-value juno-type-")
       (options (or options {}))
       (new_opts nil)
       (make_input (function ()
                      (let
                         ((dtype (or (and path_opts
                                           (resolve_path [ `type ] path_opts))
                                      (sub_type val)))
                          (input_elem (cond
                                         (and path_opts
                                            (resolve_path [ `values ] path_opts))
                                         select
                                         else
                                         input))
                          (selections (if (== input_elem select)
                                          (for_each (`vset (resolve_path [ `values ] path_opts))
                                             (progn
                                                (if (is_array? vset)
                                                   (option (+ { `value: vset.1 } 
                                                              (if (== vset.1 val)
                                                                  { selected: true }
                                                                  {}))
                                                           vset.0)
                                                   (option 
                                                       (if (== vset val)
                                                           { selected: true }
                                                           {})
                                                       vset))))
                                          [])))
                         (declare (function input_elem))
                         (input_elem (+ (cond
                                         (== dtype "Boolean")
                                         { type: "checkbox" }
                                         (not (== (lowercase dtype) "string"))
                                         { type: dtype }
                                         else
                                         {})
                                      (if options.namespace { `ns: options.namespace } {})
                                      (if (or options.read_only
                                              (and path_opts
                                                 (resolve_path [ `read_only ] path_opts)))
                                          { `disabled: true }
                                          {})
                                      
                                      { lpath: (lpath) tabindex: 0 
                                        class: (+ classes 
                                                  (lowercase dtype)
                                                  (if options.input_class
                                                     (+ " " options.input_class)
                                                     "") ) }
                                      { `title: (lpath) }
                                      (cond 
                                         (== dtype "Boolean")
                                         (if val
                                            { checked: true }
                                            {})
                                         (== dtype "Date")
                                         { `value: (first (split_by "T" (-> val `toISOString))) }
                                         (not (blank? val))
                                         { `value: val }
                                         else
                                         {}))
                                     selections))))
       (set_displayed_value (function (elem value)
                               (progn
                                  (cond
                                     (is_date? value)
                                     (set_prop elem `value (first (split_by "T" (-> value `toISOString))))
                                     (or (== true value)
                                         (== false value))
                                     (set_prop elem `checked value)
                                     else
                                     (set_prop elem `value value)))))
                                  
                                  
       (elem nil)
       (is_root? (eq nil _path))
       (_path (or _path [] ))
       (path_opts (resolve_path (conj ["paths"] _path) options))
       (lpath (function () (join "~" _path))))
    (declare (function array_to_dom obj_to_dom function_to_dom)
             (global array_to_dom obj_to_dom function_to_dom))
    
    (if path_opts
       (progn
          ;(log "found path_opts: " (lpath) path_opts)
          (= new_opts (clone options))
          (if (and path_opts.read_only
                   (== true path_opts.read_only))
             (set_prop new_opts
                `read_only true)))
       (= new_opts options))
          
    (= elem
       (cond 
         (is_array? val)
         (progn
            (array_to_dom val new_opts _path))
         (is_element? val)
         (progn
          (if val.parentElement
            (details
             (summary (+ {} (if options.namespace
                               { ns: options.namespace }
                               {})
                         { `lpath: (lpath) 
                           `class: (+ classes "view") 
                           `tabindex:0 }) 
                      (+ (sub_type val) " "))
             (span { `tabindex: 0 `style: "font-family: var(--main-app-font)" } "[ RENDERED ELEMENT ]"))
            val))
         (and (not options.include_prototypes)
              (is_regex? val))
         (span (+ {} (if options.namespace
                         { `ns: options.namespace }
                         {})
                  { `lpath: (lpath) 
                    `tabindex: 0  
                    `class: (+ classes "regexp") }) 
               (-> val `toString))
         (and (is_date? val)
              (not options.editable)
              (not options.include_prototypes))
         (span (+ {} (if options.namespace
                         { `ns: options.namespace }
                         {})
                  { `lpath: (lpath) 
                    `tabindex: 0  
                    `class: (+ classes "date") }) 
               (try (-> val `toISOString)
                  (catch RangeError (e)
                     (-> val `toString))))
         (and (is_string? val)
              (not options.editable))
         (if (starts_with? "=:" val)
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0  `class: (+ classes "symbol") } )
                 (JSON.stringify val))
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0 `class: (+ classes "string") }) 
                 (JSON.stringify val)))
         
         (instanceof val Error)
         (details (summary { `class: (+ classes "error") } 
                           (span { `tabindex: 0 `class: (+ classes "error") `style: "margin-left: 5px; font-style: italic;" } val.name " " val.message))
          (if val.details  ;; there is a details rider on this error from the compiler, print it
              (value_to_dom val.details)
              (progn
                 (defvar tmp (pre { `tabindex: 0 `class: (+ classes "error") }))
                 (set_prop tmp `innerHTML (join "\n" (rest (split_by "\n" val.stack))))
                 tmp)))
         (is_function? val)
         (function_to_dom val options _path)
         (is_object? val)
              ;(or options.include_prototypes 
                ; (not (is_date? val))))
         (obj_to_dom val new_opts _path)
         options.editable
         (make_input)
         else
         (span  (+ {} (if options.namespace { `ns: options.namespace } {}) 
                   { `lpath: (lpath) `tabindex: 0 `class: (+ classes (lowercase (sub_type val))) }) 
               val)))
    (when (and is_root?
               options.editable
               (eq nil options.namespace))
       (attach_event_listener elem
          `change
          (fn (e)
             (let
                ((changed_lpath (get_attribute e.srcElement `lpath))
                 (changed_path (if changed_lpath 
                                   (split_by "~" changed_lpath)))
                 (dtype nil)
                 (new_val nil))
                (when changed_path
                   (= dtype
                      (cond
                         (and options.paths
                            (resolve_path (conj changed_path [`type]) options.paths))
                         (resolve_path (conj changed_path [`type]) options.paths)
                         (get_attribute e.srcElement `type)
                         (get_attribute e.srcElement `type)
                         else
                         "string"))
                   
                   (= new_val 
                      (cond
                         (== dtype "integer")
                         (parseInt e.srcElement.value)
                         (== dtype "Number")
                         (float e.srcElement.value)
                         (or (== dtype "Boolean")
                             (== dtype "checkbox"))
                         (progn
                            (if (prop e.srcElement `checked)
                                true
                                false))
                         (== dtype "Date")
                         (new Date e.srcElement.value)
                         else
                         e.srcElement.value))
                   (cond 
                      (and options 
                         (is_function? options.on_change))
                      (progn
                         (= new_val (-> options `on_change changed_path new_val))
                         (cond
                            (eq nil new_val)
                            (progn
                               (set_displayed_value e.srcElement (resolve_path changed_path val))
                               (set_prop e.srcElement `value
                                  (resolve_path changed_path val)))
                            else
                            (progn
                               (set_path changed_path val new_val)
                               (set_displayed_value e.srcElement new_val))))
                      else
                      (set_path changed_path val new_val))
                   (when options.debug
                      (notify (+ "Changed Path: " changed_lpath ": " dtype ": " new_val ))))))))
    elem)
  {
    description: (+ "The `value_to_dom` function renders an arbitrary data structure to a "
                    "DOM representation and returns a DOM ready element.  Objects and their "
                    "hierarchies are rendered recursively.  The types that naturally render to the "
                    "DOM are strings, numbers, primitive objects, arrays, RegExp instances, "
                    "functions, Dates, and Booleans.  The log_view control as part of the "
                    "visual_repl control uses this facility for output mode when in `tree` mode, "
                    "which is the default output mode.<br>Additionally if the option `editable` is "
                    "passed, the rendered object will be displayed with appropriate input fields "
                    "which the user can then use to modify the values of the rendered object.  In "
                    "edit mode, data types can be specified using the `paths` option, which allows "
                    "for limiting selection or making certain paths read only.  <br><br>#### Options "
                    "  <br><br>editable:boolean -If true, the object values will be rendered with "
                    "the HTML inputs which the user can use to edit.  Upon the `change` event, the "
                    "value of the rendered object will be changed.  <br>on_change:function -If "
                    "provided, this function is called on the change event, and is passed the path "
                    "and edited value `(path new_value)` as arguments.  If the function returns nil, "
                    "the new value isn\'t accepted and the value prior to the change is restored to "
                    "the input field.  Otherwise, the returned value from the function is used as "
                    "the new value for the object, and the corresponding input element displayed "
                    "value will be updated with the `on_change` function\'s returned "
                    "value.<br>expand_all:boolean - If true, all objects will be toggled open to "
                    "display the keys by default.  This may cause rendering times to increase for "
                    "larger values, but can be useful for UI elements and other instances where an "
                    "open presentation by default is appropriate.  The default is false for this "
                    "value.<br>disable_object_toggle:boolean - If true, presented objects are "
                    "displayed open and expanded, with no `summary` displayed, preventing a toggle.  "
                    "This is useful for UI contexts where the presented object represents a form "
                    "that is to be filled out.<br>pretty_keys:boolean - If true, object keys are "
                    "presented in a more end-user friendly format, where the `from_key` function is "
                    "used to remove underscores and provide capitalization for leading characters.  "
                    "For example, the key `output_format` would be presented as `Output Format`.  "
                    "When set to true, this option has no effect on the actual key names which are "
                    "preserved in the format they were given to render.<br>paths:object -The `paths` "
                    "value allows for more control over the display, data type and values of the "
                    "presented input elements.  The paths object is structured to match the "
                    "structure of the provided object, where the leaves of the displayed object look "
                    "for attributes in the path object at the corresponding path.<br>In the "
                    "following example, the `*env_config*` object would be displayed to the REPL "
                    "output, with corresponding input fields being displayed at the leaves of the "
                    "object.  If a parent structure is marked read only, all leaves in the "
                    "corresponding structure are read only as well:```(value_to_dom *env_config* \n  "
                    "          { `editable: true \n                `paths: {\n                  "
                    "`features: {\n                        `read_only: true\n                    }\n   "
                    "               `included_libraries: {\n                        `read_only: true\n "
                    "                   }\n                    `editor:{\n                      "
                    "`extensions_to_mode: {\n                            `read_only: true\n           "
                    "               }\n                        `default_theme: {\n                    "
                    "                    values: (get_default [ `editor `themes ])\n                                   "
                    "     }\n                    }\n                    `application: {\n              "
                    "        `global_theme: {\n                            values: (keys "
                    "*global_themes*)\n                        }\n                    }\n              "
                    "}  \n                \n              })```<br><br>The above will display the "
                    "*env_config* as a hierarchical form, with some values being completely "
                    "non-editable, either due to a parent being set to read_only, or the leaf itself "
                    "being declared read only.  Note that the `editable` flag is set to `true`.  All "
                    "paths under the `inlcuded_libraries` and `features` keys are read_only.  "
                    "Specific values for `editor.default_theme` and `application,.global_theme` are "
                    "selection types, not free form text inputs.  <br>When a value is determined to "
                    "be a non-string value, either through the value itself, or a declaration in the "
                    "paths via the `type` key, then the input field will be modified accordingly to "
                    "the type.  For example if a Date type is specified, the a Date value will be "
                    "selected.  Similar for Numbers and Booleans.  <br>The path modifiers are as "
                    "follows<br>read_only:boolean -If true, then the value will not be editable.  If "
                    "this is a containing type, such as an Object or Array, then the children within "
                    "it will be non-editable.<br>type:string -Specifies the type of value that is "
                    "placed at the path. Values can be `Date`, `Boolean`, `Number`.  Otherwise the "
                    "default value will be string, or the detected type of the value "
                    "itself.<br>values:array -If present the input element is presented as a select "
                    "box with the options being the array elements provided in the `values` key.  "
                    "The array format can either be single values, such as `[\"Choice 1\" \"Choice 2\"]` "
                    "or pairs, as in `[[\"Select Value\" nil] [\"Good\" 10] [\"Imperfect\" 5] "
                    "[\"Unacceptable\" 0]]`, where in the latter, the value placed in the target "
                    "object is the second numeric value, and the presented value is the first text "
                    "value.<br><br>### Example <br>\n\n <br>In the below example, a tester object is "
                    "established, and rendered with `value_to_dom` with an `on_change` function as "
                    "well as paths which show different presentation effects and their "
                    "impacts.  ```(defglobal tester\n   {\n     name: \"\"\n     inspect_date: nil\n   "
                    "count: 0\n     confirmed: true\n     quality: nil\n     })\n \n(value_to_dom \n "
                    "tester\n   { `editable: true\n     `debug: true\n     `on_change: (function (path "
                    "value)\n                    (progn\n                       ;(log \"on_change: \" "
                    "path value)\n                       (cond\n                          (is_string? "
                    "value)\n                          (uppercase value)\n                        "
                    "(is_number? value)\n                          (if (>= value 0)\n                 "
                    "           value\n                              nil)\n                        "
                    "else\n                          value)))\n     `paths:{\n         `count: {\n      "
                    "     type: \"Number\"\n             read_only: false\n         }\n       "
                    "`inspect_date: {\n             type: \"Date\"\n         }\n         `quality: {\n    "
                    "       `type: \"Number\"\n             `values: [ [\"Select Quality\" nil]\n         "
                    "             [\"Good\" 10 ]\n                        [\"Imperfect\" 5]\n             "
                    "         [\"Unacceptable\" 0] ]\n         }\n     }\n    })```<br> ")

    usage: ["value:*" "options:?object"]
    tags: ["UI" "DOM" "value" "element" "view"]
  }
  )

(defun_sync function_to_dom (val options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (lowercase (subtype val)))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } (-> val `toString)))))
    (assert (is_function? val))
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              (aif (fn_signature val)
                                   (if (== it.type "class")
                                     (+ "class " it.name)                                            
                                     (+ (if (== it.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " it.args)
                                        "))")))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem)
  {
    description: "See value_to_dom for documentation details."
    usage: ["value:*" "options:?object"]
    tags: ["UI" "DOM" "value" "element" "view"]
    })
    
(defun_sync remote_function_to_dom (fdesc options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (cond
                 (== fdesc.type "async")
                 "asyncfunction"
                 (== fdesc.type "sync")
                 "function"
                 else
                 fdesc.type))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } fdesc.body))))
      (assert (is_object? fdesc) "remote_function_to_dom requires an object from fn_signature")
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              
                                   (if (== ftype "class")
                                     (+ "class " fdesc.name)                                            
                                     (+ (if (== fdesc.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " fdesc.args)
                                        "))"))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem)
  {
    description: "See value_to_dom for documentation details."
    usage: ["value:*" "options:?object"]
    tags: ["UI" "DOM" "value" "element" "view"]
    })
                   
       
       
       

(defun_sync array_to_dom (arr options _path)
    (let
        ((total_len arr.length)
         (_path (or _path []))
         (lpath (function () (join "~" _path)))
         (options (or options {}))
         (expanded false)
         (expansion_mode false)
         (detail_elem nil)
         (expansion_elem nil)
         (idx -1)
         (segment_size 10)
         (new_row_elem [])
         (render_array (function ()
                           (ol { `lpath: (lpath) `start: 0 `class: "juno-type-array" } 
                             (progn 
                                (for_each (val arr)
                                    (progn
                                        (inc idx)
                                        (li { `class: "juno-array-item" } 
                                            (value_to_dom val options (conj _path [idx])))))))))
         (row_elem []))
      (assert (is_array? arr))
      (when (or (> _path.length 2)
                (> arr.length (or options.expansion_length 30)))
        (= expansion_mode true))
            
      (= detail_elem 
         (details (+ { `class: "juno-type-array" }
                      (if (and (== _path.length 0)
                              (not expansion_mode))
                      { `open: true }
                      {}))
                 (summary { `lpath: (lpath)  `tabindex: 0 }  "Array [" total_len "] ")
                 (if expansion_mode
                     (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                     (render_array))))
     (when expansion_mode
         (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_array))
                                     (= render_array nil)))))
     detail_elem)
    {
      description: "See value_to_dom for documentation details."
      usage: ["value:*" "options:?object"]
      tags: ["UI" "DOM" "value" "element" "view"]
      })

(use_quoted_initializer          
   (defglobal *obj_summary_representation*
      {
        "Date":(function (obj options)
                  (summary (+ {} (if options.namespace
                                 { `ns: options.namespace }
                                 {})
                              { `lpath: options.lpath
                                `tabindex: 0
                                `class: (+ "juno-value juno-type-regexp") })
                           (-> obj `toISOString)))
        "RegExp":(function (obj options)
                    (summary (+ {} (if options.namespace
                                   { `ns: options.namespace }
                                   {})
                                { `lpath: options.lpath
                                  `tabindex: 0
                                  `class:  (+ "juno-value juno-type-regexp") })
                             (-> obj `toString)))
        }))

(defparameter *base_object_methods*
      (object_methods (new Object)))

(defun_sync pairs_without_base_methods (obj)
   (reduce_sync (pset (pairs* obj))
      (destructuring_bind (method val)
         pset
         (if (contains? method *base_object_methods*)
             nil
             pset))))

(defun_sync show_summary_representation (obj options)
   (aif (prop *obj_summary_representation* (sub_type obj))
        (it obj options)
        (progn
           (defvar idx 0)
           (defvar obj_keys (for_each (pset (pairs_without_base_methods obj))
                               (first pset)))
              
           (summary { `lpath: options.lpath `tabindex: 0 `class: "juno-obj-to-dom" }
                    (span obj.constructor.name)
                    (div { `style: "display: inline-block;" `class: "juno-non-value"  }
                         (for_each (k obj_keys)
                            (progn
                               (when (> idx 10)
                                   (break))
                               (inc idx)
                               (if (> idx 10)
                                  (span {  `class: "juno-hint" } "...")
                                  (span {  `class: "juno-hint" `style: "color: var(--type-key-color); background: #00000010;" } k)))))))))
      

(defun trigger_cascade_open (element)
   (let
      ((initial_state 0))
      (when (and (== element.tagName "DETAILS")
                 (is_nil? (get_attribute element `open)))
         (= initial_state 1)
         (set_prop element `open true)
         (when (== element.children.1.innerText "Opening...")
             (while (== element.children.1.innerText "Opening...")
                (sleep 0.01))))
      (for_each (`c element.children)
         (trigger_cascade_open c))
      (if (== initial_state 1)
          (set_prop element `open nil))
      true)
   {
     description: (+ "When provided with a DOM Element produced by `value_to_dom`, will "
                     "traverse the tree and open any `details` elements to ensure that the contents "
                     "of the tree are fully rendered.  This is required for copying the tree as a "
                     "value, since the HTML representation may not be fully rendered. ")
     usage: ["element:Element"]
     tags: ["dom_to_value" "value" "DOM" "details" "open" "summary"]
     })

(defun_sync obj_to_dom (obj options _path)
  (let
      ((options (or options {}))
       (classes "juno-value juno-type-")
       (detail_elem nil)
       (expanded false)
       (key_style? (is_string? options.key_style))
       (value_style? (is_string? options.value_style))
       (expansion_elem nil)
       (expansion_mode false)
       (get_pairs (if options.include_prototypes
                    pairs*
                    (function (obj)
                       (reduce_sync (pset (pairs* obj))
                           (destructuring_bind (method val)
                              pset
                              (if (contains? method *base_object_methods*)
                                  nil
                                  pset))))))
       (render_table (function () 
                         (table
                            (+ {}
                               (if (is_string? options.table_style)
                                  { style: options.table_style }
                                  {}))
                            (tbody
                             (for_each (keyval (get_pairs obj))
                                       (destructuring_bind (key value)
                                                           keyval
                                                           (tr 
                                                            (td (+ {}
                                                                   (if key_style?
                                                                      { style: options.key_style }
                                                                      {})
                                                                   { `class: "juno-obj-to-dom-key" })
                                                                (if options.pretty_keys
                                                                   (from_key key)
                                                                   key))
                                                            (td (+ { `class: "juno-obj-to-dom-value" } 
                                                                   (if value_style?
                                                                      { `style: options.value_style }
                                                                      {}))
                                                                (value_to_dom value options (conj _path [ key ] ))))))))))
       (_path (or _path []))
       (lpath (function () (join "~" _path))))
    (declare (function get_pairs))
    (when (or (eq nil options.visited)
              (< _path.length 2))
           (set_prop options
                     `visited (new Set)))
    
    (if (-> options.visited `has obj)
        (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "[CIRCULAR]")
        (cond
          (and false (== (length (object_methods obj)) 0))
          (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "Object {}")
          else
          (progn
           (-> options.visited `add obj)
           (when (> _path.length -1)
              (= expansion_mode true))
           (= detail_elem 
              (details (+ {  `class: "juno-obj-to-dom" }
                          (if (== _path.length 0)
                            { `open: true }
                            {}))
                       ;(summary { `lpath: (lpath) `class: "juno-obj-to-dom" } (-> obj `toString))
                       (if options.disable_object_toggle
                          (summary { class: "juno-display-none" } )
                          (show_summary_representation obj { `lpath: (lpath) `class: "juno-obj-to-dom" }))
                       (if (and expansion_mode
                                (not options.expand_all)
                                (not options.disable_object_toggle))
                         (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                         (render_table))))
           (when expansion_mode
              (unless options.disable_object_toggle
                 (attach_event_listener detail_elem
                    `toggle
                    (fn (e)
                       (progn
                          (if (is_nil? (get_attribute e.srcElement `open))
                              (remove_class "juno-display-none" detail_elem.children.0.children.1 )
                              (add_class "juno-display-none" detail_elem.children.0.children.1 ))
                          (unless expanded
                             (= expanded true)
                             (-> expansion_elem `replaceWith (render_table))
                             (= render_table nil)))))))
          detail_elem)))))



(defun_sync is_control? (val)
  (and (is_object? val) val.type val.view val.toJSON true)
  {
    usage: "val:object"
    description: "Predicate function which returns true if the provided object tests to be a control."
    tags: ["controls" "ui" "control"]
  })

(defun_sync is_layout? (control)
   (progn
      (declare (function frame_0)
               (global frame_0))
      (and (contains? control $root_controls)
           (or (== (frame_0) control)
               (resolve_path [ `options `root_bundle ] control) false)
           true))
   {
     description: (+ "For the given control, will return true if the given control if it is "
                     "determined to be a root_bundle and part of the `$root_controls` array. "
                     "Otherwise false will be returned.")
     usage: []
     tags: [ `control `controls `layout `DOM `ui ]
   })

(defun_sync is_top_control? (control)
  (if (is_control? control)
    (contains? control $root_controls)
    false))


(defun select_all_for_control (e)
   (cond
      (and *last_focus*
         (prop *last_focus* `select_all))
      (-> *last_focus* `select_all)
      (and *last_focus*
         (prop *last_focus* `editor))
      (-> (prop *last_focus* `editor) `selectAll)
      else
      (notify (dtext "Current control doesn't have a select_all method"))))

(defun copy_text_to_clipboard (text)
        (if text
           (let ((temp (textarea { `style: "position: absolute; top: -100px; left: -200px;"  } )))
               (-> (get_by_id "body") `append temp)
               (set_prop temp
                         `value
                         text)
               (-> temp `select)
               (-> temp `setSelectionRange 0 999999)
               (-> document `execCommand "copy")
               (-> temp `remove)
               true
            )
            false)
        { `usage: ["text:string"]
          `description:"Copies the provided textual argument to the system clipboard.  It cannot copy more complex types due to security limitations of browser sandboxed code."
          `tags: ["env" "copy" "clipboard" "ui"]
        } )

(defun set_key_binding (scope name desc)
  (let
      ((target (resolve_path [ scope ] *key_bindings*))
       (key_mode (get_operating_platform)))
      (set_prop target
         name
         desc)
      (set_prop *key_bindings*.active
         (prop desc key_mode)
         (prop desc `exec)))
  {
      `description: (+ "Given a scope for the keybinding, a command name key, and a description object, "
                       "establishes the binding in the *key_bindings* and in the environment as active. "
                       "<br>The description object should contain the following keys:<br>"
                       "description:text - A human readable description of what the key binding does.<br>"
                       "exec:fn - The function to execute when the key binding occurs. Some exec entries " 
                       "can be nil if the control has an internal function for the command name.<br>"
                       "mac:text - The key sequence to use on environments running on MacOS<br>"
                       "win:text - The key sequence to use when running on Windows or Linux (or non Mac environments)<br>")
      `usage: ["scope:string" "name:string" "desc:object"]
      `tags: ["keys" "bindings" "settings" "configuration" "config" ]
                       
  })


(defun remove_key_binding (scope name)
   (if (and (is_string? scope)
              (is_string? name))
      (let
         ((target (resolve_path [ scope name ] *key_bindings*))
          (key_mode (get_operating_platform))
          (active_key (when target
                         (prop target key_mode))))
         (if target
            (progn
               (delete_prop (prop *key_bindings* scope)
                            name)
               (delete_prop *key_bindings*.active
                  active_key)
               true)
            false))
      (throw TypeError "remove_key_binding requires a scope and a name as strings"))
   {
     description: (+ "Given a scope and a key binding name (the key), removes the key binding "
                     "from the `*key_bindings*` global object.  If the scope is `global`, the effect "
                     "of the removal will be immediate.  If it is a control scope, it may not take "
                     "immediate effect because the control may have mapped the key bindings in "
                     "`*key_bindings*` to an internal representation.  This occurs in the text_editor "
                     "for example.<br> ")
     usage: ["scope:string" "name:string" "desc:object"]
      tags: ["keys" "bindings" "settings" "configuration" "config" ]
   })
          

(defun_sync get_keybinding (category command)
   (aif (resolve_path [category command] *key_bindings*)
        it
        nil)
   {
       description: (+ "Given a category, such as `editor or `global and a command name, "
                        "returns the object with the defined key binding data or nil")
       usage: ["category:string" "command:string"]
       tags: ["key" "binding" "global" "sequence"]
    })

(defun_sync to_ace_keybinding (name keybinding_object fx_to_call)
   { name: name
     bindKey: { win: keybinding_object.win mac: keybinding_object.mac }
     exec: (or fx_to_call keybinding_object.exec) }
   {
       description: (+ "Given a Juno keybinding object with an exec function or an override "
                       "function as the third argument,  returns a keybinding object in a "
                       "format that can be used with the Ace Editor.")
       usage: ["name:string" "keybinding_object:object" "fx_to_call:function"]
       tags: ["key" "binding" "Ace" "editor" "command"]
   })

(defun_sync editor_key_bindings (editor)
   (if editor
      (resolve_path [`commands `commandKeyBinding ] editor)
      nil)
   {
       `description: "Returns current key bindings for the provided ACE editor object."
       `usage: ["editor:object"]
       `tags: ["bindings" "key" "controls"]
   })



(defun edit_mode_for_extension (ext)
   (or (resolve_path [ `editor `extensions_to_mode ext ] *env_config*)
       ext)
   {
       `description: (+ "Maps a file extension (with no period as a prefix) to an editor mode using the " 
                        "*env_config*~editor~extensions_to_mode lookup object. "
                        "If the file extension is found in the lookup, it will return the value, "
                        "otherwise it will return the provided extension back unchanged.")
       `usage: ["ext:string"]
       `tags: ["extension" "files" "type" "mode" "edit" "editor" ]
   })



(defun log (`& args)
   (progn
      (apply console.log args)
      (aif (-> Environment `get_global "*system_repl*" nil)
           (progn
              (-> it `log (apply div { `style: "display: flex;" } 
                           (for_each (val args)
                              (div { `style: "padding-right: 10px" } (value_to_dom val)))))))
      nil)
   {
       `description: "Logs arguments to the console and the current *system_repl* output.  Returns nil."
       `usage: ["arg0:*" "argN:*"]
       `tags: ["log" "console" "values" "display"]
   })

(defun log_error (error_message error_instance)
   (progn
      (console.error error_message error_instance)
      (aif (-> Environment `get_global "*system_repl*" nil)
           (progn
              (-> it `log_error error_message error_instance)))
      nil)
   {
       `description: "Logs an error message and the error instance to the console and the current *system_repl* output.  Returns nil."
       `usage: ["arg0:*" "argN:*"]
       `tags: ["log" "console" "values" "display"]
   })

(defun_sync clear_log ()
   (aif (and *last_focus*
             (prop *last_focus* `clear_output)
             *last_focus*)
        (progn
           (setTimeout (fn ()
                          (-> it `clear_output))
                       5)
           nil))
   {
     `description: "Clears the REPL that is currently focused."
     `usage: []
     `tags: ["log" "console" "clear" "output" "display"]
     })

(defun_sync date_to_input_format (date)
   (if (is_date? date)
       (+ "" (-> date `getFullYear) 
          "-" 
          (-> (+ "" (+ 1 (-> date `getMonth))) `padStart 2 `0) 
          "-" 
          (-> (+ "" (-> date `getDate)) `padStart 2 `0)
          "T" 
          (-> (+ "" (-> date `getHours)) `padStart 2 `0)
          ":" 
          (-> (+ "" (-> date `getMinutes)) `padStart 2 `0))
          date)
   {
     description: (+ "Given a date object returns a string suitable for use in an input element."
                     "If the value provided isn't a date instance, then it will just return the value.")
     tags: [ "ui" "date" "time" "input" "parse" ]
     usage: ["date:Date"]
   })

(defun_sync decorative_usage (symbol_data namespace suppress_type symbol_lookup)
  (let
      ((val (if (is_string? symbol_data)
                (cond
                   (starts_with? "(" symbol_data)
                   (-> symbol_data `substr 1)
                   (starts_with? "[" symbol_data)
                   (-> symbol_data `substr 1)
                   else
                   symbol_data)
                symbol_data.name))
       (show_type (function ()
                     (span { `style: "margin-left: 15px; font-style: italic" 
                             `class: (+ "juno-type-" (lowercase (or description.type "")))
                             }
                         (cond 
                            description.macro
                            "Macro"
                            description.type
                            (if suppress_type [] 
                                description.type)))))
       (metadata (if (and (is_object? symbol_data)
                          namespace
                          (not symbol_data.require_ns))
                     [list symbol_data]
                     (if symbol_lookup
                        [(symbol_lookup (trim val))]
                        (meta_for_symbol (trim val) true))))
       
       (description (if (is_object? symbol_data)
                        symbol_data
                        (if namespace
                           (first (reduce_sync (v metadata)
                                     (when (== v.namespace namespace)
                                        v)))
                           (first (or metadata [])))))
       (view nil)
       (is_symbol_binding (if (and description.require_ns
                                   (is_array? description.initializer)
                                   (== description.initializer.0 (quote pend_load)))
                              true
                              false))
       (rval nil))
      ;(console.log "decorative_usage: metadadata: " val metadata)
      (when (and is_symbol_binding
                 (is_object? description))
       (set_prop description
          `usage
          (prop (first (reduce_sync (v metadata)
                                    (when (== v.namespace description.require_ns)
                                       v)))
                `usage)))
      ;(console.log "decorative_usage:  description: " description)
      (= rval
         (cond
            (is_array? description.usage)
            (div { `style: "display: inline-block"} "("
                 (flatten [(span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                           (for_each (arg description.usage)
                              (destructuring_bind (arg_name arg_type arg_needed)
                                 (if (is_array? arg)
                                     arg
                                     (split_by ":" arg))
                                 (= arg_type (or arg_type ""))
                                 (span { `class: (+ "juno-type-" (if (starts_with? "?" arg_type)
                                                                     (lowercase (or (chop_front arg_type) ""))
                                                                     (lowercase arg_type))
                                                    " juno-arg-name") `title: arg_type
                                                `style: (if (== arg_needed "required") "text-decoration: underline" "") } arg_name ":" arg_type)
                                 ))])
                 ")" (show_type))
            (is_string? description.fn_args)
            (div { `style: "display: inline-block"} "("
                 (span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                 (for_each (arg_name (split_by " " (chop (rest description.fn_args))))
                    (span { `class: "juno-arg-name" } arg_name))
                 ")" (show_type))
            
            else
            nil))
      rval)
  {
    `usage: ["symbol:string|object" "namespace:?string" "suppress_type:?boolean"]
    `description: (+ "Given a symbol name as a string or an object metadata value (as from describe), returns a DOM element of the usage information.  "
                     "If the usage metadata is defined for the symbol it will use that, otherwise "
                     "if the symbol is a function and has fn_args defined, that content will be returned "
                     "in a DOM element.  Used by the editor to display usage information. ")
    `tags: [ `usage `editor `formatting `help `assist ]
    })

(defun unpack_description (description options)
   (let
      ((header_size_lookup [nil h1 h2 h3 h4 h5 h6])
       (regex_list [{ name: "code"
                       regex: (new RegExp "(`[a-z A-z0-9*?_%!\\-@\\$\\(\\)]+`)" `g)
                       exec: (fn (value full_regex_result)
                                (progc
                                   (defvar rval (code {} (-> value `substr 1 (- (length value) 2))))
                                   ;(log "code: value: " (-> value `substr 1 (- (length value) 2)) "rval: "  (as_lisp (element_to_lisp rval)))
                                   rval))}
                    { name: "table" 
                      regex: (new RegExp "(^[`a-zA-Z\\(\\)0-9?_*\\-]+):([`*a-z\\(\\) A-Z0-9]+)[ ]*-[ ]*(.+)")
                      exec: (fn (match_text tbl_row)
                               (progn
                                  ;(log "table: " match_text)
                                  (if options.edit_mode
                                     [(+ tbl_row.1 ":" tbl_row.2 "-") (process_regex tbl_row.3)]
                                     (when (not (blank? match_text))
                                        (div { `style: "display: flex; align-items: flex-end; flex-wrap: wrap; gap: 16px; border-bottom: 1px solid var(--main-accent-line);" }
                                             (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.1)
                                             (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.2)
                                             (div { `style: "align-self: flex-start; padding: 5px; flex-grow: 1; flex-basis: 400px;"} (process_regex tbl_row.3))))))) }
                     { name: "header" 
                       regex: (new RegExp "^([#]{1,6})[ ]+(.+)")
                       exec: (fn (value full_regex_result)
                                (progn
                                   (defvar header_section (first full_regex_result)) ;; pull it out of the array to make it easier to work with
                                   (defvar header_tag (or (prop header_size_lookup (length (prop full_regex_result 1)))
                                                     h5))
                                   (header_tag
                                      (prop full_regex_result `2)))) }
                     { name: "link"
                       regex: (new RegExp "(\\\\b(https?|ftp|file):\\\\/\\\\/[-A-Z0-9+&@#\\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\\\/%=~_|])" `ig)
                       exec: (fn (value full_regex_match)
                                (progn
                                   ;(log "link match: " value full_regex_match)
                                   (if value
                                      (a { `_target: "_blank" `href: value }
                                         value)
                                      "BAD LINK"))) }
                     { name: "horizontal_line" 
                       regex: (new RegExp "^(---[ ]*)$" `g)
                       exec: (fn (value)
                                (progn
                                   (hr))) }
                      ])
       (pre_section nil)
       (process_regex (fn (text_section)
                         (let
                            ((results [])
                             (replacement nil)
                             (ctext text_section)
                             (idx ctext.length)
                             (overlap_key nil)
                             (overlap_struct nil)
                             (split_list [])
                             (action_list [])
                             (overlaps {})
                             (acc [])
                             (comps nil))
                            ;(log "process_regex: -> " text_section)
                            (for_each (cmd regex_list)
                               (progn
                                  (= comps (scan_str cmd.regex ctext))
                                  (for_each (comp comps)
                                     (push split_list 
                                        { comp: comp
                                          pos: comp.index
                                          length: comp.0.length
                                          cmd: cmd
                                           }))))
                            ;; now we have a list of the changes to be made to the text chunk 
                            ;(log "split_list: " split_list)
                            (for_each (r1 split_list)
                               (for_each (r2 split_list)
                                  (unless (== r1 r2)
                                      (if (> r1.length r2.length)
                                          (= overlap_struct [[r1.pos (+ r1.pos r1.length)] [r2.pos (+ r2.pos r2.length)]])
                                          (= overlap_struct [[r2.pos (+ r2.pos r2.length)] [r1.pos (+ r1.pos r1.length)]]))
                                      (unless (prop overlaps (as_lisp overlap_struct))
                                         (when (apply range_overlap? overlap_struct)
                                            (set_prop overlaps
                                               (as_lisp overlap_struct)
                                               { 
                                                 parent: (if (> r1.length r2.length)
                                                             r1
                                                             r2)
                                                 child: (if (> r1.length r2.length)
                                                             r2
                                                             r1)
                                                 }))))))
                            (= action_list (reduce (action split_list)
                                              (progn
                                                 (defvar remove false)
                                                 (for_each (v (values overlaps))
                                                    (if (and (== action.pos v.child.pos)
                                                             (== action.length v.child.length))
                                                       (= remove true)))
                                                 (unless remove
                                                    action))))
                                              
                            (= split_list (reverse (sort action_list { `key: [`pos] })))
                            (if (> split_list.length 0)
                                (progn
                                   (for_each (action split_list)
                                      (progn
                                         (defvar end_of_insert (+ action.pos action.comp.0.length)) ;; point of the ctext buffer *after* the splice
                                         (defvar diff (- idx end_of_insert))   ;; text remaining from the end of the match to the idx point(which starts at the end of the ctext segment)
                                         ;(log "*" action.pos end_of_insert idx)
                                         (push acc (-> ctext `substr  end_of_insert diff)) ;; push that into our accumulator (it will be in reverse order)
                                         (push acc (-> action.cmd `exec action.comp.0 action.comp))
                                         (= idx action.pos)))  ;; update our tail end
                                   ;; if we have any remaining text, push it in to the accumulator as it will have no edits
                                   (when (> idx 0)
                                      ;(log "idx is greater than 0: " idx (-> ctext `substr 0 idx))
                                      (push acc (-> ctext `substr 0 idx))))
                                   (push acc text_section)) ;; nothing to update
                            (reverse acc))))
       (desc (progn
                (defvar tmp (eval (or description "")))
                (cond 
                   (is_element? tmp)
                   tmp
                   (and (is_object? tmp)
                        (not (is_array? tmp))
                        (is_string? tmp.description))
                   tmp.description
                   (is_string? tmp)
                   tmp
                   else  ;; not for us
                   tmp)))
       (rr (new RegExp "<-" `g))
       (subsections [])
       (segments (if (is_string? desc)
                     (split_by "```" desc)
                     []))
       (table_section nil)
       (idx -1)
       (header_section nil)
       (header_tag nil)
       (line_splitter (or options.line_splitter "<br>"))
       (header_size_lookup [nil h1 h2 h3 h4 h5 h6]) ;; pos 0 will never be found, hence nil
       (current_seg 0)
       (total_segs (length segments)))
      (if (is_string? desc)
         (div (+ { `class: "juno-editable" }
                 (if options.edit_mode
                    { `contenteditable: true }
                    {}))
              (for_each (segment segments)
                 (progn
                    (inc idx)
                    (if (== 1 (% idx 2))
                        (pre segment)
                        (for_each (section (split_by line_splitter segment))
                           (progn
                              ;(log (hr))
                              ;(log "unpack_description: section: " section)
                              (div (process_regex section))))))))
         desc))
   {
     description: (+ "Provided a text string as a primary argument, the function will convert "
                     "the text content to a DOM element structure based on a set of default rules, or "
                     "user provided rules.  A DOM element will be returned which can be placed in the "
                     "DOM.<br><br>#### Options     <br><br>This function takes the following "
                     "options:<br>edit_mode:boolean -If true, the returned DOM element will be "
                     "editable; a `contenteditable` attribute will be placed in element "
                     "returned.<br>regex_list:array -If provided, each segment of text that is not "
                     "allocated to a `PRE` element will be evaluated by the regex rules.  When a "
                     "match is found, the associated exec function of the rule will be called with "
                     "the form `(fn (value full_regex_result))` where the `value` is the matched text "
                     "value, and the `full_regex_result` is the full returned regex structure from "
                     "the `scan_str` function.  The return value of the function, typically an "
                     "Element type will replace the matched text.    <br>line_splitter:string -If "
                     "provided the line delimiter is presumed to be the provided string.  The default "
                     "is: ```<br>```<br><br>. ")
     usage: ["text:string" "options:object"]
     tags: [ `conversion `dom `ui `markdown `conversion ]
     })

(defun format_help (meta_obj options)
   (let
      ((is_symbol_binding (if (and meta_obj.require_ns
                                   (is_array? meta_obj.initializer)
                                   (== meta_obj.initializer.0 (quote pend_load)))
                              true
                              false))
       (imported_usage (first (if is_symbol_binding
                                  (reduce  (v (meta_for_symbol meta_obj.name true))
                                     (when (== v.namespace meta_obj.require_ns)
                                        v))
                                  [])))
       (elem nil))
      
     
      (when imported_usage
         (set_prop meta_obj
            `usage
            (prop imported_usage `usage))
         (set_prop meta_obj
            `tags
            (prop imported_usage `tags)))
            
            
      (= elem
         (div { `command: (+ "" meta_obj.name)  `style: "width: calc(100% - 20px); padding-bottom: 5px;" }
              (h3 (span { `style: "color: var(--namespace-color); " } meta_obj.namespace ) "/" meta_obj.name
                  (if meta_obj.macro
                     (span { `style: "float: right; margin-right: 20px; " } "Macro")
                     (span { `title: "Type" `style: "float: right" `class: (+ "juno-type-" (lowercase meta_obj.type)) } meta_obj.type)))
              (hr { `class: "LightHR" })
              (cond
                 (and (contains? `unction meta_obj.type)
                      meta_obj.usage)
                 [(h4 "Usage")
                  (decorative_usage meta_obj meta_obj.namespace true)]
                 (contains? `unction meta_obj.type)
                 [(h4 "Arguments")
                  meta_obj.fn_args]
                 else
                 [])
              (if (or meta_obj.description
                      is_symbol_binding)
                  [(h4 "Description")
                   (if is_symbol_binding
                      (p
                         (div { } "This is a bound symbol into " (span { `style: "color: var(--namespace-color); " }  meta_obj.require_ns)
                              " to " (join " " meta_obj.requires) ".  For more information refer to the core/use_symbols macro and to " (join " " meta_obj.requires) ".")
                         (br))
                      (unpack_description meta_obj.description))]
                  [])
              
              (if meta_obj.tags
                 [(h4 "Tags")
                  (for_each (`sym meta_obj.tags)
                     (span { `tabindex: 0 `class: "juno-tag" `style: "" } sym ))]
                 [])
              
              (if meta_obj.source_name
                 [(br)
                  (h4 "Defined In")
                  (span { `tabindex: 0 class: "juno-source-location juno-shadow-on-hover" } meta_obj.source_name) ]
                 [])
              
              (if meta_obj.requires
                 [(h4 "Requires")
                  (div {  } 
                       (for_each (`sym (sort meta_obj.requires))
                          (span { `tabindex: 0 `class: (+ "juno-type-" (lowercase (or (prop (describe sym) `type) "")) " juno-requires") `style: "display: inline-block;" } sym )))]
                 [])
              (if meta_obj.externals
                 [(br)
                  (hr)
                  (h4 "External References")
                  (div {  } 
                       (for_each (`sym (sort meta_obj.externals))
                          (span { `tabindex: 0 `class: "juno-requires" `style: "display: inline-block;" } sym )))]
                 [])
              ))
      (cond
         (is_function? options.on_click)
         (attach_event_listener elem
            `click
            (fn (e)
               (-> options `on_click e))))
      elem)
   {
     `description: (+ "Render object definitions to html.  Given a path "
                      "to Environment.definitions, or the output of the "
                      "describe function, returns a DOM element.  If options "
                      "is provided, the if the value for the key 'on_click' "
                      "is a function, when the produced element is clicked "
                      "the click event will be passed to the on_click function "
                      "provided.")
     `usage: ["meta_obj:object" "options:?object"]
     `tags: [`help `? `usage `info `man `manual ]
     })


(defmacro ? (symname)
   `(let
       ((results (describe ,#(if (starts_with? "=:" symname)
                                 (-> symname `substr 2)
                                 symname) true)))
       (for_each (`meta_obj (or results []))
          (format_help meta_obj)
          ))
   {
       `description: "Given a quoted symbol as an argument, the function returns a formatted manual page for the provided symbol."
       `usage: ["name:quoted_symbol"]
       `tags:["help" "assistance" "man" "usage" "info"]
   })

(defun_sync find_last_paren (editor pos options)
   (try
      (let
         ((pos (or pos (-> editor `getCursorPosition)))
          (stream (indirect_new TokenIterator editor.session pos.row pos.column))
          (done false)
          (opts (or options {}))
          (bracket_qualifier (if (and opts
                                      (is_function? opts.bracket_qualifier))
                                 opts.bracket_qualifier
                                 (function (token)
                                    (== token.type "keyword"))))
          (depth 0)
          (t nil)
          (comps nil)
          (calc_depth (function (val)
                          (progn
                            (= comps (split_by "" val))
                            (while (> comps.length 0)
                              (progn
                                 (= t (pop comps))          
                               (cond 
                                  (or (== t ")")
                                      (== t "]")
                                      (== t "}"))
                                  (inc depth)
                                  (or (== t "(")
                                      (== t "[")
                                      (== t "{"))
                                  (dec depth)))))))
          (start nil)
          (token nil))
         (while (and (not done)
                     (not start))
            (progn
               (= token (-> stream `getCurrentToken))
               (when (bracket_qualifier token)
                  (calc_depth token.value))
               
               (if (eq token nil)
                   (progn
                      (= done true)
                      (break))
                   (progn
                      (if (and  (bracket_qualifier token)
                               (or (== token.value.0 "(")
                                   (== token.value.0 "[")
                                   (== token.value.0 "{")))
                          (progn
                             (if (<= depth 0)
                                 (progn
                                    (= start { row: (-> stream `getCurrentTokenRow)
                                                   column: (-> stream `getCurrentTokenColumn) })
                                    (= done true)
                                    (break)))))))
                       
               (= token (-> stream `stepBackward))))
         (when start
            (-> editor.session `getBracketRange start)))
      (catch Error (e)
         (progn
            (console.error e)
            nil))))


(defun current_controls (no_subcontrols from_control)
   (let
      ((ctls (uniq (flatten (control_tree (if from_control
                                              [ from_control ]
                                              $root_controls)))))
       (ids nil))
      (if no_subcontrols
         (progn
            (= ids (new Set))
            (reduce (ctl ctls)
               (progn
                  (unless (-> ids `has ctl.options.id)
                     (-> ids `add ctl.options.id)
                     ctl))))
         ctls))
   {
     `usage: ["no_subcontrols:?boolean" "from_control:?control"]
     `description: (+ "Returns an array of all controls in the control tree.  "
                      "If no_subcontrols is true, then composite type contols "
                      "made up of multiple controls will be included in the "
                      "results only as the main control.  Otherwise, the "
                      "subcontrols will also be returned. If from_control "
                      "is a provided control, only controls that are "
                      "contained by that root control will be returned.")
     `tags: ["controls" "active" "tree" "ui"]
     })

(defun controls_by_type ()
   (let
      ((clist (current_controls))
       (rval {}))
      (for_each (ctl (or clist []))
         (progn
            (when (not (prop rval ctl.type))
               (set_prop rval
                  ctl.type
                  []))
            (push (prop rval ctl.type) ctl)))
      rval)
   {
     `description: (+ "Returns an object containing keys of the different types of "
                      "instantiated controls, with the corresponding values being arrays that contain "
                      "the instances of each type. ")
     `usage: []
     `tags: [`controls `control `layout `ui `DOM ]
   })

(defun all_editor_controls ()
   (reduce (ctl (current_controls))
      (when ctl.editor
         ctl))
   {
       `description: "Returns an array all editor controls in the control_tree."
       `usage: []
       `tags: ["controls" "editors" "active" "ui"]
   })

(defun cascade_resize (top_control)
  (control_tree (or top_control $root_controls)
                (fn (control)
                  (if control.resize
                    (-> control `resize))))
  {
      `usage: ["top_control:?object"]
      `description: (+ "This function invokes the resize methodFor every control " 
                       "in the control tree or from the provided starting control "
                       "and it's child controls.")
      `tags: ["controls" "active" "resize" "ui"]
  })
    

(defun set_global_theme (theme_name options)
   (if (prop *global_themes* theme_name)
       (let
          ((head_elem (-> document `querySelector "head"))
           (existing (get_by_id "juno-css-theme"))
           (is_editor_theme? (contains? theme_name (get_default [ `editor `themes ]))))
          (if existing
               (-> existing `remove))
          (-> head_elem `append
              (style { `id: "juno-css-theme" `type: "text/css" }
               (prop *global_themes* theme_name)) )
          (set_path [ `application `global_theme ] *env_config* theme_name)
          (if (and (not options.suppress_set_sub_theme)
                     (contains? theme_name (get_default [ `editor `themes ])))
              (set_path [ `editor `default_theme ] *env_config* theme_name)
              (set_path [ `editor `default_theme ] *env_config* "juno_light")) ;; this inherits the global theme
          ;; unless we are told not to, set any controls to the theme
          (unless options.suppress_cascade
              (for_each (control (current_controls))
                        (when (is_function? control.set_theme)
                          (-> control `set_theme (if is_editor_theme?
                                                     theme_name
                                                     "juno_light")))))
          true)
       (throw ReferenceError "Invalid theme name provided"))
   { `description: (+ "Sets the global theme to the named theme.  Global themes "
                      "values are looked for in *global_themes*.  If a key is found "
                      "in that object, the theme is installed, and the *env_config* "
                      "value is updated to reflect this choice.  Additionally, if an "
                      "editor theme is found with the same name, the default editor "
                      "theme is set as well.  Editor themes are found in `*env_config*` "
                      "under `[ \"editor\" \"themes\" ]`. <br><br>"
                      "Options are as follows:<br>"
                      "suppress_set_sub_theme:boolean:false:If true, individual control "
                      "themes such as the editor theme setting will not be set as part "
                      "the global theme and will retain their existing settings and "
                      "defaults.<br>"
                      "suppress_cascade:boolean:false:If this value is true, the application "
                      "theme will change, but controls will not be told about it and will "
                      "retain their current settings as they are instantiated with.")
     `tags: ["themes" "environment" "color" "settings"]
     `usage: ["theme_name:string" "options:object"] })

(defun_sync control_name (control)
   (when control
      (prop control.options `name))
   { 
     `usage: ["control:object"]
     `description: (+ "Returns the name of the given control, or nil " 
                      "if the control or the control's name is nil")
     `tags: ["control" "name"]    `
   })

(defun_sync control_id (control)
   (when control
      (prop control.options `id))
   { 
     `usage: ["control:object"]
     `description: (+ "Returns the id of the given control, or nil " 
                      "if the control or the control's name is nil")
     `tags: ["control" "name"]    `
   })

(defun get_control_by_id (id)
  (let
      ((controls (current_controls))
       (ctrl nil))
    (for_each (`control controls)
              (when (== id (and control.options control.options.id))
                (= ctrl control)
                (break)))
    ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the control with the given identifier, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "id" "find" ]
  })

(defun get_control_by_name (name)
  (let
      ((controls (current_controls))
       (ctrl nil))
      (when (is_string? name)
         (for_each (`control controls)
            (progn
               (when (== name control.name)
                  (= ctrl control)
                  (break)))))
      ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the first control with the given name, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "name" "find" ]
  })

(defun wait_for_placement (control timeout_secs)
   (let
      ((count 0)
       (timeout (* (or timeout_secs 10) 10)))
      (while (and (not (get_control_by_id (control_id control)))
                  (< count timeout))
         (progn
            (inc count)
            (sleep 0.1)))
      (when (== count timeout)
         (throw EvalError (+ "wait_for_placement: timeout waiting for: " (control_id control)))))
   {
     description: (+ "Given a control and an optional timeout value in seconds, waits for the "
                     "control to be available to the system as determined by `get_control_by_id` .  "
                     "Once the control is found, the function will return.  If the control is not "
                     "found by the timeout seconds, an `EvalError` will be thrown with a timeout "
                     "message indicating what control id couldn\'t be placed. ")
     usage: ["control:object" "timeout_secs:?number"]
     tags: ["controls" "control" "ui" "focus" "DOM" ]
   })

(defun wait_for_display (control timeout_secs)
   (if (is_control? control)
       (let
          ((count 0)
           (timeout (* (or timeout_secs 10) 10))
           (target_layout (get_layout_for_control control)))
          (declare (function get_layout_for_control)
                   (global get_layout_for_control))
          ;; ensure we have the control in a container..
          (wait_for_placement control timeout_secs)
          (while (and (not (is_array? (path_between control.view juno_container)))
                      (< count timeout))
             (progn
                (inc count)
                (sleep 0.1)))
          (when (== count timeout)
             (throw EvalError (+ "wait_for_placement: timeout waiting for: " (control_id control))))
          true)
       (throw TypeError "wait_for_display: invalid control argument given: not a control"))
   {
     description: (+ "Given a control and an optional timeout value in seconds, waits for the "
                     "control to be displayed in the browser window.  This is determined by "
                     "the `path_between` function, which is used to calculate the path between the "
                     "control\'s view and the page container element, which is at the root of all the "
                     "controls .  If the control is not displayed by the timeout seconds, "
                     "an `EvalError` will be thrown with a timeout message indicating what control id "
                     "couldn\'t be placed. <br>If a non-control value is provided as the control "
                     "argument a `TypeError` will be thrown. ")
     usage: ["control:object" "timeout_secs:?number"]
     tags: ["controls" "control" "ui" "focus" "DOM" ]
     })

(defun select_controls (predicate_func)
  (let
      ((controls (current_controls))
       (acc [])
       (ctrl nil))
    (for_each (`control controls)
        (progn
         (when (predicate_func control)
           (push acc control))))
    acc)
  {
   `description: (+ "Given a predicate function (a function that takes a "
                    "single value and returns a true or false value), tests "
                    "control by passing the control to the predicate and if "
                    "the function returns true, the control will be "
                    "returned in the array.  The function will return all "
                    "controls which tested true.")
   `usage: ["predicate_function:function"]
   `tags: ["selection" "filter" "controls"]
   })



(defun render_control_tree (controls)
   (let
      ((cell_style "border: 1px dashed var(--main-accent-line-hover);")
       (sub_style "border-right: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);")
       (parent_style "border-left: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);"))
      (table { `style: "vertical-align: top; margin: 5px; box-shadow: 1px 1px 4px 1px #00000060; width: calc(100% - 20px);" }
        (cond
           (is_array? controls)
           (for_each (ctl controls)
              (tr { `style: (+ "vertical-align: top;" cell_style) }
               (if (is_function? ctl.controls)
                   [ (td { `control_id: ctl.options.id 
                            style: (+ ""
                                      parent_style
                                      (if (== ctl *last_focus*)
                                          "font-weight: bold; background: var(--control-focused);"
                                          ""))
                            } (or ctl.name (+ "/" ctl.type)))
                    (td { `style: sub_style } (render_control_tree (-> ctl `controls)))]
                   (td { `control_id: ctl.options.id `colspan: 2 
                         `style: (+ "" cell_style (if (== ctl *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) } 
                         (or ctl.name (+ "/" ctl.type))))))
           (is_object? controls)
           (tr { `style: "" }
            (if (is_function? controls.controls)
                [(td { `style: (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "") } controls.name)
                 (td { `control_id: controls.options.id `style: cell_style } (render_control_tree (-> controls `controls)))]
                (td { `control_id: controls.options.id `colspan: 2 
                      `style: (+ "" cell_style (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) }  
                      (or controls.name (+ "/" controls.type))))))))
   {
     usage: ["controls:array"]
     description: (+ "Renders the given controls and their children as a HTML/table " 
                     "representing the hierarchy and the control positions in the tree.")
     tags: [ "ui" "controls" "DOM" "structure" "tree" ]
     })

(defun holding_tank_controls ()
  (aif (get_control_by_name "Holding Tank")
       (reduce (ctl (-> it `controls))
          (unless ctl.options.bundled
             ctl))
       [])
  {
      usage: []
      description: "Returns an array of all controls currently stored in the control holding tank."
      tags: ["ui" "controls" "holding" "tank"]
  })


(defun_sync frame_0 ()
   (let
      ((f0 nil))
      (for_each (ctl $root_controls)
         (when (and (== ctl.type "control_container")
                    (not ctl.options.root_bundle))
            (= f0 ctl)))
      f0)
   {
     description: (+ "Frame 0 is defined as the first `control_container` type that is non "
                     "bundled in the $root_controls.  It is the default where to place things.  Non "
                     "bundled means that it doesn\'t have a `root_bundle` key and is therefore "
                     "considered an open place to put new controls.  Because layouts can come and go, "
                     "this function is a utility to help easily find the first container meeting this "
                     "criteria. This function returns the container control representing frame 0. ")
     usage: []
     tags: ["layouts" "frame" "default" "ui" "controls" "control" ]
   })

(defun get_current_layout_control ()
   (let
      ((root_ctl nil))
      (for_each (ctl $root_controls)
         (when (and ctl.options.root_frame
                  (not (== ctl.type "app_header"))
                  (not (== ctl.type "holding_tank")))
             (= root_ctl ctl)
             (break)))
      root_ctl)
   {
     description: (+ "Returns the current root frame for the layout. ")
     usage: []
     tags: ["DOM" "controls" "ui" "root" "layout" "control"]
   })

(defun get_layout_for_control (control)
   (let
      ((ctls_by_parent (controls_by_parent))
       (roots (prop controls_by_parent `root))
       (next_up (fn (ctl_name)
                   (progn
                      (for_each (pset (pairs ctls_by_parent))
                         (destructuring_bind (parent_name controls)
                            pset
                            (when layout
                               (break))
                            (assert (not (== parent_name ctl_name))
                                    "get_layout_for_control: parent_name is equal to ctl_name")
                            (cond
                               (and (== parent_name "root")
                                    (contains? ctl_name (each controls `name)))
                               (progn
                                  (= layout ctl_name)
                                  (break))
                               (contains? ctl_name (each controls `name))
                               (progn
                                  (next_up parent_name))))))))
       (layout nil))
      (declare (function controls_by_parent)
               (global controls_by_parent))
      (cond 
         (is_string? control)
         (next_up control)
         (is_control? control)
         (next_up control.name)
         else
         (throw TypeError "get_layout_for_control: invalid argument provided: must be control or string"))
      ;(log "get_layout_for_control: layout is: " layout)
      (if layout
         (get_control_by_name layout)
         nil))
   {
     description: (+ "Given either a control or name of a control, returns the layout control "
                     "or root container control (such as the holding tank) for the provided control.  "
                     "If it cannot be found, nil will be returned.<br> ")
     usage: ["control:object|string"]
     tags: ["DOM" "controls" "ui" "root" "layout" "control"]
   })

(defun current_layout_locked? ()
   (aif (get_current_layout_control)
        (prop it.options `is_locked?))
   {
     `description: (+ "If the currently displayed named layout is locked, the function will "
                      "return `true` otherwise it will return `false`.  The return value is sourced "
                      "from the current root control options `is_locked?` property. ")
     usage: []
     tags: ["DOM" "controls" "ui" "root" "layout" "control"]
   })

(defun layout_locked? (layout_control)
   (aif (and (is_layout? layout_control)
             layout_control)
        (prop it.options `is_locked?))
   {
     `description: (+ "If the provided named layout is locked, the function will "
                      "return `true` otherwise it will return `false`.  The return value is sourced "
                      "from the current root control options `is_locked?` property. ")
     usage: ["layout_control:object"]
     tags: ["DOM" "controls" "ui" "root" "layout" "control"]
   })



(defun jump_to_unlocked_layout ()
   (let
      ((current_layout (get_current_layout_control))
       (f0 nil))
      (declare (function switch_to_new_layout)
               (global switch_to_new_layout))
      (if (layout_locked? current_layout)
          (progn
             (= f0 (frame_0))
             (switch_to_new_layout (prop f0 `name))
             (sleep 0.01)
             f0)
          current_layout))
   {
     description: (+ "This function, which takes no arguments, is used to ensure that the "
                     "layout operations to be performed will take place on an unlocked layout.  If "
                     "the current layout is unlocked, it will return the current layout. If the "
                     "current layout is locked, this function will move to the display to the first "
                     "unlocked layout, which will typically be the Frame 0 layout.  It will then "
                     "return the unlocked layout.   ")
     usage: []
     tags: ["layout" "controls" "control" "layouts" "ui" "panel" "DOM" "switch"]
   })


(defun control_for_dom_element (elem)
    (let
        ((control_id nil))
       (assert (is_element? elem) "Invalid element provided")
       (= control_id (-> elem `getAttribute "control_id"))
       (aif (and control_id ;; we have a control_id, so get the control
                 (get_control_by_id control_id))
            it ;; and return it
           (cond
             (eq nil elem.parentElement)
             nil ;; at top (or cannot go up further) so return nil
              
              ;; no control found and we have a parent_element
             else
             (control_for_dom_element elem.parentElement)))))



(defun control_position (control)
    (let
       ((parent_view nil)
        (parent_control_position 0)
        (parent_control nil))
    (assert control.view "target_container isn't a control container")
    (= parent_view control.view.parentElement)
    (when parent_view
        (= parent_control (control_for_dom_element parent_view))
        (when (and parent_control
                   parent_control.controls)
           (map (fn (parental_sub_control idx)
                    (when (== parental_sub_control control)
                        (= parent_control_position idx)))
                (-> parent_control `controls))))
    (aif (and (eq parent_control nil)
              (get_control_by_name "Holding Tank"))
         (if (-> it `has_control? control)
           (= parent_control it)))
      
    {
        `child: control
        `parent: parent_control
        `child_position: parent_control_position
        `layout: (get_layout_for_control control)
    })
    {
      description: (+ "<br><br>The `control_position` function returns a description object containing "
                      "the provided control (child), the control\'s parent, and the child\'s position in "
                      "the parent control. ")
      usage: ["control:object"]
      tags: ["control" "position" "placement" "controls" "UI" "DOM"]
      })

(defun get_container_for_control (control)
    (let
        ((existing_container nil)
         (pos nil)
         (next_parent nil)
         ;; controls should be in one of these container types
         (valid_containers ["split_view_horizontal" "split_view_vertical" "control_container" ]))
      (assert (and (is_object? control)
                   control.view)
              "Invalid control received")
      (= pos (control_position control))
      
    ;; is the child control (the control passed) a container?
      (cond 
        (and pos.child
           (contains? pos.child.type valid_containers))
        (= existing_container control)
        (and pos.parent
            (contains? pos.parent.type valid_containers))
        (= existing_container pos.parent)
        pos.parent
        (progn
          (while (and pos.parent
                      (not existing_container))
             (progn
                 (= pos (control_position pos.parent))
                 (console.log "pos is now: " pos)
                 (if (and pos.parent
                          (contains? pos.parent.type valid_containers))
                     (= existing_container pos.parent))))))
       
      existing_container))



(defun top_frame (control)
  (let
      ((parent nil))
    (declare (local parent))    ;; parent is a global object - shouldn't need to declare this since it has technically already been shadowed
   (assert (is_control? control) "Invalid control provided")
   (= parent (control_position control))
   (while parent.parent
       (= parent (control_position parent.parent)))
   parent.child))

(defun parents_for_control (control)
  (if (and (is_control? control)
           control.view.parentElement)
       (progn
          (defvar parent (control_for_dom_element control.view.parentElement))
          (if (is_top_control? parent)
              [parent]
              (reduce (ctl (flatten [parent (parents_for_control parent)]))
                 ctl)))
       [nil])
  {
   `description: "Given a control, returns an array containing the parent chain, with the last being the top control."
   `usage: ["control:object"]
   `tags: [ `control `controls `position `heirarchy `path]
   })


(defparameter *focus_suppress_timer* nil)

(defun set_focus_to (target_control _controls)
   (cond 
      (and target_control
           (== *last_focus* target_control))
      (progc
         false)
      (not (is_control? target_control))
      (progn
         (notify "set_focus_to: non-control as argument - error")
         ;(log "set_focus_to: non-control as argument - error" (sub_type target_control))
         (debug)
         false)
      (and (is_control? target_control )
         (not (== (get_current_layout_control) (get_layout_for_control target_control))))
      (progn
         (log (+ "set_focus_to: " (control_name target_control) " not in layout"))
         (notify (+ "set_focus_to: " (control_name target_control) " not in layout"))
         false)
      else
      (let
         ((focused_list (query_all ".juno-focused"))
          (prior_focus *last_focus*)
          (current_layout (get_current_layout_control))
          (controls (or _controls
                        (reduce (c (current_controls))
                           (when c.on_focus
                              c)))))
         (declare (function dispatch_event)
                  (global dispatch_event))
         (if (is_control? target_control)
            (= *last_focus* target_control)
            (notify  "set_focus_to: given a non-control!" `error))
         (for_each (control controls)
            (when (and (or (eq nil target_control)
                           (not (== target_control control)))
                       (is_function? control.on_blur))
               (-> control `on_blur)))
         
         ;; remove any focus class markers
         (when (> focused_list.length 0)
            (= focused_list (map (fn (v) v) focused_list))
            (apply remove_class "juno-focused" focused_list))
         (for_each (control controls)
            (when (and (or (eq nil target_control)
                           (not (== target_control control)))
                       (is_function? control.on_blur))
               (-> control `on_blur)))
         (when (not (== prior_focus target_control))
            (when (and prior_focus
                       *app_menu_control*
                       (prop prior_focus `menu_items))
               (-> *app_menu_control* `remove_menu (or (prop prior_focus `name)
                                                       "Control"))))
         (if target_control
            (progn
                (wait_for_display target_control 4)
               ;(log "set_focus_to: target_control: on_focus: " target_control.on_focus)
               (if target_control.on_focus
                  (progn
                     (-> target_control `on_focus))
                  (focus_to target_control.view))
               (set_prop current_layout.options
                  `last_focus_id target_control.options.id)
               (setq core/$current_control *last_focus*)
               (setq *last_top_frame* (top_frame target_control))
               (when (and target_control.menu_items
                          *app_menu_control*)
                  (-> *app_menu_control* `add_menu [ (or target_control.name
                                                         "Control")
                                                    target_control.menu_items
                                                    "control_menu"]))
               (dispatch_event { command: "focus" source: target_control.options.id args: [] }))
            (progn
               true)))))

(defun controls_needing_save ()
   (reduce (c (current_controls))
      (when (and c.needs_save?
                 (-> c `needs_save?))
         c))
  { description: (+ "Examines all current controls and returns any controls who have a needs_save? "
                    "method that returns true.<br> ")
    usage: []
    tags: ["controls"
           "control"
           "save"
           "dirty"
           "editor"
           "buffer"
           "modified"]})

(defun default_focus ()
  (let
      ((found_control nil))
    (control_tree [(get_current_layout_control)]
                  (fn (control)
                      (when (and (not found_control)
                                 (is_function? control.on_focus))
                        (= found_control control))))
    (if found_control
      (progn
        (set_focus_to found_control)
        found_control)
      nil)))        

(defun get_layout_holding_cell ()
   (aif (get_by_id "layout_holding_cell")
        it
        (progn
           (-> (first (get_by_tag "body"))
               `append (div { `id: "layout_holding_cell" `style: "position: absolute; top: 3000px; left: -4000px; z-index: -10; height: 600px; width: 800px; max-width: 800px; max-height: 600px;"} ))
           (get_by_id `layout_holding_cell)))
   {
     description: (+ "Returns the layout holding cell element.  If it doesn\'t yet exist in "
                     "the DOM it will create it under the body tag and then return the newly created "
                     "layout holding cell element. ")
     usage:[]
     tags: ["DOM" "layout" "controls" "root" "ui"]
     })


(defun switch_to_new_layout (layout_name)
   (if (and (not (blank? layout_name))
            (is_string? layout_name))
       (let
          ((current_layout (get_current_layout_control))
           (current_focus_for_layout (or *last_focus* (default_focus)))
           ;; get handle to the documentation and layout - if it is in the layout being moved away from,
           ;; put the documentation control in the holding tank
           (control_to_focus_to nil)
           (page_container (get_by_id `juno_container))
           (layout_holding_cell nil)
           (found false))
          (declare (function get_layout_for_control get_current_layout_control get_layout_holding_cell dispatch_event)
                   (global get_layout_for_control get_current_layout_control get_layout_holding_cell dispatch_event))
          (console.log "switch_to_new_layout: layout_name: " layout_name)
          (= layout_holding_cell (get_layout_holding_cell))
          (set_prop (first (get_by_tag "html")) `scrollTop 0)
          (cond 
             (and current_layout
                  (== current_layout.name layout_name))
             true ;; do nothing we are already here
             current_layout
             (for_each (ctl $root_controls)
                (if (== ctl.options.name layout_name)
                    (progn
                       (control_tree current_layout
                          (fn (control)
                             (when (is_function? control.lock_ratio)
                                (-> control `lock_ratio true))))
                       (set_prop current_layout.options
                          `root_frame
                          false
                          `last_focus_id
                          (if current_focus_for_layout
                             current_focus_for_layout.options.id
                             nil))
                       
                       (if (== current_layout.view.parentElement page_container)
                           (-> current_layout.view `replaceWith ctl.view) ;; replace the old one with the new one...
                           (progn
                              (-> page_container `remove current_layout.view)
                              (-> page_container `append ctl.view)))
                       ;(remove_class "juno-display-none" ctl.view)
                       ;(add_class "juno-display-none" current_layout.view)
                       (-> layout_holding_cell `append current_layout.view) ;; and store the old one until needed
                       (set_prop ctl.options
                          `root_frame
                          true)
                       (control_tree ctl
                          (fn (control)
                             (progn
                                (when (is_function? control.lock_ratio)
                                  (-> control `lock_ratio false))
                                (when (is_function? control.on_hide)
                                   (-> control `on_hide))
                                )))
                       (-> ctl `initialize)  ;; if we need to initialize, do it
                       (= found true)
                       (sleep 0.01)
                       (cascade_resize)
                       ;(log "switch_to_new_layout: target control for focus: " ctl.options.last_focus_id)
                       (when ctl.options.last_focus_id 
                          (= control_to_focus_to (get_control_by_id ctl.options.last_focus_id)))
                       (if control_to_focus_to
                           (if (not (== ctl (get_layout_for_control control_to_focus_to)))
                               (= control_to_focus_to (default_focus)))
                           (= control_to_focus_to (default_focus)))
                       (quick_alert layout_name 750)
                       (wait_for_display control_to_focus_to 5)
                       (dispatch_event { command: "switch_layout" 
                                         source: layout_name 
                                         args: []})
                       (set_focus_to control_to_focus_to)
                       
                       (break))))
             else
             (progn
                (notify "Unable to find the currently active layout: check $root_controls")))
          found)
       (throw TypeError "switch_to_new_layout: invalid layout_name provided"))
   {
     description: (+ "Given a new layout name, replaces the current layout with the provided "
                     "named layout, if it exists.  The focus will be set to the "
                     "control that was last focused in that layout. If the operation is " 
                     "successful, the function will return true, otherwise " 
                     "it will return false. ")
     usage:["layout_name:string"]
     tags: ["layout" "DOM" "controls" "ui" "root" "layout" "control"]
     })  

(defun is_sub_control? (control)
   (let
      ((pos (control_position control)))
      (if (== pos.child.options.id 
              pos.parent.options.id)
          true
          false))
   {
       description: (+ "Given a control, returns true if the control is part of another control, " 
                       "otherwise it will return false.  This is determined by the control " 
                       "having the same ID as the parent.")
       usage: ["control:object"]
       tags: ["control" "controls" "sub" "child" "bundle" "ui" "contains"]
   })



(defun set_bundle_state (control bundle_name )
   (when (is_control? control)
      (set_prop control.options
         `bundled
         bundle_name)
      (when (is_function? control.controls)
         (for_each (`c (or (-> control `controls) []))
            (unless (is_sub_control? c)
               (set_bundle_state c bundle_name))))
      bundle_name)
   {
     `description: (+ "A control bundle is a set of controls that share a common bundle "
                      "identifier in their `options` object.  A named layout will contain controls all "
                      "having the same `bundled` value, which is the name of the layout.  The "
                      "`set_bundle_state` sets the value of the `bundled` options to the name provided "
                      "in the `bundle_name` argument for all the controls managed by the provided root "
                      "control.  <br>This function is a lower level function used to control the "
                      "current state of the displayed layout and non-displayed layouts. ")
     
     `usage: ["control:object" "bundle_name:string"]
     `tags: ["control" "layout" "root" "DOM" "ui" "layouts"]
     })

(defun unlock_layout_positions (layout_name)
   (let
      ((ctl (get_control_by_name layout_name)))
      (if ctl.options.root_bundle
         (progn
            (notify (+ (dtext "Unlocked Layout") ": " layout_name))
            (set_prop ctl.options
               `is_locked?
               false))
         nil))
   {
     description: (+ "Given a layout name, sets the `is_locked?` property of the root "
                     "container control to false.  If the named layout is found, returns the updated "
                     "options of the root container.  Otherwise nil is returned. ")
     usage: ["layout_name:string"]
     tags: ["control" "layout" "root" "DOM" "ui" "layouts"]
     })
      
(defun lock_layout_positions (layout_name)
   (let
      ((ctl (get_control_by_name layout_name)))
      (if ctl.options.root_bundle
         (progn
            (notify (+ (dtext "Locked Layout") ": " layout_name))
            (set_prop ctl.options
               `is_locked?
               true))
         (if (is_control? ctl)
             (progn
                (notify (dtext "Unnamed frames and standard controls cannot be locked."))))))
   {
     description: (+ "Given a layout name, sets the `is_locked?` property of the root "
                     "container control to true.  If the named layout is found, returns the updated "
                     "options of the root container.  Otherwise nil is returned. ")
     usage: ["layout_name:string"]
     tags: ["control" "layout" "root" "DOM" "ui" "layouts"]
     })

(defun named_layouts ()
   (reduce (ctl $root_controls)
      (if ctl.options.root_bundle
         ctl.name))
   {
       description: "Returns an array containing the names of the current named layouts"
       usage:[]
       tags: ["DOM" "controls" "ui" "root" "layout" "control" "names"]
   })

(defun available_layouts ()
   (reduce (ctl $root_controls)
                 (when (and (not (== ctl.type "app_header"))
                            (not (== ctl.type "holding_tank")))
                    ctl))
   {
     description: (+ "Returns an array containing the currently active layout controls. ")
     usage: []
     tags: ["layouts" "control" "controls" "layout" "ui" "container"]
   })

(defun make_named_layout (name root_control options)
   (let
      ((target_control (cond
                          options.unmounted_source
                          root_control
                          (and (is_control? root_control)
                               (is_top_control? root_control))
                          (first (-> root_control `controls))
                          else
                          (throw TypeError "make_named_layout must be passed a control_container type")))
       (layout_name (if (and (is_string? name)
                             (not (blank? name)))
                        (trim name)
                        (throw TypeError "make_named_layout must be a non blank name")))
       (layout_control nil)
       (id (or options.id (gen_id "container")))
       (can_hide? (fn ()   ;; link to the children to prevent them going to the holding tank individually
                     false))
       (replacement_control nil)
       (already_mounted true)
       (layout_name_key (to_key layout_name))
       (num_named_layouts (length (named_layouts)))
       (layout_number (+ 2 num_named_layouts))  ;; frame 0 is 1,
       (idx 0))
      (declare (function alert_on_error control_holding_tank empty_selection_control holding_tank_controls set_key_binding)
               (global alert_on_error control_holding_tank empty_selection_control holding_tank_controls set_key_binding))
      (alert_on_error "Error when naming the layout"    ;;setup a user alert on error
          (if (is_function? target_control.controls)
              (for_each (`c (or target_control.controls []))
                 (set_bundle_state c layout_name)))
          ;; add target_control to the new layout and remove from the old one
          (= layout_control (control_container target_control
                                               {
                                                 name: layout_name
                                                 id: id
                                                 is_locked?: true
                                                 root_bundle: layout_name
                                                 last_focus_id: (resolve_path [ `options `id ]
                                                                              (or *last_focus*
                                                                                 (default_focus)
                                                                                 {}))
                                                 }))
          (assert (is_element? layout_control.view) "Unable to create the new layout control")
          ;; if we have something in the control holding tank use it
          ;; otherwise, make a new empty temp control
          ;; give the replacement control to the current root_frame
          ;; ..before switching
          (cond
             options.unmounted_source
             nil
             (> (length (holding_tank_controls)) 0)
             (progn
                (= replacement_control (first (holding_tank_controls)))
                (-> (control_holding_tank) `remove_control replacement_control))
             else
             (= replacement_control (empty_selection_control)))
          
          (remove_key_binding `global (+ "layout_" layout_name_key))
          (set_key_binding `global (+ "layout_" layout_name_key)
                           {
                             description: (+ "Jump to layout " layout_name)
                             exec: (eval `(fn ()
                                             (switch_to_new_layout ,#layout_name)))
                             mac: (+ "Command-" layout_number)
                             win: (+ "Ctrl-" layout_number)
                             })
          
          (push $root_controls
             layout_control)
          
          (unless options.unmounted_source
             (-> root_control `set_content 0 replacement_control)
             (set_focus_to replacement_control)
             (set_path [ `options `last_focus_id ] (get_current_layout_control)  replacement_control.options.id))
                    
          ;; find the displayed
          
          (aif (switch_to_new_layout layout_control.name)
               (progn
                  it)
               (progn
                  (notify "Unable to switch to the new layout")
                  it))))
   {
     `description: (+ "<br><br>Given a name for the layout, and the root control to be used as the "
                      "basis for the layout, the function will name the layout and associate the "
                      "currently displayed controls in the root_control to be part of the layout.  The "
                      "user can then switch to and from the layout allowing for multiple different "
                      "composite views to be available of the available controls.  <br>Layouts can be "
                      "switched via the `Layout` menu or key commands tied to the path `[ \"global\" "
                      "\"layout_n\" ]` where n is a numeric value starting from 0. <br>Named layouts are "
                      "preserved across serializations.<br><br>#### Options "
                      "<br><br>unmounted_source:boolean - If provided as an option and set to true, "
                      "the provided root_control is assumed to be an unmounted control, which means "
                      "that it is not currently attached to the DOM or in the holding tank.  This "
                      "option is useful for quickly creating a new named layout with a single control "
                      "as opposed to a previously mounted control.  <br> ")

     `usage: ["name:string" "root_control:object" "options:object"]
     `tags:["DOM" "controls" "ui" "root" "layout" "control" "names" "bundle"]
     })




(defun remove_named_layout (layout_name _ctl)
   (let
      ((control (if (eq nil _ctl)
                    (get_control_by_name layout_name)
                    _ctl))
       (holding_tank (control_holding_tank))
       (layout_name_key (to_key (trim layout_name)))
       (control_idx -1))
      (declare (function  control_holding_tank)
               (global  control_holding_tank))
      ;; we have to ensure we aren't in the active layout 
      (when (eq nil _ctl)
         (when (== control (get_current_layout_control))
            (throw EvalError "cannot remove a layout when it is active")))
      (when (is_control? control)
         (cond
            control.options.can_hide_orig?
            (progn
               (set_prop control
                  `can_hide?
                  control.options.can_hide_orig?)
               (delete_prop control.options
                  `can_hide_orig?))
            else
            (delete_prop control
               `can_hide?))
         (remove_prop control.options
            `bundled))
      
      
      (when (is_function? control.controls)
         (for_each (`c (or (-> control `controls) []))
            (unless (is_sub_control? c)
               (remove_named_layout layout_name c))))
      
      ;; send the control to the holding tank unless it is the 
      ;; root container, in which we remove it from the root controls
      ;; array
      
      (if (eq nil _ctl)
          (progn  ;; remove the root layout container...
             (= control_idx
                (index_of control $root_controls))
             ;(log "remove_named_layout: root_control index: " control_idx "removing: " control "layout: " layout_name)
             (remove_key_binding `global (+ "layout_" layout_name_key))
             (if (> control_idx -1)
                 (-> $root_controls `splice control_idx 1)))
          (unless (or (-> holding_tank `has_control? control) ;; add any subcontrols to the holding tank if allowed.
                      (== control.type "split_view_vertical")
                      (== control.type "split_view_horizontal"))
             (-> holding_tank `add_control control)))
      (not (contains? layout_name (each (available_layouts) control_name))))
   {
     description: (+ "Given a name of an existing named layout,  unbundles the controls "
                     "associated with the layout and places them in the holding tank.  The named "
                     "layout container is removed.  The function by default will return true.  The "
                     "bundle to be removed must not be displayed at the time of the call to this "
                     "function.  If the named layout to be deleted is currently the displayed layout, "
                     "an Error will be thrown. ")
     usage: ["layout_name:string"]
     tags: ["DOM" "controls" "ui" "root" "layout" "control" "names" "bundle"]
   })


(defun commands_button (id)
  (button { `control_id: id
            `class: "juno-command-button"
            `title: (dtext "Commands") } "⋯"))

(defun focus_to_editor (ctl)
   (progn
      (cond
          (and ctl 
             (prop ctl `editor)
             ctl.editor.focus)  
          (progn
             (focus_to (prop ctl `editor))
             (= *last_focus* ctl))
          (and (prop *last_focus* `editor)
               (resolve_path [`editor `focus ] *last_focus*))
          (focus_to (prop *last_focus* `editor)))
      *last_focus*))



(defun swap_control (target_control new_control)
  (let
      ((tmp (new Object))
       (position_details_target nil)
       (position_details_new nil)
       (current_control_layout nil)
       (new_control_layout nil)
       (holding_tank (control_holding_tank))
       (noop false)
       (replaced_keys (new Set)))
    (assert (is_control? target_control) "Invalid control provided for old_control")
    (assert (is_control? new_control) "Invalid control provided for new_control")
    
    (= current_control_layout (get_layout_for_control target_control))
    (= new_control_layout (get_layout_for_control new_control))
    
    
    (if (and new_control_layout
             new_control.options.only_for
             (not (== new_control.options.only_for (control_name new_control_layout))))
        (progn
           (notify (+ (dtext "Cannot swap out the target control - control is only for: ") new_control.options.only_for))
           (= noop true)))
    (set_prop (first (get_by_tag "html")) `scrollTop 0)
    (if (== current_control_layout holding_tank)
        (= current_control_layout nil))
    (if (== new_control_layout holding_tank)
        (= new_control_layout nil))
    
    (if (and current_control_layout
             (layout_locked? current_control_layout))
        (progn
           (console.log "swap_control: current layout is locked: " current_control_layout)
           (console.log "swap_control: target_control: " target_control "new_control: " new_control)
           (log "swap_control: cannot swap: current_layout is locked: " current_control_layout.name (layout_locked? current_control_layout))
           (notify (dtext "Cannot swap out the current control - current layout is locked"))
           (= noop true)))
    (if (and new_control_layout
             (layout_locked? new_control_layout))
        (progn
           (console.log "swap_control: new layout is locked: "new_control_layout)
           (console.log "swap_control: target_control: " target_control "new_control: " new_control)
           (notify (dtext "Cannot swap out the target control - new control layout is locked"))
           (= noop true)))
    
    
    
    (if (== target_control new_control)
        (progn
           (set_focus_to target_control)
           (if target_control.editor
              (try 
                 (focus_to target_control.editor)
                 (catch Error (e)
                    (log_error (+ "swap_control cannot set focus to editor of " target_control.editor ": " e.message))))))
        (progn
           ;; get their position in the tree
           (= position_details_target (control_position target_control))
           (= position_details_new (control_position new_control))
           (console.log "swap_control: target: " target_control "new: " new_control)))
    
    (if (and (not noop)
             new_control_layout
             current_control_layout
             (not (== new_control_layout current_control_layout)))
        (progn
           (= noop true)
           (notify (dtext "Cannot swap controls between different layouts"))))
    ;(log "swap_control: from: " (control_name current_control_layout) (control_name target_control) "->" (control_name new_control_layout) (control_name new_control))
    
    (cond
        (or (== target_control new_control)
            noop)
        nil ;; do nothing 
        
        (== position_details_target.parent holding_tank)   ;; target is in the holding tank so take the old control out and replace with new
        (progn
            (-> holding_tank `remove_control position_details_target.child)
            (-> holding_tank `add_control position_details_new.child)
            (if position_details_new.parent.set_content ;; add the targeted control to the new_controls old location (if not in holding_tank)
              (progn
               (-> position_details_new.parent `set_content position_details_new.child_position position_details_target.child)
               (cascade_resize)
               (quick_alert (control_name new_control) 750)
               (set_focus_to position_details_target.child)
               (focus_to_editor))
                position_details_target.child))

        (and (== position_details_target.child holding_tank)   ;; target IS the holding tank so replace the holding tank with the new value and hide the holding tank
             position_details_target.parent.set_content)
        (progn
         (-> holding_tank `remove_control position_details_new.child) ;; ensure the child is removed from the holding tank (if in it)
         (-> position_details_target.parent `set_content position_details_target.child_position position_details_new.child)         
         (-> holding_tank `hide)
         (quick_alert (control_name new_control) 750)
         (cascade_resize)
         (set_focus_to position_details_new.child))
        
        (and position_details_target.parent.set_content
             position_details_new.parent.set_content)  ;; controls are both in the tree somewhere so swap their positions
        (progn
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> position_details_new.parent `set_content 
                                             position_details_new.child_position 
                                             position_details_target.child)
            (set_focus_to position_details_new.child)
            (quick_alert (control_name new_control) 750)
            (cascade_resize)
            (focus_to_editor)
            target_control)
        
        (and (== position_details_new.child holding_tank)
             (is_function? position_details_target.parent.set_content))
        (progn
           (console.log "swap_control C: new is in from holding tank")
           (-> holding_tank `add_control position_details_target.child)
         (set_prop holding_tank.options
                   `in_tree
                   true) ;; otherwise the holding tank, if not initialized, will not mount correctly and place itself somewhere in the dom after initialization
         (-> position_details_target.parent `set_content position_details_target.child_position
             position_details_new.child)
         (-> holding_tank `show)
         (cascade_resize)
         (quick_alert (control_name holding_tank) 750)
         (set_focus_to position_details_new.child)
         (focus_to_editor)
         target_control)
         
        (and (== position_details_new.parent holding_tank)   ;; new control is in the holding tank 
             (is_function? position_details_target.parent.set_content))
        (progn
           (console.log "swap_control D: new control is in the holding tank")
            (-> holding_tank `remove_control position_details_new.child.options.id)
            (-> holding_tank `add_control position_details_target.child true)
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (console.log "swap_control D: setting focus to: " position_details_new.child)
            (set_focus_to position_details_new.child)
            (quick_alert (control_name new_control) 750)
            (cascade_resize)
            
            position_details_new.child)
        
        (and (eq nil position_details_new.parent)  ;; this is a new control without a parent
             position_details_target.parent.set_content)
        (progn  ;; add to the holding tank the target and put the new in the targets old place..
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> holding_tank `add_control position_details_target.child)
            (cascade_resize)
            (quick_alert (control_name new_control) 750)
            (set_focus_to position_details_new.child)
            (focus_to_editor))
        (and (-> holding_tank `has_control? position_details_new.child)
             position_details_target.parent.set_content)
        (progn
           (console.log "swap_control F: new control is in the holding tank")
           (-> position_details_target.parent `set_content
              position_details_target.child_position
              position_details_new.child)
           ;; remove from the holding tank
           (-> holding_tank `remove_control position_details_new.child)
           (-> holding_tank `add_control position_details_target.child)
           (quick_alert (control_name new_control) 750)
           (cascade_resize)
           (set_focus_to position_details_new.child)
           (focus_to_editor))
        
        else
        (progn
            (notify "Unhandled swap condition - see console")
            (log "unhandled swap position: target: " position_details_target "new: " position_details_new)
            (console.log "unhandled swap condition: environment: *last_focus*: " *last_focus*)
            (console.log "unhandled swap condition: environment: (default_focus): " (default_focus))
            (console.log "unhandled swap condition: environment: current_layout: " (get_current_layout_control))
            nil))))                               




;; container view operation
;; given a command performs an operation on the control structure

;; definitions
;; target_control - the control that is to be impacted with a change 
;; target_control_container - the container of the target_control
;; new_control - an optional new control to be inserted into the control tree
;; options - options for the given command

(defun container_view_operation (command target_control new_control options)
   (let
      ((orig_target target_control)
       (target_control (control_for_dom_element target_control.view)) ;; ensure we have the correct handle to the impaced control since this could be a sub_control given to us
       (position_details nil) ;; the structure that holds the position details of the operation
       (holding_tank (get_control_by_name "Holding Tank"))
       (tmpview nil)
       (target_layout (get_layout_for_control target_control))
       (target_layout_locked? (layout_locked? target_layout))
       (new_control_layout (if (is_control? new_control)
                               (get_layout_for_control new_control)))
       (confirmed true)
       (new_container nil)
       (split_view_parent nil))
      
      (assert target_control "Unable to find the target control")
      (assert holding_tank "Unable to find the holding tank")
      (= position_details (control_position target_control))
      (when (> __VERBOSITY__ 0)
         (log (+ "container_view_operation: do: " command ": target:") target_layout.name target_control.name " new:" 
              (if new_control_layout
                 new_control_layout.name)
              (if new_control
                 new_control.name)))
      
      (console.log "container_view_operation: original_target: " orig_target)
      (console.log "container_view_operation: computed_target: " target_control)
      (console.log "container_view_operation: target_layout_locked? " target_layout_locked? "target_layout: " (clone target_layout))
      (console.log "container_view_operation: command: " command "position_details: " position_details "new_control: " new_control)
      (when (and (== position_details.parent nil) ;; top level control
                 (not (== position_details.child holding_tank))
                 (is_top_control? position_details.child))
         (= target_control (first (-> position_details.child `controls)))
         (= position_details (control_position target_control))
         (console.log "container_view_operation: shifted down: target_control was a top control: " position_details))
      
      (unless options.suppress_destroy_confirm
         (if (and (== command "destroy")
                  (is_function? target_control.on_destroy))
             (= confirmed (-> target_control `on_destroy))))
      
      (when (and target_layout_locked?
                 (not (== target_control.type "juno_documentation_control"))
                 (not (== new_control.type "juno_documentation_control")))
         (if (starts_with? "split" command)
             (progn
                (= target_layout (frame_0))
                (switch_to_new_layout target_layout.name)
                (= target_control (first (-> target_layout `controls)))
                (= position_details (control_position target_control)))
             (progn
                (= confirmed false)
                (console.log "container_view_operation: target layout is locked")
                (notify (dtext "Target layout is locked")))))
      
      (when (and target_control.options.only_for
                 new_control_layout
                 (not (== target_control holding_tank))
                 (not (== target_control.options.only_for (control_name new_control_layout))))
         (= confirmed false)
         (notify (dtext "The requested control cannot be used with this layout.")))
         
      (console.log "container_view_operation: confirmed: " confirmed)
      (if confirmed
          ;; if the parent structure is nil in position_details, then we are at the root
          (cond
             (or (== command "hide")
                 (and (not (resolve_path [ `options `locked ] target_control))
                      (== command "destroy")))
             (progn
                (cond
                   ;; the control is not a root control if it has a parent
                   (or (== position_details.parent.type "split_view_vertical")
                       (== position_details.parent.type "split_view_horizontal"))
                   (progn
                      ;; grab the child control to keep displaying, ie. not the one in the child_position
                      (set_prop position_details
                         `child_to_display
                         (if (== position_details.child_position 0)
                             (second (-> position_details.parent `controls))
                             (first (-> position_details.parent `controls))))
                      
                      ;; we need to know the split views parent since we are going to remove the split view
                      ;; and hoist the remaining child to display into the parent structure in place of the
                      ;; split_view - not an even swap because the existing split_view is retired
                      
                      (= split_view_parent (control_position position_details.parent))
                      (assert split_view_parent.parent.set_content "Unable to set the content of the split view parent")
                      (console.log "container_view_operation: split_view_parent: " split_view_parent)
                      (when (not (blank? split_view_parent.parent.options.root_bundle))
                         (assert (== split_view_parent.parent.type "control_container") "The split_view parent is a root_bundle but is not a control_container.  Bug!")
                         (console.log "container_view_operation: hide operation: parent of split view is a named layout: " split_view_parent.parent)
                         (console.log "container_view_operation: hide operation: content of : " split_view_parent.parent.name " will be set to " position_details.child_to_display))
                      
                      (console.log "container_view_operation: split_view_parent: " split_view_parent)
                      (console.log "container_view_operation: position_details: " position_details)
                      (when (not options.dry_run)
                         ;; elevate the child to keep to the targeted_control container's position in it's parent
                         (-> split_view_parent.parent `set_content split_view_parent.child_position position_details.child_to_display)
                         
                         ;; set the child to hide in non displayed controls
                         (cond
                            (and (== command "hide")
                                 (not (== target_control holding_tank)))
                            (-> holding_tank
                                `add_control
                                target_control)
                            (and (not (resolve_path [ `options `locked ] target_control))
                                 (== command "destroy")
                                 (is_function? target_control.destroy))
                            (progn
                               (when *app_menu_control*
                                  (-> *app_menu_control* `remove_menu target_control.options.name))
                               (-> target_control `destroy)
                               (when (== *last_focus* target_control)
                                  (== *last_focus* nil)))))
                      (cascade_resize)
                      (default_focus)
                      true)
                   (and (not (resolve_path [ `options `locked ] target_control))
                        (== position_details.parent holding_tank)
                        (== command "destroy"))
                   (progn
                      (-> holding_tank `remove_control position_details.child.options.id)
                      (when *app_menu_control*
                         (-> *app_menu_control* `remove_menu position_details.child.options.name))
                      (if (is_function? position_details.child.destroy)
                        (-> position_details.child `destroy))
                      (when (== *last_focus* target_control)
                         (== *last_focus* nil))
                      (default_focus))
                   (and (== command "destroy")
                        (resolve_path [ `options `locked ] target_control))
                   (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                   (== command "destroy")   ;; single control under the root frame so swap if possible with the holding tank
                   (progn
                       (if (> (length (holding_tank_controls)) 0)
                           (progn
                              (set_path_value target_control [`options `temporary ] target_control) ;; mark as temporary
                              (swap_control target_control (last (holding_tank_controls))))
                           (progn
                              (notify "Cannot hide a single control - try replacing."))))
                   else
                   (progn
                      (if (> (length (holding_tank_controls)) 0)
                          (swap_control target_control (last (holding_tank_controls)))
                          (notify "Cannot hide a single control - try replacing"))
                      position_details)))
             
             (== command "replace")
             (progn
                (log "container_view_operation: command is replace: swap: " target_control new_control)
                (swap_control target_control new_control)
                true)
             
             (== command "split_left")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                (set_focus_to new_control)
                true)
             (== command "split_right")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical position_details.child new_control  (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                (set_focus_to new_control)
                true)
             (== command "split_above")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                (set_focus_to new_control)
                true)
             (== command "split_below")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal  position_details.child new_control (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                (set_focus_to new_control)
                true)
             (resolve_path [ `options `locked ] target_control)
             (progn
                (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                false)
             ;; otherwise we don't know how to process the command 
             else
             (progn
                (notify (+ "container_view_operation: unknown command: " command))
                position_details))
          (progn
             false))))
  
 
(defun place_control (placement control)
   (let
      ((where_map {
                   `top: "split_above"
                   `below: "split_below"
                   `left: "split_left"
                   `right: "split_right"
                   `replace: "replace"  })
       (where (aif (prop where_map placement)
                   it
                   "split_right"))
       (rval nil)
       (target_container  (control_position (top_frame (default_focus)))))
     (when target_container.child 
       (= target_container (first (-> target_container.child `controls)))
       (= rval (container_view_operation where target_container
                                         control))
       (wait_for_display control)
       (set_focus_to control)
       rval)))
              
(defun show_control (control_to_show)
  (let
      ((current_layout (get_current_layout_control))
       (control_to_show (cond 
                          (and (is_string? control_to_show)
                               (get_control_by_name control_to_show))
                          (get_control_by_name control_to_show)
                          (and (is_string? control_to_show)
                               (get_control_by_id control_to_show))
                          (get_control_by_id control_to_show)
                          (is_control? control_to_show)
                          control_to_show))
       (target_layout (if control_to_show
                          (get_layout_for_control control_to_show)))
       (target_control nil))
      ;; cannot switch to the holding tank.
      ;; first move to the correct layout
      (cond
         (is_layout? target_control)
         (if (not (== target_control current_layout))     
             (progn
                (switch_to_new_layout target_control.name)
                (sleep 0.01)))
         (== target_layout (control_holding_tank))
         (progn 
            (= target_layout nil)
            (switch_to_new_layout (prop (frame_0) `name))
            (sleep 0.01))
             ;; go to the default layout
         (not (== target_layout current_layout))
         (progn
            (switch_to_new_layout target_layout.name)
            (sleep 0.01))
         (== target_layout current_layout)
         true ;; we are on the same layout
         else
         (throw EvalError "Fall through error on show_control: cannot determine layout for requested control"))
      
      
      ;; we should be at the right layout here - assert it if it is not in the holding tank
      (if target_layout
         (assert  (== (get_current_layout_control) (get_layout_for_control control_to_show))
                 "show_control: not able to get to the current layout for the control"))
      
      ;; now where on the correct layout..
      ;; if we have a last_focus for the layout use that 
      (if (== (get_layout_for_control *last_focus*) (get_current_layout_control))
          (= target_control *last_focus*))
      
    (cond 
       (is_layout? target_control)
       true ;; we have already done our work
       
       (and target_layout ;; not in the holding tank if target_layout is not nil
            target_control
            control_to_show)
       (progn
          (sleep 0.1)
          (set_focus_to control_to_show)
          true)
       
       (and target_control control_to_show)
       (progn
          (swap_control target_control control_to_show)
          (set_focus_to control_to_show)
          (sleep 0.1)
          
          true)
       control_to_show
       (progn
          (place_control "right" control_to_show)
          (sleep 0.1)
          (set_focus_to control_to_show)
          true)
       else
       (progn 
          (notify (dtext "The requested control to display wasn't found."))
          false)))
  {
    `description: (+ "Provided a control name, id or the control object itself, will display "
                     "the control, adjusting the layout as needed. By default the control referenced "
                     "by *last_focus* is swapped with the new one, but if that isn\'t possible, the "
                     "view is split and the new control is placed to the right.<br>Returns true if "
                     "successful, otherwise a notification is delivered that the control is not "
                     "found, and false is returned. ")
    `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
    `usage: ["target:string|object"]
    })



(defun hide_control (target destroy? no_mod_layout)
   (let
      ((control (cond 
                   (and (is_string? target)
                        (get_control_by_name target))
                   (get_control_by_name target)
                   (and (is_string? target)
                        (get_control_by_id target))
                   (get_control_by_id target)
                   (is_control? target)
                   target))
       (confirmed true)
       (swap_target (and no_mod_layout
                         (last (-> (control_holding_tank) `controls)))))
      (declare (function control_holding_tank)
               (global control_holding_tank))
      (cond 
         (and control swap_target)
         (progn
            (if (and destroy?
                     (is_function? control.on_destroy))
                (= confirmed (-> control `on_destroy)))
            (sleep 0.01)
            (when confirmed   
               (swap_control control swap_target)
               (if destroy?
                  (try
                     (container_view_operation "destroy" control nil { `suppress_destroy_confirm: true } )
                     (catch Error (e)
                        (progn
                           (log_error "hide_control: " e.message)
                           (console.error "hide_control: " e)
                           (notify e.message)))))))
         control
          (progn
             (container_view_operation (if destroy? "destroy" "hide") control nil)
             true)
          else
          (progn
             (notify "Control not found")
             false)))
   {
       `description: (+ "Provided a control name, id or the control object itself, "
                        "will hide the control, adjusting the layout as needed. "
                        "Returns true if successful, otherwise a notification is "
                        "delivered that the control is not found, and false is "
                        "returned.  If destroy? is true, the control is removed from "
                        "the tree and destroyed.")
       `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
       `usage: ["target:string|object" "destroy?:?boolean" "mo_mod_layout:boolean"]
   })

(defun destroy_control (target)
  (hide_control target true)
  {
   `description: (+ "Provided a control name, id or the control object itself, "
                    "will hide the control, adjusting the layout as needed. "
                    "Returns true if successful, otherwise a notification is "
                    "delivered that the control is not found, and false is "
                    "returned. ")
   `tags: ["controls" "control" "display" "destroy" "remove" "holding_tank" "ui"]
   `usage: ["target:string|object"]
   })

(defun jump_to_control ()
   (let
      ((dlist nil)
       (dlist_id "control_names")
       (names (each (current_controls) `name))
       (collect_matches (fn (new_value)
                           (let
                              ((candidates []))
                            (for_each (name names)
                               (if (contains? new_value (lowercase name))
                                   (push candidates name)))
                            candidates)))
       (prune_selection (fn (e)
                          (let
                              ((prefix nil)
                               (new_value (lowercase search_input.value))
                               (candidates []))
                              (cond 
                                 (== e.key "Backspace")
                                 (progn
                                    (= prefix (chop new_value))
                                    (= candidates (collect_matches prefix))
                                    (while (and (> prefix.length 0)
                                                (== (length (collect_matches prefix))
                                                    candidates.length))
                                       (progn
                                          (= prefix (chop prefix))))
                                    (set_prop search_input
                                       `value
                                       prefix))))))
                           
       (check_selection (fn (e)
                           (let
                              ((new_value (lowercase search_input.value))
                               (candidates []))
                              (unless (== e.key `Backspace)
                                 (progn
                                    (= candidates (collect_matches new_value))
                                    (cond 
                                       (== candidates.length 1)
                                       (set_prop search_input
                                          `value
                                          (first candidates))
                                       (and (> new_value.length 0)
                                            (== candidates.length 0))
                                       (set_prop search_input
                                          `value
                                          (chop search_input.value))))))))
       (search_input nil)
       (target nil))
      
      (declare (function request_user_input current_controls show_control)
               (global request_user_input current_controls show_control))
     
      (aif (get_by_id dlist_id)
           (-> it `remove))
      (= dlist (datalist { `id: dlist_id }
                         (for_each (ctlname (sort names))
                            (option ctlname))))
      (-> (first (get_by_tag "body")) `append dlist)
      (= search_input (input { type: "search" 
                               list: "control_names" 
                               placeholder: (dtext "Type Control Name") 
                               style: "font-weight: bold; display: inline-block; padding: 10px; width: calc(100% - 10px); border: 0px; background: var(--editor-bg-color); color: var(--main-color);" } ))
      (attach_event_listener search_input
         `keydown
         prune_selection)
      (attach_event_listener search_input
         `keyup
         check_selection)
      (= target
         (request_user_input (dtext "Type the name of control and press Enter to switch to it. Press Escape to cancel this dialog.")
                             `text
                             {
                               `input: search_input
                               `validator: (fn (v)
                                              (if (contains? v names)
                                                  true
                                                  false))
                               }))
      (if (and (not (blank? target))
               (contains? target names))
          (show_control target))
      target)
   {
     description: (+ "This function provides a popup selector allowing the user to quickly "
                     "select a control or layout control to switch the view to.  If the user selects "
                     "a valid control, the layout will be switched to the containing layout or frame "
                     "0 if the control is in the holding tank.  Then the control will be selected.  "
                     "If the user escapes or cancels, then nothing occurs and the action is "
                     "cancelled.  ")
     usage: []
     tags: ["controls" "layout" "controls" "switch" "ui" "layouts"]
   })

(defun jump_to_symbol_definition ()
   (let
      ((syms [])
       (dlist_id "symbol_names_datalist")
       (dlist nil))
      (declare (function dispatch_event request_user_input)
               (global dispatch_event request_user_input))
      (for_with (s (all_globals))
         (push syms
            s))
      (aif (get_by_id dlist_id)
           (-> it `remove))
      (= dlist
         (datalist { `id: dlist_id }
                   (for (s (sort syms))
                        (option s))))
      (-> (first (get_by_tag "body")) `append dlist)
      (aif (request_user_input (dtext "What is the name of the symbol?")
                          nil
                          {
                            input: (input { list: dlist_id style: "width: 100%" } )
                            on_destroy: (fn ()
                                           (progn
                                              (-> dlist `remove)
                                              (= dlist nil))) })
           (dispatch_event { command: "open_definition"
                                     source: nil
                                     args: [ it ] })))
   {
     description: (+ "Taking no arguments this function will present a modal dialog with a "
                     "search box for the list of all global symbols for which the user can search for "
                     "a symbol.  Once they have selected a symbol, they can press enter or click the "
                     "OK button to be taken to a buffer containing the definition for the symbol.  "
                     "The definition information as to where to find the symbol is taken from the "
                     "symbols metadata.")
     usage: []
     tags: ["symbol" "global" "definition" "meta" "ui" "DOM" "symbols" ]

   })

(defun process_focus_chain (e originator_container)
   (progn
      (console.log "process_focus_chain: called: " e originator_container)
      (handle_event e)
      (when e.srcElement
         (let
            ((target_control nil)
             (elem e.srcElement)
             (controls (reduce (c (current_controls))
                          (when c.on_focus
                             c)))
             (focused_list (query_all ".juno-focused")))
            
            ;; check for if we have found the target control:
            ;; if the current element is equal to the controls view...
            ;; we found it, otherwise move up to the parent node...
            ;; and check again...until we can't
            (while elem
               (progn
                  (for_each (control controls)
                     (when (== elem control.view)
                        (= target_control control)
                        (break)))
                  (when target_control
                     (break))
                  (= elem elem.parentElement)))
            (console.log "process_focus_chain: setting focus to: " target_control.options.name)
            (if target_control
               (set_focus_to target_control controls))))))


(defun menu_tree (items options _path)
  (let
      ((options (either options { `flat_index: 0 }))
       (path (either _path []))
       (disappear_timer nil)
       (os (get_operating_platform))
       (command_map { "Command": "⌘"
                      "Ctrl": (if (== os "mac")
                                     "⌃"
                                     "Ctrl")
                      "Alt": (if (== os "mac")
                                 "⌥"
                                 "Alt")
                      "Shift": "⇧" 
                      "Backslash": (String.fromCharCode 92)
                      "Escape": "Esc"
                      "Slash": "/"
                      })
       (compress_keycodes (fn (keycode)
                             (join " or " (map compress_keycode (split_by "|" keycode)))))
       (compress_keycode (fn (keycode)
                            (join "-" 
                               (for_each (c (split_by "-" keycode))
                                  (aif (prop command_map c)
                                       it
                                       c)))))
                               
       (min_width (+ "min-width: " (or options.min_width 350) "px;"))
       (id (either options.id "cmenu"))  
       (active_menu_item nil)
       (menu_element
        (fn (idx menu_details `& args)
          (let
              ((text menu_details.text)
               (os (get_operating_platform)) ;; os could've changed due to rehydration
               (kcode (or menu_details.keycode ""))
               (view (li {  `class: "pure-list-item" 
                           `tabindex: 0
                          `style: (+ (if (> args.length 0)
                                         "position: relative;"
                                         "")
                                     min_width)
                          }
                         (a { 
                             `idx: idx
                             `path: (join "~" (conj path idx))
                             `href: "#"
                             `class: "pure-menu-link" 
                             `style: ""
                             }
                            (if (== args.length 0)
                              [(span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                               (span { `class: "juno-menu-submenu" } kcode)]
                              [(span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                               (span { `class: "juno-menu-submenu" } "❯")]))
                         args))
               (timer nil))
            (if (== args.length 0)
              (progn
                 (attach_event_listener view
                    `mouseenter
                    (fn (e)
                       (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)))
                 view)
              (progn
               (attach_event_listener view
                  `mouseenter
                  (fn (e)
                     (do
                        (= active_menu_item e.srcElement)
                        (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)
                        (add_class "juno-menu-selected" e.srcElement)
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (progn
                                             (set_style [["display" "inline-block" ]
                                                         ["position" "absolute"]
                                                         ["top" "0px"]
                                                         ["left" (+ "" e.srcElement.offsetWidth "px") ]]
                                                        view.children.1)
                                             
                                             (adjust_element_position view.children.1 30)
                                             ))
                                       150)))))
               (attach_event_listener view
                  `mouseleave
                  (fn (e)
                     (do
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (progn
                                             (set_style [["display" "none"]] view.children.1)))
                                       150)))))
               
               view)))))
       (view nil))
    
    (= view
       (ul (+ {}
              { `class: (if (> path.length 0)
                             "juno-menu pure-menu-list"
                             "pure-menu-list")
                `style: (+ (if (> path.length 0)
                             "display: none;"
                             "display: inline-block;")
                           "position: relative;")  }
              (if (== path.length 0)
                { `id: id }
                {}))
                     
           (map (fn (item idx)
                  (let
                      ((menu_details {})
                       (struct (if (is_function? item.0)
                                   (item.0)
                                   item.0)))
                      (cond 
                         (is_string? struct)
                         (progn
                            (set_prop menu_details
                               `text struct)
                            (aif (resolve_path [ `global (to_key struct) ] *key_bindings*)
                                 (progn
                                    (set_prop menu_details
                                       `keycode (prop it os))
                                    (set_prop menu_details
                                       `exec (prop it `exec)))))
                         (is_element? struct)
                         (progn
                            (set_prop menu_details
                               `text struct)
                            (aif (resolve_path [ `global (to_key struct) ] *key_bindings*)
                                 (progn
                                    (set_prop menu_details
                                       `keycode (prop it os))
                                    (set_prop menu_details
                                       `exec (prop it `exec)))))
                         (and (is_object? struct)
                              (is_array? struct.path))
                         (progn
                            (cond 
                                 (resolve_path struct.path *key_bindings*)
                                 (progn
                                    (defvar detail (resolve_path struct.path *key_bindings*))
                                    (set_prop menu_details
                                       `text (or struct.text
                                                detail.description)
                                       `keycode (prop detail os)
                                       `exec (or struct.exec detail.exec))
                                    (if (is_function? menu_details.exec)
                                        (set_prop item 
                                           1
                                           menu_details.exec))
                                    menu_details)
                                 (and (is_function? struct.exec)
                                      (is_string? struct.text))
                                 (progn
                                    (set_prop menu_details
                                       `text struct.text
                                       `keycode nil
                                       `exec struct.exec)
                                    (set_prop item 
                                           1
                                           menu_details.exec))
                                 else
                                 (progn
                                    (set_prop menu_details
                                       `text (or (prop struct `text)
                                                 (+ "No Menu Text Found " idx))))))
                         (is_object? struct)
                         (progn
                            (aif (and struct.text
                                      (resolve_path [ `global (to_key struct.text) ] *key_bindings*))
                                 (set_prop menu_details
                                    `text struct.text
                                    `keycode (prop it os)
                                    `exec it.exec)
                                 (set_prop menu_details
                                       `text (or struct.text
                                                (+ "No Menu Text Found " idx)))))
                         
                         else
                         (set_prop menu_details
                            `text (+ "No Menu Text Found " idx)))
                      
                      (set_prop options
                         `flat_index
                         (+ 1 options.flat_index))
                    (when menu_details.keycode
                       (set_prop menu_details
                                 `keycode 
                                 (compress_keycodes menu_details.keycode)))
                    ;(log "menu_tree: menu_details: final:" menu_details)
                    (cond
                      (is_array? item.1)
                      (menu_element options.flat_index menu_details (menu_tree item.1 options (conj path [ idx 1])))
                      (and (== menu_details.text "--") (eq nil item.1))
                      (hr { `class: "LightHR" })
                      (is_function? item.1)
                      (menu_element idx menu_details)
                      (is_string? item.1)
                      (menu_element idx menu_details)
                      (is_object? item.0)
                      (menu_element idx menu_details)
                      else
                      [])))
                items)))
    (if (> path.length 0)      
      (progn
         (adjust_element_position view)
         view)
      (progn
       (attach_event_listener view
                              `click
                              (fn (e)
                                (let
                                    ((path (-> e.srcElement `getAttribute "path"))
                                     (idx (-> e.srcElement `getAttribute "idx"))
                                     (target (if path
                                               (resolve_path (split_by "~" path) items))))
                                  (handle_event e)
                                  (-> view `remove)
                                  (aif (get_by_id "cmenu")
                                       (-> it `remove))
                                  (when (is_function? options.on_select)
                                     (options.on_select path))
                                  (sleep 0.01) ;; disconnect and move to back of the event loop for the call
                                  (when (and target
                                             (is_function? target.1))
                                    (try
                                       (target.1 e target.2)
                                       (catch Error (e)
                                          (log_error "Base Catch: " e.message)
                                          (log_error e))))
                                  )))
       (setTimeout (fn ()
                     (progn
                      (attach_event_listener view
                                             `mouseleave
                                             (function (e)
                                                       (progn
                                                        (when disappear_timer
                                                          (clearTimeout disappear_timer))
                                                        (= disappear_timer (setTimeout (fn ()
                                                                                         (progn
                                                                                          (-> view `remove)
                                                                                          (when (is_function? options.on_select)
                                                                                             (options.on_select nil))
                                                                                          (= disappear_timer nil)))
                                                                                       (or *env_config*.application.menu_timeout
                                                                                           options.menu_timeout
                                                                                           2500))))))
                      (attach_event_listener view
                                             `mouseenter
                                             (function (e)
                                                       (when disappear_timer
                                                         (clearTimeout disappear_timer)
                                                         (= disappear_timer nil))))))
                   700) ;; delay a little before adding the timeout so we don't accidentally hover over it 
       {
        `view: view
        `toJSON: (function ()
                           `(menu_tree ,#items ,#options))
        `type: "menu_tree"
        }))))

(defun make_menu (for_element menu_items options)
  (let
      ((menu_items menu_items)
       (for_element for_element)
       (pos nil)
       (mtree nil)
       (disappear_timer nil)       
                                        
       (view nil))
    (aif (get_by_id "cmenu")
         (-> it `remove))
    (setq mtree
          (menu_tree menu_items options))
    (setq view
          mtree.view)
    (add_class "juno-menu" view)
    (when for_element
      (setq pos
            (-> for_element `getBoundingClientRect))
      (set_style [["top" (+ "" (Math.max 0 pos.bottom) "px") ]
                  ["left" (+ "" (Math.max pos.left 0) "px") ]
                  ["position" "absolute"]
                  ["z-index" "30"]]
                  view))
    (if options.do_not_attach
      view
      (progn       
       (-> (get_by_id "body") `appendChild view)
       (adjust_element_position view)
       view)))
  {
    description: (+ "The `make_menu` function constructs a pop-up menu DOM structure and "
                    "attaches it to the provided element.  The menu items are constructed from the "
                    "`menu_items` nested array, which follows the standard menu structure.  The "
                    "function, by default, attaches the constructed menu view to the element when "
                    "called, but if the `do_not_attach` option is provided, will only produce and "
                    "return the menu, and not mount it as a child to the provided element.  <br>The "
                    "produced menu always has an id of `cmenu`, and if there is already an element "
                    "attached to the DOM with that ID, it will remove it prior to construction of "
                    "the new menu.<br>The menu is attached to the provided DOM element at the bottom "
                    "left of the element.<br>The return value is the generated menu "
                    "view.<br><br>#### Menu Format   <br><br>All menu structures that are provided "
                    "to this function should follow the format of:```[[\"Menu Item 1 Text\" (fn "
                    "(click_event))]\n [\"--\" nil]\n [\"Menu Item 2 Text\" [[\"Sub Menu 1\" (fn "
                    "(click_event))]\n                      [\"Sub Menu 2\" (fn "
                    "(click_event))]]]]```<br><br><br>Submenus are constructed by a nested array as "
                    "a second argument.<br>If a `--` string is encountered as a first argument and "
                    "nil as a second argument, then a horizontal rule is inserted in the generated "
                    "menu view.<br><br>#### Shortcuts   <br><br>The easiest way to link a short cut "
                    "action to a menu item is to link by name.  This means that the text value in "
                    "position 0 of the descriptor array (e.g. \"Menu Item 1 Text\") is turned into a "
                    "key by the `to_key` function, such that \"Menu Item 1 Text\" becomes "
                    "`menu_item_1_text`, which is then checked against the `*key_bindings*` global "
                    "in the namespace.  If a key binding is found with the key `menu_item_1_text` "
                    "then that key is used as a short cut.  This method helps keep a naming linkage "
                    "between the short cut key entries and the menu item entries.<br>Optionally "
                    "instead of a text item in position 0 of the descriptor array an object can "
                    "instead be present with the following key structure:```{\n  text: \"The displayed "
                    "menu text\"\n  path: [ `global `command ]  ;; in *key_bindings*\n}```<br><br>The "
                    "keycode will come from the linked key code which is dependent on the operating "
                    "platform.<br><br>#### Example   <br>```(let \n   ((b (button \"Right Click!\")))\n "
                    "(attach_event_listener b `contextmenu\n      (fn (right_click_event)\n       "
                    "(progn\n            (handle_event right_click_event)\n            (make_menu b\n  "
                    "                   [[\"Hi There\" (fn (menu_click_event)\n                        "
                    "             (notify (+ \"Hi There: \"\n                                          "
                    "      right_click_event.srcElement.tagName)))]\n                       [\"Good "
                    "Bye!\" (fn (menu_click_event)\n                                       (notify (+ "
                    "\"Good Bye!: \"\n                                                 "
                    "menu_click_event.srcElement.tagName)))]]\n                       {\n             "
                    "          min_width: 250 }))))\n   b)```<br><br><br>#### Options "
                    "<br><br>min_width:number -The minimum width for the menu item.   This setting "
                    "impacts how wide the menu element is.<br>do_not_attach:boolean -If true, the "
                    "menu Element structure is created as a view, but not attached to the target "
                    "element, and is instead just returned.   ")

    usage: ["for_element:Element" "menu_items:array" "options:?object"]
    tags: ["menu" "events" "popup" "UI" "DOM" "contextmenu" "menu-structure"]
    })

(defun_sync get_key_code (e)
  (let
      ((k []))
      (when e.metaKey
         (push k "Command"))
      (when e.ctrlKey
         (push k "Ctrl"))
      (when e.altKey
         (push k "Alt"))
    (when e.shiftKey
      (push k "Shift"))
    (unless (contains? e.key [ "Shift" "Control" "Alt" "Meta" ])      
            ;; normalize to the printed key characters on the keyboard
            (push k (cond 
                       (starts_with? "Key" e.code)
                       (-> e.code `substr 3)
                       (starts_with? "Digit" e.code)
                       (-> e.code `substr 5)
                       else
                       e.code)))
    (if (> k.length 0)
        (join "-" k)
        e.code))
  {
      `description: (+ "Given a key event, returns a text description of the set of characters in a normalized order "
                       "for matching keybinding handlers.  If no modifier keys (Control, Alt, Command, or Shift), returns "
                       "the direct code value from the key event.  If a modifier or modifiers are also pressed, will "
                       "return a composite value with the following order of priority, where if a key with a lower "
                       "prority is pressed, it will appear first in the returned value:<br>"
                       "Command - 0 <br>"
                       "Ctrl - 1<br>"
                       "Alt - 2<br>"
                       "Shift - 3 <br>"
                       "For example if the user is pressing both the Shift and the Control key and the 'A' key, the "
                       "returned value will be \"Ctrl-Shift-A\" as the priority value for 'Control' is 1 and the "
                       "priority value for 'Shift' is 3.  Note that whenever a modifier is pressed, the value of "
                       "the pressed key will be always uppercase as the descriptor.")
      `usage: ["event:Event"]
      `tags: [ "key" "events" "binding" "keycodes" "keyboard"]
  })

(defun attach_context_menu (element menu_gen)
   (progn
      (attach_event_listener element `contextmenu
         (fn (e)
            (let
               ((cmenu nil)
                (dims nil))
               (unless e.shiftKey
                  (handle_event e)
                  (= cmenu
                     (make_menu e.srcElement
                                (cond
                                   (is_function? menu_gen)
                                   (menu_gen e)
                                   (is_array? menu_gen)
                                   menu_gen)
                                {
                                  min_width: 300
                                  do_not_attach: true
                                  }))
                  (set_style [["top" (+ "" (Math.max 0 e.clientY) "px") ]
                              ["left" (+ "" (Math.max e.clientX 0) "px") ]
                              ["position" "absolute"]
                              ["z-index" "30"]]
                             cmenu)
                  (-> (get_by_id "body") `appendChild cmenu)
                  (= dims (-> cmenu `getBoundingClientRect))
                  (adjust_element_position cmenu)))))
         element)
   {
     description: (+ "Given a target DOM element and a menu generator function or a menu "
                     "array, attaches a `contextmenu` event listener to the target element.  The menu "
                     "generator argument can either be a function which returns a nested array "
                     "structure in the standard menu format, or a pre-built array with the menu "
                     "structure already generated.  The element that the context menu event listener "
                     "is returned.\n\n<br>If provided a function for the menu_generator argument, the "
                     "contextmenu event is passed to the function when called.  <br>The individual "
                     "menu items will receive the click event from the selected menu items.<br>See "
                     "`make_menu` for more information on the standard menu format.<br><br>#### "
                     "Example:   <br>```(let\n   ((b (button \"Right Click!\")))\n  (attach_context_menu "
                     "\n      b\n      (fn (right_click_event)\n         [[\"Hi There\" (fn "
                     "(menu_click_event)\n                         (notify (+ \"Hi There: \"\n           "
                     "                        right_click_event.srcElement.tagName)))]\n        "
                     "[\"Good Bye!\" (fn (menu_click_event)\n                          (notify (+ \"Good "
                     "Bye!: \"\n                                   "
                     "menu_click_event.srcElement.tagName)))]])))```<br> ")

     usage: ["element:Element" "menu_generator:function|array"]
     tags:["events" "contextmenu" "menu" "context" "event" "DOM" "UI"]
     })

(defun request_button_choice (prompt choice_text options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((current_focus *last_focus*)
                      (completed false)
                      (button_panel (section (+ {} (if options.class 
                                               { `class: options.class }
                                               { `class: "juno-button-group" `style: "margin-top: 10px;" `role: "group" }))
                                         (for (choice (or choice_text []))
                                              (cond
                                                 (and (is_array? choice)
                                                      (== choice.0 "--"))
                                                 (br)
                                                 (== choice "--")
                                                 (br)
                                                 else
                                                 (button (+ {} 
                                                         (if (is_string? options.button_class)
                                                             { class: options.button_class }
                                                             {  } )
                                                         { tabindex: 0 value: (if (is_array? choice) 
                                                                                  (or choice.1 "nil")
                                                                                  choice) })
                                                      (if (is_array? choice)
                                                          choice.0
                                                          choice))))))
                      (dwin (dialog { `style: "height: min-content; width: min-content;"   }
                                    (div { `class: "juno-instructions" } prompt)
                                    (br)
                                    button_panel
                                    (br)))
                      (rval nil)
                      (return_value (fn ()
                                       (progn
                                              (clean_up rval))))

                      (clean_up (fn (val)
                                    (when (not completed)
                                        (= completed true)
                                        (when options.on_destroy
                                           (-> options `on_destroy))
                                        (resolve val)
                                        (-> dwin `remove)
                                        (when current_focus
                                           (set_focus_to current_focus))))))
                     
                     
                     
                     
                     
                     ;; don't immediately react to keyup so as not to immediately react
                     ;; in certain scenarios
                     (setTimeout (fn ()
                                    (progn
                                       (attach_event_listener dwin
                                          `keyup
                                          (fn (e)
                                             (cond
                                                (== e.key "Escape")
                                                (progn
                                                   (handle_event e)
                                                   (clean_up nil)))))))
                                 250);
                     (attach_event_listener button_panel
                        `click
                        (fn (e)
                           (let
                              ((src e.srcElement))
                              (handle_event e)
                              (= rval (get_attribute src "value"))
                              (if (== rval "nil")
                                  (= rval nil))
                              (return_value))))
                     
                     
                     (attach_event_listener dwin
                        `close
                        (fn (e)
                           (clean_up nil)))
                     (-> juno_container
                        `appendChild dwin)
                     (when (is_function? dwin.showModal)
                        (-> dwin `showModal)))))
  {
    description: (+ "This function will pause the flow of execution until the user makes a "
                    "choice, which is presented as a series of buttons. If the user presses the "
                    "Escape key, a return value of nil will be returned.  This presented choice "
                    "dialog is useful for presenting a limited number of choices to the user, all of "
                    "which are visible as buttons.<br>There is no "
                    "automatic `Close` or `OK` or `Cancel` button.  These must be explicitly passed "
                    "if they are to be a choice.<br>Choices can be passed as either an array of "
                    "strings, or as an array of arrays.  If an array of strings, then each text "
                    "value will be the displayed button value, and will be returned if the "
                    "particular button is pressed.  If the choices are an array of arrays, the "
                    "elements of the inner array define the text of the button, and the value, "
                    "respectively.  In this case, the designated value will be returned, not the "
                    "text.<br>If a `\"--\"` is provided in the choices argument array, then a `br` is "
                    "inserted and a new line is started.<br><br>#### Examples <br><br>A simple "
                    "example illustrates the function:```(request_button_choice \"Select a choice\" "
                    "[\"Left\" \"Right\" \"Center\"])```<br><br>The above will create a dialog with three "
                    "buttons displayed and the provided text.  Whatever button is pressed, the text "
                    "of the button will be returned.<br>The next example shows passing the choices "
                    "as an array of arrays, with line break indicators "
                    "embedded.```(request_button_choice \"Select a choice.\"\n    [[\"Apply and Close\" 0 "
                    "]\n     \"--\"\n     [\"Cancel and Close\" 1 ]\n     \"--\"\n     [\"Cancel\"]])           "
                    "       ```<br><br>In the above example, there are 3 choices.  The `--` strings "
                    "indicate that a new line should start before the next button.  Otherwise, the "
                    "buttons are sequentially displayed on the line.<br><br><br>#### Options "
                    "<br><br>class:string - The class that the internal `section` element will be "
                    "assigned.  This is the class that contains the buttons.  By default the class "
                    "of the `section` element is `juno-button-group` which is defined "
                    "in `style.css` for the application.<br>button_class:string - The class to "
                    "explicitly assign to the buttons, otherwise the buttons are not assigned a "
                    "direct class, but inherit their style from being part of "
                    "the `juno-button-group` class.<br>on_destroy:function -Prior to the removal and "
                    "clean up of the dialog box and after the user has closed the dialog (either via "
                    "the cancel or OK mechanisms), this function can be called to remove any "
                    "resources that may have been created (such as a datalist) for the presentation "
                    "of the dialog.  This functionality can also be done external to the "
                    "application, but this gives an opportunity prior to the removal of the UI "
                    "elements from the DOM for user code to process the values from the inputs. ")

    usage: ["prompt:string" "type:string" "options:object"]
    tags: ["user" "input" "request" "collect" "wait" "ui" "DOM"]
    })

(defun request_user_input (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((user_input (if options.input
                                    options.input
                                    (input (+ {`tabindex: 0 `type: (or type "text") `style: "width: calc(100% - 15px)" }
                                              (if options.placeholder
                                                 { placeholder: options.placeholder }
                                                 {})
                                              (if options.title
                                                 { `title: options.title }
                                                 {})
                                              (if options.class
                                                 { `class: options.class } 
                                                 {})
                                              (if options.value
                                                 { `value: options.value } 
                                                 {})
                                                ))))
                      (current_focus *last_focus*)
                      (completed false)
                      (ok_button (button { `class: "juno-primary" `style: "float:right" } (dtext "OK")))
                      (cancel_button (button { `class: "juno-secondary" }  (dtext "Cancel")))
                      (dwin (dialog { `style: "height: min-content; width: min-content;"   }
                                    (div { `class: "juno-instructions" } prompt)
                                    (br)
                                    user_input
                                    (br)
                                    (div { `class: "pure-button-group juno-control-group" `style: "margin-top: 10px;" `role: "group" }
                                         (if options.no_cancel_button
                                            []
                                            cancel_button)
                                         ok_button)))
                      (rval nil)
                      (get_current_value (fn ()
                                            (cond
                                               user_input.value
                                               user_input.value
                                               (getAttribute user_input `value)
                                               (getAttribute user_input `value)
                                               options.no_cancel_button
                                               true)))
                      (return_value (fn ()
                                       (progn
                                          (= rval (get_current_value))
                                          (cond
                                             (is_function? options.validator)
                                             (if (-> options `validator rval)      
                                                 (clean_up rval) ;; if the validator returns true, ok remove the dialog box
                                                 nil) ;; wait for an appropriate inpit
                                              else
                                              (clean_up rval)))))
                                                     
                                                     
                      (clean_up (fn (val)
                                    (when (not completed)
                                        (= completed true)
                                        (when options.on_destroy
                                           (-> options `on_destroy))
                                        (resolve val)
                                        (-> dwin `remove)
                                        (when current_focus
                                           (set_focus_to current_focus))))))
                     
                     
                     
                     (if (is_function? options.validator)
                         (set_disabled ok_button))
                     
                     (attach_event_listener ok_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (return_value))))
                     ;; don't immediately react to keyup so as not to immediately react
                     ;; in certain scenarios
                     (setTimeout (fn ()
                                    (attach_event_listener user_input
                                       `keyup
                                       (fn (e)
                                          (cond
                                             (== e.key "Escape")
                                             (progn
                                                (handle_event e)
                                                (clean_up nil))
                                             (== e.key "Enter")
                                             (progn
                                                (handle_event e)
                                                (return_value))
                                             (is_function? options.validator)
                                             (progn
                                                (if (-> options `validator (get_current_value))
                                                    (set_enabled ok_button)
                                                    (set_disabled ok_button)))))))
                                 
                                 250);
                     (attach_event_listener cancel_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (clean_up nil))))
                     
                     (attach_event_listener dwin
                        `close
                        (fn (e)
                           (clean_up nil)))
                     
                     (when options.default_value
                        (set_prop user_input
                           `value
                           options.default_value))
                     
                     (-> juno_container
                        `appendChild dwin)
                     ;(setTimeout (fn ()
                     ;              (place_caret_at_end user_input))
                     ;          50)
                     (when (is_function? dwin.showModal)
                        (-> dwin `showModal)
                        (and (is_function? user_input.select)
                             (-> user_input `select))))))
  {
    description: (+ "This function will pause the flow of execution until the user makes a "
                    "choice, selection or input and then will return the result of the user action. "
                    "If the user presses cancel or presses the Escape key, a return value of nil "
                    "will be returned.<br>By default, the user is presented with either a text input "
                    "box in which text can entered, or an input element provided in the options. "
                    "Once the user presses return or clicks the OK button, the value is "
                    "returned. <br><br>#### Options <br><br>type:string -  If the `type option is "
                    "given as an input, the input will be of the specified type, such as \"number\" or "
                    "\"date\".<br>input:Element - If provided with a key of \"input\" and an input "
                    "element, the provided input element will be displayed and the final value "
                    "returned.  Other elements can be provided and as long as they either set a "
                    "value property or value attribute on the element, that value will be "
                    "returned.<br>validator:function - Values can be validated by passing a "
                    "\"validator\" function.  Upon the user pressing a key, the validation function "
                    "will be called with the current value and if the validation function returns "
                    "true, OK will be enabled, or if the user pressed enter, the validated value "
                    "will be returned to the caller, otherwise the OK button will be disabled and "
                    "the dialog box will not close. Note that the validator function is responsible "
                    "for any prompting of or additional notices of how to comply with the validation "
                    "rules.  This could be done by providing a more complicated element structure as "
                    "an input that is in the closure of the validator whose values could be "
                    "updated.<br>on_destroy:function - Prior to the removal and clean up of the "
                    "dialog box and after the user has closed the dialog (either via the cancel or "
                    "OK mechanisms), this function can be called to remove any resources that may "
                    "have been created (such as a datalist) for the presentation of the dialog.  "
                    "This functionality can also be done external to the application, but this gives "
                    "an opportunity prior to the removal of the UI elements from the DOM for user "
                    "code to process the values from the inputs. ")
    usage: ["prompt:string" "type:string" "options:object"]
    tags: ["user" "input" "request" "collect" "wait" "ui" "DOM"]
    })
                 
(defun request_user_choice (prompt choice_list options)
   (request_user_input prompt nil
                       {
                           `input:(apply select (+ {}
                                                   (if options.class
                                                      { `class: options.class }
                                                      {})
                                                   (if options.style
                                                      { `style: options.style }
                                                      {}))
                                     (for_each (choice choice_list)
                                        (cond
                                           (is_array? choice)
                                           (option (+ { `value: choice.1 } 
                                                      (if (and (not (blank? options.default_value))
                                                               (== choice.1 options.default_value))
                                                         { `selected: true }
                                                         {}))
                                                   choice.0)
                                           else
                                           (option (+ {} 
                                                      (if (and (not (blank? options.default_value))
                                                               (== choice options.default_value))
                                                         { `selected: true }
                                                         {}))
                                                   choice))))
                           `no_cancel_button: options.no_cancel_button
                       })
   {
       `usage: ["prompt:text" "choice_list:array" "options:object"]
       `description: (+ "This function will pause the flow of execution until the user " 
                        "makes a choice, selection or input and then will return the result " 
                        "of the user action. If the user presses cancel or presses the " 
                        "Escape key, a return value of nil will be returned.<br>"
                        "The choice list can be either an array of simple values, such as " 
                        "strings or numbers, or it can be an array of 2 value arrays (pairs), "
                        "where the first value is the presented text for the choice, and the "
                        "second value is the value of the selection that is returned "
                        "if selected.  Note that all values are stored in the DOM as "
                        "strings, so if non-string numbers are required as values, <br>" 
                        "they must be converted to their required form once returned "
                        "from this function."
                        "#### Example forms for the choice_list argument<br>"
                        "A simple form:"
                        "```[\"First Choice\" \"Second Choice\"]```"
                        "A form with two choices:"
                        "```[[\"First Choice\" 1] [\"Second Choice\" 2]]```"
                        "Note that in the second example the values are numeric, but "
                        "will be returned from the function as a string value.<br>"
                        "#### Options<br>"
                        "The options object can have the following keys:<br>"
                        "default_value:string - The value default selected choice.  This should match "
                        "a specific choice value in the choice_list array.<br>"
                        "class:string - A class name or names to be used for the select element.<br>"
                        "style:string - A semi-colon delimited set of CSS attributes "
                        "to be applied to the select element.<br>"
                        "no_cancel_button:boolean - If true the cancel button will not be displayed.<br>")
       `tags: ["request" "user" "choice" "collect" "wait" "ui" "DOM"]
   })


(defun make_named_layout_interactive ()
   (if (resolve_path [ `options `root_bundle ] (get_current_layout_control))
       (progn
          (notify (dtext "A named layout cannot be created from another named layout."))
          false)
       (let
          ((current_names (named_layouts))
           (name (request_user_input "Please enter a name for this layout."
                                     {
                                       validator:(fn (v)
                                                    (not (contains? v current_names)))
                                       })))
          (if (not (blank? name))
              (make_named_layout name (get_current_layout_control)))))
       {
         description: (+ "Using the current frame which has a layout that is to be preserved, "
                         "provides a pop up dialog to request a name for the new layout.  Once the user "
                         "has entered a name that is unique and not presently used by another named "
                         "layout, the presently displayed layout will be named and the controls bundled "
                         "together. ")

         usage: []
         tags:["DOM" "controls" "ui" "root" "layout" "control" "names" "bundle"]
         })

(defun move_control_to_new_layout (control layout_name)
   (if (is_control? control)
      (let
         ((name (if (and (not (blank? layout_name))
                         (is_string? layout_name))
                    (compute_name_for_control layout_name)
                    (compute_name_for_control (+ "" (control_name control) "-" "Layout"))))
          (initial_control_layout (get_layout_for_control control))
          (holding_tank (control_holding_tank)))
         (declare (function control_holding_tank compute_name_for_control switch_to_new_layout wait_for_display get_layout_for_control)
                  (global control_holding_tank compute_name_for_control switch_to_new_layout wait_for_display get_layout_for_control))
         (if (layout_locked? initial_control_layout)
             (progn
                (notify "Control's current layout is locked.")
                (throw EvalError "The control to be moved is part of a locked layout")))
         (unless (== (get_current_layout_control) initial_control_layout)
            (switch_to_new_layout (control_name (get_layout_for_control control))))
         ;; first hide the control to the holding tank
         ;; then move it to the new layout
         (if (hide_control control)
             (progn
                (if (-> holding_tank `has_control? control)
                    (progn
                       (-> holding_tank `remove_control (control_id control))
                       (make_named_layout name control { `unmounted_source: true }  )
                       (wait_for_display control)
                       (get_layout_for_control control))
                    (progn
                       (notify "move_control_to_new_layout: Cannot find the control after moving to holding tank")
                       (log "move_control_to_new_layout: Cannot find the control after moving to holding tank")
                       (throw EvalError "move_control_to_new_layout: cannot find the control in the holding tank"))))
             (progn
                (notify "Unable to move control")
                nil))))
   {
     description: (+ "Given a control object, `move_control_to_new_layout` will remove the "
                     "control from its current layout (if unlocked) and attempt to create a named "
                     "layout with the control.  If no layot name is provided, the name will be "
                     "automatically generated based on the controls name.  Once the layout is "
                     "created, it will be switched to and focus to the control will be set.<br>If a "
                     "layout name is provided, it will be checked for name collisions, and if there "
                     "is one a unique suffix will be appended to the name of the control.<br>If a "
                     "non-control is given as an argument a `TypeError` will be thrown.<br>If the "
                     "current layout of the control is locked, an `EvalError` will be thrown. ")
     usage: ["control:object" "layout_name:?string"]
     tags: ["controls" "layout" "layouts" "move" "ui"]
   })

(defun select_control_by_name (prompt options)
   (let
      ((no_sub_controls (not options.include_sub_controls))
       (controls (current_controls no_sub_controls))
       (prompt (or prompt (dtext "Please Select a Control")))
       (names  (reduce (ctl controls)
                 (let
                    ((name (resolve_path [ `options `name ] ctl)))
                    (progn
                       (cond
                          options.include_specials
                          name
                          (is_function? options.include_if_true)
                          (if (-> options `include_if_true ctl)
                              name
                              nil)
                          (and (not (== ctl (control_holding_tank)))
                               (not (starts_with? "split_view" ctl.type))
                               (not (resolve_path [ `options `root_frame ] ctl)))
                          name)))))
                          
                          
       (name_elems (map (fn (name) 
                           (option name))
                        names))
       
       (dlist_id (gen_id "controls"))
       (dlist (apply datalist { `id: dlist_id } name_elems))
       (selector (input { `list: dlist_id `style: "width: calc(100% - 10px);"} ))
       (value nil))
      (try
         (progn
           (-> (get_by_id `body) `append dlist)
           (= value (request_user_input prompt 
                                        `text 
                                        { input: selector
                                          validator: (fn (v)
                                                        (contains? v names))
                                        })))
         (catch Error (e)
            (progn
               (log "select_control_by_name: error in request_user_input operation: " e.message))))
      (log "selected: " value)
      (-> dlist `remove)
      (get_control_by_name value))
   {
       `description: (+ "Given a prompt and an optional options object, presents a dialog that displays the "
                        "given prompt and allows the user to select or type a control name.  A drop down "
                        "allows the user to select the closest matched to the typed in text.<br>"
                        "The selected control is returned, or nil if the user presses cancel or presses Escape.<br>"
                        "By default no split_views, sub controls (controls contained by other controls) " 
                        "or root controls are displayed, only content controls.<br>"
                        "Options:<br>"
                        "include_specials:boolean - By default false, all controls will be presented.<br>"
                        "include_sub_controls - Include the sub controls.<br>"
                        "include_if_true:function - Predicate function which is passed a control, and if the function "
                        "returns true the control will be included in the selection, otherwise it will not be.")
       `usage: ["prompt:text" "options:object"]
       `tags: ["controls" "select" "choose" "user" "UI" "DOM" ]
   })  


(defun alert_box (message detail)
   (request_user_input (or message "No message provided!") 
                       nil 
                       { `input: (if detail 
                                     (div detail)
                                     (span {})) 
                         `no_cancel_button: true })
   {
     `usage:[ "message:text" "detail:text|Element"]
     `description: "Creates a modal type popup dialog box which pauses the current execution flow until the OK button is clicked. The return value is undefined."
     `tags: ["alert" "popup" "modal" "box" "warn" "ui" "DOM" ]
   })
     
(defmacro alert_on_error (error_title `& forms)
   `(try
       (progn
          ,@forms)
       (catch Error (e)
          (progn
             (alert_box ,#(or error_title (dtext "Error on Operation"))
                         e.message)
             nil)))
   {
       `usage: ["error_title:text" "forms:*"]
       `description: (+ "All provided forms will be wrapped in a progn and the last value of the provided forms returned.  " 
                        "Any uncaught errors in the provided forms will be caught by this macro abd the provided " 
                        "error_title, and exception message presented to the user for acknowledgement.  On a caught error "
                        "nil will be returned to the calling code.")
       `tags: ["alert" "popup" "catch" "errors" "ui" "DOM"]
   })

(defmacro get_file_system_root ()
   `(if is_served?
      (rblock (get_default [ `http_services `base_directory ]))
      nil)
   {
     description: (+ "If the browser environment is running as a hosted page (served "
                     "via `HTTP` or `HTTPS`), then this macro, when evaluated will return the root "
                     "directory of the file service handler used to access file resources by "
                     "Seedling.  The root directory is the highest level in the file system that is "
                     "accessible to the service providing file support to the browser environment.  "
                     "If the setting is `/` , then all files are available in the file system.  If "
                     "the returned path is relative, then the highest set value is the current "
                     "working directory of the server process.")
     usage: []
     tags: ["path" "server" "root" "base_directory"]
   })

(defun set_file_system_root (path no_warn)
   (when is_served?
      (let
         ((ctls (reduce (ctl (all_editor_controls))
                   (if (and (prop ctl `save)
                            (prop ctl.options `filename))
                       ctl))))
          (declare (function dispatch_event)
                   (global dispatch_event))
          (if (> (length ctls)
                 0)
              (unless no_warn
                 (alert_box (dtext "Set System Root")
                         (div { } (dtext "The following controls must be closed prior to proceeding with this operation.")
                              (ol
                                 (for_each (ctl ctls)
                                    (li ctl.options.name)))))))
          (eval `(rblock
                   (http/set_file_system_root ,#path)))
          (dispatch_event { `command: "change_file_system_root" source: nil args:(list path) } )))
   {
     description: (+ "If the browser environment is hosted (as determined "
                     "by `is_served?` being `true` ), then the provided `path` argument will be set "
                     "as the base path for the `/files` and `/save_file` services on the server.  An "
                     "event is then transmitted, via `dispatch_event` with a command value of "
                     "\"change_file_system_root\" and a `nil` source, with a single argument of the "
                     "new `path`. ")
     usage: ["path:string"]
     tags: ["path" "server" "root" "base_directory"]
   })






;; -- Control Events --------
;; event routing is handled by a map that combines the command value and the source value.
;; if an array is found at the value, it will call each function in the array in sequence
;; as each function in the array is an event handler

(defvalue *event_routes* 
   { }
   {
     `description: (+ "The event routing object which contains routes used by dispatch_event. "
                      "<br>Use register_event_handler to add event handlers and " 
                      "remove_event_handler remove handlers. ")
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes"  ]
     })

(defun_sync compute_handler_key (source command)
   (+ (if (is_string? source)
                           (+ "" source )
                           "")
                       (if (is_string? command)
                           (+ "+" command)
                           ""))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given a source and a command, computes the event_handler lookup key for control events."
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" ]
   })


(defun register_event_handler (source command function_id handler_function)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (exists false))
      (if (blank? handler_key)
          (throw TypeError "register_event_handler: one or more of source and command must be specified as strings"))
      (if (blank? function_id)
          (throw TypeError "register_event_handler: function_id is required"))
      (if (blank? handler_function)
          (throw TypeError "register_event_handler: handler_function is required"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
         (set_prop *event_routes*
            handler_key
            (list { `fid: function_id f: handler_function }))
         (progn
            (for_each (handler handlers)
               (if (== handler.fid function_id)
                   (setq exists true)))
            (if exists
               (throw ReferenceError (+ "register_event_handler: function already registered for fid key for source " source ", command: " command))
               (push handlers { fid: function_id f: handler_function }))))
      handler_key)
   {
       `usage: ["source:string" "command:string" "handler_function_id:string" "handler_function:function"]
       `description: (+ "Given a control source id, command string, and a handler function, adds the function to the "
                        "event handler.<br>Either the source id or the command string can be nil, but not both. " 
                        "Omitting one of the specifiers broadens the scope of the events that will be routed "
                        "to the handler function.  For example, if the source id is omitted, but the command "
                        "string is provided, all events that match the command string, regardless of source "
                        "will be routed to the function.  Conversly, if the command string is omitted, but the "
                        "source is provided, all events from that source will trigger the handler function to "
                        "to be called.  Note that there can be multiple handler functions registered for the same "
                        "source id/command combination.<br>"
                        "If the function is determined to be already registered using equality, then "
                        "the function will throw a ReferenceError that the same function is already registered.  "
                        "Returns the computed handler_key.<br>The handler function should be defined in the "
                        "form of (fn (event_obj)), where event_obj will be the event object as transmitted " 
                        "from the source.<br>")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })
    
(defun remove_event_handler (source command handler_function_id)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (idx nil))
      (if (blank? handler_key)
          (throw TypeError "remove_event_handler: one or more of source and command must be specified as strings"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
          true
          (progn
             (if (eq nil handler_function_id) ;; if no handler_function_id is provided, remove all handlers for the events
                 (progn
                    (set_prop *event_routes*
                       handler_key
                       [])
                    true)
                 (progn
                    (map (fn (f i)
                            (if (== f.fid handler_function_id)
                                (setq idx i)))
                         handlers)
                    (when idx
                       (-> handlers `splice idx 1))
                    (if idx
                       true
                       false))))))
   {
       `usage: ["source:string" "command:string" "handler_function_id:string"]
       `description: (+ "Given a control source id, command string, and a handler function, removes the function to the "
                        "event handler.  If the function isn't found in the event handlers using equality, then "
                        "the function will return false, otherwise if successful it will return true.  If no function is "
                        "is provided, then all handlers for the key will be removed.")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })

(defun get_control_event_handlers (source command)
   (prop *event_routes* (compute_handler_key source command))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given an source string and command string, returns an array of all specific matching handlers for the given values."
       `tags: ["events" "controls" "handlers" "dispatch" "routes" ]
   })  
  
(defun remove_all_handlers_for_source (source)
   (let
      ((routes nil))
      (when (not (is_string? source))
         (throw TypeError "source must be a string"))
      (setq routes
         (reduce (key (keys *event_routes*))
            (when (starts_with? (+ "" source "+") key)
               key)))
      (apply delete_prop *event_routes* routes)
      (length routes))
   {
       usage: ["source:string"]
       description: (+ "Given a source identifier, removes all routes associated with that source. "
                       "Returns the number of routes removed.")
       tags: ["events" "controls" "routes" "handlers" "source" "dispatch"]
   })

(defun_sync dispatch_event(event_obj)
   (let
      ((handler_key (compute_handler_key event_obj.source event_obj.command))
       (handlers (when handler_key  ;; check for handlers that match specifically, match only source events, and match only command events
                    (flatten (conj (or (prop *event_routes* handler_key) [])
                                   (or (prop *event_routes* (compute_handler_key event_obj.source nil)) [])
                                   (or (prop *event_routes* (compute_handler_key nil event_obj.command)) [])))))
       (deduper (new Set)))
      (when (> __VERBOSITY__ 1)
         (log "dispatch_event: " event_obj handler_key handlers))
      (if (> handlers.length 0)
           (for_each (handler handlers)
              (try
                 (progn 
                    (unless (-> deduper `has handler.fid)
                       (-> handler `f event_obj)
                       (-> deduper `add handler.fid)))
                 (catch Error (e)
                    (progn
                       (log (+ "Error on event handler for route: " handler_key ": removing: " e.message))
                       (console.log (+ "Error on event handler for route: " handler_key ": removing: " e.message))
                       (try (remove_event_handler event_obj.source event_obj.command handler.fid)
                          (catch Error (e)
                             (log (+ "Error Cannot remove problematic event_handler: " handler_key ": " handler.fid ": " e.message))))))))
           ;; no handlers - send it up the chain if we can
           ;; if we are in an iframe and the message hasn't been passed to us 
           ;; between frame boundaries already
           (if (and (in_iframe?)
                    (eq nil event_obj.child_frame))
               (try
                  (-> window.top `postMessage (JSON.stringify event_obj) "*")
                  (catch Error (e)
                     (log "Unable to post message upward")))))
      (when event_obj.error
         (progn
            (log "dispatch_event: error: " event_obj)
            (alert_box (+ ""
                          (from_key event_obj.command)
                          (if event_obj.args.1.message
                             (+ ": " event_obj.args.1.message)
                             ""))
                       (aif (and event_obj.args.0
                                event_obj.args.0.options.filename)
                           (+ "The file " it " was unable to be saved.")))))
      true)
   {
     
     `description: (+ "Given an `event_obj` will route the object to interested handler "
                      "functions as defined in the `*event_routes*` table.  An event object can "
                      "contain both or either keys `command` and `source`, which serve as a selector "
                      "for handler functions, along with an `args` array containing 0 or more element "
                      "values as data to be passed to a matching event handler.  More than one event "
                      "handler can be subscribed to a specific event selector.<br>If a route key "
                      "resolves to an array, each handler function in the found array in "
                      "the `*event_routes*` table is called in sequence.  Routes are collected by "
                      "first looking for handlers that act on the source+command, then source, then "
                      "command.<br>The event handler functions are called with the `event_object` as a "
                      "single argument, such as `(my_handler_function "
                      "event_object)`.<br>Use `register_event_handler`  to add event handlers and "
                      "remove_event_handler remove handlers. The function return value shouldn\'t be "
                      "used. <br>An example event passed to `dispatch_event` :```{ command: \"focus\" \n "
                      "source: self.id\n  args: [] }```<br><br>In the above event, the \"focus\" command "
                      "is dispatched, along with the event source, which in the above is the `id` of "
                      "the control.  No arguments are passed.  A matching event handler would be "
                      "registered for the command string \"focus\" and for the specific id.  Another "
                      "matching event handler could be registered with a `nil` source, but for the "
                      "\"focus\" command, and thus would receive all focus events, regardless of "
                      "source.<br> ")
     `usage: ["event_obj:object"]
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
     })
     


(defun get_editors_for_path (path)
   (let
      ((spath (cond
                 (is_array? path)
                 (join "~" path)
                 (is_string? path)
                 path
                 else
                 (throw TypeError "path must be an array or string"))))
      (sort (reduce (ctl (current_controls))
               (when (and ctl.editor
                          ctl.options.path
                          (== (join "~" ctl.options.path) spath))
                  ctl))
            {
              key: ["options" "primary_rank"]
              }))
   {
       `description: (+ "Returns an array of all controls that are " 
                        "editors and that have the supplied path value. "
                        "The returned array is sorted by the primary_rank "
                        "option in the text_editor control")
       `usage: ["path:array|string"]
       `tags: ["controls" "editor" "path"]
   })

(defun get_control_by_editor (editor)
   (let
      ((ctls (current_controls true)))
      (first (reduce (ctl ctls)
                (when (== ctl.editor editor)
                   ctl))))
   {
       `description: "Given an editor object, returns the control associated with it."
       `usage: ["editor:object"]
       `tags: ["editor" "control" "find"]
   })

(defun get_editor_file_basename (editor_control)
   (aif (resolve_path [ `options `filename ] editor_control)
        (last (split_by "/" it))
        nil)
   {
       description: (+ "If given a control with an editor which is operating on a file, " 
                        "will return the filename without the directory path for that editor. "
                        "Otherwise, it will return nil")
       usage: [ "editor_control:object"]
       tags: ["editor" "file" "basename" "filename" "path"]
   })

(defun close_file (editor_control)
   (let
      ((closed_focus? false))
      (log "close_file: " (and editor_control (prop editor_control `options)))
      (if (and (is_function? editor_control.on_destroy)
               (-> editor_control `on_destroy))
          (progn
             (for_each (ctl (get_editors_for_path editor_control.options.path))
                (progn
                   (if (not closed_focus?)
                       (= closed_focus? (== ctl *last_focus*)))
                   
                   (try
                      (container_view_operation `destroy ctl nil { `suppress_destroy_confirm: true } )
                      (catch Error (e)
                         (log "close_file error: " e.message)))))
             ;(log "close_file: calling default_focus" closed_focus?)
             (if closed_focus?
                   (default_focus)))
          (notify "Close cancelled."))))

;; when save events are dispatched, this function should be the
;; receiver.  It will get the value from the sending control,
;; attempt to save it, and if successful, will dispatch save_complete to
;; all editors with the specific path

(defun save_event_handler (event_obj)
   (alert_on_error "Unable to save"
       (let
          ((control (or event_obj.source_control
                        (get_control_by_id event_obj.source)))
           (pathname (when control
                        control.options.path))
           (nseval (if (not (blank? control.options.path_namespace))
                       (-> Environment `get_namespace_handle control.options.path_namespace)
                       Environment))
           (do_remote_save (fn ()
                              
                              (let
                                 ((rval nil))
                                 (= rval (http/send_files "/save_file" (http/data_to_file control.options.filename (or (-> control `get) ""))))
                                 (if (and rval
                                          (== rval.rval "OK"))
                                     (progn
                                        (= rval rval.results)
                                        (when (> __VERBOSITY__ 0)
                                           (log "save_event_handler: saved remote file OK: " (clone rval)))
                                        (if (== rval.length 1)
                                            (publish_results (+ { `target: rval.0.filename `type: "filename" } rval.0 ))
                                            (progn
                                               (log "ERROR: got different result for save_file then expected" (clone rval))
                                               (throw TypeError "Got different result for save file then expected"))))
                                     (progn
                                        (log "ERROR: save_event_handler: couldn't remote save: " (clone rval)))
                                        (throw TypeError (or rval.message "Uknown response from server"))))))
           (do_path_save (fn ()
                            (progn
                               (make_path pathname nseval.global_ctx.scope
                                  (-> control `get))
                               (if (not (== (sha1 (as_lisp (-> control `get))) (sha1 (as_lisp (resolve_path pathname nseval.global_ctx.scope)))))
                                   (progn
                                      (log "ERROR: save_event_handler: couldn't save path: values not matching: namespace: " control.options.namespace "path:" pathname )
                                      (throw TypeError "couldn't save to the local path - values not matching for path/namespace"))
                                   (progn
                                      (when (> __VERBOSITY__ 0)
                                         (log "save_event_handler: saved local path OK: " control.options.path_namespace pathname))
                                      (publish_results { `target: pathname `type: "path" `namespace: control.options.path_namespace }))))))
                                   
                               
           (publish_results (fn (results_obj)
                               (let
                                  ((controls_to_notify (aif event_obj.source_control
                                                            [ it ]
                                                            (get_editors_for_path control.options.path))))
                                  (for_each (ctl controls_to_notify)
                                     (-> ctl `on_save_complete { `command: "save_complete" `source: control.options.id args: [ results_obj ] }))))))
          (when (> __VERBOSITY__ 0)
             (log "save_event_handler: -> " event_obj))
          ;; validate we have what we need 
          (cond
             (eq nil control)
             (throw ReferenceError "Source control not found")
             (eq nil control.get)
             (throw TypeError "Source control doesn't have a get method for saving"))
          
          (cond
             (and (is_string? control.options.filename) ;; do we have a filename
                  is_served?)  ;; can we do a save?
             (progn
                (if (contains? "http_client" *env_config*.features)
                    (do_remote_save)
                    (throw ReferenceError "http_client is not a registered feature.")))
             (is_string? control.options.filename)
             (throw Error "Not connected to a server - cannot save the remote file")
             
             control.options.path
             (progn
                (do_path_save))))))
             
             

(defun load_js_file (file)
  (let
      ((fdata (try
                (read_file file { `read_as: "text" })
                (catch Error (e)
                  e)))
       (assignment_to nil)
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
       (aif (request_user_input "Enter a name for a reference to the loaded Javascript" "text")
            (do
              (= assignment_to it)              
              (try
                (progn
                 ;(debug)
                 (cond
                   (or (== assignment_to "global")
                       (== assignment_to "script"))
                   (-> (page_header) `append (script { `type: "text/javascript" `charset: "utf-8" }
                                                     (javascript fdata)))
                   else
                   (eval `(defglobal ,#assignment_to (javascript ,#fdata)))))
                (catch Error (e)
                  (do
                    (= error true)
                    (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                    (console.error "ERROR: " e))))                                                    
              (when (not error)
                (log (message (+ "Loaded JS to " assignment_to )))))
            (notify "Entry Cancelled")))
      else
      (progn
       (log "Unable to read the file")
       (console.error fdata)))))

(defun embed_js (name js_text symbol_name) 
  (progn
     (log "embed_js: creating tag id: " name " -> symbol?" symbol_name)
   (-> (page_header) 
       `append
       (html/script
          { `id: name `type: "text/javascript" `charset: "utf-8" }
          (javascript js_text)))
   (when (not (blank? symbol_name))
      (eval `(defglobal ,#symbol_name (html/get_by_id ,#name)
                {
                  `embedded_script: true
                  `external_header_ids: [ ,#name ]
                  })))))

(defun embed_file (file options)
  (let
      ((options (if (is_object? options) 
                    options 
                    {}))
       (ftype (or options.type "text"))
       (fdata (try
                (read_file file { `read_as: ftype })
                (catch Error (e)
                   (progn
                      (log_error e.message)
                      e))))
       (assignment_to (join "-" (split_by "." (or options.symbol file.name))))
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size "assignment_to: " assignment_to)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
         (try
            (embed_js assignment_to fdata options.symbol)
            (catch Error (e)
               (do
                  (= error true)
                  (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                  (console.error "ERROR: " e))))
         (when (not error)
            (when options.symbol
               ;(log "Setting path for " assignment_to  (+ `for " " `source_name))
               (set_path [ `definitions assignment_to `source_name ] Environment file.name))
            (log (message (+ "Loaded JS to " assignment_to )))))
      else
      (progn
         (alert_box "Unable To Read File"
                    fdata.message)
         (log "Unable to read the file")
         (console.error fdata)))))





;; get all the header scripts - we need to choose to eliminate some if we want to
(defun embedded_script_ids ()
   (map (fn (v)
           (get_attribute v `id)) (-> (page_header) `querySelectorAll "script[id]"))
   {
       `description: "Returns a list of script elements in the page header"
       `usage: []
       `tags: ["scripts" "ids" "assets" "DOM" ]
   })

(defun embedded_style_ids ()
   (map (fn (v)
           (get_attribute v `id)) (-> (page_header) `querySelectorAll "style[id]"))
   {
       `description: "Returns a list of script elements in the page header"
       `usage: []
       `tags: ["styles" "style" "ids" "assets" "DOM" ]
   })



(defun load_files (files)
   (let
      ((frame nil)
       (action_selector (fn (path_text default_idx choices)
                           (select { `lpath: path_text } 
                                   (for ((choice idx) (pairs_from_list (interlace choices (range (length choices)))))
                                      (option (+ { value: choice  }
                                                 (if (== default_idx idx)
                                                     { `selected: true }
                                                     {}))
                                              (dtext choice))))))
       (import_button (button { `style: "float: right" } "Import"))
       (cancel_button (button { } (dtext "Cancel")))
       (dispatch nil)
       (file_to_symbol_mapping (reduce (file files)
                                  (when (== (sub_type file) "File")
                                     [file.name 
                                      file.type 
                                      (input { `lpath: (+ file.name "~2") `value: "" }) 
                                      (cond
                                         (== file.type "text/javascript")
                                         (action_selector (+ file.name "~3") 0 [ "Embed As Script Tag" "Assign Source To Global" "Open In Buffer" ])
                                         (starts_with? "image/" file.type)
                                         (action_selector (+ file.name "~3") 0 [ "Display" "Only Assign To Global"])
                                         else
                                         (action_selector (+ file.name "~3") 1 [ "Open In Buffer" "Only Assign To Global"]))
                                      ])))
       (harvest_values (fn ()
                          (to_object
                             (for_each (file file_to_symbol_mapping)
                                (progn
                                   (set_prop file
                                      `2
                                      file.2.value)
                                   (set_prop file
                                      `3
                                      file.3.value)
                                   [ file.0
                                    { type: file.1
                                      name: file.0
                                      symbol: (if (blank? file.2)
                                                  nil
                                                  file.2)
                                      action: file.3 } ])))))
       (resolver nil)
       (result nil)
       (load_op (fn ()
                   (when (> files.length 0)
                      (for_each (file files)
                         (progn
                            (= dispatch (prop file_to_symbol_mapping file.name))
                            (cond
                               (== file.type "text/javascript")
                               (cond 
                                  (== "Embed As Script Tag" dispatch.action)
                                  (progn
                                     (alert_on_error "Unable To Load File"
                                                     (embed_file file
                                                                 {
                                                                   `symbol: dispatch.symbol
                                                                   `type: (first (split_by "/" dispatch.type))
                                                                   })))
                                  (== "Assign Source To Global" dispatch.action)
                                  (alert_on_error "Unable to create symbol"
                                      (if (not (blank? dispatch.symbol))
                                         (progn
                                            (eval `(defglobal ,#dispatch.symbol ,#(javascript (read_file file { `read_as: "text" }))
                                                      {
                                                        source_name: (+ "" ,#file.name)
                                                        }))
                                            (log "load_files: new symbol: " dispatch.symbol))
                                        (notify (+ (dtext "No symbol name provided for the file:")
                                                   " " 
                                                   file.name))))
                                  else
                                  (alert_on_error (dtext "Unable to open buffer")
                                     (log "Opening buffer: " dispatch)
                                     (when (not (blank? dispatch.symbol))
                                        (set_global dispatch.symbol 
                                           (read_file file { `read_as: "text" })
                                                      {
                                                        source_name: (+ "" file.name)
                                                        }))
                                     
                                     (new_buffer { content: (if (blank? dispatch.symbol)
                                                                (read_file file { `read_as: "text" })
                                                                nil)
                                                   mode: "javascript"
                                                   path: (if (not (blank? dispatch.symbol))
                                                             [ dispatch.symbol ]
                                                             nil)
                                                   `name: file.name  })))
                               (starts_with? "image/" file.type)
                               (cond
                                  (== "Display" dispatch.action)
                                  (progn
                                     (defvar file_data (encode_to_base64 (read_file file { `read_as: "binary" })))
                                     (when (not (blank? dispatch.symbol))
                                        (eval
                                           `(defglobal ,#dispatch.symbol
                                               ,#file_data
                                               {
                                                   description: (+ "Image of type " ,#file.type ", source: ",#file.name )
                                               })))
                                     (alert_on_error "Cannot load image"
                                                     (place_control `right
                                                                    (image_viewer (+ "data:" file.type ";base64," file_data)
                                                                                  { name: dispatch.name `auto: true }))
                                                                    ;(panel dispatch.name
                                                                     ;      (img { src: (+ "data:" file.type ";base64," file_data) }))
                                                                    ))
                                  (and (not (blank? dispatch.symbol))
                                       (== "Only Assign To Global" dispatch.action))
                                  (set_global dispatch.symbol
                                     (read_file file { `read_as: "binary" }))
                                  (== "Only Assign To Global" dispatch.action)
                                  (notify (+ (dtext "No symbol name provided for the file:")
                                             " "
                                             file.name))
                                  else
                                  (notify "Bug: Image fall through condition - no action taken"))
                               else
                               (cond
                                  (== dispatch.action "Only Assign To Global")
                                  (progn
                                     (eval `(defglobal ,#dispatch.symbol ,#(read_file file { `read_as: "text" })
                                                      {
                                                        source_name: (+ "" ,#file.name)
                                                        })))
                                  (== dispatch.action "Open In Buffer")
                                  (alert_on_error "Unable to open buffer"
                                     (when (not (blank? dispatch.symbol))
                                        (eval `(defglobal ,#dispatch.symbol ,#(read_file file { `read_as: "text" })
                                                      {
                                                        source_name: (+ "" ,#file.name)
                                                        })))
                                           
                                     (new_buffer { `content: (if (blank? dispatch.symbol)
                                                                 (read_file file { `read_as: "text" })
                                                                 nil)
                                                   `mode: (last (split_by "/" dispatch.type))
                                                   `path: (if (not (blank? dispatch.symbol))
                                                              [ dispatch.symbol ]
                                                              nil)
                                                   `name: file.name  })))))))))
       (handle_event (fn (e)
                        (let
                           ((src e.srcElement))
                           (declare (function resolver))
                           (cond
                              (or (and (== e.type "click")
                                       (== src cancel_button))
                                  (== e.key "Escape"))
                              (progn
                                 (-> frame `close)
                                 (resolver nil))
                              (or (and (== e.type "click")
                                       (== src import_button))
                                  (== e.key "Enter"))
                              (progn
                                 (= file_to_symbol_mapping (harvest_values))
                                 (-> frame `close)
                                 (load_op)
                                 (resolver file_to_symbol_mapping))))))
       (view (div { `class: "juno-form" `style: "flex-grow: 1; "}
                     (div { `class: "juno-form-data" `style: "flex-grow: 1; "}
                          (div { } 
                               (dtext "Enter any symbol names you wish to use assign to the imported resources.")
                               (br)
                               (dtext "These will be globally accessible in the namespace") 
                               " " (b Environment.namespace) "."
                               (br)
                               (dtext "Click Import to complete the process."))
                          (br)
                          (dtable file_to_symbol_mapping 
                             {
                               `columns: ["Name" "Type" "Symbol/Path?" "Action"]
                               }))
                     (hr { `class: "LightHR" })
                     (div cancel_button import_button ))))
      (declare (function new_buffer image_viewer floating_div)
               (global new_buffer image_viewer floating_div))
      (when (> files.length 0)
         (= result
            (new Promise
               (fn (resolve reject)
                  (progn
                     (declare (function resolve reject))
                     (= resolver resolve)
                     (= frame
                        (floating_div view {
                                             title: (dtext "Import Local Files")
                                             on_close: (fn ()
                                                          (resolver nil))
                                             controls: true
                                             position: {
                                                         left: 10
                                                         top: 10
                                                         }
                                             }))
                     (attach_event_listener frame.view
                        `keydown
                        handle_event)
                     (attach_event_listener frame.view
                        `keyup
                        handle_event)
                     (attach_event_listener frame.view
                        `change
                        handle_event)
                     (attach_event_listener view
                        `click
                        handle_event)
                     (focus_to (first (-> view `querySelectorAll "input"))))))))
      result)
   {
     description: (+ "<br>The `load_files` function receives a FileList object and displays a user "
                     "interface element to the user to facilitate how the files are to be processed "
                     "in the browser system.  File actions can be specified for each file in the "
                     "list, such as embedding in a header element, opening the file in a buffer, or "
                     "creating a symbol reference to the contents.  There is no return value that is "
                     "meaningful as this function performs the dispatch of each file as specified in "
                     "the presented user interface elements.<br> ")
     usage: ["files:FileList" ]
     tags: ["files" "import" "embedded" "load" "embed" "browser"]
     })




(defun control_frame (options `& contents)
  (let
      ((has_control_bar? (and (> contents.length 1)
                              (has_class? "juno-buffer-bar" contents.0)))
       (content (if has_control_bar?
                     [(first contents)
                      (div { `class: "juno-view-content" }
                           (rest contents)) ]
                     (div { `class: "juno-view-content" }
                           (rest contents))))
       (elem (div (+ { tabindex: 0 control_id: (or options.id (generate_id "frame"))
                      class: (+  "juno-view-container"
                                  (or options.classes "")) }
                      (if options.style
                        { `style: options.style }
                        {}))
                   content)))
    ;(log "control_frame: has_control_bar: " has_control_bar? contents)
    (when (not has_control_bar?)
      (set_style [["height" "100%" ]] content))
    (when (is_array? options.events)
      (for_each (ev options.events)
                (destructuring_bind (event_type action)
                     ev
                   (console.log "making events: " event_type action)
                   (attach_event_listener elem event_type action))))
    elem)
  {
   `description: (+ "Creates and returns an element representing the external frame "
                    "of a control. The passed contents can contain a buffer bar as a "
                    "first element, which will be identified as such by having a "
                    "juno-buffer-bar class assigned to it. <br>"
                    "The passed contents (excluding the buffer bar) are wrapped in a"
                    "juno-view-content div, and the whole contents, including the optional "
                    "buffer bar element are wrapped in a juno-view-container div.<br><br>"
                    "The options are as follows: <br><br>"
                    "id:string - The assigned id for the control.<br>"
                    "style:string - A string containing css styling attributes that are assigned "
                    "to the juno-view-container div (the encompassing element).<br><br>"
                    "events:array - An array of array values in the form of pairs in the "
                    "form of [event_type:string action:fn] which are attached to the "
                    "juno-view-container element.")
   `usage: ["options:object" "elements:Elements"]
   `tags: ["ui" "controls" "control" "frame" "DOM" "Node" "element" ]
   })

(defun name_control (prefix)
  (let
      ((prefix (or prefix "Unnamed"))
       (name ""))
    (if (get_control_by_name prefix)
      (+ prefix " " (inc *view_count*))
      prefix)))




(defun symbol_browser (options)
   (let
       ((self {})
        (options (or options {}))
        (show_previews (not options.disable_preview))                                
        (id (generate_id "symbol_browser"))
        (name (name_control (or options.name "Symbol Browser")))                  
        (title_span (span { `class: "juno-title" } name))
        (path_span (span { `class: "juno-path" `style: "float: right" } ""))
        (buffer_commands_button (commands_button id))
        (stack [ ])
        (filter_span (span { `style: "margin-left: 8px; margin-right: 8px; font-family: var(--main-mono-space);" } ""))
        (filter_span_container (span { `style: "border-radius: 3px; margin-left: 10px; padding-top: 2px; padding-bottom: 2px; border: 1px solid var(--type-regexp-color);" } 
                                     (span { `style: "padding-left: 10px; padding-right: 10px; background: var(--type-regexp-color); padding-top: 2px; padding-bottom: 2px; color: wheat;" } (+ (dtext "Filter") ":"))
                                     filter_span))
        (olist_style "padding-block-start: 3px; margin-block-start: 0.2em; padding-inline-start: 2px; ")
        (li_style "")
        (control_status (div {  class: "juno-buffer-bar" }
                                buffer_commands_button
                                (cond
                                  (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span)
                                filter_span_container
                                path_span))
        (symbol_struct (symbols_by_namespace))
        (element_for_pos (fn (pos want_parent?)
                           (let
                               ((target_col nil))                                
                             (= target_col (-> cview `querySelector (+ "[pos='" (if pos pos 0) "']")))                             
                             (cond 
                               (and want_parent? target_col)
                               target_col
                               target_col
                               (or (-> target_col `querySelector ".juno-highlighted")
                                   target_col.children.0)))))
        (filter_by_text (fn (pos text)
                            (let
                                ((elems (aif (element_for_pos pos true)
                                             it.children
                                             []))
                                 (elem nil)
                                 (num_found 0)
                                 (elem_bank_found [])
                                 (elem_bank_not_found [])
                                 (target_focus nil)
                                 ;;(remove_class "filtered-hidden" elem) (add_class "filtered-hidden" elem)
                                 (clear_it (blank? text)))
                                (if clear_it
                                    (progn
                                        (remove_class "filtered-hidden" elems)
                                        (focus_to (element_for_pos pos))
                                        false)
                                    (progn
                                        (for_each (idx (range elems.length))
                                            (progn
                                                (= elem (prop elems idx))
                                                (if (starts_with? text elem.innerText)
                                                    (push elem_bank_found elem)
                                                    (push elem_bank_not_found elem))))
                                        (cond
                                            (== elem_bank_found.length 0)
                                            false ;; do nothing
                                            (> elem_bank_found.length 0)
                                            (progn
                                                (console.log "found: " elem_bank_found.length)
                                                (for_each (elem elem_bank_found)
                                                    (remove_class "filtered-hidden" elems))
                                                (for_each (elem elem_bank_not_found)
                                                    (add_class "filtered-hidden" elem))
                                                (focus_to elem_bank_found.0)
                                                true)))))))
                                       
                                
        (filter_state {
                      chars: []
                      col_num: nil
                      })
        (show_filter_state (fn ()
                               (progn
                                   (if (> (length filter_state.chars) 0)
                                       (set_style [["opacity" "1"]] filter_span_container)
                                       (set_style [["opacity" "0"]] filter_span_container))
                                   (set_prop filter_span
                                            `innerText (join "" filter_state.chars)))))
        (clear_selector (fn (update?)
                            (progn
                                (console.log "clear_selector: filter_state: " (as_lisp filter_state))
                                (when filter_state.col_num
                                    (filter_by_text filter_state.col_num ""))
                                (set_prop filter_state
                                          `chars []
                                          `col_num nil)
                                (when update?
                                    (show_filter_state)))))
        (pop_from_selector (fn (pos)
                               (progn
                                   (if (== pos filter_state.col_num)
                                       (progn
                                           (pop filter_state.chars)
                                           (filter_by_text filter_state.col_num (join "" filter_state.chars)))
                                       (clear_selector))
                                   (show_filter_state))))
        (push_into_selector (fn (pos k)
                              (progn
                                  (defvar elems nil)
                                  (cond
                                      (eq nil filter_state.col_num)
                                      (progn
                                         (set_prop filter_state
                                                   `col_num
                                                   pos)
                                         (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                             (push filter_state.chars k)))
                                      (eq pos filter_state.col_num)
                                      (progn
                                          (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                                (push filter_state.chars k)))
                                      else
                                      (progn
                                        (push_into_selector pos k)))
                                  ;; update the displayed state of our filter 
                                  (show_filter_state)
                                  )))
                                                      
                                         
                                         
        (handle_keyup (fn (e)
                        (when (and e.srcElement
                                   (get_attribute e.srcElement "ctype"))
                          (let
                              ((elem e.srcElement)
                               (ctype (get_attribute elem "ctype"))
                               (pos (parseInt (get_attribute elem "pos")))
                               (final_pos stack.length))
                            ;(console.log "pos: " pos "press: " e)                           
                            (cond
                              (and (== e.key "ArrowUp")
                                   e.altKey)
                              (focus_to elem.parentElement.children.0)
                              (== e.key "ArrowUp")
                              (focus_to elem.previousElementSibling)
                              (== e.key "ArrowDown")
                              (focus_to elem.nextElementSibling)
                              (and (== e.key "ArrowLeft")
                                   (>= pos 0))
                              (progn
                                  (aif (element_for_pos (- pos 1))
                                   (focus_to it))
                                  (clear_selector true))
                              (== e.key "ArrowRight")
                              (progn
                                (console.log "moving to the right: " (element_for_pos (+ pos 1)))
                                (aif (element_for_pos (+ pos 1))
                                     (focus_to it)
                                     (focus_to (element_for_pos (+ pos 1) true))) ;; didn't get a standard list, it's probably a value of sort..
                                (clear_selector true))
                              (== e.key "Enter")
                              (progn
                                  (handle_event e)
                                  (handle_click e))
                              (== e.key "Backspace")
                              (pop_from_selector pos)
                              (== e.key "Tab")
                              nil
                              (> e.keyCode 47)
                              (progn
                               (push_into_selector pos e.key)
                               (console.log "filter state: " (as_lisp filter_state))))))))
                                                                                                                              
        (handle_click (fn (e)
                          (when (and e.srcElement 
                                     (get_attribute e.srcElement "ctype"))
                              (console.log "handle_click: " e.srcElement)
                              (let
                                  ((elem e.srcElement)
                                   (ctype (get_attribute elem "ctype"))
                                   (pos (get_attribute elem "pos"))
                                   (final_pos stack.length))
                                  (when pos
                                      (= pos (parseInt pos)))
                                  (clear_selector true)
                                  
                                  (console.log "handle_click: pos: " pos "final_pos:" final_pos ctype elem.innerText stack)
                                  (remove_class "juno-highlighted" e.srcElement.parentElement.children)
                                  (add_class "juno-highlighted" e.srcElement)
                                  (cond
                                     (== ctype "nspace")
                                     (progn
                                         (= stack [])
                                         (render_view e.srcElement.innerText)
                                         
                                         ;; next display the first namespace
                                         (= stack [ elem.innerText ])
                                         (render_view))
                                     (and (== ctype "sym")
                                          (== pos final_pos))
                                     (progn
                                         (push stack elem.innerText)
                                         (console.log "STACK is now: " stack)
                                         (render_view))
                                     (< pos final_pos)
                                     (progn
                                         (= stack (-> stack `slice 0 pos))
                                         (push stack elem.innerText)                                         
                                         (console.log "mid stack click: stack now: " (as_lisp stack) "view children:" (length cview.children) (range cview.children.length))
                                         (for_each (child_num (-> (range cview.children.length) `reverse))
                                            (progn
                                               (console.log "child_num: " child_num (prop cview.children child_num) (parseInt (get_attribute (prop cview.children child_num) `pos)))
                                                (when (> (parseInt (get_attribute (prop cview.children child_num) `pos)) (- stack.length 1))
                                                    (-> (prop cview.children child_num) `remove))))
                                         (render_view))                                         
                                     (== e.srcElement.tagName "LI")
                                     (progn
                                      (push stack  elem.innerText)                                 
                                      (render_view)
                                      ))))))
                            
        (cview (div { `style: "" `class: "juno-symbol-browser" }))
        (has_children? (fn (val)
                           (and (is_object? val)
                                (> (length val) 0))))
        (next_possibles (fn ()
                            (let
                               ((path (conj [ "context" "scope" ] (or (rest stack) [])))
                                (ns (first stack))
                                (idx -1)
                                (val nil))
                            (assert ns "No namespace yet - invalid stack")
                            (= val (resolve_path path (-> Environment `get_namespace_handle ns)))
                            (console.log "next_possibles: namespace:" ns path "value: " val)
                            (when options.on_select
                              (options.on_select ns (rest stack)))                            
                            (cond 
                              (is_function? val)
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   (value_to_dom val))
                              (is_array? val)                                                           
                              (for_each (symb (resolve_path path (-> Environment `get_namespace_handle ns)))
                                 (progn
                                     (inc idx)
                                     (li { `tabindex: 0 `ctype: (if (is_object? symb) "sym" (lowercase (subtype symb)))
                                       `pos: stack.length
                                       `title: (subtype symb)
                                       `class: (+ "juno-list-item " (if (has_children? symb) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb)))
                                      `style: li_style } idx)))
                              (is_object? val)                                                    
                              (for_each (symb (sort (pairs (resolve_path path (-> Environment `get_namespace_handle ns)))
                                                    { `key: [ 0 ] }))
                                 (li { `tabindex: 0 `ctype: (if (is_object? symb.1) "sym" (lowercase (subtype symb.1)))
                                       `pos: stack.length
                                       `title: (subtype symb.1)
                                       `class: (+ "juno-list-item " (if (has_children? symb.1) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb.1))) 
                                       `style: li_style } symb.0))
                                                                                   
                              (is_function? options.render_preview)
                              (let
                                  ((elem (options.render_preview)))
                                (if elem
                                  (if (get_attribute elem "ctype")
                                    elem
                                    (progn
                                     (-> elem `setAttribute `ctype "val")
                                     elem))
                                  (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                       "The render_preview function didn't return an element as expected.  Check call.")))
                              
                              (is_string? val)
                              (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   val)
                              
                              else         
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: 100%;" }
                                 (value_to_dom val))))))

        (render_view (fn (ns_name)
                       (progn
                        (console.log "render_view: stack " stack)
                        (if (> stack.length 1)
                          (set_prop path_span
                                    `innerText (+ "[ "(join " " (rest stack )) " ]"))
                          (set_prop path_span
                                    `innerText ""))                                    
                        (clear_selector true)
                        (cond
                          (== stack.length 0) ;; initial state
                          (progn
                           (-> cview `replaceChildren
                              (ol { `pos: 0 }
                               (for_each (ns (sort (namespaces)))
                                         (li {`tabindex: 0
                                              `ctype: "nspace"
                                              `pos: 0
                                              `class: (+ "juno-list-item juno-namespace" (if (== ns ns_name) " juno-highlighted" ""))
                                              `style: li_style
                                              } ns))))
                           (focus_to (element_for_pos 0)))
                          else
                          (progn
                           (defvar next_elem (next_possibles))
                           (cond
                             (is_array? next_elem)
                             (progn
                                 (-> cview `appendChild
                                    (ol { `pos: stack.length  }
                                         next_elem))                                 
                                 (setTimeout (fn () (focus_to (element_for_pos stack.length))) 10))
                             (is_element? next_elem)
                             (progn
                              (-> cview `appendChild                                 
                                  next_elem)
                              (-> next_elem `setAttribute "pos" stack.length)                              
                              (focus_to next_elem)))
                           
                           (set_prop cview `scrollLeft (+ cview.offsetWidth 20)))))))
                                                                                                                               
                          
        (view (control_frame { `id: id  `events: [[ "click" handle_click]
                                                  [ "keyup" handle_keyup ]] }
                             control_status
                             cview))
        (resize (fn ()
                  (progn                           
                   (let
                       ((new_height (- (prop view.parentElement `offsetHeight) 20))
                        (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                     (set_style [[ "width" (+ "" new_width "px") ]
                                 [ "height" (+ "" new_height "px") ]]
                                view)
                     (when options.on_resize
                       (options.on_resize self))))))
        (resize_observer (new ResizeObserver resize))
        (on_focus (fn ()
                   (progn                  
                    (add_class "juno-focused" control_status ))))
        (initialized false)
        (initialize (fn ()
                      (when (and view.parentElement
                                 (not initialized))
                        (= initialized true)                       
                        (-> resize_observer `observe view.parentElement)
                        (render_view (current_namespace))
                        (push stack (current_namespace))
                        (render_view)
                        (defglobal *sbcview* cview))))   ;; TODO: REMOVE 
        
        (to_json (function ()
                           `[symbol_browser ,#options])))

    
     (set_prop options
               `id id
               `name name)                
     (set_prop self
               `view view
               `options options
               `name name
               `type "symbol_browser"              
               `initialize initialize
               `resize resize
               `toJSON to_json
               `on_focus on_focus)
     self))

(defun symbol_chooser (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((ns nil)
                      (target_path target_path)
                      (set_val (fn (selected_ns selected_path)
                                   (progn 
                                      (console.log "ns: " selected_ns selected_path)
                                      (= ns selected_ns )
                                      (= target_path selected_path)
                                      (cond
                                        (blank? ns)
                                        (set_disabled new_symbol_button)
                                        (not (blank? ns))
                                        (progn
                                         (set_enabled new_symbol_button)
                                         (set_prop new_symbol_button
                                                  `innerText (+ (dtext "New Global Value"))))))))
                                            
                      (new_symbol_button (button { `tabindex: 0 `title: (dtext "Create New Entry") `style: "margin-left: 8px; margin-right: 8px;  font-weight: bold; background: var(--highlight-bg-color);" } (dtext "New")))
                      (path_span (span { `tabindex: 0 `title: (dtext "Click to copy path")  `class: "juno-path" } ""))
                      (symbol_ctl (symbol_browser { 
                                                   `additional_elements: [(span { `class: "juno-title" `style: "color:var(--main-color)" } (dtext "Open A Location"))
                                                                          (span { `title: (dtext "Edit Mode") `class: "juno-mode" } (if type type  ""))
                                                                          new_symbol_button
                                                                          ] 
                                                    `on_select: set_val }))
                      (ok_button (button { `class: "juno-primary" `style: "min-width: 100px; margin-right: 20px; margin-left: 20px; float:right; font-weight: bold;" } "OK"))
                      (cancel_button (button { `style: "margin-left: 20px;" }   "Cancel"))
                      (dwin (dialog { `style: "height: 40%; width: 60%; overflow: hidden; padding: 2px;" }                                                                    
                                    (div { `style: "height: calc(100% - 50px);" }
                                         symbol_ctl.view)
                                    (br)
                                    (div { `class: "juno-button-group pure-button-group" `role: "group" }
                                         cancel_button
                                         ok_button))))
                   (attach_event_listener new_symbol_button
                                          `click
                                          (fn (e)
                                            (progn
                                             (aif (request_user_input (+ "" (dtext "Enter the name to be created in") " " ns) `text)
                                                  (progn
                                                   (-> dwin `remove)
                                                   (-> (-> Environment `get_namespace_handle ns)
                                                       `set_global it "")
                                                   (resolve { `namespace: ns `path: [ it ] }))))))
                   (attach_event_listener ok_button
                                          `click
                                          (fn (e)
                                            (do                                              
                                              (resolve {
                                                  `namespace: ns
                                                  `path: target_path
                                                  })
                                              (-> dwin `remove))))                   
                   (attach_event_listener cancel_button
                                          `click
                                          (fn (e)
                                            (do
                                              (-> dwin `remove)
                                              (resolve nil))))
                   (-> juno_container
                       `appendChild dwin)
                   (set_prop symbol_ctl.options
                      `temporary true)
                   (-> symbol_ctl `initialize)
                   (when (is_function? dwin.showModal)
                     (-> dwin `showModal))))))


(defun make_autocompletion_scores (analysis_object sorted_globals sorted_identifiers)
      (let
      ((result_set [])
       (keywords (try (compiler `[ true ] { `special_operators: true `env: Environment } )
                    (catch Error (e)
                       (progn
                          (log "error on compiler: " e.message)
                          (new Set)))))
       (included (new Set))
       (score 100000))
      (for_each (r (sort analysis_object.allocations))
         (progn
            (-> included `add r)
            (cond
               (contains? r analysis_object.globals)
               (push result_set
                  { `value: r `score: (dec score) `meta: "local (shadowed global)" })
               else
               (push result_set
                  { `value: r `score: (dec score) `meta: "local" }))))
      (for_each (r (sort analysis_object.symbols))
         (cond
            (contains? r analysis_object.allocations)
            true ;; we already placed it 
            else
            (progn
               (-> included `add r)
               (push result_set
                  { `value: r `score: (dec score) `meta: "local?" } ))))
      (for_each (r (sort analysis_object.keywords))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (dec score) `meta: "keyword" })))
      (for_each (r (sort analysis_object.globals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (dec score) `meta: "global" })))
      (for_each (r (sort analysis_object.literals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (dec score) `meta: "literal" })))
      (for_each (r (sort (to_array keywords)))
         (if (not (-> included `has r))
             (progn
                (-> included `add r)
                (push result_set
                   { `value: r `score: (dec score) `meta: "keyword" }))))
      
      (for_each (r (or sorted_globals (sort (to_array (all_globals)))))
         (if (not (-> included `has r))
             (push result_set
                { `value: r `score: (dec score) `meta: "global" })))
      
      (for_each (r (or sorted_identifiers []))
         (if (not (-> included `has r))
             (push result_set
                { `value: r `score: (dec score) `meta: "identifier" })))
      result_set)
   {
       `usage: ["analysis_object:object"]
       `description: (+ "Given the output of process_tree_symbols, returns a result_set to be provided to the Ace autocomplete callback for "
                        "suggestions for autocomplete.")
       `tags: ["editor" "analysis" "autocomplete" "session" "Ace"]
   })

(defun find_root_forms_for_buffer (buffer_text options)
   (let
      ((lines (split_by "\n" buffer_text))
       (ldat nil)
       (lnum -1)
       (running_depth_for_line 0)
       (new_depth nil)
       (last_line_max_col 0)
       (boundaries nil)
       (depth_positions [])
       (current_root_form nil))
      
      (for_each (line lines)
                (progn
                   (inc lnum)
                   (= ldat (analyze_text_line line))
                   
                   (= boundaries (sort (conj (for_each (o ldat.openers)
                                                [o 1 (prop line o) ])
                                             (for_each (c ldat.closers)
                                                [c -1 (prop line c)]))
                                       { `key: [ 0 ] }))
                   (= last_line_max_col (or (last ldat.closers) (length line)))
                   (for_each (t boundaries)
                      (progn
                         (= running_depth_for_line (+ t.1 running_depth_for_line))
                         (cond
                            (and (eq nil current_root_form)
                                    (== running_depth_for_line 1))
                            (progn
                               (= current_root_form {
                                                      `start_row: lnum
                                                      `start_col: t.0
                                                      `end_row: nil
                                                      `end_col: nil
                                                      }))
                            (and current_root_form
                                 (== running_depth_for_line 0))
                            (progn
                               (set_prop current_root_form
                                  `end_row lnum
                                  `end_col t.0)
                               (push depth_positions current_root_form)
                               (= current_root_form nil)))))))
      (if (and options.flexibility
               current_root_form
               (> running_depth_for_line 0)) ;; most likely unclosed form
          (progn
             (set_prop current_root_form
                `end_row lnum
                `end_col last_line_max_col)
             (push depth_positions current_root_form)
             (= current_root_form nil)))
      depth_positions)
   {
     description: (+ "Given a text value as a string and an optional options object, returns an array of objects, "
                      "each representing the starting and ending positions of each found form.  The returned objects "
                      "have the keys: start_row, start_col, end_row, and end_col, which will be numeric offsets "
                      "from line 0 and column 0 respectively.<br>"
                      "If an options object is given with the key flexibility set to true, then if the final "
                      "form is incomplete, will return the start to final part of the end form.")
     usage: ["text_buffer:string" "options:object"]
     tags: ["forms" "parsing" "syntax" "selection" ]
     })

(defun get_root_form_for_position (buffer_text row column flexibility_mode)
   (let
      ((root_forms (find_root_forms_for_buffer buffer_text { flexibility: (if flexibility_mode true false) } ))
       (target nil))
      (for_each (form (or root_forms []))
         (progn
            (when (and (>= row form.start_row)
                       (<= row form.end_row))
               (cond 
                  (or (and (== form.end_row form.start_row)
                           (>= column form.start_col)
                           (<= column form.end_col))
                  
                      (> (- form.end_row form.start_row) 0))
                  (progn
                     (= target form)
                     (break))))))
      target)
   {
     description: (+ "Given a text buffer, a row number (>= 0) and a column number (>= 0), returns an object that has the "
                     "position values for the enclosing form to a depth of 0.  The object returned has " 
                     "the following layout: <br>"
                     "{ start_row:int end_row:int start_col:int end_col:int }<br>"
                     "All values start at offset 0.")
     tags: ["form" "position" "selection" "text" "lisp"]
     usage: ["buffer_text:string" "row:int" "column:int" "flexibility_mode:?boolean"]
   })


(defun floating_div (contents options)
   (let
      ((close_button (button { `title: (dtext "Close") } "X"))
       (move_state nil)
       (expander_elem (div { `style: "position: absolute; right: 0px; bottom: 0px; width: 15px; height: 15px; cursor: nwse-resize; background: transparent;" }
                           ""))
       (full_block (div { `style: "z-index: 8; width: 100%; height: 100%; position: absolute; top:0px; left: 0px;" }))
       (dims nil)
       (top (cond
               (is_string? options.position.top)
               (+ options.position.top ";")
               (is_number? options.position.top)
               (+ "" options.position.top "px;")
               else
               (+ "" (+ 5 (random_int 10)) "px; ")))
       (left (cond
               (is_string? options.position.left)
               (+ options.position.left ";")
               (is_number? options.position.left)
               (+ "" options.position.left "px;")
               else
               (+ "" (+ 45 (random_int 10)) "%; ")))
       (initial_width (cond 
                         (is_string? options.position.width)
                         (+ options.position.width ";")
                         (is_number? options.position.width)
                         (+ "" options.position.width "px;")))
       (initial_height (cond
                          (is_string? options.position.height)
                          (+ options.position.height ";")
                          (is_number? options.position.height)
                          (+ "" options.position.height "px;")))
       (resize_mode false)
       (max_dims {
                  `width: 0
                  `height: 0
                  })
       (body_element nil)
       (block_on (fn (e)
                    (progn
                       (= dims (-> frame `getBoundingClientRect))
                       (= body_element (get_by_id "body"))
                       (= max_dims {
                                     `width: (prop body_element `offsetWidth)
                                     `height: (prop body_element `offsetHeight) })
                       (-> body_element `appendChild full_block)
                       (= move_state {
                                       mx: e.pageX
                                       my: e.pageY
                                       fx: dims.right
                                       fy: dims.top
                                       w: dims.width
                                       h: dims.height
                                       }))))
       (control_bar (div { `class: "juno-buffer-bar" style: "cursor: grab;" }
                 close_button
                 (or options.title "")))
       (end_drag (fn (e)
                    (progn
                       (= move_state nil)
                       (= resize_mode false)
                       (if (is_function? contents.resize)
                           (-> contents `resize))
                       (-> full_block `remove))))       
       (handle_drag (fn (e)
                      (when (and move_state
                                 (== e.buttons 1))
                         (if resize_mode
                            (set_style [["width"  (+ "" (Math.max 300 (Math.min (- max_dims.width 30) (+ dims.width (- e.pageX move_state.mx)))) "px")]
                                        ["height" (+ "" (Math.max 30 (Math.min (- max_dims.height 30) (+ dims.height (- e.pageY move_state.my)))) "px")]]
                                       frame)
                            (set_style [["top"  (+ "" (Math.max 0 (Math.min (- max_dims.height 30) (+ dims.top (- e.pageY move_state.my)))) "px") ]
                                        ["left" (+ "" (Math.max 0 (Math.min (- max_dims.width 30) (+ dims.left (- e.pageX move_state.mx)))) "px") ]]
                                       frame)))))
                                   
       (frame (div { class: "juno-floating-container" 
                     style: (+ "left: " left
                               "top: " top
                               (if (is_string? initial_width)
                                   (+ "width: " initial_width " ")
                                   "")
                               (if (is_string? initial_height)
                                   (+ "height: " initial_height " ")
                                   "")
                                (if (is_string? options.style)
                                    (+ "" options.style ";")
                                    ""))
                                  }
               (control_frame {}
                control_bar
                (cond
                   (and (is_object? contents)
                        contents.view)
                   contents.view
                   (is_element? contents)
                   contents
                   else
                   (value_to_dom contents)))
               expander_elem)))
      
      (attach_event_listener close_button
         `click
         (fn (v)
            (progn
               (when options.on_close
                  (options.on_close))
               (-> frame `remove))))
      
      (attach_event_listener control_bar
         `mousedown
         (fn (e)
            (block_on e)))
      (attach_event_listener expander_elem
         `mousedown
         (fn (e)
            (progn
               (= resize_mode true)
               (block_on e))))
      
      
      (attach_event_listener frame 
         `focusin
         (progn
            (add_class "juno-focused" control_bar)))
      
      (attach_event_listener full_block
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mousemove
                             handle_drag)
      (attach_event_listener full_block
                             `mousemove
                             handle_drag)
      (-> (get_by_id "body") `appendChild frame)
      ;; if we have a control, initialize it if it needs it since it is 
      ;; now mounted on the DOM
      (when contents.initialize
         (-> contents `initialize))
     
      (setTimeout (fn ()
                     (progn
                        (= dims (-> frame `getBoundingClientRect))
                        (set_style [["width"  (+ "" (Math.max 300 dims.width) "px")]
                                    ["height" (+ "" (Math.max 30  dims.height) "px")]]
                                   frame)
                        (when (is_function? options.on_display)
                           (-> options `on_display frame)))) 10)
      (if options.controls
         {
           `close: (fn ()
                      (progn
                         (when options.on_close
                            (options.on_close))
                         (-> frame `remove)))
           `view: frame
           }
         true))
   {
     description: (+ "<br><br>Given content in the form of a DOM structure, creates a draggable frame "
                     "that presents like a dialog box, and which does not affect the underlying "
                     "layout structure.  The presented frame can be modified with options.  The popup "
                     "frame includes a title bar with a close button by default.   This is a "
                     "non-modal structure, howerver by using the controls option in conjunction with "
                     "a `Promise`, evaluation of subsequent code can be prevented until the dialog is "
                     "closed.<br><br>#### Options   <br><br>position:object -An object with up to "
                     "four optional keys: left, top, width and height, which values control the "
                     "position of the box.  If a value is a string, then the value is treated "
                     "directly as a CSS directive, such as `45%`.  If the value is a number, it is "
                     "considered to be a pixel offset for that value.  <br>title:string -If provided, "
                     "this value will be used as the title bar.<br>style:string -Any CSS styling "
                     "directives to be passed to the outer frame `div` that functions as the "
                     "container for the content.<br>on_close:function -When present, this function is "
                     "called when the user has initiated a close operation with the close button.  "
                     "The return value of this function is ignored and so this function is purely "
                     "advisory.<br>on_display:function - This optional function is called after "
                     "the `floating_div` has been placed into the DOM.  The top level element of the "
                     "view is passed as an argument.<br>controls:boolean -If true, provides an "
                     "interface object to manage the floating div externally.  This provides a means "
                     "to close the floating div element and retrieve the view.  By default this "
                     "option is false. <br>If the controls option is true, then the interface object "
                     "returned will have a `view` element value, and a `close` function which will "
                     "close the window and should be called with no arguments. ")

     usage: ["contents:Element" "options:object"]
     tags: ["DOM" "ui" "html" "view" "floating" "dialog" ]
     })
(defun progress_bar (options)
   (let
      ((pbr (progress (or options {})))
       (set_value (fn (v)
                     (set_prop pbr `value v))))
      {
          `view: pbr
          `set_value: set_value
      })
   {
     description: (+ "This function, which takes an optional object which can specify initial "
                      "value, class, or style settings, returns an object with a `view` element and "
                      "a `set_value` function.  The `view` can be embedded in the DOM, and "
                      "the `set_value` can be used to pass a number between 0 and 1 to indicate the "
                      "amount of progress against the represented goal. ")
     tags: [`progress `ui `DOM]
     usage: ["options:?object"]
   })

(defun show_progress_popup(options)
   (let
      ((pbr (progress_bar (+ {
                               `style: "width: 100%;"
                               }
                            options)))
       (display_text
          (div { style: "margin-bottom: 5px;" } (or options.header "")))
       (dwin (floating_div
                (div { `style: "padding: 10px;" }
                   display_text
                   pbr.view)
                (+ {
                     controls: true
                     }
                  options))))
      {
        set_value: (fn (v)
                      (-> pbr `set_value v))
        set_text: (fn (text)
                     (set_prop display_text
                        `innerHTML
                        text))
        close: (fn ()
                  (progn
                     (-> dwin `close)
                     true)) })
   {
     description: (+ "When called, creates and displays a floating, non-modal popup window "
                     "that shows a progress bar with an optional title and header.<br>A handle "
                     "interface object is returned with methods for setting the value of the progress "
                     "bar with values between 0 and 1, inclusive, which correlates to the displayed "
                     "progress position.  If no initial value is provided, a \"busy\" type of progress "
                     "bar is displayed, indicating activity, but without showing relative progress as "
                     "no value has been set.<br><br>#### Options  <br><br>title:string -The text that "
                     "will appear in the title bar of the popup window.<br>header:string -The text "
                     "that is displayed above the progress bar to provide context into the current "
                     "activity.<br>value:number -A value between 0 and 1 indicating how much progress "
                     "to display in the progress bar.<br>Additionally the options object is passed to "
                     "both the `progress_bar` and the `floating_div` and so the options of those "
                     "functions can be used as additional parameters in this function.  For "
                     "additional information see those function\'s documentation.<br><br>#### "
                     "Interface  <br><br>close:functon - Call this function to close the "
                     "popup.<br>set_value: function - Call this function with a single numeric "
                     "argument as the work progresses with values between 0 and 1 to update the "
                     "progress bar\'s displayed position.  <br>set_text: function - When provided a "
                     "text string, this value will be displayed in the header text position. ")
     usage:["options:object"]
     tags: ["dom" "progress" "popup" "dialog" "UI" ]
     })

(defun monitor_control_tree ()
   (let
       ((view nil)
        (title_span (span { } "Control Structure"))       
        (update_timer nil))
     (if (get_by_id `control_tree_monitor)
       (notify "Control Tree Already Showing")
       (progn
        (setTimeout (fn ()
                      (set_prop title_span
                                `innerText
                                (dtext "Click to highlight a control")))
                    4000)
        (= view (div { `id: `control_tree_monitor  style: "background: var(--control-bg-color); color: var(--control-color);"}
                     (render_control_tree $root_controls)))
        (attach_event_listener view
                               `click
                               (fn (e)
                                 (let
                                     ((id (-> e.srcElement `getAttribute "control_id"))
                                      (body_element (get_by_id "body"))
                                      (dims nil)
                                      (highlighter nil)
                                      (control (if id (get_control_by_id id))))
                                   (when control
                                     (when control.view
                                       (= dims (-> control.view `getBoundingClientRect))
                                       (console.log "control dims: " control.name dims)
                                       (-> body_element `appendChild
                                           (= highlighter (div { `id: "highlighter" `class: "identification" `style: (+ "z-index: 7; position: absolute; top: " dims.top "px; left: " dims.left "px; width: " (- dims.width 5) "px; height: " (- dims.height 5) "px; border: 3px dashed red;") }
                                                           "")))
                                       (setTimeout (fn ()
                                                     (do 
                                                        (aif (get_by_id "highlighter")
                                                             (-> it `remove))
                                                        (-> highlighter `remove)))
                                                   1000))))))
                                   
        (= update_timer (setInterval (fn ()
                                     (progn                                        
                                        (-> view `replaceChildren (render_control_tree $root_controls))))
                                     1000))
        (floating_div view
                      {  `title: title_span
                         `on_close: (fn ()
                                     (progn
                                      (clearInterval update_timer)))
                       })))))

  

(defun handle_lisp_format_event (val editor)
  (progn    
    (when (and (== (- val.end.row val.start.row) 1)
              (== val.action "insert"))     
       (defvar indent_string (format_lisp_line val.end.row (function (rnum) 
                                                                     (-> editor.session `getLine rnum))))
       (when indent_string
        (-> editor.session `indentRows val.end.row val.end.row indent_string)))))

(defun_sync indent_editor_line (editor row_number options)
  (if (is_number? row_number)
    (let
        ((line (-> editor.session `getLine row_number))
         (orig_line (clone line))
         (indent_string (format_lisp_line row_number
                                          (or options.get_row
                                              (function (rnum) 
                                                        (-> editor.session `getLine rnum))))))
      (console.log "indent_row: " row_number "indent_string: " indent_string line)
      (if indent_string
        (progn
         (setq line (+ "" indent_string (trim line)))
         (console.log "line at " row_number " to be replaced with: " (JSON.stringify line))
         (if options.apply
           (progn
            (-> editor.selection `clearSelection)
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `remove (-> editor.selection `getRange))
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `replace (-> editor.selection `getRange) line)
            (console.log "indent_editor_line: get_line: " (JSON.stringify (-> editor.session `getLine row_number)))
            (-> editor.selection `clearSelection)
            true)
           line))        
        line))
    (throw EvalError "invalid row_number provided to indent_row")))

(defun_sync indent_editor_selection (editor)
  (let
      ((start nil)
       (end nil)
       (selected_range (clone (-> editor.selection `getRange))))
    
    (= start selected_range.start.row)
    (= end selected_range.end.row)
    (console.log "tab: start: selected_range: " (JSON.stringify selected_range))
    (-> editor.selection `clearSelection)
    (-> editor.selection `setSelectionAnchor start 0)
    (-> editor.selection `selectTo end 0)
    (-> editor.selection `selectLineEnd)
    (console.log "tab: start: fully selected_range: " (-> editor.selection `getRange))                                                   
    (defvar lines (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
                            (-> editor.session `getLine row_number)))
    (console.log "tab: lines: pre-change: " (clone lines))
    
    (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
              (progn
               (console.log "tab: [start]: [ " selected_range.start.row selected_range.end.row " ] analyzing row: " row_number ": " (JSON.stringify (prop lines (- row_number start))))
               (set_prop lines
                         (- row_number start)
                         (indent_editor_line editor row_number
                                     { get_row: (function (rnum)
                                                          (progn
                                                           (console.log "get_row: rnum: " rnum " relative: " (- rnum start))
                                                           (cond
                                                             (and (>= rnum start)
                                                                  (< rnum end))
                                                             (prop lines
                                                                   (- rnum start))
                                                             else
                                                             (-> editor.session `getLine rnum)))) ;; not impacted by the change
                                      } ))))
    
    (console.log "tab: adjusted lines: " lines)
    (console.log "tab:     lines joined: " (join "\n" lines))
    (-> editor.session `replace (-> editor.selection `getRange) (join "\n" lines))
    (-> editor.selection `selectLineEnd)
    ;(-> editor.selection `setRange selected_range)
    (console.log "tab: reselected fixed: " (-> editor `getCopyText))))


(defun_sync select_to_current_form (editor pos options)
  (if editor
    (let
        ((rng (-> editor `getSelectionRange))
         (already_selected? (if (and (== rng.start.row rng.end.row)
                                     (== rng.start.column rng.end.column))
                                false
                                true))
         (cpos (or pos 
                   (if already_selected?
                      (progn
                         (-> editor `navigateTo rng.start.row rng.start.column)
                         (-> editor `getCursorPosition))
                      (-> editor `getCursorPosition)))))
      (when cpos
        (= rng (find_last_paren editor cpos options))
        (when rng
          (-> editor.selection `clearSelection)
          (-> editor.selection `setRange rng)))
      rng)
    nil)
  {
   description: (+ "Given an editor and an optional position { row column }, if possible, "
                   "selects the innermost current form (expression) in the editor and "
                   "returns the range.")
   usage: ["editor:object" "pos:?object"]
   tags: ["editor" "selection" "form" "lisp" "editing" ]
   })
          
    
(defun set_word_wrap (control state wrap_at_column)
   (let
      ((target_editor 
          (cond 
             (and (is_control? control)
                  control.editor)
             control.editor
             (and control.renderer 
                control.session
                control.textInput)
             control
             else
             (throw TypeError "set_word_wrap: invalid control or editor provided"))))
      (cond
         (and (== state true)
              (is_number? wrap_at_column))
         (-> target_editor.session  `setOption `wrap wrap_at_column)
         (== state true)
         (-> target_editor.session `setOption `wrap true)
         else
         (-> target_editor.session `setOption `wrap false))
      (if state
         true
         false))
   {
     description: (+ "Given a control with an editor property, or an Ace editor object "
                     "directly, a state and an optional column number, will enable or disable word "
                     "wrap for the provided object.  If word wrap is turned on, `true` will be "
                     "returned, otherwise `false`. ")
     usage: ["control:object" "state:boolean" "wrap_at_column:number" ]
   })

       
(defun show_editor_keybindings (editor_control)
   (if (is_control? editor_control)
       (progn
          (dtable
             (reduce (bindpair (sort (pairs (editor_key_bindings editor_control.editor))
                                     { `key: [`0] }))
                (destructuring_bind (keysequence binding)
                   bindpair
                   (cond
                      (is_array? binding)
                      (for_each (binding binding)
                         [keysequence (or binding.description
                                          (from_key binding.name))])
                      (is_object? binding)
                      [keysequence (or binding.description
                                       (from_key binding.name))]
                      else
                      nil)))
             {
                 table_style: "width: 100%;"
                 columns: ["Key Sequence" "Description"]
                 display_search: true 
             }))
       (throw EvalError "show_editor_keybindings: requires a text_editor control as an argument")))

(defun show_key_bindings ()
   (let
      ((platform (get_operating_platform))
       (default_editor_keys (if (-> Environment `get_global "*orig_key_bindings*" nil)
                                (reduce (entry (values (-> Environment `get_global "*orig_key_bindings*")))
                                   (when (prop entry.bindKey platform)
                                      (to_object
                                         [[`name entry.name]
                                          [`description entry.description]
                                          [ (+ "" platform) (prop entry.bindKey platform) ]])))))
       
                                       
       (categories (reduce (k (keys *key_bindings* ))
                      (unless (== k "active")
                         k)))
       (td_style (function () 
                    { `style: "vertical-align:top; padding: 5px; border-bottom: 1px solid var(--main-accent-line);" } ))
       (table_values  (sort
                           (conj (-> (for_each (category categories)
                                        (for_each (binding (pairs (resolve_path [ category ] *key_bindings*)))
                                           (destructuring_bind (name entry)
                                              binding
                                              [ (prop entry platform)
                                               (from_key name)
                                               (from_key category)
                                               (or (prop entry `description)
                                                   "No Description") ] )))
                                     `flat 1)
                                 
                                 (for_each (binding default_editor_keys)
                                    [(prop binding platform)
                                     (from_key binding.name)
                                     "Editor"
                                     (or (prop binding `description)
                                         "No Description")]))
                           { `key: [`0] }
                            )))
      ;(log "Table values: " table_values)
      (dtable table_values
         {
           `columns: ["Key Binding" "Command" "Scope" "Description"]
           `display_search: true
           }))
   {
     `description: "Returns a table DOM element of the current key bindings."
     `usage: []
     `tags: ["help" "keys" "bindings" "display" ]
     })

(defun_sync select_root_form (editor pos)
   (if (and (is_object? editor)
            (is_object? pos))
       (let
          ((last_selection nil)
           (idx 0)
           (current_selection nil))
          ;; start with the current position
          (= current_selection (find_last_paren editor pos))
          (while (and (< idx 1000)
                      current_selection
                      (or (eq nil last_selection)
                          (not (and (== last_selection.start.column current_selection.start.column)
                                    (== last_selection.start.row current_selection.start.row)
                                    (== last_selection.end.column current_selection.end.column)
                                    (== last_selection.end.row current_selection.end.row)))))
             (progn
                (inc idx)
                (= last_selection current_selection)
                (= current_selection (find_last_paren editor current_selection.start))
                ))
          
          (aif current_selection
             {
               `start_row: it.start.row
               `start_col: it.start.column
               `end_row: it.end.row
               `end_col: it.end.column
               })
             ))
   {
     `usage: ["editor:object" "pos:object"]
     `description: "Given an editor and a position, returns the determined root form for the position."
     `tags: ["selection" "editor" "root" "form" "position"]
     })

(defun select_to_root_form (editor pos)
   (if editor
       (let
          ((cpos (-> editor `getCursorPosition))
           (pos (if pos
                    (select_root_form editor pos)
                     (select_root_form editor cpos))))
          (when pos
             (-> editor.selection `clearSelection)
             (-> editor.selection `setSelectionAnchor pos.start_row pos.start_col)
             (-> editor.selection `selectTo pos.end_row (+ pos.end_col 1))
             true))
       (throw TypeError "editor must be provided to select_to_root_form"))
   {
       description: (+ "Given an editor and an optional position, will select the complete form (to a depth of 0) if possible. "
                        "If given a position object with a row and column value, the function will use that instead.  If "
                        "succesful, the value true will be returned.  If no editor is provided, the function will throw a "
                        "TypeError.")
       usage: ["editor:object" "pos:?object"]
       tags: ["editor" "selection" "form" "lisp" "editing"]
   })


(defun get_juno_autocompletions (editor session pos prefix callback sorted_symbols identifiers)
   (let
      ((root_form (select_root_form editor pos))
       (collect_error (fn (e)
                         true))
       (text_data (+ "" (-> editor.session `getTextRange (new ace.Range root_form.start_row root_form.start_col root_form.end_row root_form.end_col)) ")"))
       (tokens (reader text_data { `suppress_throw_on_error: true on_error: collect_error  } )))
      (= tokens (make_autocompletion_scores (process_tree_symbols tokens prefix) sorted_symbols identifiers))
      ;(log "get_juno_autocompletions: tokens <-: " tokens)
      (callback null tokens))
   {
       `usage: ["editor:object" "session:object" "pos:object" "prefix:text" "callback:fn" "sorted_symbols:array"]
       `description: "Internally used by the editor for autocompletion."
       `tags: ["ace" "editor" "autocomplete" ]
   }) 
 
(defun clone_edit_session (session)
   (let
      ((s (new ace.EditSession (-> session `getDocument)
                               (-> session `getMode)))
       (undoManager (-> session `getUndoManager)))
      (-> s `setUndoManager undoManager)
      (-> s `setTabSize (-> session `getTabSize))
      (-> s `setUseSoftTabs (-> session `getUseSoftTabs))
      (-> s `setOverwrite (-> session `getOverwrite))
      (-> s `setBreakpoints (-> session `getBreakpoints))
      (-> s `setUseWrapMode (-> session `getUseWrapMode))
      (-> s `setUseWorker (-> session `getUseWorker))
      (-> s `setWrapLimitRange session.$wrapLimitRange.min session.$wrapLimitRange.max)
      (set_prop s session.$foldData
         (-> session `$cloneFoldData))
      s))

(defun eval_selected_text_in_place (ctl options)
    (progn
       (cond
          (== ctl.type "text_editor")
          (progc
             (let
                ((text nil)
                 (pos nil)
                 (editor (cond
                            (== ctl.type "text_editor")
                            ctl.editor
                            else
                            (throw TypeError "eval_selected_text_in_place: no text editor for provided control")))
                 (selection nil)  ;; range to replace with results
                 (evaluator nil)
                 (result nil))
                (= pos (-> ctl `get_selection))
                (if (and (== pos.start.row pos.end.row)
                         (== pos.start.column pos.end.column))
                    (select_to_current_form ctl.editor))
                ;; we should have an actual selection now if we didn't...
                (= selection (-> ctl `get_selection))
                (= text (-> ctl `get_selected_text))
                (if (blank? text)
                    (progn
                       (-> ctl `display_context_message (dtext "Nothing to evaluate at the cursor position")))
                    (progn
                       (= evaluator
                          (cond
                             (is_function? ctl.get_evaluator)
                             (-> ctl `get_evaluator)
                             options.evaluator_id
                             (progn
                                (aif (prop (get_control_by_id options.evaluator_id)
                                           `evaluate)
                                     it
                                     nil))))
                       (if (is_function? evaluator)
                           (progn
                              (alert_on_error (dtext "Evaluation Error")
                                              (= result (evaluator text false true true)))
                              (if (and (eq nil result)
                                       (or options.discard_nil_values
                                          (== "discard" (request_user_choice
                                                           (+ (dtext "The evaluation result is")
                                                              " "
                                                              (as_lisp result)
                                                              ".  "
                                                              (dtext "Insert or discard the result?"))
                                                           [[(dtext "Insert") "ok"]
                                                            [(dtext "Discard") "discard"]]
                                                           {
                                                             `no_cancel_button: true
                                                             }))))
                                  nil
                                  (progn
                                     (= result
                                        (cond
                                           (is_object? result)
                                           (if options.as_json
                                              (JSON.stringify result nil 2)
                                              (+ "" (pretty_print (as_lisp result))))
                                           (is_string? result)
                                           result
                                           else
                                           (+ "" (pretty_print (as_lisp result)))))
                                     (try
                                        (progn
                                           (if options.append
                                              (progn
                                                 (-> editor.selection `clearSelection)
                                                 (-> editor `navigateTo pos.end.row pos.end.column)
                                                 (set_prop pos.start
                                                    `row pos.end.row
                                                    `column pos.end.column)
                                                 (-> (-> editor `getSession) `replace pos result))
                                              (-> (-> editor `getSession) `replace selection result)))
                                        (catch Error (e)
                                           (progn
                                              (-> (-> editor `getSession) `replace selection text)
                                              (-> ctl `display_context_message (+ "Error on replace: " e.message))
                                              (log (+ (dtext "Couldn't replace text in editor") ":" (prop ctl.options `name) ": " e.message))
                                              (log e)))))))
                           (alert_box (dtext "Evaluation Error")
                                      (+ (dtext "No evaluator found for the control")
                                         " "
                                         ctl.options.name)))))))
          (== ctl.type "DOM_editor")
          (progc
             (console.log "eval_selected_text_in_place: DOM_editor" ctl options)
             (let
                ((selected (get_selection))
                 (id (gen_id "placeholder"))
                 (evaluator nil)
                 (elem nil)
                 (insert_content_into_dom (fn (result)
                                             (progn
                                                
                                                (doc_exec `insertHTML (+ "<span id='" (+ id "_pre") "' style=''>&nbsp;</span><span id='" id "' class='juno-type-" (lowercase (sub_type result)) "'>" result "</span><span id='" (+ id "_post") "' style=''>&nbsp;</span>") true)
                                                (select_element (get_by_id id))
                                                (doc_exec `removeFormat)
                                                (select_element (get_by_id (+ id "_pre")))
                                                (doc_exec `removeFormat)
                                                (select_element (get_by_id (+ id "_post")))
                                                (doc_exec `removeFormat)
                                                (remove_attribute  (get_by_id (+ id "_pre")) `id)
                                                (remove_attribute  (get_by_id id) `id)
                                                (remove_attribute  (get_by_id (+ id "_post")) `id)
                                                (collapse_to_end (get_selection)))))
                 (insert_result (fn (result)
                                   (cond
                                      (is_element? result)
                                      (insert_elem result)
                                      (or (is_control? result)
                                          (and (is_object? result)
                                               result.view))
                                      (progn
                                         (insert_elem result.view true)
                                         (when (is_function? result.initialize)
                                            (-> result `initialize )))
                                      (is_array? result)
                                      (for (val result)
                                         (insert_result val))
                                      (is_object? result)
                                      (if options.as_json
                                         (insert_elem_at_point (pre
                                                                    (JSON.stringify result nil 2)))
                                         (insert_elem_at_point (pre
                                                                    (+ "" (pretty_print (as_lisp result))))))
                                      (is_string? result)
                                      (insert_content_into_dom result)
                                      (is_number? result)
                                      (insert_content_into_dom result)
                                      else
                                      (insert_elem_at_point (pre (+ "" (pretty_print (as_lisp result))))))))
                                
                 (insert_elem (fn (result containerize?)
                                 (progn
                                    (log "inserting result")
                                    (doc_exec `insertHTML (+ "<span id='" (+ id "_pre") "' style=''>&nbsp;</span><div id='" id "'>PLACEHOLDER</div><span id='" (+ id "_post") "' style=''>&nbsp;</span>") true)
                                    (sleep 0.1)
                                    
                                    (= elem (get_by_id id))
                                    (if elem
                                       (progn
                                          (-> elem `replaceWith result)
                                          (select_element (get_by_id (+ id "_pre")))
                                          (doc_exec `removeFormat)
                                          (select_element (get_by_id (+ id "_post")))
                                          (doc_exec `removeFormat)
                                          (remove_attribute  (get_by_id (+ id "_pre")) `id)
                                          (remove_attribute  (get_by_id (+ id "_post")) `id)
                                          (if containerize?
                                             (wrap_in_resizable result true)))
                                       (notify "Cannot find placeholder")))))
                 (text (when selected
                          (-> selected `toString)))
                 (result nil))
                (declare (function insert_elem_at_point get_control_by_id wrap_in_resizable)
                         (global insert_elem_at_point get_control_by_id wrap_in_resizable))
                (if (blank? text)
                    (notify (dtext "Nothing to evaluate at the cursor position"))
                    (progn
                       (= evaluator
                          (cond
                             (is_function? ctl.get_evaluator)
                             (-> ctl `get_evaluator)
                             options.evaluator_id
                             (progn
                                (aif (prop (get_control_by_id options.evaluator_id)
                                           `evaluate)
                                     it
                                     nil))))
                       (if (is_function? evaluator)
                           (progn
                              (alert_on_error (dtext "Evaluation Error")
                                              (= result (evaluator text false true true)))
                              ;(-> selected `deleteFromDocument)
                              ;(-> selected `collapseToStart)
                              (insert_result result))
                              
                           (notify (+ "No evaluator for control " ctl.name)))))))))
    {
      description: (+ "Given a control with an editor, the selected text is evaluated "
                      "using the editors evaluator.  The evaluated selection is replaced with the result."
                      "<br>#### Options<br>"
                      "append:boolean - If true, the selected value isn't replaced but the result of the "
                      "evaluation is placed into the editor at the cursor's position.<br>"
                      "discard_nil_values:boolean - If true, a nil value (undefined or nil) will not be "
                      "placed into the editor's text.  Otherwise, if a nil value is returned the user "
                      "will be prompted to place the nil result in the buffer, or discard it.<br>"
                      "evaluator:function - An optional 'evaluator' function can be passed to be used "
                      "as the evaluator instead of the controls default evaluator.<br>"
                      "as_json:boolean - If true, the result will be placed as formatted JSON into the "
                      "editor.  The default is to place the result in formatted Juno notation.<br>")
      
      usage: ["control:object" "options:?object"]
      tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
      })

(defun evaluate_and_replace_at_point (options)
   (let
      ((ctl *last_focus*))
      (cond
         (== ctl.type "text_editor")
         (progn
            (focus_to_editor ctl)
            (eval_selected_text_in_place ctl
                                         (+ {} 
                                            (if (not (eq nil options.discard_nil_values))
                                                { discard_nil_values: options.discard_nil_values }
                                                { discard_nil_values: true })
                                            (if options.append
                                                { append: true }
                                                {}))))
         (== ctl.type "DOM_editor")
         (progn
            (eval_selected_text_in_place ctl options))
         ))
   {
     `description: (+ "Using the control in `*last_focus*`, calls the "
                      "eval_selected_text_in_place function with the provided options.  The result of "
                      "the evaluation will be placed into the focused editor, either as replacement "
                      "text or appended text.<br>The link is http://kinaknowledge.com.<br><br>### "
                      "Options <br><br>discard_nil_values:boolean -If true any nil values will not be "
                      "placed into the editor.  If false, the user will be prompted to place nil "
                      "values into the text.  The default is true.<br>append:boolean -If true, the "
                      "result of the evaluation will be appended into the editor at the point of the "
                      "cursor, or if text is selected in the editor, after the selection. ")
       `usage: ["options:object"]
       `tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })
(defun set_scroll_speed (ctl value)
   (if ctl.editor
      (progn
         (-> ctl.editor `setScrollSpeed (clamp value 1 10))
         (set_prop ctl.options
            `scroll_speed
            (clamp value 1 10))
         (-> ctl.editor `getScrollSpeed))
      (progn
         (log "set_scroll_speed: no editor for control: " ctl.name)))

   {
       description: (+ "Sets the scroll speed for the editor by taking a control with an " 
                       "editor and a value between 1 and 10, where 10 will scroll the fastest "
                       "and 1 will be the slowest scroll value.  Default speed is 5.  " 
                       "Return value will be the new scroll speed value.")
       usage: ["control:object" "value:number"]
       tags: ["editor" "scroll" "speed"]
   })

(defmacro defcontrol (name control_args allocations control_options)
   (let
      ((declared_allocations (each allocations first))
       (required_allocations [(quote render)])
       (user_allocations allocations)
       (cname (-> name `substr 2))
       (meta { `description: (or control_options.description "No description")
               `tags: (or control_options.tags [`control `ui `DOM ])
               `usage: (if (is_array? control_options.usage)
                           (conj control_options.usage
                                 [ "options:object" ])
                           nil) })
       (args (progn
                (cond
                   (is_array? control_args)
                   (conj control_args [ (quote options) ])
                   else
                   (throw SyntaxError (+ "defcontrol: " cname ": missing/malformed control arguments - check syntax")))))
       (control_options (if (is_object? control_options)
                            control_options
                            {}))
       (control_bar? (if control_options.control_bar
                        true)))            
       (assert name "control name is required: check syntax for defcontrol")
       (if (< (length (reduce (d declared_allocations)
                         (contains? d required_allocations)))
              (length required_allocations))
           (throw SyntaxError (+ "defcontrol: " cname " missing required declarations: must have render")))
       (cond
          (contains? (quote id) declared_allocations)
          (throw SyntaxError (+ "defcontrol: " cname " cannot declare id - to pass a custom ID to the control, pass id in options when instantiating the control."))
          (contains? (quote initialize) declared_allocations)
          (throw SyntaxError (+ "defcontrol: " cname " cannot declare initialize - use on_initialize")))
       
  ;; ok, now create the form to be returned..
      `(defun ,#name ,#args
          (let
             ((self {})
              (options (or options {}))
              (name (compute_name_for_control (or options.name ,#(from_key (desym_ref name)))))
              (id (or options.id 
                      (generate_id ,#name)))
              (initialized false)
              (title_span (span { `class: "juno-title" } name))
              (set_title (fn (title_text)
                            (set_prop title_span
                               `innerText
                               title_text)))
              (set_name (fn (new_name)
                           (when (and (is_string? new_name)
                                      (not (blank? new_name))
                                      (not (== new_name name)))
                              ;(log "setting_name: " name "->" new_name (is_control? (get_control_by_name new_name)))
                              (= name (compute_name_for_control new_name))
                              (set_prop options
                                 `name
                                 name)
                              (set_title name))))
              (command_button (commands_button id))
              (_parent_view nil)
              (check_observer (fn ()
                         (when (and _parent_view
                                    (not (== view.parentElement _parent_view)))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= _parent_view view.parentElement))))
              (content_view (div { `style: "overflow: hidden; height: 100%; width: 100%; background: var(--control-bg-color); color: var(--control-color);" } "uninitialized.."))
              (resize (fn ()
                         (when view.parentElement
                            (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               (check_observer)
                               (when options.on_resize
                                  (options.on_resize self))
                               ,#(if control_options.render_on_resize
                                     `(do_render)
                                     true)
                               ,#(if (contains? (quote on_resize) declared_allocations)
                                     `(on_resize self)
                                     [])
                               true))))
              (_sbox_handle nil)
              (open_search ,#(if control_options.allow_search
                                 `(fn ()
                                    (aif (-> view `querySelector ".ace_search_field")
                                         (focus_to it)
                                         (progn
                                            (= _sbox_handle 
                                                  (search_box
                                                     { 
                                                       controls: true
                                                       root_element: content_view
                                                       on_destroy: (fn ()
                                                                      (= _sbox_handle nil))
                                                       }))
                                            (-> view `append
                                              _sbox_handle.view))))
                                 nil))
              ,@user_allocations
              (control_status (if ,#control_bar?
                                  (div { `class: "juno-buffer-bar" }
                                   command_button
                                   (cond 
                                      (is_array? options.additional_elements)
                                      options.additional_elements
                                      else
                                      title_span)
                                   ,#(if (contains? (quote control_bar_elements) declared_allocations)
                                         (progn
                                            (prop (prop allocations (index_of (quote control_bar_elements) declared_allocations)) 1))
                                         []))
                                  nil))
              (do_render (fn ()
                            (let
                               ((new_view (render self)))
                               (if (and new_view
                                        (not (== content_view new_view)))
                                   (-> content_view `replaceChildren new_view))
                               (if _on_render
                                   (_on_render self)))))
              (resize_observer (new ResizeObserver resize))
              (view (control_frame (to_object
                                       [[`id id]
                                        [ `style ,#(or control_options.frame_style nil)]
                                        [`events ,#control_options.events ]])
                     (if ,#control_bar?
                         control_status
                         [])
                     content_view))
              
              (_on_render (fn ()
                             ,#(if (contains? (quote on_render) declared_allocations)
                                `(on_render self)
                                nil)))
                             
              (_on_focus (fn ()                           
                           (progn
                            ,#(if control_bar?
                                `(add_class "juno-focused" control_status)
                                `[])
                            ,#(if (contains? (quote on_focus) declared_allocations)
                                `(on_focus self)
                                `(focus_to view)))))
                                  ,
              (_on_destroy (fn ()                                     
                             (progn
                              ,#(if (contains? (quote on_destroy) declared_allocations)
                                  `(on_destroy self)
                                  `true))))
              (_to_json (function ()
                           (progn
                              ,#(if (contains? (quote to_json) declared_allocations)
                                    `(to_json)
                                    `[(quote ,#name) ,@control_args options]))))
              (initialize (function ()
                             (progn
                                (when (and view.parentElement
                                           (not initialized))
                                   (= initialized true)
                                   (= _parent_view view.parentElement)
                                   (-> resize_observer `observe view.parentElement)
                                   ,#(if (contains? (quote on_initialize) declared_allocations)
                                         `(on_initialize self)
                                         true)
                                   (do_render))))))
             (declare (function compute_name_for_control)
                      (global compute_name_for_control))
             (set_prop options
                `id id
                `name name)
             ,@(when (is_array? control_options.expose)
                  (for_each (method_set control_options.expose)
                     (destructuring_bind (method_name method_reference)
                        method_set
                     `(set_prop self
                         ,#method_name ,#method_reference))))
             ,#(if (contains? (quote menu_items) declared_allocations)
                   `(set_prop self
                       `menu_items menu_items)
                   [])
             ,#(if control_bar?
                  `(set_prop self
                      `show_control_bar 
                      (fn (state)
                         (progn
                            (if state
                               (remove_class "juno-display-none" control_status)
                               (add_class "juno-display-none" control_status))
                            (resize))))
                  `[])
             ,@(if control_options.allow_search
                  `[ (set_prop self `open_search open_search)
                     (set_prop self `next_search_result
                        (fn () (when _sbox_handle (-> _sbox_handle `next))))
                     (set_prop self `prior_search_result 
                        (fn () (when _sbox_handle (-> _sbox_handle `previous))))
                     (set_prop self `close_search 
                        (fn () (when _sbox_handle (-> _sbox_handle `destroy))))
                     ])
             ;; finally set the required self options
             (set_prop self
                `options options
                `name name
                `type ,#(desym_ref name)
                `view view
                `resize resize                
                `initialize initialize
                `initialized? (fn ()
                                 initialized)
                `toJSON _to_json
                `on_destroy _on_destroy
                `on_focus _on_focus)
             
             ;; and return the self
             self)
          ,#meta))
   {
     `description: (+ "The macro defcontrol creates a function in the current namespace that "
                      "implements the specified control features passed to the macro.  The macro "
                      "handles most of the boiler plate for a basic control, combining the passed "
                      "allocations and options to produce a standardized control constructor.  The "
                      "macro is similar in shape to a defun+let form with some differences.<br>Like "
                      "the defun macro, the first argument provides the name of the control that it "
                      "will be used to construct the name and type of the control.  Also similar to "
                      "defun, the second argument is an array containing any arguments for the "
                      "control.  Note that, mandatorily, an options argument will be appended as the "
                      "last argument of the argument list, so an empty array passed will cause the "
                      "control only to have an options argument.<br>The next argument is a series of "
                      "allocation forms that are integrated into a let allocation structure, and so "
                      "should be in the same form as the allocation block of the let operator.  For "
                      "example, the following:```(defcontrol a_simple_panel ()\n   ((render \n       (fn "
                      "() (div { } \"This is the view\")))))```<br><br>would meet the minimal "
                      "requirement for a control to be constructed.  The caller of this macro can have "
                      "as many allocation forms as needed to implement the required behavior of the "
                      "emitted control.   To place this control on screen, use ```(place_control "
                      "`right (a_simple_panel))```<br><br>Since there will be no top control bar "
                      "(title bar) on this simple control, use the `Controls` menu to remove it from "
                      "the screen.<br>The `defcontrol` macro makes symbols available to the provided "
                      "allocation forms in the evaluation context of the control that can be "
                      "referenced and used by the user provided forms.  These locally scoped symbols "
                      "are as follows:<br>self:object -The interface object "
                      "returned.<br>content_view:Element -The control\'s view (not including the "
                      "control_bar.  Effectively the contents of the control "
                      "view.<br>do_render:function -Calls the (render) function provided to the macro. "
                      " User code can call this function when a redraw is "
                      "required.<br>initialized:boolean -This value is true if the function is "
                      "initialized or false if it hasn\'t yet been.<br>options:object -The options "
                      "object passed to the control on instantiation.<br>set_name:string -Given a "
                      "string, sets the controls title and name, which can be used to reference the "
                      "specific instance of the control.   This function will handle name collisions "
                      "by appending a numeric value to the end of the string if a control with the "
                      "same name already exists.<br>set_title:string -Given a string, sets the title "
                      "bar only but doesn\'t rename the actual control.  Note that if using this "
                      "function to set the displayed text on the title bar, as opposed to set_name, "
                      "the other displayed references to the control in the application will still be "
                      "the controls `name` value, not the title, and so this can lead to confusion if "
                      "the title doesn\'t match the name.  The preferred option is to use set_name to "
                      "keep alignment between the name displayed on the title bar and the name "
                      "displayed in other areas of the application.<br>There are multiple functions "
                      "that are called upon certain events, which allow the caller to build customized "
                      "behavior and hook into the system when needed.  These functions are specified "
                      "in the allocation forms provided to the macro and are all optional except for "
                      "render:<br>render:function -This function returns the DOM structure assigned to "
                      "content_view and is what is drawn in the control\'s content container.  If the "
                      "function returns nil, nothing is done.  Can be used in conjunction with the "
                      "on_render below, which acts on the already drawn view.<br>on_focus:function "
                      "-When a focusing event occurs to the control, this function is called with the "
                      "self object of the macro.<br>on_render:function -If this function is specified "
                      "it will act as the render function so as to manipulate an already built view, "
                      "via the content_view in scope symbol, which is the contents of the controls "
                      "view.<br>on_resize:function -A resize function to invoke if a forced resize is "
                      "required.<br>control_bar_elements:array -If the control is specified with the "
                      "control_bar control_options set to true, the Elements in this array will be "
                      "placed into the control bar after any runtime additional_elements provided to "
                      "the options object.<br>menu_items:function -A function that is called on demand "
                      "that should return an array containing pairs of [menu_text menu_function] that "
                      "implement any command functionality for the menu.<br>on_destroy:function -When "
                      "the control receives a destroy call, this user provided function will be called "
                      "with the self object.  NOTE: This function should return the self object to "
                      "complete the destruction process.  If `nil` or other non-true value is "
                      "returned, the function will not be destroyed.<br>on_initialize:function -Upon "
                      "initialization, this function will be called with the self object. It should be "
                      "expected that the initialization should be called only once for a control "
                      "lifespan.<br>to_json:function -This synchronous function call can be used to "
                      "provide a customization hook for the control.  The return value must be a "
                      "structure that can be serialized into JSON form.<br>The final object, "
                      "control_options is meta data and other flags for the macro:<br>expose:array -An "
                      "array of pairs that specify [ `function_handle function_to_call ] that are "
                      "placed on the self interface and provide the API for the control.  In order for "
                      "a resource in the control scope to be accessed, it must be specified in this "
                      "option, otherwise the function remains effectively private to the "
                      "control.<br>usage:array -The argument specification for the "
                      "macrodescription:string - The description of the control that is registered in "
                      "the Environment.<br>control_bar:boolean -If a control bar is to be displayed on "
                      "the top of the control, set this to true.<br>frame_style:string -Any custom "
                      "style attributes to apply to the control frame.  These should be formatted in "
                      "the CSS manner: eg.  \"overflow: hidden;\" ")

       `usage: ["name:symbol" "control_arguments:array" "allocations:array" "control_options:object"]
       `tags: ["control" "define" "controls" "ui"]
   })

(defcontrol image_viewer (url)
   ((current_zoom 1)
    (img_dims {
             image_width: image_elem.width
             image_height: image_elem.height
             scale: 1
             })
    ;(zoom_elem (input { type: `range min: 10 max: 400 value: (* 100 current_zoom) }))
    (zoom_elem (input { `style: "width: 40px; text-align: center;" type: `number min: 10 max: 400 value: (* 100 current_zoom) } ))
    (set_auto_scale (fn (force?)
                       (progn
                          (cond 
                             (or force?
                                (not (has_class? `juno-button-on auto_button)))
                             (progn
                                (add_class "juno-button-on" auto_button)
                                (set_zoom 0))
                             (has_class? `juno-button-on auto_button)
                             (remove_class "juno-button-on" auto_button)))))
    (auto_button (button { style: "margin-left: 10px;" onclick: (fn (e) (set_auto_scale)) }  (dtext "Auto")))
    (zoom_controls (div { `style: "display: inline-block; float: right; " }
                        zoom_elem "%"
                        auto_button))
                   
    (image_elem (img { src: url alt: options.alt } ))
    (container (div { `style: "overflow: auto; height: calc(100% - 30px); width: calc(100% - 0px);" } 
                    image_elem))
    (on_resize (fn ()
                  (if (has_class? "juno-button-on" auto_button)
                      (set_zoom 0))))
    (set_zoom (fn (zoom_coef update?)
                 (progn
                    (cond 
                       (== zoom_coef 0)
                       (progn
                          ;(log "auto click: " (/ content_view.offsetWidth img_dims.image_width))
                          (set_prop img_dims
                             `scale
                             (/ content_view.offsetWidth img_dims.image_width))
                          (= update? true))
                       else
                       (progn
                          (remove_class "juno-button-on" auto_button)
                          (set_prop img_dims
                             `scale
                             (clamp zoom_coef 0.1 4))))
                    
                    (set_style [["width" (+ "" (* img_dims.image_width img_dims.scale) "px")]
                                ["height" "auto"]] image_elem)
                    ;(log "image: width: " (* img_dims.image_width img_dims.scale) img_dims.scale zoom_coef img_dims image_elem.width image_elem.height content_view.offsetWidth) 
                    (when update?
                       (set_prop zoom_elem
                          `value (parseInt (* img_dims.scale 100)))))))
    (to_json (function ()
                `(image_viewer ,#url 
                             ,#(+  options 
                                {
                                  `auto: (has_class? "juno-button-on" auto_button)
                                  `scale: img_dims.scale
                                  }))))
    (menu_items (fn ()
                   [["Reset Scale" (fn (e)
                                      (set_zoom 1 true))]
                    ["Auto Scale" (fn (e)
                                     (set_auto_scale true))]]))
    (render (fn ()
               container))
    (control_bar_elements [ zoom_controls ])
    (get_url (function ()
                url))
    (on_initialize (fn (self)
                      (progn
                         (set_prop img_dims
                            `image_width image_elem.width
                            `image_height image_elem.height)
                         (when (is_string? options.name)
                            (set_name options.name))
                         (attach_event_listener zoom_elem
                            `change
                            (fn (e)
                               (progn
                                  (set_zoom (/ (parseInt e.srcElement.value) 100) false))))
                         (when options.scale
                            (set_zoom options.scale))
                         (when options.auto
                            (set_auto_scale true))))))
   {
     description: (+ "The `image_viewer` control takes a url for an image plus an optional "
                     "`options` object, and creates a control that can display an image in the "
                     "panel.  The URL can be either a local or remote location, or a base64 encoded "
                     "data URL.<br><br>#### Options <br><br>name:string - The name of the control "
                     "(default is `Image Viewer`) that is displayed on the title bar, and which the "
                     "control can be referenced by.<br>auto:boolean - If true, the auto button is "
                     "turned on, and the image will scale to the dimensions of the panel it is "
                     "displayed.  The default is false.<br>scale:number - Given a scale value "
                     "(clamped between 0.1 and 4) displays the image scaled to the provided value.  "
                     "For example, a value of 0.1 will scale the image to 10% the original size, and "
                     "a value of 4 will display the image at 4 times the original size.  A value of 1 "
                     "will display the image with no scaling, the intrinsic image size.<br> ")
     tags: [ `image `img `display `ui `control `controls `picture ]
     control_bar: true
     expose: [ set_zoom get_url set_auto]
     usage: ["url:string" "options:object"]
   })

(defun go_to_line_number (control)
   (when (and (is_control? control)
              control.editor)
      (aif (request_user_input (dtext "Enter line number") `number)
           (-> control `move_to_position (int it) 0)))
   {
     description: (+ "Given an editor type control such as `text_editor`, presents a dialog "
                     "box asking for a line number to go to and then, once a line number has been "
                     "entered, moves the cursor and editor view to that line.  The position history "
                     "is updated as this function calls the `move_to_position` method if the editor "
                     "interface. ")
     usage: ["control:object"]
     tags: [`editor `line `row `jump `go `position `ui]
   })

(defun find_symbol_definition (symbol symbol_map current_pos root_form)
   (if (and symbol symbol_map)
       (let
          ((locations (resolve_path [`symbols symbol ] symbol_map))
           (def_locs [])
           (prior_sym nil)
           (last_chain nil)
           (in_form? false)
           (tmp [])
           (closest nil)
           (closest_symbol_to_pos nil)
           (calc_dist (fn (pos1 pos2)
                         (let
                            ((total_idx (Math.min pos1.length pos2.length))
                             (deltas 
                                (for_each (idx (range total_idx))
                                   (- (prop pos1 idx)
                                      (prop pos2 idx)))))
                            deltas)))
           (cpos (or current_pos nil))
           (root_form (or root_form nil))
           (prior_loc nil)
           (score 0)
           (top_score 0)
           (global_definers [list "defun" "defglobal" "defun_sync" "defmacro" "defcontrol" "defparameter" "defvalue"])
           (last_pos_chain_str nil)
           (last_pos_chain nil))
          
          (when (> __VERBOSITY__ 0)
             (log "find_symbol_definition: symbol: " symbol "symbol_map:" symbol_map)
             (log "find_symbol_definition: " locations cpos root_form))
          (if locations
             (progn
                (for_each (locdata locations)
                   (destructuring_bind (row column op_chain pos_chain)
                      locdata
                      (= prior_sym nil)
                      (= last_chain nil)
                      (= last_pos_chain nil)
                      (= in_form? (and root_form 
                                       (>= row root_form.start_row)
                                       (<= row root_form.end_row)))
                      
                      (when (== row cpos.row)
                         (= closest_symbol_to_pos locdata)
                         (set_prop closest_symbol_to_pos
                            3
                            closest_symbol_to_pos.3))
                       
                             
                      (if (> op_chain.length 1)
                          (= prior_sym (last (but_last op_chain))))
                      
                      (= last_chain (last_n 2 op_chain))
                      (= last_pos_chain (last_n 2 pos_chain))
                      (= last_pos_chain_str (join "." last_pos_chain))
                      (= prior_loc (last def_locs))
                     
                      (when (> __VERBOSITY__ 0) 
                         (log "local_defs: " symbol [row column] prior_sym last_chain last_pos_chain locdata in_form?))
                      (cond
                         (and (is_nil? prior_sym)
                              (== last_chain.length 1)
                              (== "defglobal" (first last_chain)))
                         (push def_locs { row: row col: column `type: "defglobal" `chain: pos_chain } )
                         
                         
                         (and (not (contains? symbol global_definers)) 
                              (contains? (last op_chain) global_definers))
                         (push def_locs { row: row col: column `type: "global" `chain: pos_chain } )
                         
                         (and in_form?
                            (contains? (first last_chain) [list `defun `defun_sync `defmacro `defcontrol])
                            (== (last op_chain) symbol)
                            (== (last pos_chain) 2))
                         (push def_locs { row: row col: column `type: "named_function_argument" `chain: pos_chain } )
                         
                         (and in_form?
                            (== (first last_chain) `defcontrol)
                            (== (last last_chain) symbol))
                         (push def_locs { row: row col: column `type: "local_let" `chain: pos_chain } )
                         
                         (and in_form?
                            (== (first last_chain) "let")
                            (== (last last_chain) symbol)
                            (== (first last_pos_chain) 1) ;; in allocation form
                            (not (== prior_loc.row row))  ;; get rid of duplicates that can occur with patterns like (let ((options options))) where options is also an argument
                            (not (== prior_loc.pchain last_pos_chain_str)))
                         (push def_locs { row: row col: column `type: "local_let" `pchain: last_pos_chain_str `chain: pos_chain } )
                         
                         (and in_form?
                            (contains? (first last_chain) (list `fn `function `function* `destructuring_bind))
                            (== (last pos_chain) 1))
                         (push def_locs { row: row col: column `type: "anonymous_function_argument" `chain: pos_chain } )
                         
                         (and in_form?
                            (contains? (last last_chain) [ "defvar" "defconst" ])
                            (== (last pos_chain) 1))
                         (push def_locs { row: row col: column `type: "local_def" `chain: pos_chain } )
                         
                         (and in_form?
                            (== (last last_chain) "catch")
                            (== 2 (last pos_chain)))
                         (push def_locs { row: row col: column `type: "catch_alloc" `chain: pos_chain}))))))
          
          (when (> __VERBOSITY__ 0)
             (log "find_symbol_definition: def_locs: " def_locs)
             (log "find_symbol_definition: current_pos: " closest_symbol_to_pos))
          (if (> def_locs.length 1)
             (for_each (loc def_locs)
                (progn
                   (= score 0)
                   (set_prop loc
                      `tree_dist
                      (if closest_symbol_to_pos
                         (but_last (calc_dist loc.chain closest_symbol_to_pos.3))  ;; remove the last 
                         nil))
                   ;; how long do the paths match up until they don't match?
                   ;; once they don't match, then we deduct the remaining from the score 
                   (for_each (tpos loc.tree_dist)
                      (progn
                         (if (== tpos 0)
                             (inc score)
                             (break))))
                   (if (< score (length loc.tree_dist))
                       (= score (- score (- (length loc.tree_dist) score))))
                   (when (> score top_score)
                      (= top_score score)
                      (= closest loc))
                   (when (> __VERBOSITY__ 0)
                      (log "top score: " top_score " score: " score loc))))
             (= closest (first def_locs)))
          (when (and (is_nil? closest)
                     (> def_locs.length 0))
             (= closest (last def_locs)))  ;; for globals take the last definition in the buffer assuming it was compiled last
          (when (> __VERBOSITY__ 0)
             (log "closest is: " closest) )
          [closest]))
   {
     description: (+ "Given a symbol name (no binding prefix), a `symbol_map` as produced by "
                     "the function `symbol_map_for_buffer`,  an optional current_pos and an optional "
                     "root_form, if the symbol is present in the provided symbol map object, this "
                     "function will return the location of the symbol definition and type of "
                     "allocation, which could be of the following: <br>global:global scope - The "
                     "symbol\'s definition was found as a global type definition in the file as "
                     "defined via `defun`, `defun_sync`, `defglobal`, `defmacro`, `defcontrol`, "
                     "`defparameter` and `defvalue`.  <br>named_function_argument:local scope - The "
                     "symbol definition was determined to be provided as an argument to a named "
                     "function that the current position is within.  Named functions are defined by "
                     "`defun`, `defun_sync`, `defmacro` and "
                     "`defcontrol`.  <br>anonymous_function_argument:local scope - The symbol\'s "
                     "definition was determined to be provided as an argument to an anonymous "
                     "function.  The operation would be `fn`, `function`, `function*` or "
                     "`destructuring_bind`.<br>local_let:local scope - The symbol was defined as part "
                     "of the let allocation block.<br>local_def:local scope - The symbol was defined "
                     "as using the `defvar`, or `defconst` operators.<br>catch_alloc:local scope - "
                     "The symbol was defined in a catch form.<br>If no root_form or current_pos "
                     "objects are provided to the function, then only global symbols will be "
                     "identified as the function will have no way to determine the local position, "
                     "and hence what is lexically available in scope. ")
     usage: ["symbol:string" "symbol_map:object" "current_pos:object" "root_form:object"]
     tags: ["symbol" "scope" "define" "allocation" "symbols" "buffer"]
     })


(defun recalc_names_for_path (path_to_value)
   (let
      ((ctls (get_editors_for_path path_to_value)))
      (for_each (ctl ctls)
         (when ctl.recalculate_name
            (-> ctl `recalculate_name)))))

;; manages the` destruction of editors that are interested in the same path
;; one of them is the primary, the rest of them will be linked to their ids




(defun get_primary_editor_in_group (controls)
   (let
      ((primaries (reduce (editor (or controls []))
                      (when (not (-> editor `get_linked))
                         editor))))
      (first primaries)))

(defun get_editors_for_filename (filename)
   (when (is_string? filename)
      (reduce (control (current_controls))
         (when (and control
                    control.editor
                    control.options.filename
                    (== control.options.filename filename))
            control)))
   {
   `description: (+ "Given a filename, this function returns an array of all controls that have "
                    "the same filename as specified in the controls options object. ")
   `usage: ["filename:string"]
   `tags: ["groups" "control" "select" "editor" "filename" "file"]
     })
   
(defun get_controls_for_group (group_name)
   (when (is_string? group_name)
      (reduce (control (current_controls))
         (when (and control
                    (is_function? control.group_name)
                    (== (-> control `group_name) group_name))
            control)))
   {
     `description: (+ "Given a group_name, this function returns an array of all controls that have "
                      "the same group_name as returned by group_name function of the control. ")
     `usage: ["group_name:string"]
     `tags: ["groups" "control" "select" "editor"]
     })
   


(defun rename_editor_group (path)
   (try 
      (let
         ((editors (get_editors_for_path path))
          (primary_id nil)
          (primary nil))
         (= primary (first editors))  ;; take the primary editor or nil 
         ;log "rename_editor_group:  primary is: " (if primary (control_name primary) nil) "number of editors: " editors.length (each editors control_name) "path: " path)
         (when (> editors.length 0)
            (assert (eq nil (resolve_path [ `options `clone_editor_with_id ] primary) "rename_editor_group: BUG: editors for path > 0 and no primary editor")))
         (cond 
            (== editors.length 0)
            true ;; nothing for us to do
            (== editors.length 1)
            (progn
               (-> primary `set_unlinked)
               (-> primary `set_name (-> primary `group_name) true))
            else
            (progn
               (unless primary                ;; unless we already have a primary...
                  (= primary (take editors))) ;; take the first editor and make it the primary
               (= primary_id primary.options.id)
               ;(log "rename_editor_group: primary_id set to: " primary_id  "which is: " (control_name primary))
               (-> primary `set_name (-> primary `group_name) true)
               (-> primary `set_unlinked)
               (assert (eq nil primary.options.clone_with_editor_id) "Primary has clone_with_editor_id set" )
               (for_each (editor editors)
                  (when (not (== editor primary))
                     (-> editor `set_linked primary.options.id)
                     (-> editor `set_name (-> primary `group_name)))))))
               ;(log "rename_editor_group: primary editor is " primary_id  "primary editor: " (control_name primary))
               ;(log "rename_editor_group: editors_for_path: " (control_name (get_editors_for_path path))))))
      (catch Error (e)
         (log "rename_editor_group: error: " e.message))))

(defun clone_text_editor_control (editor_control)
   (let
      ((id editor_control.options.id)
       (new_name (if editor_control.group_name
                     (-> editor_control `group_name))))
      (declare (function text_editor)
               (global text_editor))
      (assert new_name "clone_text_editor_control: unable to get group name of the editor to clone")
      (if (layout_locked? (get_layout_for_control editor_control))
          (progn
             (notify (dtext "Target layout is locked"))
             nil)
          (when (and editor_control.editor id)
             (alert_on_error "Unable to clone the editor"
                             (text_editor (+ {} ;; start options
                                             editor_control.options ;; take existing options..
                                             { `id: (gen_id "text_editor")
                                                   `clone_with_editor_id: id })))))))
(defun close_editors_for_path (path except_for_id)
   (let
      ((editors (get_editors_for_path path))
       (destroyed []))
      (for (editor editors)
           (unless (and except_for_id
                        (== (control_id editor) except_for_id))
              (if (destroy_control editor)
                  (push destroyed (control_id editor))
                  )))
      destroyed)
   {
     description: (+ "Given a path to a `text_editor` control, and an optional control id to "
                     "preserve, will remove all editor controls for that path.  If the "
                     "argument `except_for_id` is provided, the editor associated with that id will not "
                     "be destroyed.  Returns a list of all text_editor control ids that have been "
                     "destroyed. ")
     usage: ["path:array" "except_for_id:string"]
     tags: ["editor" "path" "control" "text_editor" "close" "destroy"]
   })


(defun select_evaluator ()
  (let
      ((idx -1)
       (dups (new Set))
       (new_name nil)
       (selected_idx nil)
       (available (reduce (control (flatten (control_tree $root_controls)))
                          (when control.evaluate
                            (if (-> dups `has (or control.name "Untitled"))
                              (progn
                               (= new_name (+ (or control.name "Untitled")
                                             "-" idx))
                               (-> dups `add new_name)
                               [ (inc idx) new_name
                                 control ])
                              (progn
                               (-> dups `add control.name)
                               [ (inc idx) control.name control ])))))
       (selection_box (select { }
                              (map (fn (v)
                                     (option { `value: v.0 } v.1))
                                     (or available [])))))
    (= selected_idx
       (request_user_input (dtext "Select an available evaluator")
                           nil
                           { input: selection_box }))
    (when selected_idx
        (prop (prop available selected_idx) 2))))

(defun symbol_map_for_buffer (source_name source)
   (let
      ((symbol_locations {}))
      (reader source
         { source_name: source_name
           suppress_throw_on_error: true 
           symbol_receiver: (fn (syms)
                               (= symbol_locations syms)) })
      symbol_locations)
      {
        description: (+ "Given a source file name and a source text, returns an object "
                        "containing the symbols defined and used by the source text and their locations "
                        "in the source text.  <br>The output format is an object:<br>source_name:string "
                        "- The name of the provided source file<br>symbols:object - An object with keys "
                        "corresponding to the discovered symbols, each with an array with 4 components: "
                        "`[ row column operator_chain position_chain ]`.  Row and column are the "
                        "location of the symbol instance in the file.  The operator chain is the chain "
                        "of operators (or keys) leading up to the root of the form the symbol appears "
                        "in.  The position chain is the offsets within the forms, with each period `.` "
                        "referring to another depth level as constructed via `(`, `[` or `{`.  These "
                        "latter two elements are used by the principal consumer of this functions "
                        "output, `find_symbol_definition` to help determine the source of a particular "
                        "symbol in the editor.<br>")
        usage: ["source_name:string" "source:string"]
        tags: ["symbol" "scope" "define" "allocation" "symbols" "buffer"]
        })

(defun editor_options (ctl)
   (let
      ((editor (if (and (is_control? ctl)
                        ctl.editor)
                   ctl.editor
                   (throw TypeError "editor_options: requires a control with an editor as an argument")))
       (to_opts (fn (path)
                   (to_object
                      (for ((opt_name data_type) (pairs (resolve_path path *ace_option_description*)))
                           [(from_mixed_case opt_name)
                                      (or (-> editor `getOption opt_name)
                                          (cond
                                             (is_function? data_type)
                                             (data_type ctl)
                                             (== data_type `boolean)
                                             false
                                             (== data_type `string)
                                             ""
                                             (== data_type `number)
                                             0
                                             else
                                             nil))
                                          ]))))
       (current_value nil))
      
      { editor: (to_opts [ `editor ])
        session: (to_opts [ `session ]) }
         )
   {
     description: (+ "The function `editor_options` processes option keys in "
                     "`*ace_editor_options*` and retrieves the present value of the provided editor "
                     "control, or, if the value is undefined, returns a default based on the type "
                     "value in `*ace_editor_options*.  It handles the conversion of mixed case format "
                     "to snake-case and returns an object that represents the current state of editor "
                     "options listed in the `*ace_editor_options*` variable. ")
     tags: ["editor" "options"]
     usage: ["control:object"]
   })

(defun show_editor_options (ctl)
   (let
      ((opts (editor_options ctl))
       (dwin nil)
       (set_as_defaults_button (button { } (dtext "Save as Defaults")))
       (close_button (button { `style: "float: right" }  (dtext "Close")))
       (special_paths {})
       (editor ctl.editor)
       (on_change (function (category path val)
                     (try
                        (progn 
                           (cond
                              (== category "editor")
                              (progn 
                                 (-> editor `setOption (to_mixed_case (last path)) val))
                              (== category "session")
                              (-> editor.session `setOption (to_mixed_case (last path)) val))
                           val)
                           (catch Error (e)
                              (progn
                                 (notify (+ "Unable to set option: " (last path) ": " e.message))
                                 nil)))))
       (set_as_defaults (fn ()
                           (try
                              (progn
                                 (unless (resolve_path [ `editor `editor_defaults ] *env_config*)
                                    (make_path [ `editor `editor_defaults ] *env_config* {}))
                                 (unless (resolve_path [ `editor `session_defaults ] *env_config*)
                                    (make_path [ `editor `session_defaults ] *env_config* {}))
                                 (for ((key val) (pairs opts.editor))
                                      (set_path [ `editor `editor_defaults key ] *env_config* val))
                                 (for ((key val) (pairs opts.session))
                                      (set_path [ `editor `session_defaults key ] *env_config* val))
                                 (log *env_config*)
                                 (notify "Set As Editor Defaults"))
                              (catch Error (e)
                                 (notify (+ "Cannot set defaults: " e.message)))))))
                              
      (traverse *ace_option_description*
         (function (val path)
            (if (is_array? val)
                (make_path (conj 
                                 (for_each (pseg path)
                                    (from_mixed_case pseg))
                                 `values)
                           special_paths
                           val))))
      (= dwin (floating_div 
                 (div { `class: "juno-form" } 
                      (h4 (dtext "Options"))
                      (br)
                      
                      (div { `class: "juno-form-data" `style: "flex-grow: 1; overflow-y: auto; overflow-x: auto; "}
                           (h4 (dtext "Editor"))
                           (value_to_dom opts.editor
                                         {
                                           `editable: true
                                           `expand_all: true
                                           `disable_object_toggle: true
                                           `pretty_keys: true
                                           `on_change: (function (path val)
                                                          (on_change `editor path val))
                                           
                                            paths: special_paths.editor
                                         })
                           (hr { `style: "width: 100%;" })
                           (h4 (dtext "Session"))
                           (value_to_dom opts.session
                                         {
                                           `editable: true
                                           `expand_all: true
                                           `disable_object_toggle: true
                                           `pretty_keys: true
                                           `on_change: (function (path val)
                                                          (on_change `session path val))
                                             paths: special_paths.session
                                         }))
                      (div { `style: "margin-top: 10px" }
                           set_as_defaults_button close_button))
                 {
                   `title: "Editor Options"
                   `controls: true
                   }))
      (attach_event_listener set_as_defaults_button
         `click
         (fn ()
            (set_as_defaults)))
      
      (attach_event_listener close_button
         `click
         (fn ()
            (-> dwin `close))))
      {
        `description: (+ "Given an editor control, presents a floating window that allows the "
                         "options listed in `*ace_editor_options*` to be modified for the given editor.  "
                         "This utility also allows the settings to be set as defaults, by setting the "
                         "appropriate path in `*env_config*`.<br> ")
         tags: ["editor" "options" "DOM"]
         usage: ["control:object"]
      })


(defun set_edit_mode (control mode_name)
   (let
      ((target_mode (if (is_string? mode_name)
                        (last (split_by "/" mode_name))
                        nil))
       (control (if (and (is_control? control)
                         control.editor
                         (is_function? control.set_mode))
                    control
                    (throw TypeError "set_edit_mode: invalid control provided"))))
      (unless target_mode
         (throw TypeError "set_edit_mode: invalid mode - must be a string"))
      
      (-> control `set_mode mode_name))
   {
     description: (+ "If the provided control is a editor control and given a mode name such "
                     "as `juno` or `markdown`,  will set that control\'s editor to the given editor "
                     "mode if possible. ")
     tags: [`control `editor `mode `ui `modes]
     usage: ["control:object" "mode_name:string"]
   })

(defun_sync select_css_rule (editor pos)
   (let
      ((cpos (or pos
                 (-> editor `getCursorPosition)))
       (rng  (select_to_current_form editor cpos { 
                                       bracket_qualifier: (function (token)
                                                             (progn
                                                                (starts_with? "paren" token.type)))
                                       }))
       (stream nil)  ;; we will need to extend to grab the selectors
       (start nil)
       (token nil))
      (when rng
         (= stream (indirect_new TokenIterator editor.session rng.start.row rng.start.column))
         (= token (-> stream `getCurrentToken))
         (= token (-> stream `stepBackward))
         (while (and token
                     (and (not (starts_with? "paren" token.type))
                          (not (== "comment" token.type))))
            (progn
               (= token (-> stream `stepBackward))))
              
         (-> stream `stepForward)
         (= start { row: (-> stream `getCurrentTokenRow)
                    column: (-> stream `getCurrentTokenColumn) })
         (-> editor.selection `setSelectionAnchor start.row start.col)
         (-> editor `getSelectionRange))))

 

(defun evaluate_css_rule_text (text)
   (when (is_string? text)
      (let
         ((comps (split_by "{" text))
          (selector (first comps))
          (body_text (join " " (split_by "\n" (join " " (rest comps))))))
         (if (> selector.length 0)
             (progn
                (= selector (join " " (split_by "\n" (trim selector))))
                (if (ends_with? "}" body_text)
                    (= body_text (chop body_text)))
                (create_css_entry selector
                   (from_style_text body_text)))
             (notify "Cannot determine selector")))))
                
            

(defun_sync evaluate_css_rule (editor pos)
   (let
      ((rng (select_css_rule editor pos))
       (text nil))
      (if rng
         (progn
            (= text (-> editor `getCopyText))
            (evaluate_css_rule_text text)))))



(defun open_symbol_definition (symbol namespace initiating_control_id)
   (let 
      ((env (if (is_string? namespace)  ;; if given a namespace, get the symbol from the perspective of the namespace, otherwise just use the current
                (-> Environment `get_namespace_handle namespace)
                Environment))
       (symbol_defs (describe symbol true))
       (symbol_def (first (reduce (def (or symbol_defs []))
                             (when (and (not def.require_ns)  ;; pointer to original
                                        def.source_name)
                                def))))
       (comps (cond 
                 (is_string? symbol_def.source_name)
                 (split_by "/" symbol_def.source_name)
                 (is_array? symbol_def.source_name)
                 symbol_def.source_name
                 else
                 nil))
       (source_file nil)
       (path_details nil)
       (is_buffer? false)
       (src_files [ "base-io.lisp" "repl.lisp" "io.lisp" "core.lisp" "compiler.lisp" "reader.lisp" "environment.lisp" "build-tools.lisp" "core-ext.lisp" ])
       (ctl nil))
      (declare (function edit_file new_buffer get_control_by_name activity_box)
               (global edit_file new_buffer get_control_by_name activity_box))
      (activity_box { `style:  "width: 200px; height: 50px;" } 
            (set_content (+ (dtext "Locating symbol:") symbol))
            (cond
               (eq nil symbol_def)
               (notify (+ "Unable to find the definition information for " symbol))
               (eq nil symbol_def.source_name)
               (notify (+ "No source file listed for " symbol))
               (and (== (length comps) 1)
                    (contains? symbol_def.source_name src_files))
               (= source_file (+ "src/" symbol_def.source_name))
               (and (== (length comps) 1)
                    (is_array? symbol_def.source_name)
                    (is_symbol? (first symbol_def.source_name)))
               (progn
                  (= is_buffer? true)
                  (= source_file symbol_def.source_name))
               (> comps.length 1)
               (= source_file symbol_def.source_name))
            
            (cond
               (and is_buffer?
                  source_file)
               (progn
                  (new_buffer { `mode: `juno `type: `juno `path: (if (is_array? source_file) source_file [ source_file ]) })
                  (aif (get_control_by_name (last (split_by "/" source_file)))
                       (when (not (== it.options.id initiating_control_id))
                          (-> it `jump_to_local_definition symbol))))
               source_file
               (progn
                  (= source_file (normalize_file_path source_file))
                  (log "jumping to source symbol: " source_file)   
                  (edit_file { `filename: source_file })
                  (aif (get_control_by_name (last (split_by "/" source_file)))
                       (when (not (== it.options.id initiating_control_id))
                          (-> it `jump_to_local_definition symbol))))
               else
               nil)))
   {
     description: (+ "Given a symbol and an optional namespace, displays an editor containing "
                      "the definition of the symbol.  If the editor is already opened, the editor will "
                      "be switched to and the position moved to the location, otherwise, a new editor "
                      "will be opened with the source.  The source information is taken from the "
                      "Environment definition object containing the metadata for the symbol.<br>The "
                      "local namespace (or provided namespace) is searched first, and then core (if "
                      "not already in core).   ")
     tags: [ `source `editor `open `symbol `definition ]
     usage: ["symbol:string" "namespace:?string"]
     })

(defun init_mode_juno (control)
   (if control.editor
      (let
         ((editor control.editor)
          (symbol_map_dirty? true)
          (cached_symbols nil)
          (evaluate_root_form (fn ()
                                 (progn
                                    (if (== editor nil)
                                        (notify "Invalid (nil) editor")
                                        (progn
                                           (select_to_root_form editor)
                                           (-> control `evaluate_selection editor))))))
          (evaluator_control nil)
          (linked_editor (-> control `get_linked))
          (symbol_map nil)
          (intf {})
          ;; the special operators used by the compiler
          (comp_special_ops (compiler nil { `special_operators: true `env: Environment }))
          (current_position (fn ()
                               (-> editor `getCursorPosition)))
          (on_change (fn (val)
                        (progn
                            (= symbol_map_dirty? true)
                            (when (not linked_editor)
                               (handle_lisp_format_event val editor)))))
          (on_initialized (fn (control)
                             (= linked_editor (-> control `get_linked))))
          (on_destroy (fn ()
                         true))
          (identifier_regex (new RegExp "[A-Za-z*+0-9_\\$\\u00A2-\\uFFFF]+"))
          (jump_to_local_definition  (fn (symbol)
                                        (when (is_string? symbol)
                                           (= evaluator_control (-> control `get_evaluator_control))
                                           (when (or symbol_map_dirty?
                                                     (eq nil symbol_map))
                                              (= symbol_map (symbol_map_for_buffer (or control.options.filename control.options.path) (-> control `get)))
                                              (= symbol_map_dirty? false))
                                           (cond
                                              (-> comp_special_ops `has symbol)
                                              (notify (+ symbol " " (dtext "is a compiler operator")))
                                              symbol_map
                                              (let
                                                 ((locations (resolve_path [`symbols symbol ] symbol_map))
                                                  (def_locs [])
                                                  (cpos (current_position))
                                                  (root_form (select_root_form editor cpos)))
                                                 (if locations
                                                    (progn
                                                       (= def_locs (find_symbol_definition symbol symbol_map cpos root_form)))
                                                    (progn
                                                       (notify (dtext "No symbol map is available"))))
                                                 (when (> def_locs.length 1)
                                                    (log "text_editor: jump_to_local_definition: def_locs: " def_locs))
                                                 (cond
                                                    (and (== def_locs.length 1)
                                                         (not (eq nil def_locs.0.row)))
                                                    (progn
                                                       (-> control `move_to_position def_locs.0.row def_locs.0.col))
                                                    (== def_locs.length 1)
                                                    (progn
                                                       ;(= in_dispatch true)
                                                       (dispatch_event { command: "open_definition"
                                                                         source: (control_id control)
                                                                         args: [ symbol (-> evaluator_control `current_namespace) (control_id control) ] }))
                                                    ;(setTimeout (fn () (= in_dispatch false)) 1000)
                                                    
                                                    (> def_locs.length 1)
                                                    (progn
                                                       (notify "Ambiguous: multiple positions found"))
                                                    (== def_locs.length 0)
                                                    (progn
                                                       ;(= in_dispatch true)
                                                       (dispatch_event { command: "open_definition"
                                                                         source: (control_id control)
                                                                         args: [ symbol (-> evaluator_control `current_namespace) (control_id control) ] })
                                                       (notify (dtext "No local definition found"))))))))))
         (-> editor.session `setMode "ace/mode/juno")
         (-> editor `setOptions
            {
              `enableBasicAutocompletion:  [{ identifierRegexps: [ identifier_regex ]
                                                                getCompletions: (fn (editor session pos prefix callback)
                                                                                   (get_juno_autocompletions editor session pos prefix callback (-> control `symbols) (-> control `identifiers))) }]
              enableLiveAutocompletion: true
              enableSnippets: true
              })
         (= intf
            {
              evaluate_root_form: evaluate_root_form
              jump_to_local_definition: jump_to_local_definition
              on_change: on_change
              name: "Juno"   ;; display name with proper capitalization
              mode: "juno"   ;; the proper system mode name
              menu_items: (fn (ctoken)
                             (conj
                                (if (and ctoken
                                         (or (== ctoken.type "identifier")
                                             (== ctoken.type "asyncfunction")
                                             (== ctoken.type "function")))
                                    [[ {
                                         text: (dtext "Go to buffer definition")
                                         path: [`editor `jump_to_local_definition ]
                                         exec: (fn ()
                                                  (jump_to_local_definition ctoken.value))
                                         } ]
                                     [ {
                                         text: (dtext "Go to current definition")
                                         path: [`editor `jump_to_local_definition ]
                                         exec: (fn ()
                                                  (dispatch_event { command: "open_definition"
                                                                    source: nil
                                                                    args: [ ctoken.value ] }))
                                         } ]
                                     ["--" nil]]
                                    [])
                                
                                [[{
                                    text: (dtext "Select to root form")
                                    path: [`editor `select_form_root ]
                                    exec: (fn ()
                                             (select_to_root_form editor))
                                    }]
                                 [{
                                    text: (dtext "Evaluate root form")
                                    path: [`editor `evaluate_root_form ]
                                    exec: evaluate_root_form
                                    }]
                                 (if (is_clipboard_allowed?)
                                     [{
                                        text: (dtext "Copy root form")
                                        path: [`editor `copy_root_form ]
                                        exec:  (fn ()
                                                  (let
                                                     ((cpos (current_position)))
                                                     (select_to_root_form editor)
                                                     (-> navigator.clipboard `writeText (-> editor `getCopyText))
                                                     (sleep 0.02)
                                                     (-> editor.selection `clearSelection)
                                                     (-> editor `navigateTo cpos.row cpos.column)))
                                        }]
                                     [])
                                 ["--" nil]
                                 [{
                                    text: (dtext "Select current form")
                                    path: [`editor `select_current_form ]
                                    exec: (fn ()
                                             (select_to_current_form editor))
                                    }]
                                 [{
                                    text: (dtext "Evaluate selection")
                                    path: [`editor `evaluate_selection ]
                                    exec: (fn ()
                                             (-> editor `evaluate_selection editor))
                                    }]
                                 ["--" nil]]))
              })
         intf)
      (progn
         {
             `name: "Juno"
             `mode: "juno"
         })))

(defun init_mode_javascript (control)
    (if control.editor
      (let
         ((editor control.editor))
         (-> editor `setOptions {
                                  `enableLiveAutocompletion: true
                                  `enableBasicAutocompletion: true })
         (-> editor.session `setMode "ace/mode/javascript")
         {
             `name: "Javascript"
             `mode: "javascript"
         })
      (progn
         {
             `name: "JavaScript"
             `mode: "javascript"
         })))

(defun init_mode_css (control)
    (if control.editor
      (let
         ((editor control.editor))
         (-> editor.session `setMode "ace/mode/css")
         (-> editor `setOptions {
                                  `enableLiveAutocompletion: true
                                  `enableBasicAutocompletion: true })
         {
           evaluate_root_form: (fn ()
                                  (evaluate_css_rule editor))
           name: "CSS"
           mode: "css"
           menu_items: (fn (current_token)   ;; current token is the word or text at the cursor position
                          [[{
                              text: (dtext "Select rule")
                              path: [`editor `select_css_rule ]
                              exec: (fn ()
                                       (select_css_rule editor))
                              }]
                           [{
                              text: (dtext "Evaluate rule")
                              path: [`editor `evaluate_root_form ]
                              exec: (fn ()
                                       (evaluate_css_rule editor))
                              }]
                           [{
                              text: (dtext "Copy rule")
                              path: [`editor `copy_css_rule ]
                              exec: (fn ()
                                       (let
                                          ((cpos (-> editor `getCursorPosition)))
                                          (select_css_rule editor)
                                          (-> navigator.clipboard `writeText (-> editor `getCopyText))
                                          (sleep 0.02) ;; so that there is a brief selection flash to show something happened
                                          (-> editor.selection `clearSelection)
                                          (-> editor `navigateTo cpos.row cpos.column)))
                              }]
                           ["--" nil]])
                             
                         
           })
      (progn
         {
              name: "CSS"
              mode: "css"
         })))

(defun init_mode_sh (control)
    (if control.editor
      (let
         ((editor control.editor))
         (-> editor.session `setMode "ace/mode/sh")
         (-> editor `setOptions {
                                  `enableLiveAutocompletion: true
                                  `enableBasicAutocompletion: true })
         {
          name: "Shell"
          mode: "sh"
          })
      (progn
         {
          name: "Shell"
          mode: "sh"
          })))

(defun init_mode_markdown (control)
    (if control.editor
       (progn
          (-> control.editor.session `setMode "ace/mode/markdown")
          (set_word_wrap control true)
          {
            name: "Markdown"
            mode: "markdown" 
          })
       (progn
          {
              name: "Markdown"
              mode: "markdown"
          })))
      
(defun available_editor_modes ()
   (reduce (symbol (sort (symbols)))
      (when (starts_with? "init_mode_" symbol)
         (+ {
              `use: symbol
              }
           (eval ((+ "=:" symbol))))))
   {
     `description: (+ "Returns an array of available modes for the `text_editor` control.  "
                      "Each object in the array will have the keys:<br>name:string - The formal name "
                      "of the mode<br>mode:string - The mode name itself which is used to reference "
                      "resources that are used by the mode functionality such as behaviors and syntax "
                      "highlighting.<br>use:string - The function name the text editor control will "
                      "call to set up the mode.<br> ")
     usage: ["editor:?control"]
     tags: ["modes" "editor" "text_editor"]
   })

(defun get_all_editor_tokens (editor prefix)
   (let
      ((text_data (if editor
                      (or (-> editor `getValue) "")
                      ""))
       (scanner (new RegExp "[*A-Z+a-z$_][A-Za-z*$0-9_]{2,}" `g)))
      (sort (uniq (each (or (scan_str scanner text_data) []) `0)))))

(defun text_editor (options)
   (aif (and (not options.clone_with_editor_id)
             (get_control_by_name options.name))
        it
        (let
           ((options (+ {}  ;; default is an empty code editing buffer for lisp
                        { mode: "juno"
                          id: (generate_id "text_editor")   ;; id can be provided and will overide this generated ID
                          content: "" }
                        (if (is_object? options)
                            options
                            (progn
                               (notify "Invalid options object provided to editor - check config")))))
            (resize_observer nil)
            (group_name nil)
            (intf {})
            (initialized false)
            (config_value (function (key default_value)
                             (or (prop options key)
                                 (resolve_path [ `editor key ] *env_config*)
                                 default_value)))
            (buffer_commands_button (commands_button options.id))
            (evaluator_span (span { `class: "juno-evaluator" `style: "cursor: pointer" `title: (dtext "Name of the evaluator assigned to this buffer") } "-"))
            (nav_back_button (button { `title: (dtext "Step Backward In Position History") `style: "float: right" } "<"))
            (nav_forward_button (button { `disabled: true `title: (dtext "Step Forward In Position History") `style: "float: right" } ">"))
            ;; if we have a namespace in options use that for referencing paths
            (nseval (if (not (blank? options.namespace))
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))
            (is_dirty? false)
            (col_pos_span (span { `title: "Position (Row Column)" `style: "float: right;margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } "[0 0]"))
            (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" }
                               (if options.read_only
                                  "RO"
                                  "")))
            (wrap_span (span { `style: "width: 25px; min-width: 25px; display: inline-block;float: right; margin-right: 15px;margin-left: 15px;" `title: "Word Wrap" } ""))
            (mode "-")
            (mode_span (span { `class: "juno-mode" `title: "Current Editing Mode" `style: "float: right; margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } mode))
            (title_span (span { `class: "juno-title" `style: "cursor: pointer"  } options.name))
            (ns_span (span { `title: "Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } nseval.namespace))
            (control_bar (or options.control_bar
                             (div { `class: "juno-buffer-bar" }
                                  buffer_commands_button
                                  title_span
                                  ns_span
                                  evaluator_span
                                  locked_span
                                  nav_forward_button
                                  nav_back_button
                                  mode_span
                                  col_pos_span
                                  wrap_span)))
            (parent_view nil)
            (context_clear_timer nil)
            (display_context_message (function (value)
                                        (if (and (blank? value)
                                                 context_clear_timer)
                                            nil
                                            (progn
                                               (when context_clear_timer
                                                  (clearTimeout context_clear_timer))
                                               (= context_clear_timer nil)
                                               (when (not (blank? value))
                                                  (= context_clear_timer (setTimeout (fn () (= context_clear_timer nil)) 3000)))  ;; delay for clearing the message to quickly if a blank comes in
                                               (cond
                                                  (is_element? value)
                                                  (-> help_context_elem
                                                     `replaceChildren value)
                                                  else
                                                  (-> help_context_elem
                                                     `replaceChildren (span { `style: "display: inline-block; text-overflow: ellipsis; width: 100%; overflow: hidden" } (+ "" value))))))))
            (check_observer (fn ()
                               (when (not (== view.parentElement parent_view))
                                  (-> resize_observer `disconnect)
                                  (-> resize_observer `observe view.parentElement)
                                  (= parent_view view.parentElement))))
            
            (help_context_elem (div { `class: "juno-help-context" } ""))
            (context_bar (div { `class: "juno-context-bar" }
                              help_context_elem))
            (offset_depth 46)
            (editor_div (div { `class: "opacity-0" `style: (+ "height: calc(100% - " offset_depth  "px); width: 100%; overflow: hidden;font-family:var(--main-mono-space);") }))
            
            (view (div { `control_id: options.id `style: "overflow: hidden; height: calc(100% - 0px); display: inline-block; width: inherit;" }
                       control_bar
                       editor_div
                       context_bar))
            (ns_notifier_id (gen_id "ns_notifier"))
            (name_change_id (gen_id "name_change_notifier"))
            (evaluator nil)
            (perform_resize (fn ()
                               (when view.parentElement
                                  (check_observer)
                                  (html/set_style [["width" "calc(100% - 2px)"];           (+ "" (- (prop view.parentElement `offsetWidth) 2) "px")]
                                                   ["height" (+ "" (- (prop view.parentElement `offsetHeight) 0) "px")]]
                                                  view)
                                  (set_style [["height" (+ "calc(100% - " (+ (Math.max 0 control_bar.offsetHeight) (Math.max 45 context_bar.offsetHeight) -10)  "px)") ]] editor_div)
                                  ;(notify (+ "" context_bar.offsetHeight))
                                  (when editor
                                     (-> editor `resize)))))
            
            (editor nil)  ;; the editor object
            (set_read_only (fn (read_only?)
                              (progn
                                 (-> editor `setReadOnly read_only?)
                                 (set_prop options
                                    `read_only read_only?)
                                 (if read_only?
                                    (set_prop locked_span
                                       `innerText
                                       (dtext "RO"))
                                    (set_prop locked_span
                                       `innerText
                                       (dtext ""))))))
            (set_evaluator (fn (evaluator_function)
                              (when (is_function? evaluator_function)
                                 (= evaluator evaluator_function)
                                 (dispatch_event { command: "editor_change"
                                                   source: options.id
                                                   args: [ { `option: "evaluator" `value: evaluator_function } ] })
                                 (aif (get_keybinding "editor" "evaluate_selection")
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (-> editor.commands `addCommand
                                         {
                                           `name: "evaluate_selection"
                                           `bindKey: { `win: "Shift-Enter" `mac: "Shift-Enter" }
                                           `exec: evaluate_selection
                                           })))))
            (change_evaluator_name (fn (event_obj)
                                      (progn
                                         (log "Received evaluator name change: " event_obj)
                                         (aif (resolve_path [ `args 0 `value ] event_obj)
                                              (set_prop evaluator_span
                                                 `innerText
                                                 it)))))
            (mode_functions {})
            (set_mode (fn (mode_name)
                         (progn
                            (set_prop options
                               `mode
                               mode_name)
                            (cond
                               options.mode
                               (progn
                                  (-> editor.session `setMode (+ "ace/mode/" options.mode))
                                  ;(-> editor `setOptions {
                                    ;                       `enableLiveAutocompletion: true
                                   ;                        `enableBasicAutocompletion: true })
                                  ;(log "set_mode: looking for: " (+ "init_mode_" options.mode))
                                  (= mode_functions 
                                     (aif (resolve_path [ `context `scope (+ "init_mode_" options.mode) ] Environment ) 
                                       (try 
                                          (it intf)
                                          (catch Error (e)
                                             (notify (+ "Error on mode: " e.message)))))))
                               else
                               (progn
                                  (set_prop options
                                     `mode
                                     `text)
                                  (= mode_functions {})
                                  (-> editor.session `setMode "ace/mode/text")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })))
                            
                            (set_prop mode_span
                               `innerText
                               options.mode)
                            (dispatch_event { command: "editor_change"
                                              source: options.id
                                              args: [ { `option: "mode" `value: options.mode } ] })
                            (when options.on_mode_set
                               (options.on_mode_set mode_name)))))
            
            (set_theme (fn (theme_name)
                          (progn
                             (-> editor `setTheme (+ "ace/theme/" theme_name))
                             (set_prop options
                                `theme
                                theme_name)
                             (dispatch_event { command: "editor_change"
                                               source: options.id
                                               args: [ { `option: "theme" `value: theme_name } ] })
                             (when options.on_theme_set
                                (options.on_theme_set theme_name)))))
            
            (set_overscroll (fn (state)
                               (if state
                                  (progn
                                     (-> editor `setOption `scrollPastEnd true)
                                     (set_prop options
                                        `overscroll
                                        true)
                                     true)
                                  (progn
                                     (-> editor `setOption `scrollPastEnd false)
                                     (set_prop options
                                        `overscroll
                                        false)
                                     false))))
            
            (set_name (fn (new_name force)
                         (progn
                            ;; if we are not already called the new name go ahead and process the new name
                            (when (and (not (blank? new_name))
                                       (not (== (get_control_by_name new_name) intf)))
                               (set_prop options
                                  `name
                                  (if force
                                     new_name
                                     (compute_name_for_control new_name)))
                               (set_prop intf
                                  `name
                                  options.name)
                               ;(log "text_editor: set_name: "  options.id  " given " new_name  " set as: " options.name)
                               (dispatch_event { command: "editor_change"
                                                 source: options.id
                                                 args: [ { `option: "name" `value: options.name } ] }))
                            (set_prop title_span
                               `innerText
                               options.name)
                            options.name)))
            (rename_editor (fn ()
                              (if (cloned_editor?)
                                  (notify (dtext "Cannot change name of a currently cloned editor instance."))
                                  (let
                                     ((name_input (input { `tabindex: 0 `style: "width: 95%; font-weight: bold;" `value: options.name } ))
                                      (bbox (-> title_span `getBoundingClientRect))
                                      (rename_view
                                         (div { `id: "cmenu" `style: (+ "z-index: 10000; padding: 5px; margin: 0px; min-width: " (+ bbox.width 15) "px; background: inherit; position:absolute; top: " (- bbox.top 5) "px; left: "  bbox.left "px;") }
                                              
                                              name_input
                                              (div { `style: "padding: 5px;"}
                                                   (cond
                                                      (and (is_array? options.path)
                                                           (== "filesystem" (first options.path)))
                                                      (div
                                                         (div { `style: "padding: 5px; font-weight: bold" } "Save To File")
                                                         (div { `style: "padding: 5px; " } (join " / " (rest options.path))))
                                                      (is_array? options.path)
                                                      (div
                                                         (div { `style: "padding: 5px; font-weight: bold" } "Save To Symbol")
                                                         (for_each (comp options.path)
                                                            (span { `style: "padding: 5px;" } comp)))
                                                      (eq nil options.path)
                                                      (div
                                                         (div { `style: "padding: 5px; font-weight: bold" } "Temporary Buffer" )
                                                         (div { `style: "padding: 5px;" } "No Path"))
                                                      else
                                                      (div
                                                         (div { `style: "padding: 5px; font-weight: bold" } "Check Path")
                                                         (div (as_lisp options.path)))))))
                                      (cmenu_remove (fn ()
                                                       (aif (get_by_id "cmenu")
                                                            (-> it `remove)))))
                                     
                                     (declare (function resolver))
                                     ;(log "renaming editor" bbox)
                                     (cmenu_remove)
                                     (sleep 0.01)
                                     (-> (get_by_id "body")
                                         `append rename_view)
                                     (-> name_input `select)
                                     (focus_to name_input)
                                     (attach_event_listener name_input
                                        `keyup
                                        (fn (e)
                                           (progn
                                              (cond
                                                 (and (== e.key "Enter")
                                                      (not (blank? name_input.value)))
                                                 (progn
                                                    (set_name name_input.value)
                                                    (set_prop options
                                                       `group_name
                                                       options.name)
                                                    (cmenu_remove)
                                                    (focus_to_editor intf))
                                                 (== e.key "Escape")
                                                 (progn
                                                    (cmenu_remove)
                                                    (focus_to_editor intf))))))))))
            (refresh_symbol_time 10000)
            (refresh_symbol_timer nil)
            (symbol_positions_timer nil)
            (evaluate_selection (function (editor)
                                   (let
                                      ((rval nil)
                                       (copytext (if options.repl_mode
                                                     (-> editor `getValue)
                                                     (-> editor `getCopyText))))
                                      (if (blank? copytext)
                                          (if (not options.repl_mode)
                                              (display_context_message (dtext "Please highlight text to evaluate")))
                                          (try
                                             (progn
                                                (when refresh_symbol_timer
                                                   (clearTimeout refresh_symbol_timer))
                                                (= refresh_symbol_timer (setTimeout (fn () (progn (get_current_symbols) (= refresh_symbol_timer nil))) refresh_symbol_time))
                                                (= rval (evaluator copytext nil (not options.repl_mode) nil { `source_name: (or options.filename options.path) } ))
                                                (-> rval `then
                                                   (function (val)
                                                      (progn
                                                         
                                                         (try
                                                            (and options.on_evaluation
                                                               (-> options `on_evaluation copytext val))
                                                            (catch Error (e)
                                                               (log_error (+ "" options.name ": Received error from on_evaluation")
                                                                          e)))
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof val Error)
                                                                           (display_context_message (+ (subtype val)
                                                                                                       (if val.message (+ ":" val.message)
                                                                                                           "")))
                                                                           (is_function? val)
                                                                           (display_context_message (+ "<- " (subtype val)))
                                                                           else
                                                                           (progn
                                                                              (defvar chopped (as_lisp val))
                                                                              (if (> chopped.length 200)
                                                                                  (= chopped (+ (-> chopped `substr 0 200) "...")))
                                                                              (display_context_message (+ "<- " chopped)))))
                                                                     100)))
                                                   (function (e)
                                                      (progn
                                                         (notify "Failure on evaluation")
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof e Error)
                                                                           (display_context_message (+ (subtype e)
                                                                                                       (if e.message (+ ":" e.message)
                                                                                                           "")))
                                                                           else
                                                                           (display_context_message "Evaluation Failure")))
                                                                     100)))))
                                             (catch Error (e)
                                                (progn
                                                   (notify (+ (dtext "Unhandled error") ": " e.message ))
                                                   (console.error e))))))))
            
            (font_size (config_value `font_size 14))
            (increase_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.min 200 (+ font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (decrease_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.max 1 (- font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size)
                                      (set_cursor_position (prop position_history position_history_idx)))))
            (select_form_root (fn ()
                                 (progn
                                    (select_to_root_form editor)
                                    nil)))
            (evaluate_root_form (fn ()
                                      (let
                                         ((cpos (current_position)))
                                         (try 
                                            (if (is_function? mode_functions.evaluate_root_form)
                                                (-> mode_functions `evaluate_root_form editor)
                                                (display_context_message (+ "" options.mode ": " (dtext "No evaluation mechanism for mode" ))))
                                            (catch Error (e)
                                               (display_context_message (+ "Mode Error:" options.mode ": " e.message))))
                                         (sleep 0.02)
                                         (-> editor.selection `clearSelection)
                                         (-> editor `navigateTo cpos.row cpos.column))))
                                       
            (select_current_form (fn ()
                                    (select_to_current_form editor)))
            (get_selected_text (function ()
                                  (-> editor `getSelectedText)))
            (get_selection_object (function ()
                                     (-> editor.selection `getRange)))
            (get_lines (function (from to)
                          (-> editor.selection `getLines from to)))
            (is_selected? (function ()
                             (progn
                                (defvar rng (get_selection_object))
                                (not (and (== rng.start.row rng.end.row)
                                          (== rng.start.column rng.end.column))))))
            (last_bracket_match nil)
            (active_lisp_operator nil) ;; the last active lisp operator
            
            (find_active_lisp_operator (function ()
                                          (let
                                             ((new_op nil)
                                              (rnge (or (-> editor.session `getBracketRange (-> editor `getCursorPosition))
                                                        (find_last_paren editor)))
                                              (usage nil)
                                              (stime (time_in_millis)))
                                             (if rnge
                                                (progn
                                                   (= last_bracket_match rnge)
                                                   (= new_op (first (split_by *whitespace_regexp* (-> editor.session `getTextRange last_bracket_match))))
                                                   
                                                   (when (not (== new_op active_lisp_operator))
                                                      (= active_lisp_operator new_op)
                                                      (= usage (decorative_usage active_lisp_operator nil nil (function (val)
                                                                                                                 (progn
                                                                                                                    (symbol_finder val true)
                                                                                                                    ))))
                                                      (when (> __VERBOSITY__ 0)
                                                         (log "find_active_lisp_operator: " active_lisp_operator " usage is: " usage))
                                                      (if usage
                                                         (-> help_context_elem
                                                            `replaceChildren usage)
                                                         (-> help_context_elem `replaceChildren))
                                                      (when usage
                                                         (dispatch_event { `command: "display_usage" `source: options.id `args: [active_lisp_operator] }))
                                                      (when options.on_new_lisp_operator
                                                         (options.on_new_lisp_operator active_lisp_operator))
                                                       (when (> __VERBOSITY__ 0)
                                                          (console.log "find_active_lisp_operator: eval time: " (- (time_in_millis) stime) "ms"))))
                                                (progn
                                                   (= active_lisp_operator nil)
                                                   (-> help_context_elem
                                                      `replaceChildren)
                                                   (when options.on_new_lisp_operator
                                                      (options.on_new_lisp_operator nil)))))))
            
            (indent_row (function (row_number options)
                           (indent_editor_line editor row_number options)))
            
            (indent_current_row (function (editor)
                                   (when (or (== *last_focus* intf)
                                             options.repl_mode)
                                      (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                         (if (not (is_selected?))
                                             (progn
                                                (defvar row_number (prop (-> editor `getCursorPosition)
                                                                         `row))
                                                (console.log "tab: start: single line: " row_number)
                                                (indent_row row_number { `apply: true }))
                                             (indent_editor_selection editor))))))
            
            (bind_key (fn (key_command func)
                         (aif (get_keybinding "editor" key_command)
                              (progn
                                 (-> editor.commands `addCommand
                                    (to_ace_keybinding key_command it func))))))
            (get_current_token (fn ()
                                  (let
                                     ((pos (or pos (-> editor `getCursorPosition)))
                                      (stream (indirect_new TokenIterator editor.session pos.row pos.column)))
                                     (-> stream `getCurrentToken))))
            
            (set_wrap_mode (fn (state)
                              (progn 
                                 (set_word_wrap editor state)
                                 (set_prop options
                                    `word_wrap
                                    state)
                                 (if (== (-> editor `getOption `wrap) "off")
                                     (set_prop wrap_span
                                        `innerText "")
                                     (set_prop wrap_span
                                        `innerText (dtext "Wrap"))))))
            ;; keyword mapper support
            (internal_keyword_mapper (function (token)
                               (progn
                                  ;(console.log "editor keyword mapper: " options.name token)
                                  (defvar rval
                                     (if (contains? token *formatting_rules*.keywords)
                                        "keyword"
                                        (symbol_finder token)))
                                  
                                  rval)))
            ;; signal ready for saving
            (request_save (fn ()
                             (progn
                                (unless options.path
                                   (let
                                      ((symbol_data (symbol_chooser "Select or Create Symbol" options.mode)))
                                      (when symbol_data
                                         (set_prop options
                                            `namespace
                                            symbol_data.namespace)
                                         (set_prop options
                                            `path
                                            symbol_data.path)
                                         (set_name (last symbol_data.path) false)
                                         (if (not options.clone_with_editor_id)
                                             (set_prop options
                                                `group_name
                                                options.name))
                                         )))
                                (if options.path
                                   (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] })))))
            
            ;; handle the results of the save
            (save_complete (function (event_obj)
                              (progn
                                 (if options.create_mode
                                    (delete_prop options `create_mode))
                                 (display_context_message (+ "Saved " (cond
                                                                         (and (== event_obj.args.0.type "path")
                                                                              (is_array? event_obj.args.0.target))
                                                                         (join "~" event_obj.args.0.target)
                                                                         (== event_obj.args.0.type "filename")
                                                                         event_obj.args.0.target)))
                                 ;(log "editor: save_complete: " (clone event_obj))
                                 (remove_class "juno-needs-save" title_span)
                                 (delete_prop options `create_mode)
                                 (= is_dirty? false)
                                 (when options.on_save
                                    (-> options `on_save intf)))))
            (split_editor (fn (dir)
                             (let
                                ((new_editor nil))
                                (cond
                                   (eq nil options.path)
                                   (alert_box "Save Required" 
                                              (+ (dtext "This temporary editor must be saved to a symbol or linked to a file in order to split.")))
                                   (== dir "vertical")
                                   (progn
                                      (= new_editor (clone_text_editor_control intf))
                                      (when new_editor
                                         (alert_on_error "Unable to split"
                                                         (container_view_operation "split_right" intf new_editor))))
                                   (== dir "horizontal")
                                   (progn
                                      (= new_editor (clone_text_editor_control intf))
                                      (when new_editor
                                         (alert_on_error "Unable to split"
                                                         (container_view_operation "split_below" intf new_editor))))
                                   else
                                   (alert_box "Invalid Split Request" "Split commands  must be vertical or horizontal")))))
            ;; position tracking
            (max_history_length (if (is_number? options.max_history_length)
                                    options.max_history_length
                                    40))
            (position_history [])
            (position_history_idx 0)
            (current_position (fn ()
                                 (-> editor `getCursorPosition)))
            
            (set_cursor_position (fn (pos)
                                    (progn
                                       (-> editor `navigateTo pos.row pos.column)
                                       (-> editor `scrollToLine pos.row true nil)
                                       (focus_to_editor intf))))
           
            (update_position (function (force?)
                                (when editor
                                   (defvar current_pos (-> editor `getCursorPosition))
                                   
                                   (set_prop col_pos_span
                                      `innerText
                                      (+ "[" current_pos.row " " current_pos.column "]"))
                                   (set_prop options `cursor_position current_pos)
                                   
                                   ;; determine if we have a new lisp operator in lisp mode
                                   (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                      (find_active_lisp_operator))
                                   (when options.on_position_change
                                      (-> options `on_position_change current_pos editor))
                                   ;; record our position history so we can go back
                                   ;; if we are less then 8 rows difference, then
                                   ;; update it, otherwise push it onto the stack
                                   (try
                                      (progn
                                         (when (isNaN position_history_idx)
                                            (log "text_editor: update_position: position_history_idx isNaN!")
                                            (= position_history_idx (- position_history.length 1))
                                            (set_disabled nav_forward_button))
                                         (defvar last_pos (prop position_history position_history_idx))
                                         (when (eq nil last_pos)
                                            (log "last_pos is nil! and it shouldn't be: " position_history_idx))
                                         (if (or force?
                                                 (> (Math.abs (- current_pos.row (prop last_pos `row)))
                                                    8))
                                             (progn
                                                (inc position_history_idx)
                                                (-> position_history `splice position_history_idx 0 current_pos)
                                                (when (> __VERBOSITY__ 0)
                                                   (log "text_editor: update_position: recorded position" position_history_idx (prop last_pos `row) (Math.abs (- current_pos.row (prop last_pos `row)))))
                                                (when (> position_history.length max_history_length)
                                                   (take position_history)
                                                   (= position_history_idx (clamp position_history_idx 0 (- position_history.length 1)))))
                                             (progn
                                                (-> position_history `splice position_history_idx 1 current_pos))))
                                      (catch Error (e)
                                         (log "ERROR " options.name  " on position history update: " e.message)))
                                   
                                   
                                   )))
            (go_backward_in_position (fn ()
                                        (progn
                                           (= position_history_idx (Math.max 0 (- position_history_idx 1)))
                                           (set_enabled nav_forward_button)
                                           (set_cursor_position (prop position_history position_history_idx)))))
            (go_forward_in_position (fn ()
                                       (progn
                                          (= position_history_idx (Math.min (- position_history.length 1) (+ position_history_idx 1)))
                                          (when (== position_history_idx (- position_history.length 1))
                                             (set_disabled nav_forward_button))
                                          (set_cursor_position (prop position_history position_history_idx)))))
            (cloned_editor? (fn ()
                               (if options.path
                                  (> (length (get_editors_for_path options.path)) 1)
                                  false)))
            (search_focus false)
            (focus_event (fn (e)
                            (progn
                               (add_class "juno-focused" control_bar)
                               (handle_event e)
                               (if (and e
                                     (or (has_class? "ace_search_field" e.relatedTarget) 
                                         (has_class? "ace_search" e.relatedTarget)))
                                (progn
                                   (= search_focus true))
                                (progn
                                   (= search_focus false)
                                   )))))
            (on_focus (fn ()
                         (progn
                            (add_class "juno-focused" control_bar)
                            (if (or search_focus
                                    (search_focused?))
                               true
                               (progn
                                  (focus_to intf.editor))))))
            (orig_bindings nil)
            (build_key_bindings (fn (editor)
                                   (progn
                                      (console.log "building_key_bindings")
                                      ;; we need to remove any keybinding that interferes with our globals and then
                                      ;; rebuild to the right scope
                                      (= orig_bindings (clone (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor)))
                                      ;(defglobal *orig_key_bindings* orig_bindings)
                                      (when options.on_save
                                         (bind_key "on_save" request_save))
                                      (bind_key "increase_font_size" increase_font_size)
                                      (bind_key "decrease_font_size" decrease_font_size)
                                      (bind_key "select_form_root" select_form_root)
                                      (bind_key "select_current_form" select_current_form)
                                      (bind_key "indent_current_row" indent_current_row)
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (bind_key "evaluate_root_form" evaluate_root_form)
                                      (bind_key "jump_to_local_definition" jump_to_local_definition_command)
                                      (bind_key "evaluate_selected_in_place" (fn (editor)
                                                                                (progn
                                                                                   (setTimeout (fn ()
                                                                                                  (try
                                                                                                     (progn
                                                                                                        (defvar rval (eval_selected_text_in_place (get_control_by_editor editor)))
                                                                                                        true)
                                                                                                     (catch Error (e)
                                                                                                        (display_context_message "Error on evaluation: " e.message))))
                                                                                               10)
                                                                                   true)))
                                      
                                      (when (is_array? options.commands)
                                         (for_each (command options.commands)
                                            (do
                                               ;(console.log "optional commands: " command.name command)
                                               (-> editor.commands `addCommand
                                                  (to_ace_keybinding command.name command)))))
                                      true)))
            
            (linked_editor_name nil)
            (linked_editor nil)
            (data_type nil)
            (data_type_defaults { String: ""
                                  array:[]
                                  object: {} })
            ;; based on the contents of the options object set the editor's content
            (set_content (fn ()
                            (let
                               ((content nil))
                               (if options.data_type
                                  (if (eq undefined (prop data_type_defaults options.data_type))
                                      (throw TypeError (+ "Invalid data_type specified: must be either: " (join ", " (keys data_type_defaults))))))
                               (cond
                                  ;; do we have a filename?
                                  (and (is_string? options.filename)
                                       is_served?)
                                  (try
                                     (progn
                                        ;(log "text_editor: requesting file: " options.filename)
                                        (if options.create_mode
                                           (= content "")
                                           (= content (-> (fetch (+ "/files/" options.filename)) `text)))
                                        
                                        (if (is_string? content)
                                            (progn
                                               (-> editor `setValue content -1))
                                            (progn
                                               (-> editor `setValue "")
                                               (= content "")
                                               (display_context_message (+ "NOTICE: unable to fetch file: " options.filename " (editor set to local value)"))))
                                        (set_prop options
                                           `path
                                           (conj [ `filesystem ] (split_by "/" options.filename))))
                                     
                                     (catch Error (e)
                                        (progn
                                           (-> editor `setValue "")
                                           (= content content)
                                           (display_context_message (+ "ERROR on fetching: " options.filename " (editor set to local value)  " e.message))
                                           (log "Error on fetching file: " options.filename ": " e)
                                           (set_prop options
                                              `path
                                              (conj [ `filesystem ] (split_by "/" options.filename))))))
                                  
                                  ;; if we are given a filename, but we are not online we can't edit it
                                  ;; if we have previous content we can edit off line, but with a notice to the user
                                  (and (is_string? options.filename)
                                       (or options.content options.content_compressed))
                                  (progn
                                     (if (and (is_symbol? `LZString)
                                              options.content_compressed)
                                         (-> editor `setValue (LZString.decompressFromBase64 options.content_compressed) -1)
                                         (-> editor `setValue options.content -1))
                                     (= content options.content)
                                     (if (get_default [ `application `offline_content_warning] )
                                         (alert_box "Warning: Using cached content"
                                                    (div { `style: "" }
                                                         (dtext "The application isn't online, so the specified content cannot be fetched.")
                                                         (dtext "The last stored value is being used, but this may not match the remote content.")
                                                         (br)
                                                         (dtext "Information loss could occur if this editor's contents are subsequently saved to the server.")
                                                         (dtext "Be careful!"))))
                                     (set_prop options
                                        `path
                                        (conj [ `filesystem ] (split_by "/" options.filename)))
                                     (display_context_message (+ "Warning: Cached value of an online file")))
                                  (is_array? options.path)
                                  (progn
                                     (= content (resolve_path options.path nseval.global_ctx.scope))
                                     (cond
                                        (eq nil content)
                                        (progn
                                           (= content (or options.content
                                                          (and options.data_type
                                                             (prop data_type_defaults options.data_type))
                                                          ""))
                                           (make_path options.path nseval.global_ctx.scope content)
                                           (display_context_message (+ "New path: " (join "~" options.path) " with content type " (sub_type content)))))
                                        ;(is_string? content)
                                        ;(progn
                                         ;  (= content (eval content))))
                                     (if (not (== "String" (sub_type content)))
                                         (-> editor `setValue (pretty_print content) -1)
                                         (-> editor `setValue content -1)))
                                  (is_string? options.content_compressed)
                                  (-> editor `setValue (LZString.decompressFromBase64 options.content_compressed) -1)
                                  (is_string? options.content)
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue content -1))
                                  (or (is_object? options.content)
                                      (is_array? options.content))
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue (pretty_print content) -1)))
                               (assert (is_value? content) "assertion failure: content is not set in set_content")
                               (= data_type
                                  (sub_type content))
                               (set_prop options
                                  `data_type
                                  data_type)
                               ;; at this point content should be loaded and displayed and
                               ;; data_type should be properly set for the content that
                               ;; is being edited
                               options)))
            (symbol_finder (function (token want_metadata)
                              (if (and token
                                       cached_symbols)
                                 (let
                                    ((rval nil)
                                     (comps (split_by "/" token))  ;; split the token into namespace and symbol if applicable 
                                     (symbol_namespace (if (> comps.length 1)
                                                           (take comps)
                                                           nil))
                                     (cns (or symbol_namespace
                                              (if evaluator_control 
                                                 (-> evaluator_control `current_namespace)
                                                 nil)))
                                     (token (last comps))
                                     (search_order (if cns
                                                       (reduce_sync (ns (keys cached_symbols) )
                                                              (if (and (not (== ns `core))
                                                                       (not (== ns cns)))
                                                                  ns))
                                                       (keys cached_symbols))))
                                    
                                    (when cns
                                       (= rval (resolve_path [ cns token  ] cached_symbols))
                                       (if rval
                                          (set_prop rval 
                                             `namespace
                                             cns))
                                       (unless rval
                                          (= rval (resolve_path [ `core token  ] cached_symbols))
                                          (if rval
                                             (set_prop rval
                                                `namespace
                                                `core))))
                                    
                                    ;(when (> __VERBOSITY__ 0)
                                     ;  (log "symbol_finder: want_metadata: " want_metadata  " rval from level 1: " token "->" rval))
                                    (when (is_function? rval)
                                       (= rval { `type: (subtype rval) })
                                      (console.log (+ "symbol_finder: received a function back!  Should be an object -> check path in namespace:" cns " for " token " in cached_symbols: ") (resolve_path [ cns token ] cached_symbols)))
                                    (if rval
                                       (progn
                                          (if want_metadata
                                            rval
                                            (progn                                               
                                               (if (is_string? rval.type)
                                                 (= rval (lowercase (prop rval `type)))
                                                 (progn
                                                  (console.error "symbol_finder: .type property for " token " is not a string: " rval.type)
                                                  (= rval "identifier"))))))
                                                  
                                       (progn
                                          (for_each (ns search_order)
                                             (progn
                                                (= rval (resolve_path [ ns token ] cached_symbols))
                                                (when rval
                                                   (set_prop rval
                                                      `namespace ns)
                                                   (break))))
                                          ;(console.log "symbol_finder: search_order:" search_order " rval from level 2: " token "->" rval)
                                          (if rval
                                             (if want_metadata
                                                rval
                                                
                                                (= rval (lowercase (prop rval `type))))
                                             (if want_metadata
                                                (= rval {})
                                                (= rval "identifier")))))
                                    ;(console.log "symbol_finder: <- " cns token "want_metadata: " want_metadata rval)
                                    rval)
                                 (progn
                                    (console.log "symbol_finder: no cached_symbols: returning empty {} / identifier")
                                    (if want_metadata
                                       {}
                                       "identifier")))))
            
            (jump_to_local_definition (fn (symbol)
                                         (if (is_function? mode_functions.jump_to_local_definition)
                                             (-> mode_functions `jump_to_local_definition symbol))))
            (jump_to_local_definition_command (fn (editor)
                                                 (let
                                                    ((token (get_current_token)))
                                                    (if token
                                                       (jump_to_local_definition token.value)))))
                                                    
            (cached_symbols nil)
            (symbol_map nil)
            (sorted_symbols [])   ;; holds the symbols as determined by what is actually in the environment
            (identifiers [])      ;; holds the identifiers as to what is in the editor itself
            (get_current_symbols (fn ()
                                    (let
                                       ((start_time (time_in_millis))
                                        (symbol_set (if evaluator_control
                                                        (-> evaluator_control `available_symbols)))
                                        (processing_time (- (time_in_millis) start_time))
                                        (cns (if evaluator_control
                                                 (-> evaluator_control `current_namespace)))
                                        (in_path nil)
                                        (search_order nil))
                                       ;(log (control_name intf) "get_current_symbols: " symbol_set)
                                       (when (== intf nil)
                                          (log_error "text_editor: getting current symbols and shouldn't be since we are destroyed!"))
                                       (when (> processing_time 4000)
                                           (if (< refresh_symbol_time 60000)
                                               (log options.name ": symbol refresh time is slow, setting refresh update delay to 60 seconds after last activity"))
                                           (= refresh_symbol_time 60000))
                                       (when (is_object? symbol_set)
                                          (= cached_symbols symbol_set)
                                          (= search_order
                                             (if cns
                                                (conj [ cns `core ] 
                                                      (reduce_sync (ns (keys cached_symbols) )
                                                         (if (and (not (== ns `core))
                                                                  (not (== ns cns)))
                                                             ns)))
                                                (keys cached_symbols)))
                                          (= sorted_symbols
                                             (uniq (flatten
                                                        (for_each (ns search_order)
                                                           (progn
                                                              (if (or (== ns cns)
                                                                      (== ns `core))
                                                                  (= in_path true)
                                                                  (= in_path false))
                                                              (for_each (sym (keys (prop cached_symbols ns)))
                                                                 (if in_path
                                                                    sym
                                                                    (+ ns "/" sym)))))))))
                                       (= identifiers (get_all_editor_tokens editor))
                                       
                                       (when evaluator_control
                                          (set_prop ns_span
                                             `innerText
                                             (-> evaluator_control `current_namespace))))))
                                       
            (set_display_control_bar (fn (state)
                                        (progn
                                           (if state
                                              (remove_class "juno-display-none" control_bar)
                                              (add_class "juno-display-none" control_bar))
                                           (perform_resize))))
            (evaluator_control nil)  ;;create a convenience handle to this if not evaluated
            (set_evaluator_control (fn (control)
                                      (if control.evaluate
                                         (progn
                                            (when options.evaluator_id
                                               (remove_event_handler options.evaluator_id "evaluator_change" ns_notifier_id)
                                               (remove_event_handler options.evaluator_id "control_name_change" name_change_id))
                                            (= evaluator_control control)
                                            (set_evaluator control.evaluate)
                                            (set_prop options
                                               `evaluator_id
                                               control.options.id)
                                            (register_event_handler options.evaluator_id "evaluator_change" ns_notifier_id get_current_symbols)
                                            (register_event_handler options.evaluator_id "control_name_change" name_change_id change_evaluator_name)
                                            (if control.name
                                               (set_prop evaluator_span
                                                  `innerText
                                                  (+ "⭢ " control.name)))
                                            (get_current_symbols)))))
            (user_select_evaluator (fn (e)
                                      (progn
                                         (aif (select_evaluator)
                                              (progn
                                                 (set_evaluator_control it)
                                                 (display_context_message (+ (dtext "Evaluator set to ") it.options.name))
                                                 (notify (+ (dtext "Evaluator set to ") it.options.name)))))))
            
            (cut_selection (fn ()
                              (when (not (blank? (-> editor `getCopyText)))
                                 (let
                                    ((text (-> editor `getCopyText))
                                     (rng (get_selection_object)))
                                    (-> navigator.clipboard `writeText text)
                                    (-> editor.session `replace rng "")))))
            (copy_selection (fn ()
                               (let
                                  ((text (if (search_focused?)
                                             (= text (prop (search_box_handle) `value))
                                             (= text (-> editor `getCopyText)))))
                                  ;(log "copy: "(search_focused?) (prop (search_box_handle) `value))
                                  (when (not (blank? text))
                                     (-> navigator.clipboard `writeText text)))))
                              
            (paste_selection (fn ()
                                (cond 
                                   (search_focused?)
                                   (progn
                                      (log "search_focused: " (-> navigator.clipboard `readText))
                                      (set_prop (search_box_handle)
                                                `value
                                                (-> navigator.clipboard `readText)))
                                   else
                                   (let
                                      ((text (-> navigator.clipboard `readText))
                                       (rng (get_selection_object)))
                                      (-> editor.session `replace rng text)))))
            
            (search_box_handle (function ()
                                  (-> view `querySelector "input.ace_search_field")))
            (search_focused? (function ()
                                (== document.activeElement 
                                   (-> view
                                       `querySelector "input.ace_search_field"))))
            
            (menu_items (fn ()
                           (if (is_object? editor)
                              [(if options.path
                                   [(+ (dtext "Save to") " " (last options.path))
                                    (fn (e) (request_save))]
                                   [])
                               [(dtext "Select Evaluator")
                                user_select_evaluator]
                               (cond
                                  (or options.clone_with_editor_id
                                      (cloned_editor?))
                                  []
                                  else 
                                  [(dtext "Rename Editor")
                                   (fn (e)
                                      (rename_editor))
                                   ])
                               
                               [(dtext "Increase Font Size") increase_font_size]
                               [(dtext "Decrease Font Size") decrease_font_size]
                               (if (== (-> editor `getOption `wrap) "off")
                                   [(dtext "Enable Word Wrap") (fn (e) (set_wrap_mode true))]
                                   [(dtext "Disable Word Wrap") (fn (e) (set_wrap_mode false)) ])
                               [(dtext "Go")
                                [[{
                                   text: (dtext "Go to line number")
                                   path: [ `global `go_to_line_number ]
                                   }]
                                [{
                                   text: (dtext "Step Backward In Position History")
                                   path: [ `global `go_backward_in_position ]
                                   }]
                                [{
                                   text: (dtext "Step Forward In Position History")
                                   path: [ `global `go_forward_in_position]
                                   }]]]
                                (if (-> editor `getReadOnly)
                                   [ (dtext "Allow Editing" ) (fn () (-> intf `set_read_only false)) ]
                                   [ (dtext "Set Read-Only Mode") (fn () (-> intf `set_read_only true)) ])
                               [(dtext "Set Edit Mode")
                                (for (mode_desc (conj [ { name: "Text" mode: "text" } ]
                                                      (available_editor_modes)))
                                    [ mode_desc.name
                                      (eval `(fn () (-> (get_control_by_id ,#options.id) `set_mode ,#mode_desc.mode)))])]
                               [(dtext "Set Editor Theme")
                                (for_each (theme (get_default [ `editor `themes ]))
                                   [theme  (fn () (-> intf `set_theme theme))])]
                                [(dtext "Options and Preferences")
                                (fn (e)
                                   (show_editor_options intf))]]
                              (progn
                                 (notify (+ "" options.name ": BUG: no editor anymore"))
                                 []))))
            
            (init_context_menu 
               (fn ()
                  (let
                     ()
                     (attach_context_menu
                        view
                        (fn (event)
                           (let
                              ((ctoken (get_current_token)))
                              ;(log "current token: " ctoken)
                              (conj
                                 (if (is_function? mode_functions.menu_items)
                                     (-> mode_functions `menu_items ctoken)
                                     [])
                                 [[{
                                     `text: (dtext "Select All")
                                     `path: [ `global `select_all ]
                                     `exec: (fn ()
                                               (-> editor `selectAll))
                                 }]]
                                 (if (is_clipboard_allowed?)
                                     [
                                      [{
                                         text: "Cut"
                                         path: [`global `cut ]
                                         exec: cut_selection }]
                                      [{
                                         text: "Copy"
                                         path: [`global `copy ]
                                         exec: copy_selection
                                         }]
                                      [ {
                                          text: "Paste"
                                          path: [`global `paste ]
                                          exec: paste_selection }]] 
                                     []))))))))
            ;; main initialization routine
            (initialize_editor (fn ()
                                  (when (not initialized)
                                     (let
                                        ((comps nil)
                                         (content nil)
                                         (start_time (time_in_millis))
                                         (extension nil))
                                        (setq initialized true)
                                        (console.log "text_editor: initializing: " options)
                                        (setq parent_view view.parentElement)
                                        (setq editor
                                           (ace.edit editor_div))
                                        (assert editor (+ "text_editor: ace editor not initializing: received: " editor " from ace.edit"))
                                        (unless (is_number? options.primary_rank)
                                           (set_prop options `primary_rank start_time))
                                        
                                        ;(log "initialize_editor: " options.mode " options: " (clone options))
                                        
                                        ;; ensure that the Ace language tools extension is loaded
                                        (display_context_message "Initializing....")
                                        (sleep 0.01)  ;; update display
                                        (defglobal LangTools (-> ace `require "ace/ext/language_tools"))
                                        
                                        ;; if we are not explicitly told to link to another editor...
                                        ;; we need to check to ensure we are not editing a path or file that is already
                                        ;; open by another editor.
                                        
                                        ;; is there already an editor with the same path or filename?
                                        ;; if so, become a linked editor to it
                                        
                                        (when (not options.clone_with_editor_id)
                                           (cond
                                              (and options.path
                                                 (> (get_editors_for_path options.path) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path options.path)))
                                                 (assert primary "initialize_editor: BUG: multiple editors for path but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))
                                              (and options.filename
                                                 (> (get_editors_for_filename options.filename) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path (get_editors_for_filename options.filename))))
                                                 (assert primary "initialize_editor: BUG: multiple editors for filename but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))))
                                        
                                        ;; are we a cloned editor?
                                        
                                        (when options.clone_with_editor_id
                                           (let ((control_to_clone (get_control_by_id options.clone_with_editor_id))
                                                 (new_session nil))
                                              (if (eq nil control_to_clone)
                                                  (log "editor: cannot find editor to clone, id: " options.clone_with_editor_id))
                                              (when (and control_to_clone
                                                         control_to_clone.editor)
                                                 (= new_session (clone_edit_session control_to_clone.editor.session))
                                                 (= linked_editor control_to_clone.options.id)
                                                 (= linked_editor_name control_to_clone.options.name)
                                                 (-> editor `setSession new_session)
                                                 (when (-> control_to_clone `needs_save?)
                                                    (= is_dirty? true)
                                                    (add_class "juno-needs-save" title_span)))))
                                        
                                        ;; behavior setup for the actual editor component
                                        (when options.on_focus
                                           (-> editor `on `focus options.on_focus))
                                        (when options.on_blur
                                           (-> editor `on `blur options.on_blur))
                                        (when options.read_only
                                           (-> editor `setReadOnly true))
                                        (when options.on_click
                                           (-> editor `on `click options.on_click))
                                        (unless linked_editor
                                           (-> editor.session `setUseSoftTabs true)
                                           (-> editor.session `setUseWorker true)
                                           (-> editor.session `setUseSoftTabs true))
                                        
                                        (-> editor.session `setOption `indentedSoftWrap false)
                                        
                                        
                                        (-> editor `setShowFoldWidgets true)
                                         
                                        ;; expose the editor in our interface
                                        (set_prop intf `editor editor)
                                        
                                        ;; set the extension if we haven't been given a specific option mode
                                        ;; if we have filename use that to determine what the mode is
                                        
                                        (when (and (eq nil options.mode)
                                                   (is_string? options.filename))
                                           (= comps (split_by "." options.filename))
                                           (when (> comps.length 1)
                                              (= extension (edit_mode_for_extension (last comps)))
                                              (set_prop options
                                                 `mode
                                                 extension)))
                                        
                                        (set_mode options.mode)
                                        
                                        ;; set the theme for the new editor
                                        (cond
                                           (is_string? options.theme)
                                           (setTimeout (fn () (progn
                                                              (-> intf `set_theme options.theme)
                                                              (remove_class "opacity-0" editor_div))) 50)
                                           else
                                           (aif (resolve_path [ `editor `default_theme ] *env_config*)
                                                (setTimeout (fn ()
                                                               (progn
                                                                  (-> intf `set_theme it)
                                                                  (remove_class "opacity-0" editor_div))) 50)))
                                        
                                        ;; build the key bindings
                                        (build_key_bindings editor)
                                        
                                        ;; set options and defaults
                                        (-> editor `setOptions {
                                                                 `showFoldWidgets: true
                                                                 `cursorStyle: "wide"
                                                                 `firstLineNumber: (or options.first_line_number 0)
                                                                 `useSoftTabs: true
                                                                 `highlightActiveWord: true
                                                                 })
                                        ;; editor defaults...
                                        (when (resolve_path [ `editor `editor_defaults ] *env_config*)
                                              (for ((key val) (pairs (resolve_path [ `editor `editor_defaults ] *env_config*)))
                                                   (try 
                                                      (-> editor `setOption (to_mixed_case key) val)
                                                      (catch Error (e)
                                                         (log (+ "Error: " name ": bad initialization default value for editor in *env_config*:" key ": ") val)))))
                                        
                                        ;; ...and session defaults
                                        (when (resolve_path [ `editor `session_defaults ] *env_config*)
                                           (for ((key val) (pairs (resolve_path [ `editor `session_defaults ] *env_config*)))
                                                (try
                                                   (-> editor.session `setOption (to_mixed_case key) val)
                                                   (catch Error (e)
                                                      (log (+ "Error: " name ": bad initialization default value for editor session in *env_config*:" key ": ") val)))))
                                        
                                        (if options.word_wrap
                                           (set_word_wrap editor options.word_wrap))
                                        
                                        ;; if this editor is primary, and not linked to another editor,
                                        ;; get the content from the specified source or path
                                        (if (not linked_editor)
                                            (set_content))
                                        
                                        (cond
                                           (and options.clone_with_editor_id
                                              (get_control_by_id options.clone_with_editor_id))
                                           (progn
                                              (defvar primary (get_control_by_id options.clone_with_editor_id))
                                              (when primary.group_name
                                                 (set_prop options
                                                    `group_name
                                                    (-> primary `group_name))))
                                           (eq nil options.group_name)
                                           (set_prop options
                                              `group_name
                                              (or options.group_name
                                                 options.name
                                                 (and (is_array? options.path)
                                                      (last options.path))
                                                 (and (is_string? options.filename)
                                                      (last (split_by "/" options.filename)))
                                                 "Untitled Buffer")))
                                        
                                        (set_name options.group_name)
                                        
                                        ;; set up the default font size
                                        
                                        (if (eq nil font_size)
                                            (= font_size (parseInt (-> editor `getFontSize)))
                                            (-> editor `setFontSize font_size))
                                        
                                        (set_prop options
                                           `font_size
                                           font_size)
                                        
                                        ;; default to overscoll mode, but TODO: this should be an global default
                                        (unless (== options.overscroll false)
                                           (-> editor `setOption `scrollPastEnd true))
                                        
                                        ;; load up the token iterator extension...
                                        (defglobal TokenIterator (prop (-> ace `require "ace/token_iterator") `TokenIterator))
                                        
                                        ;; set up change events for hints and contexual help
                                        
                                        (-> editor `on `change (function (val)
                                                                  (progn
                                                                     (when (== intf nil) ;; we've been destroyed so shouldn't be here
                                                                        (log_error "text_editor: " name ": in on change for the editor and we are destroyed!"))
                                                                     (add_class "juno-needs-save" title_span)
                                                                     (= is_dirty? true)
                                                                     (when (is_function? mode_functions.on_change)
                                                                        (-> mode_functions `on_change val))
                                                                     
                                                                        ;(find_active_lisp_operator))
                                                                     (when (not linked_editor)
                                                                        (dispatch_event { command: "editor_change"
                                                                                          source: options.id
                                                                                          args: [ val ] }))
                                                                     
                                                                     (when options.on_change
                                                                        (options.on_change editor val)))))
                                        ;; resize
                                        (-> editor `resize true)
                                        ;; reset the undo manager now that th content is loaded
                                        
                                        (unless options.clone_with_editor_id
                                           (try
                                              (aif (-> editor.session `getUndoManager)
                                                   (-> it `reset))
                                              (catch Error (e)
                                                 (log "ERROR on undo manager:" e message))))
                                        
                                        ;; is the buffer read only?
                                        (if options.read_only
                                           (set_read_only options.read_only))
                                      
                                        (attach_event_listener view
                                           `focusin
                                           focus_event)
                                        
                                        ;; signal our mode change
                                        
                                        (dispatch_event { command: "editor_change"
                                                          source: options.id
                                                          args: [ { `option: "mode" `value: options.mode } ] })
                                        
                                        ;; scroll speed of the editor
                                        (cond
                                           (is_number? options.scroll_speed)
                                           (set_scroll_speed intf options.scroll_speed)
                                           (is_number? (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                           (progn
                                              ;(log "setting scroll speed: " (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                              (set_scroll_speed intf (resolve_path [ `editor `scroll_speed ] *env_config* )))
                                           else
                                           (set_scroll_speed intf 5))  ;; default scroll speed is 5
                                        
                                        (set_prop options
                                           `scroll_speed
                                           (-> editor `getScrollSpeed))
                                        
                                        ;; when we are linked move to our current position of the other editor
                                        (when linked_editor
                                           (defvar pos (-> (prop (get_control_by_id linked_editor) `editor)
                                                           `getCursorPosition))
                                           (-> editor `navigateTo  pos.row pos.column)
                                           (-> editor `scrollToLine pos.row true nil))
                                        
                                        (push position_history
                                           (-> editor `getCursorPosition))
                                        
                                        (when options.on_initialized
                                           (options.on_initialized intf))
                                        (attach_event_listener view
                                           `keyup
                                           (function (e)
                                              (progn
                                                 (update_position))))
                                        
                                        (if (== options.display_control_bar false)
                                            (set_display_control_bar false))
                                        
                                        (init_context_menu)
                                        
                                        (when control_bar
                                           (attach_event_listener control_bar
                                              `click
                                              (fn (e)
                                                 (set_focus_to intf))))
                                        
                                        (attach_event_listener nav_forward_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_forward_in_position))))
                                        
                                        (-> editor `on `click (function (val) (update_position)))
                                        (attach_event_listener nav_back_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_backward_in_position))))
                                        (attach_event_listener col_pos_span
                                           `click
                                           (fn (e)
                                              (go_to_line_number intf)))
                                        (attach_event_listener evaluator_span
                                           `click
                                           user_select_evaluator)
                                        
                                        (attach_event_listener title_span 
                                           `click
                                           (fn (e)
                                              (rename_editor e)))
                                        
                                        ;; setup the evaluator if it is ready
                                        (setTimeout (fn ()
                                                       (let
                                                          ((count 10)
                                                           (evaluator_control nil))
                                                          (when (== options.mode "juno")
                                                          ;; unless we have been explicitly given an evaluator, use the system repl
                                                          (if options.evaluator_id
                                                             (progn
                                                                (= evaluator_control (get_control_by_id options.evaluator_id))
                                                                (while (and (> count 0)
                                                                            (not evaluator_control))
                                                                   (progn
                                                                      (sleep 1)
                                                                      (dec count)
                                                                      (= evaluator_control (get_control_by_id options.evaluator_id))))
                                                                (if evaluator_control
                                                                   (set_evaluator_control evaluator_control)
                                                                   (notify "Unable to set evalator control for the buffer - id not found")))
                                                             (when *system_repl*
                                                                (display_context_message (+ "Evaluator for this buffer is " (prop *system_repl* `name)))
                                                                (set_evaluator_control *system_repl*))))))
                                                    100)
                                        (when (is_function? mode_functions.on_initialized)
                                           (-> mode_functions `on_initialized intf))
                                        (display_context_message "Ready")
                                        ;(log "initialize_editor: " (clone options.name) (+ ": (" (last_n_chars 5 options.id) "): initialization complete:") (clone options))
                                        intf)))))
           
           (declare (function compute_name_for_control select_evaluator)
                    (global compute_name_for_control select_evaluator))
           (if (not (is_symbol? `ace))
               (throw TypeError "ace symbol not found, and is required for this editor."))
           
           (set_style [["height" (+ "calc(100% - " (+ (Math.max 12 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]]
                      editor_div )
           
           (= resize_observer (new ResizeObserver perform_resize))
           (= intf
              {
                `view: view
                `editor: editor  ;; control must be initialized before the editor can be used
                `set: (fn (text)
                         (-> editor `setValue text))
                `get: (fn (text)
                         (-> editor `getValue))
                
                ;; selection 
                
                `get_selection: get_selection_object
                `get_selected_text: get_selected_text
                `is_selected?: is_selected?
                `cut_selection: cut_selection
                `copy_selection: copy_selection
                `paste_selection: paste_selection 
                `symbols: (fn ()
                             sorted_symbols)
                `identifiers: (fn ()
                                 identifiers)
                `group_name: (fn ()
                                options.group_name)
                `type: `text_editor
                `can_hide?: (fn ()
                               (progn
                                  ;(log "editor: can_hide? " (get_editors_for_path options.path) "<= 1 can hide" options.path)
                                  (if (or (is_array? options.path)
                                          (is_string? options.path))
                                      true ;(< (length (get_editors_for_path options.path)) 2)
                                      true)))
                `on_hide: (fn ()
                             (when (> __VERBOSITY__ 0)
                                (log "text_editor: " options.name ": on_hide is called.")))
                `set_display_control_bar: set_display_control_bar
                `on_destroy: (fn ()
                                (progn
                                   (cond
                                      (and options.path
                                         (> (length (get_editors_for_path options.path)) 1))
                                      (progn
                                         true)  ;; in this case we are a linked editor so we are only really removing a view, not the primary editor control
                                      (not is_dirty?)
                                      true
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" }
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         ;(log (+ "editor: " options.name ": user response: ") response)
                                         response))))
                `destroy: (fn ()
                             (when editor
                                (when (is_function? mode_functions.on_destroy)
                                   (-> mode_functions `on_destroy))
                                (defvar others_and_me (if options.path
                                                          (get_editors_for_path options.path)
                                                          []))
                                (defvar my_orig_name (control_name intf))
                                (defvar my_path (clone options.path))
                                (when options.evaluator_id
                                   (remove_event_handler options.evaluator_id "evaluator_change" ns_notifier_id)
                                   (remove_event_handler options.evaluator_id "control_name_change" name_change_id))
                                 ;(log "text_editor:" options.id ": (" my_orig_name ") destroy: dispatching event: others and me: " others_and_me.length (< others_and_me.length 2))
                                 ;(log "text_editor:" options.id ": (" my_orig_name ") destroy: remaining editors for path: " (each (get_editors_for_path options.path) `options))
                                (dispatch_event { `command: "destroy_control" `source: options.id `args: [  ]  })
                                (-> editor `destroy)
                                (= editor nil)
                                ;; effectively de-register ourselves from the group of editors
                                (set_prop options
                                   `path
                                   nil
                                   `group_name
                                   nil
                                   `filename
                                   nil)
                                (set_prop intf
                                   `editor nil)
                                (= intf nil)
                                ;(log "text_editor:" options.id ": (" my_orig_name ") destroy: path, group, filename is nil, editor should be nil: " editor )
                                (when my_path
                                   (rename_editor_group my_path))))
                `set_evaluator: (fn (new_evaluator)
                                   (when (is_function? new_evaluator)
                                      (set_evaluator new_evaluator)))
                `set_evaluator_control: set_evaluator_control
                `get_evaluator: (fn ()
                                   evaluator)
                `get_evaluator_control: (fn ()
                                           evaluator_control)
                `evaluate_selection: (fn ()
                                       (evaluate_selection editor))
                `needs_save?: (fn ()
                                 (and (not options.repl_mode)
                                      is_dirty?))
                `set_mode: set_mode
                `get_mode: (fn ()
                              options.mode)
                `mode_functions: (fn ()
                                    mode_functions)
                `set_theme: set_theme
                `set_overscroll: set_overscroll
                `split_vertical: (fn ()
                                    (split_editor `vertical))
                `split_horizontal: (fn ()
                                      (split_editor `horizontal))
                `display_context_message: display_context_message
                `get_evaluator: (fn ()
                                   evaluator)
                `get_position_detail: (fn ()
                                         { current: (-> editor `getCursorPosition)
                                                   idx: position_history_idx
                                                   history: position_history
                                                   })
                `step_backward_in_pos_history: go_backward_in_position
                `step_forward_in_pos_history: go_forward_in_position
                `resize: (fn ()
                            (perform_resize))
                `bind_key: bind_key
                `key_bindings: (fn ()
                                  (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor))
                `save: (function ()
                          (request_save))
                `on_save_complete: (function (event_obj)
                                      (save_complete event_obj))
                `increase_font_size: increase_font_size
                `decrease_font_size: decrease_font_size
                `menu_items: menu_items
                `get_active_lisp_operator: (fn ()
                                              (find_active_lisp_operator))
                `set_read_only: set_read_only
                `read_only?: (function () (-> editor `getReadOnly))
                `get_current_pos: (fn ()
                                     (current_position))
                `set_editor_option: (fn (editor_option_name value)
                                       (when (is_string? editor_option_name)
                                          (-> editor `setOption editor_option_name value)))
                `options: options
                `set_evaluator_control: set_evaluator_control
                `on_focus: (if options.disallow_control_focus
                              nil
                              on_focus)
                `move_to_position: (fn (row column)
                                      (progn
                                         (set_cursor_position { row: row column: column })
                                         (update_position true)))
                `jump_to_local_definition: (fn (symbol)
                                              (if (is_string? symbol)
                                                 (jump_to_local_definition symbol)))
                `get_current_token: get_current_token
                `name: options.name
                `set_name: set_name
                `undo: (fn ()
                          (when editor
                             (-> editor `undo)))
                `redo: (fn ()
                          (when editor
                             (-> editor `redo)))
                `get_linked: (fn ()
                                options.clone_with_editor_id)
                `set_linked: (fn (id)
                                (set_prop options
                                   `clone_with_editor_id
                                   id))
                `set_unlinked: (function ()
                                  (progn
                                     (= linked_editor nil)
                                     (delete_prop options
                                        `clone_with_editor_id)
                                     options))
                `open_search: (fn ()
                                 (-> editor `execCommand `find))
                `cached_symbols: (function ()
                                    cached_symbols)
                `keyword_mapper: internal_keyword_mapper
                `toJSON: (function ()
                            (progn ;; we may not have ever been initialized with an editor if never mounted to the DOM
                               (if (or (not initialized)
                                       (not editor))
                                  `(text_editor ,#options)
                                  (progn
                                     (if (is_symbol? `LZString)
                                         (progn
                                            (delete_prop options `content)
                                            (set_prop options
                                               `content_compressed
                                               (LZString.compressToBase64 (-> editor `getValue))))
                                         (set_prop options
                                            `content
                                            (-> editor `getValue)))
                                     `(text_editor ,#options)))))
                `initialize: (fn ()
                                (when view.parentElement
                                   (console.log "editor: performing initialization")
                                   (-> resize_observer `observe view.parentElement)
                                   (try
                                      (initialize_editor)
                                      (catch Error (e)
                                         (log "ERROR on init: " e.message))))) })))
   {
     `description: (+ "The text_editor control provides a means for editing text based "
                      "buffers, and can either be used for editing local in-memory content or, for "
                      "remote files when the application is served via HTTP.   The editor can be split "
                      "into multiple views of the same content, provides theming, and color coded "
                      "markup capabilities.  Additionally, key sequences can be used either in the "
                      "scope of the editor, or via global scope.  It can adapt well to being a "
                      "sub-control, and has a large number of options to enable higher fidelity "
                      "between serialization and deserialization cycles.   <br><br>#### Example Usage "
                      "<br>```(text_editor \n   { mode: `juno\n     on_change: (function (editor val)\n  "
                      "         (progn\n                      (log (+ (control_name editor) \": change: "
                      "\" val))))\n     name: \"Test Editor\"\n     evaluator_id: (control_id "
                      "*system_repl*)\n     on_initialized: (fn (control)\n                      (notify "
                      "(+ (control_name control) \": initialized!\")))\n   })```<br><br><br>---<br><br> "
                      "This control serves as a wrapper around a third party library, the Ace Editor.  "
                      "The control abstracts certain Ace editor functionality as part of the control\'s "
                      "interface. <br><br>#### Ace Editor               <br><br>  The underlying text "
                      "editor library used for this control is the BSD licensed Ace Editor.  The "
                      "documentation for this library is available here: "
                      "https://github.com/ajaxorg/ace.  Certain underlying functions have been "
                      "elevated and exposed at the top level control interface for purposes of the "
                      "design and implementation of the text_editor control.  Direct access to the Ace "
                      "editor instance and its functionality is via the `editor` key in the control\'s "
                      "interface. Since this control uses a third party library underneath, any "
                      "underlying state not captured directly in the controls options object will be "
                      "lost when serialized.  A project objective is to build out the interface for "
                      "this control toward a more idiomatic and \"lisp-like\" interface.   The exposed "
                      "functionality should be expected to be able to save state and restore, unless "
                      "otherwise noted.<br><br>#### Modes               <br><br> The editor can be set "
                      "to operate in a certain \"mode\" state. Changing the editing mode enables certain "
                      "functionalities to be \"turned on\", and which is specifically relevant for the "
                      "type and purpose of the content being edited.  There are several modes that are "
                      "prebuilt into the editor: Juno/Lisp, Javascript, CSS, and plain text.  Each of "
                      "these modes provide specific features such as syntax highlighting, suggestion "
                      "rules, and active formatting rules. <br>Modes can be selected at creation time "
                      "and during run-time.    The mode is indicated visually by the \"Current Editing "
                      "Mode\" title bar text, located to the far right on the default title bar.  The  "
                      "`(get_mode)`  function can be used in the control\'s interface, which is called "
                      "with zero arguments.    <br> The mode can be changed by the user in the "
                      "control\'s command menu, where the user can select via the Set Edit Mode sub "
                      "menu.   The Controls interface exposes the  `set_mode`  function, where a "
                      "string that is equal to the mode name is given as an argument.  The names of "
                      "the built-in modes are as follows: ```[ `juno `javascript `text `css `json "
                      "]```<br><br> Each element in the array can be used to "
                      "supply `set_mode`.  <br>Additional modes can be constructed and made available "
                      "to the environment that then can be utilized by the text_editor "
                      "control. Presently, the only custom mode is `juno`, which calls back into the "
                      "Lisp environment for context.   The other modes are standard ACE editor modes "
                      "for their respective content type.  In this environments file structure, mode "
                      "files are found named `js_lib/mode-*`, where all relevant mode-code is found "
                      "with the \"mode-\" prefix.   <br>Mode details can be found on the Ace website, "
                      "https://ace.c9.io/.  <br><br>#### Split Panels            <br><br>Editors can "
                      "be split into multiple views of the same content.  Changes to the content are "
                      "propagated to each view, which is linked to the same content.  This means that "
                      "all changes in one will be reflected in the other editor.  Cursor positions and "
                      "display area can be independent to allow for simultaneous editing of a single "
                      "file in multiple panels.   The mechanism by which this occurs is a shared "
                      "underlying Ace  `Session`  instance.  There are some special characteristics of "
                      "the multi-pane mode.<br>When there are multiple panels open to the same editor, "
                      "and one of the editor panels is hidden, it will not be stored in the holding "
                      "tank, and will be disposed.  Like other controls, when there is only one "
                      "instance open, the control will behave in the standard form.  When hidden, the "
                      "control will be stored, not destroyed.  <br>Additionally, in the multiple-panel "
                      "mode, if the buffer is unsaved, the closing control will not ask if you want to "
                      "save the content, but will instead close.  Once the final view into the content "
                      "is reached, and the editor contained unsaved material, the user will be "
                      "prompted if they want to save or store the contents of the editor.<br>The "
                      "interface command `split_window` allows for programmatic control over this "
                      "functionality.  <br><br>### Launch Options                 <br><br>Options "
                      "provided to the function allow for modification of behaviors and specific "
                      "functionality to be enabled or disabled at the time of the controls creation.  "
                      " The anything placed in the options object will be serialized when the "
                      "environment is saved, and so it is important to make sure that values must be "
                      "able to represent themselves in JSON form.   <br>clone_with_editor_id:string "
                      "-When present, the created editor instance will share an editing session with "
                      "the editor with the given id.  The given editor must be a text_editor "
                      "control.   <br>mode:string -Specifies which mode the editor should start in.  "
                      "For this to take effect, the mode must be a defined Ace editor mode (see Modes "
                      "above).  If not provided, the mode is determined by the filename if "
                      "possible.<br>on_mode_set:function -If present, this function is called with the "
                      "mode `(on_mode_set mode_name)` when the mode is changed. <br>on_save:function "
                      "-Called after a document has been saved successfully.  Since an edit session "
                      "can be shared between multiple controls that display different views, saving is "
                      "handled in a centralized way through a shared function, the  "
                      "`save_event_handler` function.  This external function receives a request and "
                      "then alerts all the editor with the same `basename`, which is set in the "
                      "options object by the control by calling their `save_complete` functions.  If "
                      "the editor has an `on_save` function in the options, then that function will be "
                      "called when the save successfully completes.<br>id:string -Specifies the "
                      "specific ID of the editor.  This is generally not required, since controls "
                      "should establish their own IDs, except when being rehydrated, they will need to "
                      "keep the ID they had prior to serialization.<br>namespace:string -Specifies the "
                      "namespace that the buffer should operate in, and reference.  If not specified, "
                      "the current namespace is used.  This is necessary if the path being edited is "
                      "in a different namespace than the current evaluation "
                      "namespace.<br>read_only:boolean -If specified as true, the buffer will start in "
                      "read only mode, and will not allow changes to the editor\'s "
                      "content,.<br>control_bar:Element -When specified, uses the element provided "
                      "with this option as the control bar as opposed to the default control "
                      "bar.  <br>on_theme_set:function -If present, this function will be called with "
                      "the new theme name when a new editor theme is "
                      "set. <br>on_position_change:function - If present as an option, this function "
                      "will be called with each cursor movement with a function signature of (position "
                      "ace_editor), with the position being an object containing the column and row "
                      "and the ace_editor instance that the event occurred in.  Return value is not "
                      "used.<br>overscroll:boolean -If true, the editor view will scroll past the "
                      "final line, allowing for the final line to be displayed in the middle regions "
                      "of the view.   The default is true, and this options must be explicitly set to "
                      "false to disable.<br>filename:string -When present, the remote file is "
                      "retrieved via fetch.  The filename should contains the relative path of the "
                      "file under the root directory of the served content.  The URL constructed to "
                      "get the file is /files/filename where filename is a path, such as "
                      "/src/repl.lisp.  In this example, the final URL requested would be of the "
                      "form: `/files/src/repl.lisp`.  This option is meant to be used in "
                      "with `server_env.juno` package, which provides the HTTP-based services used to "
                      "facilitate editing the file tree of the environment.  If the path and the "
                      "filename are both provided in options. the filename is checked prior to the "
                      "path.  If this option is present, the path is is set by splitting the filename "
                      "by \"/\" and prepending the `filesystem symbol such that the "
                      "path `/src/repl.lisp` will set a path of `[ \"filesystem\" \"src\" \"repl.lisp\" "
                      "]`.  <br>repl_mode:boolean -When set to true, this places the editor into a "
                      "\"REPL\" mode, where when Control-Enter is pressed, the entire editor contents "
                      "will be submitted to the evaluator, if possible.  If no errors are received "
                      "from the evaluator for the submitted text, the contents of the editor will be "
                      "cleared, and placed in the command history structure.  If an error is returned, "
                      "the editor contents are not cleared so as to allow for correction of any "
                      "problems or issues before resubmission.   Note that when placed in REPL mode, "
                      "the editor doesn\'t signal or track if the contents need saving.  The default "
                      "for this option is false.<br>max_history_length:number -The editor keeps track "
                      "of cursor jumps that are larger than 8 rows and stores them in a history array "
                      "that can contain up to `max_cursor_positions`.  The `go_backward_in_position` "
                      "and `go_forward_in_position` functions in the text_editor closure move an index "
                      "back and forth between the stored positions.   ")
     usage: ["options:object"]
     tags: ["editor" "ui" "control" "text" "edit" "controls" "file" ]
     })


(defun compute_name_for_editor (title path_to_value)
   (let
      ((others (get_editors_for_path path_to_value))
       (counter 2))
      ;(log "compute_name_for_editor: # of editors for base title: " title ": " others.length "  path: " path_to_value)
      ;(log "compute_name_for_editor: basename found: " (get_control_by_name title))
      (cond 
         (== others.length 0)
         title
         (not (get_control_by_name title))
         (progn
            ;(log "compute_name_for_editor: returning: " title)
            title)
         else
         (progn
            (while (get_control_by_name (+ title " - " counter ""))
               (inc counter))
            ;(log "compute_name_for_editor: returning: " (+ title " - " counter))
            (+ title " - " counter "")))))

(defun compute_name_for_control (name)
   (if (and (is_string? name)
            (not (blank? name)))
       (let
           ((ctl_exists? (get_control_by_name name))
            (counter 2))
          (cond
             (not ctl_exists?)
             name
             else
             (progn
                (while (get_control_by_name (+ name " - " counter ""))
                   (inc counter))
                (+ name " - " counter "")))))
   {
       `description: (+ "Given a proposed name for a control, if the name isn't " 
                        "used by another control, will return the provided name. "
                        "Otherwise, the function will return a unique non-used "
                        "name by appending a digit, starting with 2 on the control "
                        "name.  The new name will then be returned.")
       `tags: ["control" "name" "ui" "identifier" "controls"]
       `usage: ["name:string"]
   })


(defun floating_temp_editor (options)
      (new Promise
         (fn (resolve reject)
             (let
                ((dwin nil)
                 (editor_ctl (text_editor { namespace: (or options.namespace (current_namespace)) temporary: true content: "" mode: (or options.mode `juno) display_control_bar: false }))
                 (cancel_button (button (dtext "Cancel")))
                 (ok_button (button { `style: "float: right" } (dtext "OK")))
                 (rval nil)
                 (last_focused_ctl *last_focus*)
                 (controls_container nil)
                 (closing nil)
                 (resize (fn ()
                            (progn
                               (set_style [["height" (+ "" (- view.parentElement.offsetHeight 80) "px")]
                                           ["width" (+ "" view.parentElement.offsetWidth "px") ]]
                                           editor_container)
                               ;(set_style [["width" (+ "" (- view.parentElement.offsetWidth 50) "px") ]] controls_container)
                               (-> editor_ctl `resize)
                               )))
                 (resize_observer (new ResizeObserver resize))
                 (process_results (fn (cancelled?)
                                     (progn
                                        (notify "Closing")
                                        (= closing true)
                                        (= rval (-> editor_ctl `get))
                                        (log "rval: " rval)
                                        ;(destroy_control editor_ctl)
                                        (-> dwin `close)
                                        (= editor_ctl nil)
                                        (if cancelled?
                                           (resolve nil)
                                           (resolve rval)))))
                 (editor_container
                    (div {  `style: "overflow: hidden; height: inherit; width: 100%; padding-bottom: 10px; "}
                         editor_ctl.view))
                 (view (div { `style: "height: 400px; width: 450px; " }
                            editor_container
                            (= controls_container
                               (div { `style: "position: absolute; bottom: 0px; width: calc(100% - 50px); left: 0px; padding: 10px;" }
                                 cancel_button ok_button)))))
                (= dwin (floating_div
                           view
                           {
                               `title: "Enter Form To Be Called"
                               `controls: true
                               `on_close: (fn ()
                                             (progn
                                                (unless closing
                                                   (resolve nil))))
                           }))
                (sleep 0.1)
                (-> editor_ctl `initialize)
                (attach_event_listener cancel_button
                   `click
                   (fn ()
                      (process_results true)))
                (attach_event_listener ok_button 
                   `click
                   (fn ()
                      (process_results)))
                (-> resize_observer `observe view.parentElement)
                
                (focus_to_editor editor_ctl)
                (= *last_focus* last_focused_ctl)
                )))
      {
        description: (+ "<br><br><br>The `floating_temp_editor` function initiates an editor in a "
                        "`floating_div` that will cause the calling form to wait until the user has "
                        "closed the floating editor.  If the user presses cancel or closes the floating "
                        "window via the upper left close button, then `nil` will be returned.  Otherwise "
                        "a string containing the text value of the editor will be returned.  <br>#### "
                        "Options <br><br>mode:string - The editing mode of the editor.  <br> ")
        usage: ["options:object"]
        tags: ["editor "]
        

        
        })

(defun_sync get_path_for_DOM_obj (element)
   (let
      ((non_whitespace_regex (new RegExp "\\\\s"))
       (lpath (if (is_element? element)
                  (-> element `getAttribute "lpath"))))
      (cond
         lpath
         (progn
            (for_each (v (split_by "~" lpath))
               (cond (> (length (scan_str non_whitespace_regex v)) 0)
                  (+ "\"" v "\"")
                  (isNaN (new Number v))
                  (+ "`" v)
                  else
                  v)))
         else
         (progn
            [] ))))


(defun DOM_to_value (quoted_dom _acc _ctx)
   (let
      ((acc (or _acc []))
       (ctx (new_ctx _ctx))
       (process_children (fn (children)
                            (progn
                               (for_each (child (or children []))
                                  (DOM_to_value child acc ctx)))))
       (tag nil)
       (is_obj_key? (fn ()
                   (contains? "juno-obj-to-dom-key" classes)))
       (is_obj_value? (fn ()
                        (contains? "juno-obj-to-dom-value" classes)))
       (is_new_obj? (fn ()
                       (and (== tag (quote details))
                            (contains? "juno-obj-to-dom" classes))))
       (is_new_array? (fn ()
                         (and (== tag (quote details))
                              (contains? "juno-type-array" classes))))
       (is_array_item? (fn ()
                          (and (== tag (quote li))
                               (contains? "juno-array-item" classes))))
       (val nil)
       (current_obj nil)
       (current_key nil)
       (classes nil))
      (cond
         (is_array? quoted_dom)
         (progn
            (= tag (if (is_reference? (first quoted_dom))
                       (first quoted_dom)
                       nil))
            (= classes (aif (resolve_path [1 `class ] quoted_dom)
                            (split_by " " it)
                            []))
            ;(if (not (eq nil ctx.parent))
             ;   (= ctx (new_ctx ctx)))
            (setf_ctx ctx `tag tag)
            
            ;; below are the rules to encode or handle certain elements in specific ways
            (cond
               (and tag
                  (is_new_obj?))
               (progn 
                  (set_prop ctx.scope
                     `obj {})
                  (setf_ctx ctx `current_key "")
                  (= current_obj (getf_ctx ctx `obj))
                  (if (resolve_path [ 3  ] quoted_dom)
                     (DOM_to_value (resolve_path [ 3 ] quoted_dom) acc ctx))
                  current_obj)
               (and tag
                  (is_new_array?))
               (progn
                  (setf_ctx ctx `arr [])
                  (if (resolve_path [ 3 ] quoted_dom)
                       (DOM_to_value (resolve_path [ 3 ] quoted_dom) acc ctx))
                  (getf_ctx ctx `arr))
               (and tag
                  (is_obj_key?))
               (progn
                  (setf_ctx ctx `current_key (third quoted_dom))  ;; set the key to the value in the key
                  (third quoted_dom))
                (and tag
                   (== tag (quote span))
                   (contains? "juno-obj-to-dom" classes)
                   (== (third quoted_dom) "Object {}"))
                (progn
                    {})
               (and tag
                  (is_obj_value?))
               (progn
                  (= current_key (getf_ctx ctx `current_key))
                  (= val (DOM_to_value (third quoted_dom) acc ctx))
                  (set_prop (getf_ctx ctx `obj)
                            current_key
                            val)
                  val)
               (and tag
                  (is_array_item?))
               (progn
                  (push (getf_ctx ctx `arr)
                       (DOM_to_value (third quoted_dom) acc ctx)))
              
               (and tag
                  (== tag (quote input))
                  (is_object? (second quoted_dom)))
               (progn
                  (defvar itype (prop (second quoted_dom) "type"))
                  (defvar val (prop (second quoted_dom) `value))
                  (cond
                     (eq nil itype)
                     val
                     (== itype "Number")
                     (float val)
                     (== itype "checkbox")
                     (if (prop (second quoted_dom) `is_checked)
                         true
                         false)
                     else
                     val))
                (and tag
                   (contains? "juno-code-value" classes))
               (progn
                  (read_lisp (third quoted_dom)))
               (and tag
                  (== tag (quote span))
                  (contains? "juno-value" classes))
               (cond
                  (contains? "juno-type-string" classes)
                  (chop (-> (third quoted_dom) `substr 1))
                  (contains? "juno-type-number" classes)
                  (float (third quoted_dom))
                  (contains? "juno-type-boolean" classes)
                  (if (== (third quoted_dom) "true")
                      true
                      false)
                  (contains? "juno-type-null" classes)
                  nil
                  else
                  (DOM_to_value (third quoted_dom) acc ctx))
               else 
               (progn
                  (process_children (rest quoted_dom)))))
         (is_string? quoted_dom)
         (progn
            quoted_dom)))
   {
     `description: (+ "Given a quoted DOM structure in lisp representation (for example as "
                      "returned by `element_to_lisp`), returns the object representation of the quoted "
                      "structure.  <br><br>#### Example <br>```(DOM_to_value (element_to_lisp "
                      "root_element))```<br>")
     `usage: ["quoted_dom:array"]
     `tags: ["DOM" "lisp" "reader" "read" "serialize"]
   })




(defun copy_log_struct (element as_object) 
   (let
      ((start_tag element.tagName)
       (root_elem (cond
                     (== start_tag "SUMMARY")
                     element.parentElement
                     (and (== start_tag "TD")
                          (has_class? "juno-obj-to-dom-key" element))
                     element.parentElement.parentElement.parentElement.parentElement
                     else
                     element)))
      (trigger_cascade_open root_elem)
      (if as_object
         (copy_text_to_clipboard (pretty_print (DOM_to_value (element_to_lisp root_elem))))
         (copy_text_to_clipboard (pretty_print (element_to_lisp root_elem))))))

      

(defun highlight_search_text (finding)
   (let
      ((selection (select_element finding.start_element)))
      (collapse_to_start selection)
      (-> selection `setBaseAndExtent finding.start_node finding.start_idx finding.end_node (+ 1 finding.end_idx)))
   {
     description: (+ "Given a result object from search_dom, this function will highlight it "
                     "and scroll to the position (if possible) on the screen.  Returns the selection "
                     "for the finding. ")
     usage: ["finding:object"]
     tags: ["search" "search_dom" "dom" "ui" "find"]
   })
      
(defun search_dom (from_element search_text options)
   (let
      ((results [])
       (next (fn ()
                (progn
                   (= result_idx (% (+ 1 result_idx) results.length))
                   (highlight_search_text (prop results result_idx))
                   (-> (prop (prop results result_idx) `start_element) `scrollIntoView false))))
       (previous (fn ()
                    (progn
                       (dec result_idx)
                       (when (< result_idx 0)
                          (= result_idx (- results.length 1)))
                       (highlight_search_text (prop results result_idx))
                       (-> (prop (prop results result_idx) `start_element) `scrollIntoView false)
                       )))
       (clear (fn ()
                 (progn
                    (collapse_to_end (get_selection))
                    (= result_idx 0)
                    (= results [])
                    (= total_count 0))))
       (total_count 0)
       (result_idx -1)
       (idx -1)
       (word_idx -1)
       (start_idx nil)
       (starting_node nil)
       (findings_for_element [])
       (ctext [])
       (case_sensitive (or options.case_sensitive false))
       (search_text (if case_sensitive
                        search_text
                        (lowercase search_text)))
       (first_c (first search_text))
       (serialize (fn (elem)
                (for_items (node elem.childNodes)
                    (cond
                       (== node.nodeType Node.TEXT_NODE)
                       (push ctext
                          { text: node.nodeValue 
                            node: node
                            index: (inc idx)
                            element: elem })
                       (== node.nodeType Node.ELEMENT_NODE)
                       (serialize node)))))
                       
       (on_find (and (is_function? options.on_find)
                     options.on_find)))
      (traverse_dom from_element
         (fn (element dom_path)
            (progn
               (when (== element.tagName `DETAILS)
                  (set_prop element `open `true)
                  (when (== element.children.1.innerText "Opening...")
                     (quick_alert "OPENING")
                     (sleep 0.01))))))
      
      ;; first flatten into a structure with containing text...
      ;; and references back to nodes and elements
      
      (serialize from_element)
      ;; and find the embedded string, which could span elements
      ;; approach:
      ;; idx: current offset from start of tnode.text 
      ;; start_idx: current start of potential match 
      ;; word_idx: increase  while == to search_text+idx
      ;; when (== word_idx search_text.length) then a match begins at start_idx
      (= idx 0)
      (= word_idx 0)
      (= starting_node nil)
      (log "search_dom: search_text: " search_text case_sensitive)
      (for (tnode ctext)
           ;; next_tnode - reset idx
           (= idx 0)
           (for (c (split_by "" tnode.text))
                (unless case_sensitive
                   (= c (lowercase c)))
                (cond
                   ;; do we have a continuing match?
                   (and (not (eq nil start_idx))
                      (== (prop search_text word_idx) c))
                   (progn 
                      
                      (inc word_idx) ;; .. yes
                      ;; are we at the end?
                      (when (== word_idx search_text.length)
                         (push results
                            { start_element: starting_node.element
                              start_node: starting_node.node
                              start_idx: start_idx
                              start_ctext_idx: starting_node.index
                              end_element: tnode.element
                              end_node: tnode.node
                              end_idx: idx
                              end_ctext_idx: tnode.index })
                         (= starting_node nil)
                         (= start_idx nil)
                         (= word_idx 0)))
                   start_idx  ;; .. not a match
                   (progn
                      (= start_idx nil)
                      (= starting_node nil)
                      (= word_idx 0)))
                (when (and (not start_idx)
                           (== c first_c))
                   (= start_idx idx)  ;; we have a match
                   (inc word_idx)     ;; start it
                   (= starting_node tnode))
                (inc idx)))
                   
      (when (and (> results.length 0)
                 on_find)
         (for_each (result results)
            (on_find result)))
      {
          found: results
          next: next
          index: (function ()
                    result_idx)
          total: results.length
          text: search_text
          previous: previous
          clear: clear
      })
      
   {
     description: (+ "The `search_dom` function takes an element from which to recursively "
                     "search, the text to search for, and an options object.  The function then "
                     "facilitates the search returning an interface of control methods from which to "
                     "manage the search results.  When the search is performed, the DOM tree is "
                     "scanned for the text of the search, and any `details` elements that are found "
                     "are opened and then checked.  This is because in certain cases, the contents of "
                     "details are lazily rendered, and only actually populate with content once the "
                     "details element is opened.  <br>For every successful match, a result object is "
                     "created and will have the following keys.```{ start_element, start_node, "
                     "start_idx, end_element, end_node, end_idx }```<br><br>In the "
                     "above `start_element` is the DOM element in which the search text "
                     "starts, `start_node`  is the starting text node in the element containing the "
                     "starting point of the search text, `start_idx` is the starting offset in the "
                     "specific text node, `end_element` is the ending component of the element, "
                     "end_node is the text node in which the match ends, and end_idx is the ending "
                     "offset in the end node for the match.  <br>The returned interface "
                     "contains:<br>found:array -The array of individual result objects as described "
                     "above.<br>next:function -A function that takes no arguments, when called, the "
                     "next search result is highlighted, and if possible, moved into "
                     "view.  <br>previous:function -A function that takes no arguments that "
                     "highlights the prior result and moves the screen to that position, if "
                     "possible.<br>index:number -The current position index of the search results.  "
                     "Upon reaching either end (0 or total) it will circle back to the first or last "
                     "element.<br>clear:function -Clears out the search results.  Only call when done "
                     "with the search<br>total:number -The total count of search "
                     "results. <br><br>#### Options  <br><br>on_find:function -Once all the results "
                     "are found, the on_find function is called sequentially on each of them prior to "
                     "returning the control interface. The on_find function will be called with the "
                     "signature (result) where the result argument is the individual result objects "
                     "as described above.\n<br>case_sensitive:boolean - If true, the search will only "
                     "match exact text matches which will enforce that the individual character case "
                     "matches, where by when false, the default, individual character case is not "
                     "considered. ")
     usage: ["from_element:Element" "search_text:text|RegExp" "options:object"]
     tags: ["search" "DOM" "ui" "element" "find"]
   })


(defun search_box (options)
   (let
      ((options (or options {}))
       (search_input (input { class: "ace_search_field"
                                placeholder: (dtext "Search for")
                                spellcheck: "false" }))
       (replace_input (input { class: "ace_search_field"
                             placeholder: "Replace with"
                             spellcheck: "false" }))
       (replace_button (if options.allow_replace
                           (span { action: "toggleReplace"
                                   class: "ace_button"
                                   title: "Toggle Replace mode"
                                   style: "float: left; margin-top: -2px; padding: 0px 5px;" }
                             "+")
                           []))
       (case_sensitive_button (span { action: "toggleCaseSensitive"
                                      class: "ace_button"
                                      title: "CaseSensitive Search" }
                                "Aa"))
       (current_focus (active_element)) ;; capture the current focus
       (search_count (span { class: "ace_search_counter" }
                           "0 of 0"))
       (replace_form (div { class: "ace_replace_form juno-display-none"
                         style: "" }
                    replace_input
                    (span { action: "replaceAndFindNext"
                            class: "ace_searchbtn" }
                      "Replace")
                    (span { action: "replaceAll"
                            class: "ace_searchbtn" }
                      "All")))
       (view (div { class: "ace_search right" }
                  (span { action: "hide"
                          class: "ace_searchbtn_close" })
                  (div { class: "ace_search_form" }
                       search_input
                       (span { action: "findPrev"
                               class: "ace_searchbtn prev" }
                         "​")
                       (span { action: "findNext"
                               class: "ace_searchbtn next" }
                         "​"))
                  replace_form
                  (div { class: "ace_search_options" }
                       replace_button
                       search_count
                       (if false 
                          (span { action: "toggleRegexpMode"
                               class: "ace_button"
                               title: "RegExp Search" }
                         ".*")
                          [])
                       case_sensitive_button
                       )
                  " "))
       (intf nil)
       (set_case_sensitive (fn (state)
                              (if state
                                 (add_class "checked" case_sensitive_button)
                                 (remove_class "checked" case_sensitive_button))))
       (search_timer nil)
       (search_results nil)
       (update_search_count (fn ()
                               (progn
                                  (cond 
                                     (and search_results
                                        (> search_results.total 0))
                                     (set_prop search_count
                                        `innerText (+ ""  (+ 1 (-> search_results `index)) " of " search_results.total))
                                     else
                                     (set_prop search_count
                                        `innerText "0 of 0")))))
       (destroy (fn ()
                   (progn
                      (when (is_function? search_results.clear)
                         (-> search_results `clear))
                      (when options.on_destroy
                         (if options.controls
                            (options.on_detroy intf)
                            (options.on_destroy view)))
                      (= search_results nil)
                      (-> view `remove)
                      (when current_focus
                         (focus_to current_focus)))))
       (pend_search (fn (value)
                       (progn
                        (when search_timer
                           (clearTimeout search_timer))
                        (= search_timer (setTimeout (fn () 
                                                       (progn
                                                          ;(quick_alert "searching")
                                                          (= search_timer nil)
                                                          (search value)))
                                                    (or options.delay 500))))))
       (search (fn (value)
                  (progn
                     (declare (optimize (debug 1)))
                  (cond 
                     options.root_element
                     (progc
                        (= search_results
                           (search_dom options.root_element value {
                                                                    on_find: options.on_find
                                                                    case_sensitive: (has_class? "checked" case_sensitive_button)
                                                                    }))
                        (when (> search_results.total 0)
                           (-> search_results `next)) ;; go to the first one
                        (update_search_count))))))
       (reset_search (fn ()
                        (progn
                           (= search_results nil)
                           (update_search_count))))
       (toggle_replace (fn ()
                          (if (has_class? "juno-display-none" replace_form)
                              (remove_class "juno-display-none" replace_form)
                              (add_class "juno-display-none" replace_form))))
       (move_search_index (fn (command)
                             (setTimeout (fn ()  ;; we need to recover focus
                                            (progn
                                               (when (is_function? (prop search_results command))
                                                  (-> search_results command))
                                               (update_search_count)
                                               ))
                                         1)))
       (handle_keyup_event 
          (fn (e)
             (let
                ((source e.srcElement)
                 (value source.value))
                (cond
                   (and (== e.key "Backspace")
                        (blank? source.value))
                   (reset_search)
                   (== e.key "Escape")
                   (destroy)
                   (and options.search_on_key_press
                      (== source search_input))
                   (pend_search search_input.value)
                   (== e.key "Enter")
                   (search search_input.value)
                   (== source replace_input)
                   (log "Replace input: " value)))))
                
       (handle_click_event 
          (fn (e)
             (let
                ((action (get_attribute e.srcElement `action)))
                (cond
                   (== action "hide")
                   (destroy)
                   (== action "findNext")
                   (move_search_index `next)
                   (== action "findPrev")
                   (move_search_index `previous)
                   (== action "toggleReplace")
                   (toggle_replace)
                   (== action "toggleCaseSensitive")
                   (progn
                      (set_case_sensitive (not (has_class? "checked" case_sensitive_button)))
                      (focus_to search_input))
                   (== action nil)
                   (focus_to e.srcElement))))))
      (attach_event_listener view
         `click
         handle_click_event)
      (attach_event_listener view
         `keyup
         handle_keyup_event)
      
      (setTimeout (fn ()
                     (focus_to search_input)) 100)
      (if options.controls
         (= intf {
                   view: view
                   search: (fn (val)
                              (if (blank? val)
                                  (reset_search)
                                  (progn
                                     (reset_search)
                                     (set_prop search_input
                                        `value val)
                                     (search val))))
                   next: (fn ()
                            (move_search_index `next))
                   previous: (fn ()
                                (move_search_index `previous))
                   reset: (fn ()
                             (reset_search))
                   search_text: (fn ()
                                   search_input.value)
                   destroy: (fn ()
                               (destroy))
                   })
         view))
   {
     description: (+ "The `search_box` function enables a pluggable search function for DOM "
                     "based information.  Provided with the top element in the DOM tree in "
                     "the `root_element` from which to search, a view or interface is returned from "
                     "which the user can enter the text they are interested in searching for.  Once "
                     "the search initiates, the result count will be presented and the user able to "
                     "cycle forward and backward through the search results. <br><br>#### Options "
                     "<br><br>root_element:Element - The root element in which to start the search.  "
                     "The contents of this element will recursively searched.<br>controls:boolean -If "
                     "true, instead of the view being returned, an interface is returned allowing for "
                     "control of the search from external code.   The interface provides: ```{ next, "
                     "previous, reset, search, search_text, destroy, view }```<br><br>The only "
                     "function that takes an argument is search, which is the value to search the DOM "
                     "for.  All other functions do not take "
                     "arguments. <br>search_on_key_press:boolean -If true, the search of the DOM "
                     "contents will proceed automatically after a default delay of 500 milliseconds.  "
                     " The delay timing can be set with the `delay` option.<br>delay:number -The "
                     "number of milliseconds to delay prior to initiating a search "
                     "when `search_on_key_press` is set to true.  <br>on_destroy:function -When the "
                     "search_box is destroyed, this function is called with either the interface "
                     "object if `controls` is true, or the `view` Element if controls is false. ")
     usage: ["options:object"]
     tags: ["search" "DOM" "ui" "element" "find"]
     })

(defcontrol log_view ()
   ((output_container (div { `class: "juno-log-output juno-scrollbar" `style: "scroll-behavior: smooth;" } ))
    (options (or options { `display_options: { include_prototypes: false }}))
    (name (or options.name (name_control "log_view")))
    (parent_view nil)
    (set_show_prototypes (fn (state)
                            (progn
                               (set_prop options.display_options
                                  `include_prototypes
                                  state)
                               (log_message "show prototypes: " options.display_options.include_prototypes))))
    (display_modes [ `tree `juno `json ])
    (scroll_to_bottom (fn ()
                         (progn
                            (unless (== options.smooth_scroll_mode false)
                               (set_style [[`scroll-behavior `default]] output_container)
                               (set_prop output_container `scrollTop content_height)
                               (set_style [[`scroll-behavior `smooth]] output_container))
                            (set_prop output_container
                                           `scrollTop
                                           (+ content_height 540)))))
    (set_display_mode (fn (mode)
                         (progn
                            (cond
                               (is_number? mode)
                               (set_prop options.display_options
                                  `display_mode
                                  (clamp mode 0 (max_index display_modes)))
                               (and (is_string? mode)
                                    (> (index_of mode display_modes) -1))
                               (progn
                                  (set_prop options.display_options
                                     `display_mode
                                     (prop display_modes (index_of mode display_modes))))
                               else
                               (throw TypeError (+ "invalid display_mode - need string or number - got: " mode)))
                            (log_message "set display mode: " (prop display_modes options.display_options.display_mode)))))
    
    (render (fn ()
               ;(div { `tabindex: 0  `style: "background: white; color: var(--control-color); overflow: hidden; margin: 0px; padding: 0px; height: inherit; width: 100%;" }
               output_container))
    (set_display_command_button
       (fn (state)
          (progn
             (if state
                (remove_class "juno-display-none" command_button)
                (add_class "juno-display-none" command_button)))))
    
    (copy_selection (fn ()
                       (if (not (blank? (-> (get_selection) "toString")))
                           (-> document `execCommand `copy))))
    
    (log_context_menu (fn (orig_e)
                         (let
                            ((element orig_e.srcElement)
                             (quoted (if (get_attribute element `quoted)
                                         true
                                         false))
                             (lpath (get_attribute element `lpath))
                             (path (if lpath
                                       (split_by "~" lpath)
                                       []))
                             (segment (cond
                                         (> options.display_options.display_mode 0)
                                         ""
                                         (and (== path.length 0)
                                              (== element.tagName "SUMMARY")
                                              (has_class? "juno-obj-to-dom" element))
                                         "from root"
                                         (and (== element.tagName "SUMMARY")
                                              (has_class? "juno-type-function" element))
                                         "function"
                                         (and (== path.length 0)
                                              (== element.tagName "SUMMARY")
                                              (== (get_attribute element `lpath) ""))
                                         "array"
                                         (and (== element.tagName "TD")
                                              (> path.length 0)
                                              (has_class? "juno-obj-to-dom-key" element))
                                         (last (but_last path))
                                         else
                                         (last path))))
                            (if (and (not quoted)
                                     (blank? segment))
                                (= segment "from root"))
                            
                            (if quoted
                               [["Copy output value"
                                 (fn (e)
                                    (copy_text_to_clipboard element.innerText))]
                                ["Copy selection"
                                 (fn (e)
                                    (-> document `execCommand `copy))]
                                ["--" nil]
                                [(dtext "Clear Output Log")
                                 (fn (e)
                                    (clear))]]
                               [[(+ "Copy " segment " as value")
                                 (fn (e)
                                    (progn
                                       (copy_log_struct orig_e.srcElement true)
                                       (notify "Copied to Value")))]
                                ["Copy as quoted view" (fn (e)
                                                          (progn
                                                             (copy_log_struct orig_e.srcElement)
                                                             (notify "Copied to Lisp")))]
                                ["Copy path" (fn (e)
                                                (try
                                                   (progn
                                                      (defvar path (+ "["
                                                                      (join " " (get_path_for_DOM_obj orig_e.srcElement))
                                                                      "]"))
                                                      (copy_text_to_clipboard path)
                                                      (notify path))
                                                   (catch Error (e)
                                                      (notify (+ "ERROR: " e)))))]
                                (if (not (blank? (-> (get_selection) "toString")))
                                    ["Copy selection"
                                     (fn (e)
                                        (-> document `execCommand `copy))]
                                    [])
                                ["--" nil]
                                [(dtext "Clear Output Log")
                                 (fn (e)
                                    (clear))]]))))
    (on_search (fn () true))
    (on_initialize (fn ()
                      (try
                         (progn
                            (= parent_view view.parentElement)
                            (set_style [["display" "block"]
                                        ["background" "var(--log-result-bg-color)"]
                                        ["height" "100%"]
                                        ["width" "100% ;"]
                                        ] content_view)
                            
                            (when (eq nil (prop options `display_options))
                               (set_prop options
                                  `display_options
                                  { include_prototypes: false display_mode: 0 }))
                            (when (eq nil (resolve_path [ `display_options `display_mode ] options))
                               (set_path [ `display_options `display_mode ] options 0))
                            (if options.display_options.show_timestamps
                                (set_show_timestamps options.display_options.show_timestamps)
                                (set_show_timestamps false))
                            (if options.hide_command_button
                               (set_display_command_button (not options.hide_command_button)))
                            
                            
                            
                            (attach_context_menu output_container
                                                 log_context_menu))
                         
                         
                         (catch Error (e)
                            (notify (+ "Error: " e.message))))))
    ;; override the default resize (typically we use on_resize )
    (resize (fn ()
               (let
                  ((new_height (- (prop view.parentElement `offsetHeight) 5))
                   (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                  (cond 
                     (and hide_state
                        (> new_height 5))
                     (progn
                        (= hide_state false)
                        (scroll_to_bottom)
                        (set_prop view
                           `scrollTop
                           0))
                     (and (> new_height 5)
                          (== output_container.scrollTop 0))
                     (progn
                        (sleep 0.01)
                        (scroll_to_bottom))))))
    (content_height 0)
    (document_base document)
    (add_result (fn (result command_text error_state)
                   (progn
                      (assert initialized "log_view not initialized")
                      (defvar appended_element nil)
                      ;; unless we are at the bottom do the scroll
                      (unless (== options.smooth_scroll_mode false)
                         (when (< output_container.scrollTop (- content_height 350))
                            (set_style [[`scroll-behavior `default]] output_container)
                            (set_prop output_container `scrollTop content_height))
                         (set_style [[`scroll-behavior `smooth]] output_container))
                      (when (== document_base result)
                         (= result (div { `class: "juno-code-value" } "document")))
                      (when (not (eq nil command_text))
                         
                         (-> output_container
                            `append
                            (if (> command_text.length 100)
                                (details {  class: "juno-result" }
                                         (summary { `tabindex: 0 `class: "juno-code-value" } (+ (-> command_text `substr 0 100) "..."))
                                         (pre { `tabindex: 0 `class: "juno-code-value" }
                                              command_text))
                                (div {  class: "juno-result" }
                                     (pre { `tabindex: 0 `class: "juno-code-value" }
                                          command_text)))))
                      
                      (-> output_container
                         `append
                         (= appended_element
                            (div { `class: "juno-log-message"
                                   `style: (+ " margin-top: 0px; font-family: var(--main-mono-space); "
                                              (if (eq nil command_text)
                                                  "border-top: 1px solid #00000020; padding: 5px;"
                                                  "border-left: 3px solid #0167835e; padding: 5px; margin-bottom: 5px; border-bottom: 1px solid transparent;")) }
                              (value_to_dom result options.display_options))))
                      (when (> (prop view.parentElement `offsetHeight) 10)
                         (= content_height (Math.max window.innerHeight (sum (each output_container.children `offsetHeight)))))
                      
                      (setTimeout (fn ()
                                     (progn
                                        ;(notify (+ "oc: " (+ content_height 540)))
                                        (set_prop output_container
                                           `scrollTop
                                           (+ content_height 540))
                                        (sleep 0.01)
                                        (when (> appended_element.parentElement.children.length
                                                 (or options.max_log_lines
                                                    *env_config*.application.max_log_lines
                                                    10))
                                           (-> (first appended_element.parentElement.children)
                                               `remove))))
                                  100)
                      (set_prop view
                         `scrollTop
                         0)
                      
                      result)))
    (set_max_log_lines (fn (val)
                          (when (is_number? val)
                             (set_prop options
                                `max_log_lines
                                val)
                             ;(while (> output_container.children.length options.max_log_lines)
                             ; (-> (first output_container.children)
                             ;    `remove))
                             true)))
    (set_show_timestamps (fn (state)
                            (if state
                               (progn
                                  (= ts_hidden_state "")
                                  (set_prop options.display_options
                                     `show_timestamps true)
                                  (when view  ;; surround in try catch in case we aren't completely ready
                                     (try
                                        (apply remove_class "juno-display-none" (or (-> view `querySelectorAll ".juno-timestamp") []))
                                        (catch Error (e)
                                           nil))))
                               
                               (progn
                                  (set_prop options.display_options
                                     `show_timestamps false)
                                  (= ts_hidden_state "juno-display-none")
                                  (when view
                                     (try
                                        (apply add_class "juno-display-none" (-> view `querySelectorAll ".juno-timestamp"))
                                        (catch Error (e)
                                           nil)))))))
    (set_smooth_scroll_mode (fn (state)
                               (if state
                                  (progn
                                     (set_prop options
                                        `smooth_scroll_mode true)
                                     (set_style [[`scroll-behavior `smooth]] output_container))
                                  (progn
                                     (set_prop options
                                        `smooth_scroll_mode false)
                                     (set_style [[`scroll-behavior `default]] output_container)))))
    (clear (function ()
              (-> output_container `replaceChildren)))
    (menu_items (fn ()
                   [[(dtext "Clear Log")
                     (fn ()
                        (-> output_container `replaceChildren))]
                    [(dtext "Search Log")
                     (fn ()
                        (open_search))]
                    [(dtext "Set Max Log Lines")
                     (fn ()
                        (aif (request_user_input (+ (dtext "Enter the number of log lines to keep") ":") 
                                                 `number 
                                                 { `default_value: (or options.max_log_lines
                                                                       *env_config*.application.max_log_lines) })
                             (set_max_log_lines (int it))))]
                    [(+ (dtext "Display Mode") "...")
                     [[(dtext "Tree")
                       (fn ()
                          (set_display_mode 0))]
                      [(dtext "Juno")
                       (fn ()
                          (set_display_mode 1))]
                      [(dtext "JSON")
                       (fn ()
                          (set_display_mode 2))]]]
                    
                    [(if (blank? ts_hidden_state)
                         (dtext "Hide Timestamps")
                         (dtext "Show Timestamps"))
                     (fn ()
                        (if (blank? ts_hidden_state)
                            (set_show_timestamps false)
                            (set_show_timestamps true)))]
                    (if (== options.smooth_scroll_mode false)
                        [(dtext "Turn On Smooth Scrolling")
                         (fn ()
                            (set_smooth_scroll_mode true))]
                        [(dtext "Turn Off Smooth Scrolling")
                         (fn ()
                            (set_smooth_scroll_mode false))])
                    [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                     (fn ()
                        (set_show_prototypes (not options.display_options.include_prototypes)))]]))
    (hide_state nil)
    (ts_hidden_state "")
    (on_hide (fn ()
                (progn
                   (= hide_state true))))
    (on_focus (fn (self)
                 (try
                    (progn
                       (when hide_state
                          (= content_height (Math.max window.innerHeight (sum (each output_container.children `offsetHeight))))
                          (scroll_to_bottom))
                       (= hide_state false)
                       (when options.on_focus
                          (-> options `on_focus self))
                       (add_class "juno-focused" control_status))
                    (catch Error (e) 
                       (notify (+ "ERROR: " e.message)))))) ;; we know that is the command bar
    
    (log_message (fn (highlight_color `& args)
                    (progn
                       (defvar display_mode (or options.display_options.display_mode 0))
                       (add_result (div { tabindex: 0 style: (+ "display: flex; justify-content: flex-start; align-items: flex-start; " (if (is_string? highlight_color) (+ "background: " highlight_color) "")) }
                                        (div { class: (+ "juno-timestamp " ts_hidden_state) `timestamp: (time_in_millis)  } (formatted_date (new Date)))
                                        (div { style: "display: flex; justify-content: flex-start; align-items: flex-start; " }
                                             (for_each (v args)
                                                (cond
                                                   (is_string? v)
                                                   (div { `tabindex: 0 `class: "juno-value juno-type-string" `style: "display: inline-block; padding-left: 10px" } v)
                                                   (is_number? v)
                                                   (div { `tabindex: 0 `class: "juno-value juno-type-number" `style: "display: inline-block; padding-left: 10px" } v)
                                                   (or (== v true) (== v false))
                                                   (div { `tabindex: 0 `class: "juno-value juno-type-boolean" `style: "display: inline-block; padding-left: 10px" } v)
                                                   else
                                                   (div { `tabindex: 0 `class: "juno-value" `style: "display: inline-block; padding-left: 10px" }
                                                        (cond
                                                           true ;(== display_mode 0)
                                                           (value_to_dom v)
                                                           (== display_mode 1)
                                                           (pre (pretty_print v))
                                                           (== display_mode 2)
                                                           (pre (JSON.stringify v nil 2))))))))
                                   nil nil)
                       nil)))
    (log_standard (fn (`& args)
                     (try
                        (apply log_message nil args)
                        (catch Error (e)
                           (log "Error: " e.message)))))
    (log_problem (fn (error_message error_instance)
                    (log_message "#FF404010" error_message error_instance))))
   {
     expose: [[`set_show_timestamps set_show_timestamps]
              [`set_show_prototypes set_show_prototypes]
              [`clear clear]
              [`set_display_command_button set_display_command_button]
              [`set_display_mode set_display_mode]
              [`display_mode (function ()
                                (prop display_modes options.display_options.display_mode))]
              [`display_modes (function ()
                                 display_modes)]
              [`set_smooth_scroll_mode set_smooth_scroll_mode]
              [`cut_selection (function ()
                                 (notify "Cannot cut from the log_viewer"))]
              [`copy_selection copy_selection]
              [`paste_selection (function ()
                                 (notify "Cannot paste directly to the log viewer"))]
              [`output_container output_container]
              [`open_search open_search]
              [`control_bar control_status]
              [`set_max_log_lines set_max_log_lines]
              [`max_log_lines (fn ()
                                 (or options.max_log_lines
                                    *env_config*.application.max_log_lines
                                    10))]
              [`append add_result]
              [`on_hide on_hide]
              [`scroll_to_bottom scroll_to_bottom]
              [`log_message log_standard ]
              [`log_error log_problem ]]
     frame_style: "overflow: hidden;"
     control_bar: true
     allow_search: true 
     usage: ["options:object"]
     
     })


(defun process_stack_trace (result)
   (try
      (let
         ((first_anon nil)
          (line_num nil)
          (col_num nil)
          (src (or result.result.compiled
                   result.compiled))
          (buffer []))
         (for_each (message (split_by "\n" result.stack))
            (when (eq nil first_anon)
               (for_each (m (split_by "," message))
                  (when (and (eq nil first_anon)
                             (starts_with? " <anonymous>" m))
                     (= first_anon (rest (split_by ":" m)))
                     (break)))))
         (defglobal *ll* result)
         (if (not (blank? first_anon))
             (progn
                (= line_num (parseInt (first first_anon)))
                (= col_num (parseInt (second first_anon)))
                (push buffer
                   (+ "Line: " (- line_num 3) " Column: " col_num))
                
                (when src
                   (= src (split_by "\n" src))
                   (map (fn (v idx)
                           (when (and (> idx (- line_num 5))
                                      (< idx (+ line_num 5)))
                              (if (== idx (- line_num 3))
                                  (progn
                                     (push buffer
                                        (+ " -> " (pad_left idx 5 " ") ": " v))
                                     (push buffer
                                        (+ "    " "       " (pad_left "^" col_num " "))))
                                  (push buffer
                                     (+ "    " (pad_left idx 5 " ") ": " v)))))
                        src))
                (join "\n" buffer))
             (progn
                "Unable to find source line")))
      (catch Error (e)
         (progn
            "Unable to process stack trace: unknown structure"))))


(defun process_remote_eval_result (result display_mode)
   (if (is_object? result)
       (try
          (let
             ((is_system_error? (== "FAIL" result.rval))
              (error_results nil)
              (category result.category)
              (is_compiler_error? (and (resolve_path [ `result 0 `error ] result)
                                       (resolve_path [ `result 0 `message ] result)))
              (process_tree (fn (quoted_lisp)
                               (progn
                               (try
                                  (cond
                                     (and (is_array? quoted_lisp)
                                          (== quoted_lisp.0 (quote javascript)))
                                     (progn
                                        (if (== display_mode `tree)
                                            (remote_function_to_dom
                                               (set_prop (fn_signature quoted_lisp.1)
                                                         `body
                                                         quoted_lisp.1))
                                            quoted_lisp))
                                     
                                     (and (== display_mode `tree)
                                          (is_array? quoted_lisp)
                                          (== quoted_lisp.0 (quote new))
                                          (contains? quoted_lisp.1 [(quote RegExp)]))
                                     (try
                                        (progn
                                           (eval quoted_lisp))
                                        (catch Error (e)
                                           quoted_lisp))
                                     (is_array? quoted_lisp)
                                     (for_each (val quoted_lisp)
                                        (process_tree val))
                                     (is_object? quoted_lisp)
                                     (to_object
                                        (for_each (val (pairs quoted_lisp))
                                           [val.0 (process_tree val.1)]))
                                     (and (== display_mode `tree)
                                          (is_string? quoted_lisp)
                                          (or (== quoted_lisp (quote "=:null"))
                                              (== quoted_lisp (quote "=:nil"))
                                              (== quoted_lisp (quote "=:undefined"))))
                                     (eval quoted_lisp)
                                     else
                                     quoted_lisp)
                                  (catch Error (e)
                                     (progn
                                        (log "ERROR: " e)
                                        e.message)))))))
             
            (if (and is_system_error?
                     result.stack)
               (= error_results (process_stack_trace result)))
            (if (== category "log")
                (progn
                   (when (is_string? result.result)
                      (set_prop result
                         `result
                         (reader result.result)))
                   (if (is_array? result.result)
                      (set_prop result
                         `result
                         (for_each (r result.result)
                            (process_remote_eval_result
                               {
                                   req_id: result.req_id
                                   namespace: result.namespace
                                   ws_id: result.ws_id
                                   result: (as_lisp r)
                                   rval: result.rval
                                   result_type: (sub_type r)
                                   category: "log-processed"
                               }
                               display_mode))))
                   result.result)
             (cond
                (and (or (== display_mode `juno)
                         (== display_mode `json))
                     (contains? result.result_type ["Function" "AsyncFunction"]))
                `(javascript ,#result.result.body)
                    
                (or (== display_mode `juno)
                    (== display_mode `json))
                (process_tree (if (is_string? result.result)
                                  (read_lisp result.result)
                                  result.result))
                (and is_system_error?
                   (is_array? result.result))
                (progn
                   (log "system_error: array" result)
                   (div { `style: "border-left: 5px solid red; padding: 5px;" }
                        (for_each (r result.result)
                           (value_to_dom r))))
                (and is_system_error?
                   (is_object? result))
                (progn
                   (div { `style: "border-left: 5px solid red; padding: 5px;" }
                        (+ result.result_type ": " result.message)
                        (if error_results
                           (pre error_results)
                           [])
                        (value_to_dom result.)))
                
                is_compiler_error?
                (progn
                   (notify (+ "Error: " is_compiler_error?))
                   (div { `style: "border-left: 5px solid red; padding: 5px;" }
                        (if (== (length result.result) 1)
                            (value_to_dom result.result.0)
                            (value_to_dom result.result))))
                
                (ends_with? "unction" result.result_type)
                (progn
                   (remote_function_to_dom result.result))
                (and result.needs_eval
                   (== display_mode `juno))
                (as_lisp (read_lisp result.result))
                (and result.needs_read
                   (== display_mode `juno))
                (as_lisp (read_lisp result.result))
                result.needs_eval  ;; if json form returned and is a local compile
                (eval_struct (read_lisp result.result))
                result.needs_read  ;; if juno form returned and is a local compile `
                (read_lisp result.result)
                (is_string? result.result)
                (try 
                   (progn
                      (process_tree (read_lisp result.result)))
                   (catch Error (e)
                      (progn
                         (log "Error on result: " e.message result)
                      result.result)))
                else
                result.result)))
          (catch Error (e)
             (list e.message result)))
       ;(log "process_remote_eval_result: returning: " result)
       result))

(defun create_remote_evaluator(options)
   (new Promise 
      (fn (resolve_fn reject_fn)
        (let
           ((repl_ws nil)
            (scheme (if (starts_with? "https"  window.location.protocol)
                        "wss"
                        "ws"))
            (url (or options.url (+ "" scheme "://" window.location.host "/connect_repl")))
            (name (or options.name "remote"))
            (remote_command_timeout (or options.timeout 120000)) ;; 2 minute default
            (requests {})
            (process_mode `eval)
            (active_ns nil)
            (on_message (or options.on_message
                            (fn (message)
                               (log (+ name ": message: ") message))))
            (request_id 0)
            (heartbeat nil)
            (is_initial_open? true)
            (round_trip_time nil)
            (ping (fn ()
                     (let
                        ((start_time (time_in_millis))
                         (response (send_wait "\"PING\"")))
                        (if (is_function? options.on_heartbeat)
                           (option.on_heartbeat response intf))
                        (if (== response.rval "OK")
                            (= round_trip_time (- (time_in_millis) start_time))
                            (= round_trip_time nil)))))
            (send_wait (fn (lisp_text opts)
                          (let
                             ((rval nil))
                             (assert (and (instanceof repl_ws WebSocket)
                                          (== repl_ws.readyState repl_ws.OPEN))
                                     "Websocket is not open")
                             ;(clog "ws-> ")
                             (try
                                (= rval (new Promise
                                             (fn (resolve reject)
                                                (let
                                                   ((my_request_id (inc request_id))
                                                    (timer nil))
                                                   (= timer (setTimeout (fn ()
                                                                           (progn
                                                                              (log name "timeout occurred: " my_request_id)
                                                                              (reject { `rval: "FAIL" `message: (+ "Timeout on request id: " my_request_id) })))
                                                                        remote_command_timeout))
                                                   ;; set the request id in request object, and then wait to resolve the promise until results are returned, or a timeout occurs
                                                   (set_prop requests
                                                      my_request_id
                                                      (list resolve reject timer))
                                                   (try
                                                      (http/send_to_ws repl_ws
                                                                       { `command: "eval"
                                                                         `req_id: request_id
                                                                         `args: [ lisp_text ] })
                                                      (catch Error (e)
                                                         (progn
                                                            (notify (+ "send_wait: error: " e.message))
                                                            (log "ERROR on send_to_ws: " e))))
                                                   true))))
                                (catch Error (e)
                                   (log (+ "Error on send_wait: " e))))
                             rval)))
            (process_result (fn (result)
                               (progn
                                  (cond
                                  (and (is_object? result)
                                       (== result.rval "FAIL"))
                                  (progn
                                     (defvar eresult (process_remote_eval_result result `juno))
                                     (defvar remote_error (if (is_symbol? result.result_type)
                                                              (new result.result_type result.message)
                                                              (new Error result.message)))
                                     (set_prop remote_error
                                        `details
                                        eresult)
                                     (throw remote_error))
                                  (== process_mode "display")
                                  (process_remote_eval_result result `tree)
                                  (== process_mode "eval")
                                  (eval_struct (process_remote_eval_result result `juno))
                                  (== process_mode "quoted")
                                  (process_remote_eval_result result `juno)))))
            (setup_connection
               (fn ()
                  (http/create_websocket
                     url
                     {
                       `on_message: (fn (event)
                                       (try
                                          (let
                                             ((data nil)
                                              (pdata nil)
                                              (resolver nil))
                                             
                                             (try
                                                (= data (JSON.parse event.data))
                                                (catch Error (e)
                                                   (progn
                                                      (log "Unable to parse json data: " e.message)
                                                      (= data event.data))))
                                             (if options.debug
                                                (log (+ name ": <-")  data))
                                             (when (and (is_object? data)
                                                        data.ws_id)
                                                (set_prop intf
                                                   `ws_id
                                                   data.ws_id))
                                                
                                                 
                                             (cond
                                                (and (is_object? data)
                                                     data.req_id)
                                                (progn
                                                   (if (prop requests data.req_id)
                                                       (progn
                                                          (= pdata (prop requests data.req_id))
                                                          (remove_prop requests data.req_id)
                                                          (clearTimeout (third pdata)) ;; remove the timeout
                                                          (if (== data.rval "OK")
                                                              (progn
                                                                 (= resolver (first pdata))
                                                                 (resolver data nil))
                                                              (progn
                                                                 (= resolver (first pdata)) ;; we will resolve the promise and handle the error in our remote eval result function.
                                                                 (resolver data true))))
                                                       (progn
                                                          ;; received a request but it is not tied to a request we made, could be a log message
                                                          (if (== data.rval "OK")
                                                              (on_message data)))))
                                                (and (is_object? data)
                                                     data.result)
                                                (progn
                                                   (on_message data))
                                                else
                                                (if options.debug
                                                   (log (+ "" name ": unknown response: ")  data))))
                                          (catch Error (e)
                                             (log "Unable to process received message: " e.message))))
                       `on_open: (fn (event)
                                    (progn
                                       (defvar ns_change_result nil)
                                       (if options.debug
                                          (log (+ "Connected to Remote REPL: " options.remote_repl)))
                                       (try
                                          (when active_ns
                                             (= ns_change_result (prop (send_wait (+ "(use_ns " active_ns ")")) `result))
                                             (if ns_change_result
                                                (= active_ns ns_change_result)
                                                (log (+ "Namespace set to: " (JSON.parse active_ns)))
                                                (log "Unable to set namespace")))
                                          (catch Error (e)
                                             (log "Unable to set to active namespace: " e)))
                                       ;; setup the round_trip_time values
                                       (ping)
                                       (if heartbeat
                                          (clearInterval heartbeat))
                                       (= heartbeat (setInterval ping 30000))
                                       (when is_initial_open?
                                          (= is_initial_open? false)
                                          (resolve_fn intf))))
                       
                       `on_close: (fn (event)
                                     (progn
                                        (when heartbeat 
                                           (clearInterval heartbeat)
                                           (= heartbeat nil))
                                        (if options.on_close
                                           (options.on_close event intf)
                                           (log (+ name ": socket closed")))))
                       `on_error: (fn (event)
                                     (progn
                                        (if options.on_error
                                           (options.on_error event intf)
                                           (log (+ name ": error on WS:") event))))
                       })))
           (intf {}))
        (= repl_ws (setup_connection))
        (= intf
           {
             process_mode: (function ()
                              process_mode)
             set_process_mode: (function (mode)
                                  (cond
                                     (== mode `display)
                                     (= process_mode `display)
                                     (== mode `eval)
                                     (= process_mode `eval)
                                     (== mode `quoted)
                                     (= process_mode `quoted)
                                     else
                                     (throw Error "invalid return mode")))
             evaluate: (fn (val)
                          (progn
                             (defvar result (send_wait val))
                             (process_result result)))
             url: (fn ()
                     url)
             on_message: on_message
             eval: (fn (quoted_lisp)
                      (progn
                         (defvar result (send_wait (as_lisp quoted_lisp)))
                         (process_result result)))
             ws: repl_ws
             round_trip_time: (fn ()
                                 round_trip_time)
             num_requests: (fn ()
                              request_id)
             name: (fn ()
                      name)
             close: (fn ()
                       (-> repl_ws `close))
             open?: (fn ()
                       (== (prop repl_ws `readyState) 1))
             state: (fn ()
                       (prop repl_ws `readyState))
             connect: setup_connection
             }))))
   {
     description:  (+ "The function `create_remote_evaluator` creates a websocket to the "
                      "server that can be used for remote command evaluation.  It is typically called "
                      "without options, and if successful will return an object interface that can be "
                      "used to send evaluation requests to the server via the `eval` function in the "
                      "returned interface.<br>Once the `remote_evaluator` is created, it will stay "
                      "alive until it is closed, or the connection can no longer be sustained.   A "
                      "heartbeat is sent every 30 seconds to perform keep alive duties and measure "
                      "round trip times which can be retrieved through the interface that is "
                      "returned.<br>#### Processing Modes <br><br>When results are returned from the "
                      "server, they can be processed in a few different ways.  By default the "
                      "connection is set to `eval` mode, which means that the returned forms from the "
                      "server are evaluated locally.  This allows for things like DOM Elements or "
                      "Regex objects to be sent over the wire and be represented in a natural form in "
                      "the browser.  The other mode that is used is `quoted`, which returns the result "
                      "without local evaluation<br>To close a remote evaluation connection, call the "
                      "`close` method that is returned with the interface object.<br><br>#### Options "
                      "<br><br>url:string - The location to create the websocket to, by default this "
                      "is the server that the browser environment has been served from.  This must use "
                      "a `ws` or `wss` scheme, such as: "
                      "`ws://hostname/path/to/websocket_handler`.<br>name:string - The name assigned "
                      "to the remote_evaluator.  By default the name is \"remote\", but it can be set to "
                      "a specific name for identification purposes in callouts, "
                      "etc.<br>on_message:function - When provided, this function is called with the "
                      "received data packet from the server when the remote system has sent a message "
                      "that isn\'t correlated to an originating request from the client (browser).  "
                      "Note that this function is not called for requests that have originated via the "
                      "`eval` interface function.<br>on_close:function - When the websocket is closed, "
                      "and this option is provided, this function is called with the close event and "
                      "the interface of the `remote_evaluator` object that received the close event.  "
                      "`(event interface)`<br>on_error:function - If an error occurs with the remote "
                      "evaluator connection, this function is called with the event and the "
                      "`remote_evaluator`.  `(event interface)`<br>on_heartbeat:function - Called when "
                      "the heartbeat message is received (every 30 seconds).  `(response "
                      "interface)`<br><br><br>#### Interface <br><br>process_mode:function - returns "
                      "the current response processing mode of the system as a string.  `eval` or "
                      "`quoted`<br>set_process_mode:function - sets the processing mode.  Valid modes "
                      "are `eval` or `quoted`.<br>evaluate:function - Given a string of lisp code, "
                      "will remotely evaluate the lisp and return the result.<br>eval:function - Given "
                      "a JSON structure, will remotely evaluate the lisp and return the "
                      "result.<br>url:string - Will return the url that the remote evaluator is "
                      "connected or was connected to.<br>on_message:function - Returns the on_message "
                      "function assigned in options or the default on_message function (which is to "
                      "send to log)<br>ws:Websocket - will return the websocket instance supporting "
                      "the remote evalutor.<br>round_trip_time:function - will return the latest round "
                      "trip time in milliseconds between the client and the "
                      "server<br>num_requests:function - returns the number of requests processed by "
                      "the remote evaluator<br>name:function - returns the name assigned to the remote "
                      "evaluator.<br>close:function - closes the remote evaluator if "
                      "open.<br>open?:function - Returns `true` if the remote evaluator is currently "
                      "open and `false` if it is not.<br>state:function - Returns the integer value of "
                      "the `readyState` of the websocket <br>connect:function - Attempts to connect "
                      "the websocket.  Note that this function shouldn\'t be called after "
                      "initialization.  The remote_evaluator is returned in a connected state under "
                      "normal conditions.<br><br>")
     usage: ["options:?object"]
     tags: ["websocket" "remote" "server" "rblock" "eval" "evaluate"]
   })

(defun get_remote_sys_evaluator (options)
   (let
      ((name (if (and (is_object? options)
                      options.name)
                 options.name
                 "sys_remote"))
       (existing_evaluator (prop *evaluators* name))
       (create_new (fn ()
                      (let
                         ((remote (create_remote_evaluator { `name: name })))
                         (if remote.open?
                            (progn
                               (set_prop *evaluators*
                                  name
                                  remote)
                               remote)
                            (throw EvalError "get_remote_sys_evalutor: unable to create remote connection"))))))
      (cond 
         (and existing_evaluator 
            (-> existing_evaluator `open?)) 
         ;; it's there and open, use it
         existing_evaluator
         ;; it's there but not open, so reset it
         existing_evaluator
         (progn
            (delete_prop *evaluators* name)
            (create_new))
         else
         (create_new)))
   {
     description: (+ "Returns the global `remote_evaluator` instance for the system.  If "
                     "there isn\'t one created, will attempt to create it before returning it to the "
                     "caller, otherwise it will return the existing one.  Global remote evaluators "
                     "are available in the `core/*evaluators*` object, which stores the global pool "
                     "of evaluators. The default evaluator is `sys_remote`. <br><br>#### Options "
                     "<br><br>name:string - The optional name for the remote evaluator to be used or "
                     "created in the global evaluator pool.<br><br>For more details on remote "
                     "evaluation, see `create_remote_evaluator`.<br> ")
     usage: ["options:?object"]
     tags: ["websocket" "remote" "server" "rblock" "eval" "evaluate"]
     })

(defmacro rblock (`& block_body)
   (let
      ((quoted_block block_body))
   `(let
       ((remote_evaluator (get_remote_sys_evaluator)))
       (-> remote_evaluator 
          `eval
          `(progn
             ,@quoted_block))))
   {
     `description: (+ "The `rblock` macro allows for 1 or more forms to be evaluated as a "
                      "block on the remote system.  The forms, which are provided as arguments are "
                      "provided unquoted, and, like `progn`, the final form or statement return value "
                      "is returned.<br>The `rblock` macro quotes the lisp forms within it prior to "
                      "transmission so they aren\'t evaluated locally.  However, this means that local "
                      "scope isn\'t available naturally and any references into the local scope need to "
                      "be unquoted,<br><br>### Example   <br><br>A simple example of validating the "
                      "name of a host system:```(rblock\n   (if (== \"home_server\" (hostname))\n    "
                      "true\n      false))\n```<br><br>An example of a function that combines local "
                      "references into a remotely evaluated form:```(defun ll (`& args)\n   (let\n     "
                      "((cmd (+ \"ls -l \" (join \" \" args)))\n       (lines (rblock\n                "
                      "(let\n                    ((out (prop (sys/system ,#cmd) `stdout)))\n            "
                      "       (split_by \"\n\" out))))\n       (split_lines (map (fn (l)\n                "
                      "           (no_empties (split_by \" \" l)))\n                         lines)))\n   "
                      "  (dtable \n         split_lines)))```<br><br>In the above note how the locally "
                      "scoped `cmd` is being referenced in the remote block by using the unquote "
                      "operator `,#`.<br>The results of the `rblock` evaluation are then processed "
                      "locally and presented in an html table form.<br><br> ")



     `usage: ["arg0:*" "arg1:*" "argN:*"]
     `tags: ["websocket" "remote" "server" "rblock" "eval" "evaluate" "create_remote_evaluator"]
     })

(defun cwd ()
   (if is_served?
      (rblock (sys/cwd))
      nil)
   {
     `description: (+ "If the browser environment is hosted ( `is_served?` is `true` ), "
                      "returns the current working directory of the server process the browser "
                      "environment is attached to, otherwise `nil` is returned. ")
     `usage: []
     `tags: ["system" "server" "current" "directory" "working" "folder"]
   })

(defun stat_file (path)
   (if is_served?
      (try 
         (eval `(rblock (sys/stat ,#path)))
         (catch Error (e)
            (throw e)))
       "Remote evaluator not available")
   {
     `description: (+ "Given a string based path that is accessible to the server process, "
                      "returns an object representing the path\'s target characteristics.  Note this "
                      "function must be evaluated when the client environment is able to use "
                      "the `rblock` macro, which requires WebSocket support enabled in the server. ")
     `usage: ["path:string"]
     `tags: ["file" "files" "fs" "filesystem" "stat" "properties"]
   })

(defun set_system_repl (repl_control)
   (cond
      (and repl_control 
         (== repl_control *system_repl*))
      (progn
         (log (dtext "set_system_repl: the specified control is already the system repl"))
         false)
      (and repl_control
         (== repl_control.type "visual_repl"))
      (progn
         (if *system_repl*
            (remove_prop (prop *system_repl* `options)
               `locked))
         (set_prop repl_control.options
            `locked
            true)
         (= *system_repl*
            repl_control)
         true)
      repl_control
      (progn
         (log (dtext "set_system_repl: the specified argument must be a 'visual_repl'"))
         false)
      else
      (progn
         (log (dtext "set_system_repl: no control specified to be the *system_repl*."))
         false))
   {
     `description: (+ "Given a `visual_repl` control instance, sets that repl to the "
                      "`*system_repl*`.  The *system_repl* is a global variable pointing to a "
                      "`visual_repl` instance that messages, errors and events are displayed on.  "
                      "Returns `true` if the provided control is successfully set to the system repl.  "
                      "Otherwise, the command will return false and log an error message.<br> ")
     `tags: ["repl" "system" "log" "messages" "errors" "display"]
     `usage: ["repl_control:object"]
   })

(defparameter *repl_counter* 0)

(defun visual_repl (options)
  (let
      ((options (or options {}))
       (repl_number (inc *repl_counter*))
       (last_result_symbol (or options.result_symbol (+ "$" repl_number)))
       (name (progn
                (cond
                   (and options.name
                      (get_control_by_name options.name))
                   (progn
                      (+ options.name " - " repl_number))
                   options.name
                   options.name
                   else
                   (progn
                      (+ "Visual REPL - " repl_number)))))
       (resize_observer nil)
       (search_input (input { `type: "search" `class: "juno-search" }))
       (id (or options.id (generate_id "repl")))
       (namespace_span  (span { `title: "REPL Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } (current_namespace)))
       (display_mode_span (span { `title: (dtext "Display Mode") `class: "juno-mode" style: "float: right;"} "INIT"))
       (location_span (span { `title: "Location" `style: "float: right; display:inline-block; padding-left: 10px; padding-right: 10px;" } 
                          (if options.remote_repl
                                   "Connecting"
                                   "Browser")))
       (control_button (commands_button id));  { `title: "REPL Commands" } "⋯"))
       (title_span (span { `class: "juno-title"  `style: "cursor: pointer;"} name))
       (show_prototype_details_button (button { `title: (dtext "Show Object Prototype Detail") } "P"))
       (path_span (span { `tabindex: 0 `title: (dtext "Click to copy focused path")  `class: "juno-path" } ""))
       (current_env Environment)
      ; (error_state nil)
       (reopen_button (button { `title: (dtext "Connect/Disconnect") `class: "juno-button-on" style: "float: right;" `tabindex: 0 `disabled: true }
                              "-"))
       (ws_id_span (span { `title: (dtext "Server websocket ID") `class: "juno-websocket-id" `style: "padding-left: 5px; padding-right: 5px; display: inline-block; float: right;" } "-"))
       (last_result_symbol_span (span { `title: (dtext "Last Result Symbol") `class: "juno-type-symbol juno-pointer juno-monospace" `style: "padding-left: 5px; padding-right: 5px; display: inline-block;;" } "-"))
       (set_reopen_button_state (fn (state)
                                   (cond
                                      (== state 2) ;; allow reconnect
                                      (progn
                                         (set_enabled reopen_button)
                                         (set_attribute reopen_button `title "Reconnect")
                                         (remove_class "juno-button-on" reopen_button))
                                      (== state 1) ;; connecting
                                      (progn
                                         (set_disabled reopen_button)
                                         (add_class "juno-button-on" reopen_button))
                                      else ;; connected state
                                      (progn
                                         (set_attribute reopen_button `title "Disconnect")
                                         (set_enabled reopen_button)
                                         ;(remove_class "juno-button-on" reopen_button)
                                         ))))
       
       (remote_command_timeout 120000) ;; 2 minute default
       (initialized false)       
       (intf nil)       
       (toggle_prototype_detail (function ()
                                          (progn                                           
                                           (set_prop options.display_options
                                                     `include_prototypes
                                                     (not options.display_options.include_prototypes))
                                           (set_prop output_control.options.display_options                                                     
                                                     `include_prototypes options.display_options.include_prototypes)
                                           (if options.display_options.include_prototypes
                                             (add_class "juno-button-on" show_prototype_details_button)
                                             (remove_class "juno-button-on" show_prototype_details_button)))))
       (output_control (progn
                          (log_view { `display_options: (or options.display_options { `show_timestamps: false } )
                                      `on_focus: (fn (e)
                                                    (progn
                                                       (on_focus true))) ;; suppress the focus loop but redirect the focus to this control
                                      `hide_command_button: true
                                      `additional_elements: [ control_button 
                                                             title_span 
                                                             show_prototype_details_button 
                                                             namespace_span 
                                                             last_result_symbol_span
                                                             path_span
                                                             display_mode_span 
                                                             (if options.remote_repl ws_id_span [])
                                                             location_span
                                                             (if options.remote_repl reopen_button [])] 
                                      `id: id })))
       (history (if (is_array? options.history)
                  options.history
                  []))
       (rename (fn (new_name)
                  (if (is_string? new_name)
                      (cond
                         (get_control_by_name new_name)
                         (throw Error (+ "control with name '" new_name "' already exists"))
                         else
                         (try
                            (progn
                               (set_prop options `name
                                  new_name)
                               (set_prop title_span
                                  `innerHTML
                                  new_name)
                               (set_prop intf
                                  `name
                                  new_name)
                               (= name new_name)
                               (dispatch_event { command: "control_name_change"
                                                 source: options.id
                                                 args: [ { `option: "name" `value: name } ] }))
                            (catch Error (e)
                               (progn
                                  (log  (+ "Unable to rename: " e.message)))))))))
      (prompt_rename (fn ()
                        (aif (request_user_input (+ (dtext "Rename") ": " intf.name)
                                            `text)
                             (rename it))))
      
      (determine_focus (fn ()
                          (let
                             ((element document.activeElement)
                              (sub_control (when element
                                              (while (and element
                                                          (not (== element output_control.view))
                                                          (not (== element input_container.view)))
                                                 (= element element.parentElement))
                                              element)))
                             (cond 
                                (and sub_control
                                   (== sub_control output_control.view))
                                (progn
                                   output_control)
                                (and sub_control
                                   (== sub_control input_container.view))
                                (progn
                                   input_container)))))
      (cut_selection (fn ()
                        (aif (determine_focus)
                             (-> it `cut_selection))))
      (copy_selection (fn ()
                         (aif (determine_focus)
                              (-> it `copy_selection))))
      (paste_selection (fn ()
                          (aif (determine_focus)
                               (-> it `paste_selection))))
      
      
      (clog (fn (`& args)
               (progn
                  (apply console.log args)
                 
                  (-> intf `log (apply div { `style: "display: flex;" }
                                       (for_each (val args)
                                          (div { `style: "padding-right: 10px" } (value_to_dom val)))))
                  nil)))
       (push_history (fn (lisp_text)
                       (progn
                        (push history
                                lisp_text)
                        (= history_idx history.length)
                        (when (> history.length (or options.max_history_size
                                                    50))
                          (take history)))))
       (history_idx 0) 
       (history_prior_entry (fn ()
                              (when (> history.length 0)
                                 (dec history_idx)
                                 (when (or (< history_idx 0)
                                           (>= history_idx history.length))
                                    (= history_idx history.length))
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (-> input_container `set (prop history history_idx)))
                               )))
       (history_next_entry (fn ()
                              (when (> history.length 0)
                                 (inc history_idx)
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (progn
                                        (if (>= history_idx history.length)
                                            (= history_idx 0))
                                        (-> input_container `set (prop history history_idx)))))))
       (clear_output (fn ()
                       (-> output_control `clear)))
       (clear_history (fn ()
                        (progn
                         (= history [])
                         (= history_idx 0))))
       
       (repl_key_bindings (function ()
                                    (map (function (kb)
                                             (destructuring_bind (command_name bindings)
                                                 kb                                                                                                                  
                                                 { name: command_name
                                                   mac: (prop bindings `mac)
                                                   win: (prop bindings `win)
                                                  exec: (function (editor)
                                                                  (-> intf command_name editor)) }))                                                                                                                                                                  
                                         (or (pairs *key_bindings*.repl) []))))
       (repl_ws nil)
       (request_id 0)
       (requests {})
       (remote_host nil)
       (cached_symbols {})
       (busy_with_cache_update false)
       (available_symbols (fn ()
                             (progn
                                (while busy_with_cache_update
                                   (sleep 0.2))
                                (= busy_with_cache_update true)
                                (defvar start_time (time_in_millis))
                                (defvar timings [])
                                (if options.remote_repl
                                   (let
                                      ((result (try
                                                  (send_wait "(symbols_by_namespace { include_meta: true })" { suppress_store_last_result: true })
                                                  (catch Error (e)
                                                     (progn
                                                        (log "ERROR on available_symbols: remote: " e)
                                                        nil)))))
                                      (push timings (- (time_in_millis) start_time))
                                      (if result
                                         (progn
                                            (try 
                                               (= result (reader result.result { pause_time: 0.01 }))
                                               (catch Error (e)
                                                  (log "ERROR on available_symbols update: " result)))
                                            (= busy_with_cache_update false)
                                            (push timings (- (time_in_millis) start_time))
                                            (when (> __VERBOSITY__ 0)
                                               (log options.name ": timings: " (as_lisp timings)))
                                            result)
                                         (progn
                                            (= busy_with_cache_update false)
                                            (push timings (- (time_in_millis) start_time))
                                            (when (> __VERBOSITY__ 0)
                                               (log options.name ": timings: " (as_lisp timings)))
                                            {})))
                                   (progn
                                      (= busy_with_cache_update false)
                                      (symbols_by_namespace { include_meta: true }))))))
       (open_remote_evaluator 
          (fn ()
             (if options.remote_repl
                (progn
                   (= repl_ws
                      (http/create_websocket
                         options.remote_repl
                         {
                           `on_message: (fn (event)
                                           (try
                                              (let
                                                 ((data nil)
                                                  (pdata nil)
                                                  (resolver nil))
                                                 
                                                 (try
                                                    (= data (JSON.parse event.data))
                                                    (catch Error (e)
                                                       (progn
                                                          (clog "Unable to parse json data: " e.message)
                                                          (= data event.data))))
                                                 (if (or options.debug 
                                                         (> __VERBOSITY__ 1))
                                                    (clog "remote: <-" data))
                                                 (if (and (is_object? data)
                                                          data.ws_id)
                                                     (set_prop intf
                                                        `ws_id
                                                        data.ws_id))
                                                 (cond
                                                    (and (is_object? data)
                                                         data.req_id)
                                                    (progn
                                                       
                                                       (if (prop requests data.req_id)
                                                           (progn
                                                              (= pdata (prop requests data.req_id))
                                                              (remove_prop requests data.req_id)
                                                              (clearTimeout (third pdata)) ;; remove the timeout
                                                              (if (== data.rval "OK")
                                                                  (progn
                                                                     (= resolver (first pdata))
                                                                     (resolver data nil))
                                                                  (progn
                                                                     (= resolver (first pdata)) ;; we will resolve the promise and handle the error in our remote eval result function.
                                                                     (resolver data true))))
                                                           (progn
                                                              ;; received a request but it is not tied to a request we made, could be a log message
                                                              
                                                              (if (== data.rval "OK")
                                                                  (progn
                                                                     
                                                                     (apply output_control.log_message (process_remote_eval_result data (-> output_control `display_mode))))
                                                                  (clog data.message)))))
                                                    (and (is_object? data)
                                                         data.result
                                                         data.is_log)
                                                    (clog (pretty_print (read_lisp data.result)))
                                                    (and (is_object? data)
                                                         data.result)
                                                    (progn
                                                       (-> output_control `log_message (process_remote_eval_result data (-> output_control `display_mode))))
                                                    else
                                                    (clog data)))
                                              (catch Error (e)
                                                 (clog "Unable to process received message: " e.message))))
                           `on_open: (fn (event)
                                        (progn
                                           (defvar active_ns nil)
                                           (defvar rval nil)
                                           (clog (+ "Connected to Remote REPL: " options.remote_repl))
                                           (set_reopen_button_state 0)
                                           (try
                                              (progn
                                                 (= rval (send_wait "(hostname)"))
                                                 (= remote_host rval.result)
                                                 (cond 
                                                    (is_string? remote_host)
                                                    (progn
                                                       (= remote_host (chop_front (chop remote_host)))
                                                       (set_prop location_span
                                                          `innerHTML remote_host))
                                                    else
                                                    (clog "ERROR: received invalid response for hostname: " remote_host))
                                                 (if rval.ws_id
                                                    (set_prop ws_id_span
                                                       `innerText
                                                       rval.ws_id))
                                                 (= active_ns (prop (send_wait (+ "(use_ns " namespace_span.innerText ")")) `result))
                                                 (if active_ns 
                                                    (clog (+ "Namespace set to: " (JSON.parse active_ns)))
                                                    (clog "Unable to set namespace"))
                                                 (send_wait (+ "(http/sub_log " rval.ws_id ")")))
                                              (catch Error (e)
                                                 (clog "Unable to determine remote hostname: " e)))))
                           `on_close: (fn (event)
                                         (progn
                                            (clog "Interface is now closed")
                                            (set_reopen_button_state 2)))
                           `on_error: (fn (event)
                                         (progn
                                            (set_reopen_button_state 2)
                                            (clog "Error on WS:" event)))
                           }))
                   (defglobal *repl_ws* repl_ws)))))
       (send_wait (fn (lisp_text opts)
                     (let
                        ((rval nil))
                        (assert (and (instanceof repl_ws WebSocket)
                                     (== repl_ws.readyState repl_ws.OPEN))
                                "Websocket is not open")
                        ;(clog "ws-> ")
                       (try
                          (= rval (new Promise 
                                       (fn (resolve reject)
                                          (let
                                             ((my_request_id (inc request_id))
                                              (timer nil))
                                             (= timer (setTimeout (fn ()
                                                                     (progn
                                                                        (clog "timeout occurred")
                                                                        (reject { `rval: "FAIL" `message: (+ "Timeout on request id: " my_request_id) })))
                                                                  remote_command_timeout))
                                             ;; set the request id in request object, and then wait to resolve the promise until results are returned, or a timeout occurs
                                             (set_prop requests
                                                my_request_id
                                                (list resolve reject timer))
                                             (try 
                                                (http/send_to_ws repl_ws
                                                                 { `command: "eval"
                                                                   `req_id: my_request_id
                                                                   `last_result: (unless (or opts.suppress_store_last_result
                                                                                             options.suppress_store_last_result)
                                                                                    last_result_symbol)
                                                                   `args: [ lisp_text opts] })
                                                (catch Error (e)
                                                   (progn
                                                      (notify (+ "send_wait: error: " e.message))
                                                      (clog "ERROR on send_to_ws: " e))))
                                             true))))
                             (catch Error (e)
                                (log (+ "Error on send_wait: " e))))
                       rval)))
                                                
       
       (evaluator (fn (lisp_text no_eval no_clear no_log opts)
                    (let
                        ((result nil)
                         (processed_result nil)
                         (current_ns (prop namespace_span `innerText))
                         (display_mode (-> output_control `display_mode))
                         (error_state nil)
                         (structured_text nil)
                         (compiled_metadata nil)
                         (compiled_source nil)
                         (compl_complete (fn (compilation_results)
                                            (progn
                                               (= compiled_metadata compilation_results.0)
                                               (= compiled_source compilation_results.1)))))
                        (setq error_state nil)
                        (setq compiled_source nil)
                        (setq compiled_metadata nil)
                        (if options.remote_repl
                         (progn
                            (try
                               (progn
                                  (= result (send_wait lisp_text opts)))
                               (catch Error (e)
                                  (do
                                     (= error_state true)
                                     (when e.message
                                        (notify (+ "Remote Error: " e.message))))))
                            (when (is_object? result)
                               (if (not (== result.namespace current_ns))
                                   (dispatch_event {
                                                     command: "evaluator_change"
                                                     source: id
                                                     args: [{ set: "namespace" value: result.namespace }]
                                                    }))
                               (set_prop namespace_span
                                  `innerText
                                  (or result.namespace "Unknown!"))
                               (set_prop ws_id_span
                                  `innerText
                                  result.ws_id))
                            
                            (cond 
                               (== display_mode "juno")
                               (= processed_result (pre (pretty_print (process_remote_eval_result result display_mode))))
                               (== display_mode "json")
                               (= processed_result (pre (JSON.stringify (process_remote_eval_result result display_mode) nil 2)))
                               else
                               (= processed_result (process_remote_eval_result result display_mode)))
                            ;; set the results to be returned to the caller 
                            ;; they will not be dressed up in Elements if tree mode
                            (when (and (is_object? result)
                                       (is_string? result.result))
                               (set_prop result
                                  `result
                                  (read_lisp result.result)))
                            
                            (unless no_log
                               (-> output_control `append processed_result lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set ""))
                            (= result
                               (cond
                                  (is_array? result)
                                  result
                                  (is_object? result)
                                  result.result
                                  else
                                  result)))
                            
                         (progn
                            (setq current_env (-> Environment `get_namespace_handle current_ns))
                            (assert (== current_ns current_env.namespace) (+ "visual_repl: namespace not valid: " current_ns))
                            (try
                               (progn
                                  (= error_state nil)
                                  (= structured_text (reader lisp_text { `suppress_throw_on_error: true 
                                                                         `on_error: (fn (error)
                                                                                       (progn
                                                                                          ;; opportunity to do error highlighting
                                                                                          (= error_state error))) } ))
                                  (cond
                                     (and (not error_state)
                                          (== structured_text.0 (quote use_ns)))
                                     (progn
                                        (if (contains? (desym_ref structured_text.1) (namespaces))
                                            (progn
                                               (set_prop namespace_span
                                                  `innerText
                                                  (desym_ref structured_text.1))
                                               (if (not (== result.namespace current_ns))
                                                   (dispatch_event {
                                                                     command: "evaluator_change"
                                                                     source: id
                                                                     args: [{ set: "namespace" value: (desym_ref structured_text.1) }]
                                                                     }))
                                               (clog (desym_ref structured_text.1)))
                                            (clog "Invalid Namespace: " structured_text.1 "Allowed: " (namespaces))))
                                     else
                                     (if error_state
                                        (throw LispSyntaxError error_state)
                                        (= result (if no_eval
                                                      lisp_text
                                                      (-> current_env `evaluate_local structured_text {} (+ { `json_in: true `throw_on_error: true `on_compilation_complete: compl_complete } (if opts opts {}))))))))
                               (catch Error (ex)
                                  (do
                                     (= error_state true)
                                     (console.error "ERROR: " ex)
                                     (notify (+ (sub_type ex) ": " ex.message))
                                     (when  ex.details
                                       ; (log "Caught error: " ex.details)
                                        (when compiled_source
                                           (set_prop ex.details
                                              `compiled
                                              compiled_source
                                              `compiled_metadata
                                              compiled_metadata
                                              `stack 
                                              ex.stack)
                                           (set_prop ex.details
                                                     `problem_buffer
                                                     (pre (process_stack_trace ex.details))))
                                           
                                        (when (and ex.details.expanded_source
                                                   (== display_mode "tree"))
                                           (set_prop ex.details
                                              `expanded_source
                                              (pre ex.details.expanded_source)
                                              `compiled
                                              (pre ex.details.compiled))))
                                        (= result ex.details))))
                            ;(log "<-" result)
                            (unless options.suppress_store_last_result
                               (set_global last_result_symbol result))
                            (cond 
                               (== display_mode "juno")
                               (= result (pre { `quoted: true } (pretty_print result)))
                               (== display_mode "json")
                               (= result (pre { `quoted: true }  (JSON.stringify result nil 2))))
                            
                            (unless no_log
                               (-> output_control `append result lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set ""))))
                            
                      result)))
       (input_container_name (+ (gen_id "visual_repl") "-input"))
       (input_container (text_editor 
                                  {
                                   mode: "juno"                                                                                                                             
                                   on_change: (function (editor val)
                                                        (progn
                                                         true))
                                   name: input_container_name
                                   theme: options.theme
                                   id: id
                                   evaluator_id: id
                                   disallow_control_focus: true
                                   clone_with_editor_id: options.clone_with_editor_id
                                   repl_mode: true
                                   display_control_bar: false
                                   on_evaluation: (fn (lisp_text results)
                                                     (push_history lisp_text))
                                   commands: (repl_key_bindings)
                                   on_initialized: (fn (control)
                                                       (when initialized
                                                          (try
                                                             (-> control.editor `focus)
                                                             (catch Error (e)
                                                                (log "error on focus: " e.message)))))
                                                       }))

       (sview (split_view_horizontal
                                 output_control
                                 input_container
                                 { `ratio: (or options.ratio 0.7) `id: id } ))  ;; 80/20 top-bottom
       
       (view sview.view)
       (non_whitespace_regex (new RegExp "\\\\s"))
       (hidden false)
       (blurred true)
       (last_focus_elem nil)
      
       ;; focus_event is fired whwn the focusin event hits the view
       (focus_event (fn (e)
                       (when e
                          (= last_focus_elem e.srcElement)
                          (add_class "juno-focused" output_control.control_bar)
                          )))
       
       (on_focus (fn (suppress_output_focus_call)
                   (progn
                      (if suppress_output_focus_call
                         (progn
                           (cond 
                              (or hidden blurred)
                              (focus_to input_container.editor)))
                              
                         (-> output_control `on_focus))
                      (when blurred
                         (= blurred false))
                      (when hidden
                         (= hidden false))
                    ;(-> input_container.editor `focus) ;; bring focus to the repl
                    (add_class "juno-focused" output_control.control_bar )
                    (set_prop intf
                       `editor
                       (resolve_path [ `editor_container `editor ] intf)))))
       (on_blur (fn ()
                  (progn
                     (= blurred true)
                     true)))
       (on_hide (fn ()
                   (progn
                      (when output_control
                         (-> output_control `on_hide))
                      (= hidden true))))
       (destroy (fn ()
                  (if options.locked
                     (throw EvalError (+ "" options.name " is marked as locked and cannot be destroyed"))
                     (progn
                        (if options.remote_repl
                            (try
                               (progn
                                  (log "remote_repl state: " repl_ws.readyState)
                                  (when (== repl_ws.readyState repl_ws.OPEN)
                                     (log "remote_repl: closing open connection on destroy. ")
                                     (-> repl_ws `close))
                                  (log "remote_repl state: clean up complete."))
                               (catch Error (e)
                                  (log "remote_repl: couldn't close the socket: " e.message))))
                           
                        (-> input_container `destroy)))))
       (modes { `tree: 0 `juno: 1 `json: 2 } )
       (set_display_mode (fn (mode)
                            (let
                               ((modenum (cond
                                            (is_string? mode)
                                            (or (prop modes (lowercase mode)) 0)
                                            (is_number? mode)
                                            mode
                                            else 
                                            0)))
                               (-> output_control `set_display_mode modenum)
                               (set_prop options.display_options `display_mode modenum)
                               (set_prop display_mode_span
                                  `innerText (-> output_control `display_mode)))))
       (prompt_last_result_symbol_rename 
          (fn ()
             (aif (request_user_input (dtext "What symbol should be used for storing the last return value?")
                                      `text
                                      { `default_value: last_result_symbol })
                  (progn
                     (unless (blank? it)
                        (set_prop options
                           `result_symbol it)
                        (set_prop last_result_symbol_span `innerText it)
                        (unless (is_symbol? options.result_symbol)
                           (set_global it nil))
                        (= last_result_symbol options.result_symbol))))))
       
       (menu_items (fn ()
                     [[(dtext "Clear Output Log")
                       (function ()
                                 (clear_output))]
                      [(dtext "Search Output Log")
                       (fn ()
                          (-> output_control `open_search))]
                      [(dtext "Clear REPL History")
                       (function ()
                                 (clear_history))]
                      [(dtext "Rename")
                       prompt_rename ]
                      [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                       (function ()
                                 (toggle_prototype_detail))]
                      
                     
                      [(if output_control.options.display_options.show_timestamps
                         (dtext "Hide Timestamps")
                         (dtext "Show Timestamps"))
                       (function ()
                                 (progn
                                    (if output_control.options.display_options.show_timestamps
                                       (-> output_control `set_show_timestamps false)
                                       (-> output_control `set_show_timestamps true))
                                    (set_prop options.display_options
                                              `show_timestamps
                                              output_control.options.display_options.show_timestamps)))]
                      [(dtext "Set Max Log Lines")
                       (fn ()
                         (aif (request_user_input (+ (dtext "Enter the number of log lines to keep") ":") 
                                                  `number 
                                                  { `default_value: (-> output_control `max_log_lines) })
                              (progn
                                 (-> output_control `set_max_log_lines (int it)))))]
                      [(+ (dtext "Set Display Mode") "...")
                       [[(dtext "Tree")
                         (fn ()
                            (set_display_mode `tree))]
                        [(dtext "Juno")
                         (fn ()
                            (set_display_mode `juno))]
                        [(dtext "JSON")
                         (fn ()
                            (set_display_mode `json))]]]
                      (if (== output_control.options.smooth_scroll_mode false)
                          [(dtext "Turn On Smooth Scrolling")
                           (fn ()
                              (-> output_control `set_smooth_scroll_mode true))]
                          [(dtext "Turn Off Smooth Scrolling")
                            (fn ()
                               (-> output_control `set_smooth_scroll_mode false))])
                      [(dtext "Set as *system_repl*")
                       (fn ()
                          (if (set_system_repl intf)
                              (-> input_container `display_context_message (+ "*system_repl* / REPL Mode: Press Shift-Enter to evaluate editor contents"))
                              (-> input_container `display_context_message "Unable to set this repl as the *system_repl*")))]
                      [(dtext "Set Editor Theme") (for_each (theme (get_default [ `editor `themes ]))
                                                            [theme  (fn ()
                                                                      (progn
                                                                       (set_prop options `theme theme)
                                                                       (-> input_container `set_theme theme)))])]
                      [(+ (dtext "Last Result") " " "[" last_result_symbol "]" "...")
                       [(if options.suppress_store_last_result
                            [(+ (dtext "Store last result in") " " last_result_symbol)
                             (fn ()
                                (progn
                                   (remove_class "juno-strike-out" last_result_symbol_span )
                                   (set_prop options
                                      `suppress_store_last_result false)))]
                            [(+ (dtext "Do not store last result in") " " last_result_symbol)
                             (fn ()
                                (progn
                                   (add_class "juno-strike-out" last_result_symbol_span )
                                   (set_prop options
                                      `suppress_store_last_result true)))])
                        [(dtext "Set Symbol Name")
                         (fn ()
                            (prompt_last_result_symbol_rename))]]]
                      ]))
       (initialize (fn ()
                      (when (and view.parentElement
                                 (not initialized))
                        (progn
                         (= initialized true)
                         (console.log "repl initializing")
                         (try
                            (-> output_control `initialize)
                            (catch Error (e)
                               (notify e.message)))
                         (when (eq nil options.display_options)
                           (set_prop options
                                     `display_options
                                     { `include_prototypes: false 
                                       `show_timestamps: output_control.options.display_options.show_timestamps 
                                       `display_mode: (or output_control.options.display_options.display_mode 0)
                                     }))
                         (set_prop options
                            `result_symbol
                            last_result_symbol)
                         (set_prop last_result_symbol_span `innerText last_result_symbol)
                         (when options.suppress_store_last_result
                            (add_class "juno-strike-out" last_result_symbol_span ))
                         (if options.display_options.include_prototypes
                           (add_class "juno-button-on" show_prototype_details_button))
                         (try
                            (if options.remote_repl
                               (progn
                                  (clog  (html/div { `style: "display: flex padding: 5px" }                
                                                                       (html/span { `style: "font-weight: bold; display: inline-block;" } "connecting to: ")
                                                                       (html/span { `style: "display: inline-block; margin-left: 10px;" }
                                                                                  options.remote_repl )))
                                  
                                  (open_remote_evaluator)))
                            (catch Error (e)
                               (clog "Cannot open remote REPL: " e.message)))
                         
                         (set_prop reopen_button
                            `innerHTML
                            (if (== (get_operating_platform) "win")
                                (dtext "Connect")
                                "&#9211;"))
                         (attach_event_listener reopen_button
                            `click
                            (fn (e)
                               (progn
                                  ;(clog "repl readyState: " (prop repl_ws `readyState))
                                  (cond
                                     (== (prop repl_ws `readyState) 1)
                                     (progn 
                                        (-> repl_ws `close))
                                     else
                                     (progn
                                        (set_reopen_button_state 1)
                                        (open_remote_evaluator))))))
                         (attach_event_listener title_span
                            `click
                            prompt_rename)
                         
                         (attach_event_listener last_result_symbol_span
                            `click
                            prompt_last_result_symbol_rename)
                         
                         (attach_event_listener view
                            `focusin
                            focus_event)
                         
                         (unless (is_symbol? last_result_symbol)
                            (set_global last_result_symbol nil))
                         
                         ;; set the computed name
                         (set_prop options
                            `name
                            name)
                         (log output_control.options)
                         (setTimeout (fn ()
                                        (set_prop display_mode_span
                                           `innerText (-> output_control `display_mode)))
                                     100)
                         ;; become the system_repl if none is yet defined
                         (if (eq nil *system_repl*)
                             (progn
                                (= *system_repl* intf)
                                (set_prop options
                                   `locked true)
                                (setTimeout (fn ()
                                               (progn
                                                  (-> input_container `display_context_message (+ "*system_repl* / REPL Mode: Press Shift-Enter to evaluate editor contents"))))
                                            250))
                             (setTimeout (fn ()
                                            (-> input_container `display_context_message "REPL Mode: Press Shift-Enter to evaluate editor contents")
                                            250)))
                         true)))))
      
       (attach_event_listener output_control.output_container
                           `focusin
                           (function (e)
                             (progn
                              (handle_event e)
                              (console.log "output-control: focus: " (-> e.srcElement `getAttribute "lpath") e.srcElement)
                              (aif (-> e.srcElement `getAttribute "lpath")
                                   (progn
                                    (set_prop path_span
                                             `innerText
                                             (+ "[ " (join " "
                                                           (for_each (v (split_by "~" it))
                                                                     (cond (> (length (scan_str non_whitespace_regex v)) 0)
                                                                           (+ "\"" v "\"")
                                                                           (isNaN (new Number v))
                                                                           (+ "`" v)
                                                                           else
                                                                           v)))
                                                           " ]"))
                                    (console.log "setting path span:: " it))
                                   (progn
                                    (console.log "clearing path span")
                                    (set_prop path_span
                                             `innerText
                                             ""))))))
     
    (attach_event_listener show_prototype_details_button
                           `click
                           (fn (e)
                             (progn
                              (handle_event e)
                              (toggle_prototype_detail))))
    
    (attach_event_listener path_span
                           `click
                           (fn (e)
                             (progn
                              (copy_text_to_clipboard path_span.innerText)
                              (notify (+ (dtext "Copied") " " path_span.innerText)))))

    ;; by changing the split_view type value, we prevent this control from being split or
    ;; controls being swapped
    
    (set_prop sview
              `type
              "REPL_split")
    ;(set_prop output_control
     ;  `on_focus
      ; nil)
    (set_prop options
              `id
              id)
                   
    (= intf {
             `view: view
             `options: options
             `name: name             
             `editor_container: input_container             
             `editor: nil ;; will be filled in on initialization 
             `history_next_entry: history_next_entry
             `history_prior_entry: history_prior_entry
             `command_history: (function ()
                                        history)
             `clear_history: (function ()
                                       (clear_history))
             `clear_output: clear_output             
             `set_display_mode: set_display_mode
             `initialize: initialize
             `websocket: (function ()
                            repl_ws)
             `available_symbols: available_symbols
             `current_namespace: (function ()
                                    namespace_span.innerText)
             ;; when the editor has focus it will open it's own search box otherwise open the visual repl search
             `open_search: (fn () (-> output_control `open_search))
             `next_search_result: (fn () 
                                     (progc
                                        (-> output_control `next_search_result)))
             `prior_search_result: (fn () 
                                      (progc
                                         (-> output_control `prior_search_result)))
             `keyword_mapper: input_container.keyword_mapper
             `rename: rename
             `destroy: destroy
             `on_hide: (fn ()
                          (progn
                             (when (is_function? output_control.on_hide)
                                (-> output_control `on_hide))))
             `type: "visual_repl"
             `resize: (fn ()
                       (-> sview `resize))
             `menu_items: menu_items                           
             `on_focus: on_focus
             `on_blur: on_blur  
             `on_hide: on_hide
             `set_theme: (fn (theme_name)
                           (when (contains? theme_name (get_default [ `editor `themes ]))
                             (set_prop options `theme theme_name)
                             (-> input_container `set_theme theme_name)))
             `cut_selection: cut_selection
             `copy_selection: copy_selection
             `paste_selection: paste_selection
             `toJSON: (function ()
                                (progn
                                 (set_prop options
                                           `history
                                           [(quote quotel) history])
                                `(visual_repl ,#(or options { `ratio: sview.options.ratio } ))))
             ;`controls: (fn () [ input_container output_control])
             `output_container: output_control.view
             `log: (fn (val)
                     (-> output_control `log_message val))
             `log_error: (fn (error_message error)
                            (-> output_control `log_error error_message error))
             `evaluate: (fn (lisp_text no_eval no_clear no_log options)
                          (evaluator lisp_text no_eval no_clear no_log options))
             })
    intf))    

(defun set_repl_display_mode (mode ctl)
   (if (is_string? mode)
       (progn
          (cond
             (and (is_control? ctl)
                  (is_function? ctl.set_display_mode))
             (-> ctl `set_display_mode mode)
             (and *last_focus*
                (is_function? (prop *last_focus* `set_display_mode)))
             (-> *last_focus* `set_display_mode mode)
             else
             (throw EvalError "invalid control for mode set"))
          mode)
       (throw TypeError "invalid mode specified - must be a string"))
   {
     `description: (+ "<br><br>Given a mode and an optional target REPL control (or any control that "
                      "has the `set_display_mode` interface method) will set the output display mode "
                      "to the provided mode.<br>Valid mode values are "
                      "either:```tree\njuno\njson```<br><br>If no control argument is given, the control "
                      "that `*last_focus*` is pointing at is used, if it supports the "
                      "`set_display_mode` interface method.<br>The function will return the given mode "
                      "if successful, or throw an error when the mode is not a valid string, or the "
                      "control doesn\'t support the operation. ")
     `usage: ["mode:string" "ctl:?object"]
     `tags: ["REPL" "display" "mode" "output" "format"]
   })


(defcontrol unsaved_controls ()
   ((handle_button_event (fn (elem)
                            (aif (and elem.parentElement
                                      (-> elem.parentElement `getAttribute "for_control_id"))
                                 (progn
                                    (cond
                                       (== elem.innerText (dtext "View"))
                                       (swap_control self (get_control_by_id it))
                                       (== elem.innerText (dtext "Close Control"))
                                       (container_view_operation "destroy" (get_control_by_id it)))))))
    (get_ctls (fn ()
                 (sort (controls_needing_save)
                       { `key: [`options `name] })))
    (ctls (get_ctls))
    (render (fn ()
               (div { `style: "height: 100%; overflow: auto;" } 
                 (dtable (for_each (control (or ctls []))
                            [(or control.name "!") 
                             (from_key control.type) 
                             (or control.options.filename
                                (and control.options.path
                                   (as_lisp control.options.path)))
                             (if (and control.needs_save?
                                               (-> control `needs_save?))
                                          (dtext "Yes")
                                          "")
                             (div { `for_control_id: control.options.id }
                                      (button { `tabindex: 0 } (dtext "View"))
                                      (button { `tabindex: 0 `style: "margin-left: 25px;" } (dtext "Close")))
                             ])
                         {
                             `columns: [(dtext "Name") (dtext "Type") (dtext "Path/File") (dtext "Save Needed?") (dtext "Actions")]
                         }))))
    (on_destroy (fn (self)
                   (progn
                      (clearInterval check_timer)
                      true)))
    (check_timer nil)
    (on_initialize (fn (self)
                      (progn
                         (= check_timer (setInterval 
                                           (fn (v)
                                              (progn
                                                 (defvar new_ctls (get_ctls))
                                                 (when (not (== (sha1 (as_lisp new_ctls))
                                                              (sha1 (as_lisp ctls))))
                                                     (= ctls (get_ctls))
                                                     (set_title (+ "" (length ctls) " Unsaved Controls"))
                                                     (if (== ctls.length 0)
                                                         (destroy_control self)
                                                         (do_render)))))
                                              2500))
                         (set_prop options
                            `temporary true)
                         (set_title (+ "" (length ctls) " Unsaved Controls"))
                         (attach_event_listener view
                            `click
                            (fn (e)
                               (progn
                                  (handle_event e)
                                  (handle_button_event e.srcElement))))
                         self))))
   {
       `control_bar: true
       `usage: []
   })

(defun toggle_unsaved_controls_table ()
   (aif (get_control_by_name "Unsaved Controls")
        (destroy_control it)
        (place_control `top (unsaved_controls))))

;; singleton - if it already exists, just return the control
;; otherwise make it 
(defun control_holding_tank (initial_controls options)
   (aif (get_control_by_name "Holding Tank")
        it
        (let
           ((holding_cell (div { `id: "holding_tank" }))
            (my_controls (if (and initial_controls
                                  (is_array? initial_controls))
                             (to_object
                                (reduce (control initial_controls)
                                   (when control.options.id
                                       ;; call initialize on it since it is coming to us from a rehydration
                                      [control.options.id control])))
                             {}))
            (options (or options {}))
            (intf {})
            (name (or options.name
                      "Holding Tank"))
           
            (initialized false)
            (id (or options.id (generate_id "holding_tank")))
            (title_span (span { `class: "juno-title" } (dtext "Holding Tank") " - " (dtext "non-displayed controls")))
            (buffer_commands_button (commands_button id))
            (control_status (div {  `class: "juno-buffer-bar" }
                                 buffer_commands_button
                                 (cond (is_array? options.additional_elements)
                                    options.additional_elements
                                    else
                                    title_span
                                    )))
            (perform_resize (fn ()
                               (when view.parentElement
                                  (when (not initialized)
                                     (initialize))
                                  (render_view))))
            (resize_observer nil)
            (add_control (fn (control suppress_focus)
                            (when (not (== control intf))
                               (assert (and control.type control.options.id) "Invalid control provided")
                               (set_prop my_controls
                                  control.options.id
                                  control)
                               ;(log "control_holding_tank: " control.options.name  "can_hide?" (and control.can_hide? (-> control `can_hide?)))
                               (if (and (not (resolve_path [ `options `locked ] control))
                                        (or (== control.type "empty_control")  ;; don't store the empty controls since they are placeholders
                                            control.options.temporary          ;; or if the control is marked temporary
                                            (and control.can_hide?       ;; does the control want to be hidden?
                                               (not (-> control `can_hide?)))))
                                   (progn
                                      (when *app_menu_control*
                                         (-> *app_menu_control* `remove_menu control.options.name))
                                      (remove_control control.options.id)
                                      (if control.destroy
                                         (-> control `destroy))
                                      (when (== *last_focus* control)
                                         (== *last_focus* nil))
                                      (unless suppress_focus
                                         (default_focus)))
                                   (progn  ;; control is going to storage - call on_hide if it has i
                                      (when (is_function? control.on_hide)
                                         (-> control `on_hide))
                                      (-> holding_cell `append control.view)))
                               (render_view)
                               control)))
            (remove_control (fn (id)
                               (if (is_object? id)
                                   (aif (prop my_controls id.options.id)
                                        (progn
                                           (remove_prop my_controls id.options.id)
                                           (render_view)))
                                   (aif (prop my_controls id)
                                        (progn
                                           (remove_prop my_controls id)
                                           (render_view))
                                        (notify "The requested control wasn't found")))))
            (first_button nil)
            (render_view (fn ()
                            (progn
                               (= first_button nil)
                               (-> control_view
                                  `replaceChildren
                                  (table { `tabindex: 0 `style: "width: 100%" }
                                         (thead
                                            (th (dtext "Name")) (th (dtext "Type")) (th (dtext "Needs Save?")) (th (dtext "Actions")))
                                         (tbody
                                            (for_each (control (values my_controls))
                                               (tr
                                                  (td control.name)
                                                  (td control.type)
                                                  (td (if (and control.needs_save?
                                                               (-> control `needs_save?))
                                                          (dtext "Yes")
                                                          ""))
                                                  
                                                  (td { `for_control_id: control.options.id }
                                                      (progn
                                                         (defvar b (button { `tabindex: 0 } (dtext "View")))
                                                         (if (not first_button)
                                                             (= first_button b))
                                                         b)
                                                      (button { `tabindex: 0 `style: "float: right" } (dtext "Close Control")))))))))))
            (handle_button_event (fn (elem)
                                    (aif (and elem.parentElement
                                              (-> elem.parentElement `getAttribute "for_control_id"))
                                         (progn
                                            (console.log "holding_tank: button_event: " elem.innerText elem)
                                            (cond
                                               (== elem.innerText (dtext "View"))
                                               (swap_control intf (get_control_by_id it))
                                               (== elem.innerText (dtext "Close Control"))
                                               (container_view_operation "destroy" (get_control_by_id it)))))))
            
            (initialize (fn ()
                           (when (and view.parentElement
                                      (not initialized))
                              (= initialized true)
                              (-> resize_observer `observe view.parentElement)
                              (console.log "holding_tank: in initialization: " options view.parentElement)
                              (for_each (control (values my_controls))
                                 (progn
                                     (console.log "control holding tank: initializing: " control)
                                     (-> holding_cell `append control.view)
                                     (-> control `initialize)))
                                              
                              (if options.in_tree
                                 (progn
                                    (console.log "holding_tank: in tree and setting view up to block..and calling render")
                                    (set_style [["display" "block"]] view)
                                    (render_view)
                                    (focus_to first_button))
                                 (-> (get_by_id "body")
                                     `append view)))))
            (dirty_controls_interval nil)
            (num_dirties 0)
            (num_dirties_button (button { `id: "num_dirties_button" 
                                          `title: (dtext "Click to toggle unsaved controls panel")
                                          `style: "font-size: 0.9em; font-weight: bold; padding: 4px; min-width: 25px; text-align: center; border-radius: 20px; background: #A01010; color: white; position: absolute; top: 2px; right: 20px;" }
                                  0))
            (before_unload_listener (function (e)
                                       (progn
                                          (-> e `preventDefault)
                                          (set_prop e `returnValue (+ "There are " num_dirties " items that require saves. Are you sure you want to quit?"))
                                          e)))
            (on_focus (fn ()
                         (progn
                            (add_class "juno-focused" control_status ))))
            (control_view (div { `style: "overflow: scroll; margin: 0px; padding: 0px; height: 100%; width: 100%;background: var(--control-bg-color);" }))
            (show (fn ()
                     (let
                        ((root_control (if *last_focus*
                                           (top_frame *last_focus*)
                                           (prop $root_controls 1)))
                         (current_parent (if view.parentElement
                                             (control_position (control_for_dom_element view))
                                             { `child: intf `parent: nil `child_position: 0 }))
                         (target_control (if root_control.controls
                                             (first (-> root_control `controls)))))
                        (console.log "holding_tank: show: " root_control "current_parent: " current_parent "target_control: " target_control)
                        (console.log "holding_tank: do I have a parent_element: " (parents_for_control intf))
                        (cond
                           (eq current_parent.parent nil)
                           (progn
                              (set_prop options
                                 `in_tree
                                 true)
                              (set_style [["display" "block"]] view)
                              (container_view_operation "split_below" target_control intf { `ratio: 0.7 })
                              (set_focus_to intf)
                              (focus_to first_button))
                           current_parent.parent
                           (progn
                              (set_style [["display" "block"]] view)
                              (set_prop options
                                 `in_tree
                                 true)
                              (set_focus_to intf)
                              (focus_to first_button))))))
            (hide (fn ()
                     (progn
                        (console.log "holding_tank: hide: " view.parentElement)
                        (when view.parentElement
                           (container_view_operation "hide" intf)
                           (remove_prop options
                              `in_tree)
                           (set_style [["display" "none"]] view)
                           (-> (get_by_id "body")
                               `append view)))))
            
            (open_search (fn ()
                            (aif (-> view `querySelector ".ace_search_field")
                                 (focus_to it)
                                 (progn
                                    (-> control_view `append
                                       (search_box
                                          {
                                            root_element: control_view
                                            }))))))
            (view (div { `tabindex: 0 `control_id: id `style: "display: none;  overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                       control_status
                       control_view)))
           
           
           
           (attach_event_listener view
              `click
              (fn (e)
                 (when (== e.srcElement.tagName "BUTTON")
                    (handle_button_event e.srcElement))))
           
           (attach_event_listener num_dirties_button
              `click
              (fn (e)
                 (toggle_unsaved_controls_table)))
                      
           (attach_event_listener view
              `keyup
              (fn (e)
                 (when (== e.key "Escape")
                    (hide))))
           
           (set_prop options
              `id id
              `name name)
           (= dirty_controls_interval
              (setInterval (fn ()
                              (let
                                 ((dirties (try
                                              (reduce (c (current_controls))
                                                 (if (and c.needs_save?
                                                          (-> c `needs_save?))
                                                     c))
                                              (catch Error (e)
                                                 (progn
                                                    (when dirty_controls_interval
                                                       (clearInterval dirty_controls_interval))
                                                    (log_error "dirty_controls_interval: stopping due to error: " e)
                                                    [])))))
                                 
                                 (when (and (not is_served?)
                                            (> dirties.length 0))
                                    (= *system_requires_export* true))
                                 (set_prop num_dirties_button
                                    `innerText (cond 
                                                  (> dirties.length 0)
                                                  (+ "" dirties.length)
                                                  *system_requires_export*
                                                  "↓"
                                                  else
                                                  (+ "" dirties.length)))
                                                   
                                 (cond
                                    (and (> dirties.length 0)
                                         (== num_dirties 0))
                                    (progn
                                        (= num_dirties dirties.length)
                                        (if (not num_dirties_button.parentElement)
                                            (-> (get_by_id "page-header") `append
                                                     num_dirties_button))
                                        (addEventListener `beforeunload before_unload_listener { capture: true }))
                                     (and (== dirties.length 0)
                                          (> num_dirties 0)
                                          (not *system_requires_export*))
                                     (progn
                                        (= num_dirties 0)
                                        (-> num_dirties_button `remove)
                                        (removeEventListener `beforeunload before_unload_listener { capture: true })))))
                           2000))

           (= resize_observer (new ResizeObserver perform_resize))
           
           (= intf
              {
                `view: view
                `type: "holding_tank"
                `id: id
                `name: options.name
                `initialize: initialize
                `on_focus: on_focus
                `controls: (fn ()
                              (values my_controls))
                `add_control: add_control
                `has_control?: (fn (thing) (if (is_string? thing)
                                           (prop my_controls thing)
                                           (prop my_controls thing.options.id)))
                `remove_control: remove_control
                `name: options.name
                `hide: hide
                `show: show
                
                `resize: perform_resize
                `options: options
                `toJSON: (function ()
                            `(control_holding_tank ,#(values my_controls)  ,#options ))
                })
           intf))
   {
     `usage: ["initial_controls:array" "options:object"]
     `description: (+ "The control holding tank is a is a singleton control that 'holds' any "
                      "control (except itself) that is currently not displayed.  Once instantiated "
                      "any new instantiations of the control holding tank will return the "
                      "previously instantiated control for the namespace.  All arguments will be "
                      "ignored after the initial instantiation call as the global instance will be "
                      "returned. Controls are added to the holding tank by the container_view_operation "
                      "function which manages the view state.  The holding tank can be checked for a "
                      "control being held by it by calling the has_control? function. ")
     `tags: ["ui" "controls" "hidden" "container" "holding"]
     })

(defun empty_selection_control (options)
   (let
      ((existing_control (last (holding_tank_controls))))
      (if existing_control
         existing_control
     (let
        ((options (or options {
                               `name: "Empty Selection" 
                               }))
         (id (or options.id (generate_id "empty")))
         (title_span (span { `class: "juno-title" } (if options.title options.title "Select Control")))
         (buffer_commands_button (commands_button id))
         (control_status (div {  `class: "juno-buffer-bar" }
                              buffer_commands_button
                              (cond (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span
                                  )))
         (resize_observer nil)         
         (initialized false)
         (parent_view nil)
         (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
         (perform_resize (fn ()
                           (when view.parentElement
                             (check_observer)
                           (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                             
                             (set_style [[ "width" (+ "" new_width "px") ]
                                         [ "height" (+ "" new_height "px") ]]
                                        view)))))
         (initialize (fn ()
                       (when (and view.parentElement
                                  (not initialized))
                         (= initialized true)
                         (= parent_view view.parentElement)
                         (-> resize_observer `observe view.parentElement))))
         (on_focus (fn ()
                   (progn
                     ;; bring focus to the repl
                    (add_class "juno-focused" control_status ))))
         (control_view (div { `class: "juno-empty-content" } ""))
         (view (div { `tabindex: 0 `control_id: id `style: "overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                  control_status
                  control_view)))
                             
        (set_prop options
                  `id
                  id)
        (= resize_observer (new ResizeObserver perform_resize))
        
        
       {
           `view: view
           `type: "empty_control"
           `id: id
           `initialize: initialize
           `on_focus: on_focus
           `name: options.name
           `resize: perform_resize
           `options: options
           `toJSON: (function ()
                      `[empty_selection_control ,#options ])
        }))))

(defun find_common_prefix (candidates match_to)
   (let
      ((result [])
       (subset nil)
       (match_to match_to))
      (cond
         (== (length candidates) 0)
         ""
         (== (length candidates) 1)
         (first candidates)
         
         (not (blank? match_to))
         (progn
            (while (progn
                      (= subset (reduce (c candidates)
                                   (when (starts_with? match_to c)
                                      c)))
                      (and (< subset.length 2)
                           (> match_to.length 0)))
               (= match_to (chop match_to)))
            
            (find_common_prefix subset))
         else
         (progn
            (= candidates (sort candidates))  ;; make sure the candidates are sorted
            (for_each (idx (range (length candidates.0)))
               (if (== (prop (first candidates) idx)
                       (prop (last candidates) idx))
                   (push result (prop (first candidates) idx))
                   (break)))           
            (join "" result)))))

(defun place_caret_at_end (el)
   (progn
      (javascript |
                  el.focus();
                  if (typeof window.getSelection != "undefined"
                             && typeof document.createRange != "undefined") {
                     var range = document.createRange();
                     range.selectNodeContents(el);
                     range.collapse(false);
                     var sel = window.getSelection();
                     sel.removeAllRanges();
                     sel.addRange(range);
                     }
                  | )
      true))




(defun next_hidden_control (backward?)
   (let
      ((layout_name (control_name (get_current_layout_control)))
       (candidates (reduce (ctl (holding_tank_controls))
                      (if (or (eq nil ctl.options.only_for)
                              (== ctl.options.only_for layout_name))
                          ctl)))
       (cmd (if backward?
                last
                first))
       (new_ctl nil))
      (cond
         (current_layout_locked?)
         (notify (+ (dtext "This layout is locked.") " " (dtext "Please Switch to another layout to change controls.")))
         (> candidates.length 0)
         (progn
            (= new_ctl (cmd candidates))
            (swap_control *last_focus* new_ctl))
         else
         (notify (dtext "No controls are in the holding tank."))))
   {
     `usage: ["backward?:boolean"]
     `description: (+ "If backward? is false (default) swap the current control "
                      "with the last control in the holding tank. Otherwise "
                      "swap with the first control in the holding tank. "
                      "If there are no controls, notifies the user that there are "
                      "no other non-displayed controls to swap to.")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     })

(defun next_displayed_control (backward?)
      (let
      ((next_index nil)
       (displayed_root_control (get_current_layout_control))
       (candidates (reduce (ctl (current_controls true displayed_root_control))
                      (unless (or (-> (control_holding_tank) `has_control? ctl)  ;; we only want controls that are able to take a direct focus
                                  (== ctl.type "control_container")
                                  (== ctl.type "split_view_vertical")
                                  (== ctl.type "split_view_horizontal"))
                         ctl)))
       (dir (if backward? 
                -2
                1))
       (new_ctl nil))
   (if (> candidates.length 0)
      (progn 
         (map (fn (ctl idx)
                 (if (== ctl *last_focus*)
                     (= next_index (% (+ idx dir) (length candidates)))))
              candidates)
         (when next_index
            (= new_ctl (prop candidates next_index))
            (set_focus_to new_ctl)))
            ;; control will get the on_focus event, but we want to default
            ;; focus into the editor for this operation if the control has an editor
      (notify (dtext "No controls are in the holding tank."))))
   {
     
     `description: (+ "For the current layout, move the focus to the next displayed control in "
                      "the layout.   If the `backward?` argument is true, will move backward in the "
                      "display list as opposed to the default forward operation in the control list.  ")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     `usage: ["backward?:boolean"]
     })

(defmacro on_key_down_event (e view `& key_to_action_pairs)
   (let
      ((acc []))     
      ;(assert (and e view key_to_action_pairs)
       ;       "Invalid syntax for on_key_down_event")
      (for_each (key_to_action_pair key_to_action_pairs)
                        (destructuring_bind (key action)
                           key_to_action_pair
                           (if (== key "otherwise")
                               (push acc true)
                               (push acc `(== kcode ,#key)))
                           (push acc action)))
      `(attach_event_listener 
          view
          `keydown
          (function (e)
             (let
                ((kcode e.key))
                (cond
                   ,@acc))))))



(defcontrol tree_browser ()
   ((options (or (and (is_object? options)
                          options)
                     (throw SyntaxError "options object is required for tree_browser")))
    (stack (or options.stack []))
    (initial_render false)
    (title_span (span { spellcheck: false `contenteditable: true `tabindex: 0 `style: "caret-color: red; outline: none; display: inline-block; font-size: 1.1em; font-weight: bold; font-family: var(--main-mono-space); min-width: 10px; border: 1px dotted goldenrod; padding-left: 5px; padding-right: 5px" } ""))
    (caps_lock_span (span { `class: "juno-display-none" `style: "margin-left: 20px; padding-top: 2px; padding-left: 5px; padding-right: 5px; padding-bottom: 2px; border-radius: 3px; border: 1px solid var(--main-color); " } (dtext "caps lock")))
    (on_destroy (fn (self)
                  (progn
                   (when options.on_destroy                     
                     (options.on_destroy self))
                   true)))
    (current_pos 0)
    (content_view (div { `style: "overflow-x: auto" `class: "juno-symbol-browser" }))
    (get_current_stack (fn ()
                           (clone stack)))
    (select_text (dtext (or options.select_text
                            "Press Enter To Open")))
    (ol_for_pos (fn (pos)
                   (let
                      ((target_col nil))
                      (= target_col (-> content_view `querySelector (+ "ol[pos='" (if pos pos 0) "']")))
                      target_col)))
    
    (select_child (fn (ol_elem selected_child_text)
                     (when selected_child_text
                        (for_each (child ol_elem.children)
                           (if (and (is_element? child)
                                    (== (get_attribute child "path_value") selected_child_text))
                               (progn 
                                  (add_class "juno-selected" child)
                                  ;(set_prop ol_elem `scrollTop (prop (dimensions child) `top))
                                  (-> child `scrollIntoView false)
                                  )
                               (remove_class "juno-selected" child))))))
    (path_sep (fn ()
                 (or options.path_separator "/")))
    
    (num_ol_elems (fn ()
                    (length content_view.children)))
                       
    
    (create_ol_at_pos (fn (pos)
                         (try
                            (let
                               ((stack_value_at_pos (prop stack pos))
                                (contents (get_possibles pos)))
                               (ol { `style: (if (not (is_array? contents))
                                                 "width: 100%; max-width: 100%; position: relative;"
                                                 "height: calc(100% - 20px);  position: relative;")
                                            `pos: pos }
                                   contents))
                            (catch Error (e)
                               (log "ERROR: create_ol_at_pos: " pos "" e.message)))))
    
    (find_value (fn (elem key)
                   (let
                      ((v nil))
                      (cond
                         (= v (get_attribute elem key))
                         v
                         elem.parentElement
                         (find_value elem.parentElement key)
                         else
                         nil))))
    
    (get_specifics_for_event (fn (e)
                                (let
                                   ((elem e.srcElement)
                                    (path_value (find_value elem "path_value"))
                                    (pos (int (find_value elem "pos"))))
                                   (set_path_at pos path_value))))
    
    (set_path_at (fn (pos path_value)
                    (when path_value
                       (cond
                          (== pos stack.length) ;; at end
                          (progn
                             (push stack path_value)
                             (render_stack))
                          (< pos stack.length)
                          (progn
                             (= stack (-> stack `slice 0 pos))
                             (push stack path_value)
                             (clear_suffix)
                             (render_stack))
                          else
                          (log "set_path_at: unhandled: " pos path_value)))))
    (is_at_leaf false)
    (was_at_leaf false)
    (at_leaf (fn ()
                (progn 
                   is_at_leaf)))
                   ;(log "at_leaf?: is_at_leaf: " is_at_leaf (not (has_class? "filtered-hidden" instruction_div)))
                   ;(not (has_class? "filtered-hidden" instruction_div)))))
    
    (get_path_components (fn (raw)
                            (let
                               ((text (or title_span.innerText ""))
                                (ps (path_sep)))
                               (if raw
                                  text
                                  (progn
                                     (if (ends_with? ps text)
                                         (= text (chop text)))
                                     (split_by ps text))))))
    (get_suffix (fn ()
                   (let
                      ((comps (get_path_components)))
                      (if (> comps.length stack.length)
                          (last comps)
                          ""))))
    
    (clear_suffix (fn ()
                     (let
                        ((elem (ol_for_pos stack.length))
                         (ps (path_sep)))
                        
                           (set_prop title_span
                              `innerText (+ (join ps stack)
                                            (if (and (> stack.length 0)
                                                     (not (at_leaf)))
                                                ps
                                                "")))
                        (if elem
                            (for_each (c elem.children)
                               (remove_class "filtered-lower-opacity" c))))))
                        
    (get_matches (fn (k highlight?)
                    (let
                       ((num_matches 0)
                        (pos stack.length)
                        (addl (if (blank? k) "" k))
                        (suffix (+ (get_suffix) addl))
                        (matched [])
                        (first_match nil)
                        (not_matched []))
                       (if (< pos 0)
                           []
                           (aif (ol_for_pos pos)
                                (for_each (c it.children)
                                   (progn
                                      (if (and (not (blank? suffix))
                                               (starts_with? suffix c.innerText))
                                          (push matched
                                                c)
                                          (push not_matched
                                                c))))))
                       (= last_matched matched)
                       (when highlight?
                          (for_each (elem not_matched)
                             (add_class "filtered-lower-opacity" elem))
                           (for_each (elem matched)
                              (remove_class "filtered-lower-opacity" elem)))
                       (= first_match matched.0)
                       (when first_match
                          (set_prop first_match.parentElement
                             `scrollTop
                             (- (prop first_match `offsetTop) 10)))
                       matched)))
    
    (get_last_column_values (fn ()
                               (let
                                  ((elem (ol_for_pos stack.length)))
                                  (if elem
                                      (for_each (c elem.children)
                                         (prop c `innerText))
                                      []))))
    
    (matched_as_text (fn (matched)
                        (map (fn (v)
                                v.innerText)
                             matched)))
    (last_suffix nil)
    (caps_lock_timer nil)
    (last_matched [])
    (select_matches (fn (k)
                       (let
                          ((text nil)
                           (in_reverse (== k "Backspace"))
                           (matched nil)
                           (prefix nil)
                           (suffix nil)
                           (exact_match nil)
                           (existing_suffix nil)
                           (ps (path_sep))
                           (last_path nil)
                           (at_leaf? (at_leaf)))                         
                          ;; are we going forward or backwards?
                          ;; if forwards, determine if we pressed a delim key or a regular key
                          ;; if we pressed a delim key, and the final path segment matches an element in the column, push that value to the stack, and redraw the columns and the title_span
                          ;; if we pressed a regular key, find the common prefixes, write that to the title_span,
                          ;; ...and follow the filter process.
                          ;; if we matched to a leaf, display the instruction_div 
                          
                          ;; if backwards, determine if we are at a leaf or not
                          ;; if we are, remove the character from the title_span, pop the stack, find the common prefix, write that to the title_span, follow the filter process
                          ;; if we are not, remove the character, find the common prefix, write that to the title_span and 
                          ;; follow the filter process
                          
                          ;; Filter process:
                          ;; Determine the amount of matched elements at the last path segment
                          ;; if 1 match then append the value to the path and redraw the title and the column selectors
                          ;; if >1 then find the common prefix, and append the common prefix to the title_span
                          ;; ..and highlight the matching values in the column
                          ;; if 0 matches don't append the character since it cannot contribute to narrowing the selection
                         
                          (cond
                             in_reverse
                             (progn 
                                (= was_at_leaf at_leaf?)
                                (when at_leaf? ;; if we are at leaf state, remove the final value from the stack
                                    (pop stack)
                                   
                                    (= is_at_leaf false)
                                    (add_class "filtered-hidden" instruction_div))
                                (if options.allow_non_matches
                                   (run_validations))
                                ;; find the common prefix with one character removed
                                (= existing_suffix (get_suffix))                    
                                (when (not (blank? existing_suffix))
                                   (if options.allow_non_matches
                                      (= prefix (chop existing_suffix))
                                      (= prefix (find_common_prefix (get_last_column_values) (chop existing_suffix)))))
                                (when (== prefix last_suffix)
                                    ;; we had this value last backspace, so we need to go back further
                                    (= prefix "")
                                    (= last_suffix nil))
                                (cond
                                   (and options.allow_non_matches
                                        (blank? prefix))
                                   (progn
                                      (if (blank? last_suffix)
                                          (progn
                                             (pop stack)
                                             (render_stack))
                                          (progn 
                                             (clear_suffix)
                                             (render_title prefix)
                                             true)))
                                   (blank? existing_suffix)  ;; there is no suffix, so pop the stack 
                                   (progn        
                                      (pop stack)
                                      (try
                                         (clear_suffix)
                                         (catch Error (e)
                                            (log "ERROR on clear_suffux: " e.message)))
                                      (try
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR on render stack: " e.message))))
                                   
                                   (blank? prefix)  ;; when no common prefix remove the suffix altogether
                                   ;; we will have to rebuild the title_span explicitly otherwise suffix will be preserved
                                   (progn
                                      (clear_suffix)
                                      (render_stack))
                                      ;; clear all the matches..
                                   (> (length prefix) 0)
                                   (progn
                                      (clear_suffix)
                                      (render_stack prefix true)
                                      (= last_suffix prefix)
                                      (get_matches "" true))
                                   else
                                   ;; just clear the last suffix 
                                   (progn
                                      (= last_suffix nil))))
                                ;; if we were at a leaf, we are no longer so remove the leaf node from the stack
                             
                             (and (not options.allow_non_matches)
                                  (or (== k ps)
                                      (== k "Tab")))
                             (progn
                                (= matched (get_matches "" true))
                                (= last_path (last (get_path_components)))
                                
                               (cond 
                                  ;; if there is only one match 
                                  (and (> (length title_span.innerText) 0)
                                       (== (length matched) 1)
                                       (not (ends_with? ps title_span.innerText)))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))
                                  ;; if there are multiple matches, but in those matches there is an exact match
                                  (and (> (length title_span.innerText) 0)
                                       (== (length (reduce (t (matched_as_text matched))
                                                      (== last_path (first (split_by "\n" t)))))
                                           1))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))))
                                  
                                     
                             else
                             (progn
                                (if options.allow_non_matches
                                   (if (or (== k "Tab")
                                           (== k ps))
                                       (= matched (get_matches "" true))
                                       (= matched (get_matches k true)))
                                   (= matched (get_matches k true)))
                                (= last_matched matched)  
                                (cond                                  
                                   (and (not (== k ps))
                                        (not (== k "Tab"))
                                        (not (> k.length 1))
                                        options.allow_non_matches)
                                   (progn
                                      (= prefix (+ (or (get_suffix) "") k))
                                      (render_title prefix)
                                      (when options.validate_selection
                                        (run_validations)))
                                   (== (length matched) 1)  ;; ok we matched only 1 so go ahead and put it into the stack
                                   (progn
                                      (push stack 
                                            (first (split_by "\n" matched.0.innerText)))
                                      (try 
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR: " e.message))))
                                   
                                   (and ;options.allow_non_matches
                                        (> (length matched) 1)
                                        (or (== k "Tab")
                                            (== k ps)))
                                   (progn
                                      (= prefix (get_suffix))
                                      (= exact_match (first (reduce (v matched)
                                                               (when (== (first (split_by "\n" v.innerText)) prefix)
                                                                  prefix))))
                                      (if exact_match
                                         (progn
                                            (push stack
                                               (first (split_by "\n" matched.0.innerText)))
                                            (try (render_stack)
                                               (catch Error (e)
                                                  (log "ERROR: " e.message))))
                                         (progn
                                            ;; find the common prefix and render title
                                            (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                            ;; subtract suffix
                                            (render_title prefix))))
                                   (> (length matched) 1)  ;; multiple matches, so add the character to the suffix
                                   (progn
                                      ;; find the common prefix and render title
                                      (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                      ;; subtract suffix                                                                            
                                      (render_title prefix)))))
                          (= last_suffix (get_suffix))
                           true)))
                                   
                                ;; if it is a control type type don't display
    (select_button (button { `tabindex: 0 `class: "juno-primary" `style: "font-weight: bold;margin-right: 20px;" } (or options.select_button_text "Select")))
    (instruction_div (span {`style: "float: right; margin-right: 30px; padding-left: 8px; padding-right: 8px; font-weight: bold; color: var(--value-modified-color);"  `class: "filtered-hidden"  } 
                           select_button
                           select_text))
    (prefix_div (span { `style: "font-size: 1.1em; margin-right: 8px;" } (dtext "Select or Type:")))
    (open_selection (fn ()
                       (when (and (not (has_class? "filtered-hidden" instruction_div))
                                  options.on_select
                                  (if options.allow_non_matches
                                     (options.on_select (get_path_components))
                                     (options.on_select stack))))))
    (handle_enter_event (fn (e)
                           (cond
                              (== e.srcElement title_span)
                              (progn
                                 (handle_event e)
                                 (open_selection))
                              else
                              (get_specifics_for_event e))))
   
    (on_initialize (fn (self)
                      (progn
                          (on_key_down_event e view
                             ("Enter" (progn
                                         (handle_enter_event e)))
                                         
                             ("Escape" (progn
                                          (handle_event e)
                                          (destroy_control self)))
                             ("Tab" (progn
                                       (if (or options.allow_non_matches
                                               (not (at_leaf)))
                                           (handle_event e))
                                       (select_matches e.key)))
                             (`otherwise (progn 
                                            (when (== e.srcElement title_span)
                                               (handle_event e)
                                               (if (or (== e.key "CapsLock") 
                                                       (-> e `getModifierState "CapsLock"))
                                                   (progn
                                                      (when caps_lock_timer
                                                         (clearTimeout caps_lock_timer))
                                                      (= caps_lock_timer 
                                                         (setTimeout (fn () (add_class "juno-display-none" caps_lock_span)) 1000))
                                                      (remove_class "juno-display-none" caps_lock_span))
                                                   (add_class "juno-display-none" caps_lock_span))
                                               
                                               (select_matches e.key)
                                               ))))
                         
                         (-> title_span.parentElement
                             `appendChild
                             instruction_div)
                         (-> title_span.parentElement
                            `appendChild
                            caps_lock_span)
                         (-> title_span.parentElement `insertBefore
                             prefix_div title_span)
                         (attach_event_listener select_button
                            `click
                            (fn (e)
                               (progn
                                  (handle_event e)
                                  (open_selection))))
                         (add_class "juno-highlighted" title_span.parentElement)
                         (attach_event_listener content_view
                                                `click
                                                get_specifics_for_event ))))
    
    (get_possibles (fn (pos)
                       (cond 
                          (is_function? options.get_possibles_elem)
                          (-> options `get_possibles_elem pos)
                          (is_function? options.get_possibles)  ;;  returns either a single obj with keys or an array of those objects
                          ;; keys: ctype has_children? title path_value  and view
                          (let
                                ((idx -1)
                                 (val nil)
                                 (filter_text (last (split_by (or options.path_separator "/") title_span.innerText))))
                                (= val (-> options `get_possibles pos self))
                                (if (not (is_array? val))
                                    (progn
                                       ;(remove_class "filtered-hidden"  instruction_div)
                                       (= is_at_leaf true))
                                    (progn
                                       (= is_at_leaf false)
                                       ;(add_class "filtered-hidden" instruction_div) 
                                       ))
                                (if (and options.allow_non_matches
                                         options.validate_selection)
                                    (run_validations)
                                    (if is_at_leaf
                                       (remove_class "filtered-hidden"  instruction_div)
                                       (add_class "filtered-hidden" instruction_div)))
                                    
                                (cond
                                   (is_array? val)
                                   (for_each (obj val)
                                      (progn
                                         (inc idx)
                                         
                                         (li { `tabindex: 0
                                                `ctype: (or obj.ctype "sym" )
                                               `title: obj.title
                                               `class: (+ "juno-list-item " 
                                                          (if obj.has_children? "juno-list-item-has-children " "") 
                                                          (if (and (not (blank? filter_text))
                                                                   (not (starts_with? filter_text obj.path_value)))
                                                              "filtered-lower-opacity"
                                                              ""))
                                               `style: (or obj.style
                                                           "")
                                               `path_value: obj.path_value
                                               } 
                                               (if obj.view 
                                                   obj.view 
                                                   idx))))
                                         
                                   (is_object? val)
                                   (li { `tabindex: 0
                                         `ctype: (or val.ctype "sym" )
                                         `title: val.title
                                         `class: (+ "juno-list-item " (if val.has_children? "juno-list-item-has-children " "") (if val.class val.class ""))
                                         `style:  (+ "height: calc(100% - 20px); " (if val.style val.style ""))
                                         `path_value: (or val.path_value nil)
                                         } (if val.view val.view idx))
                                   (is_string? val)
                                   (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: calc(100% - 50px);" }
                                    val)
                                   else
                                   (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: calc(100% - 50px);" }
                                    (value_to_dom val))))
                           else
                           (div { } "Missing get_possibles function or get_possibles_elem in options"))))
    (run_validations (fn ()
                        (when (and options.allow_non_matches
                                   options.validate_selection)
                           (if (-> options `validate_selection (get_path_components true) (at_leaf) last_matched)
                               (remove_class "filtered-hidden" instruction_div)
                               (add_class "filtered-hidden" instruction_div)))))
                           
                            
    (render_title (fn (new_suffix)
                     (let
                        ((suffix (or new_suffix (get_suffix) ""))
                         (ps (path_sep)))
                        (set_prop title_span
                           `innerText
                           (+ (join ps stack)
                              (cond 
                                 (at_leaf)
                                 ""
                                 (and (blank? suffix)
                                      (> stack.length 0)
                                      (if (and options.allow_non_matches
                                               options.validate_selection)
                                          (not (-> options `validate_selection (get_path_components true) (at_leaf) last_matched))
                                          true))
                                 ps
                                 (== stack.length 0)
                                 (+ "" suffix)
                                 else
                                 (+ ps suffix))))
                        (run_validations)
                        (place_caret_at_end title_span))))
    
    (render_stack (fn (prefix no_rerender)
                     (let
                        ((ol_elem nil)
                         (new_ol_elem nil))
                        
                        (if (or (not no_rerender)
                                was_at_leaf)
                        (when (> (num_ol_elems) stack.length)
                           (try
                           (for_each (pos (range_inc  stack.length (num_ol_elems)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (when ol_elem
                                    (-> ol_elem `remove))))
                           (catch Error (e)
                              (log "Error on: stack render p1: " e.message)))))
                        ;; is the stack already drawn, or do we need to render it?
                        (try
                           (for_each (pos (range (+ stack.length 1)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (if ol_elem
                                    (select_child ol_elem (prop stack pos))
                                    (progn
                                       (= new_ol_elem (create_ol_at_pos pos))
                                       (if new_ol_elem
                                          (-> content_view `append
                                             new_ol_elem))
                                       (if (prop stack pos)
                                           (select_child new_ol_elem (prop stack pos)))
                                       ))))
                           (catch Error (e)
                              (log "Error on: stack render p2: " e.message)))
                        (set_prop content_view
                           `scrollLeft (prop (dimensions content_view) `width))
                        (set_prop view
                           `scrollTop 0)
                        (try
                           (render_title prefix)
                           (catch Error (e)
                              (log "Error on render_title: " e.message))))))
    (on_focus (fn ()
                 (focus_to title_span)))
    (on_render (fn (self broaden)
                       (let
                          ((next_elem nil))
                          ;(render_stack)
                          nil)))
                          
    (render (fn ()
               (if (not initial_render)
                   (progn
                      (= initial_render true)
                      (render_stack)
                      content_view)
                   nil))))
   {
     `control_bar: true
     `expose: [[`get_current_stack get_current_stack]]
     })



(defun file_tree_browser(options)
   (let
      ((create_mode options.create_mode)
       (env_details (aif (http/get "/base_directory")
                         (and it.rval
                            (== it.rval "OK")
                            (prop it `data))))
       (render_entry (fn (entry)
                        (let
                           ((etype (fn (entry)
                                      (cond
                                         entry.isDirectory "directory"
                                         entry.isFile "file"
                                         entry.isSymlink "symlink")))
                            (rval nil))
                           (= rval
                              {
                                `has_children?: entry.isDirectory
                                `path_value: entry.name
                                `class: (etype entry)
                                `ctype: "sym"
                                `view: (div { `style: "display: inline-block; width: 100%;"
                                              `class: (+ "juno-type-file-entry " (etype entry)) }
                                         entry.name
                                         (if entry.isDirectory
                                            (span { `style: "display: inline-block; float: right" } "▸")
                                            "")) })
                           ;(log "render_entry: entry rval: " rval rval.view.outerHTML)
                           rval)))
       
       (get_possibles (fn (pos control)
                         (let
                            ((cpath (join "/" (slice (-> control `get_current_stack) 0 pos)))
                             (next_values (if (== pos 0)
                                              (http/list_files "/")
                                              (http/list_files cpath))))
                            (when (is_array? next_values)
                               (sort next_values { `key:`name }))
                            (= next_values (clone next_values))
                            (cond
                               (is_array? next_values)
                               (for_each (entry next_values)
                                  (render_entry entry))
                               (instanceof next_values Blob)
                               {
                                 `has_children?: false
                                 `ctype: "file"
                                 `style: "width: calc(100% - 10px) !important;"
                                 `view: (div { `style: "display: inline-block; width: calc(100% - 15px); height: calc(100% - 10px); overflow: hidden" }
                                             (div { `style: "height: calc(100% - 0px); overflow: auto;" }
                                                  (try
                                                     (dtable (let
                                                                ((details (eval `(stat_file ,#(+ env_details.base cpath)))))
                                                                [["Size" details.size]
                                                                 ["Last Accessed" details.atime]
                                                                 ["Last Modified" details.mtime]
                                                                 ["Created At" details.birthtime]]))
                                                     
                                                     (catch Error (e)
                                                        "Unable to remote stat the file")))
                                             (div { `style: "padding: 10px;" }
                                                  []))  ;; placeholder for any additional information about the file
                                 }
                               else
                               {
                                 `has_children?: false
                                 `ctype: "file"
                                 `view: (pre {} (sub_type next_values))
                                 }))))
       (path_details nil)
       (control nil))
      (declare (object control))
      
      
      ;; set the path for the system
      
      (= path_details (if (starts_with? "." env_details.base)
                          nil
                          (normalize_file_path options.base_directory env_details)))
      (if path_details
         (set_prop options
            `stack (if (starts_with? "/" path_details)
                       (rest (split_by "/" path_details))
                       (split_by "/" path_details))))
      (= control (tree_browser (+ { path_separator: "/"
                                    render_entry: render_entry
                                    get_possibles: get_possibles
                                    allow_non_matches: (if create_mode true false)
                                    select_text: (if create_mode
                                                    "Press Enter To Create"
                                                    "Press Enter To Open")
                                    select_button_text: (if create_mode
                                                           "Create"
                                                           "Open")
                                    validate_selection: (fn (path at_leaf matches)
                                                           (try
                                                              (progn
                                                                 ;(log "v:" path  "at_leaf: " at_leaf "# m: " (length matches))
                                                                 (cond
                                                                    at_leaf
                                                                    false
                                                                    (ends_with? "/" path)
                                                                    false
                                                                    (== 0 (length path))
                                                                    false
                                                                    (and (is_array? matches)
                                                                         (== (length matches) 1)
                                                                         (== (first (split_by "\n" (prop (first matches) `innerText)))
                                                                             (last (split_by "/" path))))
                                                                    false
                                                                    else
                                                                    true))
                                                              (catch Error (e)
                                                                 (progn
                                                                    (log "Error: " e.message)
                                                                    false))))
                                    }
                                 (if (is_object? options)
                                     options
                                     {}))))
      control)
   (progn
      (alert_box "Connection Issue"
                 "The service required for file browsing isn't available.")
      nil))



(defun save_active_buffer (save_all)
  (cond
    save_all
    (for_each (control (select_controls (fn (ctl) (is_function? (prop ctl `save)))))
              (-> control `save))
    (and *last_focus*
         (prop *last_focus* `save))
    (-> *last_focus* `save)
    *last_focus*         
    (notify (+ "" (or (prop *last_focus* `name) "Unnamed") " " (dtext "doesn't have a save method") "."))
    else
    (notify (dtext "There isn't an active control."))))
    
    
(defun split_control (dir)
   (alert_on_error "Unable to perform split"
                   (let
                      ((target_layout (get_current_layout_control))
                       (target *last_focus*))
                      (cond 
                         (layout_locked? target_layout)
                         (notify (dtext "Target Layout Locked"))
                         (eq nil target)
                         (throw Error "No Focused Control to split")
                         (and (== dir "vertical")
                              (prop target `split_vertical))
                         (-> target `split_vertical)
                         (and (== dir "horizontal")
                              (prop target `split_horizontal))
                         (-> target `split_horizontal)
                         (and (== dir "vertical")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_right" target (last (-> (control_holding_tank) `controls)))
                         (and (== dir "horizontal")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_below" target (last (-> (control_holding_tank) `controls)))
                         else
                         (notify (+ "No controls to split to" (prop target.options `name) " cannot be split")))))
   {
     description: (+ "Given a direction, either `horizontal` or `vertical`, will look at the "
                     "value of `*last_focus*` and split that control if possible.  If the layout is "
                     "locked, a notification will appear and the control will not be split. ")
     usage: ["dir:string"]
     tags: ["controls" "ui" "dom" "layout" "control" "view"]
     })


(defcontrol line_display ()
   ((menu_items (fn ()
                   [["Test" (fn ()
                               (notify "Notify Test Menu"))]]))
    (current_value (or "Not Set"))
    (set (fn (val)
            (progn
               (= current_value val)
               (do_render))))
    (render (fn ()
               (div { `class: "juno-mono-space" `style: "white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" }
                current_value))))
   {
       `buffer_bar: false
       `expose: [[`set set]]
       `usage: []
   })


(defcontrol panel (the_title element)
   ((render 
       (fn () (div { `style: "overflow: auto; height: calc(100% - 20px);" } element)))
    (on_initialize 
       (fn (self)
          (progn 
             (= name (compute_name_for_control the_title))
             (set_prop self
                `name
                name)
          (set_title the_title))))
    (to_json (function ()
                `(panel ,#the_title ,#(element_to_lisp content_view)))))
   {
     description: (+ "The `panel` control takes a title and an `Element` which is encased in "
                     "a control structure.  This can then be placed as a panel in the user interface "
                     "with the `place_control` function or other UI manipulation operations.  This "
                     "control is useful as a way to quickly display a panel with static HTML "
                     "elements, but without needing to create a formal control in order to display "
                     "information.  The panel control has a title bar which will be set to the title "
                     "provided in the call to `panel`.  <br>On serialization, the panel will "
                     "serialize to quoted lisp the view such that restoration is "
                     "possible.<br><br>#### Example <br>```(place_control `right (panel \"Key "
                     "Bindings\" (show_key_bindings)))```<br><br>This will create a panel with the "
                     "control name \"Key Bindings\" on the right hand side of the screen.<br> ")
     usage: ["title:string" "element:Element"]
     control_bar: true
     allow_search: true 
   })

(defun build_documentation_datalist ()
   (let
      ((keywords (new Set))
       (dlist_id "documentation_datalist")
       (dlist nil))
      (for_each (pset (pairs *tags_to_meta*))
         (progn
            (-> keywords `add pset.0)
            (-> keywords `add (first (split_by "/" pset.1.0)))
            (for_each (`target pset.1)
               (-> keywords `add (second (split_by "/" target))))))
      (= dlist (datalist { `id: dlist_id } 
                         (for_each (keyword (sort (to_array keywords)))
                            (option keyword))))
      (aif (get_by_id dlist_id)
          (-> it `remove))
      (-> (first (get_by_tag "body"))
          `append dlist)))

(defglobal *building_document_index* false)
(defparameter *document_tag_index_time* nil)

(defun build_tag_index ()
   (unless (or *building_document_index*
               (and *document_tag_index_time*
                  (> (- (time_in_millis) *document_tag_index_time*) 50000)))
      (setq *building_document_index* true)
      (let
         ((new_db {})
          (stime (time_in_millis))
          (env nil)
          (is_reindex? (if (== (length (keys *tags_to_meta*)) 0)
                           false
                           true)))
         (for_each (ns (namespaces))
            (progn
               (= env (-> Environment `get_namespace_handle ns))
               (for_each (pset (pairs env.definitions))
                  (destructuring_bind (name def)
                     pset
                     (when def.tags
                        (when is_reindex?
                           (sleep 0.005))
                        (for_each (tag def.tags)
                           (when (and (is_string? tag)
                                      (not (== tag "constructor")))
                              (if (eq nil (prop new_db tag))
                                  (set_prop new_db
                                     tag
                                     []))
                              (assert (prop new_db tag) (+ "Error: tag " tag " should be a place in new_db"))
                              (push (prop new_db tag)
                                    (+ "" ns "/" name)))))))
               ;; add direct links for each global, even if they refer to themself, so they are searchable
               (for_each (name (keys env.context.scope))
                  (progn
                     (if (eq nil (prop new_db name))
                         (set_prop new_db name []))
                     (push (prop new_db name)
                           (+ "" ns "/" name))))))
         (= *tags_to_meta*
            new_db)
         (build_documentation_datalist)
         (if (> __VERBOSITY__ 2)
             (log (+ "build_tag_index: time to index: " (- (time_in_millis) stime) "ms  " (if is_reindex? " (throttled)" ""))))
         (= *document_tag_index_time* (time_in_millis))
         (setq *building_document_index* false)))
      
   {
     `description: "Builds or rebuilds the tag index as held in *tags_to_meta* for use by the documentation facility."
     `tags: ["help" "index" "tags" "rebuild" "documentation" ]
     `usage: []
   })

(defun search_documentation_index (search_text target_element)
   (if (and (is_string? search_text)
              (> search_text.length 1)
              (is_element? target_element))
      (let
         ((results_by_ns {})
          (target nil)
          (ns nil)
          (sym nil)
          (disp_count 0)
          (not_found (fn () true))
          (comps []))
         ;(log "searching for " search_text)
      ;; do we have tags?
      (when (prop  *tags_to_meta* search_text)
         (for_each (command (prop  *tags_to_meta* search_text))
            (progn
               (= comps (split_by "/" command))
               (= ns (first comps))
               ;(log "ns: " ns comps.1)
               (if (eq nil (prop results_by_ns ns))
                   (set_prop results_by_ns
                      ns
                      {}))
               (set_prop (prop results_by_ns ns)
                         comps.1
                         (resolve_path [ `definitions comps.1 ] (-> Environment `get_namespace_handle ns))))))
      (for_each (ns (namespaces))
         (progn
            (= comps (split_by "/" search_text))
            (if (> comps.length 1)
                (= sym (second comps))
                (= sym (first comps)))
            (unless (resolve_path [ ns sym ] results_by_ns)
               (aif (resolve_path [ `definitions sym ] (-> Environment `get_namespace_handle ns))
                    (progn
                       (make_path [ ns sym ] results_by_ns it)))
               (aif (resolve_path [ `global_ctx `scope sym ] (-> Environment `get_namespace_handle ns))
                    (progn
                       (make_path [ ns sym ] results_by_ns 
                                  {
                                      `name: sym
                                      `description: (+ "Undocumented: " (sub_type it))
                                  }))))))
      (when (> __VERBOSITY__ 0)
         (log "search_documentation_index: results:" results_by_ns))
      
      (try
         (= target
            (div
               (for_each (ns_title (keys results_by_ns))
                  [(details { `open: true `style: "margin-bottom: 10px;"  }
                            (summary { style: "font-size: 1.2em; color: var(--namespace-color); font-weight: bold" } ns_title)
                            (table { `style: "width: 100%;font-size: 1.1em; background: var(--editor-bg-color);" }
                                   (thead
                                      (tr (th { `style: " padding: 5px;" } "Symbol Name") 
                                          (th { `style: "width: 100%; padding: 5px;" } "Description")))
                                   (tbody
                                      (for_each (pset (sort (pairs (prop results_by_ns ns_title))
                                                            { `key: [ 0 ] }))
                                         (destructuring_bind (k meta_obj)
                                            pset
                                            (when k
                                               (inc disp_count)
                                               (defvar desc "")
                                               (defvar stype (try 
                                                                (or (first (reduce (m (meta_for_symbol k true))
                                                                              (when (and (== m.namespace ns_title)
                                                                                         m.type)
                                                                                 m.type)))
                                                                    (progn
                                                                       (defvar tmp (-> Environment `get_global (+ ns_title "/" k) not_found))
                                                                       (if (== tmp not_found)
                                                                           "undefined"
                                                                           (sub_type tmp))))
                                                                (catch Error (e)
                                                                   "unknown")))
                                               (tr { `style: " vertical-align:top;" }
                                                   (td { `class: (+ "juno-requires " "juno-type-" (lowercase stype))
                                                         `tabindex: 0 
                                                         `title: stype
                                                         `style: "line-height: 1.5em; min-width: 200px; cursor: pointer; border-bottom: 1px solid var(--main-accent-line); padding-bottom: 10px; margin-bottom: 10px; padding-right: 5px; font-weight: bold; text-align: right; vertical-align:top;" } 
                                                       k)
                                                   (td { `style: "line-height: 1.5em; border-bottom: 1px solid var(--main-accent-line); margin-bottom: 10px;vertical-align:top;  padding-bottom: 10px; width: calc(100% - 150px);" }
                                                       (if (and meta_obj.require_ns
                                                                (is_array? meta_obj.requires)
                                                                (== 1 meta_obj.requires.length))
                                                           [ (dtext "Bound to") " " 
                                                             (span { style: "font-weight: bold" } (first meta_obj.requires)) ]
                                                           (or (and meta_obj.description
                                                                    (try
                                                                       (progn
                                                                          (= desc (prop (unpack_description meta_obj.description) `innerText))
                                                                          (if (> desc.length 150)
                                                                              (= desc (+ (-> desc `substr 0 150) "...")))
                                                                          (div { `style: "" }
                                                                               desc))
                                                                       
                                                                       (catch Error (e)
                                                                          (+ "error: " e.message " - can't unpack description"))))
                                                               "(No Description)"))))))))))])))
         (catch Error (e)
            (log "ERROR: " e.message e)))
      (if (== disp_count 0)
          (-> target_element `replaceChildren
             (div { `class: "juno-no-data-found" } (dtext "No Results")))
          (-> target_element `replaceChildren target))
      (setTimeout (fn ()
                     (focus_to target.children.0.children.0))
                  50))
      (log "Inproper args to search_documentation_index: " search_text)))



(defun online_learning_resource_elems ()
   (progn
      (declare (function DOM_editor)
               (global DOM_editor))
      (conj
         [ (button { onclick: (fn ()
                                 (progn
                                    (-> window `open *public_repo*))) } "GitHub") ]
         (if is_served?
            [(button { onclick: (fn ()
                                   (progn
                                      (switch_to_new_layout (control_name (frame_0))) ;; switch to unlocked
                                      (place_control `right (DOM_editor { reader_mode: true filename: "doc/seedling.dom" }))))  }
                     "Seedling Overview")
             (button { onclick: (fn ()
                                   (progn
                                      (switch_to_new_layout (control_name (frame_0)))
                                      (hide_control *system_repl*)
                                      (make_named_layout "Control Tutorial"
                                         (split_view_vertical
                                            (split_view_horizontal
                                               (text_editor { `filename: "doc/calculator.juno" })
                                               (text_editor { `filename: "doc/calculator.css" })
                                               {
                                                 ratio: 0.7
                                                 })
                                            *system_repl*)
                                         { unmounted_source: true }))) }
                     "Building an Application" )]
            []))))

;; place holder for the control reference by juno_documentation_control
(defun toggle_help_panel ()
   true)


(defcontrol juno_documentation_control ()
   ((definition_view (div { `class: "juno-log-output" `style: "margin-top: 15px; padding: 5px; overflow: scroll; width: calc(100% - 20px);" } 
                          (div { `style: "padding: 5px; line-height: 1.5em;"} 
                               "This is the Help Panel.  You can search for symbols and tags via the input above. You can open it via the "
                               "Shift-Escape, or Alt-H key sequences."
                               (if is_served?
                                  [ "To familiarize yourself with "
                                   "Seedling and the Juno language you can visit the following resources:"
                                   (br)
                                   (br)
                                   (online_learning_resource_elems)]
                                  []))))
    (search_input (input { `type: "search" `list: "documentation_datalist" `placeholder: (dtext "Search Documentation") `style: "font-weight: bold; display: inline-block; padding: 10px; width: calc(100% - 10px); border: 0px; background: var(--editor-bg-color); color: var(--main-color);" } ))
    (search_bar_elem (div { `style: "display: inline-block; width: calc(100% - 0px);height: 20px;" }
                          search_input))
    (search_result_view (div { `style: "overflow: scroll; height: calc(100% - 10px);  width: calc(100% - 20px); " }
                             (div { `style: "width: 100%; text-align: center; margin-top: 15px; padding: 10px; font-size: 1.2em;" } (dtext "Type Search Text and Press Enter"))))
    (search_view (div { `style: "display: inline-block; height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden; padding: 5px;" 
                        `class: "juno-display-none" } 
                      (div { `style: "display: inline-block; margin-top: 15px; font-weight: bold; padding: 5px; font-size: 1.2em;" }  
                           (dtext "Search Results"))
                      search_result_view))
    (upper_content_view (div { `class: "juno-log-output" `style: "padding: 5px;height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden;" } 
                             search_bar_elem
                             search_view
                             definition_view))
    (content_view (div { `class: "juno-log-output" `style: "padding: 5px;height: calc(100% - 35px); width: calc(100% - 10px); overflow: hidden;" } 
                   upper_content_view))
    (on_resize (fn (self)
                  (progn
                     (set_style [["height" (+ "calc(100% - " search_bar_elem.offsetHeight "px") ]] content_view))))
    (name (or options.name "Juno Documentation"))
    (title_span (span { `style: "font-weight: bold; margin-right: 15px;" } (dtext "Documentation")))
    (back_button (button { `disabled: true } (+ "<" " " (dtext "Go Back"))))
    (pin_button (button { } (dtext "Pin")))
    (history_button (button { } (dtext "History")))
    (pinned? (fn ()
                (or (has_class? "juno-button-on" pin_button)
                    (not (has_class? "juno-display-none" search_view)))))
    (history [])
    (history_max_length 15)
    (current_symbol nil)
    (handle_click (fn (e)
                     (progn
                        (cond
                           (has_class? "juno-requires"  e.srcElement)
                           (progn
                              (show_documentation e.srcElement.innerText))
                           (has_class? "juno-source-location" e.srcElement)
                           (open_symbol_definition current_symbol)
                           (has_class? "juno-tag" e.srcElement)
                           (progn
                              (-> self `search_by_tag e.srcElement.innerText))))))
    (control_bar_elements [back_button pin_button history_button])
    (render_command_elem (fn (command)
                            (let
                               ((results (describe command true)))
                               (for_each (meta_obj (or results ()))
                                  (progn
                                     (format_help meta_obj { `on_click: handle_click } ))))))
    
    (render_help (fn (command)
                    (div { `class: "" `style: "overflow-x: hidden;" }
                         (for_each (v (to_array (or (render_command_elem command) [])))
                            (div { `style: "padding: 5px; margin-bottom: 10px; background: var(--editor-bg-color);" }
                                 v)))))
    (search_by_tag (fn (tagname)
                      (progn
                         (set_prop search_input `value tagname)
                         (enable_search)
                         (search_documentation_index tagname search_result_view))))
    (remove_all_priors (fn (command)
                          (progn
                             (for_each (elem (-> history_content_view `querySelectorAll (+ "[command='" command "']")))
                                (try
                                   (if (is_element? elem)
                                       (-> elem.parentElement `remove))
                                   (catch Error (e)
                                      (log "ERROR: on remove: " e.message (sub_type elem)))))
                             (when (contains? command history)  ;; if history contains the command name already, remove it and display it first
                                  (defvar idx (index_of command history))
                                  (if (< idx 0)
                                      (notify "cannot find history item, even though contains? said it was there.")
                                      (-> history `splice idx 1))))))
    (message_cache []) ;; stored requests while initializing
    (message_receiver (fn (event_obj force)
                         (let
                            ((first_arg (let
                                           ((comps (split_by "(" event_obj.args.0)))
                                           (or (second comps)
                                               (first comps))))
                             (num_found_in_history_view 0)
                             (dup_remover {})
                             (count 0)
                             (new_view nil))
                            (if (not initialized)
                                (progn 
                                   (push message_cache
                                      [event_obj force]))
                                (progn
                                   ;; deal with recording the history
                                   (when first_arg
                                      ;; if there is anything in the history view that matches it, remove it so we can put it back on top
                                      (remove_all_priors first_arg)
                                      (= num_found_in_history_view (length (to_array (-> history_content_view `querySelectorAll (+ "[command='" first_arg "']")))))
                                      (push history
                                         first_arg)
                                      (if (pinned?)
                                          (-> history_content_view `prepend (render_help first_arg))
                                          (if (> (length history) 1)
                                              (-> history_content_view `prepend (render_help (prop history (- (length history) 2)))))))
                                   
                                   ;; if the history is too long, prune it
                                   (when (> (length history) history_max_length)
                                      (take history)
                                      (aif (last history_content_view.children)
                                           (-> it `remove)))
                                   
                                   (if (> history.length 1)
                                       (set_enabled back_button)
                                       (set_disabled back_button))
                                   ;(log "message_receiver: history: " history "first_arg: " first_arg)
                                   (when (or (and force first_arg)
                                             (and first_arg
                                                (not (pinned?))))
                                      (= current_symbol first_arg)
                                      
                                      (-> definition_view `replaceChildren
                                         (render_help current_symbol))))))))
    (go_back (fn ()
                (when (> history.length 1)
                   (pop history)
                   (defvar hist_item (pop history))
                   (when hist_item
                      (message_receiver { `args: [ hist_item ] })))))
             
                   
    (handler_function_id (gen_id "hid"))
    (history_mode? (fn ()
                      (has_class? "juno-button-on" history_button)))
    (history_content_view (div { `style: "overflow: scroll; height: calc(100% - 10px); width: calc(100% - 20px;) overflow: scroll;" } ))
    (history_view (div { `class: "juno-log-output" `style: "height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden; padding: 5px;" } 
                       history_content_view))
    (show_documentation (fn (text)
                           (progn
                              (hide_search_view)
                              (message_receiver { `args: [ text ] }))))
    (take_focus (fn ()
                   (focus_to search_input)))
    (on_focus (fn ()
                 (progn
                    (focus_to search_input))))
    (split_view nil)
    (show_history (fn (show?)
                       (let
                          ()
                          (if show? ;; update our button
                             (add_class "juno-button-on" history_button)
                             (remove_class "juno-button-on" history_button))
                          (cond
                             (and (history_mode?)
                                  (is_control? split_view))
                             nil ;; already showing
                             (and (history_mode?)
                                  (eq nil split_view))
                             (progn
                                (-> upper_content_view `remove)
                                (= split_view
                                   (split_view_horizontal upper_content_view history_view))
                                (-> content_view
                                   `replaceChildren
                                   split_view.view))
                             (not (history_mode?))
                             (progn
                                (-> split_view.view `remove)
                                (-> split_view `destroy)
                                (= split_view nil)
                                (-> content_view
                                   `replaceChildren
                                   upper_content_view))))))
                             
    (reindex_timer nil)                      
    (is_displayed? (fn ()
                      (progn
                         (defvar ctl_holding_tank (control_holding_tank))
                         (if (->  ctl_holding_tank `has_control? self)
                             false
                             true))))
    (render (fn ()
               (if (not initialized)
                   view)))
    (on_render (fn ()
                  (when current_symbol
                     (-> definition_view `replaceChildren
                        content_view))))
    (enable_search (fn ()
                      (progn
                         (remove_class "juno-display-none" search_view)
                         )))
    
    (hide_search_view (fn ()
                         (progn
                            (add_class "juno-display-none" search_view))))
                           
    (on_initialize (fn (self)
                      (progn
                         (register_event_handler nil "display_usage" handler_function_id (eval `(fn (event_obj force)
                                                                                                   (let
                                                                                                      ((id ,#self.options.id)
                                                                                                       (fid ,#handler_function_id))
                                                                                                      (aif (get_control_by_id id)
                                                                                                           (-> it `message_receiver event_obj force)
                                                                                                           (remove_event_handler nil "display_usage" fid))))))
                         (attach_event_listener pin_button
                            `click
                            (fn (e)
                               (if (has_class? "juno-button-on" pin_button)
                                   (remove_class "juno-button-on" pin_button)
                                   (add_class "juno-button-on" pin_button))))
                         (attach_event_listener history_button
                            `click
                            (fn (e)
                               (progn
                                  (show_history (not (history_mode?))))))
                         
                         (attach_event_listener search_input
                            `click
                            (fn (e)
                               (progn
                                  (sleep 0.05)
                                  (if (blank? search_input.value)
                                      (hide_search_view)
                                      (enable_search)))))
                         (attach_event_listener search_input
                            `keydown
                            (fn (e)
                                  (cond
                                     (and (== e.key "Escape")
                                          e.shiftKey)
                                     (progn
                                        (handle_event e)
                                        (toggle_help_panel))
                                     (== e.key "Escape")
                                     (progn
                                        (handle_event e)
                                        (set_prop search_input
                                           `value
                                           "")
                                        (hide_search_view)))))
                         (attach_event_listener search_input
                            `keyup
                            (fn (e)
                               (progn
                                  (when (== e.key "Enter")
                                     (search_documentation_index e.srcElement.value search_result_view))
                                  (if (> (length search_input.value) 0)
                                      (enable_search)
                                      (hide_search_view)))))
                         (attach_event_listener back_button
                            `click
                            (fn (e)
                               (go_back)))
                         (attach_event_listener view`
                            `keyup
                            (fn (e)
                               (cond
                                  (and (== e.key "Enter")
                                       (has_class? "juno-requires" e.srcElement))
                                  (show_documentation e.srcElement.innerText)
                                  (and (== e.key "Enter")
                                       (has_class? "juno-tag" e.srcElement))
                                  (search_by_tag e.srcElement.innerText)
                                  (== e.key "Escape")
                                  (focus_to search_input))))
                         (attach_event_listener search_result_view
                            `click
                            (fn (e)
                               (when (has_class? "juno-requires" e.srcElement)
                                  (show_documentation e.srcElement.innerText))))
                         (build_tag_index)
                         (= reindex_timer
                            (setInterval build_tag_index 60000))
                         (when (> message_cache.length 0)
                            (setTimeout (fn ()
                                           (progn
                                              (while (> message_cache.length 0)
                                                 (progn
                                                    (message_receiver (take message_cache))))))
                                        10))
                         self)))
    (on_destroy (fn ()
                   (progn
                      (remove_event_handler nil "display_usage" handler_function_id)
                      (if reindex_timer
                         (clearInterval reindex_timer))
                      true)))
    (set_pinned (fn (value)
                  
                   (cond
                      (== value current_symbol)
                      (add_class "juno-button-on" pin_button)
                      (is_string? value)
                      (progn
                         (add_class "juno-button-on" pin_button)
                         (message_receiver { args: [ value ] } true))
                      else
                      (add_class "juno-button-on" pin_button))))
    (release_pin (fn ()
                    (remove_class "juno-button-on" pin_button)))
    
    )
   {
      control_bar: true
      allow_search: true 
      expose: [[ `set_pinned set_pinned]
               [ `search_by_tag search_by_tag ]
               [ `show_documentation show_documentation ]
               [ `is_displayed? is_displayed? ]
               [ `message_receiver message_receiver]
               [ `take_focus take_focus ]
               [ `get_history (function () (clone history)) ]]
      usage: []
     })

;; hide the documentation control behind a singleton function

(defun juno_documentation (options)
   (let
      ((doc_control_name (+ "Juno Documentation - " (control_name (get_current_layout_control)))))
      (aif (or (get_control_by_name doc_control_name)
               (get_control_by_name "Juno Documentation"))
           it
           (if options.no_create
              nil
              (juno_documentation_control (+ { name: doc_control_name }
                                             options)))))
   {
     `tags: ["help" "control" "show" "search" "tags" "documentation" ]
     `usage: ["options:object"]
     `description: "Creates a new documentation control if none exists and return it, otherwise returns the existing documentation control."
     })


(defun toggle_help_panel (focus_to_help?)
   (let
      ((ctl_holding (control_holding_tank))
       (focused *last_focus*))
      
      (try
         (cond
            (-> ctl_holding `has_control? (juno_documentation { no_create: true }))
            (progn
               (place_control `right (juno_documentation { no_create: true }))
               (cascade_resize)
               (when (not focus_to_help?)
                  (setTimeout (fn ()
                                 (progn
                                    (focus_to_editor focused))) 5)))
            (juno_documentation { no_create: true } )
            (progn
               (hide_control (juno_documentation)))
            else
            (progn
               (defvar ctl (juno_documentation))
               ((fn () (place_control `right ctl)))
               (wait_for_placement ctl)
               (when (not focus_to_help?)
                  (setTimeout (fn ()
                                 (progn
                                    (sleep 0.05)
                                    (focus_to_editor focused))) 5))))
         
         (catch Error (e)
            (notify (+ "Unable to open help panel: " e.message)))))
   {
     `description: "Shows the documentation panel if it is not displayed."
     `tags: ["help" "show" "documentation" ]
     `usage: []
     })

(defun show_help_panel (focus_to_search)
   (let
      ((ctl (juno_documentation { `no_create: true })))
      (cond
         (and ctl (-> ctl `is_displayed?))
         true
         else
         (progn
            (toggle_help_panel true)))
      (if focus_to_search
         (setTimeout (fn () 
                        (progn
                           (= ctl (juno_documentation))
                           (-> ctl `take_focus)) 20))))
   {
     `description: "Shows the documentation panel if it is not displayed."
     `tags: ["help" "show" "documentation" ]
     `usage: []
     })

(defun about_seedling (switch_to_repl?)
   (progn
      (declare (function DOM_editor)
               (global DOM_editor))
      (when switch_to_repl?
         (show_control *system_repl*))
      (log (div { `style: "padding: 5px; font-family: var(--main-app-font);" }
                (div { `style: "margin-bottom: 10px;font-size: 1.2em; font-weight: bold;" } "Seedling IDE - (c) 2024 Kina" (a { `style: "padding-left: 10px;"  href:"https://kinaknowledge.com" target: "_blank" } "kinaknowledge.com"))
                (div { `style: "margin-bottom: 5px;" } "Build: " Environment.build_version)
                (div { `style: "margin-bottom: 5px;" } "MIT License")
                (div { `style: "margin-bottom: 10px;" } "For license details see Help->Licenses")
                (div { `style: "padding-top: 5px; padding-bottom: 5px;" }
                     (online_learning_resource_elems))
                ))))
                
                

(defun display_license_info ()
   (let
      ((collection {})
       (env nil))
      (for_each (ns (sort (namespaces)))
         (progn
            (= env (-> Environment `get_namespace_handle ns))
            (when env
               (for ((symbol meta) (pairs env.definitions))
                    (when meta.license
                       (set_prop collection
                          (+ ns "/" symbol) (pre meta.license)))))))
      (show_control *system_repl*)
      (log collection))
   {
     description: (+ "<br><br>Logs to the system REPL the license information recorded in each "
                     "Environment object.  License information can be found in a symbol\'s metadata "
                     "under the license key. ")
     tags: ["license" "licenses" "information" ]
     usage: []
   })


(defun display_tag (text)
   (progn
      (show_help_panel)
      (-> (juno_documentation)`search_by_tag text))
   {
     description: (+ "Given a text string, opens the documentation panel with the associated "
                     "text in the search bar, and the results of the search displayed. ")
     tags: ["tags" "help" "search" "?" "describe" "meta" ]
     usage: ["text:string"]
   })


(defun dtag (tag_text)
  (eval `(span { spellcheck: false class: "juno-tag" onclick: (fn () (display_tag ,#tag_text)) } ,#tag_text))
   {
     description: (+ "Constructs a clickable span element for the provided tag text.  When "
                     "clicked on, opens the documentation panel with the associated items for the tag "
                     "displayed. ")
     usage: ["tag_text:string"]
     tags: ["tags" "help" "search" "?" "describe" "meta" ]
   })

(defun display_documentation (text)
   (progn
      (show_help_panel)
      (-> (juno_documentation)`show_documentation text))
   {
     description: (+ "Given a text string, opens the documentation panel " 
                     "to the requested symbol. ")
     tags: ["tags" "help" "search" "?" "describe" "meta" ]
     usage: ["text:string"]
   })

(defun doclink (symbol_name)
  (eval `(span { spellcheck: false class: "juno-tag" onclick: (fn () (display_documentation ,#symbol_name)) } ,#symbol_name))
   {
     description: (+ "Constructs a clickable span element for the provided "
                     "symbol name.  When clicked on, opens the documentation "
                     "panel and displays the symbol documentation.")
     usage: ["symbol_name:string"]
     tags: ["tags" "help" "search" "?" "describe" "meta" ]
   })

(defun *help_menu_function* ()
  [[(dtext "Toggle Documentation") 
    (fn ()
       (toggle_help_panel)) ]
   [(dtext "Lookup Symbol Definition")
        jump_to_symbol_definition
        ]
   [(dtext "Show Global Key Bindings")
    (fn ()
       (place_control `right (panel "Key Bindings" (show_key_bindings ))))]
   (if (and *last_focus*
            *last_focus*.editor)
       [(dtext "Show Editor Key Bindings")
        (fn ()
           (place_control `right (panel (+ "Key Bindings" " - " (control_name *last_focus*)) 
                                        (show_editor_keybindings *last_focus*))))]
       [])
   [ "--" nil]
   (if (is_symbol? `generate_docs)
       [(+ (dtext "Create Static Documentation") "...")
         (conj [[ (dtext "For All Namespaces")
                (eval `(fn ()
                          (activity_box  { `style:  "width: 200px; height: 50px;" }
                                        (set_content "Generating Documentation to /doc")
                                        (generate_docs)
                                        (set_content "Complete")
                                        (sleep 1)
                                        )))]
                 [ "--" nil]]
               (for_each (ns (sort (namespaces)))
                  [ ns (eval `(fn ()
                                 (activity_box  { `style:  "width: 200px; height: 50px;" }
                                               (set_content "Generating Documentation to /doc")
                                               (export_documentation_to_html ,#ns)))) ]))]
       [(dtext "Import Documentation Generation Package")
        (fn (e)
           (progn
              (import "/pkg/doc_generation.juno")
              (notify (dtext "Imported Documentation Generation Package"))))
              ])
  [ "--" nil]
  [(dtext "About Seedling")
   (fn (e)
      (about_seedling true))]
  [(dtext "Licenses")
   (fn (e)
      (display_license_info))]])
  
 (defun set_display_name (name no_menu_bar_title)
   (aif (get_by_id "page-header")
     (progn
        (let
           ((header_elem (-> it `querySelector "span.juno-header")))
           (if header_elem
              (progn 
                 (if no_menu_bar_title
                    (progn
                       (set_prop header_elem
                          `innerText "")
                       (add_class "juno-display-none" header_elem))
                    (progn
                       (remove_class "juno-display-none" header_elem)
                       (set_prop header_elem
                          `innerText (or name "Seedling"))))
                 (when (and (not (blank? name))
                            (is_string? name))
                    (set_default ["application" "display_name"] name)
                    (aif (first (get_by_tag "TITLE"))
                         (set_prop it `innerText name)
                         (-> (first (get_by_tag "HEAD")) `append (html/title { } name))))
                 true)
              (throw Error "set_display_name: unable to find the header span."))))
     (throw Error "set_display_name: unable to find the page-header element."))
   {
     description: (+ "Given a text argument, sets the upper left corner text identifier. The "
                     "default text is \"Seedling\". Returns true if successful, or throws an `Error` if "
                     "unsuccessful.<br>If the provided name is a non blank string, "
                     "the `application.display_name` default is set in `*env_config*` . <br>If "
                     "the `no_menu_bar_title` argument is `true` then the title of the application "
                     "will be removed from the menu bar and will not show, shifting the menu bar "
                     "elements toward the left. ")

     usage: ["name:string" "no_menu_bar_title:boolean"]
     tags: ["application" "ui" "settings" "title" "header" "name"]
     })

(defun tag_selector (options tags)
   (let
      ((sorted_tag_names (sort (keys *tags_to_meta*)))
       (tag_dlist_id (gen_id `tags))
       (tag_dlist (datalist { `id: tag_dlist_id }
                         (for_each (t sorted_tag_names)
                            (option t))))
       (tag_view (div { `style: "display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start;" }))
       (current_tag nil)
       (extra_space (if (is_number? options.extra_space)
                        options.extra_space
                        2))
       (empty_text (or options.empty_text "name?"))
       (tag_content (fn ()
                       (uniq (reduce (text (each tag_view.children `value))
                                (unless (== empty_text text)
                                   text)))))
       
       (focus_to_tag (fn (tag)
                        (try
                           (progn
                              (-> tag `select))
                           (catch Error (e)
                              (log "error: " e.message)))))
       
       (already_have_tag? (fn (text)
                             (let
                                ((found nil))
                                (for_each (elem (or tag_view.children []))
                                   (when (== elem.value text)
                                      (= found elem)
                                      (break)))
                                found)))
       (value_count (fn (text)
                       (let
                          ((count 0))
                          (for_each (elem (or tag_view.children []))
                             (when (== elem.value text)
                                (inc count)))
                          ;(log "Count is: " count text)
                          count)))
       (prune_empties (fn ()
                         (for_each (t (or tag_view.children []))
                            (if (== t.value empty_text)
                                (-> t `remove)))))
       (adjust_size (fn (elem)
                       (try
                          (if (== elem document.activeElement)
                              (progn
                                 (set_style [["width" (+ "" (+  extra_space elem.value.length) "ch")]] elem))
                              (progn
                                 (set_style [["width" (+ "" (+  2 elem.value.length) "ch")]] elem)))
                          (catch Error (e)
                             (log "ERROR: " e.message)))))
       (new_tag (fn (text focus?)
                   (aif (already_have_tag? text)
                       (if focus? 
                          (focus_to_tag it)
                          false)
                       (let
                          ((tag (input { tabindex: 0
                                         class: "juno-editable"
                                         style: "padding: 5px;margin-right: 10px;"   
                                         list: tag_dlist_id
                                         contenteditable: true
                                         value: text }
                                        )))
                          (adjust_size tag)
                          (-> tag_view `append
                             tag)
                          (when focus?
                             (sleep 0.001)
                             (focus_to_tag tag))))))
       
       (view (div { `style: "position: relative;" }
                  tag_dlist
                  tag_view)))
      
      (attach_event_listener tag_view
         `keydown
         (fn (e)  ;; don't allow spaces in tags
            (cond 
               (or (== e.key "Enter")
                   (contains? e.key "/[]{}():;.,<>|\\\\=`~"))
               (handle_event e)
               (and (== e.key " ")
                    (not (== e.srcElement (last tag_view.children))))
               (handle_event e)
               ;; if we are at the end and we have a `blank?` ie. empty_text (default `name?`), release the focus 
               (and (== e.key "Tab")
                    (== e.srcElement (last tag_view.children))
                    (== e.srcElement.value empty_text))
               (progn
                  (if (> (length tag_view.children) 1)
                      (-> e.srcElement `remove)))
               
               ;; if we have a filled out tag, and are on the last tag, create a new one with tab or space is pressed
               (and (or (== e.key "Tab")
                        (== e.key " "))
                    (not e.shiftKey)     
                    (== e.srcElement (last tag_view.children))
                    (> (length e.srcElement.value) 1))
               (progn
                  (handle_event e)
                  (new_tag empty_text true))
               (and (== e.key "Tab")
                    e.shiftKey
                    (== e.srcElement.value empty_text))
               (progn
                  (handle_event e)
                  (let
                     ((prior e.srcElement.previousSibling))
                     (-> e.srcElement `remove)
                     (if prior
                        (focus_to_tag prior))))
               (and (== e.key "Backspace")   ;; remove when tag has no content
                    (== e.srcElement.value empty_text))
               (let
                  ((prior e.srcElement.previousSibling)
                   (next e.srcElement.nextSibling))
                  (handle_event e)
                  (-> e.srcElement `remove)
                  (cond
                     prior
                     (focus_to_tag prior)
                     next
                     (focus_to_tag next)
                     (== (length tag_view.children) 0)
                     (new_tag empty_text true))))))
              
               
                    
      
      (attach_event_listener tag_view
         `keyup
         (fn (e)
            (progn
               (cond
                  (and (== e.key "Backspace") 
                       (blank? e.srcElement.value))
                  (progn
                     (set_prop e.srcElement `value empty_text)
                     (focus_to_tag e.srcElement)))
               (adjust_size e.srcElement)
               (if (> (value_count e.srcElement.value) 1)
                   (add_class "juno-input-error" e.srcElement )
                   (remove_class "juno-input-error" e.srcElement))
               (set_prop e.srcElement
                  `value
                  (lowercase e.srcElement.value))
               (when options.on_change
                  (-> options `on_change (tag_content))))))
      
      (attach_event_listener tag_view
         `focusin
         (fn (e)
            (progn
               (focus_to_tag e.srcElement))))
      
      (attach_event_listener view
         `focusout
         (fn (e)
            (progn
               (adjust_size e.srcElement)
               (when options.on_change
                  (-> options.on_change (tag_content))
               ))))
      
      (if (and (is_array? tags)
               (> tags.length 0))
          (for_each (tag (or tags []))
             (new_tag tag))
          (new_tag empty_text))
      ;(setTimeout (fn () (focus_to_tag tag_view.children.0)) 10)
      view)
   {
     `description: (+ "Creates a simple DOM Element for creating or editing an "
                      "array of tags (unique strings).  Uses the *tags_to_meta* "
                      "object as a dependency to build the data list selections "
                      "for the tags.  Given an initial array of tags, these "
                      "provided tags will be presented, otherwise a new tag "
                      "with the empty text will be generated and displayed as "
                      "a means to start creating a list of tags.<br>"
                      "Options:<br>"
                      "empty_text:string - When a new tag is generated this "
                      "provided text is shown.  The default is 'name?'<br>"
                      "extra_space:number - How many characters to optionally "
                      "pad the input elements, since the width of the elements "
                      "are measured by the 'ch' unit.<br>"
                      "on_change:function - When a change occurs to a tag, "
                      "or when a tag is removed or created, this function " 
                      "is called with an array of strings, representing the "
                      "tag set that the user is editing.<br>")
     `usage: ["options:object" "tags:array"]
     `tags: ["view" "DOM" "tags" "edit" "manage" "tag" "element"]
     })


(defun DOM_to_markdown (quoted_dom _acc _ctx)
   (let
      ((acc (or _acc []))
       (ctx (new_ctx _ctx))
       (process_children (fn (children)
                            (progn
                               (for_each (child (or children []))
                                  (DOM_to_markdown child acc ctx)))))
       (tag nil))
      ;(log "DOM_to_markdown: " (getf_ctx ctx `tag) (getf_ctx ctx `in_pre))
      (cond
         (is_array? quoted_dom)
         (progn
            (= tag (if (is_reference? (first quoted_dom))
                       (first quoted_dom)
                       nil))
            (if (not (eq nil ctx.parent))
                (= ctx (new_ctx ctx)))
            (setf_ctx ctx `tag tag)
            ;(log "quoted_dom: " (is_reference? (first quoted_dom)) (getf_ctx ctx `tag) (pretty_print quoted_dom))
            
            ;; below are the rules to encode or handle certain elements in specific ways
            (cond
               (and tag
                  (== tag (quote div)))
               (progn 
                  (unless (or (blank? (prop quoted_dom 2))
                              (and (is_string? (prop quoted_dom 2))
                                   (blank? (trim (prop quoted_dom 2)))))
                     ;(log "DOM to markdown: " (pretty_print quoted_dom))
                     (push acc "<br>")
                     (process_children (rest quoted_dom)))
                  ;(push acc "<br>")
                  )
               (and tag
                  (== tag (quote pre)))
               (progn
                  (setf_ctx ctx `in_pre true)
                  ;(log "pre: " (pretty_print quoted_dom))
                  (defvar higher_acc acc)
                  (= acc [])
                  (push acc "```")
                  (process_children (rest quoted_dom))
                  (push acc "```<br>")
                  (push higher_acc (join "" acc))
                  (= acc higher_acc))
               (and tag
                  (== tag (quote hr))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (push acc "<br>---<br>"))
               (and tag
                  (starts_with? (+ "=:" "h") tag)
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (defvar higher_acc acc)
                  (= acc [])
                  (push acc (+ "<br>" 
                               (join "" (for_each (r (range (int (-> tag `substr 3))))
                                           "#"))))
                  (process_children (rest quoted_dom))
                  (push acc "<br>")
                  (push higher_acc (join " " acc))
                  (= acc higher_acc))
               (and tag
                  (== tag (quote p))
                  (is_object? (second quoted_dom))
                  (blank? (prop quoted_dom 2))
                  (not (getf_ctx ctx `in_pre)))
               true ; ignore blank paragraphs 
               (and tag
                  (== tag (quote code))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (unless (blank? (prop quoted_dom 2))
                     (push acc (+ "`" (prop (eval quoted_dom) `innerText) "`"))))
             
               else  
               (process_children (rest quoted_dom))))
         (is_string? quoted_dom)
         (progn
            ;(log "adding from " (getf_ctx ctx `tag) quoted_dom)
            (push acc quoted_dom)))
      acc))

(defglobal *markdown_rules*
   {
     meta: {
         name: "markdown"
         description: "Simple implementation of a subset of markdown for documentation. To be used with the DOM Editor"
     }
     
     get_as_wordwrap_text:{
         on_event: `keydown
         key_sequence: "Alt-X"
         handle_event: true
         control_menu: true
         description: (+ "Used with the text editor, will collect the DOM buffer contents and "
                         "place the contents in the description text of the edited function. "
                         "NOTE: this will close the DOM editor. ")
         qualifier: (fn (point ctl)
                       (progn
                          true))
         exec: (fn (point ctl event)
                  (if (and ctl
                             (== ctl.type "DOM_editor"))
                      (try
                         (progn
                            (-> ctl `save)
                            (defglobal $ed_rval (for_each (line (word_wrap (join "" (DOM_to_markdown  (read_lisp (-> ctl `get))))))
                                                   (if (ends_with? " " line)
                                                       line
                                                       (+ line " "))))
                            (destroy_control ctl))
                         (catch Error (e)
                            (progn
                               (notify "ERROR: " e.message)
                               (console.error e))))
                      (progn
                         (notify (+ "TYPE: " ctl.type)))))
     }
     get_as_markdown_text:{
         on_event: `keydown
         key_sequence: "Alt-R"
         handle_event: true
         control_menu: true
         description: "Copies the DOM buffer contents to the clipboard as markdown text."
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (-> ctl `save)
                     (sleep 0.1)
                     (copy_text_to_clipboard
                           (for_each (line (word_wrap (join "" (DOM_to_markdown  (read_lisp (-> ctl `get))))))
                              (if (ends_with? " " line)
                                  line
                                  (+ line " "))))))
     }
     copy_as_quoted_lisp_to_buffer:{
         on_event: `keydown
         key_sequence: "Alt-Shift-Q"
         handle_event: true
         control_menu: true
         description: "Copies the contents of the DOM buffer or selection as a quoted lisp structure"
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (let
                     ()
                     (declare (function new_buffer)
                              (global new_buffer))
                     (alert_on_error (dtext "Unable to create buffer")
                        (if (not (blank? (-> (get_selection) `toString)))
                            (new_buffer { mode: `juno content: (-> (get_selection) `toString) })
                            (new_buffer { mode: `juno content: (-> ctl `get) } )))))
     }
     copy_as_markdown_to_buffer:{
         on_event: `keydown
         key_sequence: "Alt-Shift-M"
         handle_event: true
         control_menu: true
         description: "Opens the contents of the DOM buffer editor or selection as markdown."
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn 
                     (declare (function new_buffer)
                              (global new_buffer))
                     (notify "Opening buffer")
                     (alert_on_error (dtext "Unable to create buffer")
                        (let
                           ((brregex (new RegExp "<br>" `g))
                            (content
                               (join "\n" 
                                  (for_each (line (word_wrap
                                                          (join "" (DOM_to_markdown
                                                                      (read_lisp (if (not (blank? (-> (get_selection) `toString)))
                                                                                     (-> (get_selection) `toString)
                                                                                     (-> ctl `get)))))))
                                  (replace brregex "\n"
                                     (if (ends_with? " " line)
                                      line
                                      (+ line " ")))))))
                           (console.log "copy_as_markdown_to_buffer: " content)
                           (if (blank? content)
                               (notify "Unable to convert content!")
                               (if (not (blank? (-> (get_selection) `toString)))
                                   (new_buffer { mode: `markdown content: content })
                                   (new_buffer { mode: `markdown content: content } )))))))
     }
     on_space: {
         on_event: `keydown
         key_sequence: "Space"
         control_menu: false
         handle_event: true
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point)))
         exec: (fn (point ctl event)
                  (let
                     ((pre_post (get_text_around_point point))
                      (last_word (trim (last (split_by (String.fromCharCode 160) (trim (last (split_by " " (+ "" pre_post.0))))))))
                      (selection nil)
                      (classes nil)
                      (id (gen_id "ins"))
                      (quoted_display (quotel (fn (e) (display_documentation))))
                      (text nil)
                      (elem nil))
                     (if (and (starts_with? "`" last_word)
                              (ends_with? "`" last_word)
                              (> last_word.length 2))
                         (progn
                            (= selection (get_selection))
                           
                            ;; move back the length of the symbol since it can contain characters that
                            ;; aren't considered
                            (for (idx (range last_word.length))
                                 (-> selection `modify `extend `left `character))
                            (sleep 0.001)
                            (= text (-> last_word `substr 1 (- last_word.length 2)))
                            (if (is_symbol? text)
                                (progn
                                   (= classes (+ "juno-pointer juno-type-" (lowercase (sub_type (get_global text nil))))))
                                (= classes ""))
                            
                            (defvar new_html  (+ "<code style='' id='" id "' spellcheck='false' class='" classes "'>" text "</code><span style='' id='" (+ id "_post") "'>&nbsp;</span>"))
                            (doc_exec `insertHTML new_html)
                            (sleep 0.01)
                            (= elem (get_by_id id))
                            (select_element elem)
                            (set_prop elem `style "")
                            (push (last quoted_display) text)
                            (set_prop elem `onclick
                               (eval quoted_display))
                            ;(doc_exec `removeFormat)
                            (select_element (get_by_id (+ id "_post")))
                            (doc_exec `removeFormat)
                            (remove_attribute  (get_by_id (+ id "_post")) `id)
                            (remove_attribute  (get_by_id id) `id)
                            (collapse_to_end (get_selection)))
                         (progn
                            (doc_exec `insertText " ")))))
     }
     on_empty_doc:{
         on_event: `keyup
         key_sequence: "Backspace"
         control_menu: false
         handle_event: false
         qualifier: (fn (point ctl)
                       (progn
                          (defvar text (prop (-> ctl `get_root_element) `innerText))
                          (or (blank? text)
                              (== text "\n"))))
         exec: (fn (point ctl event)
                  (progn
                     (doc_exec `insertHTML "<div>Enter text!</div>")
                     (move_point `backward `character)
                     (select_node_at_point)))
     }
     insert_pre:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keyup
         control_menu: true
         context_menu: true
         description: "Inserts a <pre> element into the DOM buffer at the location of the cursor (point)."
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "```"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-P"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: false       ;; we don't care about handling the event
         
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are already in a pre
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     (doc_exec `insertHTML "<pre style='min-height: 2.4ch'></pre><div ><br></div>" true)
                     (move_to_point point)
                     (move_point `forward `character)))
     }
    
     ;; the next two rules implement the handling of newlines in the preformatted text node
     ;; the keydown acts to cancel the default behavior of the event 
     ;; the keyup then performs the correct newline behavior for insertion of newlines
     
     on_enter_key:{
         on_event: `keydown   ;; intercept the enter key in PRE tags to add a newline vs. a new element
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   
                       (progn
                          true))  ;; we go everywhere
         handle_event: false
         control_menu: false
         exec: (fn (point ctl event)
                  (progc
                     ;(log "enter situation: OK: event: " event)
                  (cond
                     (point_under_element_tag? "PRE" point)
                     (progc
                        (handle_event event)
                        (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                           (cond
                              (== point.pos_type 3)
                              (== (length point.pos_node.textContent) point.position)
                              (== point.pos_type 1)
                              false))
                        ;(log "at_end? " at_end point)
                        (if at_end
                           (doc_exec `insertHTML "\n\n")
                           (doc_exec `insertHTML "\n")))
                     else
                     (progc ;; not under a pre
                        false))))
                         ;(move_to_point point)
                         
                         
     }
     insert_header: {
         on_event: `keyup
         prior_text_sequence: "# "
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point)))
         handle_event: true
         remove_if_prior: true
         control_menu: true
         exec: (fn (point ctl event)
                  (progc
                     (let 
                        ((preceeding_text (aif (prop (get_text_around_point point) 0)
                                               (last (split_by " " it))
                                               ""))
                         (hash_details (first (scan_str (new RegExp "[#]+$") preceeding_text)))
                         (num_hashes (if hash_details
                                         (length (prop hash_details 0))
                                         0))
                         ;; add one because our rule triggered so it deleted one and the space
                         (tag_name (+ "H" (clamp (+ num_hashes 1) 1 5)))
                         (point nil))
                        (sleep 0.001)
                        ;; since we have asked the editor to remove the matching text we are going to 
                        ;; remove the remaining and use that as a way to compute the Heading element we
                        ;; will add
                        (when (> num_hashes 0)
                           (for_each (c (range num_hashes))
                              (extend_from_point `backward `character))
                           (doc_exec `delete nil))
                        (doc_exec `insertHTML (+ "<" tag_name ">Heading</" tag_name ">"))
                        (move_point `backward `character)
                        (= point (point_for (-> ctl `get_root_element)))
                        (select_node_at_point)
                        )))
     }  
      
      insert_horizontal_rule:{
          on_event: `keyup
          handle_event: true
          control_menu: true
          context_menu: true
          remove_if_prior: true
          prior_text_sequence: "---"    ;; when three dashes 
          qualifier: (fn (point ctl)
                        (progn
                           (not (point_under_element_tag? "PRE" point))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      (doc_exec `insertHTML "<hr/>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
      insert_tab:{
          on_event: `keydown
          handle_event: true
          control_menu: false
          remove_if_prior: false
          key_sequence: "Tab"
          ;prior_text_sequence: ""    ;; when three dashes 
          qualifier: (fn (point ctl)
                        (progn
                           true))
          exec: (fn (point ctl event)
                   (progc
                      ;(sleep 0.001)
                      (log "Tab rule pressed")
                      (if (point_under_element_tag? "PRE" point)
                          (doc_exec `insertText "\t")
                          (doc_exec `insertText "\t"))
                      
                      ))
          
          }
       wrap_text_in_code_tag:{
          on_event: `keydown
          handle_event: true
          control_menu: true
          context_menu: true
          key_sequence: "Ctrl-Alt-C"
          remove_if_prior: true
          description: "Wraps the selected text in a code tag."
          qualifier: (fn (point ctl)
                        (progn
                           (sleep 0.001)
                           (and (not (point_under_element_tag? "PRE" point))
                                (not (blank? (-> (get_selection) `toString))))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      
                      (defvar text (-> (get_selection) `toString))
                      (doc_exec `insertHTML (+ "<code>" text "</code>"))
                      (select_node_at_point)
                      (collapse_to_end (get_selection))
                      (move_point `forward `character)
                      ;(doc_exec `insertHTML "<code>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
          }
       insert_button:{
          prior_text_sequence: "%BT"
          context_menu: true
          control_menu: true
          on_event: `keyup
          remove_if_prior: true
          description: "Insert button to perform a function"
          qualifier: (fn (point ctl)
                        (progn
                           (sleep 0.001)
                           (not (point_under_element_tag? "PRE" point))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      (let
                         ((command_to_call nil)
                          (text nil)
                          (elem nil)
                          (editor_ctl nil)
                          (id (gen_id "temp_button"))
                          (bcode nil))
                         (doc_exec `insertHTML (+ "<br id='" id "_br'><div id='" id "'>Button</div>") true)
                         (select_node_at_point)
                         (collapse_to_end (get_selection))
                         (move_point `forward `character)
                         (= command_to_call (floating_temp_editor))
                         (= elem (get_by_id id))
                         (if (not (blank? command_to_call))
                             (= text (request_user_input "Enter Button Text")))
                         (if (not (blank? text))
                             (progn
                                (if elem
                                   (progn
                                      (-> elem `replaceWith (button { command_text: command_to_call onclick: (eval_struct (read_lisp command_to_call)) } text))
                                      (aif (get_by_id (+ id "_br"))
                                           (-> it `remove)))
                                   (log "Unable to replace!" elem)))
                             (progn
                                (sleep 0.01)
                                (= elem (get_by_id id))
                                (if elem
                                   (-> elem `remove))
                                (aif (get_by_id (+ id "_br"))
                                     (-> it `remove)))))))
                    
       }
       reload_rules:{
         on_event: `keydown
         key_sequence: "Alt-L"
         handle_event: true
         control_menu: true
         description: "Reloads the markdown rule set.  This can be used after any changes have been made to the rule set."
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (notify (+ "Reloading Rules: " ctl.name))
                     (-> ctl `reload_rules)))
         
     }
   })

;; placeholder
(defun wait_for_file_selection ()
   true)
   

(defun wrap_in_resizable (elem unlock_ratio)
   (let
      ((move_state nil)
       (just_enable (if elem.parentElement
                        (== (get_attribute elem.parentElement "initializer") "wrap_in_resizable")
                        false))
       (expander_elem (if just_enable
                          elem.parentElement.children.1
                          (div { `contentEditable: `false `class: "juno-lower-left-expander"  }
                               "⤡")))
                          
       (full_block (div { `style: "z-index: 8; width: 100%; height: 100%; position: absolute; top:0px; left: 0px;" }))
       (dims nil)
       (resize_mode false)
       (elem_dims {
           `width: elem.offsetWidth
           `height: elem.offsetHeight
       })
       (initial_ratio (/ elem.offsetWidth elem.offsetHeight))
       (max_dims {
                  `width: 0
                  `height: 0
                  })
       (body_element nil)
       
       (block_on (fn (e)
                    (progn
                       (= dims (-> frame `getBoundingClientRect))
                       (= body_element (get_by_id "body"))
                       (= max_dims {
                                     `width: (prop body_element `offsetWidth)
                                     `height: (prop body_element `offsetHeight) })
                       (-> body_element `appendChild full_block)
                       (= move_state {
                                       mx: e.pageX
                                       my: e.pageY
                                       fx: dims.right
                                       fy: dims.top
                                       w: dims.width
                                       h: dims.height
                                       }))))
       
       (end_drag (fn (e)
                    (progn
                       (= move_state nil)
                       (= resize_mode false)
                       (if (is_function? elem.resize)
                           (-> elem `resize))
                       (-> full_block `remove))))       
       (handle_drag (fn (e)
                      (when (and move_state
                                 (== e.buttons 1))
                         (when resize_mode
                            (set_style [["height" (+ "" (Math.min (- max_dims.height 30) (+ dims.height (- e.pageY move_state.my))) "px")]]
                                       frame)
                            (if unlock_ratio
                               (set_style [["width" (+ "" (Math.min (- max_dims.width 30) (+ dims.width (- e.pageX move_state.mx))) "px") ]] frame)
                               (set_style [["width" (+ "" (* initial_ratio frame.offsetHeight) "px") ]] frame))
                            (set_style [["height" (+ "" frame.offsetHeight "px")]
                                        ["width" (+ "" frame.offsetWidth "px") ]] elem)
                            ))))
                                   
       (frame (if just_enable
                  elem.parentElement
                  (div { `initializer: "wrap_in_resizable" `class: "juno-shadow-on-hover" `style: (+ "padding: 0px;position: relative; display: inline-block; border: 1px solid transparent; width:" elem_dims.width "px; height: " elem_dims.height "px;") }))))
      
     
      (attach_event_listener expander_elem
         `mousedown
         (fn (e)
            (progn
               (= resize_mode true)
               (block_on e))))
      
      
      (attach_event_listener full_block
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mousemove
                             handle_drag)
      (attach_event_listener full_block
                             `mousemove
                             handle_drag)
      
      ;; if we have a control, initialize it if it needs it since it is 
      ;; now mounted on the DOM
      (set_style [["position" "relative"]
                  ["display" "inline-block"]] frame)
      (unless just_enable
         (-> elem `replaceWith frame)
         (-> frame `append elem)
         (-> frame `append expander_elem))
      frame)
   {
     `description: (+ "Given an element, will wrap it in a resizable element that preserves "
                      "aspect ratio. The provided element will be replaced with the wrapped element.  "
                      "The element will have a transparent handle on the lower right side that when "
                      "hovered over, will indicate that the element can be resized.  <br>If the "
                      "argument `unlocked_ratio` is true, the aspect ratio of the content is not "
                      "fixed, and can independently resized in either the X or Y axis.  ")
       `usage: ["element:Element" "unlocked_aspect_ratio:?boolean"]
       `tags: ["DOM" "element" "UI" "resize" ]
   })

(defcontrol DOM_editor ()
   ((starter  (div { } "Enter text"))
    (root_elem (div { `contenteditable: true `tabindex: 0 `class: "juno-dom-editor-root" }
                    starter))
    (document_view (div {  `class: "juno-editable" `style: "height: calc(100% - 0px); overflow: scroll; background: var(--editor-bg-color);  line-height: 1.5em; font-size: 1.1em;  padding: 5px; margin-top: 0px;margin-bottom: 0px"} 
                        root_elem))
       
    (position_elem (div { `style: "padding: 5px;color: darkblue;" } ))
    (depth_elem (div { `style: "padding: 5px; color: green;" } ))
    (path_elem (div { `style: "padding: 5px; " } ))
    (evaluator_span (span { `class: "juno-evaluator" `style: "cursor: pointer" `title: (dtext "Name of the evaluator assigned to this buffer") } "-"))
    (key_history_elem (div { `style: "padding: 5px;" }))
    (text_around_elem (div { `style: "padding: 5px;" }))
    (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" }
                               (if options.read_only
                                  "RO"
                                  "")))
    (status_elem (div { `style: "max-height: 40px; overflow: auto; border-bottom: 1px solid var(--main-accent-line-hover); padding: 5px; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
                      position_elem
                      depth_elem
                      path_elem
                      text_around_elem
                      key_history_elem))
    (debug_offset_height "55px")
    (debug_elem (div { `style: (+ " padding: 5px; overflow:scroll; height: calc(100% - " debug_offset_height ");") } ))
    (debug_container_elem (div { `style: "height: calc(100% - 10px); overflow: hidden;" }
                               status_elem
                               debug_elem))
    (add_attribute_button (button {} (dtext "Add Attribute")))
    (delete_element_button (button {} (dtext "Remove Element")))
    (attributes_title (div { style: "margin-block-start: 10px; margin-block-end: 10px;" } "Attributes"))
    (attributes_header_view (div { style: "margin: 0px; padding: 2px; background: #00000010;" }
                                   attributes_title
                                   (div { `style: "display: flex" } add_attribute_button delete_element_button)))
    
    (attributes_page_view (div {
                                 style: "height: calc(100% - 50px); overflow: auto; background: var(--editor-bg-color);  line-height: 1.5em; font-size: 1.0em;  padding: 5px; margin-top: 0px;margin-bottom: 0px";
                                 } "-"))
    (attributes_content_view 
       (div {
              style: "height: calc(100% - 50px); overflow: auto; background: var(--editor-bg-color);  line-height: 1.5em; font-size: 1.0em;  padding: 5px; margin-top: 0px;margin-bottom: 0px";
              
              } ))
    (attributes_tabs (tabs [
                            ["Section"
                             (div {} attributes_header_view
                                  attributes_content_view)]
                            ["Document" 
                             attributes_page_view]]))
    (attributes_view (div {
                            style: "height: calc(100% - 0px); min-width: 300px; overflow: hidden; background: var(--editor-bg-color); font-size: 1.0em;  padding: 0px; margin: 0px;"
                            }
                       attributes_tabs.view))
    (ns_span (span { `title: "Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } nseval.namespace))
    (sview (split_view_vertical 
                                (if options.debug
                                   (split_view_horizontal document_view  debug_container_elem)
                                   {
                                     `view: document_view
                                     })
                                attributes_view
                                {
                                    ratio: 0.7
                                }))
    (content_view (div { `style: "background: var(--control-bg-color); overflow: hidden; width: 100%; height: 100%;" }
                       sview.view))
    (show_attributes_button (button { `style: "float: right;" `class: "juno-button-on" } "Attributes"))
    (on_resize (fn (self)
                  (progc
                     
                     (= debug_offset_height (+ 45 (Math.max 5 control_status.offsetHeight)))
                     
                     (set_style [["height" (+ "calc(100% - " debug_offset_height "px)")]] debug_elem)
                     (if (not options.debug) 
                         (set_style [["height" (+ "calc(100% - " control_status.offsetHeight "px)")]] document_view))
                     (set_prop root_elem.parentElement `scrollTop current_scroll)
                     )))
    (control_bar_elements [ ns_span evaluator_span locked_span show_attributes_button ])
    (rules nil) 
    (rules_menu [])
    (collection_timer nil)
    (key_sequence_rules { keyup: {} keydown: {} })
    (prior_text_rules { keyup: {} keydown: {} })
    (post_text_rules { keyup: {}  keydown: {} })
    (load_rule (fn (name rule)
                  (let
                     ((lookup_rule (+ { name: (or name "Unnamed Rule") `remove_if_prior: (or rule.remove_if_prior false) }
                                      (if (is_function? rule.qualifier)
                                         { `qualifier: rule.qualifier }
                                         {})
                                      { `text_sequence: rule.prior_text_sequence }
                                      (if (is_function? rule.exec)
                                          { `exec: rule.exec }
                                          { `exec: (eval `(fn ()
                                                             (notify (+ "Rule " ,#name " has no exec rule")))) })
                                      (if rule.handle_event
                                         { `handle_event: true }
                                         {}))))
                     (when options.debug
                        (log "loading rule: " name rule lookup_rule))
                     (when rule.prior_text_sequence
                        (make_path [ rule.on_event rule.prior_text_sequence ] prior_text_rules lookup_rule))
                     (when rule.key_sequence
                        (make_path [ rule.on_event rule.key_sequence ] key_sequence_rules lookup_rule))
                     (when rule.control_menu
                        (push rules_menu
                           [(from_key name)
                            (eval `(fn (e)
                                      (try
                                         (progn
                                            (defvar rule ,#rule)
                                            (defvar ctl_id ,#id)
                                            (defvar ctl (get_control_by_id ctl_id))
                                            (console.log "DOM_editor: load_rule: " ctl.options (get_by_id "body"))
                                            (when (and ctl
                                                       (prop  ctl `root_elem))
                                               (focus_to (-> ctl `root_elem))
                                               (defvar current_point (-> ctl `current_point))
                                               (when current_point
                                                  (move_to_point current_point))
                                               (if (is_function? rule.qualifier)
                                                   (if (rule.qualifier current_point ctl)
                                                       (progn
                                                           (rule.exec current_point ctl nil)))
                                                   (rule.exec current_point ctl nil))))
                                         (catch Error (e)
                                            (progn
                                               (log "dom_editor: load_rule: error on eval: " e.message)
                                               (console.error "dom_editor: load_rule: error on eval: " e))))))])))))
    (load_rules (fn ()
                   (progn
                      (cond 
                         (is_array? options.rules)
                         (= rules (resolve_path options.rules Environment.context.scope))
                         (is_function? options.rules)
                         (= rules (-> options `rules self)))
                      (= rules_menu [])
                      (= key_sequence_rules { keyup: {} keydown: {} })
                      (= prior_text_rules { keyup: {} keydown: {} })
                      (= post_text_rules { keyup: {} keydown: {} })
                      (when rules
                         (for_each (pset (pairs rules))
                            (destructuring_bind (name rule)
                               pset
                               (load_rule name rule)))))))
    (active_rules (fn ()
                     prior_text_rules))
    (current_point nil)
    (saved_point nil)
    (last_event_context nil)
    (last_active_elem nil)
    (render (fn ()
               content_view))
    (evaluator nil)
    (set_evaluator (fn (evaluator_function)
                              (when (is_function? evaluator_function)
                                 (= evaluator evaluator_function)
                                 (dispatch_event { command: "dom_editor_change"
                                                   source: options.id
                                                   args: [ { `option: "evaluator" `value: evaluator_function } ] }))))
    (change_evaluator_name (fn (event_obj)
                              (progn
                                 (log "Received evaluator name change: " event_obj)
                                 (aif (resolve_path [ `args 0 `value ] event_obj)
                                      (set_prop evaluator_span
                                         `innerText
                                         it)))))
    (set_filename (fn (fname)
                     (if (is_string? fname)
                         (progn
                            (set_prop options
                               `filename
                               fname)
                            (set_prop options
                               `path
                               (conj [ `filesystem ] (split_by "/" fname)))
                            (set_prop title_span
                               `innerText
                               (get_editor_file_basename self)))
                         (notify "Require a string for the filename"))))
    (save_as (fn ()
                (let
                   ((fname (wait_for_file_selection true)))
                   (declare (function wait_for_file_selection)
                            (global wait_for_file_selection))
                   (when (not (blank? fname))
                      (set_filename fname)
                      (request_save)))))
    (hide_state false)
    (current_scroll 0)
    (on_hide (function (self)
                (progn
                   (= hide_state true)
                   (unless current_point
                      (log "DOM_editor: on_hide: no current point"))
                   (when current_point
                      ;(= saved_point (clone current_point))
                      ;(log "DOM_editor: saved_point: range: " saved_point.range)
                      ;(set_prop saved_point
                      ;   `range (-> saved_point.range `cloneRange))
                      ;(-> saved_point.selection `removeAllRanges)
                      ;(-> saved_point.selection `addRange saved_point.range)
                      true))))
    (on_focus (fn (self)
                (progc
                   (wait_for_display self)
                   (if saved_point
                      (progn
                         (if hide_state
                            (progn
                               ;(collapse_to_start saved_point.selection )
                               (move_to_point_a saved_point)
                               (set_prop root_elem.parentElement `scrollTop current_scroll)
                               ;(-> saved_point.element `scrollIntoView)
                               (set_prop (first (get_by_tag "html")) `scrollTop 0)
                               (= hide_state false))
                            (progn
                               (move_to_point_a saved_point)))
                         
                         (console.log "DOM_editor: on_focus: saved_point:  "  saved_point.element saved_point)
                         (show_attributes saved_point.element)
                         true)
                      (progn
                         (if (> root_elem.children.length 0)
                             (progn
                                (focus_to root_elem.children.0)
                                (collapse_to_start (select_element root_elem.children.0)))
                             (focus_to root_elem))
                        )))))
    (process_rules_for_event (fn (event)
                                (let
                                   ((text (get_text_around_point current_point))
                                    (on_event event.type)
                                    (rule_result nil)
                                    (results [])
                                    (prior_text_sequence (or text.0 ""))
                                    (next_text_sequence text.1)
                                    (key_sequence (clone (key_history))))
                                   
                                   ;; spaces show up as character code 160, so we need to move it to space to make
                                   ;; any matches succeed that are terminated by a space
                                   ;; note that this could probably be changed in the get_text_around_point function
                                   ;; but that needs to be thought through...
                                   
                                   (when (and (is_string? text.0)
                                              (== (-> (last_n_chars 1 text.0) `charCodeAt) 160))
                                       (set_prop text 
                                          0
                                          (+ (chop text.0) " ")))
                                   
                                   ;; next find the rule to eval if any...
                                   ;; from the most specific to the least
                                   (for_each (n [ 3 2 1 ])
                                      (progn 
                                         (aif (resolve_path [ on_event (join " " (last_n n key_sequence)) ] key_sequence_rules)
                                              (when (= rule_result (qualify_and_run it `key_sequence event))
                                                 (push results rule_result)
                                                 (break)))))
                                   (for_each (n [ 4 3 2 1 ])
                                      (progc
                                         (when (>= (length text.0) n) 
                                            (aif (resolve_path [ on_event (last_n_chars n text.0) ] prior_text_rules)
                                                (when (= rule_result (qualify_and_run it `prior_text event))
                                                   (push results rule_result)
                                                   (break))))))
                                   rule_result)))
     ;; when a rule is identified by process_rules_for_event as matching
     ;; the qualify_and_run function will make check to see if it is qualified
     ;; to run and then run the rule 
    (qualify_and_run (fn (rule identified_by event)
                        (progc
                           
                           (defvar qualified? 
                              (if (is_function? rule.qualifier)
                                  (-> rule `qualifier current_point self) ;; only run it if qualifier returns true
                                  true)) ;; otherwise default run it since no qualifier
                           (if qualified?
                              (progn
                                 (when rule.handle_event
                                    (handle_event event))
                                 (when (and rule.remove_if_prior
                                            (== identified_by "prior_text"))
                                    
                                    ;; remove the text that qualified it
                                    ;; however we can delete the complete element if we are at the same position (offset) 
                                    ;; in the current element being edited as the length of the text sequence to remove.
                                    (if (> current_point.position (length rule.text_sequence))
                                        (progn   ;; just extend the selection backward and remove the text..
                                           (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (= current_point (point_for root_elem)))
                                        (progn ;; in this case we will remove the whole node that contains the trigger text
                                               ;; so we need to move backward to the prior node so the rule works consistently.
                                            (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (move_point `backward `character)
                                           (= current_point (point_for root_elem)))))
                                 (when (== identified_by `key_sequence)
                                    (= key_history_acc []))
                                 ;; then call the rule!
                                 (try
                                    (-> rule `exec current_point self event)
                                    (catch Error (e)
                                       (progn
                                          (notify (+ "dom_editor: rule: " rule.name ": " e.message))
                                          (log "dom_editor: caught error: " e.message e)
                                          (console.error "dom_editor: caught error on rule evaluation: " e.message e))))
                                 true)
                              false))))
    (key_history_acc [])
    (key_history_length 4)
    (key_history (function ()
                    key_history_acc))
    (is_dirty? false)
    (add_to_key_history (function (key)
                           (progn
                              (unless (contains? key (list "Shift" "Alt" "Ctrl" "Command")) ;; don't grab just the special key downs
                                 (push key_history_acc key)
                                 (while (> key_history_acc.length key_history_length)
                                    (take key_history_acc))))))
    (set_last_active_element (fn (status)
                                (= last_active_elem status.element)))
    (key_down_event (fn (event)
                       (progc
                          (let
                             ((status (point_for root_elem))
                              (key event.key))
                             (cond
                               
                                (and options.close_on_escape 
                                  (== key "Escape"))
                               (progn
                                  (log "DOM Editor:Escape pressed!")
                                  (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                               else
                               (progc
                                  (add_to_key_history (get_key_code event))
                                  (= last_event_context (process_rules_for_event event))
                                  (when (> __VERBOSITY__ 0) 
                                     (log "last_event_context: " last_event_context))
                                  key))))))
    
    (key_up_event (fn (event)
                      (progc
                         (let
                            ((status (point_for root_elem))
                             (key event.key)
                             (path_comps (for_each (c status.dom_path)
                                            (progn
                                               (if (== 1 c.nodeType)
                                                   c.tagName
                                                   "text")))))
                            (= current_point status)
                            (= saved_point status)
                           
                            (when (attributes_showing?)
                               (show_attributes status.element))
                            (when current_point.element.tagName
                               (-> attributes_title
                                  `replaceChildren
                                  (path_to_root current_point.element)))
                            ;(console.log "key_up_event: current_point: " current_point)
                            (= last_event_context (process_rules_for_event event))
                            (when (or (and (== key.length 1)
                                            (not event.metaKey)
                                            (not event.ctrlKey))
                                       (or (== key "Backspace")
                                           (== key "Enter")))
                                (when (not is_dirty?)
                                   (add_class "juno-needs-save" title_span))
                                (= is_dirty? true))
                            
                            (set_prop position_elem
                               `innerText
                               status.position)
                            (set_prop depth_elem
                               `innerText (length status.dom_path))
                            ;(-> path_elem `replaceChildren
                            ;  (div { } (join ":" (key_history))))
                            (set_prop key_history_elem
                               `innerText
                               (join ":" (key_history)))
                            (set_prop text_around_elem
                               `innerText
                               (join ":" (get_text_around_point status)))
                            (-> path_elem `replaceChildren
                               (div { } (for_each (name path_comps)
                                       (span {`style: "padding-right: 5px" } name))))
                            
                            (set_prop view
                               `scrollTop 0)      
                            (when collection_timer
                               (clearTimeout collection_timer))
                            (= collection_timer
                               (setTimeout
                                  (fn ()
                                     (progn
                                        (when (and (not options.path)
                                                   (not options.filename))
                                           (= is_dirty? false)
                                           (remove_class "juno-needs-save" title_span)
                                           (set_prop options
                                              `content
                                              (element_to_lisp root_elem { use_ns: `html } )))))
                                  1000))
                               
                            (when options.debug
                               (-> debug_elem `replaceChildren
                                  (pre (pretty_print (element_to_lisp root_elem)))))
                            ))))
   
    (cut_selection (fn ()
                      (let
                         ((selection (get_selection))
                          (selrange (-> selection `getRangeAt 0))
                          (copytext (-> selrange `toString)))
                         (when (not (blank? copytext))
                            (-> navigator.clipboard `writeText copytext)
                            (doc_exec `delete nil)
                            (set_dirty)))))
    (select_all (fn ()
                   (let
                      ()
                      (focus_to root_elem)
                      (doc_exec `selectAll))))
    (copy_selection (fn ()
                       (progc
                          (notify "Copied")
                          (cond
                             (== (prop (active_element) `tagName) "INPUT")
                             (progn
                                (-> navigator.clipboard `writeText (prop (active_element) `value)))
                             else
                             (let
                                ((selection (get_selection))
                                 (selrange (-> selection `getRangeAt 0))
                                 (copytext (-> selrange `toString)))
                                (when (not (blank? copytext))
                                   (-> navigator.clipboard `writeText copytext)))))))
    
    (paste_selection (fn (e)
                        (let
                           ((perms (navigator.permissions.query { `name: "clipboard-read" }))
                            (contents nil)
                            (pasted false)
                            (id (gen_id "paste_content"))
                            (new_image nil)
                            (blob nil))
                           (if (== perms.state "denied")
                              (notify "Unable to paste due to invalid permissions")
                              (progn
                                 (= contents (-> navigator.clipboard `read))
                                 (for_with (item contents)
                                    (when (not pasted)
                                       (log "clipboard item: " item)
                                       (for_each (item_type item.types)
                                          (progn
                                             (log "..checking: " item_type)
                                             (cond
                                                (== item_type "text/html")
                                                (progn
                                                   (= pasted true)
                                                   (doc_exec `insertHTML (-> navigator.clipboard `readText))
                                                   (set_dirty)
                                                   (break))
                                                (== item_type "text/plain")
                                                (progn
                                                   (= pasted true)
                                                   (doc_exec `insertText (-> navigator.clipboard `readText))
                                                   (set_dirty)
                                                   (break))
                                                (starts_with? "image/" item_type)
                                                (progn
                                                   (= pasted true)
                                                   (= blob (-> item `getType item_type))
                                                   (= new_image 
                                                      (img { id: id style: "width: 400px; height: auto; " src: (+ "data:" item_type ";base64," (encode_to_base64 blob)) }))
                                                   (doc_exec `insertHTML new_image.outerHTML)
                                                   (sleep 0.01)
                                                   (= new_image (get_by_id id))
                                                   (when new_image
                                                      (wrap_in_resizable
                                                         new_image))
                                                   (set_dirty)
                                                   (break))))))))))))
                     
    (request_save (function ()
                        (progn
                           (if (or options.path options.filename)
                              (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] })
                              (-> self `on_save_complete)))))
    (nseval (if (not (blank? options.path_namespace))   
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))
    (menu_items (fn ()
                   (conj [["Actions" rules_menu]]
                      [["Copy contents as Lisp Structure" (fn (e) (copy_text_to_clipboard (pretty_print (as_lisp (-> self `get)))))]
                       (if options.filename
                          [(+ (dtext "Save") " " (get_editor_file_basename self)) (fn (e) (request_save))]
                          [])
                       [(+ (dtext "Save as") "...") (fn (e) (save_as)) ]
                       [(dtext "Select Evaluator")
                           user_select_evaluator]
                       (if options.read_only
                                [ (dtext "Allow Editing" ) (fn () (-> self `set_read_only false)) ]
                                [ (dtext "Set Read-Only Mode") (fn () (-> self `set_read_only true)) ])])))
    (set_name (fn (new_name force)
                 (progn
                    (when (and (not (blank? new_name))
                               (not (== (get_control_by_name new_name) self)))
                       (set_prop options
                          `name
                          (if force
                             new_name
                             (compute_name_for_control new_name)))
                       (set_prop self
                          `name
                          options.name)
                       (dispatch_event { command: "editor_change"
                                         source: self.id
                                         args: [ { `option: "name" `value: options.name } ] }))
                    (set_prop title_span
                       `innerText
                       options.name)
                    options.name)))
    (check_for_unhandled_elements (fn (elem)
                                     (let
                                        ((elem_type nil))
                                        (cond
                                           (is_element? elem)
                                           (progn
                                              (= elem_type elem.tagName)
                                              (cond
                                                 (and (== elem_type "IMG")
                                                      (not (get_attribute elem "_handled")))
                                                 (progn
                                                    (set_attribute elem "_handled" "true")
                                                    (wrap_in_resizable elem))
                                                 else
                                                 (when (> elem.children.length 0)
                                                    (for_each (c elem.children)
                                                       (check_for_unhandled_elements c)))))))))
    (saved_content nil)
    (set_read_only (fn (read_only?)
                              (progn
                                 (set_prop options
                                    `read_only
                                    read_only?)
                                 (cond 
                                    read_only?
                                    (progc
                                       (= saved_content (element_to_lisp root_elem))
                                       ;(log (pretty_print saved_content))
                                       (remove_attribute root_elem `contenteditable)
                                       (set_prop locked_span
                                          `innerText
                                          (dtext "RO")))
                                    options.reader_mode
                                    (progn
                                       (notify (dtext "This control is in reader mode, and cannot be edited."))
                                       (set_prop options
                                          `read_only
                                           true))
                                    else
                                    (progc
                                       (when saved_content
                                          ;(log (pretty_print saved_content))
                                          (set_prop saved_content.1
                                             `contenteditable true)
                                          (-> root_elem `replaceWith (eval saved_content))
                                          (= root_elem document_view.children.0)
                                          (check_for_unhandled_elements root_elem)
                                          (focus_to root_elem)
                                          ;(set_attribute root_elem `contenteditable true)
                                          (set_prop locked_span
                                             `innerText
                                             (dtext ""))))))))
    (set_show_attributes (fn (state)
                            (alert_on_error "Unable to show attributes"
                                            (if state
                                               (progn
                                                  (set_prop options
                                                     `show_attributes
                                                     true)
                                                  (add_class "juno-button-on" show_attributes_button)
                                                  (-> sview `set_show_second_panel true))
                                                  (progn
                                                     (set_prop options
                                                        `show_attributes
                                                        false)
                                                     (remove_class "juno-button-on" show_attributes_button)
                                                     (-> sview `set_show_second_panel false))))))
                                  
    (accept_content (fn (files)
                       (let
                          ((fdata nil)
                           (content_ok? 
                              (let
                                 ((is_image? false))
                                 (for_each (file files)
                                    (when file.type
                                       (if (starts_with? "image/" file.type)
                                           (= is_image? true)
                                           (progn
                                              (= is_image? false)
                                              (break)))))
                                 is_image?)))
                          ;; if the content is an image or image, OK
                          ;; otherwise send them to the standard import
                       (if content_ok?
                          (progn
                             (for_each (file files)
                                (let
                                   ((new_image nil)
                                    (id (gen_id "img")))
                                   (= fdata (encode_to_base64 (read_file file { `read_as: "binary" })))
                                   (= new_image 
                                         (img { id: id style: "width: 500px; height: auto; " src: (+ "data:" file.type ";base64," fdata) }))
                                   (doc_exec `insertHTML new_image.outerHTML)
                                   (sleep 0.01)
                                   (= new_image (get_by_id id))
                                   (when new_image
                                      (notify "Making resizable")
                                      (wrap_in_resizable
                                         new_image)))))
                          (load_files files)))))
    (error_state false)
    (set_dirty (fn ()
                  (when (not is_dirty?)
                     (add_class "juno-needs-save" title_span))
                  (= is_dirty? true)))
    (on_destroy (fn ()
                   (progn
                      (cond
                         is_dirty?
                         (progn
                            (defvar response
                               (request_user_input options.name
                                                   "text"
                                                   { input: (div { value: "remove" }
                                                                 (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                            response)
                         else
                         true))))
    (page_attribs {
                    class: ""
                    style: "" 
                    })
    (show_page_view_attributes (fn ()
                                   (let
                                      ((attrib_list (prop root_elem `attributes)))
                                      (for_each (attrib_num (range (length attrib_list)))
                                         (progn
                                            (set_prop page_attribs
                                               (resolve_path [ `attributes attrib_num `name ] root_elem)
                                               (resolve_path [ `attributes attrib_num `value ] root_elem))))
                                      (-> attributes_page_view
                                                  `replaceChildren
                                                  (div { `style: "width: calc(100% -5px);" }
                                                       [ (value_to_dom page_attribs
                                                                     {
                                                                       table_style: "width: 100%;table-layout: fixed;"
                                                                       key_style: "width: 150px"
                                                                       input_class: "juno-full-width"
                                                                       editable: true
                                                                       disable_object_toggle: true
                                                                       on_change: (function (path new_value)
                                                                                     (progn
                                                                                        (handle_attribute_change root_elem (first path) new_value)
                                                                                        new_value))
                                                                       })])))))
    (attributes_showing? (fn ()
                            (has_class? "juno-button-on" show_attributes_button)))
    (displayed_element_for_attributes nil)
    (remove_element (fn (element)
                       (progn
                          (remove_class "juno-highlighted" element)
                          (select_element element)
                          (doc_exec `removeFormat)
                          (doc_exec `delete)
                          (sleep 0.01)
                          (set_dirty)
                          ;(move_point `backward `character)
                          )))
    (path_to_root (fn (element)
                     (let
                        ((acc [])
                         (dist 0)
                         (current_element nil))
                        (div { style: "display: inline-block" }
                             (if (is_element? element)
                                 (progn
                                    (= current_element element)
                                    (while (and (is_element? current_element.parentElement)
                                                (not (== current_element root_elem)))
                                       (progn
                                          (prepend acc
                                             (div { `dist: dist class: "juno-type-element" } current_element.tagName))
                                          (inc dist)
                                          (= current_element current_element.parentElement)))
                                    (prepend acc
                                       (div { `dist: dist class: "juno-type-element"  } "DOCUMENT"))
                                    acc)
                                 "-")))))
    (go_to_tree_pos (fn (distance)
                       (let
                          ((elem displayed_element_for_attributes))
                          (when elem
                             (for (c (range (int distance)))
                                  (= elem elem.parentElement))
                             (if (== elem root_elem)
                                 (-> attributes_tabs `activate_tab 1)
                                 (progn
                                    (path_to_root elem)
                                    (show_attributes elem)
                                    (add_class "juno-highlighted" elem)
                                    (setTimeout 
                                       (fn () 
                                          (progc
                                             (remove_class "juno-highlighted" elem)
                                             )) 500)))))))
    
    (show_attributes (fn (element)
                        (if (and element
                                 (not (== element displayed_element_for_attributes)))
                           (let
                              ((attrib_list (prop element `attributes))
                               (attribs {
                                   class: (get_attribute element `class)
                                   style: (get_attribute element `style)
                                   onclick: (prop element `onclick)
                                   command_text: (if (prop element `onclick)
                                                     (+ "(javascript | " (-> (prop element `onclick) `toString) " | )")
                                                     "")
                                   contentEditable: (prop element `contentEditable)
                                   spellcheck: (prop element `spellcheck)
                               }))
                              (= displayed_element_for_attributes element)
                              (defglobal *dd* displayed_element_for_attributes)
                              (if (== element root_elem)
                                  (-> attributes_tabs `activate_tab 1)
                                  (progn
                                      (-> attributes_tabs `activate_tab 0)
                                      (when false
                                         (for_each (attrib_num (range (length attrib_list)))
                                            (progn
                                               (log "attrib: " attrib_num (resolve_path [ `attributes attrib_num `name ] element))
                                               (set_prop attribs
                                                  (resolve_path [ `attributes attrib_num `name ] element)
                                                  (resolve_path [ `attributes attrib_num `value ] element)))))
                                     (console.log "show_attributes: current_point: " current_point)
                                     (-> attributes_title
                                        `replaceChildren
                                        (path_to_root element))
                                     
                                     (-> attributes_content_view
                                        `replaceChildren
                                        (div { `style: "width: calc(100% -5px);" }
                                             (value_to_dom attribs
                                                           {
                                                             table_style: "width: 100%;table-layout: fixed;"
                                                             key_style: "width: 150px"
                                                             input_class: " juno-full-width"
                                                             editable: true
                                                             disable_object_toggle: true
                                                             on_change: (function (path new_value)
                                                                           (progn
                                                                              (handle_attribute_change element (first path) new_value)
                                                                              new_value))
                                                             })
                                             ))))))))
    
    (update_command (fn (element text)
                       (alert_on_error "Cannot update command"
                          (log "updating command: " text element.innerText)
                          (set_attribute element
                             `command_text
                             text)
                          (set_prop  element 
                             `onclick
                              (eval_struct (read_lisp text)))
                          (= displayed_element_for_attributes nil)
                          (show_attributes element)
                          )))
    
    (handle_attribute_change (function (element key new_value)
                                (progn
                                   (set_dirty)
                                   (notify (+ "Attribute change " key))
                                   (= is_dirty? true)
                                   (cond
                                      (== key "class")
                                      (progc
                                         (log "handle_attribute_change: " element.classList.value)
                                         
                                         (let
                                            ((current_classes (split_by " " element.classList.value))
                                             (new_classes (split_by " " new_value)))
                                            (log "adjusting classes: " current_classes "-> " new_classes)
                                            (for_each (c current_classes)
                                               (unless (contains? c new_classes)
                                                  (remove_class c element)))
                                            (for_each (c new_classes)
                                               (unless (has_class? c element)
                                              (add_class c element)))
                                            element.classList))
                                      (== key "style")
                                      (progn
                                         (-> element `setAttribute "style" new_value)
                                         new_value)
                                      (== key "command_text")
                                      (progn
                                         (update_command element new_value)
                                         new_value)
                                      else
                                      (progn
                                         (notify (+ "New Attribute: " key))
                                         (-> element `setAttribute key new_value)))
                                   (when options.debug
                                      (-> debug_elem `replaceChildren
                                         (pre (pretty_print (element_to_lisp root_elem)))))
                                   new_value
                                      )))
    (rename_editor (fn ()
                      (let
                         ((name_input (input { `tabindex: 0 `style: "width: 95%; font-weight: bold;" `value: options.name } ))
                          (bbox (-> title_span `getBoundingClientRect))
                          (rename_view
                             (div { `id: "cmenu" `style: (+ "z-index: 10000; padding: 5px; margin: 0px; min-width: " (+ bbox.width 15) "px; background: inherit; position:absolute; top: " (- bbox.top 5) "px; left: "  bbox.left "px;") }
                                  
                                  name_input
                                  (div { `style: "padding: 5px;"}
                                       (cond
                                          (and (is_array? options.path)
                                               (== "filesystem" (first options.path)))
                                          (div
                                             (div { `style: "padding: 5px; font-weight: bold" } "Save To File")
                                             (div { `style: "padding: 5px; " } (join " / " (rest options.path))))
                                          (is_array? options.path)
                                          (div
                                             (div { `style: "padding: 5px; font-weight: bold" } "Save To Symbol")
                                             (for_each (comp options.path)
                                                (span { `style: "padding: 5px;" } comp)))
                                          (eq nil options.path)
                                          (div
                                             (div { `style: "padding: 5px; font-weight: bold" } "Temporary Buffer" )
                                             (div { `style: "padding: 5px;" } "No Path"))
                                          else
                                          (div
                                             (div { `style: "padding: 5px; font-weight: bold" } "Check Path")
                                             (div (as_lisp options.path)))))))
                          (cmenu_remove (fn ()
                                           (aif (get_by_id "cmenu")
                                                (-> it `remove)))))
                         
                         (declare (function resolver))
                         (cmenu_remove)
                         (sleep 0.01)
                         (-> (get_by_id "body")
                             `append rename_view)
                         (-> name_input `select)
                         (focus_to name_input)
                         (attach_event_listener name_input
                            `keyup
                            (fn (e)
                               (progn
                                  (cond
                                     (and (== e.key "Enter")
                                          (not (blank? name_input.value)))
                                     (progn
                                        (set_name name_input.value)
                                        (set_prop options
                                           `group_name
                                           options.name)
                                        (cmenu_remove)
                                        (focus_to_editor self))
                                     (== e.key "Escape")
                                     (progn
                                        (cmenu_remove)
                                        (focus_to_editor self)))))))))
    (sorted_symbols [])
    (cached_symbols nil)
    (get_current_symbols (fn ()
                            (let
                               ((symbol_set (if evaluator_control
                                                (-> evaluator_control `available_symbols)))
                                (cns (if evaluator_control
                                         (-> evaluator_control `current_namespace)))
                                (in_path nil)
                                (search_order nil))
                               (when (== self nil)
                                  (log_error "text_editor: getting current symbols and shouldn't be since we are destroyed!"))
                               (when (is_object? symbol_set)
                                  (= cached_symbols symbol_set)
                                  (= search_order
                                     (if cns
                                        (conj [ cns `core ]
                                              (reduce_sync (ns (keys cached_symbols) )
                                                 (if (and (not (== ns `core))
                                                          (not (== ns cns)))
                                                     ns)))
                                        (keys cached_symbols)))
                                  (= sorted_symbols
                                     (flatten
                                        (for_each (ns search_order)
                                           (progn
                                              (if (or (== ns cns)
                                                      (== ns `core))
                                                  (= in_path true)
                                                  (= in_path false))
                                              (for_each (sym (keys (prop cached_symbols ns)))
                                                 (if in_path
                                                    sym
                                                    (+ ns "/" sym))))))))
                               
                               (when evaluator_control
                                  (set_prop ns_span
                                     `innerText
                                     (-> evaluator_control `current_namespace))))))
    (evaluator_control nil)
    (ns_notifier_id (gen_id "ns_notifier"))
    (name_change_id (gen_id "name_change_notifier"))
    (init_context_menu (fn ()
                          (attach_context_menu
                             content_view
                             (fn (event)
                                (let
                                   ()
                                   (conj 
                                      (if rules_menu 
                                         [[(+ (dtext "Actions") "...")
                                           rules_menu]]
                                         [])
                                      (if rules_menu
                                         [["--" nil]]
                                         [])
                                      [
                                       (if (is_clipboard_allowed?)
                                           [{
                                              text: "Cut"
                                              path: [`global `cut ]
                                              exec: cut_selection }]
                                           [])
                                       (if (is_clipboard_allowed?)
                                           [{
                                              text: "Copy"
                                              path: [`global `copy ]
                                              exec: copy_selection
                                              }]
                                           [])
                                       (if (is_clipboard_allowed?)
                                           [ {
                                               text: "Paste"
                                               path: [`global `paste ]
                                               exec: paste_selection }]
                                           [])
                                       ]))))))
    (set_evaluator_control (fn (control)
                                      (if control.evaluate
                                         (progn
                                            (when options.evaluator_id
                                               (remove_event_handler options.evaluator_id "evaluator_change" ns_notifier_id)
                                               (remove_event_handler options.evaluator_id "control_name_change" name_change_id))
                                            (= evaluator_control control)
                                            (set_evaluator control.evaluate)
                                            (set_prop options
                                               `evaluator_id
                                               control.options.id)
                                            (register_event_handler options.evaluator_id "evaluator_change" ns_notifier_id get_current_symbols)
                                            (register_event_handler options.evaluator_id "control_name_change" name_change_id change_evaluator_name)
                                                                                        (if control.name
                                               (set_prop evaluator_span
                                                  `innerText
                                                  (+ "⭢ " control.name)))
                                            (get_current_symbols)))))
    (user_select_evaluator (fn (e)
                              (progn
                                 (aif (select_evaluator)
                                      (progn
                                         (set_evaluator_control it)
                                         ;(display_context_message (+ (dtext "Evaluator set to ") it.options.name))
                                         (notify (+ (dtext "Evaluator set to ") it.options.name)))))))
    (on_initialize (fn ()
                      (progc
                         (let
                            ((remote_content nil)
                             (is_fresh false)
                             (load_error false)
                             (extension nil))
                            
                            (cond
                               options.filename
                               (progn
                                  (try
                                     (progn
                                        (= remote_content (fetch (+ "/files/" options.filename)))
                                        (cond
                                           (== remote_content.status 200)
                                           (progn
                                              (= remote_content (-> remote_content `text))
                                              (when options.on_load
                                                 (try
                                                    (= remote_content (-> options `on_load remote_content self))
                                                    (catch Error (e)
                                                       (progn
                                                          (alert_box "Invalid Content"
                                                                     (+ "Cannot mount content: " e.message))
                                                          (= load_error true))))))
                                           (== remote_content.status 404)
                                           (progn
                                              (= remote_content "")
                                              (notify (+ "New file: " options.filename))
                                              (= is_fresh true)
                                              (when options.on_load
                                                 (try
                                                    (= remote_content (-> options `on_load nil self))
                                                    (catch Error (e)
                                                       (progn
                                                          (alert_box "Invalid Content"
                                                                     (+ "Cannot mount content: " e.message))
                                                          (= load_error true))))))
                                           remote_content
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": " remote_content.statusText))
                                           else
                                           (throw EvalError (+ "Cannot fetch the path: " options.filename ": received nil response from the fetch operation.")))
                                        (set_filename options.filename)
                                        ;(log "remote_content: " remote_content)
                                        (when (and remote_content (not is_fresh))
                                           (= remote_content (eval (read_lisp remote_content)))
                                           
                                           (-> root_elem `replaceWith remote_content)
                                           (= root_elem remote_content))) ;document_view.children.0)))
                                     (catch Error (e)
                                        (progn
                                           (log "DOM_editor: cannot set remote content: " remote_content)
                                           (alert_box (+ "Unable to open: " options.filename " - " e.message))
                                           (if (== (dtext "Yes") (request_user_choice (dtext "Open content in a text_editor?") [(dtext "Yes") (dtext "No")]))
                                               (setTimeout (fn () (edit_file { `mode: "juno" `filename: options.filename } )) 500))
                                           (= error_state true)))))
                               (is_array? options.path)
                               (progn
                                  (defvar content (resolve_path options.path nseval.global_ctx.scope))
                                  (if (eq nil content)
                                      (progn
                                         (= content (or options.content
                                                        starter))
                                         (= is_fresh true)
                                         (make_path options.path nseval.global_ctx.scope root_elem))
                                      (progn
                                         (when (not (is_element? content))
                                            (= content (try
                                                          (eval content)
                                                          (catch Error (e)
                                                             (progn
                                                                (alert_box "Evaluation Error"
                                                                           (+ "The content cannot be read: " e.message ".  Please check the source."))
                                                                (= error_state true))))))
                                         (-> root_elem `replaceWith content)
                                         (= root_elem document_view.children.0))))
                               options.content
                               (progn
                                  (defvar tmp (if (is_element? options.content)
                                                  options.content
                                                  (eval options.content)))
                                  (if (and (is_array? options.content)
                                           (== (length options.content) 0))
                                      (= is_fresh true))
                                      
                                  (when (is_element? tmp)
                                     (-> root_elem `replaceWith tmp)
                                     (= root_elem document_view.children.0))))
                            
                            (set_name (cond
                                         (and (is_string? options.name)
                                              (not (== "DOM Editor" options.name))) ;;
                                         options.name
                                         (is_array? options.path)
                                         (last options.path)
                                         else
                                         "Untitled"))
                                          
                            (try
                               (load_rules)
                               (catch Error (e)
                                  (log "Error on load_rules: " e.message)))
                            
                             (attach_event_listener title_span 
                                           `click
                                           (fn (e)
                                              (rename_editor e)))
                            (attach_event_listener root_elem.parentElement
                               `keyup
                               (fn (e) (key_up_event e)))
                            
                            
                            (attach_event_listener root_elem.parentElement
                               `keydown
                               (fn (e)
                                  (key_down_event e)))
                            (if options.read_only
                                (set_read_only true))
                            
                            (attach_event_listener root_elem
                               `click
                               (fn (e)
                                  (let
                                     ((status (point_for e.srcElement)))
                                     (when (eq nil current_point)
                                        (if (is_element? status.element)
                                            (= current_point status)
                                            (= current_point (point_for root_elem))))
                                     (show_attributes e.srcElement))))
                                     
                            (attach_event_listener attributes_title
                               `click
                               (fn (e)
                                  (when (get_attribute e.srcElement `dist)
                                     (go_to_tree_pos (get_attribute e.srcElement `dist)))))
                            
                            (if options.reader_mode
                               (progn 
                                  (set_show_attributes false)
                                  (set_read_only true)
                                  (set_style [["display"  "none"]] show_attributes_button))
                                  
                               (attach_event_listener show_attributes_button
                                  `click
                                  (fn (e)
                                     (set_show_attributes (not (has_class? "juno-button-on" e.srcElement))))))
                          
                            (attach_event_listener content_view
                               `paste
                               (fn (e)
                                  (progc
                                     (setTimeout (fn ()
                                                    (check_for_unhandled_elements root_elem))
                                                 50))))
                            
                            
                            
                            (attach_event_listener attributes_view
                               `focusin
                               (fn (e)
                                  (progn
                                     (handle_event e))))
                            
                            (attach_event_listener add_attribute_button
                               `click
                               (fn (e)
                                  (if displayed_element_for_attributes
                                     (aif (request_user_input "Enter the name of the attribute to add:")
                                          (progn
                                             (defvar target_elem displayed_element_for_attributes)
                                             (notify (+ "setting property: " it " " target_elem.tagName))
                                             (set_prop target_elem it (or (prop target_elem it) ""))
                                             ;(log (pre (pretty_print (element_to_lisp target_elem))))
                                             (= displayed_element_for_attributes nil) ;; reset it so we will refresh
                                             (show_attributes target_elem))
                                          (progn
                                             (notify "Cancelled")))
                                     (notify "No current point!"))))
                               
                            (attach_event_listener delete_element_button
                               `click
                               (fn (e)
                                  (let
                                     ((removal displayed_element_for_attributes))
                                  (when removal
                                     (select_element removal)
                                     (add_class "juno-highlighted" removal)
                                     (aif (request_user_choice "Remove this element?" [(dtext "Yes - Remove it") ])
                                          (progn
                                             (remove_element removal))
                                          (progn
                                              (remove_class "juno-highlighted" removal)
                                             ))))))
                            (attach_event_listener root_elem.parentElement
                               `scroll
                               (fn (e)
                                  (progn
                                     (when (> e.srcElement.scrollTop 0)
                                        (= current_scroll e.srcElement.scrollTop)))))
                                  
                            (attach_event_listener evaluator_span
                                           `click
                                           user_select_evaluator)
                            (init_context_menu)
                            ;(-> document `execCommand `defaultParagraphSeparator true `p)
                            (progc
                               (set_attribute root_elem
                                  `tabindex 0))
                            
                            (set_style [["overflow" "hidden"] [ "height" "calc(100% - 2px);"]] view)
                            (if options.hide_control_bar
                               (-> self `show_control_bar false))
                            
                            (check_for_unhandled_elements root_elem)
                            
                            
                            (setTimeout (fn ()
                                           (progn
                                              (wait_for_display self)
                                              (declare (function setup_drop_file)
                                                       (global setup_drop_file))
                                               (setup_drop_file view
                                                                accept_content)
                                               (show_page_view_attributes)
                                               
                                               (if options.evaluator_id
                                                  (let
                                                     ((count 10)
                                                      (evaluator_control nil))
                                                     (= evaluator_control (get_control_by_id options.evaluator_id))
                                                     (while (and (> count 0)
                                                                 (not evaluator_control))
                                                        (progn
                                                           (sleep 1)
                                                           (dec count)
                                                           (= evaluator_control (get_control_by_id options.evaluator_id))))
                                                     (if evaluator_control
                                                        (set_evaluator_control evaluator_control)
                                                        (notify "Unable to set evalator control for the buffer - id not found")))
                                                  (when *system_repl*
                                                     (set_evaluator_control *system_repl*)))
                                                (if options.show_attributes
                                                  (set_show_attributes true)
                                                  (set_show_attributes false))
                                                (cond
                                                   error_state  ;; unable to initialize - so remove ourselves
                                                   (destroy_control self)
                                                   (and (or options.content
                                                            options.filename)
                                                        (not is_fresh))
                                                   (progn
                                                      (if (> root_elem.children.length 0)
                                                          (progn
                                                             (focus_to root_elem.children.0)
                                                             (collapse_to_start (select_element root_elem.children.0)))
                                                          (progn
                                                             (focus_to root_elem)
                                                             (collapse_to_start (select_element root_elem)))))
                                                   else
                                                   (progn
                                                      (log "dom_editor: initialize: fall_through")
                                                      (select_element starter)))))
                                        100))))))
   {
       control_bar: true
       allow_search: true
       expose: [[`active_rules active_rules]
                [`reload_rules load_rules]
                [`save request_save]
                [`copy_selection copy_selection]
                [`cut_selection cut_selection]
                [`paste_selection paste_selection]
                [`select_all select_all]
                [`on_hide on_hide ]
                [`set_evaluator (fn (new_evaluator)
                                   (when (is_function? new_evaluator)
                                      (set_evaluator new_evaluator)))]
                [`set_evaluator_control set_evaluator_control]
                [`get_evaluator (fn ()
                                   evaluator)]
                [`current_point (fn ()
                                   current_point) ]
                [`editor {
                    focus: (fn ()
                              (console.log "DOM_editor: editor.focus called."))
                    }]
                [`get (fn ()
                         (pretty_print (element_to_lisp root_elem))) ]
                
                [`root_elem (fn ()
                               root_elem) ]
                [`set_read_only  set_read_only]
                [`needs_save? (function ()
                                 is_dirty?)]
                [`on_save_complete (function (event_obj)
                                      (progn
                                         (remove_class "juno-needs-save" title_span)
                                         (= is_dirty? false)))]
                [`get_root_element (fn () root_elem)]]
   })

(defun wait_for_editor (content)
   (if (get_control_by_name "Description Editor")
       (alert_box (dtext "Open Editor")
                  (dtext "There can be only one description editor open at a time."))
       (new Promise
          (fn (resolve reject)
             (let
                ((result nil)
                 (name "Description Editor")
                 (deditor (DOM_editor { rules: [ `*markdown_rules* ] `content: content `name: name })))
                (defglobal $ed_rval nil)
                (place_control `right deditor)
                (while (and (get_control_by_id deditor.options.id)
                            (is_nil? $ed_rval))
                   (progn
                      (sleep 1)))
                (if (get_control_by_id deditor.options.id)
                    (destroy_control deditor))
                (resolve `(+ ,@$ed_rval)))))))


(defun edit_description_text (control)
   (let
      ((ctl (or (and control
                     (== control.type "text_editor"))
                (if (== (prop *last_focus* `type) "text_editor")
                    *last_focus*
                    nil))))
      (if ctl
         (let
            ((pos (-> ctl `get_selection))
             (select_pos nil)
             (parent_pos nil)
             (editor ctl.editor)
             (new_text nil)
             (content nil)
             (thing_we_are_in nil)
             (ok_to_proceed true)
             (error_content (div
                              (dtext "To use the Description Text Editor, the description field must be in one of the following forms:")
                              (br)
                              (code "description: nil")
                              (br)
                              (code "description: (+ \"content\")")))
             (text nil))
            
            (select_to_current_form editor)
            (= select_pos (-> ctl `get_selection))
            (= text (-> ctl `get_selected_text))
            
            (= thing_we_are_in (read_lisp text { suppress_throw_on_error: true } ))
            (cond
               (is_array? thing_we_are_in)
               (progn
                  (= parent_pos (find_last_paren editor select_pos.start))
                  (-> editor.selection `clearSelection)
                  (-> editor.selection `setSelectionAnchor parent_pos.start.row parent_pos.start.column)
                  (-> editor.selection `selectTo parent_pos.end.row (+ parent_pos.end.column 0))
                  (= thing_we_are_in (read_lisp (-> ctl `get_selected_text) { suppress_throw_on_error: true } ))
                  
                  (if (and (prop thing_we_are_in `description)
                           (>= select_pos.start.row parent_pos.start.row)
                           (<= select_pos.end.row parent_pos.end.row)
                           (== (eval (prop thing_we_are_in `description)) (eval (read_lisp text)))
                           )
                      (progn
                          (-> editor.selection `clearSelection)
                          (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                          (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column)))
                      (progn
                         (= ok_to_proceed false)
                         (alert_box (dtext "Edit Description Text")
                                    error_content))))
               (and (is_object? thing_we_are_in)
                    (contains? "description:" (trim (-> editor.session `getLine pos.start.row)))
                    (contains? "description" (keys thing_we_are_in))
                    (== thing_we_are_in.description (quote "=:nil")))
               (progn
                  (-> editor `clearSelection)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  (= select_pos (-> editor.session `getAWordRange pos.start.row pos.end.column))
                  (-> editor.selection `setSelectionAnchor select_pos.start.row select_pos.start.column)
                  (-> editor.selection `selectTo select_pos.end.row (+ select_pos.end.column 0))
                  
                  (= text "")
                  (= select_pos pos))
               else
               (progn
                  (= ok_to_proceed false)
                  (alert_box (dtext "Edit Description Text")
                             error_content)))
            (when ok_to_proceed
               (progc
                  (= content  (unpack_description (or (eval (read_lisp (or text ""))) "Empty") { `edit_mode: true })))
               (-> ctl `set_read_only true)
               (= pos (-> ctl `get_selection))
               (= new_text (wait_for_editor content))
               (-> ctl `set_read_only false)
               ;(log "edit_description_text: new_text: " new_text)
               (when (and new_text
                          (second new_text))
                  (= new_text (pretty_print new_text))
                  
                  (-> (-> editor `getSession) `replace pos new_text)
                  (-> editor `navigateTo pos.end.row pos.end.column)
                  ;; slow it down so we can watch the fitment..
                  (sleep 0.3)
                  (select_to_current_form ctl.editor)
                  (sleep 0.2)
                  (indent_editor_selection  ctl.editor)
                  (sleep 0.1))))
         (alert_box (dtext "Edit Description Text")
                    (dtext "The control being used must be a text editor type."))))
   { 
     `description: (+ "This function provides an ability to edit the description text of a function "
                      "for easier documentation.  When invoked, if not provided with a specific "
                      "text_editor control, will use the *last_focus* control if it is a text editor "
                      "type.   The current cursor position of the editor it is being invoked on will "
                      "be examined, and if it meets certain criteria, the description text will be "
                      "gathered and the description editor pane will pop up providing the user the "
                      "ability to edit the text in a fashion more amenable for writing "
                      "documentation.  <br>Once completed with the description edits, the user can "
                      "press the short cut key for get_as_wordwrap_text (default is bound to Alt-X) or "
                      "select the \"Get As Wordwrap Text\" menu item from the control menu.  This will "
                      "close the editor and place the contents of the description editor into the "
                      "source code in the appropriate position and form. <br>If the contents of the "
                      "description editor are not to be saved back to the text editor, just close the "
                      "editor, either from the menu or by pressing <br>Alt-D<br> (or the command "
                      "currently associated with the Close Control Command).  See (show_key_bindings) "
                      "in the REPL for a table of current globally defined key bindings. <br>#### "
                      "Qualifying formats of the Description Field to be Edited<br>The description "
                      "field must either have a value of nil (empty).  In this case, the description "
                      "editor will be empty of content when opened.  In this case the field entry "
                      "would look like:<br>```{\n   description: nil \n}```<br><br>If the description "
                      "field is already populated with content, it will need to be in the form "
                      "of: <br>```{\n   description: (+ \"Content Line\" \"more content\" "
                      "\"...\")\n}```<br><br>This is the format that the Description editor will place "
                      "into the source code when complete.<br>#### Other Notes<br>When the Description "
                      "Editor is invoked and while the user is editing text, the text_buffer that it "
                      "is being invoked on is placed into read only mode and so cannot be modified "
                      "until the Description Editor is closed. ")

      `usage: ["control:?object"]
      `tags: ["editor" "description" "metadata" "meta" ] })


(defun controls_in_layout (layout non_containers_only?)
   (let
      ((layout (if (is_layout? layout)
                  layout
                  (throw TypeError "controls_in_layout: invalid layout passed")))
       (acc []))
      (if non_containers_only?
         (reduce (control (current_controls true layout))
            (unless (contains? control.type [ "control_container" "split_view_horizontal" "split_view_vertical" ])
               control)) 
         (current_controls true layout)))
   {
     description: (+ "For the given layout, returns the controls that are contained within "
                     "it.  If the `non_containers_only?` argument is set to `true`, then splits and "
                     "control containers will not be included in the results. ")
       usage: ["layout:object" "non_containers_only?:?boolean"]
       tags: ["layouts" "layout" "controls" "ui" "control" ]
       })
      
                                    

(defun hide_others_in_layout (control)
   (if (is_control? control)
       (let
          ((layout (get_layout_for_control control)))
          (cond 
             (== control (control_holding_tank))
             (progn 
                (notify "Hide operation cannot be performed for this control")
                (throw EvalError "Hide operation cannot be performed for this control"))
             (== layout (control_holding_tank))
             (progn
                (notify (dtext "The specified control is in the holding tank"))
                (throw EvalError "hide_others_in_layout: specified control is in the holding tank"))
             (eq nil layout)
             (throw TypeError "hide_others_in_layout: nil layout for provided control")
             (layout_locked? layout)
             (progn 
                (notify (dtext "The layout is currently locked for the control"))
                (throw EvalError "hide_others_in_layout: locked layout"))
             (is_layout? layout)
             (progn
                (unless (== (get_current_layout_control) layout)
                   (switch_to_new_layout (control_name layout)))
                (wait_for_display control)
                (log "hide_others_in_layout: current_controls: " (each (controls_in_layout layout true) control_name))
                (reduce (layout_control (controls_in_layout layout true))
                   (unless (== control layout_control)
                      (log "hide_others_in_layout: hiding: " (control_name layout_control))
                      (hide_control layout_control))))))
       (throw TypeError "hide_others_in_layout: invalid control provided"))
   {
     description: (+ "Given a control to keep, the function removes all other controls from "
                      "the layout if it is unlocked.  If the layout is locked, or the control is in "
                      "the holding_tank an `EvalError` is thrown.<br>If a non control is provided, "
                      "a `TypeError` is thrown.  <br>There is no meaningful return value. ")
     usage: ["control:object"]
     tags: [`layout `controls `layouts `control `ui `hide ]
   })



(defun_sync handle_app_key_down_event (e)
   (progn                              
      (defvar kcode (get_key_code e))
      (when *log_key_events* 
         (log "key_code:" kcode "->" (prop *key_bindings*.active kcode) "event: " e))
      (aif (resolve_path [ `active kcode ]  *key_bindings*)
           (progn
              (handle_event e)
              (try
                 (it e kcode)
                 (catch Error (e)
                    (progn
                       (log_error (+ "Base Catch: (key event)" e.message))
                       (log_error e))))))))
   
(defun handle_app_click_event (e)
  (let
      ((elem e.srcElement)
       (elem_type e.srcElement.tagName)       
       (control_id (get_attribute elem "control_id"))
       (control (if control_id
                  (get_control_by_id control_id)))
       (clayout (get_current_layout_control))
       (parents (each (parents_for_control control) `name)))
      (aif (get_by_id "page-header")
         (for (menu_item (-> it `querySelectorAll ".juno-menu-selected"))
              (when (is_element? menu_item)
                 (remove_class "juno-menu-selected" menu_item))))
    (cond
      (and (has_class? "juno-command-button" elem)
           (== elem_type "BUTTON")           
           control)
      ;; a command button was clicked show the menu for the control
      (let
          ((locked? (current_layout_locked?))
           (control_menu (conj (if (is_function? control.menu_items)
                                 (-> control `menu_items)
                                 [[]])
                               [(if locked?
                                    []
                                    [(dtext "Swap") 
                                     (reduce (other_control (current_controls true))
                                        (if (and (or (== (get_layout_for_control other_control) clayout)
                                                     (== (control_holding_tank) (get_layout_for_control other_control)))
                                                 (not (== other_control control))
                                                 (not (eq nil other_control.name))
                                                 (not (contains? other_control.name parents)))
                                            [other_control.name (fn () (swap_control control other_control)) ]))])
                                (if locked?
                                   []
                                   [(dtext "Hide Others")
                                    (fn ()
                                       (hide_others_in_layout control))])
                                (if locked?
                                   [(dtext "Layout Locked") 
                                    (fn ()
                                           (alert_box (dtext "Layout Locked")
                                                      (div { `style: "line-height: 1.3em;" }
                                                           (dtext "The layout is locked and cannot be modified.")
                                                           " "
                                                           (dtext "To unlock see the Menu")
                                                           ":"
                                                           (pre (dtext "Layout") "->" (dtext "Unlock positions for")
                                                                " "
                                                                (b
                                                                   (control_name (get_current_layout_control)))))))]
                                   [(dtext "Close Panel") 
                                    (fn ()
                                       (hide_control control))])
                                (if locked?
                                   []
                                   [(dtext "Split Vertically")
                                    (fn ()
                                       (split_control `vertical))])
                                (if locked?
                                   []
                                   [(dtext "Split Horizontally")
                                    (fn ()
                                       (split_control `horizontal))])
                                (cond 
                                   locked?
                                   []
                                   (or (and (is_function? control.can_hide?)
                                            (-> control `can_hide?))
                                       (not (has_the_keys? [ `can_hide? ] control)))
                                   [(dtext "Move Control To New Layout")
                                    (fn ()
                                       (move_control_to_new_layout control))])
                                (if locked?
                                   []
                                   ["--" nil])
                                (if locked?
                                   []
                                   [(dtext "Close Panel and Destroy Control")
                                    (fn ()
                                       (destroy_control control))])]))) 
        (make_menu elem control_menu)))))

(defun browser_environments ()
   (if (and is_served?
             (== "localhost" (resolve_path [ `location `hostname ] window)))
      (let
         ((envs (rblock (http/browser_environments true)))
          (chosen_env { env: nil })
          (ctl_panel nil)
          (ctl (dtable
                  (for (env envs)
                       [env.0 env.1 (formatted_date env.2) (ago env.3)])
                  {
                    `columns: ["Name" "Size" "Created" "Last Accessed"]
                    `additional_controls: [(button "Close")]
                    `display_search: true
                    `set_filter_mode: true
                    `controls: true
                    })))
         
         (attach_event_listener ctl.view
            `click
            (fn (e)
               (cond
                  (== "TD" e.srcElement.tagName)
                  (progn
                     (set_prop chosen_env
                        `env e.srcElement.parentElement.children.0.innerText)
                     (notify (+ "Opening: " chosen_env.env))
                     (eval `(rblock (http/open_browser ,#chosen_env)))
                     (destroy_control ctl_panel)))))
         (= ctl_panel (panel "Available Environments" ctl.view))
         (attach_event_listener ctl_panel.view
            `keydown
            (fn (e)
               (progn
                  (handle_event e)
                  (when (== 27 e.keyCode)
                     (destroy_control ctl_panel)))))
         (place_control `below
                        ctl_panel))
      (alert_box "The browser_environments command is only available when running in a locally served mode."
                 "The value is_served? must be true and the window.location.hostname must be localhost."))
   {
     description: (+ "<br><br>The `browser_environments` function opens a control that allows for the "
                     "user to select an available browser environment and opens a browser window for "
                     "that environment.<br>When the user selects a environment, or presses escape, "
                     "the panel will close. ")
     tags: ["browser" "environments" "seedling" "ui" "beta"]
     usage: []
     })
                                                
(defun app_menu (global_menu_path options)
  (let
      ((view nil)
       (options (either options {}))
       (top_levels [])
       (menu_trees (resolve_path global_menu_path Environment.global_ctx.scope))
       (sticky_items (each menu_trees `0))
       (id (or options.id (generate_id "app_menu")))
       (intf {})
       (menu_trees (or menu_trees []))
       (compute_top_levels (fn ()
                             (progn
                                (defvar headers (each menu_trees `0))
                                (defvar last_focus_name (resolve_path  [ `options `name ] *last_focus*))
                                (= headers (uniq
                                                 (reduce (header_text headers)
                                                    (if (or (contains? header_text sticky_items)
                                                            (and *last_focus* 
                                                               (== last_focus_name  header_text)))
                                                        header_text))))
                                ;(log "compute_top_levels: " (clone headers))
                                ; (if (== nil (get_control_by_name (last headers)))
                                    ;(pop headers))
                                headers)))
       (help_idx nil)
       (add_menu (fn (menu)
                   (let
                       ((existing_idx (index_of menu.0 top_levels)))
                     (if (== existing_idx -1)
                       (push menu_trees
                             menu)
                       (-> menu_trees `splice existing_idx 1 menu))
                     (set_path global_menu_path Environment.context.scope menu_trees)
                     (build_view))))
       (remove_menu (fn (menu_text)
                      (let
                          ((existing_idx (index_of menu_text top_levels)))                           
                        (when (and (> existing_idx -1)
                                   (prop view.children existing_idx))
                          (-> (prop view.children existing_idx)
                              `remove)
                          (-> menu_trees `splice existing_idx 1))
                        (set_path global_menu_path Environment.context.scope menu_trees))))
       (show_sub_menu (fn (e)
                         (let
                            ((idx (-> e.srcElement `getAttribute `idx))
                             (menu_header (if (== e.srcElement.tagName "SPAN")
                                              e.srcElement.parentElement
                                              e.srcElement))
                             (pos (-> menu_header `getBoundingClientRect))
                             (help_menu_function nil)
                             (on_select (fn ()
                                           (when menu_header
                                              (remove_class "juno-menu-selected" menu_header))))
                             (mview nil)
                             (menu nil))
                            (aif (get_by_id "cmenu")
                                 (-> it `remove))
                            (remove_class "juno-menu-selected" menu_header)
                            (when idx
                               (add_class "juno-menu-selected" menu_header)
                               (if (== (parseInt idx) help_idx)
                                   (= help_menu_function *help_menu_function*)
                                   (= help_menu_function nil))
                               (console.log "app_menu: clicked: " idx "help_idx: " help_idx (prop menu_trees (parseInt idx)))
                               (aif (or help_menu_function
                                        (resolve_path [ (parseInt idx) 1 ] menu_trees))
                                    (progn
                                       (cond
                                          help_menu_function
                                          (= menu (menu_tree (it) { `on_select: on_select } ))
                                          (is_function? it)
                                          ;; if the underlying menu is a function, call the function to get..
                                          ;; up to the minute menu contents
                                          (= menu (menu_tree (it (first (prop menu_trees (parseInt idx)))) { `on_select: on_select } ))
                                          ;; other wise it is a standard menu, which may not rehydrate well depending
                                          ;; on how it was created..
                                          else
                                          (= menu (menu_tree it { `on_select: on_select } )))
                                       (= mview (div { `id: `cmenu `class: "juno-menu" `style: " z-index: 30" }
                                                     menu.view))
                                       (set_style [["position" "absolute"]
                                                   ["left" (+ "" (Math.max 0 pos.left 0) "px")]
                                                   ["top" (+ "" (Math.max 0 pos.bottom ) "px") ]]
                                                  mview)
                                       (-> (get_by_id "body") `appendChild
                                           mview))
                                    (progn
                                       (remove_class "juno-menu-selected" menu_header)
                                       (notify "Unable to find menu resource")))))))
       (build_view (fn ()
                       (let
                           ((new_view nil)
                            (header_elem nil))
                         (= top_levels (compute_top_levels))
                         (unless options.disable_help
                                 (push top_levels
                                       "Help")
                                 (= help_idx (- (length top_levels) 1)))
                         
                         (= new_view
                            (ul { `id: id `class: "pure-menu-list" `style: "margin-left: 10px" }
                                (if (> top_levels.length 0)
                                  (map (fn (top_level idx)
                                         (li { `idx: idx  `class: "juno-menu-header juno-main-menu-header" }
                                             (span { `idx: idx `class: "juno-menu-item" } (dtext top_level))))
                                       top_levels)
                                  [])))
                         (map (fn (child)
                                 (progn
                                    (attach_event_listener child
                                       `mouseenter
                                       (fn (e)
                                          (progn
                                             (when (get_by_id "cmenu") ;; if the menu is already showing show the new menu, otherwise don't do anything
                                                (remove_class "juno-menu-selected" new_view.children)
                                                (show_sub_menu e)))))
                                    (attach_event_listener child
                                       `mouseleave
                                       (fn (e)
                                          true))))
                              new_view.children)
                         (attach_event_listener new_view
                                                `click
                                                show_sub_menu)
                                                                        
                         
                         (if view.parentElement
                           (-> view `replaceWith new_view))
                         (= view new_view)
                         view))))
    
    
    (build_view)
    (set_prop options
              `id
              id)
    (set_prop intf
              `view view
              `add_menu add_menu
              `remove_menu remove_menu
              `type "app_menu"
              `toJSON (function ()
                                `(app_menu ,#global_menu_path ,#options)))
    (setq *app_menu_control* intf)
    intf))



(defun app_header (controls options)
  (let
      ((existing_header (-> document `querySelector "header"))
       (intf nil))
    (when (eq existing_header nil)
      (-> (first (get_by_tag "body"))
          `prepend
          (= existing_header (header { `id: "page-header" class: "juno-page-header" }))))
    (when options.app_title
      (-> existing_header `appendChild (span { `class: "juno-header" } options.app_title)))
    (for_each (`elem controls)
              (progn
               (cond
                 elem.view
                 (-> existing_header `appendChild elem.view)
                 (is_element? elem)
                 (-> existing_header `appendChild elem)
                 else
                 (create_dom_element "span" elem))))
    ;(-> existing_header `appendChild (span { `style: "float: right; ")
    (set_prop options
              `id
              (or options.id "app-header"))
   
    (= intf
       {     
        `options: options
        `controls: controls
        `type: "app_header"
        `toJSON: (function ()
                           `(app_header ,#controls ,#options))
        })
    
    intf))




(defun build_starter_environment (opts)
  (if is_served?
    (let
       ((remote_connection nil)
        (remote_id nil)
        (server_platform nil)
        (kickstart_result nil)
        (opt (or opts {})))
       (log "Building Starter Environment..")
       (sleep 0.1)
       (try
          (= remote_connection (create_remote_evaluator))
          (catch Error (e)
             (progn
                (alert_box (dtext "Error")
                           (dtext "The system cannot establish a control connection to the host.")))))
       (if (eq nil remote_connection)
           (return nil))
       (unless (-> remote_connection `open?)
          (progn
             (alert_box (dtext "Error")
                        (dtext "Unable to establish a control connection: connection is closed."))
             (return nil)))
       
       ;; validate the environment..
       (= server_platform (-> remote_connection `evaluate (as_lisp `(operating_system))))
       (log "Build Environment is: " server_platform)
       (if (== server_platform "windows")
           (= kickstart_result (-> remote_connection `evaluate (as_lisp `(sys/system "powershell.exe ./scripts/build_browser_env.ps1"))))
           (= kickstart_result (-> remote_connection `evaluate (as_lisp `(sys/system "./scripts/build_browser_env.sh")))))
       (when kickstart_result.success
          (for_each (v (split_by "\n" kickstart_result.stdout))
             (log v))
          (log "Wrote the generator..starting build")
          (log "Removing temporary environment: " (-> remote_connection `evaluate "(undefine `*export_env*)"))
          (-> remote_connection `close)
          (log "Closed remote connection")
          (log "building starter environment")
          (= *build_window* 
             (floating_div (iframe { width: 500 height: 300
                                     `style: "width: calc(100% - 5px); min-height: 500px; min-width: 500px; overflow: auto; height:calc(100% - 5px); border: 0px solid transparent;"
                                     src: (+ "/env/starter.html?theme=" (resolve_path [ `application `global_theme ] *env_config*))} )
                           { controls: true } ))))))

(defun rebuild_remote_environment ()
  (if is_served?
    (let
       ((remote_connection nil)
        (remote_id nil)
        (server_platform nil)
        (results (pre { }))
        
        (kickstart_result nil))
       (log "Building remote environment..This may take a few moments.")
       
       (notify "Logging build messages to the System REPL")
       (sleep 0.1)
       (try
          (= remote_connection (create_remote_evaluator))
          (catch Error (e)
             (progn
                (alert_box (dtext "Error")
                           (dtext "The system cannot establish a control connection to the host.")))))
       (if (eq nil remote_connection)
           (return nil))
       (unless (-> remote_connection `open?)
          (progn
             (alert_box (dtext "Error")
                        (dtext "Unable to establish a control connection: connection is closed."))
             (return nil)))
       (= server_platform (-> remote_connection `evaluate (as_lisp `(operating_system))))
       (log "Build Environment is: " server_platform)
       ;; validate the environment..
       (if (== server_platform "windows")
           (= kickstart_result (-> remote_connection `evaluate (as_lisp `(sys/system "powershell.exe ./scripts/rebuild_env.ps1"))))
           (= kickstart_result (-> remote_connection `evaluate (as_lisp `(sys/system "./scripts/rebuild_env.sh")))))
       (notify "Remote build completed - check System REPL output")
       (when kickstart_result.success
          (for_each (v (split_by "\n" kickstart_result.stdout))
             (progn (-> results `append v)
                (-> results `append (br))))
          (log results)
          true))))
    


(defun controls_by_parent ()
    (let
        ((acc [])
         (current { `root: [] })
         (found_control {})
         (control_identity (fn (control)
                                 (and control
                                      (or control.name
                                          control.options.id
                                          "Untitled"))))
         (collect_control (fn (control parent)
                              (when (and control.options.id 
                                         (not (prop found_control control.options.id)))
                                 (when (and parent
                                            (not control.name))
                                     (cond
                                         parent.name
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.name "-" control.type))
                                         parent.type
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.type "-" control.type))))
                                 (cond
                                     (and parent
                                          (not (prop current (control_identity parent))))
                                     (set_prop current 
                                               (control_identity parent)
                                               [ control ])
                                     (and parent
                                          (prop current (control_identity parent)))
                                     (push (prop current (control_identity parent))
                                               control)
                                     (eq nil parent)
                                     (push (prop current `root)
                                               control))
                                 (set_prop found_control
                                           control.options.id
                                           control)))))
        (for_each (controls (or $root_controls []))
           (control_tree controls collect_control))
        current))

(defun all_global_controls (namespace)
   (let
      ((env_handle (if namespace 
                       (-> Environment `get_namespace_handle namespace)
                       nil)))
      (if namespace
          (reduce (pset (pairs env_handle.context.scope))
             (destructuring_bind (symbol_name symbol_value)
                pset
                (if (is_control? symbol_value)
                    symbol_name)))
          (flatten (for_each (namespace (namespaces))
                      (for_each (ctl (all_global_controls namespace))
                         (+ namespace "/" ctl))))))
   {
     `description: (+ "Returns all controls in the global context.  If provided " 
                      "with a namespace, it will return only the controls for "
                      "that namespace, otherwise it will return all controls "
                      "in every namespace in a fully qualified form.")
     `usage: ["namespace:?string"]
     `tags: [`controls `ui `global]
     })


(defun symbols_for_controls (target_controls options)
   (let
      ((target_controls (if (is_array? target_controls)
                            target_controls
                            [ target_controls ]))
       (namespace (or options.namespace (current_namespace)))
       (ctl_symbol_data [])
       (sub_ctls nil)
       (results nil)
       (initializer_symbol (cond 
                              (and (is_string? options.initializer_symbol)
                                   (is_function? (get_global options.initializer_symbol)))
                              options.initializer_symbol
                              options.initializer_symbol
                              (throw TypeError "symbols_for_controls: option initializer_symbol must be a string"))))
      
      (for_each (ctl target_controls)
         (progn
            (= sub_ctls (current_controls false target_controls))
            (for_each (sctl (or sub_ctls []))
               (unless (contains? sctl target_controls)
                  (push target_controls sctl)))))
      
      (log "symbols_for_controls: target_controls: " target_controls)
      (log "symbols_for_controls: initializer_symbol: " initializer_symbol options)
      (for_each (`ctl target_controls)
         (assert (is_control? ctl`) "symbols_for_control: non control provided in target_controls argument"))
      ;; make a temp symbol that will represent the root
      ;; find the control definition
      (for_each (`ctl target_controls)
         (for_each (desc (describe ctl.type true))
            (when (== desc.namespace namespace)
               (push ctl_symbol_data desc)
               (break))))
      (= results
         (symbol_dependencies (conj (each ctl_symbol_data `name)
                                    (if initializer_symbol
                                       [ initializer_symbol ]
                                       [] ))))
      (when results
         (for_each (t target_controls)
            (push results.dependencies
               t.type)))
      (when (and results
                 initializer_symbol)
         (push results.dependencies
            initializer_symbol))
      results))

(defun shake_tree (root_control options)
   (let
      ((root_control root_control)
       (root_and_children (if (is_control? root_control)
                              (current_controls false root_control)
                              (throw EvalError "shake_tree: invalid root_control")))
       
       (symbol_data (and (is_control? root_control)
                         (symbols_for_controls root_control options)))
       (export_order {
                       `symbols: []
                       `namespaces: []
                       `do_not_include: []
                       })
       (req_namespaces (new Set))
       (env nil)
       (sdata nil)
       (dependency_data (sort_dependencies)))
      (assert (is_object? symbol_data) "shake_tree: first argument must be a control object")
      (for_each (qualified_symbol dependency_data.symbols)
         (destructuring_bind (ns symbol)
            (split_by "/" qualified_symbol)
            (= env (-> Environment `get_namespace_handle ns))
            (= sdata nil)
            (when (and ns (not (== ns "EXTERNAL")))
               (try
                  (= sdata (-> env `eval `(describe ,#symbol)))
                  (catch Error (e)
                     (log "shake_tree: " ns " cannot describe symbol:" symbol e))))
            (when sdata
               (if (or (== ns "html")
                       (== "Special" sdata.type)
                       (contains? symbol symbol_data.dependencies))
                   (progn
                      (push export_order.symbols
                         qualified_symbol)
                      (when (not (-> req_namespaces `has ns))
                         (-> req_namespaces `add ns)
                         (push export_order.namespaces
                            ns)))
                   (progn
                      (push export_order.do_not_include
                         qualified_symbol))))))
      
      export_order))

(defun serialize_controls (controls options)
  (let
     ((serialized_layout [(quote quote) (JSON.parse (JSON.stringify controls))]))
     (log "serialize_controls: options: " options)
     (unless options.keep_text_editor_content
        (traverse serialized_layout
                   (fn (val path)
                      (progn
                         (when (and (is_object? val)
                                    (prop val "content_compressed"))
                            (delete_prop val "content_compressed"))))))
     serialized_layout)
  {
    `description: (+ "Given an array of controls, serializes their state to JSON form such "
                     "that their state can be stored.<br>As an example, given the current "
                     "`$root_controls` array, will produce a JSON form:```(serialize_controls "
                     "$root_controls)```<br><br>The returned structure can then be rehydrated using "
                     "the `rehydrate_controls` function.<br><br> ")
    `usage: ["controls:array"]
    `tags: ["controls" "storage" "serialize" "serialization" "dehydration" "save" "state" "application"]
  })



(defun save_control_image (validate_name? options)
  (let
     ((options (if (is_object? options)
                   options
                   {}))
      (root (if (is_array? options.root_controls)
                options.root_controls
                $root_controls))
      (root_controls $root_controls) ;; capture the root controls 
      (current_control $current_control)
      (save_as_name (or options.save_prefix
                        *env_config*.export.save_prefix))
      (system_repl *system_repl*)
      (orig_initializer *initializer*)
      (initializer (cond 
                      (and (is_string? options.initializer_symbol)
                           (is_function? (get_global options.initializer_symbol nil)))
                      (get_global options.initializer_symbol)
                      (is_string? options.initializer_symbol)
                      (throw TypeError "save_control_image: initializer_symbol option must be a symbol to a global function")
                      else
                      nil))
      (export_details {
                        do_not_include: (new Set)
                        namespaces: (new Set)
                        symbols: (new Set)
                        })
      (exp nil))
     (when validate_name?
        (aif (request_user_input (+ (dtext "Enter a name for the saved image.")
                                    " "
                                    (dtext "The file will be saved with this prefix and an .html extension."))
                                 `text
                                 { `default_value: save_as_name })
                (= save_as_name it)
                (= save_as_name nil)))
     (when (blank? save_as_name)
        (notify (dtext "Cancelled Save Operation"))
        (return 0))
     (= save_as_name (to_key save_as_name))
     
     
     (when options.shake_tree
        (for_each (ctl root)
           (progn
              (log "save_control_image: evaluating control dependencies for: " ctl.type)
              (= exp (shake_tree ctl options))
              (for_each (sym exp.symbols)
                 (-> export_details.symbols `add sym))
              (for_each (ns exp.namespaces)
                 (-> export_details.namespaces `add ns))))
        ;; now add the do not includes - but only if there is no symbol dependencies do not contain it
        (for_each (ctl root)
           (progn
              (for_each (dni exp.do_not_include)
                 (unless (-> export_details.symbols `has dni)
                    (-> export_details.do_not_include `add dni)))))
        ;; there are some special functions that we need to include
        ;; *initializer* is the initialization routine that isn't a dependency for the control since it calls the control
        ;; user/keyword_mapper - this is a special 'hoisted' function that get moved up to core and exposed for the 
        ;; Ace editor modes that are calling into the environment
        
        (for_each (`entries [ "user/*initializer*" "user/keyword_mapper" ] )
           (-> export_details.do_not_include `delete entries))
        (set_prop export_details
           `do_not_include (to_array export_details.do_not_include)
           `namespaces (to_array export_details.namespaces)
           `symbols (to_array export_details.symbols))
        
        (set_prop options
           `do_not_include export_details.do_not_include))
     ;; do we have an initializer to use?
     (when initializer
        (log "save_control_image: using initializer: " options.initializer_symbol initializer)
        (= *initializer* initializer))
     
     (log (+ "save_control_image: saving application state to: " save_as_name))
     (log "save_control_image: export_details: " export_details)
     (try
        (progn
           (set_focus_to nil)
           
           (defvar results nil)
           (= *serialized_controls* (serialize_controls root options))
           ;(log "save_control_image: " *serialized_controls*)
           
           (for_each (ctl root)
              (log "save_control_image: serializing: " (or (control_name ctl) ctl.type)))
           (= *system_repl* nil)
           ;[(quote quote) [(quote quote) (JSON.parse (JSON.stringify $root_controls))]])
           (console.log "*serialized_controls*: " *serialized_controls*)
           (= results (save_image (+ { `save_as: save_as_name } options)))
           (= *system_repl* system_repl)
           (when (is_function? initializer)
              (= *initializer* orig_initializer))
           ;(defglobal core/$root_controls root_controls)
           ;(defglobal core/$current_control current_control)
           (log (+ "save_control_image: result: ") results)
           (log (+ "save_control_image: " (dtext "Complete")))
           (when (and is_served? options.open_new_image)
              (-> window `open (+ "/env/" save_as_name ".html") save_as_name))
           results)
        (catch Error (e)
           (progn
              (= *system_repl* system_repl)
               (when (is_function? initializer)
                  (= *initializer* orig_initializer))
              (log "Error during save: " e.message)
              (if validate_name?
                 (alert_box "Save Image Problem" e.message))
              (console.error "Cannot save image: " e)
              (log_error "ERROR on save: " e.message))))))
             
    

(defun rehydrate_controls (container serialized_controls)
   (let
      ((control nil)
       (lhc (get_layout_holding_cell)))
      (assert lhc "cannot find the layout holding cell: this is an error/bug")
      (console.log "rehydrate_controls: serialized_controls: " serialized_controls)
      (for_each (`serialized_control serialized_controls)
         (progn
            (= control (eval serialized_control))
            (console.log "rehydrate_controls: rehydrating: " control.options "control has parent: " control.view.parentElement)
            (cond
               (and control.view
                  (not control.view.parentElement)
                  (or (== control.type "app_header")
                      (== control.options.root_frame true)))
               (progn
                  (-> container
                     `append control.view)
                  (console.log "rehydrate_controls: appended control " control.options.name " to displayed container"))
               (and control.view
                  (not (blank? control.options.last_focus_id)))
               (progn
                  (-> lhc `append control.view)
                  (console.log "rehydrate_controls: appended control " control.options.name " to layout holding cell")))
            (push $root_controls
               control)
            (when control.initialize
               (-> control `initialize)))))
   {
     description: (+ "<br>Given a DOM element and a JSON structure of serialized controls as produced "
                     "through the `serialize_controls` function, this function will instantiate them "
                     "from their saved state into the DOM structure. ")
     usage: ["conainer:Element" "serialize_controls:array"]
     tags:  ["controls" "storage" "serialize" "serialization" "rehydration" "restore" "state" "application"]
     })

(defun layout_initializer ()
   (let
      ((key_mode (get_operating_platform)))
    (defvalue $root_controls [])
    ;; the root container which controls are added to..
    (defglobal juno_container
      (div { `id: "juno_container" `style: "height: inherit; width: inherit; position: relative; overflow:hidden;" }))
   (attach_event_listener juno_container `click
                           (fn (e)
                             (progn
                              (defvar menu (get_by_id `cmenu))
                              (when menu (-> menu `remove)))))
    (set_prop *env_config*.export
	      `save_path
	      nil)
    (attach_event_listener juno_container
                           `focusin
                           (fn (e)
                             (process_focus_chain e)))
    (-> (get_by_id "body") `appendChild juno_container)
    (rehydrate_controls juno_container *serialized_controls*)
    (sleep 0.1)
    (default_focus)
    ;; setup key bindings
    (set_prop *key_bindings*
              `active
              {})  ;; reset out and copy
    (for_each (desc (values (prop *key_bindings* `global)))
       (progn
          (for_each (key_combo (split_by "|" (prop desc key_mode)))
             (set_prop *key_bindings*.active
                key_combo
                (prop desc `exec)))))

     (attach_event_listener juno_container
                           `click
                           (fn (e)
                             (handle_app_click_event e)))
    
    (attach_event_listener (first (get_by_tag `body))
                           `keydown
                           (function (e)
                             (progn                              
                              (defvar kcode (get_key_code e))
                              (when *log_key_events* (log "key_code:" kcode "->" (prop *key_bindings*.active kcode)))
                              ;(console.log "kcode is: " kcode)
                              (aif (prop *key_bindings*.active kcode)
                                   (progn
                                    (handle_event e)
                                    (try 
                                       (it)
                                       (catch Error (e)
                                          (progn
                                             (log_error (+ "Base Catch: " e.message))
                                             (log_error e))))))
                              )))
    
    (attach_event_listener document
       `blur
       (fn (event)
          (progn
             (setq *document_focused* false)
             (dispatch_event { command: "blur"
                               source: "document"
                               args: [ ] }))))
    (attach_event_listener document
       `focus
       (fn (event)
          (progn
             (setq *document_focused* true)
             (dispatch_event { command: "focus"
                               source: "document"
                               args: [ ] }))))))


(defun_sync to_indent (str)
    (join "" (for_each (c (range str.length))
                       " ")))

           
(defun_sync juno_format_handler (line tab base_indent)
   "")  ;; we let the control take care of this since it has better visibility to prior lines



(defun jump_to_frame_0 ()
   (aif (frame_0)
        (switch_to_new_layout it.name)
        (alert_box (dtext "Layout Error")
                   (dtext "Frame 0 cannot be found, check to make sure it exists"))))

(defun new_buffer (options)
   (let
      ((options  (cond
                    (is_array? options)
                    { `path: options `mode: "juno"}
                    (is_object? options)
                    (+ (if options.filename
                           {}
                           { `mode: (or options.type `juno) })
                       options)  ;; if options has mode specified and we don't have a filename, it will override the default juno mode
                    (is_string? options)
                    { `path: [ options ] `mode: "juno" }
                    else
                    { `mode: "juno" }))
       (starting_layout (get_current_layout_control))
       (target_layout (jump_to_unlocked_layout))
       (target_container nil)
       (new_control nil)
       (symbol_data (cond 
                       options.path
                       { `path: options.path `namespace: (or options.namespace (current_namespace)) }
                       (and (is_string? options.content)
                            (not options.filename))
                       nil
                       else
                       (symbol_chooser "Select a symbol to edit" options.mode)))
       (extension (cond
                     options.mode
                     options.mode
                     options.filename
                     (last (split_by "." options.filename))
                     ;(== options.mode "dom")
                     ;"dom"
                     else
                     "juno"))
       (target_ns symbol_data.namespace)
       (current_layout (get_current_layout_control))
       (target_env nil))
      
      
      (if (and (eq nil symbol_data)
               (eq nil options.path)
               (eq nil options.filename)
               (eq nil options.content))
          (console.log "Selection cancelled")
          (progn
             (= target_container (or (and (== starting_layout target_layout)
                                          options.control_to_replace  ;; first check easy thing
                                          (== current_layout (get_current_layout_control)) ;; then the hard thing
                                          options.control_to_replace) ;; then return the control to replace
                                     (and target_layout.options.last_focus_id
                                        (get_control_by_id target_layout.options.last_focus_id))
                                     *last_focus*
                                     (default_focus)))
             
             ;(log "new_buffer: target_container: " target_container.name (prop (get_current_layout_control) `name))
             (when target_ns
                (= target_env (-> Environment `get_namespace_handle symbol_data.namespace)))
             (when (and target_env (eq nil (resolve_path symbol_data.path target_env.global_ctx.scope)))
                (make_path symbol_data.path target_env.global_ctx.scope ""))
             (= new_control
                (if (== extension `dom)
                    (DOM_editor (+ { rules: [ `*markdown_rules* ]
                                           hide_control_bar: false
                                           debug: false }
                                   options))
                    (text_editor (+ { name: (if symbol_data.path
                                                (last symbol_data.path)
                                                nil)
                                           namespace: target_ns
                                           path_namespace: target_ns
                                           path: symbol_data.path
                                           mode: options.mode }
                                    options ))
                    ))
             (cond
                (is_top_control? target_container)
                (container_view_operation "split_right"
                                          (first (-> target_container `controls))
                                          new_control)
                else
                (progn
                   (swap_control target_container
                                 new_control)))
             (sleep 0.1)
             (set_focus_to new_control))))
   {
     `description: (+ "Opens a new editor, if possible, in the currently focused control.  If necessary, it may "
                      "split the view to the right for the new editor.  If no options are provided, the user "
                      "will be prompted for a symbol to edit.  Options can be: <br>"
                      "string: is considered a symbol name and the function will open or create the "
                      "specified symbol in the current namespace global context.<br>"
                      "array: is considered a path to access, and if the path is present will open the path.  If not, "
                      "will attempt to create the final value in the path as a string for editing.<br>"
                      "object: if an object, the object can contain:<br>"
                      "  path: array: the path to the symbol to be edited.  If the final path segment doesn't exist "
                      "it will create it.<br>"
                      "  namespace: string: the namespace to use for accessing the provided path.<br>"
                      "  mode: the mode to open the editor in. The default mode is Juno.<br>")
     `tags: ["editor" "edit" "buffer" "control"]
     `usage: ["options:object?"]
     })

(defun new_top_level_frame ()
   (let
      ((ctl (empty_selection_control))
       (new_frame (control_container ctl { `root_frame: true } )))
      (push $root_controls
         new_frame)
      (if (> (length (-> (control_holding_tank) `controls)) 0)
          (swap_control ctl (last (-> (control_holding_tank) `controls))))))

(defun new_juno_repl (options)
   (let
      ((name (compute_name_for_control "Juno REPL"))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (remote_repl (if (is_string? options.remote_repl)
                        options.remote_repl)))
      (alert_on_error "REPL Error"
                      (cond
                         (is_top_control? target_container)
                         (container_view_operation "split_right" (first (-> target_container `controls)) (visual_repl { `name: name `remote_repl: remote_repl }))
                         else
                         (swap_control target_container (visual_repl { `name: name `remote_repl: remote_repl })))))
   {
       usage: ["options:?object"]
       description: (+ "Creates a new REPL in the current frame.  If provided with a `control_to_replace "
                       "in options, it will replace that control with the new REPL, with the replaced control "
                       "being put in the holding tank if the replaced control is allowed."
                       "If no target is provided, the function will split the top frame, replacing the " 
                       "currently focused control.")
       tags: [ "REPL" "create" "new" "control"]
   })
 
(defun rename_control (old_name new_name)
   (cond 
      (is_string? old_name)
      (aif (get_control_by_name old_name)
            (if (is_function? it.rename)
                (-> it `rename new_name)
                (throw EvalError (+ "Control " old_name " doesn't have a rename method"))))
      (is_control? old_name)
      (if (-> old_name `rename)
          (-> old_name `rename new_name)
          (throw EvalError (+ "Control " old_name.options.name " doesn't have a rename method"))))
   {
       `description: (+ "Given a control or a name of a control, and a new name, " 
                        "renames the given control to the new name.  If the control "
                        "cannot be renamed, will throw an EvalError indicating that "
                        "it couldn't be renamed.")
       `usage: ["old:string|object" "new_name:string"]
       `tags: [`controls `name `rename `control `id ]
   })  

(defun wait_for_file_selection (create_mode) 
   (new Promise (fn (resolve reject)
                   (let
                       ((selection nil)
                        ;; get the current layout if the user cancels the open
                        ;; then we can switch back to where they were..
                        (current_layout (get_current_layout_control))
                        (current_control  *last_focus*)
                        (env_details (aif (http/get "/base_directory")
                                          (and it.rval
                                             (== it.rval "OK")
                                             (prop it `data))))
                        (base_directory (cond 
                                           (and current_control.options.path
                                                (== (first current_control.options.path) "filesystem")
                                                env_details.base
                                                (== env_details.base "/"))
                                           (+ "/" (join "/" (chop (rest current_control.options.path))))
                                           else
                                           nil))
                        (locked_state (layout_locked? current_layout))
                        (f0 (frame_0))
                        (target_layout  f0)
                        (target_control (or (get_control_by_id target_layout.options.last_focus_id) *last_focus* (default_focus)))
                        (control (file_tree_browser { 
                                                      create_mode: create_mode 
                                                      base_directory: base_directory
                                                      on_select: (fn (stack)
                                                                    (progn
                                                                     (= selection (join "/" stack))
                                                                     (if (> stack.length 0)
                                                                       (progn
                                                                          (destroy_control control)))))
                                                                        
                                                     on_destroy: (fn (self)
                                                                    (progn
                                                                       (console.log "wait_for_file_selection: selection is: " selection)
                                                                       (when (and (not (== current_layout f0))
                                                                                  (blank? selection))
                                                                          (switch_to_new_layout (resolve_path [ `options `name ] current_layout)))
                                                                       (if (not (blank? selection))
                                                                           (setTimeout (fn ()
                                                                                          (progn
                                                                                             (sleep 0.05)
                                                                                             (console.log "wait_for_file_selection: " target_layout.name ": target_control:" target_control)
                                                                                             (set_focus_to target_control)
                                                                                             (resolve selection))
                                                                                          20))
                                                                           (setTimeout (fn ()
                                                                                          (progn
                                                                                             (set_focus_to current_control)))
                                                                                       100))
                                                                       true)) })))
                       ;; if the layout is locked, remove the lock temporarily so we can pop open a selector
                     (console.log "wait_for_file_selection: locked_state: " locked_state "target_layout: " target_layout target_control)  
                     
                     (switch_to_new_layout (resolve_path [ `options `name ] f0))
                     (place_control `below control)
                     (set_focus_to control))))
   {
       `description: (+ "Opens a file tree browser for selection of a file.  Once the a " 
                        "file is chosen, or the selection is cancelled via escape, then either "
                        "the selected path is returned, or nil if cancelled or closed.<br>If "
                        "the create_mode flag is true, the behavior is modified in the "
                        "selection control where path completions aren't automatically "
                        "used, instead the user must press tab to complete the selection. "
                        "This allows for the user to select a file that may not be "
                        "present on the filesystem for purposes of creation.  By default the "
                        "create_mode flag is set to false.")
       `usage:["create_mode:?boolean"]
       `tags: ["UI" "DOM" "file" "editor" "select" "open"]
   })


(defun file_status (file_path)
   (if (is_string? file_path)
       (let
          ((comps (split_by "/" file_path))
           (fname (pop comps))
           (parent_path (progn
                           (defvar tmp (join "/" comps))
                           (if (blank? tmp)
                               "/"
                               tmp)))
           (results (http/list_files parent_path)))
         (or (first (reduce (r results)
                       (if (== r.name fname)
                           r)))
             nil))
       (throw TypeError "file_status: requires a file_path argument as a string"))
   {
     `description: "Given a path to a file, if the file exists, returns the details, otherwise nil."
     usage: ["file_path:string"]
     tags: ["io" "file" "status" "exist"]
     })
          

(defun edit_file (options)
   (let
      ((options (cond 
                   (and (is_object? options)
                        options.filename)
                   options
                   (and (is_object? options)
                        options.create_mode)
                   (+ {} 
                      options
                      { filename: (wait_for_file_selection true) })
                   else
                    (progn
                       {
                           filename: (wait_for_file_selection)
                       })))
       (symbol_path (cond
                       (is_array? options.path)
                       options.path
                       (is_string? options.filename)
                       (conj ["filesystem"] (split_by "/" options.filename))))
       (rval nil)
       (data_to_save (or options.initial_data ""))
       (acc []))
      (if (eq options.filename nil)
          (return nil))
      (assert (and symbol_path options.filename) "Invalid options to edit_file")
      
      ;; if we are given a create mode, make the shell of a file
      (if (and options.create_mode
               (> (length data_to_save) 0) )
         (try
            (progn
               (= rval (http/send_files "/save_file" (http/data_to_file options.filename data_to_save "text/plain")))
               (if (and rval
                        (== rval.rval "OK"))
                   (log "Created empty file: " options.filename)
                   (throw Error rval.message)))
            (catch Error (e)
               (progn
                  (alert_box (dtext "Unable to Create File")
                             (+ "" options.filename ": "
                                e.message))
                  (set_prop options
                             `filename
                             nil)))))
            
      (if (eq options.filename nil)
          (return nil))
      
      (if (and (starts_with? "filesystem" symbol_path)
               (eq nil (resolve_path symbol_path Environment.global_ctx.scope)))
          (progn
             (for_each (comp (chop symbol_path))
                (progn
                   (push acc comp)
                   (set_path acc Environment.global_ctx.scope {})))
             (push acc (last symbol_path))
             (set_path acc Environment.global_ctx.scope "")))
      (set_prop options
         `path
         symbol_path)
      (alert_on_error "File Open Error"
         (new_buffer options)))
   {
       `description: (+ "If provided an options object with a filename key and file path value, "
                        "the function will attempt to fetch and present that file for editing. "
                        "If an error is encountered, the error will be presented to the user "
                        "in a popup window and nil returned.  If called with no options, the "
                        "function will prompt the user to select a file via a file_tree_browser "
                        "control.  If create_mode is true in the options, then a new file "
                        "creation will be attempted and an editor returned for that.  If a "
                        "new file cannot be created, the user will be warned and nil will "
                        "be returned.")
       `usage: ["options:object"]
       `tags: ["DOM" "ui" "file" "edit" "open"]
   })
       
(defun new_file (filename)
   (cond 
      (and (is_string? filename) (file_status filename))
      (throw Error "new_file: filename already exists!")
      (is_string? filename)
      (edit_file { `filename: filename `create_mode: true })
      else
      (edit_file { `create_mode: true }))
   {
     description: (+ "The function `new_file` creates a new file and opens it up for "
                     "editing.  If provided with a filename it will directly create that file if it "
                     "doesn\'t already exist.  If it already exists, it will throw an error stating "
                     "that the file already exists.  If not filename is provided, it will open up a "
                     "prompt for the file to be selected by the user prior to the create and open "
                     "steps.  ")
     usage: ["filename:?string"]
     tags: ["DOM" "ui" "file" "edit" "open" "create"]
     })

  
;; control behavior for unsaved controls in remote mode
;; if a control that is a buffer is to be saved to a file:
;;  1.  select a file to create
;;  2.  make a new editor with the contents of the old control as a proper file
;;  3.  swap with old control. 
;; if we do not have a host and are running locally, 
;;  1.  Establish an export_as name and save the file to that, but retain the existing editor

(defun handle_save_file (control options)
  (let
      ((fname (when control
                (or (and options.no_prompt
                         (is_string? control.options.filename)
                         control.options.filename)
                    (and options.remote
                       (wait_for_file_selection true))
                    (and (not options.remote)
                         (request_user_input (dtext "Download Buffer To Local File") 
                                             `text
                                             { `placeholder: (dtext "Name Of File")
                                                            `value: (aif (resolve_path [ `options `export_as ] control)
                                                                         it
                                                                         nil) })))))
       (rval nil))
      (declare (function wait_for_file_selection)
               (global wait_for_file_selection))
    
    (when (and (not (blank? fname))
               control
               control.get)
       (cond
          (and options.remote
               fname)
          (progn
             (alert_on_error "Cannot Create File"
                (progn
                   (= rval (http/send_files "/save_file" (http/data_to_file fname (or (-> control `get) ""))))
                   (if (and rval
                            (== rval.rval "OK"))
                       (progn
                          (= rval rval.results)
                          (notify "File saved")
                          (when (== rval.length 1)
                             ;; we made the file, now open a new buffer to it and swap with the old control
                             (edit_file { `filename: fname `control_to_replace: control })))
                       (progn
                          (log "ERROR on file creation: " rval)
                          (throw rval.message))))))
          fname
          (alert_on_error "Cannot Save Locally"
             (= rval (save_locally fname (-> control `get)
                                   "application/text"))
             (when rval
                (set_path_value control [ `options `export_as ] fname)
                (if control.display_context_message
                   (-> control `display_context_message (+ (dtext "Exported as: ") fname))))
             (log "Local save returned: " rval)))))
  {
   `usage: ["control:object" "options:?object"]
   `description: (+ "Given a control and an optional options object, will call the control's "
                    "`get method for the data value, and saves the value returned by the get "
                    "operation.  If the remote option is true and there is no options.filename "
                    "set, the user will be prompted with a chooser.  If the file is to be saved "
                    "locally, the user will be asked for a name to export it as, and the file "
                    "will be downloaded from the browser to the local environment and placed "
                    "in the default download folder of the browser.<br>"
                    "When a file is saved remotely, a new editor is established that is now "
                    "linked to the remote file and further saves for that buffer will be "
                    "defaulted to that filename.  If local, on subsequent saves the user will "
                    "be prompted to confirm the filename, or choose another."
                    "<br>Options are: <br>"
                    "remote:boolean - Attempt to save the file to the hosting server.<br>"
                    "no_prompt:boolean - If a filename is already established via options.filename "
                    "do not prompt for a new filename.")
   `tags: ["save" "file" "control"]
   })    



(defun serialize_layout (layout_name options)
   (let
      ((layout (cond 
                  (is_string? layout_name)
                  (get_control_by_name layout_name)
                  (is_control? layout_name)
                  layout_name
                  else
                  (throw TypeError "invalid layout value provided to serialize_layout: must be string or control")))
       (serialized_layout nil))
      (assert (is_control? layout) "layout isn't a control: check provided name or value to serialize_layout")
      (cond
         options.include_container
         (= serialized_layout (JSON.parse (JSON.stringify layout)))
         else
         (= serialized_layout (JSON.parse (JSON.stringify (first (-> layout `controls))))))
      (unless options.keep_text_editor_content
         (log "serialize_layout: removing compressed text editor content")
         (traverse serialized_layout
                   (fn (val path)
                      (progn
                         (when (and (is_object? val)
                                    (prop val "content_compressed"))
                            (log "removing content_compressed: " path)
                            (delete_prop val "content_compress`ed"))))))
                            
      serialized_layout))


(defun copy_layout_to_buffer (layout options)
   (let
      ((layout (cond 
                  (is_string? layout)
                  (get_control_by_name layout)
                  (is_control? layout)
                  layout
                  else
                  (throw TypeError "copy_layout_to_buffer: layout must either be a string or a control")))
       (idx 0)
       (base_name (to_key (control_name layout)))
       (symbol_name (if options.symbol_name
                        options.symbol_name
                        (progn
                           (= symbol_name base_name)
                           (while (is_symbol? symbol_name)
                              (progn
                                 (inc idx)
                                 (= symbol_name (+ "" base_name "_" idx))))
                           symbol_name))))
      (log "Symbol name: " symbol_name)
      (-> Environment `set_global symbol_name (pretty_print (serialize_layout layout options)))
      (new_buffer {
                    path: [ symbol_name ]
                    }))
   {
     description: (+ "Given a layout name, serializes the layout, places it in a global "
                     "variable and opens up a buffer with the value.  The name of the global variable "
                     "can be specified with options, or, by default, the name will be generated from "
                     "the layout name.  If a symbol already exists by that name, a numeric suffix "
                     "will be appended to the name to ensure it is unique.<br><br>#### Options "
                     "<br><br>symbol_name:string - The name of the symbol to create.  NOTE: when "
                     "using this option and provided with an existing symbol, that symbol will be "
                     "overwritten with the contents of the layout "
                     "code.  <br>include_container:boolean - If true, the root container of the "
                     "layout is included, otherwise only the contents are included.<br> ")

   })

(defun global_search_dispatch (event keycode)
   (let
      ((control (or (control_for_dom_element event.srcElement)
                    *last_focus*)))
      (cond 
         (and control
            control.open_search)
         (-> control `open_search))))

(defun global_search_next_dispatch (event keycode)
   (let
      ((control (or (control_for_dom_element event.srcElement)
                    *last_focus*)))
      ;(quick_alert (+ "-> " (control_name control)))
      (cond 
         (and control
            control.next_search_result)
         (-> control `next_search_result))))

(defun global_search_prior_dispatch (event keycode)
   (let
      ((control (or (control_for_dom_element event.srcElement)
                    *last_focus*)))
      ;(quick_alert (+ "<-" (control_name control)))
      (cond 
         (and control
            control.prior_search_result)
         (-> control `prior_search_result))))

(defun close_periphery (event keycode)
   (let
      ((control (or (control_for_dom_element event.srcElement)
                    *last_focus*)))
      (aif (get_by_id "cmenu")
           (-> it `remove))
      (set_focus_to *last_focus*)
      (cond 
         (and control
              control.close_search)
         (-> control `close_search))))

(defun setup_drop_file (dom_elem onload options)
   (let
      ((attached_file nil)
       (files [])
       (drop  (fn (e)
                 (progn
                    (console.log "DROP: " e)
                    (handle_event e)
                    (= files e.dataTransfer.files)
                    (if options.on_drag_leave
                       (options.on_drag_leave e.dataTransfer.files e))
                    (onload files))))
       (drag_enter (fn (e)
                      (do
                         (handle_event e)
                         (= files e.originalEvent.dataTransfer.files)
                         (if options.on_drag_enter
                            (do
                               (if (options.on_drag_enter files e)
                                   true
                                   false))
                            (do
                               (add_class (or options.drop_ok_class
                                              "juno-file-drop-ok")
                                          dom_elem)
                               true)))))
       (drag_over  (fn (e)
                      (do
                         (handle_event e)
                         true)))
       (drag_leave
          (fn (e)
             (do
                (handle_event e)
                (= files e.originalEvent.dataTransfer.files)
                (if options.on_drag_leave
                   (do
                      (if (options.on_drag_leave files e)
                          true
                          false))
                   (do
                      (remove_class (or options.drop_ok_class
                                        "juno-file-drop-ok")
                                    dom_elem)
                      true))))))
      (when (eq nil dom_elem)
         (throw Error "Invalid DOM Element"))
      (-> dom_elem `addEventListener `dragenter drag_enter)
      (-> dom_elem `addEventListener `dragover drag_over)
      (-> dom_elem `addEventListener `drop drop)
      (-> dom_elem `addEventListener `dragleave drag_leave)
      dom_elem)
   {
     description: (+ "Given a DOM element and a function that accepts the file data, sets up "
                     "a drag and drop interface the given DOM element.<br><br>#### Options "
                     "<br><br>on_drag_enter:function-If present, the function signature (fn "
                     "(file_array event)) is called when a drag enter event occurs on the DOM "
                     "element. Return true to accept/false if not "
                     "acceptable.<br>on_drag_leave:function-If present, the function signature (fn "
                     "(file_array event)) is called when a drag leave event occurs on the DOM "
                     "element. <br>drop_ok_class:string-A CSS class to add/remove when an element "
                     "enters and leaves the DOM element. The default is `juno-file-drop-ok`. ")
     usage: ["dom_elem:DOM Element" "onload:function" "options:object"]
     tags: ["ui" "drag" "drop" "file"]
     })

(defun import_local_files ()
   (-> resource_loader_button `click)
   {
     description: (+ "<br><br>Initiates the process of local file access via the browser.  This will "
                     "open the Browser\'s file picker window and if a file is selected, will open the "
                     "import dialog box to allow the user to determine how to process the files. ")
     usage: []
     tags: ["import" "local" "files" "resources" "browser" "ui"]
   })


(defun setup_bootstrap_handler ()
   (let
      ((in_build false)
       (errors_encountered false))
   (remove_event_handler "evaluator" "build_application")
   (remove_event_handler "bootstrap" "build_application")
   
   (register_event_handler "evaluator" "build_application" "build_application_evaluator" 
                           (fn (event)
                              (cond
                                 (resolve_path [`args 0 `value 0 `error] event)
                                 (progn
                                    (= errors_encountered true)
                                    (log_error "Bootstrap Error: " event.args.0.value.0))
                                 (resolve_path [`args 0 `error_state] event)
                                 (progn
                                    (= errors_encountered true)
                                    (log_error "Bootstrap Error: " event.args.0.value))
                                 (and (resolve_path [`args 0 `value `results] event)
                                      (not errors_encountered))
                                 (log "Bootstrap: wrote output: " (resolve_path [`args 0 `value `results] event))
                                 (resolve_path [`args 0 `value] event)
                                 (if errors_encountered
                                    (log_error "Bootstrap: " event.args.0.value)
                                    (log "Bootstrap: " event.args.0.value))
                                 else
                                 (log "Bootstrap: Received Unknown: " event))))
                                                                                                
       
       (register_event_handler "bootstrap" "build_application" "build_application_bootstrap" 
                               (fn (event)
                                  (progn
                                     ;(log "build_app: : event: " event (resolve_path [`args 0] event))
                                     (cond 
                                        (== "start" (resolve_path [`args 0] event))
                                        (progn
                                           (= in_build true)
                                           (log "Bootstrap: Build started"))
                                        (== "complete" (resolve_path [`args 0] event))
                                        (progn
                                           (if errors_encountered
                                              (log_error "Bootstrap Failed" "See log")
                                              (progn
                                                 (log "Bootstrap Completed Successfully")
                                                 (when (is_object? *build_window*)
                                                    (-> *build_window* `close)
                                                    (= *build_window* nil))
                                                 (try
                                                    (progn 
                                                       (log "Loading system validations..")
                                                       (sleep 0.1)
                                                       (load "tests/seedling-tasks.juno")
                                                       (sleep 0.1)
                                                       (if (contains? "seedling-tests" (namespaces))
                                                          (eval `(seedling-tests/make_named_layout "Validations"
                                                                                    (seedling-tests/system_validations { `deploy: true `url: (+ "/env/seedling_build.html?theme=" ,#(encodeURIComponent *env_config*.application.global_theme)) } )
                                                                                    {
                                                                                      `unmounted_source: true
                                                                                      }))
                                                          (log_error "Unable to load tests/seedling-tasks.juno - the seedling-tests namespace wasn't loaded.")))

                                                    (catch Error (e)
                                                       (log_error "ERROR on loading validations: " e)))))
                                            (= errors_encountered false)
                                            (= in_build false))))))
       true))

(defun export_system (layout_name options)
   (let
      ((cancel_button (button { `style: "float: right" }  (dtext "Close")))
       (orig_options options)
       (whole_application? (if (== layout_name nil)
                               true
                               false))
       (export_button (button (if whole_application?
                                  (dtext "Save Image")
                                  (dtext "Export"))))
       (array_to_keyed_booleans (fn (items init_state)
                                   (if (is_array? items)
                                       (to_object
                                          (for_each (item items)
                                             [item (or init_state false)])))))
       (embedded_scripts (array_to_keyed_booleans (reduce (embeded_id (embedded_script_ids))
                                                     (unless (or (== embeded_id "juno-core")
                                                                 (== embeded_id "lz_string"))
                                                        embeded_id))
                                                  true))
       (embedded_styles (array_to_keyed_booleans (reduce (embeded_id (embedded_style_ids))
                                                    (unless (or (== embeded_id "juno-css")
                                                                (== embeded_id "juno-css-theme"))
                                                       embeded_id))
                                                 true))
       (assets_elem nil)
       (export_options nil)
       (copy_button (button { `title: "Copy as a quoted form that can be reused in other code" } (dtext "Copy Code")))
       (status_elem (div { `style: "border: 2px inset #FFFFFF; padding: 8px; background: #FFFFFF20; font-weight: bold; margin-bottom: 20px;margin-top: 10px;" } (dtext "Ready")))
       (dcomps (date_components (new Date)))
       (version_tag (join "." [ dcomps.year dcomps.month dcomps.day dcomps.hour dcomps.minute ]))
       (get_app_name (fn ()
                        (+ (if whole_application?
                               options.application_name
                               (or layout_name "unnamed_layout"))
                           (if options.date_stamp
                              (+ "." version_tag)
                              ""))))
       
       (options (+ {}
                   (if whole_application?
                      {}
                      { include_container: true })
                   {
                     keep_text_editor_content: (if is_served?
                                                  false
                                                  true)
                     date_stamp: (get_default `application.append_date_stamp)
                     application_name: (if whole_application?
                                          *env_config*.application.name
                                          (or layout_name "layout"))
                     save_location: (if is_served?
                                       "Server"
                                       "Local To This Computer")
                     output_as: "Multi-line Lisp" }
                   options)) ;; if supplied options, use them as defaults
       (check_all_assets_button (button { } "Check All"))
       (uncheck_all_assets_button (button { } "Uncheck All"))
       (set_busy (fn (message)
                    (if (is_string? message)
                        (progn
                           (set_prop status_elem
                              `innerHTML
                              message)
                           (set_disabled cancel_button export_button copy_button))
                        (progn
                           (set_prop status_elem
                              `innerHTML
                              (dtext "Ready"))
                           (set_enabled cancel_button export_button copy_button)))))
       (set_message (fn (message)
                       (if (is_string? message)
                           (progn
                              (log "export_system: " message)
                              (set_prop status_elem
                                 `innerHTML
                                 message)))))
       (check_all_assets (fn (state)
                            (progn
                               (try
                                  (for_each (elem (-> assets_elem `querySelectorAll "input"))
                                     (when (is_element? elem)
                                        (if (or (and (== state false`)
                                                     elem.checked)
                                                (and (== state true)
                                                     (not elem.checked)))
                                            (-> elem `click))))
                                  (catch Error (e)
                                     (log "Error: " e))))))
       (layout (unless whole_application?
                  (get_control_by_name layout_name)))
       (save_ide (fn ()
                    (let
                       ((rval nil)
                        (app_name nil))
                       (set_busy (+ (dtext "Saving") "..."))
                       (sleep 0.1)
                       (= export_options
                          {
                            `save_prefix: (get_app_name)
                            `shake_tree: false
                            `keep_text_editor_content: options.keep_text_editor_content
                            `save_locally: (if (== "Local To This Computer" options.save_location)
                                               true
                                               false)
                            })
                       (= rval
                          (save_control_image false
                                              export_options))
                       (set_busy nil)
                       (cond
                          (and export_options.save_locally
                             (== rval true))
                          (progn
                             (= *system_requires_export* false)
                             (set_message "Saved Locally - check your Downloads Folder"))
                          (and (not export_options.save_locally)
                               (== rval.rval "OK"))
                          (progn
                             (= app_name (last (split_by "/" rval.results.0.filename)))
                             (set_message (+ "Saved To Host - opening in browser: " (+ "/env/" app_name)))
                             (= *system_requires_export* false)
                             (-> window `open (+ "/env/" app_name) (get_app_name)))
                          else
                          (progn
                             (set_prop status_elem
                                `innerHTML
                                (+ "ERROR: " (or rval.message "Check system repl for return value")))))
                       (log "export_system: result: " rval))))
       
       
       (save_as_app (fn ()
                       (when (not (blank? options.application_name))
                          (let
                             ((rval nil)
                              (app_name nil))
                             (set_busy (+ (dtext "Saving") "..."))
                             (sleep 0.1)
                             (= export_options
                                {
                                  `no_header: true
                                  `do_not_include_scripts: (reduce (emset (pairs embedded_scripts))
                                                              (destructuring_bind (script_name is_wanted)
                                                                 emset
                                                                 (unless (or is_wanted
                                                                             (== script_name "juno-core")
                                                                             (== script_name "lz_string"))
                                                                    script_name)))
                                  `do_not_include_styles: (reduce (emset (pairs embedded_styles))
                                                             (destructuring_bind (script_name is_wanted)
                                                                emset
                                                                (unless (or is_wanted
                                                                            (== script_name "juno-core")
                                                                            (== script_name "lz_string"))
                                                                   script_name)))
                                  `initializer_symbol: `layout_initializer
                                  `save_prefix: options.application_name
                                  `keep_text_editor_content: options.keep_text_editor_content
                                  `root_controls: [ layout ]
                                  `shake_tree: true
                                  `save_locally: (if (== "Local To This Computer" options.save_location)
                                                     true
                                                     false)
                                  })
                             (log (pre (pretty_print `(save_control_image false ,#(+ {} export_options { `root_controls: [ `(get_control_by_name ,#layout_name) ] } )))))
                             (= rval (save_control_image false
                                                         export_options))
                             ;(-> window `open (+ "/env/" save_as_name ".html") save_as_name)
                             (set_busy nil)
                             (cond
                                (and export_options.save_locally
                                   (== rval true))
                                (progn
                                   (= *system_requires_export* false)
                                   (set_message "Saved Locally - check your Downloads Folder"))
                                (and (not export_options.save_locally)
                                     (== rval.rval "OK"))
                                (progn
                                   (= app_name (last (split_by "/" rval.results.0.filename)))
                                   (= *system_requires_export* false)
                                   (set_message (+ "Saved To Host - opening in browser: " (+ "/env/" app_name)))
                                   (-> window `open (+ "/env/" app_name) (get_app_name)))
                                else
                                (progn
                                   (set_prop status_elem
                                      `innerHTML
                                      (+ "ERROR: " (or rval.message "Check system repl for return value")))))
                             (log "export_system: result: " rval)))))
       (resolver nil)
       (handle_event (fn (e)
                        (let
                           ((src e.srcElement))
                           (declare (function resolver))
                           (cond
                              (== src cancel_button)
                              (progn
                                 (-> frame `close)
                                 (resolver nil))
                              (== src export_button)
                              (progn
                                 (if whole_application?
                                    (save_ide)
                                    (save_as_app)))
                              (== src copy_button)
                              (progn
                                 (copy_layout_to_buffer layout options))
                              (== src check_all_assets_button)
                              (progn
                                 (check_all_assets true))
                              (== src uncheck_all_assets_button)
                              (progn
                                 (check_all_assets false))
                              ))))
       (view nil)
       (frame nil)
       (result nil))
      
      (unless whole_application?
         (assert (is_control? layout) "export_system: invalid layout or control name provided"))
      (= view
         (div { `class: "juno-form" `style: "flex-grow: 1; "}
              (if whole_application?
                 (h4 *env_config*.application.name)
                 (h4 (+ "Layout: " layout_name)))
              (if whole_application?
                 (dtext "Save the current global state of the IDE with the settings below.")
                 (dtext "You can export the layout as usable code, or save the layout as an application."))
              (br)
              (br)
              (div { `class: "juno-form-data" `style: "flex-grow: 1; "}
                   (div { `style: "flex-grow: 0;"  }
                        (value_to_dom options
                                      { editable: true
                                        disable_object_toggle: true
                                        pretty_keys: true
                                        expand_all: true
                                        paths: {
                                                 application_name: {
                                                                     style:
                                                                     }
                                                 output_as: {
                                                              values: (if whole_application?
                                                                         ["HTML Page"]
                                                                         ["Formatted Lisp"
                                                                          "Single-line Lisp"
                                                                          "Formatted JSON"
                                                                          "Single-line JSON"])
                                                              }
                                                 save_location: {
                                                                  values: (if is_served?
                                                                             [ "Server" "Local To This Computer"]
                                                                             ["Local to This Computer"])
                                                                  }
                                                 }
                                        }))
                   (hr { `style: "width: 100%" } )
                   (h4 { `style: "flex-grow: 0;" } "DOM Resident Assets")
                   (if whole_application?
                      (div { `style: "flex-grow: 0;" }
                           (div "Since the whole IDE state is being saved, the below scripts and styles are included with the full IDE export.")
                           (div "No tree shaking will occur."))
                      (div { `style: "flex-grow: 0;" } "Checked items will be included in the emitted page."
                           (div { `style: "display: inline-block;"} check_all_assets_button uncheck_all_assets_button)))
                   (= assets_elem
                      (div { `style: "margin-top: 3px; justify-content: stretch; flex-grow: 2; flex-shrink: 2; flex-basis: 150px; overflow: scroll;" }
                           (div { `style: "display: flex; align-items: stretch; justify-content: stretch; flex-direction: row;" }
                                (div { `style: "flex-grow: 1;margin-top: 3px; background: #FFFFFF10; ; padding: 5px; " }
                                     (div { `style: "font-weight: bold;" } "Scripts")
                                     (value_to_dom embedded_scripts
                                                   { editable: (not whole_application?)
                                                              disable_object_toggle: true
                                                              pretty_keys: true
                                                              expand_all: true
                                                              }))
                                (div { `style: "flex-grow: 1;  margin-top: 3px; background: #FFFFFF10;; padding: 5px; " }
                                     (div { `style: "font-weight: bold;"} "Styles")
                                     (value_to_dom embedded_styles
                                                   { editable:  (not whole_application?)
                                                              disable_object_toggle: true
                                                              pretty_keys: true
                                                              expand_all: true
                                                              })))))
                   status_elem
                   (div
                      export_button
                      (if whole_application?
                         []
                         copy_button)
                      cancel_button))))
      (attach_event_listener view
         `click
         handle_event)
      
      
      ;; now wait for the user to confirm/select choices
      (= result
         (new Promise
            (fn (resolve reject)
               (progn
                  (declare (function resolve reject))
                  (= resolver resolve)
                  
                  (= frame
                     (floating_div view {
                                          title: (if whole_application?
                                                    (dtext "Save Application Image")
                                                    (+ (dtext "Export/Copy") ": " layout_name))
                                          on_close: (fn ()
                                                       (resolver nil))
                                          controls: true
                                          position: {
                                                      left: 10
                                                      top: 10
                                                      }
                                          }))
                  (attach_event_listener frame.view
                     `keydown
                     (fn (e)
                        (progn
                           (if (== e.key "Escape")
                               (progn
                                  (-> frame `close)
                                  (resolver nil)))
                           )))
                  (focus_to (first (-> view `querySelectorAll "input")))
                  ))))
      
      
      result))
  
(defun export_remote_system (options)
   (if is_served?
      (let
         ((env_config (rblock *env_config*))
          (remote_os (rblock (operating_system)))
          (cancel_button (button { `style: "float: right" }  (dtext "Close")))
          (export_button (button (dtext "Build")))
          (array_to_keyed_booleans (fn (items init_state)
                                      (if (is_array? items)
                                          (to_object
                                             (for_each (item items)
                                                [item (or init_state false)])))))
          (export_options nil)
          (ui_environments (conj [""] (rblock (http/browser_environments))))
          (arch (if (== remote_os "darwin")
                    (chop (rblock (prop (sys/system "uname -p") `stdout)))
                    nil))
          (selected_target
             (cond
                (and arch
                   (== arch "arm")
                   (== remote_os "darwin"))
                `aarch64-apple-darwin
                (== remote_os "darwin")
                `x86_64-apple-darwin
                (== remote_os "linux")
                `x86_64-unknown-linux-gnu
                else
                `x86_64-pc-windows-msvc))
          (perms (rblock (permissions)))
          (perms_set (to_object
                                (for ((perm_name state) (pairs perms))
                                     [ perm_name (if (== state "granted") true false) ])))
          (target_architectures [`x86_64-unknown-linux-gnu `x86_64-pc-windows-msvc,
                                 `x86_64-apple-darwin `aarch64-apple-darwin])
          (status_elem (div { `style: "border: 2px inset #FFFFFF; padding: 8px; background: #FFFFFF20; font-weight: bold; margin-bottom: 20px;margin-top: 10px;" } (dtext "Ready")))
          (options (+ {}
                      {
                        emit_as: (or env_config.export.save_executable "Unknown")
                        embed_user_interface: ""
                        save_location: (if is_served?
                                          "Server"
                                          "Downloads Folder")
                        default_namespace: (or env_config.export.default_namespace "user")
                        target_architecture: selected_target }
                      options))  ;; if supplied options, use them as defaults
          (set_busy (fn (message)
                       (if (is_string? message)
                           (progn
                              (set_prop status_elem
                                 `innerHTML
                                 message)
                              (set_disabled cancel_button export_button ))
                           (progn
                              (set_prop status_elem
                                 `innerHTML
                                 (dtext "Ready"))
                              (set_enabled cancel_button export_button )))))
          (set_message (fn (message)
                          (if (is_string? message)
                              (progn
                                 (log "export_system: " message)
                                 (set_prop status_elem
                                    `innerHTML
                                    message)))))
          (save_system
             (fn ()
                (let
                   ((save_opts (+ {} 
                                  (clone options)
                                  {
                                      `permissions: (reduce (pset (pairs perms_set))
                                                       (if pset.1
                                                          pset.0))
                                  }
                                  { `target: options.target_architecture 
                                    `source: "working/image.js" }
                                  ))
                    (js_image_result nil)
                    (result nil))
                   
                   (if (blank? save_opts.emit_as)
                       (alert_box "Invalid Name" "The emitted executable must have a name.")
                       (progn
                          (set_disabled export_button cancel_button)
                          (when (== options.save_location "Downloads Folder")
                             (set_prop save_opts
                                `emit_as (+ "working/" (last (split_by "/" save_opts.emit_as))))
                             (if (and (== save_opts.target_architecture "x86_64-pc-windows-msvc")
                                      (not (ends_with? ".exe" save_opts.emit_as)))
                                 (set_prop save_opts
                                    `emit_as (+ save_opts.emit_as ".exe"))))
                          (set_message (+ "Embedding UI: " save_opts.embed_user_interface))
                          (unless (blank? save_opts.embed_user_interface)
                             (eval `(rblock (http/enable_ui ,#(to_object [[`environment_file (+ "" save_opts.embed_user_interface) ]
                                                                          [`open_browser_on_start true ]])))))
                          (log "Save Options: " save_opts)
                          (set_message (+"Saving System into " save_opts.save_location))
                          (try
                             (progn
                                (= js_image_result (rblock
                                                      (eval `(set_default export.default_namespace ,#save_opts.default_namespace))
                                                      (import "pkg/save_env.juno")
                                                      (save_environment { `save_as: "working/image.js" })))
                                
                                (log "js_image_result: " js_image_result)
                                (if (is_string? js_image_result.js)
                                    (= result (rblock
                                                 (eval `(sys/compile_executable ,#save_opts))))
                                    (throw EvalError "Unable to construct the JS image")))
                             (catch Error (e)
                                (progn
                                   (set_message (+ "Error: " e.message))
                                   (log "Error: " e))))
                          (if (and (is_object? result)
                                   result.success)
                              (progn
                                 ;(rblock
                                  ;  (sys/delete_file "working/image.js"))
                                 (if (== options.save_location "Downloads Folder")
                                     (progn
                                        (-> window `open (+ "/files/" save_opts.emit_as))
                                        (set_message (+ "Completed: check downloads"))
                                        (setTimeout (fn ()
                                                       (progn
                                                          (log "removing "save_opts.emit_as)
                                                          (rblock (eval `(sys/delete_file ,#save_opts.emit_as)))))
                                                    10000))
                                     (progn
                                        (set_message (+ "Saved as: " result.emitted))))))
                          (set_enabled export_button cancel_button)
                          (log "compilation results: " result))))))
          
          (resolver nil)
          (handle_event (fn (e)
                           (let
                              ((src e.srcElement))
                              (declare (function resolver))
                              (cond
                                 (== src cancel_button)
                                 (progn
                                    (-> frame `close)
                                    (resolver nil))
                                 (== src export_button)
                                 (progn
                                    (save_system))))))
          (view nil)
          (frame nil)
          (result nil))
         (= view
            (div { `class: "juno-form" `style: "flex-grow: 1; "}
                 
                 (p { `style: "line-height: 1.3em; max-width: 600px;" }
                    (dtext "To create an executable with the current server image, select the target architecture and platform, the required system permissions, and click 'Export' to create the executable."))
                 
                 (div { `class: "juno-form-data" `style: "flex-grow: 1; "}
                      (div { `style: "flex-grow: 0;"  }
                           (value_to_dom options
                                         { editable: true
                                           disable_object_toggle: true
                                           pretty_keys: true
                                           expand_all: true
                                           paths: {
                                                    embed_user_interface: {
                                                        values: ui_environments
                                                    }
                                                    target_architecture: {
                                                                           values: target_architectures}
                                                    save_location: {
                                                                     values: (if is_served?
                                                                                [ "Server" "Downloads Folder"]
                                                                                ["Downloads Folder"])
                                                                     }
                                                    }
                                           })))
                 (hr { `style: "width: 100%" } )
                 (h4 { `style: "flex-grow: 0;" } "Permissions for the Executable")
                 (value_to_dom perms_set
                               { editable: true
                                 disable_object_toggle: true
                                 pretty_keys: false
                                 expand_all: true
                                 })
                 status_elem
                 (div
                    export_button
                    cancel_button)))
         (attach_event_listener view
            `click
            handle_event)
         
         
         ;; now wait for the user to confirm/select choices
         (= result
            (new Promise
               (fn (resolve reject)
                  (progn
                     (declare (function resolve reject))
                     (= resolver resolve)
                     
                     (= frame
                        (floating_div view {
                                             title: "Export System Image"
                                             on_close: (fn ()
                                                          (resolver nil))
                                             controls: true
                                             position: {
                                                         left: 10
                                                         top: 10
                                                         }
                                             }))
                     (attach_event_listener frame.view
                        `keydown
                        (fn (e)
                           (progn
                              (if (== e.key "Escape")
                                  (progn
                                     (-> frame `close)
                                     (resolver nil)))
                              )))
                     (focus_to (first (-> view `querySelectorAll "input")))))))
         result)
      (alert_box  (dtext "This function is only available when connected to a server environment."))))

;; the global keyword_mapper routes to the currently focused
;; editor for the local keyword_mapper to that editor and the
;; environment it might be connected to

(defun_sync keyword_mapper (token)
   (progn
      (defvar details nil)
      (defvar rval
         (cond
            (and *last_focus*
               (prop *last_focus* `keyword_mapper))
            (-> *last_focus* `keyword_mapper token)
            (contains? token *formatting_rules*.keywords)
            "keyword"
            (progn
               (setq details
                     (first (meta_for_symbol token true)))
               details.type)
            (lowercase details.type)
            else
            "identifier"))      
      rval))

;; and redirect the core/keyword_mapper entry point
;; from the javascript world..

(use_quoted_initializer
 (defun_sync core/keyword_mapper (token)
   (user/keyword_mapper token)))

(defun eval_in_iframe (iframe_element quoted_lisp timeout)
   (new Promise 
      (fn (resolve reject)
         (let
            ((pid (gen_id "pid"))
             (timeout (if (is_number? timeout)
                          timeout
                          10000)))
            (set_prop *ipc_promise_ids*
               pid
               (list resolve
                  (setTimeout (fn ()
                                 (when (prop *ipc_promise_ids* pid)
                                    (clearTimeout (second (prop *ipc_promise_ids* pid)))
                                    (delete_prop *ipc_promise_ids* pid)
                                    (reject undefined)))
                              10000)))
            (-> iframe_element.contentWindow `postMessage 
               (JSON.stringify { source: nil command: "exec" args: [pid quoted_lisp] })))))
   {
     description: (+ "Given an iframe element that is listening for dispatched events on the "
                     "\"exec\" command, and quoted lisp code for evaluation, the code will be sent to "
                     "the iframe, compiled within it, evaluated, and the answer returned.  The "
                     "function will not return until either the response from the iframe is received, "
                     "or a timeout occurs at which point the promise being waited on will be rejected "
                     "with an undefined value.   <br>An optional timeout value in milliseconds can be "
                     "provided as the 3rd argument, otherwise a default of 10 seconds (10000) is "
                     "used. ")
     usage: ["iframe_element:Element" "quoted_lisp:array" "timeout:?number"]
     tags: [`iframe `eval `evaluation `ipc ]
     })




(defun gen_file_menu ()
   [["New..." [(if is_served?
                   ["Server File" new_file]
                   [])
               ["Juno REPL" (fn (e) (new_juno_repl))]
               (if is_served? 
                  ["Juno Remote REPL" (fn (e) 
                                         (new_juno_repl { `remote_repl: (+ "" (if (starts_with? "https" window.location.protocol)
                                                                                  "wss://" 
                                                                                  "ws://")
                                                                           window.location.host "/connect_repl") }))]
                  [])
               ["--" nil]
               [{ text: "Juno Lisp Editor" 
                  path: [ `global `open_new_buffer ]
                  }
                  (fn (e) (new_buffer { `content: "" `type: "juno" }))]
               [{ text: "Javascript Editor" 
                  path: [ `global `open_new_javascript_buffer ]
                  exec: (fn (e) (new_buffer { `content: "" `type: "javascript" })) }]
               [{ text: "CSS Editor" 
                  path: [ `global `open_new_css_editor ]
                  exec: (fn (e) (new_buffer { `content: "" `type: "css" })) } ]
               [{ text: "Text Editor" 
                  path: [ `global `open_new_text_buffer ]
                  }]
               ["Markdown Editor" (fn (e) (new_buffer { `content: "" `type: "markdown" })) ]
               ["JSON Editor" (fn (e) (new_buffer { `content: "" `type: "json" }))]]]
    (if is_served?
       ["Open File" edit_file ]
       [])
    ["Open Symbol" (fn ()
                      (new_buffer))]
    (if (and is_served?
             (== "localhost" (resolve_path [ `location `hostname ] window)))
        ["Open Environment"
         (fn (e) (browser_environments))]
        [])
    (if (resolve_path [ `get ] *last_focus*) 
        ["--" nil]
        [])
    (cond
       (and is_served?
             *last_focus*
             (resolve_path [ `options `filename ] *last_focus*))
        [{ text: (+ (dtext "Close ") (get_editor_file_basename *last_focus*)) 
           path: [ `global `close_control ] } 
           (fn () (close_file *last_focus*)) ]
        (and *last_focus*
             (resolve_path [ `options `name ] *last_focus*))
        [{ text: (+ (dtext "Close ") (resolve_path [ `options `name ] *last_focus*))
           path: [ `global `close_control ] }
           (fn () 
              (hide_control *last_focus* true true)) ]
        else
        [])
    (if (and *last_focus*
             is_served?
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [{ text: (+ (dtext "Save") " "
                    (or (aif (resolve_path [ `options `filename ] *last_focus*)
                             (last (split_by "/" it)))
                        (resolve_path [ `options `name ] *last_focus*)
                        ""))
           path: [ `global `save_file ] }
         (fn (e) (save_active_buffer))]
        [])
    (if (and *last_focus*
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [(+ (dtext "Save As")
            "...")
         [(if is_served?
              [(dtext "New Server File") (fn (e) (handle_save_file *last_focus* { `remote: true }))]
              [])
          [(dtext "Local File") (fn (e) (handle_save_file *last_focus*))]]]
        [])
    ["--" nil]
    [(+ (dtext "Browser Environment") "...")
     [
      [(dtext "Bundle And Save Current State") (fn (e) (export_system nil)) ]
      [(dtext "Import Local File") import_local_files ]
      (if is_served?
         ["--" nil])
      (if is_served?
        [(dtext "Rebuild Seedling IDE") (fn () (build_starter_environment))]
        [])]]
    (if is_served?
         [(+ (dtext "Server Environment") "...")
          [[(dtext "Save Server State as an Executable")
            (fn (e) (export_remote_system))]
           [(dtext "Rebuild Host Juno Environment")
                    (fn (e) (rebuild_remote_environment))]]]
         [])
    (if *global_themes*
       ["--" nil]
       [])
    (if *global_themes*
       ["Set Global Theme" (conj (cond 
                                     (and is_served?
                                        (is_symbol? `theme_selection))
                                     [["Open Theme Manager" (fn ()
                                                               (eval (quote (theme_selection))))]
                                      ["--"]]
                                     is_served?
                                     [["Import and Open Theme Manager"
                                       (fn ()
                                          (activity_box { `style:  "width: 200px; height: 50px;" }
                                                        (set_content (dtext "Loading the theme_manager"))
                                                        (import "/pkg/theme_manager.juno")
                                                        (eval (quote (theme_selection)))))]
                                      ["--"]]
                                     else
                                     [])
                                 (for_each (theme_name (keys *global_themes*))
                                    [theme_name (fn ()
                                                   (set_global_theme theme_name))]))]
       [])
    [(dtext "Quit") (fn () (window.close))]]);


(defun gen_edit_menu ()
   [[{ text: (dtext "Undo")
      path: [ `global `undo ] }]
    [{ text: (dtext "Redo")
      path: [ `global `redo ] }]
    ["--" nil]
    [{ text: (dtext "Cut")
      path: [ `global `cut ] }]
    [{ text: (dtext "Copy")
      path: [ `global `copy ] }]
    [{ text: (dtext "Paste")
       path: [ `global `paste ] }]
    ["--" nil ]
    [{ text: (dtext "Select All")
      path: [ `global `select_all ] }]
    ["--" nil]
    [{ text: (dtext "Find")
       path: [ `global `find ] }]])

(defun gen_layout_menu ()
   (let
      ((current_layout (get_current_layout_control))
       (idx 0)
       (f0 (frame_0))
       (roots (available_layouts))
       (layout_locked? (prop current_layout.options `is_locked?)))
      (conj 
         (for_each (ctl roots)
            (progn
               (inc idx)
               (if (== ctl.options.root_frame true)
                   [{
                      path: [ `global (if (== ctl f0)
                                          "frame_0"
                                          (+ "layout_" (to_key ctl.options.name))) ]
                      text: (span { class: "juno-selected-menu-item" } ctl.options.name)
                      exec:(fn ()
                              true)
                      }]
                   [{
                      path: [ `global (if (== ctl f0)
                                          "frame_0"
                                          (+ "layout_" (to_key ctl.options.name))) ]
                      text: ctl.options.name
                      exec:(fn ()
                              (switch_to_new_layout ctl.options.name))
                      }])))
         [["--" nil]]
         [(if current_layout.options.root_bundle
                []
                [{
                    text: (dtext "New named layout")
                    path: [ `global `make_named_layout ]
                    exec: (fn ()
                             (make_named_layout_interactive current_layout))
                }])]
         [(if (and current_layout.options.root_bundle
                layout_locked?)
             [{
                text: (+ (dtext "Unlock positions for") " " current_layout.options.name)
                path: [ `global `unlock_current_layout_positions ]
                exec: (fn ()
                         (unlock_layout_positions current_layout.options.name))
                }]
             [{
                text: (+ (dtext "Lock positions for") " " current_layout.options.name)
                path: [ `global `lock_current_layout_positions ]
                exec: (fn ()
                         (lock_layout_positions current_layout.options.name))
                }])]
             
         [(if current_layout.options.root_bundle
              [(dtext "Open This Layout Code in New Buffer")
               (fn ()
                  (copy_layout_to_buffer current_layout))]
              [])]
          [(if current_layout.options.root_bundle
              [(+ (dtext "Export Layout") " " (control_name current_layout) "...")
               (fn ()
                  (export_system (control_name current_layout)))]
              [])]
         [["--" nil]]
         [[(dtext "Remove Named Layout..")
           (on_empty [["No Named Layouts" 
                      (fn ()
                         false)]]
              (reduce (ctl roots)
                  (progn
                     (when (and (not (== ctl f0))
                                (not (blank? ctl.options.root_bundle)))
                        [{
                           text: ctl.options.name
                           path: [ `global `remove_named_layout ]
                           exec: (fn ()
                                    (alert_on_error "Error removing layout"
                                                    (eval `(progn
                                                              (when (== (resolve_path [ `options `id ] (get_current_layout_control)) 
                                                                      ,#ctl.options.id)
                                                                  (switch_to_new_layout "Frame 0"))
                                                              (remove_named_layout ,#ctl.options.name)
                                                              (notify (+ "Removed Layout: " ,#ctl.options.name))
                                                              ))))
                           }]))))]])))

(defun gen_controls_menu ()
  (progn
   (defvar holding_tank (get_control_by_name "Holding Tank"))                
   (defvar holding_tank_visible? (if (prop (control_position holding_tank) `parent)
                                     true
                                     false))
   (defvar current_layout (get_current_layout_control))
   
   (conj 
        [[ {
             `path: [ `global `jump_to_control ]
             `text: (dtext "Jump to Control or Layout")
           }]
         ["--" nil]]
        (reduce (control (current_controls))
            (when (and control.on_focus
                       control.options.id)
              (defvar is_displayed? (and (== (get_layout_for_control control) current_layout)
                                         (not (== holding_tank control))
                                         (not (-> holding_tank `has_control? control))))
              [(if (== *system_repl* control)
                   (span { class: "juno-selected-menu-item" } control.name) ;(+" ⮕ " control.name)  
                   (+ "   " (or control.name "Untitled")))
               (reduce (operation ["Show" "Focus" "Hide" "--" "Close Control"])
                       (cond
                         (== control.name "Holding Tank")                              
                         (cond
                           (== operation "Focus")
                           [(dtext "Show")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `show))]
                           (and holding_tank_visible?
                                (== operation "Hide"))
                           [(dtext "Hide")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `hide))]
                           else
                           nil)
                         else
                         [(dtext operation)
                          (cond
                            (and (not is_displayed?)
                                 (== operation "Show"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (show_control it)))
                            (and is_displayed? (== operation "Focus"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (set_focus_to it)))
                            (and is_displayed? (== operation "--"))
                            nil
                            (and is_displayed? (== operation "Hide"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "hide" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id)))))
                            (== operation "Close Control")
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "destroy" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id))))))]))]))
        [[(dtext "Monitor Control Tree") 
          (fn ()
            (progn
             (monitor_control_tree)))  ]])))

(defun standard_error_notifier (event)
   (progn
      (log_error (+ (if event.args.1
                        (+ event.args.1 ":")
                        "Error: "))
                 (or event.args.0 "An error event was reported, but the information was malformed."))
      (alert_box (+ "Error" (if event.args.1
                                (+ ": " event.args.1)
                                ""))
                 (or event.args.0 "An error event was reported, but the information was malformed.")))
   {
     `description: (+ "This function is the standard registered error notification function, "
                      "which by defaults pops up an alert box and logs the error as received via "
                      "the `log_error` facility.  The event should be in the following format:```{ "
                      "source: nil \n  command: \"notify_error\"\n  args: [ \"error message in the first "
                      "position\" \"title or prefix in the second\" ] "
                      "}```<br><br>The `standard_error_notifier` can be re-defined, or the event "
                      "itself can be re-registered to a different function. The function ID it is "
                      "registered under is: `standard_error_notifier` .<br>")
     `tags: ["error" "notification" "event" "dispatch" "register" "handler" ]
     `usage: ["event:object"]
     })

(defun system_theme_change_event_handler (e)
   (progn
      (when (get_default [ `application `color_scheme `follow_desktop_preference ])
         (if e.matches
            (aif (get_default [ `application `color_scheme `dark_theme])
                 (set_global_theme it))
            (aif (get_default [ `application `color_scheme `light_theme])
                 (set_global_theme it)))))
   {
       description: "Called by the matchMedia event handler to handle an OS theme change based on the user's preferences."
       usage: [ "e:Event" ]
       tags: ["system" "event" "handler" "theme" "listener"]
   })

(defun install_color_scheme_detector ()
   (let
      ((handler system_theme_change_event_handler))
      (if (eq nil (resolve_path [`application `color_scheme ] *env_config*))
          (set_default [ `application `color_scheme ]
                       { follow_desktop_preference: true
                         dark_theme: `dark_grey
                         light_theme: `juno_light }))
      (javascript "window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change',handler)")))

(defun adjust_for_display_density ()
   (let
      ((hi_dpi? (> window.devicePixelRatio (or (get_default `application.fonts.device_pixel_ratio_threshold 1.3))))
       (replacer (new RegExp "[\"']" `g))
       (lookup (if hi_dpi? ;; build the lookup object based on whether the display is currently hi dpi
                   (to_object (get_default `application.fonts.dpi_map))
                   (to_object (map reverse (get_default `application.fonts.dpi_map))))))
      (set_css_var "--main-app-font"  ;; if we find a face from the css var in the lookup, replace it with the value
         (join ","
            (for (face (each (split_by "," (get_css_var "--main-app-font")) trim))
                 (= face (replace replacer "" face))
                 (aif (prop lookup face)
                      it
                      face))))
      
      ;; in some cases we can have weird scroll behavior for scrollTop 
      ;; these are precautionary
      (set_prop (get_by_id "juno_container")
                `scrollTop 0)
      (set_prop (get_by_id "body")
                `scrollTop 0)
      true)
   { description: (+ "This function, which takes no arguments, checks the window object\'s "
                     "devicePixelRatio, and if determined to have a ratio greater "
                     "than `application.fonts.device_pixel_ratio` in `*env_config*`, adjusts "
                     "the `--main-app-font` variable for a replacement higher density font.  This is "
                     "done via the lookup table in `application.fonts.dpi_map`.  The first entry is "
                     "the lower dpi font, and the second entry is the font to use in a high dpi "
                     "setting.  These value will override the css settings by default if set. ")
     usage: []
     tags: [ "ui" "dpi" "UI" "DOM" "resolution" "display" "density" "font" "css"]
     })

(defun dpi_change_listener ()
   (let
      ((media_query_string nil)
       (media nil))
      ;(declare (function *dpi_change_listener*))
      (progc
         (when *dpi_change_listener*
            (*dpi_change_listener*))
         (= media_query_string
            (+ "(resolution: " window.devicePixelRatio "dppx)"))
         (= media (matchMedia media_query_string))
         (-> media `addEventListener "change" dpi_change_listener)
         (= *dpi_change_listener*
            (fn ()
               (-> media `removeEventListener "change", dpi_change_listener)))
         (dispatch_event { `command: "dpi_change"
                           `source: "dpi_change_listener"
                           `args: [ window.devicePixelRatio ] })
         (adjust_for_display_density)
         true))
   {
       description: (+ "Installed at boot, listens for media change events on " 
                       "resolution dppx, and calls the adjust for display density function.")
       usage: []
       tags: [ `dpi `UI `display `density ]
   })

;; seedling_ready is called when the IDE is fully loaded.
;; you can put your custom startup code in here

(defun seedling_ready ()
  (progn
     (if is_served? 
        (log (div "The environment is running from a service:"
                  (span { `style: "padding-left: 10px; color: var(--type-function-color)" }
                       (try
                          (rblock *env_config*.build)
                          (catch Error (e)
                             "Not Identified")))))
        (log (div "The environment is running in local mode.")))
     (when is_served?
        (defvar click_span (span { `class: "juno-tag" } `set_file_system_root))
        (log (div "The current file service root is: " (get_file_system_root)))
        (log (div "Use " click_span " to change the file service root directory."))
        (attach_event_listener click_span `click
           (fn (e)
              (progn
                 (notify "clicked")
                 (show_help_panel)
                 ;(-> (get_control_by_name "Juno Documentation - Frame 0") `search_by_tag "set_file_system_root")
                 ;(sleep 0.1)
                 (-> (get_control_by_name "Juno Documentation - Frame 0") `show_documentation "set_file_system_root")
                 ))))
     (notify (+ "In namespace " *namespace* ))))


(defun user/*initializer* ()
  (let
      ((header nil)       
       (scripts (-> (page_header) `querySelectorAll "script[id]"))                     
       (scratch_editor nil)
       (page_frame nil)
       (control nil)
       (temp_editable nil)
       (key_mode (get_operating_platform))
       (repl_split nil))
                                                               
    (console.log "user/*initializer* is running." )
    (console.log (sort (symbols)))
    (= *last_focus* nil)
    
    ;(defglobal main_menu_button (li  { `class: "juno-menu-header" }
     ;                                        (span { `class: "juno-menu-item" `style: "" } "File")))

    (defglobal resource_loader_button (file_picker_button "" load_files))    
    (set_style [["position" "absolute"]
                ["top" "-100px"]
                ["left" "-100px"]
                ["width" "1px"]
                ["height" "1px"]] resource_loader_button)
    
    (-> (get_by_id "body") `appendChild resource_loader_button)
    
    ;; this may be a bit of a hack - but it seems that the first editable div sets the template 
    ;; (at least in chrome) for what newly inserted elements are to be modeled as..
    (= temp_editable (div { `contentEditable: true `style: "display: inline-block;" `id: "temp" } ""))
    (-> (get_by_id "body") `appendChild
        temp_editable)
    (-> temp_editable `remove)
    (defvalue $root_controls [])
    
    (when (resolve_path [ `ace `config] globalThis)
       (-> ace.config `set `basePath "/files/js_lib/editor-assets"))
    
    
    ;; the root container which controls are added to..
    (defglobal juno_container
      (div { `id: "juno_container" `style: "height: inherit; width: inherit; position: relative; overflow:hidden;" }))
    (console.log "user/*initializer*: juno_container is: " juno_container)
    
    (set_prop *env_config*.editor
       `extensions_to_mode
       {
         `js: `javascript
         `lisp: `juno
         `md: `markdown
         `txt: `text
         })
    
    (set_path [ `definitions `ace ] Environment
            { `description: "The Ace Editor - see https://ace.c9.io for details"
              license: (join "\n"
                          ["Copyright (c) 2010, Ajax.org B.V."
                           "All rights reserved."
                           ""
                           "Redistribution and use in source and binary forms, with or without"
                           "modification, are permitted provided that the following conditions are met:"
                           "    * Redistributions of source code must retain the above copyright"
                           "      notice, this list of conditions and the following disclaimer."
                           "    * Redistributions in binary form must reproduce the above copyright"
                           "      notice, this list of conditions and the following disclaimer in the"
                           "      documentation and/or other materials provided with the distribution."
                           "    * Neither the name of Ajax.org B.V. nor the"
                           "      names of its contributors may be used to endorse or promote products"
                           "      derived from this software without specific prior written permission."
                           ""
                           "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"
                           "ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"
                           "WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"
                           "DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY"
                           "DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"
                           "(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"
                           "LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"
                           "ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"
                           "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"
                           "SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. "])
              })
    
    (setup_drop_file (get_by_id "body") 
                 load_files
                 {
                   on_drag_enter: (fn (files e)
                                     (progn
                                        (setTimeout (fn ()
                                                       (aif (get_by_id "drop_ok")
                                                            (-> it `remove)))
                                                    2500)
                                        (sleep 0.1) ;; a delay allows any drag_leave events to clear first
                                        (unless (get_by_id "drop_ok")
                                           (-> (get_by_id "body")
                                               `append (div { id: "drop_ok" style: "font-size: 2.0em; position: absolute; top: 45%; left: 45%; background: var(--highlight-bg-color); color: var(--highlight-color); padding: 5px; box-shadow: 2px 3px 8px 0px #00000040;" }
                                                            "Drop To Import Files")))))
                   on_drag_leave: (fn (files e)
                                     (progn
                                        (aif (get_by_id "drop_ok")
                                             (-> it `remove))))
                 })
    
    (attach_event_listener juno_container `click
                           (fn (e)
                             (progn
                              (defvar menu (get_by_id `cmenu))
                              (when menu (-> menu `remove)))))
    
    (set_prop *env_config*.export
	      `save_path
	      nil)
            
    (attach_event_listener juno_container
                           `focusin
                           (fn (e)
                             (process_focus_chain e)))

    (-> (get_by_id "body") `appendChild juno_container)
    (console.log "user/*initializer*: validating juno_container is mounted to dom: " (get_by_id "juno_container"))
    (when (not (get_by_id "juno_container"))
        (-> (get_by_id "body")
            `append (div "ERROR: unable to find juno_container mounted"))
        (throw Error "Juno Container isn't mounted: unable to find juno_container"))
        
    (install_color_scheme_detector)
    (when (get_default ["application" "color_scheme" "follow_desktop_preference" ])
       (cond 
          (prefers_dark_theme?)
          (aif (get_default ["application" "color_scheme" "dark_theme" ])
               (set_global_theme it))
          else
          (aif (get_default ["application" "color_scheme" "light_theme" ])
               (set_global_theme it))))
    
    
    (set_prop *formatting_rules*
       `allocating_forms {
                           `let: (fn (tree)
                                    (progn
                                       (flatten (list (resolve_multi_path [ 1 `* 0 ] tree)))))
                           `defun: (fn (tree)
                                      (progn
                                         (conj (list (resolve_path [ 1 ] tree))
                                               (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defun_sync: (fn (tree)
                                           (progn
                                              (conj (list (resolve_path [ 1 ] tree))
                                                    (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defmacro: (fn (tree)
                                         (progn
                                            (conj (list (resolve_path [ 1 ] tree))
                                                  (flatten (list (resolve_path [ 2 ] tree))))))
                           `function: (fn (tree)
                                         (flatten (list (resolve_path [ 1 ] tree) )))
                           `fn: (fn (tree)
                                   (flatten (list (resolve_path [ 1 ] tree) )))
                           `lambda: (fn (tree)
                                       (flatten (list (resolve_path [ 1 ] tree) )))
                           `destructuring_bind: (fn (tree)
                                                   (progn
                                                      (flatten (list (resolve_path [ 1 ] tree)))))
                           `defvar: (fn (tree)
                                        (flatten (list (prop tree 1))))
                           `for_each: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `for_with: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `reduce: (fn (tree)
                                       (list (resolve_path [ 1 0 ] tree)))
                           `reduce_sync: (fn (tree)
                                            (list (resolve_path [ 1 0 ] tree)))
                           `defglobal: (fn (tree)
                                          (list (prop tree 1)))
                           `defparameter: (fn (tree)
                                             (list (prop tree 1)))
                           
                           })
    
    
    ;; initialize or rehydrate the controls
    (if (== (length *serialized_controls*) 0)
      (progn       
       (console.log "initializing control surface")
       ;; take in the global default theme, but don't impact the setting for the sub themes
       (set_global_theme *env_config*.application.global_theme { `suppress_set_sub_theme: true `suppress_cascade: true })
       (defglobal $repl (visual_repl { `name: "Juno REPL"  `display_options: { `show_timestamps: false }}))
       (try
         (= scratch_editor
            (text_editor { name: "*scratch*" 
                          namespace: "user" 
                          path: [ `*scratch* ] 
                          mode: `juno }))
         (catch Error (e)
           (console.error "error on constructing scratch editor: " e)))

       (push *main_menu*   ;; using a wrapper function allows us to change the menu more dynamically
             [ (dtext "File") 
              (fn ()
                 (gen_file_menu))])
       
       (push *main_menu*   ;; using a wrapper function allows us to change the menu more dynamically
             [ (dtext "Edit") 
              (fn ()
                 (gen_edit_menu))])
       
       (push *main_menu*            
             ["View" (fn ()
                        (gen_controls_menu))])
       (push *main_menu*
             ["Layout"
               (fn ()
                  (gen_layout_menu))])
       (push $root_controls
             (app_header [(app_menu [ `*main_menu* ])]
                         { `app_title: "Seedling" }))
       
       (setq page_frame ;; or surface which can be named in the upper right or middle
             (control_container nil {                                     
                                     `root_frame: true
                                     }))

       
       (set_prop *key_bindings*.global
                 "open_new_buffer" { win: "Alt-Shift-Enter"
                                     mac: "Command-Enter"
                                     description: "New Juno Buffer"
                                     exec: (fn () (new_buffer { content: "" type: "juno" }))
                                    }
                 "open_new_text_buffer" { win: "Ctrl-Alt-Enter"
                                     mac: "Command-Shift-Enter"
                                     description: "New Juno Text Buffer"
                                     exec: (fn () (new_buffer { content: "" type: "text" }))
                                    }
                 "juno_remote_repl" { win: "Alt-Shift-2"
                                     mac: "Command-Shift-2"
                                     description: "Juno Remote Repl"
                                     exec: (fn (e) (new_juno_repl { `remote_repl: (+ ""
                                                                                     (if (starts_with? "https" window.location.protocol)
                                                                                         "wss://"
                                                                                         "ws://")
                                                                                     window.location.host 
                                                                                     "/connect_repl") }))
                                    }
                 "juno_repl" { win: "Alt-Shift-1"
                               mac: "Command-Shift-1"
                               description: "Juno REPL"
                               exec: (fn (e) (new_juno_repl))
                               }
                 "save_file" { win: "Ctrl-S"
                               mac: "Command-S"
                               description: "Save File"
                               exec: (fn () (save_active_buffer))                              
                              }
                 "open_file" { win: "Ctrl-O"
                               mac: "Command-O"
                               description: "Open File"
                               exec: (fn () (edit_file))
                              }
                 "server_file" { win: "Ctrl-N"
                               mac: "Command-N"
                               description: "New File"
                               exec: (fn () (new_file))
                              }
                 "toggle_documentation" { win: "Shift-Escape"
                                        mac: "Shift-Escape"
                                        description: "Show Help Panel"
                                        exec: (fn () 
                                                 (toggle_help_panel)) }
                 "search_documentation" { win: "Alt-H"
                                          mac: "Alt-H"
                                          description: "Search Documentation"
                                          exec: (fn () 
                                                  (show_help_panel true)) }
                 
                 "lookup_symbol_definition" {
                                              win: "Alt-Shift-L"
                                              mac: "Alt-Shift-L"
                                              description: "Lookup Symbol Definition"
                                              exec: jump_to_symbol_definition
                                              }
                 "save_environment" { win: "Ctrl-Shift-S"
                                      mac: "Command-Shift-S"
                                      description: "Saves the current state of the application"
                                      exec: (fn () (save_control_image true))
                                     } 
                 "next_hidden_control" { win: "Alt-Shift-Period"
                                         mac: "Command-Shift-Period"
                                         description: "Next Hidden Control"
                                         exec: (fn () (next_hidden_control))
                                         }
                 "go_to_line_number" {
                                       description: "Go to specicic line number in a text editor"
                                       win: "Alt-Shift-G"
                                       mac: "Alt-Shift-G"
                                       exec: (fn ()
                                                (if (prop *last_focus* `editor)
                                                   (go_to_line_number *last_focus*)
                                                   (notify "Cannot go to a line number")))
                                       }
                 "go_backward_in_position" {
                                       description: "Go backward in the current editor position history"
                                       win: "Alt-BracketLeft"
                                       mac: "Command-BracketLeft"
                                       exec: (fn ()
                                                (when (prop *last_focus* `step_backward_in_pos_history)
                                                   (-> *last_focus* `step_backward_in_pos_history)))
                                       }
                 "go_forward_in_position" {
                                       description: "Go forward in the current editor position history"
                                       win: "Alt-BracketRight"
                                       mac: "Command-BracketRight"
                                       exec: (fn ()
                                                (when (prop *last_focus* `step_forward_in_pos_history)
                                                   (-> *last_focus* `step_forward_in_pos_history)))
                                       }
                 "prior_hidden_control" { win: "Alt-Shift-Comma"
                                          mac: "Command-Shift-Comma"
                                          description: "Prior Hidden Control"
                                          exec: (fn () (next_hidden_control true))
                                          }
                 "next_displayed_control" { win: "Alt-Period"
                                            mac: "Command-Period"
                                            description: "Next Displayed Control"
                                            exec: (fn () (next_displayed_control))
                                            }
                 "split_vertically" {
                                       win: "Ctrl-Backslash|Alt-3"
                                       mac: "Ctrl-Backslash|Alt-3"
                                       description: "Split the current control to the right"
                                       exec: (fn () (split_control `vertical))
                                      }
                 "split_horizontally" {
                                       win: "Alt-Backslash|Alt-2"
                                       mac: "Alt-Backslash|Alt-2"
                                       description: "Split the current control downward"
                                       exec: (fn () (split_control `horizontal))
                                      }
                 "move_control_to_new_layout" {
                                                win: "Alt-4"
                                                mac: "Alt-4"
                                                description: "Move the currently focused control to new layout"
                                                exec: (fn () (move_control_to_new_layout *last_focus*))
                                                }
                  "close_panel" {
                                       win: "Alt-0"
                                       mac: "Alt-0"
                                       description: "Close the currently focused panel and put the control into the holding tank."
                                       exec: (fn () (hide_control *last_focus*))
                                      }
                  "close_control" {
                                       win: "Alt-D"
                                       mac: "Alt-D"
                                       description: "Close (Destroy) the control in the currently focused panel."
                                       exec: (fn () (hide_control *last_focus* true true))
                                      }
                  "hide_others" {
                                  win: "Alt-1"
                                  mac: "Alt-1"
                                  description: "Hide all controls in the current layout except for the currently focused control."
                                  exec: (fn () (hide_others_in_layout *last_focus*))
                  }
                  "evaluate_and_replace_at_point" {
                                                    mac: "Command-R"
                                                    win: "Alt-R"
                                                    description: "Evaluate the selected text, or text prior to the form and replace with the results if not nil"
                                                    exec: (fn ()
                                                             (evaluate_and_replace_at_point))
                                                    }
                  "evaluate_and_append_at_point" {
                                                   mac: "Command-Shift-R"
                                                   win: "Ctrl-Alt-R"
                                                   description: "Evaluate the selected text, or text prior to the form and append with the results if not nil"
                                                   exec: (fn ()
                                                            (evaluate_and_replace_at_point { `append: true }))
                                                   }
                  "edit_description_text" {
                                            win: "Alt-E"
                                            mac: "Command-E"
                                            description: "Edit the description text in the DOM editor"
                                            exec: (fn () (edit_description_text))
                                            }
                  "clear_repl_output" {
                                        win: "Alt-Shift-K"
                                        mac: "Command-Shift-K"
                                        description: "Clears the system repl output pane."
                                        exec: (fn () (clear_log))
                                        }
                  "select_all" {
                      win: "Ctrl-A"
                      mac: "Command-A"
                      description: "Select all contents of the current editor"
                      exec: (fn ()
                               (select_all_for_control))
                  }
                  "copy" {
                            win: "Ctrl-C"
                            mac: "Command-C"
                            description: "Copies the current selection"
                            exec: (fn (e) (handle_clipboard_event `copy e))
                            }
                  "cut" {
                          win: "Ctrl-X"
                          mac: "Command-X"
                          description: "Copy the current selection and remove from document"
                          exec: (fn (e) (handle_clipboard_event `cut e))
                          }
                  "paste" {
                            win: "Ctrl-V"
                            mac: "Command-V"
                            description: "Copy the current selection and remove from document"
                            exec: (fn (e) (handle_clipboard_event `paste e))
                            }
                  "undo" {
                            win: "Ctrl-Z"
                            mac: "Command-Z"
                            description: "Attempt to undo the last operation"
                            exec: (fn (e) (attempt_undo))
                            }
                  "redo" {
                            win: "Ctrl-Shift-Z"
                            mac: "Command-Shift-Z"
                            description: "Attempt to redo the last operation"
                            exec: (fn (e) (attempt_redo))
                            }
                  "jump_to_control" {
                      win: "Alt-J"
                      mac: "Command-J"
                      description: "Allows the user to quickly select the control or layout to move to"
                      exec: jump_to_control
                  }
                  "find" {
                           win: "Ctrl-F"
                           mac: "Command-F"
                           description: "Search the current focused control or area."
                           exec: (fn (e k)
                                     (global_search_dispatch e k))
                     }
                  "find_next" {
                                `win: "Ctrl-G"
                                `mac: "Command-G"
                                `description: "If active, move to the next search result"
                                `exec: (fn (e k)
                                          (global_search_next_dispatch e k))
                                }
                  "find_prior" {
                                 `win: "Ctrl-Shift-G"
                                 `mac: "Command-Shift-G"
                                 `description: "If active, move to the prior search result"
                                 `exec: (fn (e k)
                                           (global_search_prior_dispatch e k))
                                 }
                  "close_peripheral" {
                                 `win: "Escape"
                                 `mac: "Escape"
                                 `description: "Closes any periphery element such as a menu or search box"
                                 `exec: (fn (e k)
                                           (close_periphery e k))
                                 }
                  "frame_0" {
                              win: "Ctrl-1"
                              mac: "Command-1"
                              description: "Jump to frame 0"
                              exec: (fn (e) (jump_to_frame_0))
                              }
                  "make_named_layout" {
                              win: "Alt-Shift-L"
                              mac: "Command-Shift-L"
                              description: "Make a new named layout from the current frame"
                              exec: (fn ()
                                       (progn
                                          (make_named_layout_interactive)))
                              })
       
       ;; the execs are nil because the editor will use the key of the object to assign the correct
       ;; internal function
       
       (set_prop *key_bindings*.editor
                 "evaluate_selection" { win: "Shift-Enter"
                                        mac: "Shift-Enter"
                                        description: "Evaluate the current selected text"
                                        exec: nil
                                       }
                 "on_save" {  description: "Invokes save for the currently focused control"
                              win: "Ctrl-s"
                              mac: "Command-s"
                              exec: nil
                            }
                 "increase_font_size" {
                                       description: "Increase the font size of the current editor"
                                       win: "Ctrl-Shift-="
                                       mac: "Ctrl-Shift-="
                                       exec: nil
                                       }
                 "decrease_font_size" {
                                       description: "Decrease the font size of the current editor"
                                       win: "Ctrl-Shift--"
                                       mac: "Ctrl-Shift--"
                                       exec: nil
                                       }
                 
                 "select_form_root" {
                                     description: "select_form_root"
                                     win: "Ctrl-Shift-Enter"
                                     mac: "Ctrl-Shift-Enter" 
                                     exec: nil }
                 "select_current_form" {
                                        description: "select_current_form"
                                        win: "Ctrl-Enter"
                                        mac: "Ctrl-Enter" 
                                        }
                 "evaluate_root_form" {
                                        description: "Evaluates the current form at the cursor position."
                                        win: "Alt-C"
                                        mac: "Alt-C"
                                        exec: nil
                                        }
                 "indent_current_row" {
                                       description: "Indent the row at the cursor position"
                                       win: "tab"
                                       mac: "tab"
                                       exec: nil
                                       }
                 "jump_to_local_definition" {
                                              description: "Jump to the local definition"
                                              win: "Alt-Shift-J"
                                              mac: "Alt-Shift-J"
                                              exec: nil
                                              })
       
       
                 
       (-> juno_container
           `append page_frame.view)

       (-> page_frame `initialize)
       
       (-> page_frame `set_content 0
           (split_view_vertical scratch_editor
                                $repl))
       
       (console.log "initializer: *last_top_frame*: " *last_top_frame*)
       
       (push $root_controls page_frame)
       ;; the holding tank contains the controls  that are still needed but not
       ;; presently displayed 
       (push $root_controls (control_holding_tank [] {}))
       
       (-> scratch_editor
           `set_evaluator_control $repl)
       
       (when (blank? (prop *env_config*.export `save_prefix))
         (set_prop *env_config*.export
                   `save_prefix
                   "seedling"))
       (register_event_handler nil "open_definition" "open_symbol_definition" 
                               (fn (event)
                                  (apply open_symbol_definition event.args)))
       
       ;; setup the iframe communications 
       (if (in_iframe?)
           (register_event_handler nil "exec" "executor"
                                   (fn (event)
                                      (if (in_iframe?)
                                          (-> window.top `postMessage (JSON.stringify { source: "executor" command: "result" 
                                                                                        args: (progn
                                                                                                 (defvar result
                                                                                                    (try
                                                                                                       (eval (second event.args))
                                                                                                       (catch Error (e)
                                                                                                          e)))
                                                                                                 (list (first event.args)
                                                                                                       result
                                                                                                       (if (is_error? result)
                                                                                                           {
                                                                                                               type: (sub_type result)
                                                                                                               message: result.message
                                                                                                           })))
                                                                                                          })))))
           (register_event_handler "executor" "result" "executor_result"
                           (fn (event)
                              (let
                                 ((resolver nil)
                                  (pid nil))
                                 (declare (function resolver))
                                 ;(log "event.args: " event)
                                 (when event.args
                                    (= pid (first event.args))
                                    (when (prop *ipc_promise_ids* pid)
                                       (clearTimeout (second (prop *ipc_promise_ids* pid)))
                                       (= resolver (first (prop *ipc_promise_ids* pid)))
                                       (delete_prop *ipc_promise_ids* pid)
                                       (resolver (second event.args))))))))
       
       (setup_bootstrap_handler)
       
       
       (-> juno_container
           `append page_frame.view)
       (-> (control_holding_tank) `add_control (juno_documentation))
       (-> page_frame `initialize)
       (about_seedling))
      (try     
         (progn
            (console.log "serialized controls: " *serialized_controls*)
            (rehydrate_controls juno_container *serialized_controls*)
            (if (in_iframe?)
                (register_event_handler nil "exec" "executor"
                   (fn (event)
                      (if (in_iframe?)
                          (-> window.top `postMessage (JSON.stringify { source: "executor" command: "result"
                                                                        args: (progn
                                                                                 (defvar result
                                                                                    (try
                                                                                       (eval (second event.args))
                                                                                       (catch Error (e)
                                                                                          e)))
                                                                                 (list (first event.args)
                                                                                       result
                                                                                       (if (is_error? result)
                                                                                           {
                                                                                             type: (sub_type result)
                                                                                             message: result.message
                                                                                             })))
                                                                        })))))
                (try
                   (register_event_handler "executor" "result" "executor_result"
                      (fn (event)
                         (let
                            ((resolver nil)
                             (pid nil))
                            (declare (function resolver))
                            ;(log "event.args: " event)
                            (when event.args
                               (= pid (first event.args))
                               (when (prop *ipc_promise_ids* pid)
                                  (clearTimeout (second (prop *ipc_promise_ids* pid)))
                                  (= resolver (first (prop *ipc_promise_ids* pid)))
                                  (delete_prop *ipc_promise_ids* pid)
                                  (resolver (second event.args)))))))
                   (catch Error (e)
                      (console.log "executor/result is already registered: " e.message)))))
         (catch Error (e)
            (progn
               (console.error "Unable to initialize: " e)
               (dispatch_event { `command: "initialization_error" source: "rehydrate_controls" args: [(current_namespace) e.message *serialized_controls*] })
               (-> juno_container 
                   `append (div { `class: "juno-error" } 
                                (div "Unable to initialize from serialized controls: " 
                                   e.message)
                                (div "See console for error stack trace")
                                (div "Serialized Controls: ")
                                (pre
                                   (pretty_print *serialized_controls*))))))))
    
    (unless (get_control_by_name "Holding Tank")
       (progn
          (push $root_controls (control_holding_tank [] {}))
          (get_control_by_name "Holding Tank")))
    
    (sleep 0.1)
    (default_focus)
    ;; setup key bindings
    (set_prop *key_bindings*
              `active
              {})  ;; reset out and copy
    (for_each (desc (values (prop *key_bindings* `global)))
       (progn
          (for_each (key_combo (split_by "|" (prop desc key_mode)))
             (set_prop *key_bindings*.active
                key_combo
                (prop desc `exec)))))

     (attach_event_listener juno_container
                           `click
                           (fn (e)
                             (handle_app_click_event e)))
    
    (attach_event_listener (first (get_by_tag `body))
                           `keydown
                           (function (e)
                              (handle_app_key_down_event e)))
    
    (attach_event_listener document
       `blur
       (fn (event)
          (progn
             (setq *document_focused* false)
             (dispatch_event { command: "blur"
                               source: "document"
                               args: [ ] }))))
    (attach_event_listener document
       `focus
       (fn (event)
          (progn
             (setq *document_focused* true)
             (dispatch_event { command: "focus"
                               source: "document"
                               args: [ ] }))))
    
    (set_display_name (or (get_default ["application" "display_name"])
                          (get_default ["application" "name"]))
                      (and (== globalThis.navigator.platform "Win32")
                           (== (prop (get_app_args) `app_mode) "true")))
    
    (adjust_for_display_density)
    
    (try 
       (aif (-> (prop (new URL window.location) `searchParams) `get "theme")
            (when (not (blank? it))
               (set_global_theme it)))
       (catch Error (e)
          (console.log "user/*initializer*: no theme passed - using default")))
    
    (set_prop window `onmessage
       (fn (e)
          (progc
             (let
                ((data (JSON.parse e.data)))
                (if (and (is_object? data)
                         data.command)
                    (progn
                       (if (not (in_iframe?))
                           (set_prop data
                              `child_frame true)
                           (set_prop data
                              `child_frame false))
                       (dispatch_event data))
                    (progn
                       (log "window.onmessage: received invalid message: " e)))))))
                       
    (try
       (register_event_handler nil "notify_error"
                               "standard_error_notifier"
                               standard_error_notifier)
       (catch Error (e)
          (console.log e.message)))
    (dpi_change_listener)
    (dispatch_event { command: "complete" source: "initializer" args: [ (current_namespace) ] })
    (try
       (aif (get_default [ `application `on_ready ] )
            (aif (and (is_string? it)
                      (get_global it nil))
                 (if (is_function? it)
                     (it))))
       (catch Error (e)
          (log_error "Error when calling application.on_ready default:" e)))
              
   
    true))






