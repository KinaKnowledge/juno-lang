;; TODO: SPLIT UP INTO SEPARATE FILES - TOO LARGE 
;; main browser initialization file - initializes the user browser environment
;; after the browser_workspace has setup the underlying environment

(defglobal main_menu_button nil) ;; placeholders 
(defglobal resource_loader_button nil)
(defglobal juno_container nil)
(defglobal repl_editor nil)
(defglobal *scratch* ";; *scratch* buffer\n\n")
(defvalue *key_bindings* {
                           repl:{}
                           editor:{}
                           global:{}
                           active: {}
                           })



(defvalue *main_menu* [])
(defvalue *serialized_controls* [])

(defparameter core/$current_control nil)

;; the controls at the top level of the view
(defparameter core/$root_controls [])

(defparameter core/*system_repl* nil)

(console.log "browser_initializer running")

;; the global pointer to the control which has focus
;; nil if there are no focus points or values.

(defparameter core/is_served? (not (blank? (resolve_path [ `location `hostname ] window))))
(defparameter filesystem {})
(defparameter *last_focus* nil)
(defparameter *last_top_frame* nil)
(defparameter *app_menu_control* nil)
(defparameter *log_key_events* false)

(defparameter *whitespace_regexp* (new RegExp "\\\\s" `g))

(defparameter TokenIterator (function () true)) ;; filled in by the first editor

(defparameter
    *editor_themes*
    (reduce (included_lib (or *env_config*.included_libraries []))
        (aif (starts_with? "theme" included_lib)
            (second (split_by "-" (first (split_by "." included_lib)))))))

(set_prop *key_bindings*.repl          
          `history_next_entry { win: "Ctrl-Alt-n" mac: "Ctrl-Alt-n" }                                                               
          `history_prior_entry { win: "Ctrl-Alt-p" mac: "Ctrl-Alt-p" })

(create_css_entry "td.juno-obj-to-dom-key"
                  [["vertical-align" "top"]
                   ["color" "#881280"]
                   ["text-align" "right"]
                   ["font-weight" "bold"]
                   ["padding-right" "5px"]])





;;(create_css_entry "span.juno-value"
 ;;                 [["display" "inline-block"]])
   
;;(create_css_entry "li.juno-array-item"
;;                  [["list-style" "decimal"]])   
 
;; for determining keycodes
(defun get_operating_platform ()
    (if (contains? "Macintosh" navigator.userAgent)
        "mac"
        "win"))
      

(defun_sync value_to_dom (val options _path)
  (let 
      ((classes "juno-value juno-type-")
       (options (or options {}))
       (elem nil)
       (_path (or _path [] ))
       (lpath (function () (join "~" _path))))
    (declare (function array_to_dom obj_to_dom function_to_dom)
             (global array_to_dom obj_to_dom function_to_dom))
    (= elem
       (cond 
         (is_array? val)
         (array_to_dom val options _path)
         (is_element? val)
         (progn
          (if val.parentElement
            (details
             (summary (+ {} (if options.namespace
                               { ns: options.namespace }
                               {})
                         { `lpath: (lpath) 
                           `class: (+ classes "view") 
                           `tabindex:0 }) 
                      (+ (sub_type val) " "))
             (span { `tabindex: 0 `style: "font-family: var(--main-app-font)" } "[ RENDERED ELEMENT ]"))
            val))
         (is_regex? val)
         (span (+ {} (if options.namespace
                         { `ns: options.namespace }
                         {})
                  { `lpath: (lpath) 
                    `tabindex: 0  
                    `class: (+ classes "regexp") }) 
               (-> val `toString))
         (is_string? val)
         (if (starts_with? "=:" val)
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0  `class: (+ classes "symbol") } )
                 (JSON.stringify val))
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0 `class: (+ classes "string") }) 
                 (JSON.stringify val)))
         
         (instanceof val Error)
         (details (summary { `class: (+ classes "error") } 
                           (span { `tabindex: 0 `class: (+ classes "error") `style: "margin-left: 5px; font-style: italic;" } val.name " " val.message))
          (if val.details  ;; there is a details rider on this error from the compiler, print it
              (value_to_dom val.details)
              (progn
                 (defvar tmp (pre { `tabindex: 0 `class: (+ classes "error") }))
                 (set_prop tmp `innerHTML (join "\n" (rest (split_by "\n" val.stack))))
                 tmp)))
         (is_function? val)
         (function_to_dom val options _path)
         (is_object? val)
         (obj_to_dom val options _path)          
         else
         (span  (+ {} (if options.namespace { `ns: options.namespace } {}) 
                   { `lpath: (lpath) `tabindex: 0 `class: (+ classes (lowercase (sub_type val))) }) 
               val)))
    elem))  

(defun_sync function_to_dom (val options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (lowercase (subtype val)))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } (-> val `toString)))))
    (assert (is_function? val))
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              (aif (fn_signature val)
                                   (if (== it.type "class")
                                     (+ "class " it.name)                                            
                                     (+ (if (== it.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " it.args)
                                        "))")))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem))
    
(defun_sync remote_function_to_dom (fdesc options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (cond
                 (== fdesc.type "async")
                 "asyncfunction"
                 (== fdesc.type "sync")
                 "function"
                 else
                 fdesc.type))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } fdesc.body))))
      (assert (is_object? fdesc) "remote_function_to_dom requires an object from fn_signature")
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              
                                   (if (== ftype "class")
                                     (+ "class " fdesc.name)                                            
                                     (+ (if (== fdesc.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " fdesc.args)
                                        "))"))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem))
                   
       
       
       

(defun_sync array_to_dom (arr options _path)
    (let
        ((total_len arr.length)
         (_path (or _path []))
         (lpath (function () (join "~" _path)))
         (options (or options {}))
         (expanded false)
         (expansion_mode false)
         (detail_elem nil)
         (expansion_elem nil)
         (idx -1)
         (segment_size 10)
         (new_row_elem [])
         (render_array (function ()
                           (ol { `lpath: (lpath) `start: 0 `class: "juno-type-array" } 
                             (progn 
                                (for_each (val arr)
                                    (progn
                                        (inc idx)
                                        (li { `class: "juno-array-item" } 
                                            (value_to_dom val options (conj _path [idx])))))))))
         (row_elem []))
      (assert (is_array? arr))
      (when (or (> _path.length 2)
                (> arr.length (or options.expansion_length 30)))
        (= expansion_mode true))
            
      (= detail_elem 
         (details (+ { `class: "juno-type-array" }
                      (if (and (== _path.length 0)
                              (not expansion_mode))
                      { `open: true }
                      {}))
                 (summary { `lpath: (lpath)  `tabindex: 0 }  "Array [" total_len "] ")
                 (if expansion_mode
                     (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                     (render_array))))
     (when expansion_mode
         (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_array))
                                     (= render_array nil)))))
     detail_elem))
           
(defun_sync obj_to_dom (obj options _path)
  (let
      ((options (or options {}))
       (classes "juno-value juno-type-")
       (detail_elem nil)
       (expanded false)
       (expansion_elem nil)
       (expansion_mode false)
       (get_pairs (if options.include_prototypes
                    pairs*
                    pairs))
       (render_table (function () 
                         (table
                            (tbody
                             (for_each (keyval (get_pairs obj))
                                       (destructuring_bind (key value)
                                                           keyval
                                                           (tr 
                                                            (td {  `class: "juno-obj-to-dom-key" } key)
                                                            (td { `class: "juno-obj-to-dom-value" } 
                                                                (value_to_dom value options (conj _path [ key ] ))))))))))
       (_path (or _path []))
       (lpath (function () (join "~" _path))))
    (declare (function get_pairs))
    (when (or (eq nil options.visited)
              (< _path.length 2))
           (set_prop options
                     `visited (new Set)))
    
    (if (-> options.visited `has obj)
        (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "[CIRCULAR]")
        (cond
          (== (length obj) 0)
          (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "Object {}")
          else
          (progn
           (-> options.visited `add obj)    
           (when (> _path.length 2)
             (= expansion_mode true))
           (= detail_elem 
              (details (+ {  `class: "juno-obj-to-dom" }
                          (if (== _path.length 0)
                            { `open: true }
                            {}))
                       (summary { `lpath: (lpath) `class: "juno-obj-to-dom" } obj.constructor.name)
                       (if expansion_mode
                         (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                         (render_table))))
           (when expansion_mode
             (attach_event_listener detail_elem
                                    `toggle
                                    (fn (e) 
                                      (unless expanded
                                              (= expanded true)
                                              (-> expansion_elem `replaceWith (render_table))
                                              (= render_table nil)))))
           detail_elem)))))




(defun copy_text_to_clipboard (text)
        (if text
           (let ((temp (textarea { `style: "position: absolute; top: -100px; left: -200px;"  } )))
               (-> (get_by_id "body") `append temp)
               (set_prop temp
                         `value
                         text)
               (-> temp `select)
               (-> temp `setSelectionRange 0 999999)
               (-> document `execCommand "copy")
               (-> temp `remove)
               true
            )
            false)
        { `usage: ["text:string"]
          `description:"Copies the provided textual argument to the system clipboard.  It cannot copy more complex types due to security limitations of browser sandboxed code."
          `tags: ["env" "copy" "clipboard" "ui"]
        } )


(defun_sync get_keybinding (category command)
   (aif (resolve_path [category command] *key_bindings*)
        it
        nil)
   {
       description: (+ "Given a category, such as `editor or `global and a command name, "
                        "returns the object with the defined key binding data or nil")
       usage: ["category:string" "command:string"]
       tags: ["key" "binding" "global" "sequence"]
    })

(defun_sync to_ace_keybinding (name keybinding_object fx_to_call)
   { name: name
     bindKey: { win: keybinding_object.win mac: keybinding_object.mac }
     exec: (or fx_to_call keybinding_object.exec) }
   {
       description: (+ "Given a Juno keybinding object with an exec function or an override "
                       "function as the third argument,  returns a keybinding object in a "
                       "format that can be used with the Ace Editor.")
       usage: ["name:string" "keybinding_object:object" "fx_to_call:function"]
       tags: ["key" "binding" "Ace" "editor" "command"]
   })

(defun_sync editor_key_bindings (editor)
   (if editor
      (resolve_path [`commands `commandKeyBinding ] editor)
      nil)
   {
       `description: "Returns current key bindings for the provided ACE editor object."
       `usage: ["editor:object"]
       `tags: ["bindings" "key" "controls"]
   })



(defun edit_mode_for_extension (ext)
   (or (resolve_path [ `editor `extensions_to_mode ext ] *env_config*)
       ext)
   {
       `description: (+ "Maps a file extension (with no period as a prefix) to an editor mode using the " 
                        "*env_config*~editor~extensions_to_mode lookup object. "
                        "If the file extension is found in the lookup, it will return the value, "
                        "otherwise it will return the provided extension back unchanged.")
       `usage: ["ext:string"]
       `tags: ["extension" "files" "type" "mode" "edit" "editor" ]
   })

(defun *help_menu_function* ()
  [["No Help Installed" (fn () false) ]])


(defun log (`& args)
   (progn
      (apply console.log args)
      (aif (-> Environment `get_global "*system_repl*" nil)
           (progn
              (-> it `log (apply div { `style: "display: flex;" } 
                           (for_each (val args)
                              (div { `style: "padding-right: 10px" } (value_to_dom val)))))))
      nil)
   {
       `description: "Logs arguments to the console and the current *system_repl* output.  Returns nil."
       `usage: ["arg0:*" "argN:*"]
       `tags: ["log" "console" "values" "display"]
   })

(defun_sync clear_log ()
   (aif (and *last_focus*
             (prop *last_focus* `clear_output)
             *last_focus*)
        (progn
           (setTimeout (fn ()
                          (-> it `clear_output))
                       5)
           nil))
   {
     `description: "Clears the REPL that is currently focused."
     `usage: []
     `tags: ["log" "console" "clear" "output" "display"]
     })

(defun_sync decorative_usage (symbol_data namespace suppress_type)
  (let
      ((val (if (is_string? symbol_data)
                (cond
                   (starts_with? "(" symbol_data)
                   (-> symbol_data `substr 1)
                   (starts_with? "[" symbol_data)
                   (-> symbol_data `substr 1)
                   else
                   symbol_data)
                symbol_data.name))
       (show_type (function ()
                     (span { `style: "margin-left: 15px; font-style: italic" 
                             `class: (+ "juno-type-" (lowercase (or description.type "")))
                             }
                         (cond 
                            description.macro
                            "Macro"
                            description.type
                            (if suppress_type [] 
                                description.type)))))
       (metadata (if (and (is_object? symbol_data)
                          namespace
                          (not symbol_data.require_ns))
                     [list symbol_data]
                     (meta_for_symbol (trim val) true)))
       
       (description (if (is_object? symbol_data)
                        symbol_data
                        (if namespace
                           (first (reduce_sync (v metadata)
                                     (when (== v.namespace namespace)
                                        v)))
                           (first (or metadata [])))))
       (view nil)
       (is_symbol_binding (if (and description.require_ns
                                   (is_array? description.initializer)
                                   (== description.initializer.0 (quote pend_load)))
                              true
                              false))
       (rval nil))
     
      (when (and is_symbol_binding
                 (is_object? description))
       (set_prop description
          `usage
          (prop (first (reduce_sync (v metadata)
                                    (when (== v.namespace description.require_ns)
                                       v)))
                `usage)))
      (= rval
         (cond
            (is_array? description.usage)
            (div { `style: "display: inline-block"} "("
                 (flatten [(span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                           (for_each (arg description.usage)
                              (destructuring_bind (arg_name arg_type arg_needed)
                                 (split_by ":" arg)
                                 (= arg_type (or arg_type ""))
                                 (span { `class: (+ "juno-type-" (if (starts_with? "?" arg_type)
                                                                     (lowercase (or (chop_front arg_type) ""))
                                                                     (lowercase arg_type))
                                                    " juno-arg-name") `title: arg_type
                                                `style: (if (== arg_needed "required") "text-decoration: underline" "") } arg_name ":" arg_type)
                                 ))])
                 ")" (show_type))
            (is_string? description.fn_args)
            (div { `style: "display: inline-block"} "("
                 (span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                 (for_each (arg_name (split_by " " (chop (rest description.fn_args))))
                    (span { `class: "juno-arg-name" } arg_name))
                 ")" (show_type))
            
            else
            nil))
      rval)
  {
    `usage: ["symbol:string|object" "namespace:?string" "suppress_type:?boolean"]
    `description: (+ "Given a symbol name as a string or an object metadata value (as from describe), returns a DOM element of the usage information.  "
                     "If the usage metadata is defined for the symbol it will use that, otherwise "
                     "if the symbol is a function and has fn_args defined, that content will be returned "
                     "in a DOM element.  Used by the editor to display usage information. ")
    `tags: [ `usage `editor `formatting `help `assist ]
    })

(defun unpack_description (description)
   (let
      ((desc (eval description))
       (rr (new RegExp "<-" `g))
       (subsections []))
       (for_each (seg (split_by "<br>" desc))
          (when (is_string? seg)
             (= seg (replace rr "\\u{279C}"  seg))
             (map (fn (comp i)
                     (if (== 1 (% i 2))
                         (push subsections
                            (pre comp))
                         (push subsections
                            (p comp))))
                  (split_by "%%%" seg))))
       (div
          subsections))
    {
       `usage: ["description:text"]
       `description: "Given a marked up description text, builds the output format for the browser."
       `tags: [ `usage `help `assist `formatted `markup ]
   })

(defun format_help (meta_obj)
   (let
      ((is_symbol_binding (if (and meta_obj.require_ns
                                   (is_array? meta_obj.initializer)
                                   (== meta_obj.initializer.0 (quote pend_load)))
                              true
                              false))
       (imported_usage (first (if is_symbol_binding
                                  (reduce  (v (meta_for_symbol meta_obj.name true))
                                     (when (== v.namespace meta_obj.require_ns)
                                        v))
                                  []))))
      (when imported_usage
         (set_prop meta_obj
            `usage
            (prop imported_usage `usage))
         (set_prop meta_obj
            `tags
            (prop imported_usage `tags)))
            
            
      
      (div { `style: "width: calc(100% - 20px);" }
           (h3 (span { `style: "color: var(--namespace-color); " } meta_obj.namespace ) "/" meta_obj.name
               (if meta_obj.macro
                  (span { `style: "float: right; margin-right: 20px; " } "Macro")
                  (span { `title: "Type" `style: "float: right" `class: (+ "juno-type-" (lowercase meta_obj.type)) } meta_obj.type)))
           (hr { `class: "LightHR" })
           (cond
              (and (contains? `unction meta_obj.type)
                   meta_obj.usage)
              [(h4 "Usage")
               (decorative_usage meta_obj meta_obj.namespace true)]
              (contains? `unction meta_obj.type)
              [(h4 "Arguments")
               meta_obj.fn_args]
              else
              [])
           (if (or meta_obj.description
                   is_symbol_binding)
               [(h4 "Description")
                (if is_symbol_binding
                   (p
                      (div { } "This is a bound symbol into " (span { `style: "color: var(--namespace-color); " }  meta_obj.require_ns)
                           " to " (join " " meta_obj.requires) ".  For more information refer to the core/use_symbols macro and to " (join " " meta_obj.requires) ".")
                      (br))
                   (unpack_description meta_obj.description))]
                [])
              
              (if meta_obj.tags
                 [(h4 "Tags")
                  (for_each (`sym meta_obj.tags)
                     (span {  `style: "margin-right: 5px; padding: 5px;border: 1px solid var(--main-accent-line-hover)"} sym ))]
                 [])
              (if meta_obj.requires
                 [(h4 "Requires")
                  (for_each (`sym (sort meta_obj.requires))
                     (span { `class: (+ "juno-type-" (lowercase (or (prop (describe sym) `type) ""))) `style: "padding: 5px;"} sym ))]
                 []) ))
   {
     `description: (+ "Render object definitions to html.  Given a path "
                      "to Environment.definitions, or the output of the "
                      "describe function, returns a DOM element.")
     `usage: ["meta_obj:object"]
     `tags: [`help `? `usage `info `man `manual ]
     })


(defmacro ? (symname)
   `(let
       ((results (describe ,#(if (starts_with? "=:" symname)
                                 (-> symname `substr 2)
                                 symname) true)))
       (for_each (`meta_obj (or results []))
          (format_help meta_obj)
          ))
   {
       `description: "Given a quoted symbol as an argument, the function returns a formatted manual page for the provided symbol."
       `usage: ["name:quoted_symbol"]
       `tags:["help" "assistance" "man" "usage" "info"]
   })

(defun_sync find_last_paren (editor pos)
   (try
      (let
         ((pos  (or pos (-> editor `getCursorPosition)))
          (stream (indirect_new TokenIterator editor.session pos.row pos.column))
          (done false)
          (depth 0)
          (t nil)
          (comps nil)
          (calc_depth (function (val)
                          (progn
                            (= comps (split_by "" val))
                            (while (> comps.length 0)
                              (progn
                                 (= t (pop comps))          
                               (cond 
                                  (or (== t ")")
                                      (== t "]"))
                                  (inc depth)
                                  (or (== t "(")
                                      (== t "["))
                                  (dec depth)))))))
          (start nil)
          (token nil))
         (while (and (not done)
                     (not start))
            (progn
               (= token (-> stream `getCurrentToken))
               (when (== token.type "keyword")
                  (calc_depth token.value))
               (if (eq token nil)
                   (progn
                      (= done true)
                      (break))
                   (if (and (== token.type "keyword")
                            (or (== token.value.0 "(")
                                (== token.value.0 "[")))
                      (progn
                         (if (<= depth 0)
                             (progn
                                (= start { row: (-> stream `getCurrentTokenRow)
                                               column: (-> stream `getCurrentTokenColumn) })
                                (= done true)
                                (break))))))
                       
               (= token (-> stream `stepBackward))))
         (when start
            (-> editor.session `getBracketRange start)))
      (catch Error (e)
         (progn
            (console.error e)
            nil))))



(defun current_controls (no_subcontrols from_control)
   (let
      ((ctls (uniq (flatten (control_tree (if from_control
                                              [ from_control ]
                                              $root_controls)))))
       (ids nil))
      (if no_subcontrols
         (progn
            (= ids (new Set))
            (reduce (ctl ctls)
               (progn
                  (unless (-> ids `has ctl.options.id)
                     (-> ids `add ctl.options.id)
                     ctl))))
         ctls))
   {
     `usage: ["no_subcontrols:?boolean" "from_control:?control"]
     `description: (+ "Returns an array of all controls in the control tree.  "
                      "If no_subcontrols is true, then composite type contols "
                      "made up of multiple controls will be included in the "
                      "results only as the main control.  Otherwise, the "
                      "subcontrols will also be returned. If from_control "
                      "is a provided control, only controls that are "
                      "contained by that root control will be returned.")
     `tags: ["controls" "active" "tree" "ui"]
     })

(defun all_editor_controls ()
   (reduce (ctl (current_controls))
      (when ctl.editor
         ctl))
   {
       `description: "Returns an array all editor controls in the control_tree."
       `usage: []
       `tags: ["controls" "editors" "active" "ui"]
   })

(defun cascade_resize (top_control)
  (control_tree (or top_control $root_controls)
                (fn (control)
                  (if control.resize
                    (-> control `resize))))
  {
      `usage: ["top_control:?object"]
      `description: (+ "This function invokes the resize methodFor every control " 
                       "in the control tree or from the provided starting control "
                       "and it's child controls.")
      `tags: ["controls" "active" "resize" "ui"]
  })
    

(defun set_global_theme (theme_name options)
   (if (prop *global_themes* theme_name)
       (let
          ((head_elem (-> document `querySelector "head"))
           (existing (get_by_id "juno-css-theme")))
          (if existing
               (-> existing `remove))
          (-> head_elem `append
              (style { `id: "juno-css-theme" `type: "text/css" }
               (prop *global_themes* theme_name)) )
          (set_path [ `application `global_theme ] *env_config* theme_name)
          (when (and (not options.suppress_set_sub_theme)
                     (contains? theme_name *editor_themes*))
             (set_path [ `editor `default_theme ] *env_config* theme_name))
          ;; unless we are told not to, set any controls to the theme
          (unless options.suppress_cascade
              (for_each (control (current_controls))
                        (when (is_function? control.set_theme)
                          (-> control `set_theme theme_name))))
          true)
       (throw ReferenceError "Invalid theme name provided"))
   { `description: (+ "Sets the global theme to the named theme.  Global themes "
                      "values are looked for in *global_themes*.  If a key is found "
                      "in that object, the theme is installed, and the *env_config* "
                      "value is updated to reflect this choice.  Additionally, if an "
                      "editor theme is found with the same name, the default editor "
                      "theme is set as well.  Editor themes are found in the global "
                      "*editor_themes*. <br><br>"
                      "Options are as follows:<br>"
                      "suppress_set_sub_theme:boolean:false:If true, individual control "
                      "themes such as the editor theme setting will not be set as part "
                      "the global theme and will retain their existing settings and "
                      "defaults.<br>"
                      "suppress_cascade:boolean:false:If this value is true, the application "
                      "theme will change, but controls will not be told about it and will "
                      "retain their current settings as they are instantiated with.")
     `tags: ["themes" "environment" "color" "settings"]
     `usage: ["theme_name:string" "options:object"] })

(defun get_control_by_id (id)
  (let
      ((controls (current_controls))
       (ctrl nil))
    (for_each (`control controls)
              (when (== id (and control.options control.options.id))
                (= ctrl control)
                (break)))
    ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the control with the given identifier, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "id" "find" ]
  })

(defun get_control_by_name (name)
  (let
      ((controls (current_controls))
       (ctrl nil))
      (when (is_string? name)
         (for_each (`control controls)
            (progn
               (when (== name control.name)
                  (= ctrl control)
                  (break)))))
      ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the first control with the given name, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "name" "find" ]
  })



(defun select_controls (predicate_func)
  (let
      ((controls (current_controls))
       (acc [])
       (ctrl nil))
    (for_each (`control controls)
        (progn
         (when (predicate_func control)
           (push acc control))))
    acc)
  {
   `description: (+ "Given a predicate function (a function that takes a "
                    "single value and returns a true or false value), tests "
                    "control by passing the control to the predicate and if "
                    "the function returns true, the control will be "
                    "returned in the array.  The function will return all "
                    "controls which tested true.")
   `usage: ["predicate_function:function"]
   `tags: ["selection" "filter" "controls"]
   })



(defun render_control_tree (controls)
   (let
      ((cell_style "border: 1px dashed var(--main-accent-line-hover);")
       (sub_style "border-right: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);")
       (parent_style "border-left: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);"))
      (table { `style: "vertical-align: top; margin: 5px; box-shadow: 1px 1px 4px 1px #00000060; width: calc(100% - 20px);" }
        (cond
           (is_array? controls)
           (for_each (ctl controls)
              (tr { `style: (+ "vertical-align: top;" cell_style) }
               (if (is_function? ctl.controls)
                   [ (td { `control_id: ctl.options.id 
                            style: (+ ""
                                      parent_style
                                      (if (== ctl *last_focus*)
                                          "font-weight: bold; background: var(--control-focused);"
                                          ""))
                            } (or ctl.name (+ "/" ctl.type)))
                    (td { `style: sub_style } (render_control_tree (-> ctl `controls)))]
                   (td { `control_id: ctl.options.id `colspan: 2 
                         `style: (+ "" cell_style (if (== ctl *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) } 
                         (or ctl.name (+ "/" ctl.type))))))
           (is_object? controls)
           (tr { `style: "" }
            (if (is_function? controls.controls)
                [(td { `style: (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "") } controls.name)
                 (td { `control_id: controls.options.id `style: cell_style } (render_control_tree (-> controls `controls)))]
                (td { `control_id: controls.options.id `colspan: 2 
                      `style: (+ "" cell_style (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) }  
                      (or controls.name (+ "/" controls.type))))))))
   {
     usage: ["controls:array"]
     description: (+ "Renders the given controls and their children as a HTML/table " 
                     "representing the hierarchy and the control positions in the tree.")
     tags: [ "ui" "controls" "DOM" "structure" "tree" ]
     })

(defun holding_tank_controls ()
  (aif (get_control_by_name "Holding Tank")
       (-> it `controls)
       [])
  {
      usage: []
      description: "Returns an array of all controls currently stored in the control holding tank."
      tags: ["ui" "controls" "holding" "tank"]
  })

(defun replace_control (target_control new_control)
  (let
      ((tmp (new Object))
       (replaced_keys (new Set)))
    (assert (is_object? target_control) "Invalid object provided for old_control")
    (assert (is_object? new_control) "Invalid object provided for new_control")
    ;; first transfer the old object contents to the new location
    (for_each (k (keys target_control))
              (set_prop tmp
                        k
                        (prop target_control k)))
    
    ;; now tmp has the target_control scope references
    ;; replace the target_control with new values
    (for_each (k (keys new_control))
              (progn
               (-> replaced_keys `add k)
               (set_prop target_control
                         k
                         (prop new_control k))))
    
    ;; now remove any keys that are not in the set from the target_control
    (for_each (k (keys target_control))
              (if (not (-> replaced_keys `has k))
                (remove_prop target_control k)))
    
    ;; the objects should be swapped at this point
    ;; return tmp as the old control
    tmp))



(defun control_for_dom_element (elem)
    (let
        ((control_id nil))
       (assert (is_element? elem) "Invalid element provided")
       (= control_id (-> elem `getAttribute "control_id"))
       (aif (and control_id ;; we have a control_id, so get the control
                 (get_control_by_id control_id))
            it ;; and return it
           (cond
             (eq nil elem.parentElement)
             nil ;; at top (or cannot go up further) so return nil
              
              ;; no control found and we have a parent_element
             else
             (control_for_dom_element elem.parentElement)))))



(defun control_position (control)
    (let
       ((parent_view nil)
        (parent_control_position 0)
        (parent_control nil))
    (assert control.view "target_container isn't a control container")
    (= parent_view control.view.parentElement)
    (when parent_view
        (= parent_control (control_for_dom_element parent_view))
        (when (and parent_control
                   parent_control.controls)
           (map (fn (parental_sub_control idx)
                    (when (== parental_sub_control control)
                        (= parent_control_position idx)))
                (-> parent_control `controls))))
    (aif (and (eq parent_control nil)
              (get_control_by_name "Holding Tank"))
         (if (-> it `has_control? control)
           (= parent_control it)))
      
    {
        `child: control
        `parent: parent_control
        `child_position: parent_control_position
    }))

(defun get_container_for_control (control)
    (let
        ((existing_container nil)
         (pos nil)
         (next_parent nil)
         ;; controls should be in one of these container types
         (valid_containers ["split_view_horizontal" "split_view_vertical" "control_container" ]))
      (assert (and (is_object? control)
                   control.view)
              "Invalid control received")
      (= pos (control_position control))
      
    ;; is the child control (the control passed) a container?
      (cond 
        (and pos.child
           (contains? pos.child.type valid_containers))
        (= existing_container control)
        (and pos.parent
            (contains? pos.parent.type valid_containers))
        (= existing_container pos.parent)
        pos.parent
        (progn
          (while (and pos.parent
                      (not existing_container))
             (progn
                 (= pos (control_position pos.parent))
                 (console.log "pos is now: " pos)
                 (if (and pos.parent
                          (contains? pos.parent.type valid_containers))
                     (= existing_container pos.parent))))))
       
      existing_container))

(defun_sync is_control? (val)
  (and (is_object? val) val.type val.view val.toJSON true)
  {
    usage: "val:object"
    description: "Predicate function which returns true if the provided object tests to be a control."
    tags: ["controls" "ui" "control"]
  })

(defun_sync is_top_control? (control)
  (if (is_control? control)
    (contains? control $root_controls)
    false))

(defun top_frame (control)
  (let
      ((parent nil))
    (declare (local parent))    ;; parent is a global object - shouldn't need to declare this since it has technically already been shadowed
   (assert (is_control? control) "Invalid control provided")
   (= parent (control_position control))
   (while parent.parent
       (= parent (control_position parent.parent)))
   parent.child))

(defun parents_for_control (control)
  (if (and (is_control? control)
           control.view.parentElement)
       (progn
          (defvar parent (control_for_dom_element control.view.parentElement))
          (if (is_top_control? parent)
              [parent]
              (reduce (ctl (flatten [parent (parents_for_control parent)]))
                 ctl)))
       [nil])
  {
   `description: "Given a control, returns an array containing the parent chain, with the last being the top control."
   `usage: ["control:object"]
   `tags: [ `control `controls `position `heirarchy ]
   })


(defun set_focus_to (target_control _controls)
  (let
      ((focused_list (query_all ".juno-focused"))
       (controls (or _controls
                     (reduce (c (current_controls))                        
                        (when c.on_focus                          
                          c)))))
    
    (for_each (control controls)
                 (when (and (or (eq nil target_control)
                                (not (== target_control control)))
                            (is_function? control.on_blur))
                   (-> control `on_blur)))
    
    ;; remove any focus class markers
    (when (> focused_list.length 0)
      (= focused_list (map (fn (v) v) focused_list))       
      (apply remove_class "juno-focused" focused_list))
    (for_each (control controls)
                 (when (and (or (eq nil target_control)
                                (not (== target_control control)))
                            (is_function? control.on_blur))
                   (-> control `on_blur)))
    (when (not (== *last_focus* target_control))
      (when (and *last_focus*
                 (prop *last_focus* `menu_items))
        (-> *app_menu_control* `remove_menu (or (prop *last_focus* `name)
                                                "Control"))))
      
    (if target_control
      (progn
              
       (if target_control.on_focus 
          (-> target_control `on_focus))
       (setq *last_focus* target_control)
       (setq core/$current_control *last_focus*)
       (setq *last_top_frame* (top_frame target_control))
       (when target_control.menu_items
         (-> *app_menu_control* `add_menu [ (or target_control.name
                                                "Control")
                                           target_control.menu_items 
                                           "control_menu"])))
      (progn
       ;(setq *last_focus* nil)
       ))))

(defun default_focus ()
  (let
      ((found_control nil))
    (control_tree $root_controls
                  (fn (control)
                      (when (and (not found_control)
                                 (is_function? control.on_focus))
                        (= found_control control))))
    (if found_control
      (progn
        (set_focus_to found_control)
        found_control)
      nil)))

(defun commands_button (id)
  (button { `control_id: id
            `class: "juno-command-button"
            `title: (dtext "Commands") } "â‹¯"))

(defun focus_to_editor ()
   (progn
      (if (prop *last_focus* `editor)
          (focus_to (prop *last_focus* `editor)))
      *last_focus*))



(defun swap_control (target_control new_control)
  (let
      ((tmp (new Object))
       (position_details_target nil)
       (position_details_new nil)
       (holding_tank (get_control_by_name "Holding Tank"))
       (replaced_keys (new Set)))
    (assert (is_control? target_control) "Invalid control provided for old_control")
    (assert (is_control? new_control) "Invalid control provided for new_control")
    
    (if (== target_control new_control)
        (progn
           (set_focus_to target_control)
           (if target_control.editor
              (focus_to target_control.editor)))
        (progn
           ;; get their position in the tree
           (= position_details_target (control_position target_control))
           (= position_details_new (control_position new_control))
           (console.log "swap_control: target: " target_control "new: " new_control)))
    
    (cond
        (== target_control new_control)
        nil ;; do nothing 
        
        (== position_details_target.parent holding_tank)   ;; target is in the holding tank so take the old control out and replace with new
        (progn
            (-> holding_tank `remove_control position_details_target.child)
            (-> holding_tank `add_control position_details_new.child)
            (if position_details_new.parent.set_content ;; add the targeted control to the new_controls old location (if not in holding_tank)
              (progn
               (-> position_details_new.parent `set_content position_details_new.child_position position_details_target.child)
               (cascade_resize)
               (set_focus_to position_details_target.child)
               (focus_to_editor))
                position_details_target.child))

        (and (== position_details_target.child holding_tank)   ;; target IS the holding tank so replace the holding tank with the new value and hide the holding tank
             position_details_target.parent.set_content)
        (progn
         (-> holding_tank `remove_control position_details_new.child) ;; ensure the child is removed from the holding tank (if in it)
         (-> position_details_target.parent `set_content position_details_target.child_position position_details_new.child)         
         (-> holding_tank `hide)
         (cascade_resize)
         (set_focus_to position_details_new.child))
        
        (and position_details_target.parent.set_content
             position_details_new.parent.set_content)  ;; controls are both in the tree somewhere so swap their positions
        (progn
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> position_details_new.parent `set_content 
                                             position_details_new.child_position 
                                             position_details_target.child)
            (set_focus_to position_details_new.child)
            (cascade_resize)
            (focus_to_editor)
            target_control)
        
        (and (== position_details_new.child holding_tank)
             (is_function? position_details_target.parent.set_content))
        (progn
         (-> holding_tank `add_control position_details_target.child)
         (set_prop holding_tank.options
                   `in_tree
                   true) ;; otherwise the holding tank, if not initialized, will not mount correctly and place itself somewhere in the dom after initialization
         (-> position_details_target.parent `set_content position_details_target.child_position
             position_details_new.child)
         (-> holding_tank `show)
         (cascade_resize)
         (set_focus_to position_details_new.child)
         (focus_to_editor)
         target_control)
         
        (and (== position_details_new.parent holding_tank)   ;; new control is in the holding tank 
             (is_function? position_details_target.parent.set_content))
        (progn
            (debug)
            (-> holding_tank `remove_control position_details_new.child.options.id)
            (-> holding_tank `add_control position_details_target.child)
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (set_focus_to position_details_new.child)
            (cascade_resize)
            (focus_to_editor)
            position_details_new.child)
        
        (and (eq nil position_details_new.parent)  ;; this is a new control without a parent
             position_details_target.parent.set_content)
        (progn  ;; add to the holding tank the target and put the new in the targets old place..
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> holding_tank `add_control position_details_target.child)
            (cascade_resize)
            (set_focus_to position_details_new.child)
            (focus_to_editor))
        (and (-> holding_tank `has_control? position_details_new.child)
             position_details_target.parent.set_content)
        (progn
           (-> position_details_target.parent `set_content
              position_details_target.child_position
              position_details_new.child)
           ;; remove from the holding tank
           (-> holding_tank `remove_control position_details_new.child)
           (-> holding_tank `add_control position_details_target.child)
           (cascade_resize)
           (set_focus_to position_details_new.child)
           (focus_to_editor))
        
        else
        (progn
            (notify "Unhandled swap condition - see console")
            (log "unhandled swap position: target: " position_details_target "new: " position_details_new)
            nil))))                               




;; container view operation
;; given a command performs an operation on the control structure

;; definitions
;; target_control - the control that is to be impacted with a change 
;; target_control_container - the container of the target_control
;; new_control - an optional new control to be inserted into the control tree
;; options - options for the given command

(defun container_view_operation (command target_control new_control options)
   (let
      ((orig_target target_control)
       (target_control (control_for_dom_element target_control.view)) ;; ensure we have the correct handle to the impaced control since this could be a sub_control given to us
       (position_details nil) ;; the structure that holds the position details of the operation
       (holding_tank (get_control_by_name "Holding Tank"))
       (tmpview nil)
       (confirmed true)
       (new_container nil)
       (split_view_parent nil))
      
      (assert target_control "Unable to find the target control")
      (assert holding_tank "Unable to find the holding tank")
      (= position_details (control_position target_control))
      (console.log "container_view_operation: original_target: " orig_target)
      (console.log "container_view_operation: computed_target: " target_control)
      (console.log "container_view_operation: command: " command "position_details: " position_details "new_control: " new_control)
      (when (and (== position_details.parent nil) ;; top level control
                 (not (== position_details.child holding_tank))
                 (is_top_control? position_details.child))
         (= target_control (first (-> position_details.child `controls)))
         (= position_details (control_position target_control))
         (console.log "container_view_operation: shifted down: target_control was a top control: " position_details))
      ;(log "container_view_operation: options.suppress_destroy_confirm: " options.suppress_destroy_confirm  (and *last_focus* (prop *last_focus* `options)))
      (unless options.suppress_destroy_confirm
         (if (and (== command "destroy")
                  (is_function? target_control.on_destroy))
             (= confirmed (-> target_control `on_destroy))))
      (console.log "container_view_operation: confirmed: " confirmed)
      (if confirmed
          ;; if the parent structure is nil in position_details, then we are at the root
          (cond
             (or (== command "hide")
                 (and (not (resolve_path [ `options `locked ] target_control))
                      (== command "destroy")))
             (progn
                (cond
                   ;; the control is not a root control if it has a parent
                   (or (== position_details.parent.type "split_view_vertical")
                       (== position_details.parent.type "split_view_horizontal"))
                   (progn
                      ;; grab the child control to keep displaying, ie. not the one in the child_position
                      (set_prop position_details
                         `child_to_display
                         (if (== position_details.child_position 0)
                             (second (-> position_details.parent `controls))
                             (first (-> position_details.parent `controls))))
                      
                      ;; we need to know the split views parent since we are going to remove the split view
                      ;; and hoist the remaining child to display into the parent structure in place of the
                      ;; split_view - not an even swap because the existing split_view is retired
                      
                      (= split_view_parent (control_position position_details.parent))
                      (assert split_view_parent.parent.set_content "Unable to set the content of the split view parent")
                      (console.log "container_view_operation: split_view_parent: " split_view_parent)
                      (console.log "container_view_operation: position_details: " position_details)
                      (when (not options.dry_run)
                         ;; elevate the child to keep to the targeted_control container's position in it's parent
                         (-> split_view_parent.parent `set_content split_view_parent.child_position position_details.child_to_display)
                         
                         ;; set the child to hide in non displayed controls
                         (cond
                            (and (== command "hide")
                                 (not (== target_control holding_tank)))
                            (-> holding_tank
                                `add_control
                                target_control)
                            (and (not (resolve_path [ `options `locked ] target_control))
                                 (== command "destroy")
                                 (is_function? target_control.destroy))
                            (progn
                               (when *app_menu_control*
                                  (-> *app_menu_control* `remove_menu target_control.options.name))
                               (-> target_control `destroy)
                               (when (== *last_focus* target_control)
                                  (== *last_focus* nil)))))
                      (cascade_resize)
                      (default_focus)
                      true)
                   (and (not (resolve_path [ `options `locked ] target_control))
                        (== position_details.parent holding_tank)
                        (== command "destroy"))
                   (progn
                      (-> holding_tank `remove_control position_details.child.options.id)
                      (when *app_menu_control*
                         (-> *app_menu_control* `remove_menu position_details.child.options.name))
                      (if (is_function? position_details.child.destroy)
                        (-> position_details.child `destroy))
                      (when (== *last_focus* target_control)
                         (== *last_focus* nil))
                      (default_focus))
                   (and (== command "destroy")
                        (resolve_path [ `options `locked ] target_control))
                   (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                   (== command "destroy")   ;; single control under the root frame so swap if possible with the holding tank
                   (progn
                       (if (> (length (holding_tank_controls)) 0)
                           (progn
                              (set_path_value target_control [`options `temporary ] target_control) ;; mark as temporary
                              (swap_control target_control (last (holding_tank_controls))))
                           (progn
                              (notify "Cannot hide a single control - try replacing."))))
                   else
                   (progn
                      (if (> (length (holding_tank_controls)) 0)
                          (swap_control target_control (last (holding_tank_controls)))
                          (notify "Cannot hide a single control - try replacing"))
                      position_details)))
             
             (== command "replace")
             (progn
                (log "container_view_operation: command is replace: swap: " target_control new_control)
                (swap_control target_control new_control)
                true)
             
             (== command "split_left")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (== command "split_right")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical position_details.child new_control  (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                
                (cascade_resize)
                true)
             (== command "split_above")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (== command "split_below")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal  position_details.child new_control (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (resolve_path [ `options `locked ] target_control)
             (progn
                (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                false)
             ;; otherwise we don't know how to process the command 
             else
             (progn
                (notify (+ "container_view_operation: unknown command: " command))
                position_details))
          (progn
             false))))
  
 
(defmacro place_control(placement `& control_def)
   (let
      ((where_map {
                   `top: "split_above"
                   `below: "split_below"
                   `left: "split_left"
                   `right: "split_right"
                   `replace: "replace"  })
       (where (aif (prop where_map placement)
                   it
                   "split_right")))
       
  `(let
      ((target_container  (control_position (top_frame (default_focus)))))
     (when target_container.child 
       (= target_container (first (-> target_container.child `controls)))
       (container_view_operation ,#where target_container
                                   ,@control_def)))))
              
(defun show_control (control_to_show)
  (let
      ((control_to_show (cond 
                          (and (is_string? control_to_show)
                               (get_control_by_name control_to_show))
                          (get_control_by_name control_to_show)
                          (and (is_string? control_to_show)
                               (get_control_by_id control_to_show))
                          (get_control_by_id control_to_show)
                          (is_control? control_to_show)
                          control_to_show))
       (target_control (if *last_focus*
                         *last_focus*
                           nil)))
    (cond 
       (and target_control control_to_show)
       (progn
          (swap_control target_control control_to_show)
          (set_focus_to control_to_show)
          (sleep 0.1)
          
          true)
       control_to_show
       (progn
          (place_control "right" control_to_show)
          (sleep 0.1)
          (set_focus_to control_to_show)
          true)
       else
       (progn 
          (notify (dtext "The requested control to display wasn't found."))
          false)))
  {
    `description: (+ "Provided a control name, id or the control object itself, "
                     "will display the control, adjusting the layout as needed. "
                     "By default the control referenced by *last_focus* is swapped with the new one, "
                     "but if that isn't possible, the view is split and the new control is placed to "
                     "the right.<br>"
                     "Returns true if successful, otherwise a notification is "
                     "delivered that the control is not found, and false is "
                     "returned.")
    `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
    `usage: ["target:string|object"]
    })



(defun hide_control (target destroy? no_mod_layout)
   (let
      ((control (cond 
                   (and (is_string? target)
                        (get_control_by_name target))
                   (get_control_by_name target)
                   (and (is_string? target)
                        (get_control_by_id target))
                   (get_control_by_id target)
                   (is_control? target)
                   target))
       (confirmed true)
       (swap_target (and no_mod_layout
                         (last (-> (control_holding_tank) `controls)))))
      (declare (function control_holding_tank)
               (global control_holding_tank))
      (cond 
         (and control swap_target)
         (progn
            (if (and destroy?
                     (is_function? control.on_destroy))
                (= confirmed (-> control `on_destroy)))
            (sleep 0.01)
            (when confirmed   
               (swap_control control swap_target)
               (if destroy?
                  (container_view_operation "destroy" control nil { `suppress_destroy_confirm: true } ))))
         control
          (progn
             (container_view_operation (if destroy? "destroy" "hide") control nil)
             true)
          else
          (progn
             (notify "Control not found")
             false)))
   {
       `description: (+ "Provided a control name, id or the control object itself, "
                        "will hide the control, adjusting the layout as needed. "
                        "Returns true if successful, otherwise a notification is "
                        "delivered that the control is not found, and false is "
                        "returned.  If destroy? is true, the control is removed from "
                        "the tree and destroyed.")
       `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
       `usage: ["target:string|object" "destroy?:?boolean"]
   })

(defun destroy_control (target)
  (hide_control target true)
  {
   `description: (+ "Provided a control name, id or the control object itself, "
                    "will hide the control, adjusting the layout as needed. "
                    "Returns true if successful, otherwise a notification is "
                    "delivered that the control is not found, and false is "
                    "returned. ")
   `tags: ["controls" "control" "display" "destroy" "remove" "holding_tank" "ui"]
   `usage: ["target:string|object"]
   })



(defun process_focus_chain (e originator_container)
  (progn
   (handle_event e)   
   (when e.path
     (let
         ((target_control nil)
          (controls (reduce (c (current_controls))                        
                        (when c.on_focus                          
                          c)))
          (focused_list (query_all ".juno-focused")))

      
       (for_each (elem e.path)
          (progn
           (for_each (control controls)
                     (when (== elem control.view)
                       (= target_control control)
                       (break)))
           (when target_control
             (break))))
       
       (set_focus_to target_control controls)))))


    



(defun menu_tree (items options _path)
  (let
      ((options (either options { `flat_index: 0 }))
       (path (either _path []))
       (disappear_timer nil)
       (min_width (+ "min-width: " (or options.min_width 300) "px;"))
       (id (either options.id "cmenu"))  
       (active_menu_item nil)
       (menu_element
        (fn (idx text `& args)
          (let
              ((view (li {  `class: "pure-list-item"                                         
                          `style: (+ (if (> args.length 0)
                                         "position: relative;"
                                         "")
                                     min_width)
                          }
                         (a { 
                             `idx: idx
                             `path: (join "~" (conj path idx))
                             `href: "#"
                             `class: "pure-menu-link" 
                             `style: ""
                             }
                            (if (== args.length 0)
                              (span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                              [(span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                               (span { `class: "juno-menu-submenu" } "â¯")]))
                         args))
               (timer nil))
            (if (== args.length 0)
              (progn
                 (attach_event_listener view
                    `mouseenter
                    (fn (e)
                       (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)))
                 view)
              (progn
               (attach_event_listener view
                  `mouseenter
                  (fn (e)
                     (do
                        (= active_menu_item e.srcElement)
                        (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)
                        (add_class "juno-menu-selected" e.srcElement)
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (set_style [["display" "inline-block" ]
                                                      ["position" "absolute"]
                                                      ["top" "0px"]
                                                      ["left" (+ "" e.srcElement.offsetWidth "px") ]]
                                                     view.children.1))
                                       150)))))
               (attach_event_listener view
                  `mouseleave
                  (fn (e)
                     (do
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (progn
                                             (set_style [["display" "none"]] view.children.1)))
                                       150)))))
               
               view)))))
       (view nil))
    
    (= view
       (ul (+ {}
              { `class: (if (> path.length 0)
                             "juno-menu pure-menu-list"
                             "pure-menu-list")
                `style: (+ (if (> path.length 0)
                             "display: none;"
                             "display: inline-block;")
                           "position: relative;")  }
              (if (== path.length 0)
                { `id: id }
                {}))
                     
           (map (fn (item idx)
                  (let
                      ((text (if (is_function? item.0)
                               (item.0)
                               item.0)))
                    (set_prop options
                              `flat_index
                              (+ 1 options.flat_index))                     
                    (cond
                      (is_array? item.1)
                      (menu_element options.flat_index text (menu_tree item.1 options (conj path [ idx 1])))
                      (and (== text "--") (eq nil item.1))
                      (hr { `class: "LightHR" })
                      (is_function? item.1)
                      (menu_element idx text)
                      else
                      [])))
                items)))
    (if (> path.length 0)      
       view
      (progn
       (attach_event_listener view
                              `click
                              (fn (e)
                                (let
                                    ((path (-> e.srcElement `getAttribute "path"))
                                     (idx (-> e.srcElement `getAttribute "idx"))
                                     (target (if path
                                               (resolve_path (split_by "~" path) items))))
                                  (handle_event e)
                                  (-> view `remove)
                                  (aif (get_by_id "cmenu")
                                       (-> it `remove))
                                  (when (is_function? options.on_select)
                                     (options.on_select path))
                                  (sleep 0.01) ;; disconnect and move to back of the event loop for the call
                                  (when (and target
                                             (is_function? target.1))
                                    (target.1 e target.2))
                                  )))
       (setTimeout (fn ()
                     (progn
                      (attach_event_listener view
                                             `mouseleave
                                             (function (e)
                                                       (progn
                                                        (when disappear_timer
                                                          (clearTimeout disappear_timer))
                                                        (= disappear_timer (setTimeout (fn ()
                                                                                         (progn
                                                                                          (-> view `remove)
                                                                                          (when (is_function? options.on_select)
                                                                                             (options.on_select nil))
                                                                                          (= disappear_timer nil)))
                                                                                       (or *env_config*.application.menu_timeout
                                                                                           options.menu_timeout
                                                                                           2500))))))
                      (attach_event_listener view
                                             `mouseenter
                                             (function (e)
                                                       (when disappear_timer
                                                         (clearTimeout disappear_timer)
                                                         (= disappear_timer nil))))))
                   700) ;; delay a little before adding the timeout so we don't accidentally hover over it 
       {
        `view: view
        `toJSON: (function ()
                           `(menu_tree ,#items ,#options))
        `type: "menu_tree"
        }))))

(defun make_menu (for_element menu_items options)
  (let
      ((menu_items menu_items)
       (for_element for_element)
       (pos nil)
       (mtree nil)
       (disappear_timer nil)       
                                        
       (view nil))
    (aif (get_by_id "cmenu")
         (-> it `remove))
    (setq mtree
          (menu_tree menu_items options))
    (setq view
          mtree.view)
    (add_class "juno-menu" view)
    (when for_element
      (setq pos
            (-> for_element `getBoundingClientRect))
      (set_style [["top" (+ "" (Math.max 0 pos.bottom) "px") ]
                  ["left" (+ "" (Math.max pos.left 0) "px") ]
                  ["position" "absolute"]
                  ["z-index" "30"]]
                  view)
      (console.log "make_menu: found element at: " pos))
    
     
    (if options.do_not_attach
      view
      (progn       
       (-> (get_by_id "body") `appendChild view)
       (console.log "appended view" view)
       view))))

(defun_sync get_key_code (e)
  (let
      ((k []))
      (when e.metaKey
         (push k "Command"))
      (when e.ctrlKey
         (push k "Ctrl"))
      (when e.altKey
         (push k "Alt"))
    (when e.shiftKey
      (push k "Shift"))
    (console.log e)
    (unless (contains? e.key [ "Shift" "Control" "Alt" "Meta" ])      
            ;; normalize to the printed key characters on the keyboard
            (push k (cond 
                       (starts_with? "Key" e.code)
                       (-> e.code `substr 3)
                       (starts_with? "Digit" e.code)
                       (-> e.code `substr 5)
                       else
                       e.code)))
    (if (> k.length 0)
        (join "-" k)
        e.code))
  {
      `description: (+ "Given a key event, returns a text description of the set of characters in a normalized order "
                       "for matching keybinding handlers.  If no modifier keys (Control, Alt, Command, or Shift), returns "
                       "the direct code value from the key event.  If a modifier or modifiers are also pressed, will "
                       "return a composite value with the following order of priority, where if a key with a lower "
                       "prority is pressed, it will appear first in the returned value:<br>"
                       "Command - 0 <br>"
                       "Ctrl - 1<br>"
                       "Alt - 2<br>"
                       "Shift - 3 <br>"
                       "For example if the user is pressing both the Shift and the Control key and the 'A' key, the "
                       "returned value will be \"Ctrl-Shift-A\" as the priority value for 'Control' is 1 and the "
                       "priority value for 'Shift' is 3.  Note that whenever a modifier is pressed, the value of "
                       "the pressed key will be always uppercase as the descriptor.")
      `usage: ["event:Event"]
      `tags: [ "key" "events" "binding" "keycodes" "keyboard"]
  })

(defun request_user_input (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((user_input (if options.input
                                    options.input
                                    (input (+ {`tabindex: 0 `type: (or type "text") `style: "width: calc(100% - 15px)" }
                                              (if options.placeholder
                                                 { placeholder: options.placeholder }
                                                 {})
                                              (if options.title
                                                 { `title: options.title }
                                                 {})
                                              (if options.class
                                                 { `class: options.class } 
                                                 {})
                                              (if options.value
                                                 { `value: options.value } 
                                                 {})
                                                ))))
                      (completed false)
                      (ok_button (button { `class: "juno-primary" `style: "float:right" } (dtext "OK")))
                      (cancel_button (button { `class: "juno-secondary" }  (dtext "Cancel")))
                      (dwin (dialog { `style: "height: min-content; width: min-content;"   }
                                    (div { `class: "juno-instructions" } prompt)
                                    (br)
                                    user_input
                                    (br)
                                    (div { `class: "pure-button-group juno-control-group" `style: "margin-top: 10px;" `role: "group" }
                                         (if options.no_cancel_button
                                            []
                                            cancel_button)
                                         ok_button)))
                      (rval nil)
                      (get_current_value (fn ()
                                            (cond
                                               user_input.value
                                               user_input.value
                                               (getAttribute user_input `value)
                                               (getAttribute user_input `value)
                                               options.no_cancel_button
                                               true)))
                      (return_value (fn ()
                                       (progn
                                          (= rval (get_current_value))
                                          (cond
                                             (is_function? options.validator)
                                             (if (-> options `validator rval)      
                                                 (clean_up rval) ;; if the validator returns true, ok remove the dialog box
                                                 nil) ;; wait for an appropriate inpit
                                              else
                                              (clean_up rval)))))
                                                     
                                                     
                      (clean_up (fn (val)
                                    (when (not completed)
                                        (= completed true)
                                        (resolve val)
                                        (-> dwin `remove)))))
                     
                     
                     
                     (if (is_function? options.validator)
                         (set_disabled ok_button))
                     
                     (attach_event_listener ok_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (return_value))))
                     ;; don't immediately react to keyup so as not to immediately react
                     ;; in certain scenarios
                     (setTimeout (fn ()
                                    (attach_event_listener user_input
                                       `keyup
                                       (fn (e)
                                          (cond
                                             (== e.key "Enter")
                                             (progn
                                                (handle_event e)
                                                (return_value))
                                             (is_function? options.validator)
                                             (progn
                                                (if (-> options `validator (get_current_value))
                                                    (set_enabled ok_button)
                                                    (set_disabled ok_button)))))))
                                 
                                 250);
                     (attach_event_listener cancel_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (return_value))))
                     
                     (attach_event_listener dwin
                        `close
                        (fn (e)
                           (clean_up nil)))
                     
                     (when options.default_value
                        (set_prop user_input
                           `value
                           options.default_value))
                     
                     (-> juno_container
                        `appendChild dwin)
                     ;(setTimeout (fn ()
                     ;              (place_caret_at_end user_input))
                     ;          50)
                     (when (is_function? dwin.showModal)
                        (-> dwin `showModal)
                        (-> user_input `select)))))
  {
    description: (+ "This function will pause the flow of execution until the user makes a choice, "
                    "selection or input and then will return the result of the user action.  If the "
                    "user presses cancel or presses the Escape key, a return value of nil will be "
                    "returned.<br>"
                    "By default, the user is presented with a text input box in which text can "
                    "entered.  Once the user presses return or clicks the OK button, the value is "
                    "returned.  However, if the `type option is given as an input, the input will "
                    "be of the specified type, such as \"number\" or \"date\". <br>"
                    "Additionally options can be provided for more control over the interaction "
                    "and value presentation.  If provided with a key of \"input\" and an input element, "
                    "the provided input element will be displayed and the final value returned.  "
                    "Other elements can be provided and as long as they either set a value property "
                    "or value attribute on the element, that value will be returned.<br>"
                    "Values can be validated by passing a \"validator\" function.  Upon the user "
                    "pressing a key, the validation function will be called with the "
                    "current value and if the validation function returns true, OK will be enabled, "
                    "or if the user pressed enter, the validated value will be returned to the caller, "
                    "otherwise the OK button will be disabled and the dialog box will not close. "
                    "Note that the validator function is responsible for any prompting of "
                    "or additional notices of how to comply with the validation rules.  This "
                    "could be done by providing a more complicated element structure as an input that is in "
                    "the closure of the validator whose values could be updated.")
    usage: ["prompt:string" "type:string" "options:object"]
    tags: ["user" "input" "request" "collect" "wait" "ui" "DOM"]
    })
                 
(defun select_control_by_name (prompt options)
   (let
      ((no_sub_controls (not options.include_sub_controls))
       (controls (current_controls no_sub_controls))
       (prompt (or prompt (dtext "Please Select a Control")))
       (names  (reduce (ctl controls)
                 (let
                    ((name (resolve_path [ `options `name ] ctl)))
                    (progn
                       (cond
                          options.include_specials
                          name
                          (is_function? options.include_if_true)
                          (if (-> options `include_if_true ctl)
                              name
                              nil)
                          (and (not (== ctl (control_holding_tank)))
                               (not (starts_with? "split_view" ctl.type))
                               (not (resolve_path [ `options `root_frame ] ctl)))
                          name)))))
                          
                          
       (name_elems (map (fn (name) 
                           (option name))
                        names))
       
       (dlist_id (gen_id "controls"))
       (dlist (apply datalist { `id: dlist_id } name_elems))
       (selector (input { `list: dlist_id `style: "width: calc(100% - 10px);"} ))
       (value nil))
      (try
         (progn
           (-> (get_by_id `body) `append dlist)
           (= value (request_user_input prompt 
                                        `text 
                                        { input: selector
                                          validator: (fn (v)
                                                        (contains? v names))
                                        })))
         (catch Error (e)
            (progn
               (log "select_control_by_name: error in request_user_input operation: " e.message))))
      (log "selected: " value)
      (-> dlist `remove)
      (get_control_by_name value))
   {
       `description: (+ "Given a prompt and an optional options object, presents a dialog that displays the "
                        "given prompt and allows the user to select or type a control name.  A drop down "
                        "allows the user to select the closest matched to the typed in text.<br>"
                        "The selected control is returned, or nil if the user presses cancel or presses Escape.<br>"
                        "By default no split_views, sub controls (controls contained by other controls) " 
                        "or root controls are displayed, only content controls.<br>"
                        "Options:<br>"
                        "include_specials:boolean - By default false, all controls will be presented.<br>"
                        "include_sub_controls - Include the sub controls.<br>"
                        "include_if_true:function - Predicate function which is passed a control, and if the function "
                        "returns true the control will be included in the selection, otherwise it will not be.")
       `usage: ["prompt:text" "options:object"]
       `tags: ["controls" "select" "choose" "user" "UI" "DOM" ]
   })  


(defun alert_box (message detail)
   (request_user_input (or message "No message provided!") 
                       nil 
                       { `input: (if detail 
                                     (div detail)
                                     (span {})) 
                         `no_cancel_button: true })
   {
     `usage:[ "message:text" "detail:text|Element"]
     `description: "Creates a modal type popup dialog box which pauses the current execution flow until the OK button is clicked. The return value is undefined."
     `tags: ["alert" "popup" "modal" "box" "warn" "ui" "DOM" ]
   })
     
(defmacro alert_on_error (error_title `& forms)
   `(try
       (progn
          ,@forms)
       (catch Error (e)
          (progn
             (alert_box ,#(or error_title (dtext "Error on Operation"))
                         e.message)
             nil)))
   {
       `usage: ["error_title:text" "forms:*"]
       `description: (+ "All provided forms will be wrapped in a progn and the last value of the provided forms returned.  " 
                        "Any uncaught errors in the provided forms will be caught by this macro abd the provided " 
                        "error_title, and exception message presented to the user for acknowledgement.  On a caught error "
                        "nil will be returned to the calling code.")
       `tags: ["alert" "popup" "catch" "errors" "ui" "DOM"]
   })

;; -- Control Events --------
;; event routing is handled by a map that combines the command value and the source value.
;; if an array is found at the value, it will call each function in the array in sequence
;; as each function in the array is an event handler

(defparameter *event_routes* 
   { }
   {
     `description: (+ "The event routing object which contains routes used by dispatch_event. "
                      "<br>Use register_event_handler to add event handlers and " 
                      "remove_event_handler remove handlers. ")
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes"  ]
     })

(defun_sync compute_handler_key (source command)
   (+ (if (is_string? source)
                           (+ "" source )
                           "")
                       (if (is_string? command)
                           (+ "+" command)
                           ""))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given a source and a command, computes the event_handler lookup key for control events."
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" ]
   })


(defun register_event_handler (source command function_id handler_function)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (exists false))
      (if (blank? handler_key)
          (throw TypeError "register_event_handler: one or more of source and command must be specified as strings"))
      (if (blank? function_id)
          (throw TypeError "register_event_handler: function_id is required"))
      (if (blank? handler_function)
          (throw TypeError "register_event_handler: handler_function is required"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
         (set_prop *event_routes*
            handler_key
            (list { `fid: function_id f: handler_function }))
         (progn
            (for_each (handler handlers)
               (if (== handler.fid function_id)
                   (setq exists true)))
            (if exists
               (throw ReferenceError "register_event_handler: function already registered for key")
               (push handlers { fid: function_id f: handler_function }))))
      handler_key)
   {
       `usage: ["source:string" "command:string" "handler_function_id:string" "handler_function:function"]
       `description: (+ "Given a control source id, command string, and a handler function, adds the function to the "
                        "event handler.  If the function is determined to be already registered using equality, then "
                        "the function will throw a ReferenceError that the same function is already registered.  "
                        "Returns the computed handler_key.<br>The handler function should be defined in the "
                        "form of (fn (event_obj)), where event_obj will be the event object as transmitted " 
                        "from the source.<br>")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })
    
(defun remove_event_handler (source command handler_function_id)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (idx nil))
      (if (blank? handler_key)
          (throw TypeError "remove_event_handler: one or more of source and command must be specified as strings"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
          true
          (progn
             (if (eq nil handler_function_id) ;; if no handler_function_id is provided, remove all handlers for the events
                 (progn
                    (set_prop *event_routes*
                       handler_key
                       [])
                    true)
                 (progn
                    (map (fn (f i)
                            (if (== f.fid handler_function_id)
                                (setq idx i)))
                         handlers)
                    (when idx
                       (-> handlers `splice idx 1))
                    (if idx
                       true
                       false))))))
   {
       `usage: ["source:string" "command:string" "handler_function_id:string"]
       `description: (+ "Given a control source id, command string, and a handler function, removes the function to the "
                        "event handler.  If the function isn't found in the event handlers using equality, then "
                        "the function will return false, otherwise if successful it will return true.  If no function is "
                        "is provided, then all handlers for the key will be removed.")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })

(defun get_control_event_handlers (source command)
   (prop *event_routes* (compute_handler_key source command))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given an source string and command string, returns an array of all specific matching handlers for the given values."
       `tags: ["events" "controls" "handlers" "dispatch" "routes" ]
   })  
  
(defun remove_all_handlers_for_source (source)
   (let
      ((routes nil))
      (when (not (is_string? source))
         (throw TypeError "source must be a string"))
      (setq routes
         (reduce (key (keys *event_routes*))
            (when (starts_with? (+ "" source "+") key)
               key)))
      (apply delete_prop *event_routes* routes)
      (length routes))
   {
       usage: ["source:string"]
       description: (+ "Given a source identifier, removes all routes associated with that source. "
                       "Returns the number of routes removed.")
       tags: ["events" "controls" "routes" "handlers" "source" "dispatch"]
   })

(defun_sync dispatch_event(event_obj)
   (let
      ((handler_key (compute_handler_key event_obj.source event_obj.command))
       (handlers (when handler_key  ;; check for handlers that match specifically, match only source events, and match only command events
                    (flatten (conj (or (prop *event_routes* handler_key) [])
                                   (or (prop *event_routes* (compute_handler_key event_obj.source nil)) [])
                                   (or (prop *event_routes* (compute_handler_key nil event_obj.command)) []))))))
                    
     ;(when (> handlers.length 0)
      ;  (log "dispatch_event: " event_obj handler_key handlers))
      (if (> handlers.length 0)
           (for_each (handler handlers)
              (try
                 (progn 
                    (-> handler `f event_obj))
                 (catch Error (e)
                    (log (+ "Error on event handler for route: " handler_key ": " e.message))))))
      (when event_obj.error
         (progn
            (log "dispatch_event: error: " event_obj)
            (alert_box (+ ""
                          (from_key event_obj.command)
                          (if event_obj.args.1.message
                             (+ ": " event_obj.args.1.message)
                             ""))
                       (aif (and event_obj.args.0
                                event_obj.args.0.options.filename)
                           (+ "The file " it " was unable to be saved.")))))
      true)
   {
     `usage: ["event_obj:object"]
     `description: (+ "Dispatches received event objects from controls using the *event_routes* table.  Routes are "
                      "determined via compute_handler_key.  If a route key resolves to an array, each handler function in "
                      "the found array in the *event_routes* table is called in sequence.  Routes are collected by first " 
                      "looking for handlers that act on the source+command, then source, then command."
                      "<br>Use register_event_handler to add event handlers and remove_event_handler remove handlers. "
                      "The function return value shouldn't be used.")
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
     })
     


(defun get_editors_for_path (path)
   (let
      ((spath (cond
                 (is_array? path)
                 (join "~" path)
                 (is_string? path)
                 path
                 else
                 (throw TypeError "path must be an array or string"))))
      (reduce (ctl (current_controls))
         (when (and ctl.editor
                    ctl.options.path
                    (== (join "~" ctl.options.path) spath))
            ctl)))
   {
       `description: "Returns an array of all controls that are editors and that have the supplied path value."
       `usage: ["path:array|string"]
       `tags: ["controls" "editor" "path"]
   }) 

(defun get_control_by_editor (editor)
   (let
      ((ctls (current_controls true)))
      (first (reduce (ctl ctls)
                (when (== ctl.editor editor)
                   (log "found ctl for editor")
                   ctl))))
   {
       `description: "Given an editor object, returns the control associated with it."
       `usage: ["editor:object"]
       `tags: ["editor" "control" "find"]
   })

(defun get_editor_file_basename (editor_control)
   (aif (resolve_path [ `options `filename ] editor_control)
        (last (split_by "/" it))
        nil)
   {
       description: (+ "If given a control with an editor which is operating on a file, " 
                        "will return the filename without the directory path for that editor. "
                        "Otherwise, it will return nil")
       usage: [ "editor_control:object"]
       tags: ["editor" "file" "basename" "filename" "path"]
   })

(defun close_file (editor_control)
   (let
      ((closed_focus? false))
      (log "close_file: " (and editor_control (prop editor_control `options)))
      (if (and (is_function? editor_control.on_destroy)
               (-> editor_control `on_destroy))
          (progn
             (for_each (ctl (get_editors_for_path editor_control.options.path))
                (progn
                   (if (not closed_focus?)
                       (= closed_focus? (== ctl *last_focus*)))
                   
                   (try
                      (container_view_operation `destroy ctl nil { `suppress_destroy_confirm: true } )
                      (catch Error (e)
                         (log "close_file error: " e.message)))))
             ;(log "close_file: calling default_focus" closed_focus?)
             (if closed_focus?
                   (default_focus)))
          (notify "Close cancelled."))))

;; when save events are dispatched, this function should be the
;; receiver.  It will get the value from the sending control,
;; attempt to save it, and if successful, will dispatch save_complete to
;; all editors with the specific path

(defun save_event_handler (event_obj)
   (alert_on_error "Unable to save"
       (let
          ((control (get_control_by_id event_obj.source))
           (pathname (when control
                        control.options.path))
           (nseval (if (not (blank? control.options.path_namespace))
                       (-> Environment `get_namespace_handle control.options.path_namespace)
                       Environment))
           (do_remote_save (fn ()
                              
                              (let
                                 ((rval nil))
                                 (= rval (http/send_files "/save_file" (http/data_to_file control.options.filename (or (-> control `get) ""))))
                                 (if (and rval
                                          (== rval.rval "OK"))
                                     (progn
                                        (= rval rval.results)
                                        (log "save_event_handler: saved remote file OK: " (clone rval))
                                        (if (== rval.length 1)
                                            (publish_results (+ { `target: rval.0.filename `type: "filename" } rval.0 ))
                                            (progn
                                               (log "ERROR: got different result for save_file then expected" (clone rval))
                                               (throw TypeError "Got different result for save file then expected"))))
                                     (progn
                                        (log "ERROR: save_event_handler: couldn't remote save: " (clone rval)))
                                        (throw TypeError (or rval.message "Uknown response from server"))))))
           (do_path_save (fn ()
                            (progn
                               (make_path pathname nseval.global_ctx.scope
                                  (-> control `get))
                               (if (not (== (-> control `get) (resolve_path pathname nseval.global_ctx.scope)))
                                   (progn
                                      (log "ERROR: save_event_handler: couldn't save path: values not matching: namespace: " control.options.path_namespace "path:" pathname )
                                      (throw TypeError "couldn't save to the local path - values not matching for path/namespace"))
                                   (progn
                                      (log "save_event_handler: saved local path OK: " control.options.path_namespace pathname)
                                      (publish_results { `target: pathname `type: "path" `namespace: control.options.path_namespace }))))))
                                   
                               
           (publish_results (fn (results_obj)
                               (let
                                  ((controls_to_notify (get_editors_for_path control.options.path)))
                                  (for_each (ctl controls_to_notify)
                                     (-> ctl `on_save_complete { `command: "save_complete" `source: control.options.id args: [ results_obj ] }))))))
          
          ;; validate we have what we need 
          (cond
             (eq nil control)
             (throw ReferenceError "Source control not found")
             (eq nil control.get)
             (throw TypeError "Source control doesn't have a get method for saving"))
          
          (cond
             (and (is_string? control.options.filename) ;; do we have a filename
                  is_served?)  ;; can we do a save?
             (progn
                (if (contains? "http_client" *env_config*.features)
                    (do_remote_save)
                    (throw ReferenceError "http_client is not a registered feature.")))
             (is_string? control.options.filename)
             (throw Error "Not connected to a server - cannot save the remove file")
             
             control.options.path
             (progn
                (do_path_save))))))
             
             

    
                     
(defun message (text)
  (div { `style: "border-left: 5px solid darkblue; padding: 5px;" } text))

(defun error_message (text)
  (div { `style: "border-left: 5px solid red; padding: 5px;" } text))

(defun log_error (message error_instance)
  (progn
   (log (error_message message))
   (console.error message)
   (when error_instance
     (when error_instance.messasge
       (error_message error_instance.message))
     (console.error error_instance))))
     


(defun load_js_file (file)
  (let
      ((fdata (try
                (read_file file { `read_as: "text" })
                (catch Error (e)
                  e)))
       (assignment_to nil)
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
       (aif (request_user_input "Enter a name for a reference to the loaded Javascript" "text")
            (do
              (= assignment_to it)              
              (try
                (progn
                 (debug)
                 (cond
                   (or (== assignment_to "global")
                       (== assignment_to "script"))
                   (-> (page_header) `append (script { `type: "text/javascript" `charset: "utf-8" }
                                                     (javascript fdata)))
                   else
                   (eval `(defglobal ,#assignment_to (javascript ,#fdata)))))
                (catch Error (e)
                  (do
                    (= error true)
                    (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                    (console.error "ERROR: " e))))                                                    
              (when (not error)
                (log (message (+ "Loaded JS to " assignment_to )))))
            (notify "Entry Cancelled")))
      else
      (progn
       (log "Unable to read the file")
       (console.error fdata)))))

(defun embed_js_orig (name js_text) 
  (progn
   (debug)
   (-> (page_header) `append (html/script { `id: name `type: "text/javascript" `charset: "utf-8" }
                                     (javascript js_text)))   
   (eval `(defglobal ,#name (html/get_by_id ,#name)
            {
             `embedded_script: true
             }))))

(defun embed_js (name js_text) 
  (progn
   (debug)
   (eval `(-> (page_header) `append (html/script { `id: name `type: "text/javascript" `charset: "utf-8" }
                                     (javascript ,#js_text))))
   (eval `(defglobal ,#name (html/get_by_id ,#name)
            {
             `embedded_script: true
             }))))

(defun embed_js_file (file)
  (let
      ((fdata (try
                (read_file file { `read_as: "text" })
                (catch Error (e)
                  e)))
       (assignment_to nil)
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
       (aif (request_user_input "Enter a name for a reference to the loaded Javascript" "text")
            (do
              (= assignment_to it)              
              (try
                (embed_js_orig assignment_to fdata)                   
                (catch Error (e)
                  (do
                    (= error true)
                    (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                    (console.error "ERROR: " e))))                                                    
              (when (not error)
                (log (message (+ "Loaded JS to " assignment_to )))))
            (notify "Entry Cancelled")))
      else
      (progn
       (log "Unable to read the file")
       (console.error fdata)))))

(defun load_files (files)
  (when (> files.length 0)
    (for_each (file files)
       (do
         (cond
           (== file.type "text/javascript")
           (embed_js_file file)
           (== file.type "text/plain")
           (notify "Text Resource")
           (or (ends_with? file.name ".lisp")
               (ends_with? file.name ".juno"))
           (notify "Loading lisp file"))))))



(defun control_frame (options `& contents)
  (let
      ((has_control_bar? (and (> contents.length 1)
                              (has_class? "juno-buffer-bar" contents.0)))
       (content (if has_control_bar?
                     [(first contents)
                      (div { `class: "juno-view-content" }
                           (rest contents)) ]
                     (div { `class: "juno-view-content" }
                           (rest contents))))
       (elem (div (+ { tabindex: 0 control_id: (or options.id (generate_id "frame"))
                      class: (+  "juno-view-container"
                                  (or options.classes "")) }
                      (if options.style
                        { `style: options.style }
                        {}))
                   content)))
    (console.log "control_frame: has_control_bar: " has_control_bar? contents)
    (when (not has_control_bar?)
      (set_style [["height" "100%" ]] content))
    (when (is_array? options.events)
      (for_each (ev options.events)
                (destructuring_bind (event_type action)
                     ev
                   (console.log "making events: " event_type action)
                   (attach_event_listener elem event_type action))))
    elem)
  {
   `description: (+ "Creates and returns an element representing the external frame "
                    "of a control. The passed contents can contain a buffer bar as a "
                    "first element, which will be identified as such by having a "
                    "juno-buffer-bar class assigned to it. <br>"
                    "The passed contents (excluding the buffer bar) are wrapped in a"
                    "juno-view-content div, and the whole contents, including the optional "
                    "buffer bar element are wrapped in a juno-view-container div.<br><br>"
                    "The options are as follows: <br><br>"
                    "id:string:The assigned id for the control.<br>"
                    "style:string:A string containing css styling attributes that are assigned "
                    "to the juno-view-container div (the encompassing element).<br><br>"
                    "events:array:An array of array values in the form of pairs in the "
                    "form of [event_type:string action:fn] which are attached to the "
                    "juno-view-container element.")
   `usage: ["options:object" "elements:Elements"]
   `tags: ["ui" "controls" "control" "frame" "DOM" "Node" "element" ]
   })

(defun name_control (prefix)
  (let
      ((prefix (or prefix "Unnamed"))
       (name ""))
    (if (get_control_by_name prefix)
      (+ prefix " " (inc *view_count*))
      prefix)))




(defun symbol_browser (options)
   (let
       ((self {})
        (options (or options {}))
        (show_previews (not options.disable_preview))                                
        (id (generate_id "symbol_browser"))
        (name (name_control (or options.name "Symbol Browser")))                  
        (title_span (span { `class: "juno-title" } name))
        (path_span (span { `class: "juno-path" `style: "float: right" } ""))
        (buffer_commands_button (commands_button id))
        (stack [ ])
        (filter_span (span { `style: "margin-left: 8px; margin-right: 8px; font-family: var(--main-mono-space);" } ""))
        (filter_span_container (span { `style: "border-radius: 3px; margin-left: 10px; padding-top: 2px; padding-bottom: 2px; border: 1px solid var(--type-regexp-color);" } 
                                     (span { `style: "padding-left: 10px; padding-right: 10px; background: var(--type-regexp-color); padding-top: 2px; padding-bottom: 2px; color: wheat;" } (+ (dtext "Filter") ":"))
                                     filter_span))
        (olist_style "padding-block-start: 3px; margin-block-start: 0.2em; padding-inline-start: 2px; ")
        (li_style "")
        (control_status (div {  class: "juno-buffer-bar" }
                                buffer_commands_button
                                (cond
                                  (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span)
                                filter_span_container
                                path_span))
        (symbol_struct (symbols_by_namespace))
        (element_for_pos (fn (pos want_parent?)
                           (let
                               ((target_col nil))                                
                             (= target_col (-> cview `querySelector (+ "[pos='" (if pos pos 0) "']")))                             
                             (cond 
                               (and want_parent? target_col)
                               target_col
                               target_col
                               (or (-> target_col `querySelector ".juno-highlighted")
                                   target_col.children.0)))))
        (filter_by_text (fn (pos text)
                            (let
                                ((elems (aif (element_for_pos pos true)
                                             it.children
                                             []))
                                 (elem nil)
                                 (num_found 0)
                                 (elem_bank_found [])
                                 (elem_bank_not_found [])
                                 (target_focus nil)
                                 ;;(remove_class "filtered-hidden" elem) (add_class "filtered-hidden" elem)
                                 (clear_it (blank? text)))
                                (if clear_it
                                    (progn
                                        (remove_class "filtered-hidden" elems)
                                        (focus_to (element_for_pos pos))
                                        false)
                                    (progn
                                        (for_each (idx (range elems.length))
                                            (progn
                                                (= elem (prop elems idx))
                                                (if (starts_with? text elem.innerText)
                                                    (push elem_bank_found elem)
                                                    (push elem_bank_not_found elem))))
                                        (cond
                                            (== elem_bank_found.length 0)
                                            false ;; do nothing
                                            (> elem_bank_found.length 0)
                                            (progn
                                                (console.log "found: " elem_bank_found.length)
                                                (for_each (elem elem_bank_found)
                                                    (remove_class "filtered-hidden" elems))
                                                (for_each (elem elem_bank_not_found)
                                                    (add_class "filtered-hidden" elem))
                                                (focus_to elem_bank_found.0)
                                                true)))))))
                                       
                                
        (filter_state {
                      chars: []
                      col_num: nil
                      })
        (show_filter_state (fn ()
                               (progn
                                   (if (> (length filter_state.chars) 0)
                                       (set_style [["opacity" "1"]] filter_span_container)
                                       (set_style [["opacity" "0"]] filter_span_container))
                                   (set_prop filter_span
                                            `innerText (join "" filter_state.chars)))))
        (clear_selector (fn (update?)
                            (progn
                                (console.log "clear_selector: filter_state: " (as_lisp filter_state))
                                (when filter_state.col_num
                                    (filter_by_text filter_state.col_num ""))
                                (set_prop filter_state
                                          `chars []
                                          `col_num nil)
                                (when update?
                                    (show_filter_state)))))
        (pop_from_selector (fn (pos)
                               (progn
                                   (if (== pos filter_state.col_num)
                                       (progn
                                           (pop filter_state.chars)
                                           (filter_by_text filter_state.col_num (join "" filter_state.chars)))
                                       (clear_selector))
                                   (show_filter_state))))
        (push_into_selector (fn (pos k)
                              (progn
                                  (defvar elems nil)
                                  (cond
                                      (eq nil filter_state.col_num)
                                      (progn
                                         (set_prop filter_state
                                                   `col_num
                                                   pos)
                                         (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                             (push filter_state.chars k)))
                                      (eq pos filter_state.col_num)
                                      (progn
                                          (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                                (push filter_state.chars k)))
                                      else
                                      (progn
                                        (push_into_selector pos k)))
                                  ;; update the displayed state of our filter 
                                  (show_filter_state)
                                  )))
                                                      
                                         
                                         
        (handle_keyup (fn (e)
                        (when (and e.srcElement
                                   (get_attribute e.srcElement "ctype"))
                          (let
                              ((elem e.srcElement)
                               (ctype (get_attribute elem "ctype"))
                               (pos (parseInt (get_attribute elem "pos")))
                               (final_pos stack.length))
                            ;(console.log "pos: " pos "press: " e)                           
                            (cond
                              (and (== e.key "ArrowUp")
                                   e.altKey)
                              (focus_to elem.parentElement.children.0)
                              (== e.key "ArrowUp")
                              (focus_to elem.previousElementSibling)
                              (== e.key "ArrowDown")
                              (focus_to elem.nextElementSibling)
                              (and (== e.key "ArrowLeft")
                                   (>= pos 0))
                              (progn
                                  (aif (element_for_pos (- pos 1))
                                   (focus_to it))
                                  (clear_selector true))
                              (== e.key "ArrowRight")
                              (progn
                                (console.log "moving to the right: " (element_for_pos (+ pos 1)))
                                (aif (element_for_pos (+ pos 1))
                                     (focus_to it)
                                     (focus_to (element_for_pos (+ pos 1) true))) ;; didn't get a standard list, it's probably a value of sort..
                                (clear_selector true))
                              (== e.key "Enter")
                              (progn
                                  (handle_event e)
                                  (handle_click e))
                              (== e.key "Backspace")
                              (pop_from_selector pos)
                              (== e.key "Tab")
                              nil
                              (> e.keyCode 47)
                              (progn
                               (push_into_selector pos e.key)
                               (console.log "filter state: " (as_lisp filter_state))))))))
                                                                                                                              
        (handle_click (fn (e)
                          (when (and e.srcElement 
                                     (get_attribute e.srcElement "ctype"))
                              (console.log "handle_click: " e.srcElement)
                              (let
                                  ((elem e.srcElement)
                                   (ctype (get_attribute elem "ctype"))
                                   (pos (get_attribute elem "pos"))
                                   (final_pos stack.length))
                                  (when pos
                                      (= pos (parseInt pos)))
                                  (clear_selector true)
                                  
                                  (console.log "handle_click: pos: " pos "final_pos:" final_pos ctype elem.innerText stack)
                                  (remove_class "juno-highlighted" e.srcElement.parentElement.children)
                                  (add_class "juno-highlighted" e.srcElement)
                                  (cond
                                     (== ctype "nspace")
                                     (progn
                                         (= stack [])
                                         (render_view e.srcElement.innerText)
                                         
                                         ;; next display the first namespace
                                         (= stack [ elem.innerText ])
                                         (render_view))
                                     (and (== ctype "sym")
                                          (== pos final_pos))
                                     (progn
                                         (push stack elem.innerText)
                                         (console.log "STACK is now: " stack)
                                         (render_view))
                                     (< pos final_pos)
                                     (progn
                                         (= stack (-> stack `slice 0 pos))
                                         (push stack elem.innerText)                                         
                                         (console.log "mid stack click: stack now: " (as_lisp stack) "view children:" (length cview.children) (range cview.children.length))
                                         (for_each (child_num (-> (range cview.children.length) `reverse))
                                            (progn
                                               (console.log "child_num: " child_num (prop cview.children child_num) (parseInt (get_attribute (prop cview.children child_num) `pos)))
                                                (when (> (parseInt (get_attribute (prop cview.children child_num) `pos)) (- stack.length 1))
                                                    (-> (prop cview.children child_num) `remove))))
                                         (render_view))                                         
                                     (== e.srcElement.tagName "LI")
                                     (progn
                                      (push stack  elem.innerText)                                 
                                      (render_view)
                                      ))))))
                            
        (cview (div { `style: "" `class: "juno-symbol-browser" }))
        (has_children? (fn (val)
                           (and (is_object? val)
                                (> (length val) 0))))
        (next_possibles (fn ()
                            (let
                               ((path (conj [ "context" "scope" ] (or (rest stack) [])))
                                (ns (first stack))
                                (idx -1)
                                (val nil))
                            (assert ns "No namespace yet - invalid stack")
                            (= val (resolve_path path (-> Environment `get_namespace_handle ns)))
                            (console.log "next_possibles: namespace:" ns path "value: " val)
                            (when options.on_select
                              (options.on_select ns (rest stack)))                            
                            (cond 
                              (is_function? val)
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   (value_to_dom val))
                              (is_array? val)                                                           
                              (for_each (symb (resolve_path path (-> Environment `get_namespace_handle ns)))
                                 (progn
                                     (inc idx)
                                     (li { `tabindex: 0 `ctype: (if (is_object? symb) "sym" (lowercase (subtype symb)))
                                       `pos: stack.length
                                       `title: (subtype symb)
                                       `class: (+ "juno-list-item " (if (has_children? symb) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb)))
                                      `style: li_style } idx)))
                              (is_object? val)                                                    
                              (for_each (symb (sort (pairs (resolve_path path (-> Environment `get_namespace_handle ns)))
                                                    { `key: [ 0 ] }))
                                 (li { `tabindex: 0 `ctype: (if (is_object? symb.1) "sym" (lowercase (subtype symb.1)))
                                       `pos: stack.length
                                       `title: (subtype symb.1)
                                       `class: (+ "juno-list-item " (if (has_children? symb.1) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb.1))) 
                                       `style: li_style } symb.0))
                                                                                   
                              (is_function? options.render_preview)
                              (let
                                  ((elem (options.render_preview)))
                                (if elem
                                  (if (get_attribute elem "ctype")
                                    elem
                                    (progn
                                     (-> elem `setAttribute `ctype "val")
                                     elem))
                                  (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                       "The render_preview function didn't return an element as expected.  Check call.")))
                              
                              (is_string? val)
                              (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   val)
                              
                              else         
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: 100%;" }
                                 (value_to_dom val))))))

        (render_view (fn (ns_name)
                       (progn
                        (console.log "render_view: stack " stack)
                        (if (> stack.length 1)
                          (set_prop path_span
                                    `innerText (+ "[ "(join " " (rest stack )) " ]"))
                          (set_prop path_span
                                    `innerText ""))                                    
                        (clear_selector true)
                        (cond
                          (== stack.length 0) ;; initial state
                          (progn
                           (-> cview `replaceChildren
                              (ol { `pos: 0 }
                               (for_each (ns (sort (namespaces)))
                                         (li {`tabindex: 0
                                              `ctype: "nspace"
                                              `pos: 0
                                              `class: (+ "juno-list-item juno-namespace" (if (== ns ns_name) " juno-highlighted" ""))
                                              `style: li_style
                                              } ns))))
                           (focus_to (element_for_pos 0)))
                          else
                          (progn
                           (defvar next_elem (next_possibles))
                           (cond
                             (is_array? next_elem)
                             (progn
                                 (-> cview `appendChild
                                    (ol { `pos: stack.length  }
                                         next_elem))                                 
                                 (setTimeout (fn () (focus_to (element_for_pos stack.length))) 10))
                             (is_element? next_elem)
                             (progn
                              (-> cview `appendChild                                 
                                  next_elem)
                              (-> next_elem `setAttribute "pos" stack.length)                              
                              (focus_to next_elem)))
                           
                           (set_prop cview `scrollLeft (+ cview.offsetWidth 20)))))))
                                                                                                                               
                          
        (view (control_frame { `id: id  `events: [[ "click" handle_click]
                                                  [ "keyup" handle_keyup ]] }
                             control_status
                             cview))
        (resize (fn ()
                  (progn                           
                   (let
                       ((new_height (- (prop view.parentElement `offsetHeight) 20))
                        (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                     (set_style [[ "width" (+ "" new_width "px") ]
                                 [ "height" (+ "" new_height "px") ]]
                                view)
                     (when options.on_resize
                       (options.on_resize self))))))
        (resize_observer (new ResizeObserver resize))
        (on_focus (fn ()
                   (progn                  
                    (add_class "juno-focused" control_status ))))
        (initialized false)
        (initialize (fn ()
                      (when (and view.parentElement
                                 (not initialized))
                        (= initialized true)                       
                        (-> resize_observer `observe view.parentElement)
                        (render_view (current_namespace))
                        (push stack (current_namespace))
                        (render_view)
                        (defglobal *sbcview* cview))))   ;; TODO: REMOVE 
        
        (to_json (function ()
                           `[symbol_browser ,#options])))

    
     (set_prop options
               `id id
               `name name)                
     (set_prop self
               `view view
               `options options
               `name name
               `type "symbol_browser"              
               `initialize initialize
               `resize resize
               `toJSON to_json
               `on_focus on_focus)
     self))

(defun symbol_chooser (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((ns nil)
                      (target_path target_path)
                      (set_val (fn (selected_ns selected_path)
                                   (progn 
                                      (console.log "ns: " selected_ns selected_path)
                                      (= ns selected_ns )
                                      (= target_path selected_path)
                                      (cond
                                        (blank? ns)
                                        (set_disabled new_symbol_button)
                                        (not (blank? ns))
                                        (progn
                                         (set_enabled new_symbol_button)
                                         (set_prop new_symbol_button
                                                  `innerText (+ (dtext "New Global Value"))))))))
                                            
                      (new_symbol_button (button { `tabindex: 0 `title: (dtext "Create New Entry") `style: "margin-left: 8px; margin-right: 8px;  font-weight: bold; background: var(--highlight-bg-color);" } (dtext "New")))
                      (path_span (span { `tabindex: 0 `title: (dtext "Click to copy path")  `class: "juno-path" } ""))
                      (symbol_ctl (symbol_browser { 
                                                   `additional_elements: [(span { `class: "juno-title" `style: "color:var(--main-color)" } (dtext "Open A Location"))
                                                                          (span { `title: (dtext "Edit Mode") `class: "juno-mode" } (if type type  ""))
                                                                          new_symbol_button
                                                                          ] 
                                                    `on_select: set_val }))
                      (ok_button (button { `class: "juno-primary" `style: "min-width: 100px; margin-right: 20px; margin-left: 20px; float:right; font-weight: bold;" } "OK"))
                      (cancel_button (button { `style: "margin-left: 20px;" }   "Cancel"))
                      (dwin (dialog { `style: "height: 40%; width: 60%; overflow: hidden; padding: 2px;" }                                                                    
                                    (div { `style: "height: calc(100% - 50px);" }
                                         symbol_ctl.view)
                                    (br)
                                    (div { `class: "juno-button-group pure-button-group" `role: "group" }
                                         cancel_button
                                         ok_button))))
                   (attach_event_listener new_symbol_button
                                          `click
                                          (fn (e)
                                            (progn
                                             (aif (request_user_input (+ "" (dtext "Enter the name to be created in") " " ns) `text)
                                                  (progn
                                                   (-> dwin `remove)
                                                   (-> (-> Environment `get_namespace_handle ns)
                                                       `set_global it "")
                                                   (resolve { `namespace: ns `path: [ it ] }))))))
                   (attach_event_listener ok_button
                                          `click
                                          (fn (e)
                                            (do                                              
                                              (resolve {
                                                  `namespace: ns
                                                  `path: target_path
                                                  })
                                              (-> dwin `remove))))                   
                   (attach_event_listener cancel_button
                                          `click
                                          (fn (e)
                                            (do
                                              (-> dwin `remove)
                                              (resolve nil))))
                   (-> juno_container
                       `appendChild dwin)
                   (set_prop symbol_ctl.options
                      `temporary true)
                   (-> symbol_ctl `initialize)
                   (when (is_function? dwin.showModal)
                     (-> dwin `showModal))))))


(defun make_autocompletion_scores (analysis_object)
   (let
      ((result_set [])
       (keywords (try (compiler `[ true ] { `special_operators: true `env: Environment } )
                    (catch Error (e)
                       (progn
                          (log "error on compiler: " e.message)
                          (new Set)))))
       (included (new Set))
       (score 0))
      (for_each (r (sort analysis_object.allocations))
         (progn
            (-> included `add r)
            (cond
               (contains? r analysis_object.globals)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local (shadowed global)" })
               else
               (push result_set
                  { `value: r `score: (inc score) `meta: "local" }))))
      (for_each (r (sort analysis_object.symbols))
         (cond
            (contains? r analysis_object.allocations)
            true ;; we already placed it 
            else
            (progn
               (-> included `add r)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local?" } ))))
      (for_each (r (sort analysis_object.keywords))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "keyword" })))
      (for_each (r (sort analysis_object.globals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "global" })))
      (for_each (r (sort analysis_object.literals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "literal" })))
      (for_each (r (sort (to_array keywords)))
         (if (not (-> included `has r))
             (progn
                (-> included `add r)
                (push result_set
                   { `value: r `score: (inc score) `meta: "keyword" }))))
      (for_each (r (sort (to_array (all_globals))))
         (if (not (-> included `has r))
             (push result_set
                { `value: r `score: (inc score) `meta: "global" })))
      result_set)
   {
       `usage: ["analysis_object:object"]
       `description: (+ "Given the output of process_tree_symbols, returns a result_set to be provided to the Ace autocomplete callback for "
                        "suggestions for autocomplete.")
       `tags: ["editor" "analysis" "autocomplete" "session" "Ace"]
   })

(defun find_root_forms_for_buffer (buffer_text options)
   (let
      ((lines (split_by "\n" buffer_text))
       (ldat nil)
       (lnum -1)
       (running_depth_for_line 0)
       (new_depth nil)
       (last_line_max_col 0)
       (boundaries nil)
       (depth_positions [])
       (current_root_form nil))
      
      (for_each (line lines)
                (progn
                   (inc lnum)
                   (= ldat (analyze_text_line line))
                   
                   (= boundaries (sort (conj (for_each (o ldat.openers)
                                                [o 1 (prop line o) ])
                                             (for_each (c ldat.closers)
                                                [c -1 (prop line c)]))
                                       { `key: [ 0 ] }))
                   (= last_line_max_col (or (last ldat.closers) (length line)))
                   (for_each (t boundaries)
                      (progn
                         (= running_depth_for_line (+ t.1 running_depth_for_line))
                         (cond
                            (and (eq nil current_root_form)
                                    (== running_depth_for_line 1))
                            (progn
                               (= current_root_form {
                                                      `start_row: lnum
                                                      `start_col: t.0
                                                      `end_row: nil
                                                      `end_col: nil
                                                      }))
                            (and current_root_form
                                 (== running_depth_for_line 0))
                            (progn
                               (set_prop current_root_form
                                  `end_row lnum
                                  `end_col t.0)
                               (push depth_positions current_root_form)
                               (= current_root_form nil)))))))
      (if (and options.flexibility
               current_root_form
               (> running_depth_for_line 0)) ;; most likely unclosed form
          (progn
             (set_prop current_root_form
                `end_row lnum
                `end_col last_line_max_col)
             (push depth_positions current_root_form)
             (= current_root_form nil)))
      depth_positions)
   {
     description: (+ "Given a text value as a string and an optional options object, returns an array of objects, "
                      "each representing the starting and ending positions of each found form.  The returned objects "
                      "have the keys: start_row, start_col, end_row, and end_col, which will be numeric offsets "
                      "from line 0 and column 0 respectively.<br>"
                      "If an options object is given with the key flexibility set to true, then if the final "
                      "form is incomplete, will return the start to final part of the end form.")
     usage: ["text_buffer:string" "options:object"]
     tags: ["forms" "parsing" "syntax" "selection" ]
     })

(defun get_root_form_for_position (buffer_text row column flexibility_mode)
   (let
      ((root_forms (find_root_forms_for_buffer buffer_text { flexibility: (if flexibility_mode true false) } ))
       (target nil))
      (for_each (form (or root_forms []))
         (progn
            (when (and (>= row form.start_row)
                       (<= row form.end_row))
               (cond 
                  (or (and (== form.end_row form.start_row)
                           (>= column form.start_col)
                           (<= column form.end_col))
                  
                      (> (- form.end_row form.start_row) 0))
                  (progn
                     (= target form)
                     (break))))))
      target)
   {
     description: (+ "Given a text buffer, a row number (>= 0) and a column number (>= 0), returns an object that has the "
                     "position values for the enclosing form to a depth of 0.  The object returned has " 
                     "the following layout: <br>"
                     "{ start_row:int end_row:int start_col:int end_col:int }<br>"
                     "All values start at offset 0.")
     tags: ["form" "position" "selection" "text" "lisp"]
     usage: ["buffer_text:string" "row:int" "column:int" "flexibility_mode:?boolean"]
   })


(defun floating_div (contents options)
   (let
      ((close_button (button { `title: (dtext "Close") } "X"))
       (move_state nil)
       (expander_elem (div { `style: "position: absolute; right: 0px; bottom: 0px; width: 15px; height: 15px; cursor: nwse-resize; background: transparent;" }
                           ""))
       (full_block (div { `style: "z-index: 8; width: 100%; height: 100%; position: absolute; top:0px; left: 0px;" }))
       (dims nil)
       (resize_mode false)
       (max_dims {
                  `width: 0
                  `height: 0
                  })
       (body_element nil)
       (block_on (fn (e)
                    (progn
                       (= dims (-> frame `getBoundingClientRect))
                       (= body_element (get_by_id "body"))
                       (= max_dims {
                                     `width: (prop body_element `offsetWidth)
                                     `height: (prop body_element `offsetHeight) })
                       (-> body_element `appendChild full_block)
                       (= move_state {
                                       mx: e.pageX
                                       my: e.pageY
                                       fx: dims.right
                                       fy: dims.top
                                       w: dims.width
                                       h: dims.height
                                       }))))
       (control_bar (div { `class: "juno-buffer-bar" style: "cursor: grab;" }
                 close_button
                 (or options.title "")))
       (end_drag (fn (e)
                    (progn
                       (= move_state nil)
                       (= resize_mode false)
                       (if (is_function? contents.resize)
                           (-> contents `resize))
                       (-> full_block `remove))))       
       (handle_drag (fn (e)
                      (when (and move_state
                                 (== e.buttons 1))
                         (if resize_mode
                            (set_style [["width"  (+ "" (Math.max 300 (Math.min (- max_dims.width 30) (+ dims.width (- e.pageX move_state.mx)))) "px")]
                                        ["height" (+ "" (Math.max 30 (Math.min (- max_dims.height 30) (+ dims.height (- e.pageY move_state.my)))) "px")]]
                                       frame)
                            (set_style [["top"  (+ "" (Math.max 0 (Math.min (- max_dims.height 30) (+ dims.top (- e.pageY move_state.my)))) "px") ]
                                        ["left" (+ "" (Math.max 0 (Math.min (- max_dims.width 30) (+ dims.left (- e.pageX move_state.mx)))) "px") ]]
                                       frame)))))
                                   
       (frame (div { class: "juno-floating-container" 
                     style: (+ "left: " (+ 50 (random_int 10)) "%; " 
                               "top: " (+ 5 (random_int 10)) "px; "
                                (if (is_string? options.style)
                                    (+ "" options.style ";")
                                    ""))
                                  }
               (control_frame {}
                control_bar
                (cond
                   (and (is_object? contents)
                        contents.view)
                   contents.view
                   (is_element? contents)
                   contents
                   else
                   (value_to_dom contents)))
               expander_elem)))
      
      (attach_event_listener close_button
         `click
         (fn (v)
            (progn
               (when options.on_close
                  (options.on_close))
               (-> frame `remove))))
      
      (attach_event_listener control_bar
         `mousedown
         (fn (e)
            (block_on e)))
      (attach_event_listener expander_elem
         `mousedown
         (fn (e)
            (progn
               (= resize_mode true)
               (block_on e))))
      
      
      (attach_event_listener full_block
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mousemove
                             handle_drag)
      (attach_event_listener full_block
                             `mousemove
                             handle_drag)
      (-> (get_by_id "body") `appendChild frame)
      ;; if we have a control, initialize it if it needs it since it is 
      ;; now mounted on the DOM
      (when contents.initialize
         (-> contents `initialize))
      
      true))

(defun monitor_control_tree ()
   (let
       ((view nil)
        (title_span (span { } "Control Structure"))       
        (update_timer nil))
     (if (get_by_id `control_tree_monitor)
       (notify "Control Tree Already Showing")
       (progn
        (setTimeout (fn ()
                      (set_prop title_span
                                `innerText
                                (dtext "Click to highlight a control")))
                    4000)
        (= view (div { `id: `control_tree_monitor }
                     (render_control_tree $root_controls)))
        (attach_event_listener view
                               `click
                               (fn (e)
                                 (let
                                     ((id (-> e.srcElement `getAttribute "control_id"))
                                      (body_element (get_by_id "body"))
                                      (dims nil)
                                      (highlighter nil)
                                      (control (if id (get_control_by_id id))))
                                   (when control
                                     (when control.view
                                       (= dims (-> control.view `getBoundingClientRect))
                                       (console.log "control dims: " control.name dims)
                                       (-> body_element `appendChild
                                           (= highlighter (div { `id: "highlighter" `class: "identification" `style: (+ "z-index: 7; position: absolute; top: " dims.top "px; left: " dims.left "px; width: " (- dims.width 5) "px; height: " (- dims.height 5) "px; border: 3px dashed red;") }
                                                           "")))
                                       (setTimeout (fn ()
                                                     (do 
                                                        (aif (get_by_id "highlighter")
                                                             (-> it `remove))
                                                        (-> highlighter `remove)))
                                                   1000))))))
                                   
        (= update_timer (setInterval (fn ()
                                     (progn                                        
                                        (-> view `replaceChildren (render_control_tree $root_controls))))
                                     1000))
        (floating_div view
                      {  `title: title_span
                         `on_close: (fn ()
                                     (progn
                                      (clearInterval update_timer)))
                       })))))

  

(defun handle_lisp_format_event (val editor)
  (progn    
    (when (and (== (- val.end.row val.start.row) 1)
              (== val.action "insert"))     
       (defvar indent_string (format_lisp_line val.end.row (function (rnum) 
                                                                     (-> editor.session `getLine rnum))))
       (when indent_string
        (-> editor.session `indentRows val.end.row val.end.row indent_string)))))

(defun_sync indent_editor_line (editor row_number options)
  (if (is_number? row_number)
    (let
        ((line (-> editor.session `getLine row_number))
         (orig_line (clone line))
         (indent_string (format_lisp_line row_number
                                          (or options.get_row
                                              (function (rnum) 
                                                        (-> editor.session `getLine rnum))))))
      (console.log "indent_row: " row_number "indent_string: " indent_string line)
      (if indent_string
        (progn
         (setq line (+ "" indent_string (trim line)))
         (console.log "line at " row_number " to be replaced with: " (JSON.stringify line))
         (if options.apply
           (progn
            (-> editor.selection `clearSelection)
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `remove (-> editor.selection `getRange))
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `replace (-> editor.selection `getRange) line)
            (console.log "indent_editor_line: get_line: " (JSON.stringify (-> editor.session `getLine row_number)))
            (-> editor.selection `clearSelection)
            true)
           line))        
        line))
    (throw EvalError "invalid row_number provided to indent_row")))

(defun_sync indent_editor_selection (editor)
  (let
      ((start nil)
       (end nil)
       (selected_range (clone (-> editor.selection `getRange))))
    
    (= start selected_range.start.row)
    (= end selected_range.end.row)
    (console.log "tab: start: selected_range: " (JSON.stringify selected_range))
    (-> editor.selection `clearSelection)
    (-> editor.selection `setSelectionAnchor start 0)
    (-> editor.selection `selectTo end 0)
    (-> editor.selection `selectLineEnd)
    (console.log "tab: start: fully selected_range: " (-> editor.selection `getRange))                                                   
    (defvar lines (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
                            (-> editor.session `getLine row_number)))
    (console.log "tab: lines: pre-change: " (clone lines))
    
    (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
              (progn
               (console.log "tab: [start]: [ " selected_range.start.row selected_range.end.row " ] analyzing row: " row_number ": " (JSON.stringify (prop lines (- row_number start))))
               (set_prop lines
                         (- row_number start)
                         (indent_editor_line editor row_number
                                     { get_row: (function (rnum)
                                                          (progn
                                                           (console.log "get_row: rnum: " rnum " relative: " (- rnum start))
                                                           (cond
                                                             (and (>= rnum start)
                                                                  (< rnum end))
                                                             (prop lines
                                                                   (- rnum start))
                                                             else
                                                             (-> editor.session `getLine rnum)))) ;; not impacted by the change
                                      } ))))
    
    (console.log "tab: adjusted lines: " lines)
    (console.log "tab:     lines joined: " (join "\n" lines))
    (-> editor.session `replace (-> editor.selection `getRange) (join "\n" lines))
    (-> editor.selection `selectLineEnd)
    ;(-> editor.selection `setRange selected_range)
    (console.log "tab: reselected fixed: " (-> editor `getCopyText))))


(defun_sync select_to_current_form (editor pos)
  (if editor
    (let
        ((rng (-> editor `getSelectionRange))
         (already_selected? (if (and (== rng.start.row rng.end.row)
                                     (== rng.start.column rng.end.column))
                                false
                                true))
         (cpos (or pos 
                   (if already_selected?
                      (progn
                         (-> editor `navigateTo rng.start.row rng.start.column)
                         (-> editor `getCursorPosition))
                      (-> editor `getCursorPosition)))))
      (when cpos
        (= rng (find_last_paren editor cpos))
        (when rng
          (-> editor.selection `clearSelection)
          (-> editor.selection `setRange rng)))
      rng)
    nil)
  {
   description: (+ "Given an editor and an optional position { row column }, if possible, "
                   "selects the innermost current form (expression) in the editor and "
                   "returns the range.")
   usage: ["editor:object" "pos:?object"]
   tags: ["editor" "selection" "form" "lisp" "editing" ]
   })
          
           
(defun show_editor_keybindings (editor_control)
   (let
      ((binding_row (fn (keysequence binding)
                       (tr
                          (td keysequence)
                          (td (or binding.description
                                  (from_key binding.name)))))))
      (table { `style: "width: 100%" }
             (thead
                (tr
                   (th "Key Sequence")
                   (th "Description")))
             (tbody
                (for_each (bindpair (sort (pairs (editor_key_bindings editor_control.editor))
                                          { `key: [`0] }))
                   (destructuring_bind (keysequence binding)
                      bindpair
                      (cond
                         (is_array? binding)
                         (for_each (bindval binding)
                            (binding_row keysequence bindval))
                         (is_object? binding)
                         (binding_row keysequence binding)
                         else
                         [])))))))

(defun show_key_bindings ()
   (let
      ((platform (get_operating_platform))
       (default_editor_keys (if (-> Environment `get_global "*orig_key_bindings*" nil)
                                (reduce (entry (values (-> Environment `get_global "*orig_key_bindings*")))
                                   (when (prop entry.bindKey platform)
                                      (to_object
                                         [[`name entry.name]
                                          [`description entry.description]
                                          [ (+ "" platform) (prop entry.bindKey platform) ]])))))
       
                                       
       (categories (reduce (k (keys *key_bindings* ))
                      (unless (== k "active")
                         k)))
       (td_style (function () 
                    { `style: "vertical-align:top; padding: 5px; border-bottom: 1px solid var(--main-accent-line);" } ))
       (table_values  (sort
                           (conj (-> (for_each (category categories)
                                        (for_each (binding (pairs (resolve_path [ category ] *key_bindings*)))
                                           (destructuring_bind (name entry)
                                              binding
                                              [ (prop entry platform)
                                               (from_key name)
                                               (from_key category)
                                               (or (prop entry `description)
                                                   "No Description") ] )))
                                     `flat 1)
                                 
                                 (for_each (binding default_editor_keys)
                                    [(prop binding platform)
                                     (from_key binding.name)
                                     "Editor"
                                     (or (prop binding `description)
                                         "No Description")]))
                           { `key: [`0] }
                            )))
      (log "Table values: " table_values)
      (table { `style: "width: 100%" }
         (thead
            (tr { `style: "" }
               (th { `style: "padding: 5px;" } "Key Binding")
               (th { `style: "padding: 5px;" } "Command")
               (th { `style: "padding: 5px;" } "Scope")
               (th { `style: "padding: 5px;" } "Description")))
         (tbody
            (for_each (row table_values)
               (tr { `style: "padding: 5px; " }
                  (td (td_style) row.0)
                  (td (td_style) row.1)
                  (td (td_style) row.2)
                  (td (td_style) row.3))))))
   {
     `description: "Returns a table DOM element of the current key bindings."
     `usage: []
     `tags: ["help" "keys" "bindings" "display" ]
     })

(defun_sync select_root_form (editor pos)
   (if (and (is_object? editor)
            (is_object? pos))
       (let
          ((last_selection nil)
           (idx 0)
           (current_selection nil))
          ;; start with the current position
          (= current_selection (find_last_paren editor pos))
          (while (and (< idx 100)
                      current_selection
                      (or (eq nil last_selection)
                          (not (and (== last_selection.start.column current_selection.start.column)
                                    (== last_selection.start.row current_selection.start.row)
                                    (== last_selection.end.column current_selection.end.column)
                                    (== last_selection.end.row current_selection.end.row)))))
             (progn
                (inc idx)
                (= last_selection current_selection)
                (= current_selection (find_last_paren editor current_selection.start))
                ))
          (aif current_selection
             {
               `start_row: it.start.row
               `start_col: it.start.column
               `end_row: it.end.row
               `end_col: it.end.column
               })
             ))
   {
     `usage: ["editor:object" "pos:object"]
     `description: "Given an editor and a position, returns the determined root form for the position."
     `tags: ["selection" "editor" "root" "form" "position"]
     })

(defun select_to_root_form (editor pos)
   (if editor
       (let
          ((cpos (-> editor `getCursorPosition))
           (pos (if pos
                    (select_root_form editor pos)
                     (select_root_form editor cpos))))
          (when pos
             (-> editor.selection `clearSelection)
             (-> editor.selection `setSelectionAnchor pos.start_row pos.start_col)
             (-> editor.selection `selectTo pos.end_row (+ pos.end_col 1))
             true))
       (throw TypeError "editor must be provided to select_to_root_form"))
   {
       description: (+ "Given an editor and an optional position, will select the complete form (to a depth of 0) if possible. "
                        "If given a position object with a row and column value, the function will use that instead.  If "
                        "succesful, the value true will be returned.  If no editor is provided, the function will throw a "
                        "TypeError.")
       usage: ["editor:object" "pos:?object"]
       tags: ["editor" "selection" "form" "lisp" "editing"]
   })


(defun get_juno_autocompletions (editor session pos prefix callback)
   (let
      ((root_form (select_root_form editor pos))
       (collect_error (fn (e)
                         true))
       (text_data (+ "" (-> editor.session `getTextRange (new ace.Range root_form.start_row root_form.start_col root_form.end_row root_form.end_col)) ")"))
       (tokens (reader text_data { `suppress_throw_on_error: true on_error: collect_error  } )))
      
      (= tokens (make_autocompletion_scores (process_tree_symbols tokens prefix)))
      (callback null tokens))
   {
       `usage: ["editor:object" "session:object" "pos:object" "prefix:text" "callback:fn" ]
       `description: "Internally used by the editor for autocompletion."
       `tags: ["ace" "editor" "autocomplete" ]
   })
 
(defun clone_edit_session (session)
   (let
      ((s (new ace.EditSession (-> session `getDocument)
                               (-> session `getMode)))
       (undoManager (-> session `getUndoManager)))
      (-> s `setUndoManager undoManager)
      (-> s `setTabSize (-> session `getTabSize))
      (-> s `setUseSoftTabs (-> session `getUseSoftTabs))
      (-> s `setOverwrite (-> session `getOverwrite))
      (-> s `setBreakpoints (-> session `getBreakpoints))
      (-> s `setUseWrapMode (-> session `getUseWrapMode))
      (-> s `setUseWorker (-> session `getUseWorker))
      (-> s `setWrapLimitRange session.$wrapLimitRange.min session.$wrapLimitRange.max)
      (set_prop s session.$foldData
         (-> session `$cloneFoldData))
      s))

(defun eval_selected_text_in_place (ctl options)
   (progn
      (let
         ((text (-> ctl `get_selected_text))
          (editor (or ctl.editor
                      options.editor
                      (throw TypeError "eval_selected_text_in_place: no editor for provided control")))
          (selection (-> ctl `get_selection))  ;; range to replace with results
          (evaluator nil)
          (result nil))
         (= evaluator
            (cond
               (is_function? options.evaluator)
               options.evaluator
               ctl.get_evaluator
               (-> ctl `get_evaluator)))
         (assert (is_function? evaluator) "eval_selected_text_in_place: no evaluator found for control or in provided options.")
         (= result (evaluator text false true true))
         (log "result: " result)
         (= result
            (cond
               (is_object? result)
               (if options.as_json
                  (JSON.stringify result nil 2)
                  (+ "" (as_lisp result)))
               (is_string? result)
               result
               else
               (+ "" (as_lisp result))))
         (try 
            (-> (-> editor `getSession) `replace selection result)
            (catch Error (e)
               (progn
                  (-> (-> editor `getSession) `replace selection text)
                  (-> ctl `display_context_message (+ "Error on replace: " e.message))
                  (log (+ (dtext "Couldn't replace text in editor") ":" (prop ctl.options `name) ": " e.message))
                  (log e))))
         ))
   {
     description: (+ "Given a control with an editor, the selected text is evaluated " 
                     "using the editors evaluator.  The evaluated selection is replaced with the result."  
                     "An optional 'evaluator' function can be passed to be used as the evaluator instead "
                     "of the controls default evaluator.  If 'as_json' as true, then the result will be "
                     "written as a JSON object in the editor.")
     usage: ["control:object" "options:?object"]
     tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })


(defun make_editor (content options)
   (let
      ((options (or options {
                              `mode: "juno"
                              }))
       (resize_observer nil)
       (intf {})
       (initialized false)
       (config_value (function (key default_value)
                        (or (prop options key)
                            (resolve_path [ `editor key ] *env_config*)
                            default_value)))
       (id (or options.id (generate_id id)))
       (content (or content ""))
       (controls (div { `style: "display: flex; " }))
       (parent_view nil)
       (name (name_control (or options.name "Untitled Buffer")))
       (context_clear_timer nil)
       (display_context_message (function (value)
                                   (if (and (blank? value)
                                            context_clear_timer)
                                       nil
                                       (progn
                                          (when context_clear_timer
                                             (clearTimeout context_clear_timer))
                                          (= context_clear_timer nil)
                                          (when (not (blank? value))
                                             (= context_clear_timer (setTimeout (fn () (= context_clear_timer nil)) 3000)))  ;; delay for clearing the message to quickly if a blank comes in
                                          (cond
                                             (is_element? value)
                                             (-> help_context_elem
                                                 `replaceChildren value)
                                             else
                                             (-> help_context_elem
                                                 `replaceChildren (span { `style: "display: inline-block; text-overflow: ellipsis; width: 100%; overflow: hidden" } (+ "" value))))))))
       (check_observer (fn ()
                          (when (not (== view.parentElement parent_view))
                             (-> resize_observer `disconnect)
                             (-> resize_observer `observe view.parentElement)
                             (= parent_view view.parentElement))))
       
       (help_context_elem (div { `class: "juno-help-context" } ""))
       (context_bar (div { `class: "juno-context-bar" }
                     help_context_elem))
       (offset_depth 46)
       (editor_div (div { `class: "opacity-0" `style: (+ "height: calc(100% - " offset_depth  "px); width: 100%; overflow: hidden;font-family:var(--main-mono-space);") }))
       
       (view (div { `control_id: id `style: "overflow: hidden; height: calc(100% - 10px); display: inline-block; width: inherit;" }
              controls
              editor_div
              context_bar))
       
       (perform_resize (fn ()
                          (when view.parentElement
                             (check_observer)
                             (html/set_style [["width" "calc(100% - 2px)"];           (+ "" (- (prop view.parentElement `offsetWidth) 2) "px")]
                                              ["height" (+ "" (- (prop view.parentElement `offsetHeight) 2) "px")]]
                              view)
                             (set_style [["height" (+ "calc(100% - " (+ (Math.max 12 controls.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] editor_div)
                             (when editor
                                (-> editor `resize)))))
       (editor nil)
       (set_evaluator (fn ()
                         (when options.evaluator
                            (dispatch_event { command: "editor_change" 
                                              source: options.id
                                              args: [ { `option: "evaluator" `value: options.evaluator } ] })
                            (aif (get_keybinding "editor" "evaluate_selection")
                                 (bind_key "evaluate_selection" evaluate_selection)
                                 (-> editor.commands `addCommand
                                     {
                                       `name: "evaluate_selection"
                                       `bindKey: { `win: "Shift-Enter" `mac: "Shift-Enter" }
                                       `exec: evaluate_selection
                                       })))))
       
       (evaluate_selection (function (editor)
                              (let
                                 ((rval nil)
                                  (copytext (if options.repl_mode
                                                (-> editor `getValue)
                                                (-> editor `getCopyText))))
                                 (if (blank? copytext)
                                     (if (not options.repl_mode)
                                         (display_context_message (dtext "Please highlight text to evaluate")))
                                     (try
                                        (progn
                                           (= rval (options.evaluator copytext nil (not options.repl_mode)))
                                           (-> rval `then
                                               (function (val)
                                                  (setTimeout (fn ()
                                                                 (cond
                                                                    (instanceof val Error)
                                                                    (display_context_message (+ (subtype val)
                                                                                                (if val.message (+ ":" val.message)
                                                                                                    "")))
                                                                    (is_function? val)
                                                                    (display_context_message (+ "<- " (subtype val)))
                                                                    else
                                                                    (progn
                                                                       (defvar chopped (as_lisp val))
                                                                       (if (> chopped.length 200)
                                                                           (= chopped (+ (-> chopped `substr 0 200) "...")))
                                                                       (display_context_message (+ "<- " chopped)))))
                                                   100))
                                               (function (e)
                                                  (progn
                                                     (notify "Failure on evaluation")
                                                     (setTimeout (fn ()
                                                                    (cond
                                                                       (instanceof e Error)
                                                                       (display_context_message (+ (subtype e)
                                                                                                   (if e.message (+ ":" e.message)
                                                                                                       "")))
                                                                       else
                                                                       (display_context_message "Evaluation Failure")))
                                                      100)))))
                                        (catch Error (e)
                                           (progn
                                              (notify (+ (dtext "Unhandled error") ": " e.message ))
                                              (console.error e))))))))
       
       (font_size (config_value `font_size 14))
       (increase_font_size (function ()
                              (when font_size
                                 (= font_size (Math.min 200 (+ font_size 1)))
                                 (set_prop options
                                    `font_size font_size)
                                 (console.log "editor: options: " options)
                                 (-> editor `setFontSize font_size))))
       (decrease_font_size (function ()
                              (when font_size
                                 (= font_size (Math.max 1 (- font_size 1)))
                                 (set_prop options
                                    `font_size font_size)
                                 (console.log "editor: options: " options)
                                 (-> editor `setFontSize font_size))))
       (select_form_root (fn ()
                            (progn
                               (select_to_root_form editor)
                               nil)))
       (evaluate_root_form (fn ()
                              (let
                                 ((cpos (current_position)))
                                 (select_form_root)
                                 (evaluate_selection editor)
                                 (sleep 0.02)
                                 (-> editor.selection `clearSelection)
                                 (-> editor `navigateTo cpos.row cpos.column)
                                 )))
                                
       (select_current_form (fn ()
                               (select_to_current_form editor)))
       (get_selected_text (function () 
                             (-> editor `getSelectedText)))
       (get_selection (function ()
                         (-> editor.selection `getRange)))
       (get_lines (function (from to)
                     (-> editor.selection `getLines from to)))
       (is_selected? (function ()
                        (progn
                           (defvar rng (get_selection))
                           (not (and (== rng.start.row rng.end.row)
                                     (== rng.start.column rng.end.column))))))
       (last_bracket_match nil)
       (active_lisp_operator nil) ;; the last active lisp operator
       (current_position (fn ()
                            (-> editor `getCursorPosition)))
       (find_active_lisp_operator (function ()
                                     (let
                                        ((new_op nil)
                                         (rnge (or (-> editor.session `getBracketRange (-> editor `getCursorPosition))
                                                   (find_last_paren editor)))
                                         (usage nil))
                                        (if rnge
                                            (progn
                                               (= last_bracket_match rnge)
                                               (= new_op (first (split_by *whitespace_regexp* (-> editor.session `getTextRange last_bracket_match))))
                                               
                                               (when (not (== new_op active_lisp_operator))
                                                  (= active_lisp_operator new_op)
                                                  (= usage (decorative_usage active_lisp_operator))
                                                  (if usage 
                                                     (-> help_context_elem
                                                        `replaceChildren usage)
                                                     (-> help_context_elem `replaceChildren))
                                                  (when usage 
                                                     (dispatch_event { `command: "display_usage" `source: id `args: [active_lisp_operator] }))
                                                  (when options.on_new_lisp_operator
                                                     (options.on_new_lisp_operator active_lisp_operator))))
                                            (progn
                                               (= active_lisp_operator nil)
                                               (-> help_context_elem
                                                   `replaceChildren)
                                               (when options.on_new_lisp_operator
                                                  (options.on_new_lisp_operator nil)))))))
       
       (indent_row (function (row_number options)
                      (indent_editor_line editor row_number options)))
       
       (indent_current_row (function (editor)
                              (when (== *last_focus* intf)
                                 (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                    (if (not (is_selected?))
                                        (progn
                                           (defvar row_number (prop (-> editor `getCursorPosition)
                                                                    `row))
                                           (console.log "tab: start: single line: " row_number)
                                           (indent_row row_number { `apply: true }))
                                        (indent_editor_selection editor))))))
       
       (bind_key (fn (key_command func)
                    (aif (get_keybinding "editor" key_command)
                         (progn
                            ;(log "binding command: " key_command it (prop it (get_operating_platform)) (to_ace_keybinding key_command it func))
                            ;(if (is_string? key_command) 
                             ;   (try
                              ;    (if (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding (prop it (get_operating_platform)) ] editor)
                               ;       (delete_path [ `keyBinding `$defaultHandler `commandKeyBinding (prop it (get_operating_platform)) ] editor))
                                ;  (catch Error (e)
                                 ;    (log "ERROR on finding existing keybinding: " e.message))))
                            (-> editor.commands `addCommand
                                (to_ace_keybinding key_command it func))))))
       (request_save (function ()
                        (progn
                           (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] }))))
       
       (save_complete (function (event_obj)
                         (progn
                            (if options.create_mode
                               (delete_prop options `create_mode))
                            (display_context_message (+ "Saved " (cond 
                                                                    (and (== event_obj.args.0.type "path")
                                                                         (is_array? event_obj.args.0.target))
                                                                    (join "~" event_obj.args.0.target)
                                                                    (== event_obj.args.0.type "filename")
                                                                    event_obj.args.0.target)))
                            (log "editor: save_complete: " (clone event_obj))
                            (when options.on_save
                               (-> options `on_save intf)))))
       
                     
       (orig_bindings nil)                  
       (build_key_bindings (fn (editor)
                              (progn
                                 (console.log "building_key_bindings")
                                 ;; we need to remove any keybinding that interferes with our globals and then
                                 ;; rebuild to the right scope
                                 (= orig_bindings (clone (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor)))
                                 (defglobal *orig_key_bindings* orig_bindings)
                                 (when options.on_save
                                    (bind_key "on_save" request_save))
                                 (bind_key "increase_font_size" increase_font_size)
                                 (bind_key "decrease_font_size" decrease_font_size)
                                 (bind_key "select_form_root" select_form_root)
                                 (bind_key "select_current_form" select_current_form)
                                 (bind_key "indent_current_row" indent_current_row)
                                 (bind_key "evaluate_selection" evaluate_selection)
                                 (bind_key "evaluate_root_form" evaluate_root_form)
                                 (bind_key "evaluate_selected_in_place" (fn (editor)
                                                                           (progn
                                                                              (setTimeout (fn ()
                                                                                             (try
                                                                                                (progn
                                                                                                   (defvar rval (eval_selected_text_in_place (get_control_by_editor editor)))
                                                                                                   true)
                                                                                                (catch Error (e)
                                                                                                   (display_context_message "Error on evaluation: " e.message))))
                                                                                          10)
                                                                              true)))
                                                                           
                                 (when (is_array? options.commands)
                                    (for_each (command options.commands)
                                       (do
                                          (console.log "optional commands: " command.name command)
                                          (-> editor.commands `addCommand
                                              (to_ace_keybinding command.name command)))))
                                 (console.log "building_key_bindings: complete.")
                                 true)))
       
       (linked_editor nil)
       (initialize_editor (fn ()
                             (when (not initialized)
                                (let
                                   ((comps nil)
                                    (remote_content nil)
                                    (start_time (time_in_millis))
                                    (identifier_regex (new RegExp "[A-Za-z*+0-9_\\$\\u00A2-\\uFFFF]+"))
                                    (extension nil))
                                   (setq initialized true)
                                   (setq parent_view view.parentElement)
                                   (setq editor
                                         (ace.edit editor_div))
                                   (console.log "initialize_editor: " options.mode " options: " (clone options))
                                   (console.log "initialize_editor: loading ace langtools: ace/ext/language_tools..")
                                   (defglobal LangTools (-> ace `require "ace/ext/language_tools"))
                                   (console.log "initialize_editor: loaded langtool")
                                   ;; are we a cloned editor?
                                   
                                   (when options.clone_with_editor_id
                                      (let ((control_to_clone (get_control_by_id options.clone_with_editor_id))
                                            (new_session nil))
                                         (when (and control_to_clone
                                                    control_to_clone.editor)
                                            (= new_session (clone_edit_session control_to_clone.editor.session))
                                            (= linked_editor control_to_clone.options.id)
                                            (-> editor `setSession new_session))))
                                            
                                   (unless options.evaluator
                                      (when *system_repl*
                                         (display_context_message (+ "Evaluator for this buffer is " (prop *system_repl* `name)))
                                         (set_prop options
                                            `evaluator
                                            (prop *system_repl* `evaluate))))
                                   
                                   (set_evaluator)
                                   
                                   (when options.on_focus
                                      (-> editor `on `focus options.on_focus))
                                   (when options.on_blur
                                      (-> editor `on `blur options.on_blur))
                                   (when options.read_only
                                      (-> editor `setReadOnly true))
                                   (when options.on_click
                                      (-> editor `on `click options.on_click))
                                   (unless linked_editor
                                      (-> editor.session `setUseSoftTabs true)
                                      
                                      (-> editor.session `setUseWorker true)
                                      (-> editor.session `setUseSoftTabs true))
                                   (-> editor `setShowFoldWidgets true)
                                   
                                   ;; set the extension if we haven't been given a specific option mode
                                   (when (and (eq nil options.mode)
                                              (is_string? options.filename))
                                      (= comps (split_by "." options.filename))
                                      (when (> comps.length 1)
                                         (= extension (edit_mode_for_extension (last comps)))
                                         (console.log "make_editor: setting extension: " extension " based on: " options.filename)
                                         (set_prop options
                                            `mode
                                            extension)))
                                   (console.log "initialize_editor: setting mode: " (clone options.mode) " options: " (clone options))
                                   (cond
                                      (== options.mode "juno")
                                      (progn
                                         (console.log "mode to juno")
                                         (-> editor.session `setMode "ace/mode/juno")
                                         (-> editor `setOptions {
                                                                  `enableBasicAutocompletion:  [{ identifierRegexps: [ identifier_regex ]
                                                                                                  getCompletions: (fn (editor session pos prefix callback)
                                                                                                                     (get_juno_autocompletions editor session pos prefix callback)) }] 
                                                                  enableLiveAutocompletion: true
                                                                  enableSnippets: true
                                         }))
                                      (== options.mode "javascript")
                                      (progn
                                         (-> editor `setOptions {
                                                                  `enableLiveAutocompletion: true
                                                                  `enableBasicAutocompletion: true })
                                         (-> editor.session `setMode "ace/mode/javascript"))
                                      (== options.mode "css")
                                      (progn
                                         (-> editor.session `setMode "ace/mode/css")
                                         (-> editor `setOptions {
                                                                  `enableLiveAutocompletion: true
                                                                  `enableBasicAutocompletion: true }))
                                      options.mode
                                      (progn
                                         (-> editor.session `setMode options.mode)
                                         (-> editor `setOptions {
                                                               `enableLiveAutocompletion: true
                                                                  `enableBasicAutocompletion: true })))
                                   (console.log "initialize_editor: mode set done.")
                                   
                                   (cond
                                      (is_string? options.theme)
                                      (setTimeout (fn () (progn
                                                       (-> intf `set_theme options.theme)
                                                       (remove_class "opacity-0" editor_div))) 50)
                                      else
                                      (aif (resolve_path [ `editor `default_theme ] *env_config*)
                                           (setTimeout (fn ()
                                                          (progn
                                                             (-> intf `set_theme it)
                                                             (remove_class "opacity-0" editor_div))) 50)))
                                   (build_key_bindings editor)
                                   (-> editor `setOptions {
                                                            `showFoldWidgets: true
                                                            `cursorStyle: "wide"
                                                            `firstLineNumber: (or options.first_line_number 0)
                                                            `useSoftTabs: true
                                                            `highlightActiveWord: true
                                                            })
                                   (if (not linked_editor)
                                      (if (is_string? options.filename)
                                          (if is_served?
                                             (try
                                                (progn
                                                   (console.log "initialize_editor: requesting: " options.filename)
                                                   (if options.create_mode
                                                      (= remote_content "")
                                                      (= remote_content (-> (fetch (+ "/files/" options.filename)) `text)))
                                                   (console.log "initialize_editor: received content: time: " (- (time_in_millis) start_time) "ms")
                                                   (if (is_string? remote_content)
                                                       (-> editor `setValue remote_content -1)
                                                       (progn
                                                          (-> editor `setValue content)
                                                          (display_context_message (+ "NOTICE: unable to fetch file: " options.filename " (editor set to local value)")))))
                                                (catch Error (e)
                                                   (progn
                                                      (-> editor `setValue content)
                                                      (display_context_message (+ "ERROR on fetching: " options.filename " (editor set to local value)  " e.message))
                                                      (log "Error on fetching file: " options.filename ": " e))))
                                             (progn
                                                (-> editor `setValue content)
                                                (display_context_message (+ "NOTICE: not online, so the file cannot be fetched.  Using existing local value at path."))))
                                          (progn
                                             (-> editor `setValue content -1)
                                             (unless options.repl_mode 
                                                (display_context_message "Editing local value")))))
                                      
                                            
                                   (console.log "initialize_editor: setting font size...")   
                                   (if (eq nil font_size)
                                       (= font_size (parseInt (-> editor `getFontSize)))
                                       (-> editor `setFontSize font_size))
                                   (set_prop options
                                      `font_size
                                      font_size)
                                   (set_prop options
                                      `name name
                                      `id id)
                                      
                                   (console.log "initialize_editor: loading ace/token_iterator..")
                                   (defglobal TokenIterator (prop (-> ace `require "ace/token_iterator") `TokenIterator))
                                   (console.log "initialize_editor: loaded token_iterator");
                                   (when options.on_change
                                      (-> editor `on `change (function (val)
                                                                (progn
                                                                   (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                                                      (when (not linked_editor)
                                                                         (handle_lisp_format_event val editor))
                                                                      (find_active_lisp_operator))
                                                                    (when (not linked_editor)
                                                                       (dispatch_event { command: "editor_change" 
                                                                                         source: options.id
                                                                                         args: [ val ] }))
                                                                   (options.on_change editor val)))))
                                   (-> editor `resize true)
                                   (unless options.clone_with_editor_id
                                      (try
                                         (aif (-> editor.session `getUndoManager)
                                              (-> it `reset))
                                         (catch Error (e)
                                            (log "ERROR on undo manager:" e,message))))
                                   (set_prop intf `editor editor)
                                   (when (is_object? options.on_mode_set)
                                      (options.on_mode_set options.mode))
                                   (dispatch_event { command: "editor_change" 
                                                     source: options.id
                                                     args: [ { `option: "mode" `value: options.mode } ] })
                                   
                                   (console.log "initialize_editor: is this a linked_editor: " linked_editor)
                                   (when linked_editor
                                      (defvar pos (-> (prop (get_control_by_id linked_editor) `editor)
                                                      `getCursorPosition))
                                      (-> editor `navigateTo  pos.row pos.column)
                                      (-> editor `scrollToLine pos.row true nil)
                                   
                                      (register_event_handler linked_editor 
                                                              "destroy_control"
                                                              id
                                                              (fn (event_obj)
                                                                 (progn
                                                                    (log options.id ": handle_event: received: destroy_control" event_obj)
                                                                    (when linked_editor 
                                                                       (log options.id ": handle_event: linked_editor:" event_obj)
                                                                       (remove_event_handler linked_editor "destroy_control"))
                                                                    ))))
                                   (console.log "initialize_editor: time: " (- (time_in_millis) start_time) " base initialization complete: " (clone options))
                                   (when options.on_initialized
                                      (options.on_initialized intf))
                                   )))))
       
      (set_prop options
               `id
               id)
    
      (if (not (is_symbol? `$ace_editor))
          (throw TypeError "$ace_editor symbol not found, and is required for this editor."))
      
      (when (is_element? options.command_bar)
         (-> controls `prepend options.command_bar))
      (set_style [["height" (+ "calc(100% - " (+ (Math.max 12 controls.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] editor_div )
      
      (= resize_observer (new ResizeObserver perform_resize))
      (= intf
       {
         `view: view
         `editor: editor
         `set: (fn (text)
                  (-> editor `setValue text))
         `get: (fn (text)
                  (-> editor `getValue))
         `get_selection: get_selection
         `get_selected_text: get_selected_text
         `is_selected?: is_selected?
         `type: `make_editor
         `can_hide?: (fn ()
                        (progn
                           ;(log "editor: can_hide? " (get_editors_for_path options.path) "<= 1 can hide" options.path)
                           (< (length (get_editors_for_path options.path)) 2)))
         `destroy: (fn ()
                      (when editor
                         ;(defvar others_and_me (get_editors_for_path options.path))
                         ;(log "editor: " options.name ": got destroy..dispatching event: others and me: " others_and_me.length (< others_and_me.length 2))
                         ;(log "editor: remaining editors for path: " (each (get_editors_for_path options.path) `options))
                         (dispatch_event { `command: "destroy_control" `source: options.id `args: [  ]  })
                         (-> editor `destroy)
                         (= editor nil)
                         (= intf nil)))
         
         `set_evaluator: (fn (new_evaluator)
                            (when (is_function? new_evaluator)
                               (set_prop options
                                  `evaluator
                                  new_evaluator)
                               (set_evaluator)))
         `set_mode: (fn (mode_name)
                       (progn
                          (set_prop options
                             `mode
                             mode_name)
                          (cond
                             (== options.mode "juno")
                             (-> editor.session `setMode "ace/mode/juno")
                             (== options.mode "javascript")
                             (-> editor.session `setMode "ace/mode/javascript")
                             (== options.mode "css")
                             (-> editor.session `setMode "ace/mode/css")
                             else
                             (-> editor.session `setMode options.mode))
                           (dispatch_event { command: "editor_change" 
                                             source: options.id
                                             args: [ { `option: "mode" `value: options.mode } ] })
                          (when options.on_mode_set
                             (options.on_mode_set mode_name))))
         `get_mode: (fn ()
                      options.mode)
         `set_theme: (fn (theme_name)
                        (progn
                           (-> editor `setTheme (+ "ace/theme/" theme_name))
                           (set_prop options
                              `theme
                              theme_name)
                           (dispatch_event { command: "editor_change" 
                                             source: options.id
                                             args: [ { `option: "theme" `value: theme_name } ] })
                           (when options.on_theme_set
                              (options.on_theme_set theme_name))))
         
         `display_context_message: display_context_message
         `get_evaluator: (fn ()
                            options.evaluator)
         `resize: (fn ()
                     (perform_resize))
         `bind_key: bind_key
         `key_bindings: (fn ()
                           (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding] editor))
         `save: (function ()
                   (request_save))
         `on_save_complete: (function (event_obj)
                               (save_complete event_obj))
         `increase_font_size: increase_font_size
         `decrease_font_size: decrease_font_size
         `menu_items: (function ()
                         [[(dtext "Increase Font Size") increase_font_size]
                          [(dtext "Decrease Font Size") decrease_font_size]
                          (if (-> editor `getReadOnly)
                              [ (dtext "Allow Editing" ) (fn () (-> intf `set_read_only false)) ]
                              [ (dtext "Set Read-Only Mode") (fn () (-> intf `set_read_only true)) ])
                          [(dtext "Set Edit Mode") 
                           [["Juno" (fn () (-> intf `set_mode "juno"))]
                            ["Javascript" (fn () (-> intf `set_mode "javascript")) ]
                            ["Text" (fn () (-> intf `set_mode "text"))]
                            ["CSS" (fn () (-> intf `set_mode "css"))]
                            ["JSON" (fn () (-> intf `set_mode "json"))]]]
                          [(dtext "Set Editor Theme") (for_each (theme *editor_themes*)
                                  [theme  (fn () (-> intf `set_theme theme))])]])
         `get_active_lisp_operator: (fn ()
                                       (find_active_lisp_operator))
         `set_read_only: (fn (read_only?)
                           (-> editor `setReadOnly read_only?))
         `get_current_pos: (fn ()
                              (current_position))
         `options: options
         `name: options.name 
         `set_name: (fn (new_name)
                      (when (not (blank? new_name))
                         (set_prop options
                            `name
                            (name_control new_name))
                         options.name))
         `toJSON: (function ()
                     `(make_editor ,#(-> editor `getValue) ,#options))
         `initialize: (fn ()
                         (when view.parentElement
                            (console.log "editor: performing initialization")
                            (-> resize_observer `observe view.parentElement)
                            (initialize_editor))) })))

(defun select_evaluator ()
  (let
      ((idx -1)
       (dups (new Set))
       (new_name nil)
       (selected_idx nil)
       (available (reduce (control (flatten (control_tree $root_controls)))
                          (when control.evaluate
                            (if (-> dups `has (or control.name "Untitled"))
                              (progn
                               (= new_name (+ (or control.name "Untitled")
                                             "-" idx))
                               (-> dups `add new_name)
                               [ (inc idx) new_name
                                 control ])
                              (progn
                               (-> dups `add control.name)
                               [ (inc idx) control.name control ])))))
       (selection_box (select { }
                              (map (fn (v)
                                     (option { `value: v.0 } v.1))
                                     (or available [])))))
    (= selected_idx
       (request_user_input (dtext "Select an available evaluator")
                           nil
                           { input: selection_box }))
    (when selected_idx
        (prop (prop available selected_idx) 2))))
  



(defun set_scroll_speed (ctl value)
   (if ctl.editor
      (-> ctl `editor) `setScrollSpeed (Math.min 1 10))
   {
       description: (+ "Sets the scroll speed for the editor by taking a control with an " 
                       "editor and a value between 1 and 10, where 10 will scroll the fastest "
                       "and 1 will be the slowest scroll value.  No return value.")
       usage: ["control:object" "value:number"]
       tags: ["editor" "scroll" "speed"]
   })

(defun compute_name_for_editor (title path_to_value)
   (let
      ((others (get_editors_for_path path_to_value))
       (counter 2))
      ;(log "compute_name_for_editor: # of editors for base title: " title ": " others.length "  path: " path_to_value)
      ;(log "compute_name_for_editor: basename found: " (get_control_by_name title))
      (cond 
         (== others.length 0)
         title
         (not (get_control_by_name title))
         (progn
            ;(log "compute_name_for_editor: returning: " title)
            title)
         else
         (progn
            (while (get_control_by_name (+ title " - " counter ""))
               (inc counter))
            ;(log "compute_name_for_editor: returning: " (+ title " - " counter))
            (+ title " - " counter "")))))

(defun compute_name_for_control (name)
   (if (and (is_string? name)
            (not (blank? name)))
       (let
           ((ctl_exists? (get_control_by_name name))
            (counter 2))
          (cond
             (not ctl_exists?)
             name
             else
             (progn
                (while (get_control_by_name (+ name " - " counter ""))
                   (inc counter))
                (+ name " - " counter "")))))
   {
       `description: (+ "Given a proposed name for a control, if the name isn't " 
                        "used by another control, will return the provided name. "
                        "Otherwise, the function will return a unique non-used "
                        "name by appending a digit, starting with 2 on the control "
                        "name.  The new name will then be returned.")
       `tags: ["control" "name" "ui" "identifier"]
       `usage: ["name:string"]
   })

(defun recalc_names_for_path (path_to_value)
   (let
      ((ctls (get_editors_for_path path_to_value)))
      (for_each (ctl ctls)
         (when ctl.recalculate_name
            (-> ctl `recalculate_name)))))
       
(defun clone_editor_control (editor_control)
   (let
      ((id editor_control.options.id)
       (new_name (if editor_control.basename
                     (-> editor_control `basename)
                     editor_control.options.name)))
      (declare (function buffer_editor)
               (global buffer_editor))
      (when (and editor_control.editor id)
         (alert_on_error "Unable to clone the editor"
                         (buffer_editor new_name 
                                        editor_control.options.namespace 
                                        editor_control.options.path 
                                        (-> editor_control `get_mode)
                                        (+ {} ;; start options 
                                           editor_control.options 
                                           { `id: (gen_id "buffer_editor") 
                                             `clone_with_editor_id: id }))))))

(defun buffer_editor (title namespace path_to_value mode options)
   (aif (and (not options.clone_with_editor_id)
             (get_control_by_name title))
        it
        (let
           ((nseval (if (not (blank? namespace))
                        (-> Environment `get_namespace_handle namespace)
                        Environment))
            (orig_title (clone title))
            (title (compute_name_for_editor orig_title path_to_value))
            (title_span (span { `class: "juno-title" } title))
            (options (or options {}))
            (id (or options.id (generate_id "buffer_editor")))
            (evaluator (cond
                          (and (is_object? options.evaluator)
                               (is_function? options.evaluator.evaluate))
                          options.evaluator.evaluate
                          (is_function? options.evaluator)
                          options.evaluator
                          *system_repl*
                          *system_repl*))
            
            (evaluator_span (span { `class: "juno-evaluator" `title: (dtext "Name of the evaluator assigned to this buffer") } "-"))
            (buffer_commands_button (commands_button id))
            (nav_back_button (button { `title: (dtext "back") } "<"))
            (nav_forward_button (button { `title: (dtext "forward") } ">"))
            (is_dirty? false)
            (col_pos_span (span { `title: "Position (Row Column)" `style: "float: right;margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } "[0 0]"))
            (mode_span (span { `class: "juno-mode" `title: "Current Editing Mode" `style: "float: right; margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } mode))
            (command_bar (or options.command_bar
                             (div { `class: "juno-buffer-bar" }
                                  buffer_commands_button
                                  title_span
                                  (span { `title: "Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } nseval.namespace)
                                  evaluator_span
                                  (if options.read_only
                                     (span { `title: "This buffer doesn't allow editing" `style: "padding-left: 5px; padding-right: 5px;" } (dtext "Locked"))
                                     ())
                                  mode_span
                                  col_pos_span)))
            (init_value (resolve_path path_to_value nseval.global_ctx.scope))
            (current_pos nil)
            (on_save (fn (ctl)
                        (let
                           ((rval nil)
                            (report []))
                           ;; on_save should only send the request to the save handler and wait for a registered event handler response to display results
                           (remove_class "juno-needs-save" title_span)
                           (delete_prop options `create_mode)
                           (= is_dirty? false))))
            
            (on_focus (fn ()
                         (progn
                            (setq *last_focus* edit_control)
                            (add_class "juno-focused" command_bar))))
            (split_editor (fn (dir)
                             (let
                                ((new_editor nil))
                             (cond
                                (== dir "vertical")
                                (progn
                                   (= new_editor (clone_editor_control edit_control))
                                   (alert_on_error "Unable to split"
                                                   (container_view_operation "split_right" edit_control new_editor)))
                                (== dir "horizontal")
                                (progn
                                   (= new_editor (clone_editor_control edit_control))
                                   (alert_on_error "Unable to split"
                                                   (container_view_operation "split_below" edit_control new_editor)))
                                else
                                (alert_box "Invalid Split Request" "Split commands  must be vertical or horizontal")))))
                                   
            (update_position (function ()
                                (when edit_control.editor
                                   (= current_pos (-> edit_control.editor `getCursorPosition))
                                   (set_prop col_pos_span
                                      `innerText
                                      (+ "[" current_pos.row " " current_pos.column "]"))
                                   (set_prop options `cursor_position current_pos)
                                   ;; check for new lisp operator
                                   (-> edit_control `get_active_lisp_operator))))
            (edit_control (make_editor (if (is_string? init_value)
                                           init_value
                                           "")
                                       {
                                         mode: mode
                                         command_bar: command_bar
                                         on_save: on_save
                                         create_mode: options.create_mode ;; this will be removed by the editor on first save but signals that it shouldn't try to open the file if not found.
                                         filename: options.filename
                                         path: path_to_value
                                         path_namespace: namespace
                                         id: id
                                         theme: options.theme
                                         clone_with_editor_id: options.clone_with_editor_id
                                         read_only: options.read_only
                                         font_size: options.font_size
                                         on_click: (function ()
                                                      (update_position))
                                         on_theme_set: (function (val)
                                                          (set_prop options
                                                             `theme
                                                             val))
                                         on_mode_set: (function (val)
                                                         (progn
                                                            (= mode val)
                                                            (set_prop mode_span `innerText val)))
                                         on_change: (function (editor val)
                                                       (progn
                                                          (when (not is_dirty?)
                                                             (= is_dirty? true)
                                                             (add_class "juno-needs-save" title_span))
                                                          
                                                          (when options.on_change
                                                             (-> options.on_change editor val))))
                                         evaluator: evaluator
                                         }))
            (menu_items (fn ()
                           (conj
                              [(when path_to_value
                                  [(+ (dtext "Save to") " " (last path_to_value))
                                   (fn (e) (-> edit_control `save))])
                               [(dtext "Select Evaluator")
                                select_my_evaluator]
                               [(dtext "Split Vertically") 
                                (fn (e)
                                   (split_editor `vertical)) ]
                               [(dtext "Split Horizontally")
                                (fn (e)
                                   (split_editor `horizontal))]]
                              (-> edit_control `sub_menu_items))))
            (set_evaluator_control (fn (control)
                                      (if control.evaluate
                                         (progn
                                            (-> edit_control `set_evaluator control.evaluate)
                                            (set_prop options
                                               `evaluator_id
                                               control.options.id)
                                            (if control.name
                                               (set_prop evaluator_span
                                                  `innerText
                                                  (+ "â­¢ " control.name)))))))
            (select_my_evaluator (fn ()
                                    (aif (select_evaluator)
                                         (progn
                                            (set_evaluator_control it)
                                            (notify (+ (dtext "Evaluator set to ") it.name)))))))
           
   
           (attach_event_listener edit_control.view
              `keyup
              (function (e)
                 (update_position)))
           
           (set_prop options
              `id
              id)
           
        
           (set_prop edit_control
              `sub_initializer
              edit_control.initialize
              `sub_menu_items
              edit_control.menu_items
              `sub_destroy
              edit_control.destroy)
           
           (set_prop options
              `name
              title
              `namespace
              namespace
              `path
              edit_control.options.path)
           
           (set_prop edit_control
              `set_evaluator_control  set_evaluator_control
              `on_focus on_focus
              `on_destroy (fn ()
                             (cond
                                (not is_dirty?)
                                true
                                is_dirty?
                                (request_user_input title 
                                                    "text"
                                                    { input: (div { value: "remove" } (dtext "The contents of this editor haven't been stored. Really remove?")) })))
              `recalculate_name (fn ()
                                    (unless (== orig_title title)
                                       (progn
                                          (defvar new_name (compute_name_for_editor orig_title path_to_value))
                                          (set_prop title_span
                                             `innerText
                                             new_name)
                                          (set_prop options
                                             `name
                                             new_name)
                                          (= title new_name)
                                          (set_prop edit_control
                                             `name
                                             new_name))))
              `destroy (fn ()
                          (progn
                             (-> edit_control `sub_destroy)
                             (recalc_names_for_path path_to_value)
                             (set_focus_to (default_focus))))
              `needs_save? (function ()
                              is_dirty?)
              `split_vertical (fn ()
                                 (split_editor `vertical))
              `split_horizontal (fn ()
                                   (split_editor `horizontal))
              `options options
              `name title
              `basename (fn ()
                           orig_title)
              `menu_items menu_items
              `type `buffer_editor
              `initialize (fn ()
                             (when edit_control.view.parentElement
                                (-> edit_control `sub_initializer)
                                (when options.clone_with_editor_id
                                   (if (get_control_by_id options.clone_with_editor_id)
                                       (progn
                                          (= is_dirty? (-> (get_control_by_id options.clone_with_editor_id) `needs_save?))
                                          (when is_dirty?
                                             (add_class "juno-needs-save" title_span)))))
                                (console.log "buffer_editor: sub initialized: setting evaluator if I have it: " options)
                                (cond
                                   options.evaluator_id
                                   (set_evaluator_control (get_control_by_id options.evaluator_id))
                                   *system_repl*
                                   (set_evaluator_control *system_repl*))
                                (sleep 0.01)
                                (-> (prop edit_control `editor) `focus)))
                                
              
              
              `toJSON (function ()
                         `(buffer_editor ,#title ,#namespace ,#path_to_value ,#mode ,#options)))
           edit_control)))



(defun log_view (options)
  (let
      ((output_container (div { `class: "juno-log-output"  } ))       
       (options (or options { `display_options: { include_prototypes: false }}))
       (title_span (span { `class: "juno-title" } (if options.title options.title "Unnamed")))
       (control_status (div {  `class: "juno-buffer-bar" }
                            (cond (is_array? options.additional_elements)
                                  options.additional_elements
                                  options.title
                                  title_span
                                  else
                                  [])))
       (name (or options.name (name_control "log_view")))
       (resize_observer nil)
       (parent_view nil)
       (set_show_prototypes (fn (state)
                                  (progn                                                                      
                                   (set_prop options.display_options
                                             `include_prototypes
                                             state)
                                   (log_message "show prototypes: " options.display_options.include_prototypes))))
                                   
       (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
       (id (or options.id (generate_id "log_view")))
       (view (div { `tabindex: 0 `control_id: id `style: "overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                  control_status
                  output_container))
       (initialized false)
       (initialize (fn ()
                     (when (and view.parentElement
                                (not initialized))
                       (= initialized true)
                       (= parent_view view.parentElement)                                   
                       (= resize_observer (new ResizeObserver perform_resize))
                       (-> resize_observer `observe view.parentElement))))
                       
       (perform_resize (fn ()
                         (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 5))
                                (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                             
                             (set_style [[ "width" (+ "" new_width "px") ]
                                         [ "height" (+ "" new_height "px") ]]
                                        view))))
       (add_result (fn (result command_text error_state)
                     (progn
                      (console.log "log_view: <- " result) 
                      (when (not (eq nil command_text))
                        (-> output_container
                            `append
                            (if (> command_text.length 100)
                              (details {  class: "juno-result" }
                                       (summary { `tabindex: 0 `class: "juno-code-value" } (+ (-> command_text `substr 0 100) "..."))
                                       (pre { `tabindex: 0 `class: "juno-code-value" }
                                             command_text))
                              (div {  class: "juno-result" }
                                   (code { `tabindex: 0 `class: "juno-code-value" }
                                             command_text)))))
                      (-> output_container
                          `append
                          (div { `class: "juno-log-message"
                                `style: (+ " margin-top: 0px; width: calc(100% - 10px); display: inline-block; font-family: var(--main-mono-space); "
                                            (if (eq nil command_text)
                                              "border-top: 1px solid #00000008; padding: 5px;"
                                              "border-left: 3px solid #0167835e; padding: 10px; margin-bottom: 5px; border-bottom: 1px solid transparent;")) } 
                               (value_to_dom result options.display_options)))
                      (when (> output_container.children.length (or options.max_log_lines
                                                                    *env_config*.application.max_log_lines
                                                                    10))
                        (-> (first output_container.children)
                            `remove))                      
                      (set_prop output_container
                                `scrollTop
                                1000000)
                      (set_prop view
                                `scrollTop
                                0)
                      result)))
       (set_max_log_lines (fn (val)
                            (when (is_number? val)
                              (set_prop options
                                        `max_log_lines
                                        val)
                              (while (> output_container.children.length options.max_log_lines)
                                (-> (first output_container.children)
                                    `remove))
                              true)))
                              
       (menu_items (fn ()
                     [[(dtext "Clear Log")
                       (function ()
                                 (-> output_container `replaceChildren))]
                      [(dtext "Set Max Log Lines")
                       (fn ()
                         (aif (request_user_input (+ (dtext "Enter the number of log lines to keep") ":") `number { `default_value: (or options.max_log_lines
                                                                                                                                        *env_config*.application.max_log_lines) })
                              (set_max_log_lines it)))]
                      [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                       (function ()
                                 (set_show_prototypes (not options.display_options.include_prototypes)))]]))
                      
       (on_focus (fn ()
                   (progn                   
                    (add_class "juno-focused" control_status)))) ;; we know that is the command bar
       (log_message (fn (`& args)
                      (progn
                       (add_result (div { `tabindex: 0 `style: "display: flex; justify-content: flex-start; align-items: flex-start; " }
                                        (div { `timestamp: (time_in_millis) `style: "padding-right: 10px; min-width: 150px; display: inline-block; " } (formatted_date (new Date)))
                                        (div { `style: "display: flex; justify-content: flex-start; align-items: flex-start; " }
                                             (for_each (v args)
                                                       (cond
                                                         (is_string? v)
                                                         (div { `tabindex: 0 `class: "juno-value juno-type-string" `style: "display: inline-block; padding-left: 10px" } v)
                                                         (is_number? v)
                                                         (div { `tabindex: 0 `class: "juno-value juno-type-number" `style: "display: inline-block; padding-left: 10px" } v)
                                                         (or (== v true) (== v false))
                                                         (div { `tabindex: 0 `class: "juno-value juno-type-boolean" `style: "display: inline-block; padding-left: 10px" } v)
                                                         else
                                                         (div { `tabindex: 0 `class: "juno-value" `style: "display: inline-block; padding-left: 10px" } (value_to_dom v))))))
                                   nil nil)
                       nil)))
                        
       (interf {}))
    (set_prop options
              `id
              id
              `name
              name)

    (set_prop interf
              `view view
              `name name
              `append add_result
              `log_message log_message
              `menu_items menu_items
              `control_bar control_status
              `output_container output_container
              `initialize initialize
              `resize perform_resize
              `type `log_view              
              `clear (fn ()
                       (-> output_container `replaceChildren))
              `options options
              `toJSON (function ()
                                `(log_view ,#options)))
    interf))

;(new_juno_repl { `remote_repl: "ws://localhost:56432/connect_repl" })
(defun visual_repl (options)
  (let
      ((options (or options {}))
       (name options.name)       
       (resize_observer nil)
       (id (or options.id (generate_id "repl")))
       (namespace_span  (span { `title: "REPL Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } (current_namespace)))
       (location_span (span { `title: "Location" `style: "float: right; display:inline-block; padding-left: 10px; padding-right: 10px;" } 
                          (if options.remote_repl
                                   "Connecting"
                                   "Browser")))
       (control_button (commands_button id));  { `title: "REPL Commands" } "â‹¯"))
       (title_span (span { `class: "juno-title" } (if options.name options.name "Unnamed")))
       (show_prototype_details_button (button { `title: (dtext "Show Object Prototype Detail") } "P"))
       (path_span (span { `tabindex: 0 `title: (dtext "Click to copy focused path")  `class: "juno-path" } ""))
       (current_env Environment)
       (error_state nil)
       (remote_command_timeout 120000) ;; 2 minute default
       (initialized false)       
       (intf nil)       
       (toggle_prototype_detail (function ()
                                          (progn                                           
                                           (set_prop options.display_options
                                                     `include_prototypes
                                                     (not options.display_options.include_prototypes))
                                           (set_prop output_control.options.display_options                                                     
                                                     `include_prototypes options.display_options.include_prototypes)
                                           (if options.display_options.include_prototypes
                                             (add_class "juno-button-on" show_prototype_details_button)
                                             (remove_class "juno-button-on" show_prototype_details_button)))))
       (output_control (log_view { `display_options: (or options.display_options {} )
                                   `additional_elements: [ control_button title_span show_prototype_details_button namespace_span  path_span location_span] `id: id }))
       (history (if (is_array? options.history)
                  options.history
                  []))
       (clog (fn (`& args)
               (progn
                  (apply console.log args)
                  (-> intf `log (apply div { `style: "display: flex;" }
                                       (for_each (val args)
                                          (div { `style: "padding-right: 10px" } (value_to_dom val)))))
                  nil)))
       (push_history (fn (lisp_text)
                       (progn
                        (push history
                                lisp_text)
                        (= history_idx history.length)
                        (when (> history.length (or options.max_history_size
                                                    50))
                          (take history)))))
       (history_idx 0) 
       (history_prior_entry (fn ()
                              (when (> history.length 0)
                                 (dec history_idx)
                                 (when (or (< history_idx 0)
                                           (>= history_idx history.length))
                                    (= history_idx history.length))
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (-> input_container `set (prop history history_idx)))
                               )))
       (history_next_entry (fn ()
                              (when (> history.length 0)
                                 (inc history_idx)
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (progn
                                        (if (>= history_idx history.length)
                                            (= history_idx 0))
                                        (-> input_container `set (prop history history_idx)))))))
       (clear_output (fn ()
                       (-> output_control `clear)))
       (clear_history (fn ()
                        (progn
                         (= history [])
                         (= history_idx 0))))
       
       (repl_key_bindings (function ()
                                    (map (function (kb)
                                             (destructuring_bind (command_name bindings)
                                                 kb                                                                                                                  
                                                 { name: command_name
                                                   mac: (prop bindings `mac)
                                                   win: (prop bindings `win)
                                                  exec: (function (editor)
                                                                  (-> intf command_name editor)) }))                                                                                                                                                                  
                                         (or (pairs *key_bindings*.repl) []))))
       (repl_ws nil)
       (request_id 0)
       (requests {})
       (open_remote_evaluator (fn ()
                                 (if options.remote_repl
                                    (progn
                                       (= repl_ws
                                          (http/create_websocket options.remote_repl
                                                            {
                                                              `on_message: (fn (event)
                                                                             (try
                                                                                (let
                                                                                   ((data nil)
                                                                                    (pdata nil)
                                                                                    (resolver nil))
                                                                                   
                                                                                   (try 
                                                                                      (= data (JSON.parse event.data))
                                                                                      (catch Error (e)
                                                                                         (progn
                                                                                            (clog "Unable to parse json data: " e.message)
                                                                                            (= data event.data))))
                                                                                   ;(clog "<-" event.data)
                                                                                   (cond
                                                                                      (and (is_object? data)
                                                                                           data.req_id)
                                                                                      (progn
                                                                                         (if (prop requests data.req_id)
                                                                                             (progn
                                                                                                (= pdata (prop requests data.req_id))
                                                                                                (remove_prop requests data.req_id)
                                                                                                (clearTimeout (third pdata)) ;; remove the timeout
                                                                                                (if (== data.rval "OK")
                                                                                                    (progn
                                                                                                       (= resolver (first pdata))
                                                                                                       (resolver data nil))
                                                                                                    (progn
                                                                                                       (= resolver (first pdata)) ;; we will resolve the promise and handle the error in our remote eval result function.
                                                                                                       (resolver data true))))
                                                                                             (progn
                                                                                                ;; received a request but it is not tied to a request we made, could be a log message
                                                                                                (if (== data.rval "OK")
                                                                                                    (clog data.result)
                                                                                                    (clog data.message)))))
                                                                                      (and (is_object? data)
                                                                                           data.result)
                                                                                      (clog "[message]:" data.result)
                                                                                      else
                                                                                      (clog data)))
                                                                                (catch Error (e)
                                                                                   (clog "Unable to process received message: " e.message))))
                                                              `on_open: (fn (event)
                                                                           (progn
                                                                              (clog (+ "Connected to Remote REPL: " options.remote_repl))
                                                                              (try 
                                                                                 (set_prop location_span
                                                                                    `innerText (prop (send_wait "(hostname)") `result))
                                                                                 (catch Error (e)
                                                                                    (clog "Unable to determine remote hostname: " e)))))
                                                              `on_close: (fn (event)
                                                                            (clog "Interface is now closed"))
                                                              `on_error: (fn (event)
                                                                            (clog "Error on WS:" event))
                                                            }))
                                       (defglobal *repl_ws* repl_ws)
                                       ))))
       (send_wait (fn (lisp_text)
                     (let
                        ((rval nil))
                        (assert (and (instanceof repl_ws WebSocket)
                                     (== repl_ws.readyState repl_ws.OPEN))
                                "Websocket is not open")
                       (try
                          (= rval (new Promise 
                                       (fn (resolve reject)
                                          (let
                                             ((my_request_id (inc request_id))
                                              (timer nil))
                                             (= timer (setTimeout (fn ()
                                                                     (progn
                                                                        (clog "timeout occurred")
                                                                        (reject { `rval: "FAIL" `message: (+ "Timeout on request id: " my_request_id) })))
                                                                  remote_command_timeout))
                                             ;; set the request id in request object, and then wait to resolve the promise until results are returned, or a timeout occurs
                                             (set_prop requests
                                                my_request_id
                                                (list resolve reject timer))
                                             (try 
                                                (http/send_to_ws repl_ws
                                                                 { `command: "eval"
                                                                   `req_id: request_id
                                                                   `args: [ lisp_text ] })
                                                (catch Error (e)
                                                   (clog "ERROR on send_to_ws: " e)))
                                             true))))
                             (catch Error (e)
                                (log (+ "Error on send_wait: " e))))
                       rval)))
                                                
       (process_remote_eval_result (fn (result)
                                      (if (is_object? result)
                                          (try
                                             (let
                                                ((is_system_error? (== "FAIL" result.rval))
                                                 (is_compiler_error? (and (resolve_path [ `result 0 `error ] result)
                                                                          (resolve_path [ `result 0 `message ] result))))
                                                (cond
                                                   is_system_error?
                                                   (progn
                                                      (div { `style: "border-left: 5px solid red; padding: 5px;" } 
                                                           (+ result.result_type ": " result.message)
                                                           (value_to_dom result)))
                                                   is_compiler_error?
                                                   (progn
                                                      (notify (+ "Error: " is_compiler_error?))
                                                      (div { `style: "border-left: 5px solid red; padding: 5px;" }
                                                           (if (== (length result.result) 1)
                                                               (value_to_dom result.result.0)
                                                               (value_to_dom result.result))))
                                                   
                                                   (ends_with? "unction" result.result_type)
                                                   (remote_function_to_dom result.result)
                                                   result.needs_eval
                                                   (eval_struct (JSON.parse result.result))
                                                   else
                                                   result.result))
                                             (catch Error (e)
                                                (list e.message result)))
                                          result)))
       
       
                                            
                                            
       (evaluator (fn (lisp_text no_eval no_clear no_log)
                    (let
                        ((result nil))
                      (setq error_state nil)
                      (if options.remote_repl
                         (progn
                            (try
                               (progn
                                  (= result (send_wait lisp_text)))
                               (catch Error (e)
                                  (do
                                     (= error_state true)
                                     (when e.message
                                        (notify (+ "Error: " e.message))))))
                            (console.log "remote: <-" result)
                            (when (is_object? result)
                               (set_prop namespace_span
                                  `innerText
                                  (or result.namespace "Unknown!")))
                            (unless no_log
                               (-> output_control `append (process_remote_eval_result result) lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set "")))
                            
                         (progn
                            (setq current_env (-> Environment `get_namespace_handle (current_namespace)))
                            (try
                               (= result (if no_eval
                                             lisp_text
                                             (-> current_env `evaluate lisp_text {} { `throw_on_error: true })))
                               (catch Error (ex)
                                  (do
                                     (= error_state true)
                                     (notify (+ "Error: " ex.message))
                                     (= result ex))))
                            (console.log "<-" result)
                            (set_prop namespace_span
                               `innerText
                               (current_namespace))
                            (unless no_log
                               (-> output_control `append result lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set ""))))
                      result)))
                             
       (input_container (make_editor 
                                   ""                                  
                                  {
                                   mode: "juno"                                                                                                                             
                                   on_change: (function (editor val)
                                                        (progn
                                                         true))
                                   theme: options.theme
                                   id: id
                                   clone_with_editor_id: options.clone_with_editor_id
                                   repl_mode: true
                                   on_new_lisp_operator: (function (val)
                                                            (progn      
                                                               true
                                                               ;(dispatch_event { `command: "display_usage" source: id `args: [val] })
                                                               ))
                                   evaluator: (fn (lisp_text no_eval no_clear)
                                                (progn
                                                 (push_history lisp_text)
                                                 (evaluator lisp_text no_eval no_clear)))
                                   commands: (repl_key_bindings)
                                   on_initialized: (fn (control)
                                                       (when initialized
                                                          (try
                                                             (-> control.editor `focus)
                                                             (catch Error (e)
                                                                (log "error on focus: " e.message)))))
                                                       }))

       (sview (split_view_horizontal
                                 output_control
                                 input_container
                                 { `ratio: (or options.ratio 0.7) `id: id } ))  ;; 80/20 top-bottom
       
       (view sview.view)
       (non_whitespace_regex (new RegExp "\\\\s"))
       (on_focus (fn ()
                   (progn
                    ;(-> input_container.editor `focus) ;; bring focus to the repl
                    (add_class "juno-focused" output_control.control_bar )
                    (set_prop intf
                       `editor
                       (resolve_path [ `editor_container `editor ] intf))
                    )))
       (on_blur (fn ()
                  (progn
                   true)))
       (destroy (fn ()
                  (if options.locked
                     (throw EvalError (+ "" options.name " is marked as locked and cannot be destroyed"))
                     (progn
                        (if options.remote_repl
                            (try
                               (progn
                                  (log "remote_repl state: " repl_ws.readyState)
                                  (when (== repl_ws.readyState repl_ws.OPEN)
                                     (log "remote_repl: closing open connection on destroy. ")
                                     (-> repl_ws `close))
                                  (log "remote_repl state: clean up complete."))
                               (catch Error (e)
                                  (log "remote_repl: couldn't close the socket: " e.message))))
                           
                        (-> input_container `destroy)))))
       (menu_items (fn ()
                     [[(dtext "Clear Output Log")
                       (function ()
                                 (clear_output))]
                      [(dtext "Clear REPL History")
                       (function ()
                                 (clear_history))]
                      [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                       (function ()
                                 (toggle_prototype_detail))]
                      [(dtext "Set Editor Theme") (for_each (theme *editor_themes*)
                                                            [theme  (fn ()
                                                                      (progn
                                                                       (set_prop options `theme theme)
                                                                       (-> input_container `set_theme theme)))])]]))
       (initialize (fn ()
                     (progn
                      (if initialized
                        false
                        (progn
                         (= initialized true)
                         (console.log "repl initializing")
                         (when (eq nil options.display_options)
                           (set_prop options
                                     `display_options
                                     { `include_prototypes: false }))                           
                         (if options.display_options.include_prototypes
                           (add_class "juno-button-on" show_prototype_details_button))
                         (try
                            (if options.remote_repl
                               (progn
                                  (clog  (html/div { `style: "display: flex padding: 5px" }                
                                                                       (html/span { `style: "font-weight: bold; display: inline-block;" } "connecting to: ")
                                                                       (html/span { `style: "display: inline-block; margin-left: 10px;" }
                                                                                  options.remote_repl )))
                                  
                                  (open_remote_evaluator)))
                            (catch Error (e)
                               (clog "Cannot open remote REPL: " e.message)))
                         (unless options.remote_repl
                            (-> output_control `append (html/div { `style: "display: flex padding: 5px" }
                                                                 (html/span { `style: "font-weight: bold; display: inline-block;" } "Juno REPL")
                                                                 (html/span { `style: "display: inline-block; margin-left: 10px;" }
                                                                            "Version: " Environment.build_version   ))))
                         ;; become the system_repl if none is yet defined
                         (if (eq nil *system_repl*)
                             (progn
                                (= *system_repl* intf)
                                (set_prop options
                                   `locked true)
                                (setTimeout (fn ()
                                               (progn
                                                  (-> input_container `display_context_message (+ "*system_repl* / REPL Mode: Press Shift-Enter to evaluate editor contents"))))
                                            250))
                             (setTimeout (fn ()
                                            (-> input_container `display_context_message "REPL Mode: Press Shift-Enter to evaluate editor contents")
                                            250)))
                         
                         true))))))

       (attach_event_listener output_control.output_container
                           `focusin
                           (function (e)
                             (progn
                              (handle_event e)
                              (console.log "output-control: focus: " (-> e.srcElement `getAttribute "lpath") e.srcElement)
                              (aif (-> e.srcElement `getAttribute "lpath")
                                   (progn
                                    (set_prop path_span
                                             `innerText
                                             (+ "[ " (join " "
                                                           (for_each (v (split_by "~" it))
                                                                     (cond (> (length (scan_str non_whitespace_regex v)) 0)
                                                                           (+ "\"" v "\"")
                                                                           (isNaN (new Number v))
                                                                           (+ "`" v)
                                                                           else
                                                                           v)))
                                                           " ]"))
                                    (console.log "setting path span:: " it))
                                   (progn
                                    (console.log "clearing path span")
                                    (set_prop path_span
                                             `innerText
                                             ""))))))
     
    (attach_event_listener show_prototype_details_button
                           `click
                           (fn (e)
                             (progn
                              (handle_event e)
                              (toggle_prototype_detail))))
    
    (attach_event_listener path_span
                           `click
                           (fn (e)
                             (progn
                              (copy_text_to_clipboard path_span.innerText)
                              (notify (+ (dtext "Copied") " " path_span.innerText)))))

    ;; by changing the split_view type value, we prevent this control from being split or
    ;; controls being swapped
    
    (set_prop sview
              `type
              "REPL_split")
    
    (set_prop options
              `id
              id)
                   
    (= intf {
             `view: view
             `options: options
             `name: name             
             `editor_container: input_container             
             `editor: nil ;; will be filled in on initialization 
             `history_next_entry: history_next_entry
             `history_prior_entry: history_prior_entry
             `command_history: (function ()
                                        history)
             `clear_history: (function ()
                                       (clear_history))
             `clear_output: clear_output             
             `initialize: initialize
             `destroy: destroy
             `type: "visual_repl"
             `resize: (fn ()
                       (-> sview `resize))
             `menu_items: menu_items                           
             `on_focus: on_focus
             `on_blur: on_blur           
             `set_theme: (fn (theme_name)
                           (when (contains? theme_name *editor_themes*)
                             (set_prop options `theme theme_name)
                             (-> input_container `set_theme theme_name)))
             `toJSON: (function ()
                                (progn
                                 (set_prop options
                                           `history
                                           [(quote quotel) history])
                                `(visual_repl ,#(or options { `ratio: sview.options.ratio } ))))
             `controls: (fn () [ input_container output_control])
             
             `output_container: output_control.view
             `log: (fn (val)
                     (-> output_control `log_message val))
             `evaluate: (fn (lisp_text no_eval no_clear no_log)
                          (evaluator lisp_text no_eval no_clear no_log))
             })
    intf))



;; singleton - if it already exists, just return the control
;; otherwise make it 
(defun control_holding_tank (initial_controls options)
  (aif (get_control_by_name "Holding Tank")
       it
       (let
           ((my_controls (if (and initial_controls
                                  (is_array? initial_controls))
                           (to_object
                            (reduce (control initial_controls)
                                    (when control.options.id 
                                      [control.options.id control])))
                           {}))                                                    
            (options (or options {}))
            (intf {})
            (name (or options.name
                      "Holding Tank"))
            (initialized false)
            (id (or options.id (generate_id "holding_tank")))
            (title_span (span { `class: "juno-title" } (dtext "Holding Tank")))
            (buffer_commands_button (commands_button id))
            (control_status (div {  `class: "juno-buffer-bar" }
                                 buffer_commands_button
                                 (cond (is_array? options.additional_elements)
                                       options.additional_elements
                                       else
                                       title_span
                                       )))
            (perform_resize (fn ()
                              (when view.parentElement
                                (when (not initialized)
                                  (initialize))
                                (render_view))))
            
            (resize_observer nil)
            (add_control (fn (control)
                             (when (not (== control intf))
                                 (assert (and control.type control.options.id) "Invalid control provided")
                                 (set_prop my_controls
                                    control.options.id
                                    control) 
                                 ;(log "control_holding_tank: " control.options.name  "can_hide?" (and control.can_hide? (-> control `can_hide?)))
                                 (if (and (not (resolve_path [ `options `locked ] control))
                                          (or (== control.type "empty_control")  ;; don't store the empty controls since they are placeholders
                                              control.options.temporary          ;; or if the control is marked temporary
                                              (and control.can_hide?       ;; does the control want to be hidden?
                                                 (not (-> control `can_hide?)))))
                                     (progn
                                        (when *app_menu_control*
                                           (-> *app_menu_control* `remove_menu control.options.name))
                                        (remove_control control.options.id)
                                        (if control.destroy
                                           (-> control `destroy))
                                        (when (== *last_focus* control)
                                           (== *last_focus* nil))
                                        (default_focus)))
                                 (render_view)
                                 control)
                             ))
            (remove_control (fn (id)
                              (if (is_object? id)
                                (aif (prop my_controls id.options.id)
                                     (progn
                                      (remove_prop my_controls id.options.id)
                                      (render_view)))
                                (aif (prop my_controls id)
                                     (progn
                                      (remove_prop my_controls id)
                                      (render_view))
                                     (notify "The requested control wasn't found")))))
            
            (render_view (fn ()
                           (-> control_view
                               `replaceChildren
                               (table { `style: "width: 100%" }
                                (thead
                                 (th "Name") (th "Type") (th "Actions"))
                                (tbody
                                 (for_each (control (values my_controls))
                                           (tr
                                            (td control.name)
                                            (td control.type)
                                            (td { `for_control_id: control.options.id }
                                                (button (dtext "View"))                                               
                                                (button { `style: "float: right" } (dtext "Close Control"))))))))))
            (handle_button_event (fn (elem)
                                   (aif (and elem.parentElement
                                            (-> elem.parentElement `getAttribute "for_control_id"))
                                        (progn
                                         (console.log "holding_tank: button_event: " elem.innerText elem)
                                         (cond
                                           (== elem.innerText (dtext "View"))
                                           (swap_control intf (get_control_by_id it))
                                           (== elem.innerText (dtext "Close Control"))
                                           (container_view_operation "destroy" (get_control_by_id it)))))))
                                   
            (initialize (fn ()
                          (when (and view.parentElement
                                     (not initialized))
                            (= initialized true)
                            (-> resize_observer `observe view.parentElement)
                            (console.log "holding_tank: in initialization: " options view.parentElement)
                            (if options.in_tree                                
                              (progn
                               (console.log "holding_tank: in tree and setting view up to block..and calling render")
                               (set_style [["display" "block"]] view)
                               (render_view))
                              (-> (get_by_id "body")
                                  `append view)))))
                        
            (on_focus (fn ()
                        (progn
                         (add_class "juno-focused" control_status ))))
            (control_view (div { `style: "overflow: scroll; margin: 0px; padding: 0px; height: 100%; width: 100%;" }))
            (show (fn ()
                      (let
                          ((root_control (if *last_focus*
                                             (top_frame *last_focus*)
                                             (prop $root_controls 1)))
                           (current_parent (if view.parentElement
                                               (control_position (control_for_dom_element view))
                                               { `child: intf `parent: nil `child_position: 0 }))
                           (target_control (if root_control.controls
                                             (first (-> root_control `controls)))))
                        (console.log "holding_tank: show: " root_control "current_parent: " current_parent "target_control: " target_control)
                        (console.log "holding_tank: do I have a parent_element: " (parents_for_control intf))
                          (cond 
                            (eq current_parent.parent nil)
                            (progn
                             (set_prop options
                                       `in_tree
                                       true)
                             (set_style [["display" "block"]] view)
                             (container_view_operation "split_right" target_control intf { `ratio: 0.8 }))
                            current_parent.parent
                            (progn
                             (set_style [["display" "block"]] view)
                             (set_prop options
                                       `in_tree
                                       true)
                             (set_focus_to intf))))))
            (hide (fn ()
                    (progn
                     (console.log "holding_tank: hide: " view.parentElement)
                     (if view.parentElement
                       (container_view_operation "hide" intf)
                       (remove_prop options
                                    `in_tree)
                       (set_style [["display" "none"]] view)
                        (-> (get_by_id "body")
                            `append view)))))
                             
                          
            (view (div { `tabindex: 0 `control_id: id `style: "display: none; overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                       control_status
                       control_view)))

         (attach_event_listener view
                                `click
                                (fn (e)
                                  (when (== e.srcElement.tagName "BUTTON")
                                    (handle_button_event e.srcElement))))
         (set_prop options
                   `id id
                   `name name)
         (= resize_observer (new ResizeObserver perform_resize))        
         
         (= intf
            {
              `view: view
              `type: "holding_tank"
              `id: id
              `name: options.name 
              `initialize: initialize
              `on_focus: on_focus
              `controls: (fn ()
                           (values my_controls))
              `add_control: add_control
              `has_control?: (fn (thing) (if (is_string? thing)
                                           (prop my_controls thing)
                                           (prop my_controls thing.options.id)))
              `remove_control: remove_control
              `name: options.name
              `hide: hide
              `show: show
             
              `resize: perform_resize
              `options: options
              `toJSON: (function ()
                                 `(control_holding_tank ,#(values my_controls)  ,#options ))
              })
          intf))
  {
    `usage: ["initial_controls:array" "options:object"]
    `description: (+ "The control holding tank is a is a singleton control that 'holds' any "
                     "control (except itself) that is currently not displayed.  Once instantiated "
                     "any new instantiations of the control holding tank will return the "
                     "previously instantiated control for the namespace.  All arguments will be " 
                     "ignored after the initial instantiation call as the global instance will be "
                     "returned. Controls are added to the holding tank by the container_view_operation "
                     "function which manages the view state.  The holding tank can be checked for a "
                     "control being held by it by calling the has_control? function. ")
    `tags: ["ui" "controls" "hidden" "container" "holding"]
    })

(defun empty_selection_control (options)
   (let
      ((existing_control (last (holding_tank_controls))))
      (if existing_control
         existing_control
     (let
        ((options (or options {
                               `name: "Empty Selection" 
                               }))
         (id (or options.id (generate_id "empty")))
         (title_span (span { `class: "juno-title" } (if options.title options.title "Select Control")))
         (buffer_commands_button (commands_button id))
         (control_status (div {  `class: "juno-buffer-bar" }
                              buffer_commands_button
                              (cond (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span
                                  )))
         (resize_observer nil)         
         (initialized false)
         (parent_view nil)
         (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
         (perform_resize (fn ()
                           (when view.parentElement
                             (check_observer)
                           (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                             
                             (set_style [[ "width" (+ "" new_width "px") ]
                                         [ "height" (+ "" new_height "px") ]]
                                        view)))))
         (initialize (fn ()
                       (when (and view.parentElement
                                  (not initialized))
                         (= initialized true)
                         (= parent_view view.parentElement)
                         (-> resize_observer `observe view.parentElement))))
         (on_focus (fn ()
                   (progn
                     ;; bring focus to the repl
                    (add_class "juno-focused" control_status ))))
         (control_view (div { `class: "juno-empty-content" } ""))
         (view (div { `tabindex: 0 `control_id: id `style: "overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                  control_status
                  control_view)))
                             
        (set_prop options
                  `id
                  id)
        (= resize_observer (new ResizeObserver perform_resize))
        
        
       {
           `view: view
           `type: "empty_control"
           `id: id
           `initialize: initialize
           `on_focus: on_focus
           `name: options.name
           `resize: perform_resize
           `options: options
           `toJSON: (function ()
                      `[empty_selection_control ,#options ])
        }))))

(defun find_common_prefix (candidates match_to)
   (let
      ((result [])
       (subset nil)
       (match_to match_to))
      (cond
         (== (length candidates) 0)
         ""
         (== (length candidates) 1)
         (first candidates)
         
         (not (blank? match_to))
         (progn
            (while (progn
                      (= subset (reduce (c candidates)
                                   (when (starts_with? match_to c)
                                      c)))
                      (and (< subset.length 2)
                           (> match_to.length 0)))
               (= match_to (chop match_to)))
            
            (find_common_prefix subset))
         else
         (progn
            (= candidates (sort candidates))  ;; make sure the candidates are sorted
            (for_each (idx (range (length candidates.0)))
               (if (== (prop (first candidates) idx)
                       (prop (last candidates) idx))
                   (push result (prop (first candidates) idx))
                   (break)))           
            (join "" result)))))

(defun place_caret_at_end (el)
   (progn
      (javascript |
                  el.focus();
                  if (typeof window.getSelection != "undefined"
                             && typeof document.createRange != "undefined") {
                     var range = document.createRange();
                     range.selectNodeContents(el);
                     range.collapse(false);
                     var sel = window.getSelection();
                     sel.removeAllRanges();
                     sel.addRange(range);
                     }
                  | )
      true))

(defun next_hidden_control (backward?)
   (let
      ((candidates (holding_tank_controls))
       (cmd (if backward? 
                first
                last))
       (new_ctl nil))
   (if (> candidates.length 0)
      (progn 
         (= new_ctl (cmd candidates))
         (swap_control *last_focus* new_ctl)
         ;; control will get the on_focus event, but we want to default
         ;; focus into the editor for this operation
         (when new_ctl.editor
            (focus_to new_ctl.editor)))
      (notify (dtext "No controls are in the holding tank."))))
   {
     `usage: ["backward?:boolean"]
     `description: (+ "If backward? is false (default) swap the current control " 
                      "with the last control in the holding tank. Otherwise "
                      "swap with the first control in the holding tank. "
                      "If there are no controls, notifies the user that there are "
                      "no other non-displayed controls to swap to.")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     })

(defun next_displayed_control (backward?)
      (let
      ((next_index nil)
       (displayed_root_control (reduce (ctl (uniq (flatten (control_tree $root_controls))))
                                  (if (and (not (-> (control_holding_tank) `has_control? ctl))
                                           (== ctl.type "control_container"))
                                      ctl)))
       (candidates (reduce (ctl (current_controls true displayed_root_control))
                      (unless (or (-> (control_holding_tank) `has_control? ctl)  ;; we only want controls that are able to take a direct focus
                                  (== ctl.type "control_container")
                                  (== ctl.type "split_view_vertical")
                                  (== ctl.type "split_view_horizontal"))
                         ctl)))
       (dir (if backward? 
                -2
                1))
       (new_ctl nil))
   (if (> candidates.length 0)
      (progn 
         (map (fn (ctl idx)
                 (if (== ctl *last_focus*)
                     (= next_index (% (+ idx dir) (length candidates)))))
              candidates)
         (when next_index
            (= new_ctl (prop candidates next_index))
            (set_focus_to new_ctl)
            ;; control will get the on_focus event, but we want to default
            ;; focus into the editor for this operation if the control has an editor
            (if new_ctl.editor
               (focus_to new_ctl.editor))))
      (notify (dtext "No controls are in the holding tank."))))
   {
     `usage: ["backward?:boolean"]
     `description: (+ "If backward? is false (default) swap the current control " 
                      "with the next control in the displayed control tree. Otherwise "
                      "swap with the first control in the holding tank. "
                      "If there are no controls, notifies the user that there are "
                      "no other non-displayed controls to swap to.")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     })

(defmacro on_key_down_event (e view `& key_to_action_pairs)
   (let
      ((acc []))     
      ;(assert (and e view key_to_action_pairs)
       ;       "Invalid syntax for on_key_down_event")
      (for_each (key_to_action_pair key_to_action_pairs)
                        (destructuring_bind (key action)
                           key_to_action_pair
                           (if (== key "otherwise")
                               (push acc true)
                               (push acc `(== kcode ,#key)))
                           (push acc action)))
      `(attach_event_listener 
          view
          `keydown
          (function (e)
             (let
                ((kcode e.key))
                (cond
                   ,@acc))))))

(defmacro defcontrol (name control_args allocations control_options)
   (let
      ((declared_allocations (each allocations first))
       (required_allocations [(quote render)])
       (user_allocations allocations)
       (meta { `description: (or control_options.description "No description")
               `tags: (or control_options.tags [`control `ui `DOM ])
               `usage: (if (is_array? control_options.usage)
                           (conj control_options.usage
                                 [ "options:object" ])
                           nil) })
       (args (progn
                (cond
                   (is_array? control_args)
                   (conj control_args [ (quote options) ])
                   else
                   (throw SyntaxError "defcontrol: missing/malformed control arguments - check syntax"))))
       (control_options (if (is_object? control_options)
                            control_options
                            {}))
       (control_bar? (if control_options.control_bar
                        true)))            
       (assert name "control name is required: check syntax for defcontrol")
       (if (< (length (reduce (d declared_allocations)
                         (contains? d required_allocations)))
              (length required_allocations))
           (throw SyntaxError "missing required declarations: must have render"))
  ;; ok, now create the form to be returned..
      `(defun ,#name ,#args
          (let
             ((self {})
              (options (or options {}))
              (`name (name_control (or options.name ,#(desym_ref name))))
              (id (generate_id ,#name))
              (initialized false)
              (title_span (span { `class: "juno-title" } name))
              (command_button (commands_button id))
              (content_view (div { } "uninitialized.."))
              (resize (fn ()
                         (progn
                            (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               (when options.on_resize
                                  (options.on_resize self))
                               ,#(if control_options.render_on_resize
                                     `(do_render)
                                     true)
                               true))))
              ,@user_allocations
              (control_status (if ,#control_bar?
                                  (div { `class: "juno-buffer-bar" }
                                   command_button
                                   (cond 
                                      (is_array? options.additional_elements)
                                      options.additional_elements
                                      else
                                      title_span)
                                   ,#(if (contains? (quote control_bar_elements) declared_allocations)
                                         (progn
                                            (prop (prop allocations (index_of (quote control_bar_elements) declared_allocations)) 1))
                                         []))
                                  nil))
              (do_render (fn ()
                            (let
                               ((new_view (render self)))
                               (if (and new_view
                                        (not (== content_view new_view)))
                                   (-> content_view `replaceChildren new_view))
                               (if _on_render
                                   (_on_render self)))))
              (resize_observer (new ResizeObserver resize))
              (view (control_frame (to_object
                                       [[`id id]
                                        [`events ,#control_options.events ]])
                     (if ,#control_bar?
                         control_status
                         [])
                                content_view))
              (_on_render (fn ()
                             ,#(if (contains? (quote on_render) declared_allocations)
                                `(on_render self)
                                nil)))
                             
              (_on_focus (fn ()                           
                           (progn
                            ,#(if control_bar?
                                `(add_class "juno-focused" control_status)
                                `[])
                            ,#(if (contains? (quote on_focus) declared_allocations)
                                `(on_focus self)))))
              (_on_destroy (fn ()                                     
                             (progn
                              ,#(if (contains? (quote on_destroy) declared_allocations)
                                  `(on_destroy self)))))
              (_to_json (function ()
                           (progn
                              ,#(if (contains? (quote to_json) declared_allocations)
                                    `(to_json)
                                    `[(quote ,#name) ,@control_args options]))))
              (initialize (function ()
                             (progn
                                (when (and view.parentElement
                                           (not initialized))
                                   (= initialized true)
                                   (-> resize_observer `observe view.parentElement)                                   
                                   ,#(if (contains? (quote on_initialize) declared_allocations)
                                         `(on_initialize self)
                                         true)
                                   (do_render))))))
             (set_prop options
                `id id
                `name name)
             ,@(when (is_array? control_options.expose)
                  (for_each (method_set control_options.expose)
                     (destructuring_bind (method_name method_reference)
                        method_set
                     `(set_prop self
                         ,#method_name ,#method_reference))))
             ,#(if (contains? (quote menu_items) declared_allocations)
                   `(set_prop self
                       `menu_items menu_items)
                   [])
             ;; finally set the required self options
             (set_prop self
                `options options
                `name name
                `type ,#(desym_ref name)
                `view view
                `resize resize                
                `initialize initialize
                `toJSON _to_json
                `on_destroy _on_destroy
                `on_focus _on_focus)
             ;; and return the self
             self)
          ,#meta))
   {
       `description: (+ "The macro defcontrol creates a function in the current namespace that implements the specified "
                        "control features passed to the macro.  The macro handles most of the boiler plate for a basic "
                        "control, combining the passed allocations and options to produce a standardized control "
                        "constructor.  The macro is similar in shape to a defun+let form with some differences.<br><br>"
                        "Like the defun macro, the first argument provides the name of the control that it will be used " 
                        "to construct the name and type of the control.  Also similar to defun, the second argument is "
                        "an array containing any arguments for the control.  Note that, mandatorily, an options argument "
                        "will be appended as the last argument of the argument list, so an empty array passed will "
                        "cause the control only to have an options argument.<br><br>"
                        "The next argument is a series of allocation forms that are integrated into a let allocation "
                        "structure, and so should be in the same form as the allocation block of the let operator.  For "
                        "example, ((render (fn () (div { } \"My View\")))) would meet the minimal requirement for a "
                        "control to be constructed.  The caller of this macro can have as many allocation forms as needed "
                        "to implement the required behavior of the emitted control.  To note that there are "
                        "symbols that made available to these provided forms in the evaluation context of the form that "
                        "can be referenced and used by the user provided forms:<br>"
                        "self:object - The interface object returned.<br>"
                        "content_view:Element - The control's view (not including the control_bar.  Effectively the contents of "
                        "the control view.<br>"
                        "do_render:function - Calls the (render) function provided to the macro.  User code can call this "
                        "function when a redraw is required.<br>"
                        "resize:function - A resize function to invoke if a forced resize is required.<br>"
                        "initialized:boolean - This value is true if the function is initialized or false if it hasn't " 
                        "yet been.<br>"
                        "options:object - The options object passed to the control on instantiation.<br>"
                        "<br><br>"
                        "There are multiple functions that are called upon certain events, which allow the caller to build "
                        "customized behavior and hook into the system when needed.  These functions are specified in the "
                        "allocation forms provided to the macro and are all optional except for render:<br>"
                        "render:function - This function returns the DOM structure assigned to content_view and is what is "
                        "drawn in the control's content container.  If the function returns nil, nothing is done.  Can be "
                        "used in conjunction with the on_render below, which acts on the already drawn view.<br>"
                        "on_focus:function - When a focusing event occurs to the control, this function is called with the "
                        "self object of the macro.<br>"
                        "on_render:function - If this function is specified it will act as the render function so as to "
                        "manipulate an already built view, via the content_view in scope symbol, which is the contents of the "
                        "controls view.<br>"
                        "control_bar_elements:array - If the control is specified with the control_bar control_options set to "
                        "true, the Elements in this array will be placed into the control bar after any runtime additional_elements "
                        "provided to the options object.<br>"
                        "menu_items:function - A function that is called on demand that should return an array containing "
                        "pairs of [menu_text menu_function] that implement any command functionality for the menu.<br>"
                        "on_destroy:function - When the control receives a destroy call, this user provided function will be "
                        "called with the self object.<br>"
                        "on_initialize:function - Upon initialization, this function will be called with the self function. It "
                        "should be expected that the initialization should be called only once for a control lifespan.<br>"
                        "to_json:function - This synchronous function call can be used to provide a customization hook "
                        "for the control.  The return value must be a structure that can be serialized into JSON form.<br><br>"
                        "The final object, control_options is meta data and other flags for the macro:<br>"
                        "exposes:array - An array of pairs that specify [ `function_handle function_to_call ] that are placed "
                        "on the self interface and provide the API for the control.  In order for a resource in the control "
                        "scope to be accessed, it must be specified in this option, otherwise the function remains effectively "
                        "private to the control.<br>"
                        "usage:array - The argument specification for the macro"
                        "description:string - The description of the control that is registered in the Environment.<br>"
                        "control_bar:boolean - If a control bar is to be displayed on the top of the control, set this to "
                        "true.<br>")
       `usage: ["name:symbol" "control_arguments:array" "allocations:array" "control_options:object"]
       `tags: ["control" "define" "controls" "ui"]
   })

(defcontrol tree_browser ()
   ((options (or (and (is_object? options)
                          options)
                     (throw SyntaxError "options object is required for tree_browser")))
    (stack [])
    (initial_render false)
    (title_span (span { spellcheck: false `contenteditable: true `tabindex: 0 `style: "caret-color: red; outline: none; display: inline-block; font-size: 1.1em; font-weight: bold; font-family: var(--main-mono-space); min-width: 10px; border: 1px dotted goldenrod; padding-left: 5px; padding-right: 5px" } ""))
    (caps_lock_span (span { `class: "juno-display-none" `style: "margin-left: 20px; padding-top: 2px; padding-left: 5px; padding-right: 5px; padding-bottom: 2px; border-radius: 3px; border: 1px solid var(--main-color); " } (dtext "caps lock")))
    (on_destroy (fn (self)
                  (progn
                   (when options.on_destroy                     
                     (options.on_destroy self))
                   true)))
    (current_pos 0)
    (content_view (div { `style: "" `class: "juno-symbol-browser" }))
    (get_current_stack (fn ()
                           (clone stack)))
    (select_text (dtext (or options.select_text
                            "Press Enter To Open")))
    (ol_for_pos (fn (pos)
                   (let
                      ((target_col nil))
                      (= target_col (-> content_view `querySelector (+ "ol[pos='" (if pos pos 0) "']")))
                      target_col)))
    
    (select_child (fn (ol_elem selected_child_text)
                     (when selected_child_text
                        (for_each (child ol_elem.children)
                           (if (and (is_element? child)
                                    (== (get_attribute child "path_value") selected_child_text))
                               (add_class "juno-selected" child)
                               (remove_class "juno-selected" child))))))
    (path_sep (fn ()
                 (or options.path_separator "/")))
    
    (num_ol_elems (fn ()
                    (length content_view.children)))
                       
    
    (create_ol_at_pos (fn (pos)
                         (try
                            (let
                               ((stack_value_at_pos (prop stack pos))
                                (contents (get_possibles pos)))
                               (ol { `style: (if (not (is_array? contents))
                                                 "width: 100%; max-width: 100%; position: relative;"
                                                 "height: calc(100% - 20px);  position: relative;")
                                            `pos: pos }
                                   contents))
                            (catch Error (e)
                               (log "ERROR: create_ol_at_pos: " pos "" e.message)))))
    
    (find_value (fn (elem key)
                   (let
                      ((v nil))
                      (cond
                         (= v (get_attribute elem key))
                         v
                         elem.parentElement
                         (find_value elem.parentElement key)
                         else
                         nil))))
    
    (get_specifics_for_event (fn (e)
                                (let
                                   ((elem e.srcElement)
                                    (path_value (find_value elem "path_value"))
                                    (pos (int (find_value elem "pos"))))
                                   (set_path_at pos path_value))))
    
    (set_path_at (fn (pos path_value)
                    (when path_value
                       (cond
                          (== pos stack.length) ;; at end
                          (progn
                             (push stack path_value)
                             (render_stack))
                          (< pos stack.length)
                          (progn
                             (= stack (-> stack `slice 0 pos))
                             (push stack path_value)
                             (clear_suffix)
                             (render_stack))
                          else
                          (log "set_path_at: unhandled: " pos path_value)))))
    (is_at_leaf false)
    (was_at_leaf false)
    (at_leaf (fn ()
                (progn 
                   is_at_leaf)))
                   ;(log "at_leaf?: is_at_leaf: " is_at_leaf (not (has_class? "filtered-hidden" instruction_div)))
                   ;(not (has_class? "filtered-hidden" instruction_div)))))
    
    (get_path_components (fn (raw)
                            (let
                               ((text (or title_span.innerText ""))
                                (ps (path_sep)))
                               (if raw
                                  text
                                  (progn
                                     (if (ends_with? ps text)
                                         (= text (chop text)))
                                     (split_by ps text))))))
    (get_suffix (fn ()
                   (let
                      ((comps (get_path_components)))
                      (if (> comps.length stack.length)
                          (last comps)
                          ""))))
    
    (clear_suffix (fn ()
                     (let
                        ((elem (ol_for_pos stack.length))
                         (ps (path_sep)))
                        
                           (set_prop title_span
                              `innerText (+ (join ps stack)
                                            (if (and (> stack.length 0)
                                                     (not (at_leaf)))
                                                ps
                                                "")))
                        (if elem
                            (for_each (c elem.children)
                               (remove_class "filtered-lower-opacity" c))))))
                        
    (get_matches (fn (k highlight?)
                    (let
                       ((num_matches 0)
                        (pos stack.length)
                        (addl (if (blank? k) "" k))
                        (suffix (+ (get_suffix) addl))
                        (matched [])
                        (first_match nil)
                        (not_matched []))                       
                       (if (< pos 0)
                           []
                           (aif (ol_for_pos pos)
                                (for_each (c it.children)
                                   (progn
                                      (if (and (not (blank? suffix))
                                               (starts_with? suffix c.innerText))
                                          (push matched
                                                c)
                                          (push not_matched
                                                c))))))
                       (= last_matched matched)
                       (when highlight?
                          
                          
                          (for_each (elem not_matched)
                             (add_class "filtered-lower-opacity" elem))
                           (for_each (elem matched)
                              (remove_class "filtered-lower-opacity" elem)))
                       (= first_match matched.0)
                       (when first_match
                          (set_prop first_match.parentElement
                             `scrollTop
                             (- (prop first_match `offsetTop) 10)))
                       matched)))
    
    (get_last_column_values (fn ()
                               (let
                                  ((elem (ol_for_pos stack.length)))
                                  (if elem
                                      (for_each (c elem.children)
                                         (prop c `innerText))
                                      []))))
    
    (matched_as_text (fn (matched)
                        (map (fn (v)
                                v.innerText)
                             matched)))
    (last_suffix nil)
    (caps_lock_timer nil)
    (last_matched [])
    (select_matches (fn (k)
                       (let
                          ((text nil)
                           (in_reverse (== k "Backspace"))
                           (matched nil)
                           (prefix nil)
                           (suffix nil)
                           (exact_match nil)
                           (existing_suffix nil)
                           (ps (path_sep))
                           (last_path nil)
                           (at_leaf? (at_leaf)))                         
                          ;; are we going forward or backwards?
                          ;; if forwards, determine if we pressed a delim key or a regular key
                          ;; if we pressed a delim key, and the final path segment matches an element in the column, push that value to the stack, and redraw the columns and the title_span
                          ;; if we pressed a regular key, find the common prefixes, write that to the title_span,
                          ;; ...and follow the filter process.
                          ;; if we matched to a leaf, display the instruction_div 
                          
                          ;; if backwards, determine if we are at a leaf or not
                          ;; if we are, remove the character from the title_span, pop the stack, find the common prefix, write that to the title_span, follow the filter process
                          ;; if we are not, remove the character, find the common prefix, write that to the title_span and 
                          ;; follow the filter process
                          
                          ;; Filter process:
                          ;; Determine the amount of matched elements at the last path segment
                          ;; if 1 match then append the value to the path and redraw the title and the column selectors
                          ;; if >1 then find the common prefix, and append the common prefix to the title_span
                          ;; ..and highlight the matching values in the column
                          ;; if 0 matches don't append the character since it cannot contribute to narrowing the selection
                         
                          (cond
                             in_reverse
                             (progn 
                                (= was_at_leaf at_leaf?)
                                (when at_leaf? ;; if we are at leaf state, remove the final value from the stack
                                    (pop stack)
                                   
                                    (= is_at_leaf false)
                                    (add_class "filtered-hidden" instruction_div))
                                (if options.allow_non_matches
                                   (run_validations))
                                ;; find the common prefix with one character removed
                                (= existing_suffix (get_suffix))                    
                                (when (not (blank? existing_suffix))
                                   (if options.allow_non_matches
                                      (= prefix (chop existing_suffix))
                                      (= prefix (find_common_prefix (get_last_column_values) (chop existing_suffix)))))
                                (when (== prefix last_suffix)
                                    ;; we had this value last backspace, so we need to go back further
                                    (= prefix "")
                                    (= last_suffix nil))
                                (cond
                                   (and options.allow_non_matches
                                        (blank? prefix))
                                   (progn
                                      (if (blank? last_suffix)
                                          (progn
                                             (pop stack)
                                             (render_stack))
                                          (progn 
                                             (clear_suffix)
                                             (render_title prefix)
                                             true)))
                                   (blank? existing_suffix)  ;; there is no suffix, so pop the stack 
                                   (progn        
                                      (pop stack)
                                      (try
                                         (clear_suffix)
                                         (catch Error (e)
                                            (log "ERROR on clear_suffux: " e.message)))
                                      (try
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR on render stack: " e.message))))
                                   
                                   (blank? prefix)  ;; when no common prefix remove the suffix altogether
                                   ;; we will have to rebuild the title_span explicitly otherwise suffix will be preserved
                                   (progn
                                      (clear_suffix)
                                      (render_stack))
                                      ;; clear all the matches..
                                   (> (length prefix) 0)
                                   (progn
                                      (clear_suffix)
                                      (render_stack prefix true)
                                      (= last_suffix prefix)
                                      (get_matches "" true))
                                   else
                                   ;; just clear the last suffix 
                                   (progn
                                      (= last_suffix nil))))
                                ;; if we were at a leaf, we are no longer so remove the leaf node from the stack
                             
                             (and (not options.allow_non_matches)
                                  (or (== k ps)
                                      (== k "Tab")))
                             (progn
                                (= matched (get_matches "" true))
                                (= last_path (last (get_path_components)))
                                
                               (cond 
                                  ;; if there is only one match 
                                  (and (> (length title_span.innerText) 0)
                                       (== (length matched) 1)
                                       (not (ends_with? ps title_span.innerText)))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))
                                  ;; if there are multiple matches, but in those matches there is an exact match
                                  (and (> (length title_span.innerText) 0)
                                       (== (length (reduce (t (matched_as_text matched))
                                                      (== last_path (first (split_by "\n" t)))))
                                           1))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))))
                                  
                                     
                             else
                             (progn
                                (if options.allow_non_matches
                                   (if (or (== k "Tab")
                                           (== k ps))
                                       (= matched (get_matches "" true))
                                       (= matched (get_matches k true)))
                                   (= matched (get_matches k true)))
                                (= last_matched matched)  
                                (cond                                  
                                   (and (not (== k ps))
                                        (not (== k "Tab"))
                                        (not (> k.length 1))
                                        options.allow_non_matches)
                                   (progn
                                      (= prefix (+ (or (get_suffix) "") k))
                                      (render_title prefix)
                                      (when options.validate_selection
                                        (run_validations)))
                                   (== (length matched) 1)  ;; ok we matched only 1 so go ahead and put it into the stack
                                   (progn
                                      (push stack 
                                            (first (split_by "\n" matched.0.innerText)))
                                      (try 
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR: " e.message))))
                                   
                                   (and ;options.allow_non_matches
                                        (> (length matched) 1)
                                        (or (== k "Tab")
                                            (== k ps)))
                                   (progn
                                      (= prefix (get_suffix))
                                      (= exact_match (first (reduce (v matched)
                                                               (when (== (first (split_by "\n" v.innerText)) prefix)
                                                                  prefix))))
                                      (if exact_match
                                         (progn
                                            (push stack
                                               (first (split_by "\n" matched.0.innerText)))
                                            (try (render_stack)
                                               (catch Error (e)
                                                  (log "ERROR: " e.message))))
                                         (progn
                                            ;; find the common prefix and render title
                                            (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                            ;; subtract suffix
                                            (render_title prefix))))
                                   (> (length matched) 1)  ;; multiple matches, so add the character to the suffix
                                   (progn
                                      ;; find the common prefix and render title
                                      (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                      ;; subtract suffix                                                                            
                                      (render_title prefix)))))
                          (= last_suffix (get_suffix))
                           true)))
                                   
                                ;; if it is a control type type don't display
    (select_button (button { `tabindex: 0 `class: "juno-primary" `style: "font-weight: bold;margin-right: 20px;" } (or options.select_button_text "Select")))
    (instruction_div (span {`style: "float: right; margin-right: 30px; padding-left: 8px; padding-right: 8px; font-weight: bold; color: var(--value-modified-color);"  `class: "filtered-hidden"  } 
                           select_button
                           select_text))
    (prefix_div (span { `style: "font-size: 1.1em; margin-right: 8px;" } (dtext "Select or Type:")))
    (open_selection (fn ()
                       (when (and (not (has_class? "filtered-hidden" instruction_div))
                                  options.on_select
                                  (if options.allow_non_matches
                                     (options.on_select (get_path_components))
                                     (options.on_select stack))))))
    (handle_enter_event (fn (e)
                           (cond
                              (== e.srcElement title_span)
                              (progn
                                 (handle_event e)
                                 (open_selection))
                              else
                              (get_specifics_for_event e))))
   
    (on_initialize (fn (self)
                      (progn
                          (on_key_down_event e view
                             ("Enter" (progn
                                         (handle_enter_event e)))
                                         
                             ("Escape" (progn
                                          (handle_event e)
                                          (destroy_control self)))
                             ("Tab" (progn
                                       (if (or options.allow_non_matches
                                               (not (at_leaf)))
                                           (handle_event e))
                                       (select_matches e.key)))
                             (`otherwise (progn 
                                            (when (== e.srcElement title_span)
                                               (handle_event e)
                                               (if (or (== e.key "CapsLock") 
                                                       (-> e `getModifierState "CapsLock"))
                                                   (progn
                                                      (when caps_lock_timer
                                                         (clearTimeout caps_lock_timer))
                                                      (= caps_lock_timer 
                                                         (setTimeout (fn () (add_class "juno-display-none" caps_lock_span)) 1000))
                                                      (remove_class "juno-display-none" caps_lock_span))
                                                   (add_class "juno-display-none" caps_lock_span))
                                               
                                               (select_matches e.key)
                                               ))))
                         
                         (-> title_span.parentElement
                             `appendChild
                             instruction_div)
                         (-> title_span.parentElement
                            `appendChild
                            caps_lock_span)
                         (-> title_span.parentElement `insertBefore
                             prefix_div title_span)
                         (attach_event_listener select_button
                            `click
                            (fn (e)
                               (progn
                                  (handle_event e)
                                  (open_selection))))
                         (add_class "juno-highlighted" title_span.parentElement)
                         (attach_event_listener content_view
                                                `click
                                                get_specifics_for_event ))))
    
    (get_possibles (fn (pos)
                       (cond 
                          (is_function? options.get_possibles_elem)
                          (-> options `get_possibles_elem pos)
                          (is_function? options.get_possibles)  ;;  returns either a single obj with keys or an array of those objects
                          ;; keys: ctype has_children? title path_value  and view
                          (let
                                ((idx -1)
                                 (val nil)
                                 (filter_text (last (split_by (or options.path_separator "/") title_span.innerText))))
                                (= val (-> options `get_possibles pos self))
                                (if (not (is_array? val))
                                    (progn
                                       ;(remove_class "filtered-hidden"  instruction_div)
                                       (= is_at_leaf true))
                                    (progn
                                       (= is_at_leaf false)
                                       ;(add_class "filtered-hidden" instruction_div) 
                                       ))
                                (if (and options.allow_non_matches
                                         options.validate_selection)
                                    (run_validations)
                                    (if is_at_leaf
                                       (remove_class "filtered-hidden"  instruction_div)
                                       (add_class "filtered-hidden" instruction_div)))
                                    
                                (cond
                                   (is_array? val)
                                   (for_each (obj val)
                                      (progn
                                         (inc idx)
                                         
                                         (li { `tabindex: 0
                                                `ctype: (or obj.ctype "sym" )
                                               `title: obj.title
                                               `class: (+ "juno-list-item " 
                                                          (if obj.has_children? "juno-list-item-has-children " "") 
                                                          (if (and (not (blank? filter_text))
                                                                   (not (starts_with? filter_text obj.path_value)))
                                                              "filtered-lower-opacity"
                                                              ""))
                                               `style: (or obj.style
                                                           "")
                                               `path_value: obj.path_value
                                               } 
                                               (if obj.view 
                                                   obj.view 
                                                   idx))))
                                         
                                   (is_object? val)
                                   (li { `tabindex: 0
                                         `ctype: (or val.ctype "sym" )
                                         `title: val.title
                                         `class: (+ "juno-list-item " (if val.has_children? "juno-list-item-has-children " "") (if val.class val.class ""))
                                         `style:  (+ "height: calc(100% - 20px); " (if val.style val.style ""))
                                         `path_value: (or val.path_value nil)
                                         } (if val.view val.view idx))
                                   (is_string? val)
                                   (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: calc(100% - 50px);" }
                                    val)
                                   else
                                   (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: calc(100% - 50px);" }
                                    (value_to_dom val))))
                           else
                           (div { } "Missing get_possibles function or get_possibles_elem in options"))))
    (run_validations (fn ()
                        (when (and options.allow_non_matches
                                   options.validate_selection)
                           (if (-> options `validate_selection (get_path_components true) (at_leaf) last_matched)
                               (remove_class "filtered-hidden" instruction_div)
                               (add_class "filtered-hidden" instruction_div)))))
                           
                            
    (render_title (fn (new_suffix)
                     (let
                        ((suffix (or new_suffix (get_suffix) ""))
                         (ps (path_sep)))
                        (set_prop title_span
                           `innerText
                           (+ (join ps stack)
                              (cond 
                                 (at_leaf)
                                 ""
                                 (and (blank? suffix)
                                      (> stack.length 0)
                                      (if (and options.allow_non_matches
                                               options.validate_selection)
                                          (not (-> options `validate_selection (get_path_components true) (at_leaf) last_matched))
                                          true))
                                 ps
                                 (== stack.length 0)
                                 (+ "" suffix)
                                 else
                                 (+ ps suffix))))
                        (run_validations)
                        (place_caret_at_end title_span))))
    
    (render_stack (fn (prefix no_rerender)
                     (let
                        ((ol_elem nil)
                         (new_ol_elem nil))
                        
                        (if (or (not no_rerender)
                                was_at_leaf)
                        (when (> (num_ol_elems) stack.length)
                           (try
                           (for_each (pos (range_inc  stack.length (num_ol_elems)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (when ol_elem
                                    (-> ol_elem `remove))))
                           (catch Error (e)
                              (log "Error on: stack render p1: " e.message)))))
                        ;; is the stack already drawn, or do we need to render it?
                        (try
                           (for_each (pos (range (+ stack.length 1)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (if ol_elem
                                    (select_child ol_elem (prop stack pos))
                                    (progn
                                       (= new_ol_elem (create_ol_at_pos pos))
                                       (if new_ol_elem
                                          (-> content_view `append
                                             (create_ol_at_pos pos)))))))
                           (catch Error (e)
                              (log "Error on: stack render p2: " e.message)))
                        (try
                           (render_title prefix)
                           (catch Error (e)
                              (log "Error on render_title: " e.message))))))
    
    (on_render (fn (self broaden)
                       (let
                          ((next_elem nil))
                          ;(render_stack)
                          nil)))
                          
    (render (fn ()
               (if (not initial_render)
                   (progn
                      (= initial_render true)
                      (render_stack)
                      content_view)
                   nil))))
   {
     `control_bar: true
     `expose: [[`get_current_stack get_current_stack]]
     })



(defun file_tree_browser(options)
    (let
       ((create_mode options.create_mode)
        (render_entry (fn (entry)
                         (let
                              ((etype (fn (entry)
                                         (cond
                                                entry.isDirectory "directory"
                                                entry.isFile "file"
                                                entry.isSymlink "symlink")))
                               (rval nil))
                              (= rval
                               {
                                 `has_children?: entry.isDirectory
                                 `path_value: entry.name
                                 `class: (etype entry)
                                 `ctype: "sym"
                                 `view: (div { `style: "display: inline-block; width: 100%;"
                                               `class: (+ "juno-type-file-entry " (etype entry)) }
                                               entry.name
                                               (if entry.isDirectory
                                                    (span { `style: "display: inline-block; float: right" } "â–¸")
                                                      "")) })
                              ;(log "render_entry: entry rval: " rval rval.view.outerHTML)
                              rval)))
        
        (get_possibles (fn (pos control)
                           (let
                              ((next_values (if (== pos 0)
                                                (http/list_files "/")
                                                (http/list_files (join "/" (-> control `get_current_stack))))))
                              (when (is_array? next_values)
                                 (sort next_values { `key:`name }))
                              (= next_values (clone next_values))
                              (cond
                                 (is_array? next_values)
                                 (for_each (entry next_values)
                                    (render_entry entry))
                                 (instanceof next_values Blob)
                                 {
                                   `has_children?: false
                                   `ctype: "file"
                                   `style: "width: calc(100% - 10px) !important;"
                                   `view: (div { `style: "display: inline-block; width: calc(100% - 50px); height: 100%; overflow: hidden" }
                                               (div { `style: "height: calc(100% - 30px); overflow: scroll;" }
                                                    (pre {} (-> next_values `text)))
                                               (div { `style: "padding: 10px;" }
                                                    []))  ;; placeholder for any additional information about the file
                                   }
                                 else
                                 {
                                   `has_children?: false
                                   `ctype: "file"
                                   `view: (pre {} (sub_type next_values))
                                   }))))
        
        (control (tree_browser (+ { `path_separator: "/"
                                    `render_entry: render_entry
                                    `get_possibles: get_possibles
                                    allow_non_matches: (if create_mode true false)
                                    select_text: (if create_mode
                                                    "Press Enter To Create"
                                                    "Press Enter To Open")
                                    select_button_text: (if create_mode
                                                           "Create"
                                                           "Open")
                                    validate_selection: (fn (path at_leaf matches)
                                                           (try
                                                              (progn
                                                                 ;(log "v:" path  "at_leaf: " at_leaf "# m: " (length matches))
                                                                 (cond
                                                                    at_leaf
                                                                    false
                                                                    (ends_with? "/" path)
                                                                    false
                                                                    (== 0 (length path))
                                                                    false
                                                                    (and (is_array? matches)
                                                                         (== (length matches) 1)
                                                                         (== (first (split_by "\n" (prop (first matches) `innerText)))
                                                                             (last (split_by "/" path))))
                                                                    false
                                                                    else
                                                                    true))
                                                              (catch Error (e)
                                                                 (progn
                                                                    (log "Error: " e.message)
                                                                    false))))
                                    }
                                    (if (is_object? options)
                                        options
                                        {})))))
       
       control))



(defun save_active_buffer (save_all)
  (cond
    save_all
    (for_each (control (select_controls (fn (ctl) (is_function? (prop ctl `save)))))
              (-> control `save))
    (and *last_focus*
         (prop *last_focus* `save))
    (-> *last_focus* `save)
    *last_focus*         
    (notify (+ "" (or (prop *last_focus* `name) "Unnamed") " " (dtext "doesn't have a save method") "."))
    else
    (notify (dtext "There isn't an active control."))))
    
    
(defun split_control (dir)
   (alert_on_error "Unable to perform split"
                   (let
                      ((target *last_focus*))
                      (if (eq nil target)
                          (throw Error "No Focused Control to split"))
                      (cond
                         (and (== dir "vertical")
                              (prop target `split_vertical))
                         (-> target `split_vertical)
                         (and (== dir "horizontal")
                              (prop target `split_horizontal))
                         (-> target `split_horizontal)
                         (and (== dir "vertical")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_right" target (last (-> (control_holding_tank) `controls)))
                         (and (== dir "horizontal")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_below" target (last (-> (control_holding_tank) `controls)))
                         else
                         (notify (+ "No controls to split to" (prop target.options `name) " cannot be split"))))))


(defcontrol line_display ()
   ((menu_items (fn ()
                   [["Test" (fn ()
                               (notify "Notify Test Menu"))]]))
    (current_value (or "Not Set"))
    (set (fn (val)
            (progn
               (= current_value val)
               (do_render))))
    (render (fn ()
               (div { `class: "juno-mono-space" `style: "white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" }
                current_value))))
   {
       `buffer_bar: false
       `expose: [[`set set]]
       `usage: []
   })

(defcontrol juno_documentation_control ()
   ((definition_view (div { `class: "juno-log-output" `style: "padding: 5px; overflow: scroll; width: calc(100% - 20px);" } "Help Introduction"))
    (content_view (div { `class: "juno-log-output" `style: "padding: 5px;height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden;" } 
                       definition_view))
    (view (div { `class: "juno-log-output" `style: "padding: 5px; width: calc(100% - 20px); overflow: hidden;"} 
          content_view))
    (name "Juno Documentation")
    (title_span (span { `style: "font-weight: bold; margin-right: 15px;" } (dtext "Documentation")))
    (pin_button (button { } (dtext "Pin")))
    (history_button (button { } (dtext "History")))
    (pinned? (fn ()
                (has_class? "juno-button-on" pin_button)))
    (history [])
    (history_max_length 5)
    (current_symbol nil)
    (control_bar_elements [pin_button history_button])
    (render_command_elem (fn (command)
                            (let
                               ((results (describe command true)))
                               (for_each (meta_obj (or results ()))
                                  (format_help meta_obj)))))
    
    (render_help (fn (command)
                    (div { `class: "" `style: "overflow-x: hidden;" }
                         (for_each (v (to_array (or (render_command_elem command) [])))
                            (div { `style: "padding: 5px; margin-bottom: 10px; background: var(--editor-bg-color);" }
                                 v)))))
    
    (message_receiver (fn (event_obj force)
                         (let
                            ((first_arg (let
                                           ((comps (split_by "(" event_obj.args.0)))
                                           (or (second comps)
                                               (first comps))))
                             (new_view nil))
                            ;; deal with recording the history 
                            (when first_arg
                               (when (not (== (last history) first_arg))
                                  ;(log "pushed:" (last history) first_arg)
                                  (push history
                                     first_arg)
                                  (if (pinned?)
                                      (-> history_content_view `prepend (render_help first_arg))
                                      (if (> (length history) 1)
                                          (-> history_content_view `prepend (render_help (prop history (- (length history) 2)))))))
                               (when (> (length history) history_max_length)
                                  (take history)
                                  (aif (last history_content_view.children)
                                       (-> it `remove))))
                              
                            (when (or (and force first_arg)
                                      (and first_arg
                                         (not (pinned?))))
                               (= current_symbol first_arg)
                               (-> definition_view `replaceChildren
                                  (render_help current_symbol))))))
    
    (handler_function_id (gen_id "hid"))
    (history_mode? (fn ()
                      (has_class? "juno-button-on" history_button)))
    (history_content_view (div { `style: "overflow: scroll; height: calc(100% - 10px); width: calc(100% - 20px;) overflow: scroll;" } ))
    (history_view (div { `class: "juno-log-output" `style: "height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden; padding: 5px;" } 
                       history_content_view))
    (split_view nil)
    (show_history (fn (show?)
                       (let
                          ()
                          (if show? ;; update our button
                             (add_class "juno-button-on" history_button)
                             (remove_class "juno-button-on" history_button))
                          (cond
                             (and (history_mode?)
                                  (is_control? split_view))
                             nil ;; already showing
                             (and (history_mode?)
                                  (eq nil split_view))
                             (progn
                                (-> definition_view `remove)
                                (= split_view
                                   (split_view_horizontal definition_view history_view))
                                (-> content_view
                                   `replaceChildren
                                   split_view.view))
                             (not (history_mode?))
                             (progn
                                (-> split_view.view `remove)
                                (-> split_view `destroy)
                                (= split_view nil)
                                (-> content_view
                                   `replaceChildren
                                   definition_view))))))
                             
                          
                          
    (render (fn ()
               (if (not initialized)
                   view)))
    (on_render (fn ()
                  (when current_symbol
                     (-> definition_view `replaceChildren
                        content_view))))
                 
    (on_initialize (fn (anything_here)
                      (progn
                         (register_event_handler nil "display_usage" handler_function_id message_receiver)
                         (attach_event_listener pin_button
                            `click
                            (fn (e)
                               (if (has_class? "juno-button-on" pin_button)
                                   (remove_class "juno-button-on" pin_button)
                                   (add_class "juno-button-on" pin_button))))
                         (attach_event_listener history_button
                            `click
                            (fn (e)
                               (progn
                                  (show_history (not (history_mode?))))))
                               
                         anything_here)))
    (on_destroy (fn (anything_here)
                   (progn
                      (remove_event_handler nil "display_usage" handler_function_id)
                      )))
    (set_pinned (fn (value)
                   (cond
                      (== value current_symbol)
                      (add_class "juno-button-on" pin_button)
                      (is_string? value)
                      (progn
                         (add_class "juno-button-on" pin_button)
                         (message_receiver { args: [ value ] } true))
                      else
                      (add_class "juno-button-on" pin_button))))
    (release_pin (fn ()
                    (remove_class "juno-button-on" pin_button)))
    
    )
   {
     `control_bar: true
     `expose: [[ `set_pinned set_pinned]
                [ `get_history (function () (clone history)) ]]
     `usage: []
     })

;; hide the documentation control behind a singleton function
(defun juno_documentation (options)
   (aif (get_control_by_name "Juno Documentation")
        it
        (juno_documentation_control options)))



(defun handle_app_click_event (e)
  (let
      ((elem e.srcElement)
       (elem_type e.srcElement.tagName)       
       (control_id (get_attribute elem "control_id"))
       (control (if control_id
                  (get_control_by_id control_id)))
       (parents (each (parents_for_control control) `name)))
    (cond
      (and (has_class? "juno-command-button" elem)
           (== elem_type "BUTTON")           
           control)
      ;; a command button was clicked show the menu for the control
      (let
          ((control_menu (conj (if (is_function? control.menu_items)
                                 (-> control `menu_items)
                                 [[]])
                               [[(dtext "Swap") (reduce (other_control (current_controls true))
                                                         (unless (or (== other_control control)
                                                                     (eq nil other_control.name)
                                                                     (contains? other_control.name parents))
                                                                 [other_control.name (fn () (swap_control control other_control)) ]))]
                                [(dtext "Hide") (fn ()
                                                  (hide_control control))]
                                ["--" nil]
                                [(dtext "Close Control")
                                 (fn ()
                                    (destroy_control control))]])))
        (make_menu elem control_menu)))))

      
                                                
(defun app_menu(global_menu_path options)
  (let
      ((view nil)
       (options (either options {}))
       (top_levels [])
       (menu_trees (resolve_path global_menu_path Environment.global_ctx.scope))
       (id (or options.id (generate_id "app_menu")))
       (intf {})
       (menu_trees (or menu_trees []))
       (compute_top_levels (fn ()
                             (progn
                                
                                (defvar headers (each menu_trees `0))
                                (if (== nil (get_control_by_name (last headers)))
                                    (pop headers))
                                
                                headers)))
                                    
       (help_idx nil)
       (add_menu (fn (menu)
                   (let
                       ((existing_idx (index_of menu.0 top_levels)))
                     (if (== existing_idx -1)
                       (push menu_trees
                             menu)
                       (-> menu_trees `splice existing_idx 1 menu))
                     (set_path global_menu_path Environment.context.scope menu_trees)
                     (build_view))))
       (remove_menu (fn (menu_text)
                      (let
                          ((existing_idx (index_of menu_text top_levels)))                           
                        (when (and (> existing_idx -1)
                                   (prop view.children existing_idx))
                          (-> (prop view.children existing_idx)
                              `remove)
                          (-> menu_trees `splice existing_idx 1))
                        (set_path global_menu_path Environment.context.scope menu_trees))))
       (show_sub_menu (fn (e)
                         (let
                            ((idx (-> e.srcElement `getAttribute `idx))
                             (menu_header (if (== e.srcElement.tagName "SPAN")
                                              e.srcElement.parentElement
                                              e.srcElement))
                             (pos (-> menu_header `getBoundingClientRect))
                             (help_menu_function nil)
                             (on_select (fn ()
                                           (when menu_header
                                              (remove_class "juno-menu-selected" menu_header))))
                             (mview nil)
                             (menu nil))
                            (aif (get_by_id "cmenu")
                                 (-> it `remove))
                            (remove_class "juno-menu-selected" menu_header)
                            (when idx
                               (add_class "juno-menu-selected" menu_header)
                               (if (== (parseInt idx) help_idx)
                                   (= help_menu_function *help_menu_function*)
                                   (= help_menu_function nil))
                               (console.log "app_menu: clicked: " idx "help_idx: " help_idx (prop menu_trees (parseInt idx)))
                               (aif (or help_menu_function
                                        (resolve_path [ (parseInt idx) 1 ] menu_trees))
                                    (progn
                                       (cond
                                          help_menu_function
                                          (= menu (menu_tree (it) { `on_select: on_select } ))
                                          (is_function? it)
                                          ;; if the underlying menu is a function, call the function to get..
                                          ;; up to the minute menu contents
                                          (= menu (menu_tree (it (first (prop menu_trees (parseInt idx)))) { `on_select: on_select } ))
                                          ;; other wise it is a standard menu, which may not rehydrate well depending
                                          ;; on how it was created..
                                          else
                                          (= menu (menu_tree it { `on_select: on_select } )))
                                       (= mview (div { `id: `cmenu `class: "juno-menu" `style: " z-index: 30" }
                                                     menu.view))
                                       (set_style [["position" "absolute"]
                                                   ["left" (+ "" (Math.max 0 pos.left 0) "px")]
                                                   ["top" (+ "" (Math.max 0 pos.bottom ) "px") ]]
                                                  mview)
                                       (-> (get_by_id "body") `appendChild
                                           mview))
                                    (progn
                                       (remove_class "juno-menu-selected" menu_header)
                                       (notify "Unable to find menu resource")))))))
       (build_view (fn ()
                       (let
                           ((new_view nil)
                            (header_elem nil))
                         (= top_levels (compute_top_levels))
                         (unless options.disable_help
                                 (push top_levels
                                       "Help")
                                 (= help_idx (- (length top_levels) 1)))
                         
                         (= new_view
                            (ul { `id: id `class: "pure-menu-list" `style: "margin-left: 10px" }
                                (if (> top_levels.length 0)
                                  (map (fn (top_level idx)
                                         (li { `idx: idx  `class: "juno-menu-header juno-main-menu-header" }
                                             (span { `idx: idx `class: "juno-menu-item" } (dtext top_level))))
                                       top_levels)
                                  [])))
                         (map (fn (child)
                                 (progn
                                    (attach_event_listener child
                                       `mouseenter
                                       (fn (e)
                                          (progn
                                             (when (get_by_id "cmenu") ;; if the menu is already showing show the new menu, otherwise don't do anything
                                                (remove_class "juno-menu-selected" new_view.children)
                                                (show_sub_menu e)))))
                                    (attach_event_listener child
                                       `mouseleave
                                       (fn (e)
                                          true))))
                              new_view.children)
                         (attach_event_listener new_view
                                                `click
                                                show_sub_menu)
                                                                        
                         
                         (if view.parentElement
                           (-> view `replaceWith new_view))
                         (= view new_view)
                         view))))
    
    
    (build_view)
    (set_prop options
              `id
              id)
    (set_prop intf
              `view view
              `add_menu add_menu
              `remove_menu remove_menu
              `type "app_menu"
              `toJSON (function ()
                                `(app_menu ,#global_menu_path ,#options)))
    (setq *app_menu_control* intf)
    intf))

(defun app_header (controls options)
  (let
      ((existing_header (-> document `querySelector "header"))
       (intf nil))
    (when (eq existing_header nil)
      (-> (first (get_by_tag "body"))
          `prepend
          (= existing_header (header { `id: "page-header" class: "juno-page-header" }))))
    (when options.app_title
      (-> existing_header `appendChild (span { `class: "juno-header" } options.app_title)))
    (for_each (`elem controls)
              (progn
               (cond
                 elem.view
                 (-> existing_header `appendChild elem.view)
                 (is_element? elem)
                 (-> existing_header `appendChild elem)
                 else
                 (create_dom_element "span" elem))))
    (set_prop options
              `id
              (or options.id "app-header"))
   
    (= intf
       {     
        `options: options
        `controls: controls
        `type: "app_header"
        `toJSON: (function ()
                           `(app_header ,#controls ,#options))
        })
    
    intf))


(defun build_starter_environment ()
  (if is_served?
    (progn
     (log "building starter environment")
     (floating_div (iframe { width: 500 height: 300
                   `style: "width: 90%; min-width: 500px; overflow: scroll; border: 0px solid transparent;"
                   src: (+ "/env/starter.html?theme=" (resolve_path [ `application `global_theme ] *env_config*))} )))))


(defun controls_by_parent ()
    (let
        ((acc [])
         (current { `root: [] })
         (found_control {})
         (control_identity (fn (control)
                                 (and control
                                      (or control.name
                                          control.options.id
                                          "Untitled"))))
         (collect_control (fn (control parent)
                              (when (and control.options.id 
                                         (not (prop found_control control.options.id)))
                                 (when (and parent
                                            (not control.name))
                                     (cond
                                         parent.name
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.name "-" control.type))
                                         parent.type
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.type "-" control.type))))
                                 (cond
                                     (and parent
                                          (not (prop current (control_identity parent))))
                                     (set_prop current 
                                               (control_identity parent)
                                               [ control ])
                                     (and parent
                                          (prop current (control_identity parent)))
                                     (push (prop current (control_identity parent))
                                               control)
                                     (eq nil parent)
                                     (push (prop current `root)
                                               control))
                                 (set_prop found_control
                                           control.options.id
                                           control)))))
        (for_each (controls (or $root_controls []))
           (control_tree controls collect_control))
        current))

(defun all_global_controls (namespace)
   (let
      ((env_handle (if namespace 
                       (-> Environment `get_namespace_handle namespace)
                       nil)))
      (if namespace
          (reduce (pset (pairs env_handle.context.scope))
             (destructuring_bind (symbol_name symbol_value)
                pset
                (if (is_control? symbol_value)
                    symbol_name)))
          (flatten (for_each (namespace (namespaces))
                      (for_each (ctl (all_global_controls namespace))
                         (+ namespace "/" ctl))))))
   {
     `description: (+ "Returns all controls in the global context.  If provided " 
                      "with a namespace, it will return only the controls for "
                      "that namespace, otherwise it will return all controls "
                      "in every namespace in a fully qualified form.")
     `usage: ["namespace:?string"]
     `tags: [`controls `ui `global]
     })


(defun serialize_controls (controls)
  [(quote quote) [(quote quote) (JSON.parse (JSON.stringify controls))]])



(defun save_control_image ()
  (progn

   (log (dtext "Saving Application State.."))
   (set_focus_to nil)
   (defvar system_repl *system_repl*)
   (= *system_repl* nil)
   
   (= *serialized_controls* (serialize_controls $root_controls))
      ;[(quote quote) [(quote quote) (JSON.parse (JSON.stringify $root_controls))]])
   (console.log "*serialized_controls*: " *serialized_controls*)
   
   (log (dtext "Save Application State Results: ") (save_image))
   (log (dtext "Complete"))
   (= *system_repl* system_repl)))

(defun rehydrate_controls (container serialized_controls)
  (let
      ((control nil))
    (for_each (`serialized_control serialized_controls)
      (progn
       (= control (eval serialized_control))
       (when (and control.view
                  (not control.view.parentElement))
         (-> container
             `append control.view))
       (push $root_controls
             control)
       (when control.initialize
         (-> control `initialize))))))



(defun_sync to_indent (str)
    (join "" (for_each (c (range str.length))
                       " ")))

           
(defun_sync juno_format_handler (line tab base_indent)
   "")  ;; we let the control take care of this since it has better visibility to prior lines


(defun toggle_help_panel ()
   (progn
      (defvar ctl_holding (control_holding_tank))
      (try
         (cond
            (-> ctl_holding `has_control? (juno_documentation))
            (progn
               (place_control `right (juno_documentation)))
            (get_control_by_name "Juno Documentation")
            (hide_control (juno_documentation))
            else
            (progn
               (defvar ctl (juno_documentation))
               (place_control `right ctl)))
         (catch Error (e)
            (notify (+ "Unable to open help panel: " e.message))))))



(defun new_buffer (options)
  (let
      ((options (cond
                   (is_array? options)
                   { `path: options `mode: "juno"}
                   (is_object? options)
                   (+ (if options.filename
                          {}
                          { `mode: `juno })
                      options)  ;; if options has mode specified and we don't have a filename, it will override the default juno mode
                   (is_string? options)
                   { `path: [ options ] `mode: "juno" }
                   else
                   { `mode: "juno" }))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (symbol_data (if options.path
                        { `path: options.path `namespace: (or options.namespace (current_namespace)) }
                        (symbol_chooser "Select a symbol to edit" options.mode)))
       (target_ns symbol_data.namespace)
       (target_env nil))
      (console.log "new_buffer: for: " options target_ns symbol_data)
      
    (when target_ns
      (= target_env (-> Environment `get_namespace_handle symbol_data.namespace)))
    (when (and target_env (not (resolve_path symbol_data.path target_env.global_ctx.scope)))
       (console.log "new_buffer: target symbol doesn't exist: creating it")
       (set_path symbol_data.path target_env.global_ctx.scope ""))
    (when symbol_data.path
      (cond
         (is_top_control? target_container)
         (container_view_operation "split_right" (first (-> target_container `controls))
                                   (buffer_editor (last symbol_data.path) target_ns symbol_data.path options.mode options))
         else
         (swap_control target_container (buffer_editor (last symbol_data.path) target_ns symbol_data.path options.mode options )))))
  {
      `description: (+ "Opens a new editor, if possible, in the currently focused control.  If necessary, it may "
                       "split the view to the right for the new editor.  If no options are provided, the user "
                       "will be prompted for a symbol to edit.  Options can be: <br>"
                       "string: is considered a symbol name and the function will open or create the " 
                       "specified symbol in the current namespace global context.<br>"
                       "array: is considered a path to access, and if the path is present will open the path.  If not, "
                       "will attempt to create the final value in the path as a string for editing.<br>"
                       "object: if an object, the object can contain:<br>"
                       "  path: array: the path to the symbol to be edited.  If the final path segment doesn't exist "
                       "it will create it.<br>"
                       "  namespace: string: the namespace to use for accessing the provided path.<br>"
                       "  mode: the mode to open the editor in. The default mode is Juno.<br>")
      `tags: ["editor" "edit" "buffer" "control"]
      `usage: ["options:object?"]
  })

(defun new_top_level_frame ()
   (let
      ((ctl (empty_selection_control))
       (new_frame (control_container ctl { `root_frame: true } )))
      (push $root_controls
         new_frame)
      (if (> (length (-> (control_holding_tank) `controls)) 0)
          (swap_control ctl (last (-> (control_holding_tank) `controls))))))

(defun new_juno_repl (options)
   (let
      ((name (compute_name_for_control "Juno REPL"))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (remote_repl (if (is_string? options.remote_repl)
                        options.remote_repl)))
      (alert_on_error "REPL Error"
                      (cond
                         (is_top_control? target_container)
                         (container_view_operation "split_right" (first (-> target_container `controls)) (visual_repl { `name: name `remote_repl: remote_repl }))
                         else
                         (swap_control target_container (visual_repl { `name: name `remote_repl: remote_repl })))))
   {
       usage: ["options:?object"]
       description: (+ "Creates a new REPL in the current frame.  If provided with a `control_to_replace "
                       "in options, it will replace that control with the new REPL, with the replaced control "
                       "being put in the holding tank if the replaced control is allowed."
                       "If no target is provided, the function will split the top frame, replacing the " 
                       "currently focused control.")
       tags: [ "REPL" "create" "new" "control"]
   })
   

(defun wait_for_file_selection (create_mode) 
   (new Promise (fn (resolve reject)
                   (let
                       ((selection nil)
                        (target_control (or *last_focus* (default_focus)))
                        (control (file_tree_browser { 
                                                      create_mode: create_mode                          
                                                      on_select: (fn (stack)
                                                                    (progn
                                                                     (= selection (join "/" stack))
                                                                     (if (> stack.length 0)
                                                                       (progn
                                                                        (destroy_control control)))))
                                                                        
                                                     on_destroy: (fn (self)
                                                                    (progn
                                                                     (setTimeout (fn ()
                                                                                    (progn
                                                                                       (set_focus_to target_control)
                                                                                       (resolve selection))
                                                                                    20))
                                                                     true)) })))

                     (place_control `below control)
                     (set_focus_to control))))
   {
       `description: (+ "Opens a file tree browser for selection of a file.  Once the a " 
                        "file is chosen, or the selection is cancelled via escape, then either "
                        "the selected path is returned, or nil if cancelled or closed.")
       `usage:[]
       `tags: ["UI" "DOM" "file" "editor" "select" "open"]
   })



(defun edit_file (options)
   (let
      ((options (cond 
                   (and (is_object? options)
                        options.filename)
                   options
                   (and (is_object? options)
                        options.create_mode)
                   (+ {} 
                      options
                      { filename: (wait_for_file_selection true) })
                   else
                    (progn
                       {
                           filename: (wait_for_file_selection)
                       })))
       (symbol_path (cond
                       (is_array? options.path)
                       options.path
                       (is_string? options.filename)
                       (conj ["filesystem"] (split_by "/" options.filename))))
       (rval nil)
       (data_to_save (or options.initial_data ""))
       (acc []))
      (if (eq options.filename nil)
          (return nil))
      (assert (and symbol_path options.filename) "Invalid options to edit_file")
      
      ;; if we are given a create mode, make the shell of a file
      (if (and options.create_mode
               (> (length data_to_save) 0) )
         (try
            (progn
               (= rval (http/send_files "/save_file" (http/data_to_file options.filename data_to_save "text/plain")))
               (if (and rval
                        (== rval.rval "OK"))
                   (log "Created empty file: " options.filename)
                   (throw Error rval.message)))
            (catch Error (e)
               (progn
                  (alert_box (dtext "Unable to Create File")
                             (+ "" options.filename ": "
                                e.message))
                  (set_prop options
                             `filename
                             nil)))))
            
      (if (eq options.filename nil)
          (return nil))
      
      (if (and (starts_with? "filesystem" symbol_path)
               (eq nil (resolve_path symbol_path Environment.global_ctx.scope)))
          (progn
             (for_each (comp (chop symbol_path))
                (progn
                   (push acc comp)
                   (set_path acc Environment.global_ctx.scope {})))
             (push acc (last symbol_path))
             (set_path acc Environment.global_ctx.scope "")))
      (set_prop options
         `path
         symbol_path)
      (alert_on_error "File Open Error"
         (new_buffer options)))
   {
       `description: (+ "If provided an options object with a filename key and file path value, "
                        "the function will attempt to fetch and present that file for editing. "
                        "If an error is encountered, the error will be presented to the user "
                        "in a popup window and nil returned.  If called with no options, the "
                        "function will prompt the user to select a file via a file_tree_browser "
                        "control.  If create_mode is true in the options, then a new file "
                        "creation will be attempted and an editor returned for that.  If a "
                        "new file cannot be created, the user will be warned and nil will "
                        "be returned.")
       `usage: ["options:object"]
       `tags: ["DOM" "ui" "file" "edit" "open"]
   })
       


  
;; control behavior for unsaved controls in remote mode
;; if a control that is a buffer is to be saved to a file:
;;  1.  select a file to create
;;  2.  make a new editor with the contents of the old control as a proper file
;;  3.  swap with old control. 
;; if we do not have a host and are running locally, 
;;  1.  Establish an export_as name and save the file to that, but retain the existing editor

(defun handle_save_file (control options)
  (let
      ((fname (when control
                (or (and options.no_prompt
                         (is_string? control.options.filename)
                         control.options.filename)
                    (and options.remote
                       (wait_for_file_selection true))
                    (and (not options.remote)
                         (request_user_input (dtext "Download Buffer To Local File") 
                                             `text
                                             { `placeholder: (dtext "Name Of File")
                                                            `value: (aif (resolve_path [ `options `export_as ] control)
                                                                         it
                                                                         nil) })))))
       (rval nil))
      (declare (function wait_for_file_selection)
               (global wait_for_file_selection))
    
    (when (and (not (blank? fname))
               control
               control.get)
       (cond
          (and options.remote
               fname)
          (progn
             (alert_on_error "Cannot Create File"
                (progn
                   (= rval (http/send_files "/save_file" (http/data_to_file fname (or (-> control `get) ""))))
                   (if (and rval
                            (== rval.rval "OK"))
                       (progn
                          (= rval rval.results)
                          (notify "File saved")
                          (when (== rval.length 1)
                             ;; we made the file, now open a new buffer to it and swap with the old control
                             (edit_file { `filename: fname `control_to_replace: control })))
                       (progn
                          (log "ERROR on file creation: " rval)
                          (throw rval.message))))))
          fname
          (alert_on_error "Cannot Save Locally"
             (= rval (save_locally fname (-> control `get)
                                   "application/text"))
             (when rval
                (set_path_value control [ `options `export_as ] fname)
                (if control.display_context_message
                   (-> control `display_context_message (+ (dtext "Exported as: ") fname))))
             (log "Local save returned: " rval)))))
  {
   `usage: ["control:object" "options:?object"]
   `description: (+ "Given a control and an optional options object, will call the control's "
                    "`get method for the data value, and saves the value returned by the get "
                    "operation.  If the remote option is true and there is no options.filename "
                    "set, the user will be prompted with a chooser.  If the file is to be saved "
                    "locally, the user will be asked for a name to export it as, and the file "
                    "will be downloaded from the browser to the local environment and placed "
                    "in the default download folder of the browser.<br>"
                    "When a file is saved remotely, a new editor is established that is now "
                    "linked to the remote file and further saves for that buffer will be "
                    "defaulted to that filename.  If local, on subsequent saves the user will "
                    "be prompted to confirm the filename, or choose another."
                    "<br>Options are: <br>"
                    "remote:boolean - Attempt to save the file to the hosting server.<br>"
                    "no_prompt:boolean - If a filename is already established via options.filename "
                    "do not prompt for a new filename.")
   `tags: ["save" "file" "control"]
   })    

(defun set_key_binding (scope name desc)
  (let
      ((target (resolve_path [ scope ] *key_bindings*))
       (key_mode (get_operating_platform)))
    (progn
     (set_prop target
               name
               desc)
     (set_prop *key_bindings*.active
               (prop desc key_mode) 
               (prop desc `exec))))
  {
      `description: (+ "Given a scope for the keybinding, a command name key, and a description object, "
                       "establishes the binding in the *key_bindings* and in the environment as active. "
                       "<br>The description object should contain the following keys:<br>"
                       "description:text - A human readable description of what the key binding does.<br>"
                       "exec:fn - The function to execute when the key binding occurs. Some exec entries " 
                       "can be nil if the control has an internal function for the command name.<br>"
                       "mac:text - The key sequence to use on environments running on MacOS<br>"
                       "win:text - The key sequence to use when running on Windows or Linux (or non Mac environments)<br>")
      `usage: ["scope:string" "name:string" "desc:object"]
      `tags: ["keys" "bindings" "settings" "configuration" "config" ]
                       
  })
  
;; build a more sophisticated keyword_mapper
(defun_sync keyword_mapper (token)
   (progn
      (defvar details nil)
      (defvar rval
         (cond
            (contains? token *formatting_rules*.keywords)
            "keyword"
            (progn
               (setq details
                     (first (meta_for_symbol token true)))
               details.type)
            (lowercase details.type)
            else
            "identifier"))      
      rval))

;; and redirect the core/keyword_mapper


(use_quoted_initializer
 (defun_sync core/keyword_mapper (token)
   (user/keyword_mapper token)))

(defun gen_file_menu ()
   [["New..." [(if is_served?
                   ["File" (fn (e) (edit_file { `create_mode: true }))]
                   [])
               ["Juno REPL" (fn (e) (new_juno_repl))]
               (if is_served? 
                  ["Juno Remote REPL" (fn (e) (new_juno_repl { `remote_repl: (+ "ws://" window.location.host "/connect_repl") }))]
                  [])
               ["--" nil]
               ["Juno Lisp Editor" (fn (e) (new_buffer { `type: "juno" }))]
               ["Javascript Editor" (fn (e) (new_buffer { `type: "javascript" })) ]
               ["CSS Editor" (fn (e) (new_buffer { `type: "css" })) ]
               ["Text Editor" (fn (e) (new_buffer { `type: "text" })) ]
               ["JSON Editor" (fn (e) (new_buffer { `type: "json" }))]]]
    (if is_served?
       ["Open File" edit_file ]
       [])
    (if (resolve_path [ `get ] *last_focus*) 
        ["--" nil]
        [])
    (if (and is_served?
             *last_focus*
             (resolve_path [ `options `filename ] *last_focus*))
        [(+ (dtext "Close ") (get_editor_file_basename *last_focus*))
         (fn () (close_file *last_focus*)) ]
        [])
    (if (and *last_focus*
             is_served?
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [(+ (dtext "Save") " "
            (or (aif (resolve_path [ `options `filename ] *last_focus*)
                     (last (split_by "/" it)))
                (resolve_path [ `options `name ] *last_focus*)
                ""))
         (fn (e) (save_active_buffer))]
        [])
    (if (and *last_focus*
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [(+ (dtext "Save As")
            "...")
         [(if is_served?
              [(dtext "New Server File") (fn (e) (handle_save_file *last_focus* { `remote: true }))]
              [])
          [(dtext "Local File") (fn (e) (handle_save_file *last_focus*))]]]
        [])
    ["--" nil]
    ["Save Environment" (fn (e) (save_control_image)) ]
    (if is_served?
       ["Generate Starter Environment" build_starter_environment]
       [])
    ["Load File Into Environment" (fn (e) (-> resource_loader_button `click)) ]
    (if *global_themes*
       ["--" nil]
       [])
    (if *global_themes*
       ["Set Global Theme" (for_each (theme_name (keys *global_themes*))
                              [theme_name (fn ()
                                             (set_global_theme theme_name))])]
       [])])

(defun gen_layout_menu ()
   (let
      ((menu_acc [])
       (idx 0)
       (holding_tank (get_control_by_name "Holding Tank"))
       (control_to_place (fn ()
                            (if (and (prop *last_focus* `editor) ;; if we are in an editor, (but not repl) split it
                                     (not (== (prop *last_focus* `type) "visual_repl")))
                                (clone_editor_control *last_focus*) 
                                (empty_selection_control)))) ;; otherwise pull the last control out of storage
                             
       (root_ctls (new Set)))
      (conj
         ;[["New Frame" (fn ()
                          ;(new_top_level_frame))]]
         (reduce (pset (pairs (controls_by_parent)))
            (destructuring_bind (key controls)
               pset
               (console.log "key: " key "is the holding tank?" (== (get_control_by_name key) holding_tank) controls  )
               (cond
                  (== key "root")
                  (progn
                     (for_each (control controls)
                        (-> root_ctls `add control.name))
                     nil)
                  
                  (and (-> root_ctls `has key)
                       (not (== key "Holding Tank")))
                  [key (for_each (operation ["Split Right" "Split Bottom" "Show" "Hide"])
                          (progn
                             (defvar control (get_control_by_name key))
                             [(dtext operation)
                              (cond
                                 (and (> idx 1)
                                      (== operation "--"))
                                 nil
                                 (== operation "Split Right")
                                 (fn ()
                                    (place_control "right" (control_to_place)))
                                 (== operation "Split Bottom")
                                 (fn ()
                                    (place_control "below" (control_to_place)))
                                 (or (and (== operation "Show")
                                          (-> holding_tank `has_control? control))
                                     (and (== operation "Hide")
                                          (not (-> holding_tank `has_control? control)))
                                     (and (== operation "Close Control")
                                          (-> holding_tank `has_control? control)))
                                 (progn
                                    (when (-> holding_tank `has_control? control)
                                       (inc idx))
                                    (fn ()
                                       (container_view_operation (to_key operation)
                                                                 (get_control_by_name key)
                                                                 nil))))]))]
                  
                  (not (== key "Holding Tank"))
                  [key (for_each (operation ["Split Above" "Split Below" "Split Left" "Split Right"])
                          [(dtext operation) (fn ()
                                  (progn
                                     (console.log key "operation: " operation controls)
                                     (container_view_operation (to_key operation)
                                                               (get_control_by_name key)
                                                               (control_to_place))))])]))))))

(defun gen_controls_menu ()
  (progn
   (defvar holding_tank (get_control_by_name "Holding Tank"))                
   (defvar holding_tank_visible? (if (prop (control_position holding_tank) `parent)
                                     true
                                     false))
   (conj 
        (reduce (control (current_controls))
            (when (and control.on_focus
                       control.options.id)
              (defvar is_displayed? (and (not (== holding_tank control))
                                         (not (-> holding_tank `has_control? control))))
              [(or control.name "Untitled") 
               (reduce (operation ["Show" "Focus" "Hide" "--" "Close Control"])
                       (cond
                         (== control.name "Holding Tank")                              
                         (cond
                           (== operation "Focus")
                           [(dtext "Show")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `show))]
                           (and holding_tank_visible?
                                (== operation "Hide"))
                           [(dtext "Hide")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `hide))]
                           else
                           nil)
                         else
                         [(dtext operation)
                          (cond
                            (and (not is_displayed?)
                                 (== operation "Show"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (show_control it)))
                            (and is_displayed? (== operation "Focus"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (set_focus_to it)))
                            (and is_displayed? (== operation "--"))
                            nil
                            (and is_displayed? (== operation "Hide"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "hide" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id)))))
                            (== operation "Close Control")
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "destroy" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id))))))]))]))
        [[(dtext "Monitor Control Tree") 
          (fn ()
            (progn
             (monitor_control_tree)))  ]])))



(defun user/*initializer* ()
  (let
      ((header nil)       
       (scripts (-> (page_header) `querySelectorAll "script[id]"))                     
       (scratch_editor nil)
       (page_frame nil)
       (control nil)
       (key_mode (get_operating_platform))
       (repl_split nil))
                                                               
    (console.log "user/*initializer is running." )
    
    ;(defglobal main_menu_button (li  { `class: "juno-menu-header" }
     ;                                        (span { `class: "juno-menu-item" `style: "" } "File")))

    (defglobal resource_loader_button (file_picker_button "" load_files))    
    (set_style [["position" "absolute"]
                ["top" "-100px"]
                ["left" "-100px"]
                ["width" "1px"]
                ["height" "1px"]] resource_loader_button)
    
    (-> (get_by_id "body") `appendChild resource_loader_button)
       
    (defvalue $root_controls [])
    
    (set_prop window
       `onbeforeunload
       (function ()
          true))
    
    ;; the root container which controls are added to..
    (defglobal juno_container
      (div { `style: "height: inherit; width: inherit; position: relative; overflow:hidden;" }))

    
    (set_prop *env_config*.editor
       `extensions_to_mode
       {
         `js: `javascript
         `lisp: `juno
         })
    
    (attach_event_listener juno_container `click
                           (fn (e)
                             (progn
                              (defvar menu (get_by_id `cmenu))
                              (when menu (-> menu `remove)))))
    
    (set_prop *env_config*.export
	      `save_path
	      nil)
            
    (attach_event_listener juno_container
                           `focusin
                           (fn (e)
                             (process_focus_chain e)))

    (-> (get_by_id "body") `appendChild juno_container)

    
    (set_prop *formatting_rules*
       `allocating_forms {
                           `let: (fn (tree)
                                    (progn
                                       (flatten (list (resolve_multi_path [ 1 `* 0 ] tree)))))
                           `defun: (fn (tree)
                                      (progn
                                         (conj (list (resolve_path [ 1 ] tree))
                                               (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defun_sync: (fn (tree)
                                           (progn
                                              (conj (list (resolve_path [ 1 ] tree))
                                                    (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defmacro: (fn (tree)
                                         (progn
                                            (conj (list (resolve_path [ 1 ] tree))
                                                  (flatten (list (resolve_path [ 2 ] tree))))))
                           `function: (fn (tree)
                                         (flatten (list (resolve_path [ 1 ] tree) )))
                           `fn: (fn (tree)
                                   (flatten (list (resolve_path [ 1 ] tree) )))
                           `lambda: (fn (tree)
                                       (flatten (list (resolve_path [ 1 ] tree) )))
                           `destructuring_bind: (fn (tree)
                                                   (progn
                                                      (flatten (list (resolve_path [ 1 ] tree)))))
                           `defvar: (fn (tree)
                                        (flatten (list (prop tree 1))))
                           `for_each: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `for_with: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `reduce: (fn (tree)
                                       (list (resolve_path [ 1 0 ] tree)))
                           `reduce_sync: (fn (tree)
                                            (list (resolve_path [ 1 0 ] tree)))
                           `defglobal: (fn (tree)
                                          (list (prop tree 1)))
                           `defparameter: (fn (tree)
                                             (list (prop tree 1)))
                           
                           })
    
    
    ;; initialize or rehydrate the controls
    (if (== (length *serialized_controls*) 0)
      (progn       
       (console.log "initializing control surface")
       ;; take in the global default theme, but don't impact the setting for the sub themes
       (set_global_theme *env_config*.application.global_theme { `suppress_set_sub_theme: true `suppress_cascade: true })
       (defglobal $repl (visual_repl { `name: "Juno REPL" }))
       (= scratch_editor
          (buffer_editor "*scratch*" "user" [ `*scratch* ] `juno))

       (push *main_menu*   ;; using a wrapper function allows us to change the menu more dynamically
             [ "File" (fn ()
                         (gen_file_menu))])
                         
       
       (push *main_menu*            
             ["Controls" (fn ()
                        (gen_controls_menu))])
       (push *main_menu*
             ["Layout"
               (fn ()
                  (gen_layout_menu))])
       
       (push $root_controls
             (app_header [(app_menu [ `*main_menu* ])]
                         { `app_title: "Seedling" }))
       (setq page_frame ;; or surface which can be named in the upper right or middle
             (control_container nil {                                     
                                     `root_frame: true
                                     }))

       
       (set_prop *key_bindings*.global
                 "open_new_buffer" { win: "Command-Enter"
                                     mac: "Command-Enter"
                                     description: "New Juno Buffer"
                                     exec: (fn () (new_buffer { type: "juno" }))
                                    }
                 "save_file" { win: "Ctrl-S"
                               mac: "Command-S"
                               description: "Save File"
                               exec: (fn () (save_active_buffer))                              
                              }
                 "open_file" { win: "Ctrl-O"
                               mac: "Command-O"
                               description: "Open File"
                               exec: (fn () (edit_file))
                              }
                 "toggle_documentation" { win: "Shift-Escape"
                                        mac: "Shift-Escape"
                                        description: "Show Help Panel"
                                        exec: (fn () 
                                                 (toggle_help_panel)) }
                 "save_environment" { win: "Ctrl-Shift-S"
                                      mac: "Command-Shift-S"
                                      description: "Saves the current state of the application"
                                      exec: (fn () (save_control_image))
                                     } 
                 "next_hidden_control" { win: "Alt-Shift-Period"
                                         mac: "Command-Shift-Period"
                                         description: "Next Hidden Control"
                                         exec: (fn () (next_hidden_control))
                                         }
                 "prior_hidden_control" { win: "Alt-Shift-Comma"
                                          mac: "Command-Shift-Comma"
                                          description: "Prior Hidden Control"
                                          exec: (fn () (next_hidden_control true))
                                          }
                 "next_displayed_control" { win: "Alt-Period"
                                            mac: "Command-Period"
                                            description: "Next Displayed Control"
                                            exec: (fn () (next_displayed_control))
                                            }
                 "split_vertically" {
                                       win: "Ctrl-Backslash"
                                       mac: "Ctrl-Backslash"
                                       description: "Split the current control to the right"
                                       exec: (fn () (split_control `vertical))
                                      }
                 "split_horizontally" {
                                       win: "Alt-Backslash"
                                       mac: "Alt-Backslash"
                                       description: "Split the current control downward"
                                       exec: (fn () (split_control `horizontal))
                                      }
                  "close_panel" {
                                       win: "Alt-0"
                                       mac: "Alt-0"
                                       description: "Close the currently focused panel and put the control into the holding tank."
                                       exec: (fn () (hide_control *last_focus*))
                                      }
                  "close_control" {
                                       win: "Alt-D"
                                       mac: "Alt-D"
                                       description: "Close (Destroy) the control in the currently focused panel."
                                       exec: (fn () (hide_control *last_focus* true true))
                                      })
       ;; the execs are nil because the editor will use the key of the object to assign the correct
       ;; internal function
       
       (set_prop *key_bindings*.editor
                 "evaluate_selection" { win: "Shift-Enter"
                                        mac: "Shift-Enter"
                                        description: "Evaluate the current selected text"
                                        exec: nil
                                       }
                 "on_save" {  description: "Invokes save for the currently focused control"
                              win: "Ctrl-s"
                              mac: "Command-s"
                              exec: nil
                            }
                 "increase_font_size" {
                                       description: "Increase the font size of the current editor"
                                       win: "Ctrl-Shift-="
                                       mac: "Ctrl-Shift-="
                                       exec: nil
                                       }
                 "decrease_font_size" {
                                       description: "Decrease the font size of the current editor"
                                       win: "Ctrl-Shift--"
                                       mac: "Ctrl-Shift--"
                                       exec: nil
                                       }
                 "select_form_root" {
                                     description: "select_form_root"
                                     win: "Ctrl-Shift-Enter"
                                     mac: "Ctrl-Shift-Enter" 
                                     exec: nil }
                 "select_current_form" {
                                        description: "select_current_form"
                                        win: "Ctrl-Enter"
                                        mac: "Ctrl-Enter" 
                                        }
                 "evaluate_root_form" {
                                        description: "Evaluates the current form at the cursor position."
                                        win: "Alt-C"
                                        mac: "Alt-C"
                                        exec: nil
                                        }
                 "indent_current_row" {
                                       description: "Indent the row at the cursor position"
                                       win: "tab"
                                       mac: "tab"
                                       exec: nil
                                       }
                 "evaluate_selected_in_place" {
                                                description: "Evaluates and then replaces the selected text with the results of the evaluation."
                                                win: "Alt-R"
                                                mac: "Alt-R"
                                                exec: nil
                                                })
                 
       
       
                 
       (-> juno_container
           `append page_frame.view)

       (-> page_frame `initialize)
       
       (-> page_frame `set_content 0
           (split_view_vertical scratch_editor
                                $repl))
       
       (console.log "initializer: *last_top_frame*: " *last_top_frame*)
       
       (push $root_controls page_frame)
       ;; the holding tank contains the controls  that are still needed but not
       ;; presently displayed 
       (push $root_controls (control_holding_tank [] {}))
       
       (-> scratch_editor
           `set_evaluator_control $repl)
       
       (when (blank? (prop *env_config*.export `save_prefix))
         (set_prop *env_config*.export
                   `save_prefix
                   "seedling"))
       
       (-> juno_container
           `append page_frame.view)       
       (-> page_frame `initialize))
      (progn     
       (console.log "serialized controls: " *serialized_controls*)
       (rehydrate_controls juno_container *serialized_controls*)))
    
    (default_focus)
    ;; setup key bindings
    (set_prop *key_bindings*
              `active
              {})  ;; reset out and copy
    (for_each (desc (values (prop *key_bindings* `global)))
       (progn
        (set_prop *key_bindings*.active
                  (prop desc key_mode) 
                  (prop desc `exec))))

     (attach_event_listener juno_container
                           `click
                           (fn (e)
                             (handle_app_click_event e)))
    
    (attach_event_listener (first (get_by_tag `body))
                           `keydown
                           (function (e)
                             (progn                              
                              (defvar kcode (get_key_code e))
                              (when *log_key_events* (log "key_code:" kcode "->" (prop *key_bindings*.active kcode)))
                              ;(console.log "kcode is: " kcode)
                              (aif (prop *key_bindings*.active kcode)
                                   (progn
                                    (handle_event e)
                                    (it)))                              
                              )))

    
    
    
    (notify (+ "Hello " *namespace* ))
    true))






