;; TODO: SPLIT UP INTO SEPARATE FILES - TOO LARGE 
;; main browser initialization file - initializes the user browser environment
;; after the browser_workspace has setup the underlying environment

(defglobal main_menu_button nil) ;; placeholders 
(defglobal resource_loader_button nil)
(defglobal juno_container nil)
(defglobal repl_editor nil)
(defglobal *scratch* ";; *scratch* buffer\n\n")
(defvalue *key_bindings* {
                           repl:{}
                           editor:{}
                           global:{}
                           active: {}
                           })



(defvalue *main_menu* [])
(defvalue *serialized_controls* [])
(defparameter *tags_to_meta* {})
(defparameter core/$current_control nil)

;; the controls at the top level of the view
(defparameter core/$root_controls [])

(defparameter core/*system_repl* nil)

(console.log "browser_initializer running")

;; the global pointer to the control which has focus
;; nil if there are no focus points or values.

(defparameter core/is_served? (not (blank? (resolve_path [ `location `hostname ] window))))
(defparameter filesystem {})
(defparameter *last_focus* nil)
(defparameter *last_top_frame* nil)
(defparameter *app_menu_control* nil)
(defparameter *log_key_events* false)
(defparameter *document_focused* true)

(defparameter *whitespace_regexp* (new RegExp "\\\\s" `g))

(defparameter TokenIterator (function () true)) ;; filled in by the first editor

(defparameter
    *editor_themes*
    (reduce (included_lib (or *env_config*.included_libraries []))
        (aif (starts_with? "theme" included_lib)
            (second (split_by "-" (first (split_by "." included_lib)))))))

(set_prop *key_bindings*.repl          
          `history_next_entry { win: "Ctrl-Alt-n" mac: "Ctrl-Alt-n" }                                                               
          `history_prior_entry { win: "Ctrl-Alt-p" mac: "Ctrl-Alt-p" })

(create_css_entry "td.juno-obj-to-dom-key"
                  [["vertical-align" "top"]
                   ["color" "#881280"]
                   ["text-align" "right"]
                   ["font-weight" "bold"]
                   ["padding-right" "5px"]])





;;(create_css_entry "span.juno-value"
 ;;                 [["display" "inline-block"]])
   
;;(create_css_entry "li.juno-array-item"
;;                  [["list-style" "decimal"]])   
 
;; for determining keycodes
(defun get_operating_platform ()
    (if (contains? "Macintosh" navigator.userAgent)
        "mac"
        "win"))
      
(defun message (text)
  (div { `style: "border-left: 5px solid darkblue; padding: 5px;" } text))

(defun error_message (text)
  (div { `style: "border-left: 5px solid red; padding: 5px;" } text))

(defun log_error (message error_instance)
  (progn
   (log (error_message message))
   (console.error message)
   (when error_instance
     (when error_instance.messasge
       (error_message error_instance.message))
     (console.error error_instance))))
     


(defun_sync value_to_dom (val options _path)
  (let 
      ((classes "juno-value juno-type-")
       (options (or options {}))
       (elem nil)
       (_path (or _path [] ))
       (lpath (function () (join "~" _path))))
    (declare (function array_to_dom obj_to_dom function_to_dom)
             (global array_to_dom obj_to_dom function_to_dom))
    (= elem
       (cond 
         (is_array? val)
         (array_to_dom val options _path)
         (is_element? val)
         (progn
          (if val.parentElement
            (details
             (summary (+ {} (if options.namespace
                               { ns: options.namespace }
                               {})
                         { `lpath: (lpath) 
                           `class: (+ classes "view") 
                           `tabindex:0 }) 
                      (+ (sub_type val) " "))
             (span { `tabindex: 0 `style: "font-family: var(--main-app-font)" } "[ RENDERED ELEMENT ]"))
            val))
         (is_regex? val)
         (span (+ {} (if options.namespace
                         { `ns: options.namespace }
                         {})
                  { `lpath: (lpath) 
                    `tabindex: 0  
                    `class: (+ classes "regexp") }) 
               (-> val `toString))
         (is_string? val)
         (if (starts_with? "=:" val)
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0  `class: (+ classes "symbol") } )
                 (JSON.stringify val))
           (span (+ {} (if options.namespace { `ns: options.namespace } {}) 
                    { `lpath: (lpath) `tabindex: 0 `class: (+ classes "string") }) 
                 (JSON.stringify val)))
         
         (instanceof val Error)
         (details (summary { `class: (+ classes "error") } 
                           (span { `tabindex: 0 `class: (+ classes "error") `style: "margin-left: 5px; font-style: italic;" } val.name " " val.message))
          (if val.details  ;; there is a details rider on this error from the compiler, print it
              (value_to_dom val.details)
              (progn
                 (defvar tmp (pre { `tabindex: 0 `class: (+ classes "error") }))
                 (set_prop tmp `innerHTML (join "\n" (rest (split_by "\n" val.stack))))
                 tmp)))
         (is_function? val)
         (function_to_dom val options _path)
         (is_object? val)
         (obj_to_dom val options _path)          
         else
         (span  (+ {} (if options.namespace { `ns: options.namespace } {}) 
                   { `lpath: (lpath) `tabindex: 0 `class: (+ classes (lowercase (sub_type val))) }) 
               val)))
    elem))  

(defun_sync function_to_dom (val options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (lowercase (subtype val)))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } (-> val `toString)))))
    (assert (is_function? val))
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              (aif (fn_signature val)
                                   (if (== it.type "class")
                                     (+ "class " it.name)                                            
                                     (+ (if (== it.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " it.args)
                                        "))")))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem))
    
(defun_sync remote_function_to_dom (fdesc options _path)
  (let
      ((_path (or _path []))
       (options (or options {}))
       (detail_elem nil)
       (expanded false)
       (ftype (cond
                 (== fdesc.type "async")
                 "asyncfunction"
                 (== fdesc.type "sync")
                 "function"
                 else
                 fdesc.type))
       (expansion_elem nil)
       (lpath (function () (join "~" _path)))
       (classes (+"juno-value juno-type-" ftype))
       (render_function (function ()
                                  (pre  { `lpath: (lpath)  `tabindex: 0 `class: "juno-value juno-type-code" } fdesc.body))))
      (assert (is_object? fdesc) "remote_function_to_dom requires an object from fn_signature")
    (= detail_elem
       (details (summary { `tabindex: 0 `lpath: (lpath) `class: classes }
                        (span { `lpath: (lpath)
                               `class: classes
                               `style: "margin-left: 5px; font-style: italic;" }
                              
                                   (if (== ftype "class")
                                     (+ "class " fdesc.name)                                            
                                     (+ (if (== fdesc.type "async")
                                          "(fn ("                                            
                                          "(function (")
                                        (join " " fdesc.args)
                                        "))"))))
                (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))))
    
    (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_function))
                                     (= render_function nil))))
    detail_elem))
                   
       
       
       

(defun_sync array_to_dom (arr options _path)
    (let
        ((total_len arr.length)
         (_path (or _path []))
         (lpath (function () (join "~" _path)))
         (options (or options {}))
         (expanded false)
         (expansion_mode false)
         (detail_elem nil)
         (expansion_elem nil)
         (idx -1)
         (segment_size 10)
         (new_row_elem [])
         (render_array (function ()
                           (ol { `lpath: (lpath) `start: 0 `class: "juno-type-array" } 
                             (progn 
                                (for_each (val arr)
                                    (progn
                                        (inc idx)
                                        (li { `class: "juno-array-item" } 
                                            (value_to_dom val options (conj _path [idx])))))))))
         (row_elem []))
      (assert (is_array? arr))
      (when (or (> _path.length 2)
                (> arr.length (or options.expansion_length 30)))
        (= expansion_mode true))
            
      (= detail_elem 
         (details (+ { `class: "juno-type-array" }
                      (if (and (== _path.length 0)
                              (not expansion_mode))
                      { `open: true }
                      {}))
                 (summary { `lpath: (lpath)  `tabindex: 0 }  "Array [" total_len "] ")
                 (if expansion_mode
                     (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                     (render_array))))
     (when expansion_mode
         (attach_event_listener detail_elem
                                `toggle
                                (fn (e)
                                    (unless expanded
                                     (= expanded true)
                                     (-> expansion_elem `replaceWith (render_array))
                                     (= render_array nil)))))
     detail_elem))
           
(defun_sync obj_to_dom (obj options _path)
  (let
      ((options (or options {}))
       (classes "juno-value juno-type-")
       (detail_elem nil)
       (expanded false)
       (expansion_elem nil)
       (expansion_mode false)
       (get_pairs (if options.include_prototypes
                    pairs*
                    pairs))
       (render_table (function () 
                         (table
                            (tbody
                             (for_each (keyval (get_pairs obj))
                                       (destructuring_bind (key value)
                                                           keyval
                                                           (tr 
                                                            (td {  `class: "juno-obj-to-dom-key" } key)
                                                            (td { `class: "juno-obj-to-dom-value" } 
                                                                (value_to_dom value options (conj _path [ key ] ))))))))))
       (_path (or _path []))
       (lpath (function () (join "~" _path))))
    (declare (function get_pairs))
    (when (or (eq nil options.visited)
              (< _path.length 2))
           (set_prop options
                     `visited (new Set)))
    
    (if (-> options.visited `has obj)
        (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "[CIRCULAR]")
        (cond
          (== (length obj) 0)
          (span { `lpath: (lpath) `tabindex: 0 `class: "juno-value juno-obj-to-dom" } "Object {}")
          else
          (progn
           (-> options.visited `add obj)    
           (when (> _path.length 2)
             (= expansion_mode true))
           (= detail_elem 
              (details (+ {  `class: "juno-obj-to-dom" }
                          (if (== _path.length 0)
                            { `open: true }
                            {}))
                       (summary { `lpath: (lpath) `class: "juno-obj-to-dom" } obj.constructor.name)
                       (if expansion_mode
                         (= expansion_elem (span { `class: "juno-in-expansion" } (+ (dtext "Opening") "...")))
                         (render_table))))
           (when expansion_mode
             (attach_event_listener detail_elem
                                    `toggle
                                    (fn (e) 
                                      (unless expanded
                                              (= expanded true)
                                              (-> expansion_elem `replaceWith (render_table))
                                              (= render_table nil)))))
           detail_elem)))))




(defun copy_text_to_clipboard (text)
        (if text
           (let ((temp (textarea { `style: "position: absolute; top: -100px; left: -200px;"  } )))
               (-> (get_by_id "body") `append temp)
               (set_prop temp
                         `value
                         text)
               (-> temp `select)
               (-> temp `setSelectionRange 0 999999)
               (-> document `execCommand "copy")
               (-> temp `remove)
               true
            )
            false)
        { `usage: ["text:string"]
          `description:"Copies the provided textual argument to the system clipboard.  It cannot copy more complex types due to security limitations of browser sandboxed code."
          `tags: ["env" "copy" "clipboard" "ui"]
        } )


(defun_sync get_keybinding (category command)
   (aif (resolve_path [category command] *key_bindings*)
        it
        nil)
   {
       description: (+ "Given a category, such as `editor or `global and a command name, "
                        "returns the object with the defined key binding data or nil")
       usage: ["category:string" "command:string"]
       tags: ["key" "binding" "global" "sequence"]
    })

(defun_sync to_ace_keybinding (name keybinding_object fx_to_call)
   { name: name
     bindKey: { win: keybinding_object.win mac: keybinding_object.mac }
     exec: (or fx_to_call keybinding_object.exec) }
   {
       description: (+ "Given a Juno keybinding object with an exec function or an override "
                       "function as the third argument,  returns a keybinding object in a "
                       "format that can be used with the Ace Editor.")
       usage: ["name:string" "keybinding_object:object" "fx_to_call:function"]
       tags: ["key" "binding" "Ace" "editor" "command"]
   })

(defun_sync editor_key_bindings (editor)
   (if editor
      (resolve_path [`commands `commandKeyBinding ] editor)
      nil)
   {
       `description: "Returns current key bindings for the provided ACE editor object."
       `usage: ["editor:object"]
       `tags: ["bindings" "key" "controls"]
   })



(defun edit_mode_for_extension (ext)
   (or (resolve_path [ `editor `extensions_to_mode ext ] *env_config*)
       ext)
   {
       `description: (+ "Maps a file extension (with no period as a prefix) to an editor mode using the " 
                        "*env_config*~editor~extensions_to_mode lookup object. "
                        "If the file extension is found in the lookup, it will return the value, "
                        "otherwise it will return the provided extension back unchanged.")
       `usage: ["ext:string"]
       `tags: ["extension" "files" "type" "mode" "edit" "editor" ]
   })



(defun log (`& args)
   (progn
      (apply console.log args)
      (aif (-> Environment `get_global "*system_repl*" nil)
           (progn
              (-> it `log (apply div { `style: "display: flex;" } 
                           (for_each (val args)
                              (div { `style: "padding-right: 10px" } (value_to_dom val)))))))
      nil)
   {
       `description: "Logs arguments to the console and the current *system_repl* output.  Returns nil."
       `usage: ["arg0:*" "argN:*"]
       `tags: ["log" "console" "values" "display"]
   })

(defun log_error (error_message error_instance)
   (progn
      (console.error error_message error_instance)
      (aif (-> Environment `get_global "*system_repl*" nil)
           (progn
              (-> it `log_error error_message error_instance)))
      nil)
   {
       `description: "Logs an error message and the error instance to the console and the current *system_repl* output.  Returns nil."
       `usage: ["arg0:*" "argN:*"]
       `tags: ["log" "console" "values" "display"]
   })

(defun_sync clear_log ()
   (aif (and *last_focus*
             (prop *last_focus* `clear_output)
             *last_focus*)
        (progn
           (setTimeout (fn ()
                          (-> it `clear_output))
                       5)
           nil))
   {
     `description: "Clears the REPL that is currently focused."
     `usage: []
     `tags: ["log" "console" "clear" "output" "display"]
     })

(defun_sync decorative_usage (symbol_data namespace suppress_type)
  (let
      ((val (if (is_string? symbol_data)
                (cond
                   (starts_with? "(" symbol_data)
                   (-> symbol_data `substr 1)
                   (starts_with? "[" symbol_data)
                   (-> symbol_data `substr 1)
                   else
                   symbol_data)
                symbol_data.name))
       (show_type (function ()
                     (span { `style: "margin-left: 15px; font-style: italic" 
                             `class: (+ "juno-type-" (lowercase (or description.type "")))
                             }
                         (cond 
                            description.macro
                            "Macro"
                            description.type
                            (if suppress_type [] 
                                description.type)))))
       (metadata (if (and (is_object? symbol_data)
                          namespace
                          (not symbol_data.require_ns))
                     [list symbol_data]
                     (meta_for_symbol (trim val) true)))
       
       (description (if (is_object? symbol_data)
                        symbol_data
                        (if namespace
                           (first (reduce_sync (v metadata)
                                     (when (== v.namespace namespace)
                                        v)))
                           (first (or metadata [])))))
       (view nil)
       (is_symbol_binding (if (and description.require_ns
                                   (is_array? description.initializer)
                                   (== description.initializer.0 (quote pend_load)))
                              true
                              false))
       (rval nil))
     
      (when (and is_symbol_binding
                 (is_object? description))
       (set_prop description
          `usage
          (prop (first (reduce_sync (v metadata)
                                    (when (== v.namespace description.require_ns)
                                       v)))
                `usage)))
      (= rval
         (cond
            (is_array? description.usage)
            (div { `style: "display: inline-block"} "("
                 (flatten [(span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                           (for_each (arg description.usage)
                              (destructuring_bind (arg_name arg_type arg_needed)
                                 (split_by ":" arg)
                                 (= arg_type (or arg_type ""))
                                 (span { `class: (+ "juno-type-" (if (starts_with? "?" arg_type)
                                                                     (lowercase (or (chop_front arg_type) ""))
                                                                     (lowercase arg_type))
                                                    " juno-arg-name") `title: arg_type
                                                `style: (if (== arg_needed "required") "text-decoration: underline" "") } arg_name ":" arg_type)
                                 ))])
                 ")" (show_type))
            (is_string? description.fn_args)
            (div { `style: "display: inline-block"} "("
                 (span { `class: "juno-operator-name" `style: "font-weight: bold;" } val)
                 (for_each (arg_name (split_by " " (chop (rest description.fn_args))))
                    (span { `class: "juno-arg-name" } arg_name))
                 ")" (show_type))
            
            else
            nil))
      rval)
  {
    `usage: ["symbol:string|object" "namespace:?string" "suppress_type:?boolean"]
    `description: (+ "Given a symbol name as a string or an object metadata value (as from describe), returns a DOM element of the usage information.  "
                     "If the usage metadata is defined for the symbol it will use that, otherwise "
                     "if the symbol is a function and has fn_args defined, that content will be returned "
                     "in a DOM element.  Used by the editor to display usage information. ")
    `tags: [ `usage `editor `formatting `help `assist ]
    })

(defun unpack_description (description options)
   (let
      ((table_regex (new RegExp "(^[a-zA-Z\\(\\)0-9?_*\\-]+):([a-z\\(\\) A-Z0-9]+)[ ]*-[ ]*(.+)"))
       (header_regex (new RegExp "^([#]{1,6})[ ]+(.+)"))
       (desc (progn
                (defvar tmp (eval description))
                (if (and (is_object? tmp)
                         (not (is_array? tmp)))
                    tmp.description
                    tmp)))
       (rr (new RegExp "<-" `g))
       (subsections [])
       (segments (split_by "<br>" desc))
       (table_section nil)
       (header_section nil)
       (header_tag nil)
       (header_size_lookup [nil h1 h2 h3 h4 h5 h6]) ;; pos 0 will never be found, hence nil
       (current_seg 0)
       (total_segs (length segments)))
       (for_each (seg segments)
          (progn
             (inc current_seg)
             (when (is_string? seg)
                (= seg (replace rr "\\u{279C}"  seg))
                (map (fn (comp i)
                        (if (== 1 (% i 2))
                            (push subsections
                               (if options.wrap_fn
                                  (try
                                     (progn
                                        (-> options `wrap_fn comp current_seg total_segs))
                                     (catch Error (e)
                                        (pre "Error in wrap_fn call 1: " e.message)))
                                  (pre comp)))
                            (push subsections
                               (if options.wrap_fn
                                  (try
                                     (-> options `wrap_fn comp current_seg total_segs)
                                     (catch Error (e)
                                        (p "Error in wrap_fn call 2: " e.message)))
                                  (progn
                                     (cond
                                        (progn
                                           (= table_section (scan_str table_regex comp))
                                           (> (length table_section) 0))
                                        (for_each (tbl_row table_section)
                                           (div { `style: "display: flex; align-items: flex-end; flex-wrap: wrap; gap: 16px; border-bottom: 1px solid var(--main-accent-line);" }
                                                (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.1)
                                                (div { `style: "align-self: flex-start; font-weight: bold; padding: 5px; flex-grow: 0; flex-basis: 100px;" } tbl_row.2)
                                                (div { `style: "align-self: flex-start; padding: 5px; flex-grow: 1; flex-basis: 400px;"} tbl_row.3)))
                                        (== comp "---")
                                        (progn
                                           (hr))
                                        (progn
                                           (= header_section (scan_str header_regex comp))
                                           (> (length header_section) 0))
                                        (progn
                                           (= header_section (first header_section)) ;; pull it out of the array to make it easier to work with
                                           (= header_tag (or (prop header_size_lookup (length (prop header_section 1)))
                                                             "h5"))
                                           (header_tag 
                                            (prop header_section `2)))
                                              
                                        else
                                        (p comp)))))))
                     (split_by "```" seg)))))
       (div { `class: "juno-editable" }
          subsections))
    {
       `usage: ["description:text"]
       `description: "Given a marked up description text, builds the output format for the browser."
       `tags: [ `usage `help `assist `formatted `markup ]
   })

(defun format_help (meta_obj options)
   (let
      ((is_symbol_binding (if (and meta_obj.require_ns
                                   (is_array? meta_obj.initializer)
                                   (== meta_obj.initializer.0 (quote pend_load)))
                              true
                              false))
       (imported_usage (first (if is_symbol_binding
                                  (reduce  (v (meta_for_symbol meta_obj.name true))
                                     (when (== v.namespace meta_obj.require_ns)
                                        v))
                                  [])))
       (elem nil))
      
     
      (when imported_usage
         (set_prop meta_obj
            `usage
            (prop imported_usage `usage))
         (set_prop meta_obj
            `tags
            (prop imported_usage `tags)))
            
            
      (= elem
         (div { `command: (+ "" meta_obj.name)  `style: "width: calc(100% - 20px); padding-bottom: 5px;" }
              (h3 (span { `style: "color: var(--namespace-color); " } meta_obj.namespace ) "/" meta_obj.name
                  (if meta_obj.macro
                     (span { `style: "float: right; margin-right: 20px; " } "Macro")
                     (span { `title: "Type" `style: "float: right" `class: (+ "juno-type-" (lowercase meta_obj.type)) } meta_obj.type)))
              (hr { `class: "LightHR" })
              (cond
                 (and (contains? `unction meta_obj.type)
                      meta_obj.usage)
                 [(h4 "Usage")
                  (decorative_usage meta_obj meta_obj.namespace true)]
                 (contains? `unction meta_obj.type)
                 [(h4 "Arguments")
                  meta_obj.fn_args]
                 else
                 [])
              (if (or meta_obj.description
                      is_symbol_binding)
                  [(h4 "Description")
                   (if is_symbol_binding
                      (p
                         (div { } "This is a bound symbol into " (span { `style: "color: var(--namespace-color); " }  meta_obj.require_ns)
                              " to " (join " " meta_obj.requires) ".  For more information refer to the core/use_symbols macro and to " (join " " meta_obj.requires) ".")
                         (br))
                      (unpack_description meta_obj.description))]
                  [])
              
              (if meta_obj.tags
                 [(h4 "Tags")
                  (for_each (`sym meta_obj.tags)
                     (span { `tabindex: 0 `class: "juno-tag" `style: "" } sym ))]
                 [])
              (if meta_obj.requires
                 [(h4 "Requires")
                  (for_each (`sym (sort meta_obj.requires))
                     (span { `tabindex: 0 `class: (+ "juno-type-" (lowercase (or (prop (describe sym) `type) "")) " juno-requires") } sym ))]
                 [])
              ))
      (cond
         (is_function? options.on_click)
         (attach_event_listener elem
            `click
            (fn (e)
               (-> options `on_click e))))
      elem)
   {
     `description: (+ "Render object definitions to html.  Given a path "
                      "to Environment.definitions, or the output of the "
                      "describe function, returns a DOM element.  If options "
                      "is provided, the if the value for the key 'on_click' "
                      "is a function, when the produced element is clicked "
                      "the click event will be passed to the on_click function "
                      "provided.")
     `usage: ["meta_obj:object" "options:?object"]
     `tags: [`help `? `usage `info `man `manual ]
     })


(defmacro ? (symname)
   `(let
       ((results (describe ,#(if (starts_with? "=:" symname)
                                 (-> symname `substr 2)
                                 symname) true)))
       (for_each (`meta_obj (or results []))
          (format_help meta_obj)
          ))
   {
       `description: "Given a quoted symbol as an argument, the function returns a formatted manual page for the provided symbol."
       `usage: ["name:quoted_symbol"]
       `tags:["help" "assistance" "man" "usage" "info"]
   })

(defun_sync find_last_paren (editor pos)
   (try
      (let
         ((pos  (or pos (-> editor `getCursorPosition)))
          (stream (indirect_new TokenIterator editor.session pos.row pos.column))
          (done false)
          (depth 0)
          (t nil)
          (comps nil)
          (calc_depth (function (val)
                          (progn
                            (= comps (split_by "" val))
                            (while (> comps.length 0)
                              (progn
                                 (= t (pop comps))          
                               (cond 
                                  (or (== t ")")
                                      (== t "]"))
                                  (inc depth)
                                  (or (== t "(")
                                      (== t "["))
                                  (dec depth)))))))
          (start nil)
          (token nil))
         (while (and (not done)
                     (not start))
            (progn
               (= token (-> stream `getCurrentToken))
               (when (== token.type "keyword")
                  (calc_depth token.value))
               (if (eq token nil)
                   (progn
                      (= done true)
                      (break))
                   (if (and (== token.type "keyword")
                            (or (== token.value.0 "(")
                                (== token.value.0 "[")))
                      (progn
                         (if (<= depth 0)
                             (progn
                                (= start { row: (-> stream `getCurrentTokenRow)
                                               column: (-> stream `getCurrentTokenColumn) })
                                (= done true)
                                (break))))))
                       
               (= token (-> stream `stepBackward))))
         (when start
            (-> editor.session `getBracketRange start)))
      (catch Error (e)
         (progn
            (console.error e)
            nil))))



(defun current_controls (no_subcontrols from_control)
   (let
      ((ctls (uniq (flatten (control_tree (if from_control
                                              [ from_control ]
                                              $root_controls)))))
       (ids nil))
      (if no_subcontrols
         (progn
            (= ids (new Set))
            (reduce (ctl ctls)
               (progn
                  (unless (-> ids `has ctl.options.id)
                     (-> ids `add ctl.options.id)
                     ctl))))
         ctls))
   {
     `usage: ["no_subcontrols:?boolean" "from_control:?control"]
     `description: (+ "Returns an array of all controls in the control tree.  "
                      "If no_subcontrols is true, then composite type contols "
                      "made up of multiple controls will be included in the "
                      "results only as the main control.  Otherwise, the "
                      "subcontrols will also be returned. If from_control "
                      "is a provided control, only controls that are "
                      "contained by that root control will be returned.")
     `tags: ["controls" "active" "tree" "ui"]
     })

(defun all_editor_controls ()
   (reduce (ctl (current_controls))
      (when ctl.editor
         ctl))
   {
       `description: "Returns an array all editor controls in the control_tree."
       `usage: []
       `tags: ["controls" "editors" "active" "ui"]
   })

(defun cascade_resize (top_control)
  (control_tree (or top_control $root_controls)
                (fn (control)
                  (if control.resize
                    (-> control `resize))))
  {
      `usage: ["top_control:?object"]
      `description: (+ "This function invokes the resize methodFor every control " 
                       "in the control tree or from the provided starting control "
                       "and it's child controls.")
      `tags: ["controls" "active" "resize" "ui"]
  })
    

(defun set_global_theme (theme_name options)
   (if (prop *global_themes* theme_name)
       (let
          ((head_elem (-> document `querySelector "head"))
           (existing (get_by_id "juno-css-theme")))
          (if existing
               (-> existing `remove))
          (-> head_elem `append
              (style { `id: "juno-css-theme" `type: "text/css" }
               (prop *global_themes* theme_name)) )
          (set_path [ `application `global_theme ] *env_config* theme_name)
          (when (and (not options.suppress_set_sub_theme)
                     (contains? theme_name *editor_themes*))
             (set_path [ `editor `default_theme ] *env_config* theme_name))
          ;; unless we are told not to, set any controls to the theme
          (unless options.suppress_cascade
              (for_each (control (current_controls))
                        (when (is_function? control.set_theme)
                          (-> control `set_theme theme_name))))
          true)
       (throw ReferenceError "Invalid theme name provided"))
   { `description: (+ "Sets the global theme to the named theme.  Global themes "
                      "values are looked for in *global_themes*.  If a key is found "
                      "in that object, the theme is installed, and the *env_config* "
                      "value is updated to reflect this choice.  Additionally, if an "
                      "editor theme is found with the same name, the default editor "
                      "theme is set as well.  Editor themes are found in the global "
                      "*editor_themes*. <br><br>"
                      "Options are as follows:<br>"
                      "suppress_set_sub_theme:boolean:false:If true, individual control "
                      "themes such as the editor theme setting will not be set as part "
                      "the global theme and will retain their existing settings and "
                      "defaults.<br>"
                      "suppress_cascade:boolean:false:If this value is true, the application "
                      "theme will change, but controls will not be told about it and will "
                      "retain their current settings as they are instantiated with.")
     `tags: ["themes" "environment" "color" "settings"]
     `usage: ["theme_name:string" "options:object"] })

(defun get_control_by_id (id)
  (let
      ((controls (current_controls))
       (ctrl nil))
    (for_each (`control controls)
              (when (== id (and control.options control.options.id))
                (= ctrl control)
                (break)))
    ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the control with the given identifier, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "id" "find" ]
  })

(defun get_control_by_name (name)
  (let
      ((controls (current_controls))
       (ctrl nil))
      (when (is_string? name)
         (for_each (`control controls)
            (progn
               (when (== name control.name)
                  (= ctrl control)
                  (break)))))
      ctrl)
  {
      usage: ["id:string"]
      description: (+ "Returns the first control with the given name, " 
                      "or nil if not found.")
      tags: [ "ui" "controls" "name" "find" ]
  })



(defun select_controls (predicate_func)
  (let
      ((controls (current_controls))
       (acc [])
       (ctrl nil))
    (for_each (`control controls)
        (progn
         (when (predicate_func control)
           (push acc control))))
    acc)
  {
   `description: (+ "Given a predicate function (a function that takes a "
                    "single value and returns a true or false value), tests "
                    "control by passing the control to the predicate and if "
                    "the function returns true, the control will be "
                    "returned in the array.  The function will return all "
                    "controls which tested true.")
   `usage: ["predicate_function:function"]
   `tags: ["selection" "filter" "controls"]
   })



(defun render_control_tree (controls)
   (let
      ((cell_style "border: 1px dashed var(--main-accent-line-hover);")
       (sub_style "border-right: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);")
       (parent_style "border-left: 1px dashed var(--main-accent-line-hover); border-bottom: 1px dashed var(--main-accent-line-hover);border-top: 1px dashed var(--main-accent-line-hover);"))
      (table { `style: "vertical-align: top; margin: 5px; box-shadow: 1px 1px 4px 1px #00000060; width: calc(100% - 20px);" }
        (cond
           (is_array? controls)
           (for_each (ctl controls)
              (tr { `style: (+ "vertical-align: top;" cell_style) }
               (if (is_function? ctl.controls)
                   [ (td { `control_id: ctl.options.id 
                            style: (+ ""
                                      parent_style
                                      (if (== ctl *last_focus*)
                                          "font-weight: bold; background: var(--control-focused);"
                                          ""))
                            } (or ctl.name (+ "/" ctl.type)))
                    (td { `style: sub_style } (render_control_tree (-> ctl `controls)))]
                   (td { `control_id: ctl.options.id `colspan: 2 
                         `style: (+ "" cell_style (if (== ctl *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) } 
                         (or ctl.name (+ "/" ctl.type))))))
           (is_object? controls)
           (tr { `style: "" }
            (if (is_function? controls.controls)
                [(td { `style: (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "") } controls.name)
                 (td { `control_id: controls.options.id `style: cell_style } (render_control_tree (-> controls `controls)))]
                (td { `control_id: controls.options.id `colspan: 2 
                      `style: (+ "" cell_style (if (== controls *last_focus*) "font-weight: bold; background: var(--control-focused);" "")) }  
                      (or controls.name (+ "/" controls.type))))))))
   {
     usage: ["controls:array"]
     description: (+ "Renders the given controls and their children as a HTML/table " 
                     "representing the hierarchy and the control positions in the tree.")
     tags: [ "ui" "controls" "DOM" "structure" "tree" ]
     })

(defun holding_tank_controls ()
  (aif (get_control_by_name "Holding Tank")
       (-> it `controls)
       [])
  {
      usage: []
      description: "Returns an array of all controls currently stored in the control holding tank."
      tags: ["ui" "controls" "holding" "tank"]
  })

(defun replace_control (target_control new_control)
  (let
      ((tmp (new Object))
       (replaced_keys (new Set)))
    (assert (is_object? target_control) "Invalid object provided for old_control")
    (assert (is_object? new_control) "Invalid object provided for new_control")
    ;; first transfer the old object contents to the new location
    (for_each (k (keys target_control))
              (set_prop tmp
                        k
                        (prop target_control k)))
    
    ;; now tmp has the target_control scope references
    ;; replace the target_control with new values
    (for_each (k (keys new_control))
              (progn
               (-> replaced_keys `add k)
               (set_prop target_control
                         k
                         (prop new_control k))))
    
    ;; now remove any keys that are not in the set from the target_control
    (for_each (k (keys target_control))
              (if (not (-> replaced_keys `has k))
                (remove_prop target_control k)))
    
    ;; the objects should be swapped at this point
    ;; return tmp as the old control
    tmp))



(defun control_for_dom_element (elem)
    (let
        ((control_id nil))
       (assert (is_element? elem) "Invalid element provided")
       (= control_id (-> elem `getAttribute "control_id"))
       (aif (and control_id ;; we have a control_id, so get the control
                 (get_control_by_id control_id))
            it ;; and return it
           (cond
             (eq nil elem.parentElement)
             nil ;; at top (or cannot go up further) so return nil
              
              ;; no control found and we have a parent_element
             else
             (control_for_dom_element elem.parentElement)))))



(defun control_position (control)
    (let
       ((parent_view nil)
        (parent_control_position 0)
        (parent_control nil))
    (assert control.view "target_container isn't a control container")
    (= parent_view control.view.parentElement)
    (when parent_view
        (= parent_control (control_for_dom_element parent_view))
        (when (and parent_control
                   parent_control.controls)
           (map (fn (parental_sub_control idx)
                    (when (== parental_sub_control control)
                        (= parent_control_position idx)))
                (-> parent_control `controls))))
    (aif (and (eq parent_control nil)
              (get_control_by_name "Holding Tank"))
         (if (-> it `has_control? control)
           (= parent_control it)))
      
    {
        `child: control
        `parent: parent_control
        `child_position: parent_control_position
    }))

(defun get_container_for_control (control)
    (let
        ((existing_container nil)
         (pos nil)
         (next_parent nil)
         ;; controls should be in one of these container types
         (valid_containers ["split_view_horizontal" "split_view_vertical" "control_container" ]))
      (assert (and (is_object? control)
                   control.view)
              "Invalid control received")
      (= pos (control_position control))
      
    ;; is the child control (the control passed) a container?
      (cond 
        (and pos.child
           (contains? pos.child.type valid_containers))
        (= existing_container control)
        (and pos.parent
            (contains? pos.parent.type valid_containers))
        (= existing_container pos.parent)
        pos.parent
        (progn
          (while (and pos.parent
                      (not existing_container))
             (progn
                 (= pos (control_position pos.parent))
                 (console.log "pos is now: " pos)
                 (if (and pos.parent
                          (contains? pos.parent.type valid_containers))
                     (= existing_container pos.parent))))))
       
      existing_container))

(defun_sync is_control? (val)
  (and (is_object? val) val.type val.view val.toJSON true)
  {
    usage: "val:object"
    description: "Predicate function which returns true if the provided object tests to be a control."
    tags: ["controls" "ui" "control"]
  })

(defun_sync is_top_control? (control)
  (if (is_control? control)
    (contains? control $root_controls)
    false))

(defun top_frame (control)
  (let
      ((parent nil))
    (declare (local parent))    ;; parent is a global object - shouldn't need to declare this since it has technically already been shadowed
   (assert (is_control? control) "Invalid control provided")
   (= parent (control_position control))
   (while parent.parent
       (= parent (control_position parent.parent)))
   parent.child))

(defun parents_for_control (control)
  (if (and (is_control? control)
           control.view.parentElement)
       (progn
          (defvar parent (control_for_dom_element control.view.parentElement))
          (if (is_top_control? parent)
              [parent]
              (reduce (ctl (flatten [parent (parents_for_control parent)]))
                 ctl)))
       [nil])
  {
   `description: "Given a control, returns an array containing the parent chain, with the last being the top control."
   `usage: ["control:object"]
   `tags: [ `control `controls `position `heirarchy `path]
   })


(defun set_focus_to (target_control _controls)
  (let
      ((focused_list (query_all ".juno-focused"))
       (controls (or _controls
                     (reduce (c (current_controls))                        
                        (when c.on_focus                          
                          c)))))
    
    (for_each (control controls)
                 (when (and (or (eq nil target_control)
                                (not (== target_control control)))
                            (is_function? control.on_blur))
                   (-> control `on_blur)))
    
    ;; remove any focus class markers
    (when (> focused_list.length 0)
      (= focused_list (map (fn (v) v) focused_list))       
      (apply remove_class "juno-focused" focused_list))
    (for_each (control controls)
                 (when (and (or (eq nil target_control)
                                (not (== target_control control)))
                            (is_function? control.on_blur))
                   (-> control `on_blur)))
    (when (not (== *last_focus* target_control))
      (when (and *last_focus*
                 (prop *last_focus* `menu_items))
        (-> *app_menu_control* `remove_menu (or (prop *last_focus* `name)
                                                "Control"))))
      
    (if target_control
      (progn
       (if target_control.on_focus 
          (-> target_control `on_focus)
          (focus_to target_control.view))
       (setq *last_focus* target_control)
       (setq core/$current_control *last_focus*)
       (setq *last_top_frame* (top_frame target_control))
       (when target_control.menu_items
         (-> *app_menu_control* `add_menu [ (or target_control.name
                                                "Control")
                                           target_control.menu_items 
                                           "control_menu"])))
      (progn
       ;(setq *last_focus* nil)
       ))))

(defun default_focus ()
  (let
      ((found_control nil))
    (control_tree $root_controls
                  (fn (control)
                      (when (and (not found_control)
                                 (is_function? control.on_focus))
                        (= found_control control))))
    (if found_control
      (progn
        (set_focus_to found_control)
        found_control)
      nil)))

(defun commands_button (id)
  (button { `control_id: id
            `class: "juno-command-button"
            `title: (dtext "Commands") } "⋯"))

(defun focus_to_editor (ctl)
   (progn
      (cond
          (and ctl (prop ctl `editor))
          (focus_to (prop ctl `editor))
          (prop *last_focus* `editor)
          (focus_to (prop *last_focus* `editor)))
      *last_focus*))



(defun swap_control (target_control new_control)
  (let
      ((tmp (new Object))
       (position_details_target nil)
       (position_details_new nil)
       (holding_tank (get_control_by_name "Holding Tank"))
       (replaced_keys (new Set)))
    (assert (is_control? target_control) "Invalid control provided for old_control")
    (assert (is_control? new_control) "Invalid control provided for new_control")
    
    (if (== target_control new_control)
        (progn
           (set_focus_to target_control)
           (if target_control.editor
              (focus_to target_control.editor)))
        (progn
           ;; get their position in the tree
           (= position_details_target (control_position target_control))
           (= position_details_new (control_position new_control))
           (console.log "swap_control: target: " target_control "new: " new_control)))
    
    (cond
        (== target_control new_control)
        nil ;; do nothing 
        
        (== position_details_target.parent holding_tank)   ;; target is in the holding tank so take the old control out and replace with new
        (progn
            (-> holding_tank `remove_control position_details_target.child)
            (-> holding_tank `add_control position_details_new.child)
            (if position_details_new.parent.set_content ;; add the targeted control to the new_controls old location (if not in holding_tank)
              (progn
               (-> position_details_new.parent `set_content position_details_new.child_position position_details_target.child)
               (cascade_resize)
               (set_focus_to position_details_target.child)
               (focus_to_editor))
                position_details_target.child))

        (and (== position_details_target.child holding_tank)   ;; target IS the holding tank so replace the holding tank with the new value and hide the holding tank
             position_details_target.parent.set_content)
        (progn
         (-> holding_tank `remove_control position_details_new.child) ;; ensure the child is removed from the holding tank (if in it)
         (-> position_details_target.parent `set_content position_details_target.child_position position_details_new.child)         
         (-> holding_tank `hide)
         (cascade_resize)
         (set_focus_to position_details_new.child))
        
        (and position_details_target.parent.set_content
             position_details_new.parent.set_content)  ;; controls are both in the tree somewhere so swap their positions
        (progn
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> position_details_new.parent `set_content 
                                             position_details_new.child_position 
                                             position_details_target.child)
            (set_focus_to position_details_new.child)
            (cascade_resize)
            (focus_to_editor)
            target_control)
        
        (and (== position_details_new.child holding_tank)
             (is_function? position_details_target.parent.set_content))
        (progn
         (-> holding_tank `add_control position_details_target.child)
         (set_prop holding_tank.options
                   `in_tree
                   true) ;; otherwise the holding tank, if not initialized, will not mount correctly and place itself somewhere in the dom after initialization
         (-> position_details_target.parent `set_content position_details_target.child_position
             position_details_new.child)
         (-> holding_tank `show)
         (cascade_resize)
         (set_focus_to position_details_new.child)
         (focus_to_editor)
         target_control)
         
        (and (== position_details_new.parent holding_tank)   ;; new control is in the holding tank 
             (is_function? position_details_target.parent.set_content))
        (progn
            (debug)
            (-> holding_tank `remove_control position_details_new.child.options.id)
            (-> holding_tank `add_control position_details_target.child)
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (set_focus_to position_details_new.child)
            (cascade_resize)
            (focus_to_editor)
            position_details_new.child)
        
        (and (eq nil position_details_new.parent)  ;; this is a new control without a parent
             position_details_target.parent.set_content)
        (progn  ;; add to the holding tank the target and put the new in the targets old place..
            (-> position_details_target.parent `set_content 
                                                position_details_target.child_position 
                                                position_details_new.child)
            (-> holding_tank `add_control position_details_target.child)
            (cascade_resize)
            (set_focus_to position_details_new.child)
            (focus_to_editor))
        (and (-> holding_tank `has_control? position_details_new.child)
             position_details_target.parent.set_content)
        (progn
           (-> position_details_target.parent `set_content
              position_details_target.child_position
              position_details_new.child)
           ;; remove from the holding tank
           (-> holding_tank `remove_control position_details_new.child)
           (-> holding_tank `add_control position_details_target.child)
           (cascade_resize)
           (set_focus_to position_details_new.child)
           (focus_to_editor))
        
        else
        (progn
            (notify "Unhandled swap condition - see console")
            (log "unhandled swap position: target: " position_details_target "new: " position_details_new)
            nil))))                               




;; container view operation
;; given a command performs an operation on the control structure

;; definitions
;; target_control - the control that is to be impacted with a change 
;; target_control_container - the container of the target_control
;; new_control - an optional new control to be inserted into the control tree
;; options - options for the given command

(defun container_view_operation (command target_control new_control options)
   (let
      ((orig_target target_control)
       (target_control (control_for_dom_element target_control.view)) ;; ensure we have the correct handle to the impaced control since this could be a sub_control given to us
       (position_details nil) ;; the structure that holds the position details of the operation
       (holding_tank (get_control_by_name "Holding Tank"))
       (tmpview nil)
       (confirmed true)
       (new_container nil)
       (split_view_parent nil))
      
      (assert target_control "Unable to find the target control")
      (assert holding_tank "Unable to find the holding tank")
      (= position_details (control_position target_control))
      (console.log "container_view_operation: original_target: " orig_target)
      (console.log "container_view_operation: computed_target: " target_control)
      (console.log "container_view_operation: command: " command "position_details: " position_details "new_control: " new_control)
      (when (and (== position_details.parent nil) ;; top level control
                 (not (== position_details.child holding_tank))
                 (is_top_control? position_details.child))
         (= target_control (first (-> position_details.child `controls)))
         (= position_details (control_position target_control))
         (console.log "container_view_operation: shifted down: target_control was a top control: " position_details))
      ;(log "container_view_operation: options.suppress_destroy_confirm: " options.suppress_destroy_confirm  (and *last_focus* (prop *last_focus* `options)))
      (unless options.suppress_destroy_confirm
         (if (and (== command "destroy")
                  (is_function? target_control.on_destroy))
             (= confirmed (-> target_control `on_destroy))))
      (console.log "container_view_operation: confirmed: " confirmed)
      (if confirmed
          ;; if the parent structure is nil in position_details, then we are at the root
          (cond
             (or (== command "hide")
                 (and (not (resolve_path [ `options `locked ] target_control))
                      (== command "destroy")))
             (progn
                (cond
                   ;; the control is not a root control if it has a parent
                   (or (== position_details.parent.type "split_view_vertical")
                       (== position_details.parent.type "split_view_horizontal"))
                   (progn
                      ;; grab the child control to keep displaying, ie. not the one in the child_position
                      (set_prop position_details
                         `child_to_display
                         (if (== position_details.child_position 0)
                             (second (-> position_details.parent `controls))
                             (first (-> position_details.parent `controls))))
                      
                      ;; we need to know the split views parent since we are going to remove the split view
                      ;; and hoist the remaining child to display into the parent structure in place of the
                      ;; split_view - not an even swap because the existing split_view is retired
                      
                      (= split_view_parent (control_position position_details.parent))
                      (assert split_view_parent.parent.set_content "Unable to set the content of the split view parent")
                      (console.log "container_view_operation: split_view_parent: " split_view_parent)
                      (console.log "container_view_operation: position_details: " position_details)
                      (when (not options.dry_run)
                         ;; elevate the child to keep to the targeted_control container's position in it's parent
                         (-> split_view_parent.parent `set_content split_view_parent.child_position position_details.child_to_display)
                         
                         ;; set the child to hide in non displayed controls
                         (cond
                            (and (== command "hide")
                                 (not (== target_control holding_tank)))
                            (-> holding_tank
                                `add_control
                                target_control)
                            (and (not (resolve_path [ `options `locked ] target_control))
                                 (== command "destroy")
                                 (is_function? target_control.destroy))
                            (progn
                               (when *app_menu_control*
                                  (-> *app_menu_control* `remove_menu target_control.options.name))
                               (-> target_control `destroy)
                               (when (== *last_focus* target_control)
                                  (== *last_focus* nil)))))
                      (cascade_resize)
                      (default_focus)
                      true)
                   (and (not (resolve_path [ `options `locked ] target_control))
                        (== position_details.parent holding_tank)
                        (== command "destroy"))
                   (progn
                      (-> holding_tank `remove_control position_details.child.options.id)
                      (when *app_menu_control*
                         (-> *app_menu_control* `remove_menu position_details.child.options.name))
                      (if (is_function? position_details.child.destroy)
                        (-> position_details.child `destroy))
                      (when (== *last_focus* target_control)
                         (== *last_focus* nil))
                      (default_focus))
                   (and (== command "destroy")
                        (resolve_path [ `options `locked ] target_control))
                   (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                   (== command "destroy")   ;; single control under the root frame so swap if possible with the holding tank
                   (progn
                       (if (> (length (holding_tank_controls)) 0)
                           (progn
                              (set_path_value target_control [`options `temporary ] target_control) ;; mark as temporary
                              (swap_control target_control (last (holding_tank_controls))))
                           (progn
                              (notify "Cannot hide a single control - try replacing."))))
                   else
                   (progn
                      (if (> (length (holding_tank_controls)) 0)
                          (swap_control target_control (last (holding_tank_controls)))
                          (notify "Cannot hide a single control - try replacing"))
                      position_details)))
             
             (== command "replace")
             (progn
                (log "container_view_operation: command is replace: swap: " target_control new_control)
                (swap_control target_control new_control)
                true)
             
             (== command "split_left")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (== command "split_right")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_vertical position_details.child new_control  (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                
                (cascade_resize)
                true)
             (== command "split_above")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal new_control position_details.child (or options { `ratio: 0.3 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (== command "split_below")
             (progn
                (assert (is_control? new_control) "Invalid control provided for the replacement control")
                (assert (not (== position_details.parent holding_tank)) "Cannot split the holding tank")
                (= tmpview (div { } "Placeholder"))
                ;; get it off the dom
                (-> position_details.child.view `replaceWith
                    tmpview)
                (= new_container (split_view_horizontal  position_details.child new_control (or options { `ratio: 0.7 } )))
                (-> holding_tank `remove_control new_control)
                (-> position_details.parent `set_content position_details.child_position new_container)
                (cascade_resize)
                true)
             (resolve_path [ `options `locked ] target_control)
             (progn
                (notify (+ "" (or (resolve_path [ `options `name ] target_control)
                                  "The control")
                           " is set to locked and cannot be removed."))
                false)
             ;; otherwise we don't know how to process the command 
             else
             (progn
                (notify (+ "container_view_operation: unknown command: " command))
                position_details))
          (progn
             false))))
  
 
(defmacro place_control(placement `& control_def)
   (let
      ((where_map {
                   `top: "split_above"
                   `below: "split_below"
                   `left: "split_left"
                   `right: "split_right"
                   `replace: "replace"  })
       (where (aif (prop where_map placement)
                   it
                   "split_right")))
       
  `(let
      ((target_container  (control_position (top_frame (default_focus)))))
     (when target_container.child 
       (= target_container (first (-> target_container.child `controls)))
       (container_view_operation ,#where target_container
                                   ,@control_def)))))
              
(defun show_control (control_to_show)
  (let
      ((control_to_show (cond 
                          (and (is_string? control_to_show)
                               (get_control_by_name control_to_show))
                          (get_control_by_name control_to_show)
                          (and (is_string? control_to_show)
                               (get_control_by_id control_to_show))
                          (get_control_by_id control_to_show)
                          (is_control? control_to_show)
                          control_to_show))
       (target_control (if *last_focus*
                         *last_focus*
                           nil)))
    (cond 
       (and target_control control_to_show)
       (progn
          (swap_control target_control control_to_show)
          (set_focus_to control_to_show)
          (sleep 0.1)
          
          true)
       control_to_show
       (progn
          (place_control "right" control_to_show)
          (sleep 0.1)
          (set_focus_to control_to_show)
          true)
       else
       (progn 
          (notify (dtext "The requested control to display wasn't found."))
          false)))
  {
    `description: (+ "Provided a control name, id or the control object itself, "
                     "will display the control, adjusting the layout as needed. "
                     "By default the control referenced by *last_focus* is swapped with the new one, "
                     "but if that isn't possible, the view is split and the new control is placed to "
                     "the right.<br>"
                     "Returns true if successful, otherwise a notification is "
                     "delivered that the control is not found, and false is "
                     "returned.")
    `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
    `usage: ["target:string|object"]
    })



(defun hide_control (target destroy? no_mod_layout)
   (let
      ((control (cond 
                   (and (is_string? target)
                        (get_control_by_name target))
                   (get_control_by_name target)
                   (and (is_string? target)
                        (get_control_by_id target))
                   (get_control_by_id target)
                   (is_control? target)
                   target))
       (confirmed true)
       (swap_target (and no_mod_layout
                         (last (-> (control_holding_tank) `controls)))))
      (declare (function control_holding_tank)
               (global control_holding_tank))
      (cond 
         (and control swap_target)
         (progn
            (if (and destroy?
                     (is_function? control.on_destroy))
                (= confirmed (-> control `on_destroy)))
            (sleep 0.01)
            (when confirmed   
               (swap_control control swap_target)
               (if destroy?
                  (container_view_operation "destroy" control nil { `suppress_destroy_confirm: true } ))))
         control
          (progn
             (container_view_operation (if destroy? "destroy" "hide") control nil)
             true)
          else
          (progn
             (notify "Control not found")
             false)))
   {
       `description: (+ "Provided a control name, id or the control object itself, "
                        "will hide the control, adjusting the layout as needed. "
                        "Returns true if successful, otherwise a notification is "
                        "delivered that the control is not found, and false is "
                        "returned.  If destroy? is true, the control is removed from "
                        "the tree and destroyed.")
       `tags: ["controls" "control" "display" "hiding" "holding_tank" "ui"]
       `usage: ["target:string|object" "destroy?:?boolean"]
   })

(defun destroy_control (target)
  (hide_control target true)
  {
   `description: (+ "Provided a control name, id or the control object itself, "
                    "will hide the control, adjusting the layout as needed. "
                    "Returns true if successful, otherwise a notification is "
                    "delivered that the control is not found, and false is "
                    "returned. ")
   `tags: ["controls" "control" "display" "destroy" "remove" "holding_tank" "ui"]
   `usage: ["target:string|object"]
   })



(defun process_focus_chain (e originator_container)
   (progn
      (handle_event e)
      (when e.srcElement
         (let
            ((target_control nil)
             (elem e.srcElement)
             (controls (reduce (c (current_controls))
                          (when c.on_focus
                             c)))
             (focused_list (query_all ".juno-focused")))
            
            ;; check for if we have found the target control:
            ;; if the current element is equal to the controls view...
            ;; we found it, otherwise move up to the parent node...
            ;; and check again...until we can't
            (while elem
               (progn
                  (for_each (control controls)
                     (when (== elem control.view)
                        (= target_control control)
                        (break)))
                  (when target_control
                     (break))
                  (= elem elem.parentElement)))
            
            (set_focus_to target_control controls)))))


(defun menu_tree (items options _path)
  (let
      ((options (either options { `flat_index: 0 }))
       (path (either _path []))
       (disappear_timer nil)
       (min_width (+ "min-width: " (or options.min_width 300) "px;"))
       (id (either options.id "cmenu"))  
       (active_menu_item nil)
       (menu_element
        (fn (idx text `& args)
          (let
              ((view (li {  `class: "pure-list-item"                                         
                          `style: (+ (if (> args.length 0)
                                         "position: relative;"
                                         "")
                                     min_width)
                          }
                         (a { 
                             `idx: idx
                             `path: (join "~" (conj path idx))
                             `href: "#"
                             `class: "pure-menu-link" 
                             `style: ""
                             }
                            (if (== args.length 0)
                              (span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                              [(span { `path: (join "~" (conj path idx)) `class: "juno-menu-text" } text)
                               (span { `class: "juno-menu-submenu" } "❯")]))
                         args))
               (timer nil))
            (if (== args.length 0)
              (progn
                 (attach_event_listener view
                    `mouseenter
                    (fn (e)
                       (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)))
                 view)
              (progn
               (attach_event_listener view
                  `mouseenter
                  (fn (e)
                     (do
                        (= active_menu_item e.srcElement)
                        (apply remove_class "juno-menu-selected" e.srcElement.parentElement.children)
                        (add_class "juno-menu-selected" e.srcElement)
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (set_style [["display" "inline-block" ]
                                                      ["position" "absolute"]
                                                      ["top" "0px"]
                                                      ["left" (+ "" e.srcElement.offsetWidth "px") ]]
                                                     view.children.1))
                                       150)))))
               (attach_event_listener view
                  `mouseleave
                  (fn (e)
                     (do
                        (when timer
                           (clearTimeout timer))
                        (= timer
                           (setTimeout (fn ()
                                          (progn
                                             (set_style [["display" "none"]] view.children.1)))
                                       150)))))
               
               view)))))
       (view nil))
    
    (= view
       (ul (+ {}
              { `class: (if (> path.length 0)
                             "juno-menu pure-menu-list"
                             "pure-menu-list")
                `style: (+ (if (> path.length 0)
                             "display: none;"
                             "display: inline-block;")
                           "position: relative;")  }
              (if (== path.length 0)
                { `id: id }
                {}))
                     
           (map (fn (item idx)
                  (let
                      ((text (if (is_function? item.0)
                               (item.0)
                               item.0)))
                    (set_prop options
                              `flat_index
                              (+ 1 options.flat_index))                     
                    (cond
                      (is_array? item.1)
                      (menu_element options.flat_index text (menu_tree item.1 options (conj path [ idx 1])))
                      (and (== text "--") (eq nil item.1))
                      (hr { `class: "LightHR" })
                      (is_function? item.1)
                      (menu_element idx text)
                      else
                      [])))
                items)))
    (if (> path.length 0)      
       view
      (progn
       (attach_event_listener view
                              `click
                              (fn (e)
                                (let
                                    ((path (-> e.srcElement `getAttribute "path"))
                                     (idx (-> e.srcElement `getAttribute "idx"))
                                     (target (if path
                                               (resolve_path (split_by "~" path) items))))
                                  (handle_event e)
                                  (-> view `remove)
                                  (aif (get_by_id "cmenu")
                                       (-> it `remove))
                                  (when (is_function? options.on_select)
                                     (options.on_select path))
                                  (sleep 0.01) ;; disconnect and move to back of the event loop for the call
                                  (when (and target
                                             (is_function? target.1))
                                    (try
                                       (target.1 e target.2)
                                       (catch Error (e)
                                          (log_error "Base Catch: " e.message)
                                          (log_error e))))
                                  )))
       (setTimeout (fn ()
                     (progn
                      (attach_event_listener view
                                             `mouseleave
                                             (function (e)
                                                       (progn
                                                        (when disappear_timer
                                                          (clearTimeout disappear_timer))
                                                        (= disappear_timer (setTimeout (fn ()
                                                                                         (progn
                                                                                          (-> view `remove)
                                                                                          (when (is_function? options.on_select)
                                                                                             (options.on_select nil))
                                                                                          (= disappear_timer nil)))
                                                                                       (or *env_config*.application.menu_timeout
                                                                                           options.menu_timeout
                                                                                           2500))))))
                      (attach_event_listener view
                                             `mouseenter
                                             (function (e)
                                                       (when disappear_timer
                                                         (clearTimeout disappear_timer)
                                                         (= disappear_timer nil))))))
                   700) ;; delay a little before adding the timeout so we don't accidentally hover over it 
       {
        `view: view
        `toJSON: (function ()
                           `(menu_tree ,#items ,#options))
        `type: "menu_tree"
        }))))

(defun make_menu (for_element menu_items options)
  (let
      ((menu_items menu_items)
       (for_element for_element)
       (pos nil)
       (mtree nil)
       (disappear_timer nil)       
                                        
       (view nil))
    (aif (get_by_id "cmenu")
         (-> it `remove))
    (setq mtree
          (menu_tree menu_items options))
    (setq view
          mtree.view)
    (add_class "juno-menu" view)
    (when for_element
      (setq pos
            (-> for_element `getBoundingClientRect))
      (set_style [["top" (+ "" (Math.max 0 pos.bottom) "px") ]
                  ["left" (+ "" (Math.max pos.left 0) "px") ]
                  ["position" "absolute"]
                  ["z-index" "30"]]
                  view)
      (console.log "make_menu: found element at: " pos))
    
     
    (if options.do_not_attach
      view
      (progn       
       (-> (get_by_id "body") `appendChild view)
       (console.log "appended view" view)
       view))))

(defun_sync get_key_code (e)
  (let
      ((k []))
      (when e.metaKey
         (push k "Command"))
      (when e.ctrlKey
         (push k "Ctrl"))
      (when e.altKey
         (push k "Alt"))
    (when e.shiftKey
      (push k "Shift"))
    (unless (contains? e.key [ "Shift" "Control" "Alt" "Meta" ])      
            ;; normalize to the printed key characters on the keyboard
            (push k (cond 
                       (starts_with? "Key" e.code)
                       (-> e.code `substr 3)
                       (starts_with? "Digit" e.code)
                       (-> e.code `substr 5)
                       else
                       e.code)))
    (if (> k.length 0)
        (join "-" k)
        e.code))
  {
      `description: (+ "Given a key event, returns a text description of the set of characters in a normalized order "
                       "for matching keybinding handlers.  If no modifier keys (Control, Alt, Command, or Shift), returns "
                       "the direct code value from the key event.  If a modifier or modifiers are also pressed, will "
                       "return a composite value with the following order of priority, where if a key with a lower "
                       "prority is pressed, it will appear first in the returned value:<br>"
                       "Command - 0 <br>"
                       "Ctrl - 1<br>"
                       "Alt - 2<br>"
                       "Shift - 3 <br>"
                       "For example if the user is pressing both the Shift and the Control key and the 'A' key, the "
                       "returned value will be \"Ctrl-Shift-A\" as the priority value for 'Control' is 1 and the "
                       "priority value for 'Shift' is 3.  Note that whenever a modifier is pressed, the value of "
                       "the pressed key will be always uppercase as the descriptor.")
      `usage: ["event:Event"]
      `tags: [ "key" "events" "binding" "keycodes" "keyboard"]
  })

(defun request_user_input (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((user_input (if options.input
                                    options.input
                                    (input (+ {`tabindex: 0 `type: (or type "text") `style: "width: calc(100% - 15px)" }
                                              (if options.placeholder
                                                 { placeholder: options.placeholder }
                                                 {})
                                              (if options.title
                                                 { `title: options.title }
                                                 {})
                                              (if options.class
                                                 { `class: options.class } 
                                                 {})
                                              (if options.value
                                                 { `value: options.value } 
                                                 {})
                                                ))))
                      (completed false)
                      (ok_button (button { `class: "juno-primary" `style: "float:right" } (dtext "OK")))
                      (cancel_button (button { `class: "juno-secondary" }  (dtext "Cancel")))
                      (dwin (dialog { `style: "height: min-content; width: min-content;"   }
                                    (div { `class: "juno-instructions" } prompt)
                                    (br)
                                    user_input
                                    (br)
                                    (div { `class: "pure-button-group juno-control-group" `style: "margin-top: 10px;" `role: "group" }
                                         (if options.no_cancel_button
                                            []
                                            cancel_button)
                                         ok_button)))
                      (rval nil)
                      (get_current_value (fn ()
                                            (cond
                                               user_input.value
                                               user_input.value
                                               (getAttribute user_input `value)
                                               (getAttribute user_input `value)
                                               options.no_cancel_button
                                               true)))
                      (return_value (fn ()
                                       (progn
                                          (= rval (get_current_value))
                                          (cond
                                             (is_function? options.validator)
                                             (if (-> options `validator rval)      
                                                 (clean_up rval) ;; if the validator returns true, ok remove the dialog box
                                                 nil) ;; wait for an appropriate inpit
                                              else
                                              (clean_up rval)))))
                                                     
                                                     
                      (clean_up (fn (val)
                                    (when (not completed)
                                        (= completed true)
                                        (resolve val)
                                        (-> dwin `remove)))))
                     
                     
                     
                     (if (is_function? options.validator)
                         (set_disabled ok_button))
                     
                     (attach_event_listener ok_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (return_value))))
                     ;; don't immediately react to keyup so as not to immediately react
                     ;; in certain scenarios
                     (setTimeout (fn ()
                                    (attach_event_listener user_input
                                       `keyup
                                       (fn (e)
                                          (cond
                                             (== e.key "Enter")
                                             (progn
                                                (handle_event e)
                                                (return_value))
                                             (is_function? options.validator)
                                             (progn
                                                (if (-> options `validator (get_current_value))
                                                    (set_enabled ok_button)
                                                    (set_disabled ok_button)))))))
                                 
                                 250);
                     (attach_event_listener cancel_button
                        `click
                        (fn (e)
                           (progn
                              (handle_event e)
                              (clean_up nil))))
                     
                     (attach_event_listener dwin
                        `close
                        (fn (e)
                           (clean_up nil)))
                     
                     (when options.default_value
                        (set_prop user_input
                           `value
                           options.default_value))
                     
                     (-> juno_container
                        `appendChild dwin)
                     ;(setTimeout (fn ()
                     ;              (place_caret_at_end user_input))
                     ;          50)
                     (when (is_function? dwin.showModal)
                        (-> dwin `showModal)
                        (-> user_input `select)))))
  {
    description: (+ "This function will pause the flow of execution until the user makes a choice, "
                    "selection or input and then will return the result of the user action.  If the "
                    "user presses cancel or presses the Escape key, a return value of nil will be "
                    "returned.<br>"
                    "By default, the user is presented with a text input box in which text can "
                    "entered.  Once the user presses return or clicks the OK button, the value is "
                    "returned.  However, if the `type option is given as an input, the input will "
                    "be of the specified type, such as \"number\" or \"date\". <br>"
                    "Additionally options can be provided for more control over the interaction "
                    "and value presentation.  If provided with a key of \"input\" and an input element, "
                    "the provided input element will be displayed and the final value returned.  "
                    "Other elements can be provided and as long as they either set a value property "
                    "or value attribute on the element, that value will be returned.<br>"
                    "Values can be validated by passing a \"validator\" function.  Upon the user "
                    "pressing a key, the validation function will be called with the "
                    "current value and if the validation function returns true, OK will be enabled, "
                    "or if the user pressed enter, the validated value will be returned to the caller, "
                    "otherwise the OK button will be disabled and the dialog box will not close. "
                    "Note that the validator function is responsible for any prompting of "
                    "or additional notices of how to comply with the validation rules.  This "
                    "could be done by providing a more complicated element structure as an input that is in "
                    "the closure of the validator whose values could be updated.")
    usage: ["prompt:string" "type:string" "options:object"]
    tags: ["user" "input" "request" "collect" "wait" "ui" "DOM"]
    })
                 
(defun select_control_by_name (prompt options)
   (let
      ((no_sub_controls (not options.include_sub_controls))
       (controls (current_controls no_sub_controls))
       (prompt (or prompt (dtext "Please Select a Control")))
       (names  (reduce (ctl controls)
                 (let
                    ((name (resolve_path [ `options `name ] ctl)))
                    (progn
                       (cond
                          options.include_specials
                          name
                          (is_function? options.include_if_true)
                          (if (-> options `include_if_true ctl)
                              name
                              nil)
                          (and (not (== ctl (control_holding_tank)))
                               (not (starts_with? "split_view" ctl.type))
                               (not (resolve_path [ `options `root_frame ] ctl)))
                          name)))))
                          
                          
       (name_elems (map (fn (name) 
                           (option name))
                        names))
       
       (dlist_id (gen_id "controls"))
       (dlist (apply datalist { `id: dlist_id } name_elems))
       (selector (input { `list: dlist_id `style: "width: calc(100% - 10px);"} ))
       (value nil))
      (try
         (progn
           (-> (get_by_id `body) `append dlist)
           (= value (request_user_input prompt 
                                        `text 
                                        { input: selector
                                          validator: (fn (v)
                                                        (contains? v names))
                                        })))
         (catch Error (e)
            (progn
               (log "select_control_by_name: error in request_user_input operation: " e.message))))
      (log "selected: " value)
      (-> dlist `remove)
      (get_control_by_name value))
   {
       `description: (+ "Given a prompt and an optional options object, presents a dialog that displays the "
                        "given prompt and allows the user to select or type a control name.  A drop down "
                        "allows the user to select the closest matched to the typed in text.<br>"
                        "The selected control is returned, or nil if the user presses cancel or presses Escape.<br>"
                        "By default no split_views, sub controls (controls contained by other controls) " 
                        "or root controls are displayed, only content controls.<br>"
                        "Options:<br>"
                        "include_specials:boolean - By default false, all controls will be presented.<br>"
                        "include_sub_controls - Include the sub controls.<br>"
                        "include_if_true:function - Predicate function which is passed a control, and if the function "
                        "returns true the control will be included in the selection, otherwise it will not be.")
       `usage: ["prompt:text" "options:object"]
       `tags: ["controls" "select" "choose" "user" "UI" "DOM" ]
   })  


(defun alert_box (message detail)
   (request_user_input (or message "No message provided!") 
                       nil 
                       { `input: (if detail 
                                     (div detail)
                                     (span {})) 
                         `no_cancel_button: true })
   {
     `usage:[ "message:text" "detail:text|Element"]
     `description: "Creates a modal type popup dialog box which pauses the current execution flow until the OK button is clicked. The return value is undefined."
     `tags: ["alert" "popup" "modal" "box" "warn" "ui" "DOM" ]
   })
     
(defmacro alert_on_error (error_title `& forms)
   `(try
       (progn
          ,@forms)
       (catch Error (e)
          (progn
             (alert_box ,#(or error_title (dtext "Error on Operation"))
                         e.message)
             nil)))
   {
       `usage: ["error_title:text" "forms:*"]
       `description: (+ "All provided forms will be wrapped in a progn and the last value of the provided forms returned.  " 
                        "Any uncaught errors in the provided forms will be caught by this macro abd the provided " 
                        "error_title, and exception message presented to the user for acknowledgement.  On a caught error "
                        "nil will be returned to the calling code.")
       `tags: ["alert" "popup" "catch" "errors" "ui" "DOM"]
   })

;; -- Control Events --------
;; event routing is handled by a map that combines the command value and the source value.
;; if an array is found at the value, it will call each function in the array in sequence
;; as each function in the array is an event handler

(defparameter *event_routes* 
   { }
   {
     `description: (+ "The event routing object which contains routes used by dispatch_event. "
                      "<br>Use register_event_handler to add event handlers and " 
                      "remove_event_handler remove handlers. ")
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes"  ]
     })

(defun_sync compute_handler_key (source command)
   (+ (if (is_string? source)
                           (+ "" source )
                           "")
                       (if (is_string? command)
                           (+ "+" command)
                           ""))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given a source and a command, computes the event_handler lookup key for control events."
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" ]
   })


(defun register_event_handler (source command function_id handler_function)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (exists false))
      (if (blank? handler_key)
          (throw TypeError "register_event_handler: one or more of source and command must be specified as strings"))
      (if (blank? function_id)
          (throw TypeError "register_event_handler: function_id is required"))
      (if (blank? handler_function)
          (throw TypeError "register_event_handler: handler_function is required"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
         (set_prop *event_routes*
            handler_key
            (list { `fid: function_id f: handler_function }))
         (progn
            (for_each (handler handlers)
               (if (== handler.fid function_id)
                   (setq exists true)))
            (if exists
               (throw ReferenceError "register_event_handler: function already registered for key")
               (push handlers { fid: function_id f: handler_function }))))
      handler_key)
   {
       `usage: ["source:string" "command:string" "handler_function_id:string" "handler_function:function"]
       `description: (+ "Given a control source id, command string, and a handler function, adds the function to the "
                        "event handler.<br>Either the source id or the command string can be nil, but not both. " 
                        "Omitting one of the specifiers broadens the scope of the events that will be routed "
                        "to the handler function.  For example, if the source id is omitted, but the command "
                        "string is provided, all events that match the command string, regardless of source "
                        "will be routed to the function.  Conversly, if the command string is omitted, but the "
                        "source is provided, all events from that source will trigger the handler function to "
                        "to be called.  Note that there can be multiple handler functions registered for the same "
                        "source id/command combination.<br>"
                        "If the function is determined to be already registered using equality, then "
                        "the function will throw a ReferenceError that the same function is already registered.  "
                        "Returns the computed handler_key.<br>The handler function should be defined in the "
                        "form of (fn (event_obj)), where event_obj will be the event object as transmitted " 
                        "from the source.<br>")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })
    
(defun remove_event_handler (source command handler_function_id)
   (let
      ((handler_key (compute_handler_key source command))
       (handlers nil)
       (idx nil))
      (if (blank? handler_key)
          (throw TypeError "remove_event_handler: one or more of source and command must be specified as strings"))
      (setq handlers
         (prop *event_routes* handler_key))
      (if (eq nil handlers)
          true
          (progn
             (if (eq nil handler_function_id) ;; if no handler_function_id is provided, remove all handlers for the events
                 (progn
                    (set_prop *event_routes*
                       handler_key
                       [])
                    true)
                 (progn
                    (map (fn (f i)
                            (if (== f.fid handler_function_id)
                                (setq idx i)))
                         handlers)
                    (when idx
                       (-> handlers `splice idx 1))
                    (if idx
                       true
                       false))))))
   {
       `usage: ["source:string" "command:string" "handler_function_id:string"]
       `description: (+ "Given a control source id, command string, and a handler function, removes the function to the "
                        "event handler.  If the function isn't found in the event handlers using equality, then "
                        "the function will return false, otherwise if successful it will return true.  If no function is "
                        "is provided, then all handlers for the key will be removed.")
       `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
   })

(defun get_control_event_handlers (source command)
   (prop *event_routes* (compute_handler_key source command))
   {
       `usage: ["source:string" "command:string"]
       `description: "Given an source string and command string, returns an array of all specific matching handlers for the given values."
       `tags: ["events" "controls" "handlers" "dispatch" "routes" ]
   })  
  
(defun remove_all_handlers_for_source (source)
   (let
      ((routes nil))
      (when (not (is_string? source))
         (throw TypeError "source must be a string"))
      (setq routes
         (reduce (key (keys *event_routes*))
            (when (starts_with? (+ "" source "+") key)
               key)))
      (apply delete_prop *event_routes* routes)
      (length routes))
   {
       usage: ["source:string"]
       description: (+ "Given a source identifier, removes all routes associated with that source. "
                       "Returns the number of routes removed.")
       tags: ["events" "controls" "routes" "handlers" "source" "dispatch"]
   })

(defun_sync dispatch_event(event_obj)
   (let
      ((handler_key (compute_handler_key event_obj.source event_obj.command))
       (handlers (when handler_key  ;; check for handlers that match specifically, match only source events, and match only command events
                    (flatten (conj (or (prop *event_routes* handler_key) [])
                                   (or (prop *event_routes* (compute_handler_key event_obj.source nil)) [])
                                   (or (prop *event_routes* (compute_handler_key nil event_obj.command)) []))))))
                    
      (when (> __VERBOSITY__ 0)
         (log "dispatch_event: " event_obj handler_key handlers))
      (if (> handlers.length 0)
           (for_each (handler handlers)
              (try
                 (progn 
                    (-> handler `f event_obj))
                 (catch Error (e)
                    (log (+ "Error on event handler for route: " handler_key ": " e.message))))))
      (when event_obj.error
         (progn
            (log "dispatch_event: error: " event_obj)
            (alert_box (+ ""
                          (from_key event_obj.command)
                          (if event_obj.args.1.message
                             (+ ": " event_obj.args.1.message)
                             ""))
                       (aif (and event_obj.args.0
                                event_obj.args.0.options.filename)
                           (+ "The file " it " was unable to be saved.")))))
      true)
   {
     `usage: ["event_obj:object"]
     `description: (+ "Dispatches received event objects from controls using the *event_routes* table.  Routes are "
                      "determined via compute_handler_key.  If a route key resolves to an array, each handler function in "
                      "the found array in the *event_routes* table is called in sequence.  Routes are collected by first " 
                      "looking for handlers that act on the source+command, then source, then command."
                      "<br>Use register_event_handler to add event handlers and remove_event_handler remove handlers. "
                      "The function return value shouldn't be used.")
     `tags: ["events" "controls" "key" "handlers" "dispatch" "routes" "create" ]
     })
     


(defun get_editors_for_path (path)
   (let
      ((spath (cond
                 (is_array? path)
                 (join "~" path)
                 (is_string? path)
                 path
                 else
                 (throw TypeError "path must be an array or string"))))
      (reduce (ctl (current_controls))
         (when (and ctl.editor
                    ctl.options.path
                    (== (join "~" ctl.options.path) spath))
            ctl)))
   {
       `description: "Returns an array of all controls that are editors and that have the supplied path value."
       `usage: ["path:array|string"]
       `tags: ["controls" "editor" "path"]
   }) 

(defun get_control_by_editor (editor)
   (let
      ((ctls (current_controls true)))
      (first (reduce (ctl ctls)
                (when (== ctl.editor editor)
                   (log "found ctl for editor")
                   ctl))))
   {
       `description: "Given an editor object, returns the control associated with it."
       `usage: ["editor:object"]
       `tags: ["editor" "control" "find"]
   })

(defun get_editor_file_basename (editor_control)
   (aif (resolve_path [ `options `filename ] editor_control)
        (last (split_by "/" it))
        nil)
   {
       description: (+ "If given a control with an editor which is operating on a file, " 
                        "will return the filename without the directory path for that editor. "
                        "Otherwise, it will return nil")
       usage: [ "editor_control:object"]
       tags: ["editor" "file" "basename" "filename" "path"]
   })

(defun close_file (editor_control)
   (let
      ((closed_focus? false))
      (log "close_file: " (and editor_control (prop editor_control `options)))
      (if (and (is_function? editor_control.on_destroy)
               (-> editor_control `on_destroy))
          (progn
             (for_each (ctl (get_editors_for_path editor_control.options.path))
                (progn
                   (if (not closed_focus?)
                       (= closed_focus? (== ctl *last_focus*)))
                   
                   (try
                      (container_view_operation `destroy ctl nil { `suppress_destroy_confirm: true } )
                      (catch Error (e)
                         (log "close_file error: " e.message)))))
             ;(log "close_file: calling default_focus" closed_focus?)
             (if closed_focus?
                   (default_focus)))
          (notify "Close cancelled."))))

;; when save events are dispatched, this function should be the
;; receiver.  It will get the value from the sending control,
;; attempt to save it, and if successful, will dispatch save_complete to
;; all editors with the specific path

(defun save_event_handler (event_obj)
   (alert_on_error "Unable to save"
       (let
          ((control (get_control_by_id event_obj.source))
           (pathname (when control
                        control.options.path))
           (nseval (if (not (blank? control.options.path_namespace))
                       (-> Environment `get_namespace_handle control.options.path_namespace)
                       Environment))
           (do_remote_save (fn ()
                              
                              (let
                                 ((rval nil))
                                 (= rval (http/send_files "/save_file" (http/data_to_file control.options.filename (or (-> control `get) ""))))
                                 (if (and rval
                                          (== rval.rval "OK"))
                                     (progn
                                        (= rval rval.results)
                                        (log "save_event_handler: saved remote file OK: " (clone rval))
                                        (if (== rval.length 1)
                                            (publish_results (+ { `target: rval.0.filename `type: "filename" } rval.0 ))
                                            (progn
                                               (log "ERROR: got different result for save_file then expected" (clone rval))
                                               (throw TypeError "Got different result for save file then expected"))))
                                     (progn
                                        (log "ERROR: save_event_handler: couldn't remote save: " (clone rval)))
                                        (throw TypeError (or rval.message "Uknown response from server"))))))
           (do_path_save (fn ()
                            (progn
                               (make_path pathname nseval.global_ctx.scope
                                  (-> control `get))
                               (if (not (== (-> control `get) (resolve_path pathname nseval.global_ctx.scope)))
                                   (progn
                                      (log "ERROR: save_event_handler: couldn't save path: values not matching: namespace: " control.options.path_namespace "path:" pathname )
                                      (throw TypeError "couldn't save to the local path - values not matching for path/namespace"))
                                   (progn
                                      (log "save_event_handler: saved local path OK: " control.options.path_namespace pathname)
                                      (publish_results { `target: pathname `type: "path" `namespace: control.options.path_namespace }))))))
                                   
                               
           (publish_results (fn (results_obj)
                               (let
                                  ((controls_to_notify (get_editors_for_path control.options.path)))
                                  (for_each (ctl controls_to_notify)
                                     (-> ctl `on_save_complete { `command: "save_complete" `source: control.options.id args: [ results_obj ] }))))))
          
          ;; validate we have what we need 
          (cond
             (eq nil control)
             (throw ReferenceError "Source control not found")
             (eq nil control.get)
             (throw TypeError "Source control doesn't have a get method for saving"))
          
          (cond
             (and (is_string? control.options.filename) ;; do we have a filename
                  is_served?)  ;; can we do a save?
             (progn
                (if (contains? "http_client" *env_config*.features)
                    (do_remote_save)
                    (throw ReferenceError "http_client is not a registered feature.")))
             (is_string? control.options.filename)
             (throw Error "Not connected to a server - cannot save the remove file")
             
             control.options.path
             (progn
                (do_path_save))))))
             
             

    
                     


(defun load_js_file (file)
  (let
      ((fdata (try
                (read_file file { `read_as: "text" })
                (catch Error (e)
                  e)))
       (assignment_to nil)
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
       (aif (request_user_input "Enter a name for a reference to the loaded Javascript" "text")
            (do
              (= assignment_to it)              
              (try
                (progn
                 (debug)
                 (cond
                   (or (== assignment_to "global")
                       (== assignment_to "script"))
                   (-> (page_header) `append (script { `type: "text/javascript" `charset: "utf-8" }
                                                     (javascript fdata)))
                   else
                   (eval `(defglobal ,#assignment_to (javascript ,#fdata)))))
                (catch Error (e)
                  (do
                    (= error true)
                    (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                    (console.error "ERROR: " e))))                                                    
              (when (not error)
                (log (message (+ "Loaded JS to " assignment_to )))))
            (notify "Entry Cancelled")))
      else
      (progn
       (log "Unable to read the file")
       (console.error fdata)))))

(defun embed_js_orig (name js_text) 
  (progn
   (debug)
   (-> (page_header) `append (html/script { `id: name `type: "text/javascript" `charset: "utf-8" }
                                     (javascript js_text)))   
   (eval `(defglobal ,#name (html/get_by_id ,#name)
            {
             `embedded_script: true
             }))))

(defun embed_js (name js_text) 
  (progn
   (debug)
   (eval `(-> (page_header) `append (html/script { `id: name `type: "text/javascript" `charset: "utf-8" }
                                     (javascript ,#js_text))))
   (eval `(defglobal ,#name (html/get_by_id ,#name)
            {
             `embedded_script: true
             }))))

(defun embed_js_file (file)
  (let
      ((fdata (try
                (read_file file { `read_as: "text" })
                (catch Error (e)
                  e)))
       (assignment_to nil)
       (error nil))
    (log (message (+ "found and read JS " file.name ", size: " file.size)))
    (cond
      (and fdata
           (not (instanceof fdata Error)))
      (progn
       (aif (request_user_input "Enter a name for a reference to the loaded Javascript" "text")
            (do
              (= assignment_to it)              
              (try
                (embed_js_orig assignment_to fdata)                   
                (catch Error (e)
                  (do
                    (= error true)
                    (log (error_message (+ "Unable to create " assignment_to ": " e.message)))
                    (console.error "ERROR: " e))))                                                    
              (when (not error)
                (log (message (+ "Loaded JS to " assignment_to )))))
            (notify "Entry Cancelled")))
      else
      (progn
       (log "Unable to read the file")
       (console.error fdata)))))

(defun load_files (files)
  (when (> files.length 0)
    (for_each (file files)
       (do
         (cond
           (== file.type "text/javascript")
           (embed_js_file file)
           (== file.type "text/plain")
           (notify "Text Resource")
           (or (ends_with? file.name ".lisp")
               (ends_with? file.name ".juno"))
           (notify "Loading lisp file"))))))



(defun control_frame (options `& contents)
  (let
      ((has_control_bar? (and (> contents.length 1)
                              (has_class? "juno-buffer-bar" contents.0)))
       (content (if has_control_bar?
                     [(first contents)
                      (div { `class: "juno-view-content" }
                           (rest contents)) ]
                     (div { `class: "juno-view-content" }
                           (rest contents))))
       (elem (div (+ { tabindex: 0 control_id: (or options.id (generate_id "frame"))
                      class: (+  "juno-view-container"
                                  (or options.classes "")) }
                      (if options.style
                        { `style: options.style }
                        {}))
                   content)))
    ;(log "control_frame: has_control_bar: " has_control_bar? contents)
    (when (not has_control_bar?)
      (set_style [["height" "100%" ]] content))
    (when (is_array? options.events)
      (for_each (ev options.events)
                (destructuring_bind (event_type action)
                     ev
                   (console.log "making events: " event_type action)
                   (attach_event_listener elem event_type action))))
    elem)
  {
   `description: (+ "Creates and returns an element representing the external frame "
                    "of a control. The passed contents can contain a buffer bar as a "
                    "first element, which will be identified as such by having a "
                    "juno-buffer-bar class assigned to it. <br>"
                    "The passed contents (excluding the buffer bar) are wrapped in a"
                    "juno-view-content div, and the whole contents, including the optional "
                    "buffer bar element are wrapped in a juno-view-container div.<br><br>"
                    "The options are as follows: <br><br>"
                    "id:string - The assigned id for the control.<br>"
                    "style:string - A string containing css styling attributes that are assigned "
                    "to the juno-view-container div (the encompassing element).<br><br>"
                    "events:array - An array of array values in the form of pairs in the "
                    "form of [event_type:string action:fn] which are attached to the "
                    "juno-view-container element.")
   `usage: ["options:object" "elements:Elements"]
   `tags: ["ui" "controls" "control" "frame" "DOM" "Node" "element" ]
   })

(defun name_control (prefix)
  (let
      ((prefix (or prefix "Unnamed"))
       (name ""))
    (if (get_control_by_name prefix)
      (+ prefix " " (inc *view_count*))
      prefix)))




(defun symbol_browser (options)
   (let
       ((self {})
        (options (or options {}))
        (show_previews (not options.disable_preview))                                
        (id (generate_id "symbol_browser"))
        (name (name_control (or options.name "Symbol Browser")))                  
        (title_span (span { `class: "juno-title" } name))
        (path_span (span { `class: "juno-path" `style: "float: right" } ""))
        (buffer_commands_button (commands_button id))
        (stack [ ])
        (filter_span (span { `style: "margin-left: 8px; margin-right: 8px; font-family: var(--main-mono-space);" } ""))
        (filter_span_container (span { `style: "border-radius: 3px; margin-left: 10px; padding-top: 2px; padding-bottom: 2px; border: 1px solid var(--type-regexp-color);" } 
                                     (span { `style: "padding-left: 10px; padding-right: 10px; background: var(--type-regexp-color); padding-top: 2px; padding-bottom: 2px; color: wheat;" } (+ (dtext "Filter") ":"))
                                     filter_span))
        (olist_style "padding-block-start: 3px; margin-block-start: 0.2em; padding-inline-start: 2px; ")
        (li_style "")
        (control_status (div {  class: "juno-buffer-bar" }
                                buffer_commands_button
                                (cond
                                  (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span)
                                filter_span_container
                                path_span))
        (symbol_struct (symbols_by_namespace))
        (element_for_pos (fn (pos want_parent?)
                           (let
                               ((target_col nil))                                
                             (= target_col (-> cview `querySelector (+ "[pos='" (if pos pos 0) "']")))                             
                             (cond 
                               (and want_parent? target_col)
                               target_col
                               target_col
                               (or (-> target_col `querySelector ".juno-highlighted")
                                   target_col.children.0)))))
        (filter_by_text (fn (pos text)
                            (let
                                ((elems (aif (element_for_pos pos true)
                                             it.children
                                             []))
                                 (elem nil)
                                 (num_found 0)
                                 (elem_bank_found [])
                                 (elem_bank_not_found [])
                                 (target_focus nil)
                                 ;;(remove_class "filtered-hidden" elem) (add_class "filtered-hidden" elem)
                                 (clear_it (blank? text)))
                                (if clear_it
                                    (progn
                                        (remove_class "filtered-hidden" elems)
                                        (focus_to (element_for_pos pos))
                                        false)
                                    (progn
                                        (for_each (idx (range elems.length))
                                            (progn
                                                (= elem (prop elems idx))
                                                (if (starts_with? text elem.innerText)
                                                    (push elem_bank_found elem)
                                                    (push elem_bank_not_found elem))))
                                        (cond
                                            (== elem_bank_found.length 0)
                                            false ;; do nothing
                                            (> elem_bank_found.length 0)
                                            (progn
                                                (console.log "found: " elem_bank_found.length)
                                                (for_each (elem elem_bank_found)
                                                    (remove_class "filtered-hidden" elems))
                                                (for_each (elem elem_bank_not_found)
                                                    (add_class "filtered-hidden" elem))
                                                (focus_to elem_bank_found.0)
                                                true)))))))
                                       
                                
        (filter_state {
                      chars: []
                      col_num: nil
                      })
        (show_filter_state (fn ()
                               (progn
                                   (if (> (length filter_state.chars) 0)
                                       (set_style [["opacity" "1"]] filter_span_container)
                                       (set_style [["opacity" "0"]] filter_span_container))
                                   (set_prop filter_span
                                            `innerText (join "" filter_state.chars)))))
        (clear_selector (fn (update?)
                            (progn
                                (console.log "clear_selector: filter_state: " (as_lisp filter_state))
                                (when filter_state.col_num
                                    (filter_by_text filter_state.col_num ""))
                                (set_prop filter_state
                                          `chars []
                                          `col_num nil)
                                (when update?
                                    (show_filter_state)))))
        (pop_from_selector (fn (pos)
                               (progn
                                   (if (== pos filter_state.col_num)
                                       (progn
                                           (pop filter_state.chars)
                                           (filter_by_text filter_state.col_num (join "" filter_state.chars)))
                                       (clear_selector))
                                   (show_filter_state))))
        (push_into_selector (fn (pos k)
                              (progn
                                  (defvar elems nil)
                                  (cond
                                      (eq nil filter_state.col_num)
                                      (progn
                                         (set_prop filter_state
                                                   `col_num
                                                   pos)
                                         (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                             (push filter_state.chars k)))
                                      (eq pos filter_state.col_num)
                                      (progn
                                          (when (filter_by_text pos (+ (join "" filter_state.chars) k))
                                                (push filter_state.chars k)))
                                      else
                                      (progn
                                        (push_into_selector pos k)))
                                  ;; update the displayed state of our filter 
                                  (show_filter_state)
                                  )))
                                                      
                                         
                                         
        (handle_keyup (fn (e)
                        (when (and e.srcElement
                                   (get_attribute e.srcElement "ctype"))
                          (let
                              ((elem e.srcElement)
                               (ctype (get_attribute elem "ctype"))
                               (pos (parseInt (get_attribute elem "pos")))
                               (final_pos stack.length))
                            ;(console.log "pos: " pos "press: " e)                           
                            (cond
                              (and (== e.key "ArrowUp")
                                   e.altKey)
                              (focus_to elem.parentElement.children.0)
                              (== e.key "ArrowUp")
                              (focus_to elem.previousElementSibling)
                              (== e.key "ArrowDown")
                              (focus_to elem.nextElementSibling)
                              (and (== e.key "ArrowLeft")
                                   (>= pos 0))
                              (progn
                                  (aif (element_for_pos (- pos 1))
                                   (focus_to it))
                                  (clear_selector true))
                              (== e.key "ArrowRight")
                              (progn
                                (console.log "moving to the right: " (element_for_pos (+ pos 1)))
                                (aif (element_for_pos (+ pos 1))
                                     (focus_to it)
                                     (focus_to (element_for_pos (+ pos 1) true))) ;; didn't get a standard list, it's probably a value of sort..
                                (clear_selector true))
                              (== e.key "Enter")
                              (progn
                                  (handle_event e)
                                  (handle_click e))
                              (== e.key "Backspace")
                              (pop_from_selector pos)
                              (== e.key "Tab")
                              nil
                              (> e.keyCode 47)
                              (progn
                               (push_into_selector pos e.key)
                               (console.log "filter state: " (as_lisp filter_state))))))))
                                                                                                                              
        (handle_click (fn (e)
                          (when (and e.srcElement 
                                     (get_attribute e.srcElement "ctype"))
                              (console.log "handle_click: " e.srcElement)
                              (let
                                  ((elem e.srcElement)
                                   (ctype (get_attribute elem "ctype"))
                                   (pos (get_attribute elem "pos"))
                                   (final_pos stack.length))
                                  (when pos
                                      (= pos (parseInt pos)))
                                  (clear_selector true)
                                  
                                  (console.log "handle_click: pos: " pos "final_pos:" final_pos ctype elem.innerText stack)
                                  (remove_class "juno-highlighted" e.srcElement.parentElement.children)
                                  (add_class "juno-highlighted" e.srcElement)
                                  (cond
                                     (== ctype "nspace")
                                     (progn
                                         (= stack [])
                                         (render_view e.srcElement.innerText)
                                         
                                         ;; next display the first namespace
                                         (= stack [ elem.innerText ])
                                         (render_view))
                                     (and (== ctype "sym")
                                          (== pos final_pos))
                                     (progn
                                         (push stack elem.innerText)
                                         (console.log "STACK is now: " stack)
                                         (render_view))
                                     (< pos final_pos)
                                     (progn
                                         (= stack (-> stack `slice 0 pos))
                                         (push stack elem.innerText)                                         
                                         (console.log "mid stack click: stack now: " (as_lisp stack) "view children:" (length cview.children) (range cview.children.length))
                                         (for_each (child_num (-> (range cview.children.length) `reverse))
                                            (progn
                                               (console.log "child_num: " child_num (prop cview.children child_num) (parseInt (get_attribute (prop cview.children child_num) `pos)))
                                                (when (> (parseInt (get_attribute (prop cview.children child_num) `pos)) (- stack.length 1))
                                                    (-> (prop cview.children child_num) `remove))))
                                         (render_view))                                         
                                     (== e.srcElement.tagName "LI")
                                     (progn
                                      (push stack  elem.innerText)                                 
                                      (render_view)
                                      ))))))
                            
        (cview (div { `style: "" `class: "juno-symbol-browser" }))
        (has_children? (fn (val)
                           (and (is_object? val)
                                (> (length val) 0))))
        (next_possibles (fn ()
                            (let
                               ((path (conj [ "context" "scope" ] (or (rest stack) [])))
                                (ns (first stack))
                                (idx -1)
                                (val nil))
                            (assert ns "No namespace yet - invalid stack")
                            (= val (resolve_path path (-> Environment `get_namespace_handle ns)))
                            (console.log "next_possibles: namespace:" ns path "value: " val)
                            (when options.on_select
                              (options.on_select ns (rest stack)))                            
                            (cond 
                              (is_function? val)
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   (value_to_dom val))
                              (is_array? val)                                                           
                              (for_each (symb (resolve_path path (-> Environment `get_namespace_handle ns)))
                                 (progn
                                     (inc idx)
                                     (li { `tabindex: 0 `ctype: (if (is_object? symb) "sym" (lowercase (subtype symb)))
                                       `pos: stack.length
                                       `title: (subtype symb)
                                       `class: (+ "juno-list-item " (if (has_children? symb) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb)))
                                      `style: li_style } idx)))
                              (is_object? val)                                                    
                              (for_each (symb (sort (pairs (resolve_path path (-> Environment `get_namespace_handle ns)))
                                                    { `key: [ 0 ] }))
                                 (li { `tabindex: 0 `ctype: (if (is_object? symb.1) "sym" (lowercase (subtype symb.1)))
                                       `pos: stack.length
                                       `title: (subtype symb.1)
                                       `class: (+ "juno-list-item " (if (has_children? symb.1) "juno-list-item-has-children " "") "juno-type-" (lowercase (subtype symb.1))) 
                                       `style: li_style } symb.0))
                                                                                   
                              (is_function? options.render_preview)
                              (let
                                  ((elem (options.render_preview)))
                                (if elem
                                  (if (get_attribute elem "ctype")
                                    elem
                                    (progn
                                     (-> elem `setAttribute `ctype "val")
                                     elem))
                                  (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                       "The render_preview function didn't return an element as expected.  Check call.")))
                              
                              (is_string? val)
                              (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: 100%;" }
                                   val)
                              
                              else         
                              (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: 100%;" }
                                 (value_to_dom val))))))

        (render_view (fn (ns_name)
                       (progn
                        (console.log "render_view: stack " stack)
                        (if (> stack.length 1)
                          (set_prop path_span
                                    `innerText (+ "[ "(join " " (rest stack )) " ]"))
                          (set_prop path_span
                                    `innerText ""))                                    
                        (clear_selector true)
                        (cond
                          (== stack.length 0) ;; initial state
                          (progn
                           (-> cview `replaceChildren
                              (ol { `pos: 0 }
                               (for_each (ns (sort (namespaces)))
                                         (li {`tabindex: 0
                                              `ctype: "nspace"
                                              `pos: 0
                                              `class: (+ "juno-list-item juno-namespace" (if (== ns ns_name) " juno-highlighted" ""))
                                              `style: li_style
                                              } ns))))
                           (focus_to (element_for_pos 0)))
                          else
                          (progn
                           (defvar next_elem (next_possibles))
                           (cond
                             (is_array? next_elem)
                             (progn
                                 (-> cview `appendChild
                                    (ol { `pos: stack.length  }
                                         next_elem))                                 
                                 (setTimeout (fn () (focus_to (element_for_pos stack.length))) 10))
                             (is_element? next_elem)
                             (progn
                              (-> cview `appendChild                                 
                                  next_elem)
                              (-> next_elem `setAttribute "pos" stack.length)                              
                              (focus_to next_elem)))
                           
                           (set_prop cview `scrollLeft (+ cview.offsetWidth 20)))))))
                                                                                                                               
                          
        (view (control_frame { `id: id  `events: [[ "click" handle_click]
                                                  [ "keyup" handle_keyup ]] }
                             control_status
                             cview))
        (resize (fn ()
                  (progn                           
                   (let
                       ((new_height (- (prop view.parentElement `offsetHeight) 20))
                        (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                     (set_style [[ "width" (+ "" new_width "px") ]
                                 [ "height" (+ "" new_height "px") ]]
                                view)
                     (when options.on_resize
                       (options.on_resize self))))))
        (resize_observer (new ResizeObserver resize))
        (on_focus (fn ()
                   (progn                  
                    (add_class "juno-focused" control_status ))))
        (initialized false)
        (initialize (fn ()
                      (when (and view.parentElement
                                 (not initialized))
                        (= initialized true)                       
                        (-> resize_observer `observe view.parentElement)
                        (render_view (current_namespace))
                        (push stack (current_namespace))
                        (render_view)
                        (defglobal *sbcview* cview))))   ;; TODO: REMOVE 
        
        (to_json (function ()
                           `[symbol_browser ,#options])))

    
     (set_prop options
               `id id
               `name name)                
     (set_prop self
               `view view
               `options options
               `name name
               `type "symbol_browser"              
               `initialize initialize
               `resize resize
               `toJSON to_json
               `on_focus on_focus)
     self))

(defun symbol_chooser (prompt type options)
  (new Promise (fn (resolve reject)                 
                 (let
                     ((ns nil)
                      (target_path target_path)
                      (set_val (fn (selected_ns selected_path)
                                   (progn 
                                      (console.log "ns: " selected_ns selected_path)
                                      (= ns selected_ns )
                                      (= target_path selected_path)
                                      (cond
                                        (blank? ns)
                                        (set_disabled new_symbol_button)
                                        (not (blank? ns))
                                        (progn
                                         (set_enabled new_symbol_button)
                                         (set_prop new_symbol_button
                                                  `innerText (+ (dtext "New Global Value"))))))))
                                            
                      (new_symbol_button (button { `tabindex: 0 `title: (dtext "Create New Entry") `style: "margin-left: 8px; margin-right: 8px;  font-weight: bold; background: var(--highlight-bg-color);" } (dtext "New")))
                      (path_span (span { `tabindex: 0 `title: (dtext "Click to copy path")  `class: "juno-path" } ""))
                      (symbol_ctl (symbol_browser { 
                                                   `additional_elements: [(span { `class: "juno-title" `style: "color:var(--main-color)" } (dtext "Open A Location"))
                                                                          (span { `title: (dtext "Edit Mode") `class: "juno-mode" } (if type type  ""))
                                                                          new_symbol_button
                                                                          ] 
                                                    `on_select: set_val }))
                      (ok_button (button { `class: "juno-primary" `style: "min-width: 100px; margin-right: 20px; margin-left: 20px; float:right; font-weight: bold;" } "OK"))
                      (cancel_button (button { `style: "margin-left: 20px;" }   "Cancel"))
                      (dwin (dialog { `style: "height: 40%; width: 60%; overflow: hidden; padding: 2px;" }                                                                    
                                    (div { `style: "height: calc(100% - 50px);" }
                                         symbol_ctl.view)
                                    (br)
                                    (div { `class: "juno-button-group pure-button-group" `role: "group" }
                                         cancel_button
                                         ok_button))))
                   (attach_event_listener new_symbol_button
                                          `click
                                          (fn (e)
                                            (progn
                                             (aif (request_user_input (+ "" (dtext "Enter the name to be created in") " " ns) `text)
                                                  (progn
                                                   (-> dwin `remove)
                                                   (-> (-> Environment `get_namespace_handle ns)
                                                       `set_global it "")
                                                   (resolve { `namespace: ns `path: [ it ] }))))))
                   (attach_event_listener ok_button
                                          `click
                                          (fn (e)
                                            (do                                              
                                              (resolve {
                                                  `namespace: ns
                                                  `path: target_path
                                                  })
                                              (-> dwin `remove))))                   
                   (attach_event_listener cancel_button
                                          `click
                                          (fn (e)
                                            (do
                                              (-> dwin `remove)
                                              (resolve nil))))
                   (-> juno_container
                       `appendChild dwin)
                   (set_prop symbol_ctl.options
                      `temporary true)
                   (-> symbol_ctl `initialize)
                   (when (is_function? dwin.showModal)
                     (-> dwin `showModal))))))


(defun make_autocompletion_scores (analysis_object)
   (let
      ((result_set [])
       (keywords (try (compiler `[ true ] { `special_operators: true `env: Environment } )
                    (catch Error (e)
                       (progn
                          (log "error on compiler: " e.message)
                          (new Set)))))
       (included (new Set))
       (score 0))
      (for_each (r (sort analysis_object.allocations))
         (progn
            (-> included `add r)
            (cond
               (contains? r analysis_object.globals)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local (shadowed global)" })
               else
               (push result_set
                  { `value: r `score: (inc score) `meta: "local" }))))
      (for_each (r (sort analysis_object.symbols))
         (cond
            (contains? r analysis_object.allocations)
            true ;; we already placed it 
            else
            (progn
               (-> included `add r)
               (push result_set
                  { `value: r `score: (inc score) `meta: "local?" } ))))
      (for_each (r (sort analysis_object.keywords))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "keyword" })))
      (for_each (r (sort analysis_object.globals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "global" })))
      (for_each (r (sort analysis_object.literals))
         (progn
            (-> included `add r)
            (push result_set
               { `value: r `score: (inc score) `meta: "literal" })))
      (for_each (r (sort (to_array keywords)))
         (if (not (-> included `has r))
             (progn
                (-> included `add r)
                (push result_set
                   { `value: r `score: (inc score) `meta: "keyword" }))))
      (for_each (r (sort (to_array (all_globals))))
         (if (not (-> included `has r))
             (push result_set
                { `value: r `score: (inc score) `meta: "global" })))
      result_set)
   {
       `usage: ["analysis_object:object"]
       `description: (+ "Given the output of process_tree_symbols, returns a result_set to be provided to the Ace autocomplete callback for "
                        "suggestions for autocomplete.")
       `tags: ["editor" "analysis" "autocomplete" "session" "Ace"]
   })

(defun find_root_forms_for_buffer (buffer_text options)
   (let
      ((lines (split_by "\n" buffer_text))
       (ldat nil)
       (lnum -1)
       (running_depth_for_line 0)
       (new_depth nil)
       (last_line_max_col 0)
       (boundaries nil)
       (depth_positions [])
       (current_root_form nil))
      
      (for_each (line lines)
                (progn
                   (inc lnum)
                   (= ldat (analyze_text_line line))
                   
                   (= boundaries (sort (conj (for_each (o ldat.openers)
                                                [o 1 (prop line o) ])
                                             (for_each (c ldat.closers)
                                                [c -1 (prop line c)]))
                                       { `key: [ 0 ] }))
                   (= last_line_max_col (or (last ldat.closers) (length line)))
                   (for_each (t boundaries)
                      (progn
                         (= running_depth_for_line (+ t.1 running_depth_for_line))
                         (cond
                            (and (eq nil current_root_form)
                                    (== running_depth_for_line 1))
                            (progn
                               (= current_root_form {
                                                      `start_row: lnum
                                                      `start_col: t.0
                                                      `end_row: nil
                                                      `end_col: nil
                                                      }))
                            (and current_root_form
                                 (== running_depth_for_line 0))
                            (progn
                               (set_prop current_root_form
                                  `end_row lnum
                                  `end_col t.0)
                               (push depth_positions current_root_form)
                               (= current_root_form nil)))))))
      (if (and options.flexibility
               current_root_form
               (> running_depth_for_line 0)) ;; most likely unclosed form
          (progn
             (set_prop current_root_form
                `end_row lnum
                `end_col last_line_max_col)
             (push depth_positions current_root_form)
             (= current_root_form nil)))
      depth_positions)
   {
     description: (+ "Given a text value as a string and an optional options object, returns an array of objects, "
                      "each representing the starting and ending positions of each found form.  The returned objects "
                      "have the keys: start_row, start_col, end_row, and end_col, which will be numeric offsets "
                      "from line 0 and column 0 respectively.<br>"
                      "If an options object is given with the key flexibility set to true, then if the final "
                      "form is incomplete, will return the start to final part of the end form.")
     usage: ["text_buffer:string" "options:object"]
     tags: ["forms" "parsing" "syntax" "selection" ]
     })

(defun get_root_form_for_position (buffer_text row column flexibility_mode)
   (let
      ((root_forms (find_root_forms_for_buffer buffer_text { flexibility: (if flexibility_mode true false) } ))
       (target nil))
      (for_each (form (or root_forms []))
         (progn
            (when (and (>= row form.start_row)
                       (<= row form.end_row))
               (cond 
                  (or (and (== form.end_row form.start_row)
                           (>= column form.start_col)
                           (<= column form.end_col))
                  
                      (> (- form.end_row form.start_row) 0))
                  (progn
                     (= target form)
                     (break))))))
      target)
   {
     description: (+ "Given a text buffer, a row number (>= 0) and a column number (>= 0), returns an object that has the "
                     "position values for the enclosing form to a depth of 0.  The object returned has " 
                     "the following layout: <br>"
                     "{ start_row:int end_row:int start_col:int end_col:int }<br>"
                     "All values start at offset 0.")
     tags: ["form" "position" "selection" "text" "lisp"]
     usage: ["buffer_text:string" "row:int" "column:int" "flexibility_mode:?boolean"]
   })


(defun floating_div (contents options)
   (let
      ((close_button (button { `title: (dtext "Close") } "X"))
       (move_state nil)
       (expander_elem (div { `style: "position: absolute; right: 0px; bottom: 0px; width: 15px; height: 15px; cursor: nwse-resize; background: transparent;" }
                           ""))
       (full_block (div { `style: "z-index: 8; width: 100%; height: 100%; position: absolute; top:0px; left: 0px;" }))
       (dims nil)
       (resize_mode false)
       (max_dims {
                  `width: 0
                  `height: 0
                  })
       (body_element nil)
       (block_on (fn (e)
                    (progn
                       (= dims (-> frame `getBoundingClientRect))
                       (= body_element (get_by_id "body"))
                       (= max_dims {
                                     `width: (prop body_element `offsetWidth)
                                     `height: (prop body_element `offsetHeight) })
                       (-> body_element `appendChild full_block)
                       (= move_state {
                                       mx: e.pageX
                                       my: e.pageY
                                       fx: dims.right
                                       fy: dims.top
                                       w: dims.width
                                       h: dims.height
                                       }))))
       (control_bar (div { `class: "juno-buffer-bar" style: "cursor: grab;" }
                 close_button
                 (or options.title "")))
       (end_drag (fn (e)
                    (progn
                       (= move_state nil)
                       (= resize_mode false)
                       (if (is_function? contents.resize)
                           (-> contents `resize))
                       (-> full_block `remove))))       
       (handle_drag (fn (e)
                      (when (and move_state
                                 (== e.buttons 1))
                         (if resize_mode
                            (set_style [["width"  (+ "" (Math.max 300 (Math.min (- max_dims.width 30) (+ dims.width (- e.pageX move_state.mx)))) "px")]
                                        ["height" (+ "" (Math.max 30 (Math.min (- max_dims.height 30) (+ dims.height (- e.pageY move_state.my)))) "px")]]
                                       frame)
                            (set_style [["top"  (+ "" (Math.max 0 (Math.min (- max_dims.height 30) (+ dims.top (- e.pageY move_state.my)))) "px") ]
                                        ["left" (+ "" (Math.max 0 (Math.min (- max_dims.width 30) (+ dims.left (- e.pageX move_state.mx)))) "px") ]]
                                       frame)))))
                                   
       (frame (div { class: "juno-floating-container" 
                     style: (+ "left: " (+ 50 (random_int 10)) "%; " 
                               "top: " (+ 5 (random_int 10)) "px; "
                                (if (is_string? options.style)
                                    (+ "" options.style ";")
                                    ""))
                                  }
               (control_frame {}
                control_bar
                (cond
                   (and (is_object? contents)
                        contents.view)
                   contents.view
                   (is_element? contents)
                   contents
                   else
                   (value_to_dom contents)))
               expander_elem)))
      
      (attach_event_listener close_button
         `click
         (fn (v)
            (progn
               (when options.on_close
                  (options.on_close))
               (-> frame `remove))))
      
      (attach_event_listener control_bar
         `mousedown
         (fn (e)
            (block_on e)))
      (attach_event_listener expander_elem
         `mousedown
         (fn (e)
            (progn
               (= resize_mode true)
               (block_on e))))
      
      
      (attach_event_listener full_block
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mouseup
                             end_drag)
      (attach_event_listener frame
                             `mousemove
                             handle_drag)
      (attach_event_listener full_block
                             `mousemove
                             handle_drag)
      (-> (get_by_id "body") `appendChild frame)
      ;; if we have a control, initialize it if it needs it since it is 
      ;; now mounted on the DOM
      (when contents.initialize
         (-> contents `initialize))
      
      true))

(defun monitor_control_tree ()
   (let
       ((view nil)
        (title_span (span { } "Control Structure"))       
        (update_timer nil))
     (if (get_by_id `control_tree_monitor)
       (notify "Control Tree Already Showing")
       (progn
        (setTimeout (fn ()
                      (set_prop title_span
                                `innerText
                                (dtext "Click to highlight a control")))
                    4000)
        (= view (div { `id: `control_tree_monitor  style: "background: var(--control-bg-color); color: var(--control-color);"}
                     (render_control_tree $root_controls)))
        (attach_event_listener view
                               `click
                               (fn (e)
                                 (let
                                     ((id (-> e.srcElement `getAttribute "control_id"))
                                      (body_element (get_by_id "body"))
                                      (dims nil)
                                      (highlighter nil)
                                      (control (if id (get_control_by_id id))))
                                   (when control
                                     (when control.view
                                       (= dims (-> control.view `getBoundingClientRect))
                                       (console.log "control dims: " control.name dims)
                                       (-> body_element `appendChild
                                           (= highlighter (div { `id: "highlighter" `class: "identification" `style: (+ "z-index: 7; position: absolute; top: " dims.top "px; left: " dims.left "px; width: " (- dims.width 5) "px; height: " (- dims.height 5) "px; border: 3px dashed red;") }
                                                           "")))
                                       (setTimeout (fn ()
                                                     (do 
                                                        (aif (get_by_id "highlighter")
                                                             (-> it `remove))
                                                        (-> highlighter `remove)))
                                                   1000))))))
                                   
        (= update_timer (setInterval (fn ()
                                     (progn                                        
                                        (-> view `replaceChildren (render_control_tree $root_controls))))
                                     1000))
        (floating_div view
                      {  `title: title_span
                         `on_close: (fn ()
                                     (progn
                                      (clearInterval update_timer)))
                       })))))

  

(defun handle_lisp_format_event (val editor)
  (progn    
    (when (and (== (- val.end.row val.start.row) 1)
              (== val.action "insert"))     
       (defvar indent_string (format_lisp_line val.end.row (function (rnum) 
                                                                     (-> editor.session `getLine rnum))))
       (when indent_string
        (-> editor.session `indentRows val.end.row val.end.row indent_string)))))

(defun_sync indent_editor_line (editor row_number options)
  (if (is_number? row_number)
    (let
        ((line (-> editor.session `getLine row_number))
         (orig_line (clone line))
         (indent_string (format_lisp_line row_number
                                          (or options.get_row
                                              (function (rnum) 
                                                        (-> editor.session `getLine rnum))))))
      (console.log "indent_row: " row_number "indent_string: " indent_string line)
      (if indent_string
        (progn
         (setq line (+ "" indent_string (trim line)))
         (console.log "line at " row_number " to be replaced with: " (JSON.stringify line))
         (if options.apply
           (progn
            (-> editor.selection `clearSelection)
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `remove (-> editor.selection `getRange))
            (-> editor.selection `setSelectionAnchor row_number 0)
            (-> editor.selection `selectLineEnd)
            (console.log "indent_editor_line: selected line" (JSON.stringify (clone (-> editor.selection `getRange))))
            (-> editor.session `replace (-> editor.selection `getRange) line)
            (console.log "indent_editor_line: get_line: " (JSON.stringify (-> editor.session `getLine row_number)))
            (-> editor.selection `clearSelection)
            true)
           line))        
        line))
    (throw EvalError "invalid row_number provided to indent_row")))

(defun_sync indent_editor_selection (editor)
  (let
      ((start nil)
       (end nil)
       (selected_range (clone (-> editor.selection `getRange))))
    
    (= start selected_range.start.row)
    (= end selected_range.end.row)
    (console.log "tab: start: selected_range: " (JSON.stringify selected_range))
    (-> editor.selection `clearSelection)
    (-> editor.selection `setSelectionAnchor start 0)
    (-> editor.selection `selectTo end 0)
    (-> editor.selection `selectLineEnd)
    (console.log "tab: start: fully selected_range: " (-> editor.selection `getRange))                                                   
    (defvar lines (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
                            (-> editor.session `getLine row_number)))
    (console.log "tab: lines: pre-change: " (clone lines))
    
    (for_each (row_number (range_inc selected_range.start.row selected_range.end.row))
              (progn
               (console.log "tab: [start]: [ " selected_range.start.row selected_range.end.row " ] analyzing row: " row_number ": " (JSON.stringify (prop lines (- row_number start))))
               (set_prop lines
                         (- row_number start)
                         (indent_editor_line editor row_number
                                     { get_row: (function (rnum)
                                                          (progn
                                                           (console.log "get_row: rnum: " rnum " relative: " (- rnum start))
                                                           (cond
                                                             (and (>= rnum start)
                                                                  (< rnum end))
                                                             (prop lines
                                                                   (- rnum start))
                                                             else
                                                             (-> editor.session `getLine rnum)))) ;; not impacted by the change
                                      } ))))
    
    (console.log "tab: adjusted lines: " lines)
    (console.log "tab:     lines joined: " (join "\n" lines))
    (-> editor.session `replace (-> editor.selection `getRange) (join "\n" lines))
    (-> editor.selection `selectLineEnd)
    ;(-> editor.selection `setRange selected_range)
    (console.log "tab: reselected fixed: " (-> editor `getCopyText))))


(defun_sync select_to_current_form (editor pos)
  (if editor
    (let
        ((rng (-> editor `getSelectionRange))
         (already_selected? (if (and (== rng.start.row rng.end.row)
                                     (== rng.start.column rng.end.column))
                                false
                                true))
         (cpos (or pos 
                   (if already_selected?
                      (progn
                         (-> editor `navigateTo rng.start.row rng.start.column)
                         (-> editor `getCursorPosition))
                      (-> editor `getCursorPosition)))))
      (when cpos
        (= rng (find_last_paren editor cpos))
        (when rng
          (-> editor.selection `clearSelection)
          (-> editor.selection `setRange rng)))
      rng)
    nil)
  {
   description: (+ "Given an editor and an optional position { row column }, if possible, "
                   "selects the innermost current form (expression) in the editor and "
                   "returns the range.")
   usage: ["editor:object" "pos:?object"]
   tags: ["editor" "selection" "form" "lisp" "editing" ]
   })
          
           
(defun show_editor_keybindings (editor_control)
   (let
      ((binding_row (fn (keysequence binding)
                       (tr
                          (td keysequence)
                          (td (or binding.description
                                  (from_key binding.name)))))))
      (table { `style: "width: 100%" }
             (thead
                (tr
                   (th "Key Sequence")
                   (th "Description")))
             (tbody
                (for_each (bindpair (sort (pairs (editor_key_bindings editor_control.editor))
                                          { `key: [`0] }))
                   (destructuring_bind (keysequence binding)
                      bindpair
                      (cond
                         (is_array? binding)
                         (for_each (bindval binding)
                            (binding_row keysequence bindval))
                         (is_object? binding)
                         (binding_row keysequence binding)
                         else
                         [])))))))

(defun show_key_bindings ()
   (let
      ((platform (get_operating_platform))
       (default_editor_keys (if (-> Environment `get_global "*orig_key_bindings*" nil)
                                (reduce (entry (values (-> Environment `get_global "*orig_key_bindings*")))
                                   (when (prop entry.bindKey platform)
                                      (to_object
                                         [[`name entry.name]
                                          [`description entry.description]
                                          [ (+ "" platform) (prop entry.bindKey platform) ]])))))
       
                                       
       (categories (reduce (k (keys *key_bindings* ))
                      (unless (== k "active")
                         k)))
       (td_style (function () 
                    { `style: "vertical-align:top; padding: 5px; border-bottom: 1px solid var(--main-accent-line);" } ))
       (table_values  (sort
                           (conj (-> (for_each (category categories)
                                        (for_each (binding (pairs (resolve_path [ category ] *key_bindings*)))
                                           (destructuring_bind (name entry)
                                              binding
                                              [ (prop entry platform)
                                               (from_key name)
                                               (from_key category)
                                               (or (prop entry `description)
                                                   "No Description") ] )))
                                     `flat 1)
                                 
                                 (for_each (binding default_editor_keys)
                                    [(prop binding platform)
                                     (from_key binding.name)
                                     "Editor"
                                     (or (prop binding `description)
                                         "No Description")]))
                           { `key: [`0] }
                            )))
      ;(log "Table values: " table_values)
      (table { `style: "width: 100%" }
         (thead
            (tr { `style: "" }
               (th { `style: "padding: 5px;" } "Key Binding")
               (th { `style: "padding: 5px;" } "Command")
               (th { `style: "padding: 5px;" } "Scope")
               (th { `style: "padding: 5px;" } "Description")))
         (tbody
            (for_each (row table_values)
               (tr { `style: "padding: 5px; " }
                  (td (td_style) row.0)
                  (td (td_style) row.1)
                  (td (td_style) row.2)
                  (td (td_style) row.3))))))
   {
     `description: "Returns a table DOM element of the current key bindings."
     `usage: []
     `tags: ["help" "keys" "bindings" "display" ]
     })

(defun_sync select_root_form (editor pos)
   (if (and (is_object? editor)
            (is_object? pos))
       (let
          ((last_selection nil)
           (idx 0)
           (current_selection nil))
          ;; start with the current position
          (= current_selection (find_last_paren editor pos))
          (while (and (< idx 1000)
                      current_selection
                      (or (eq nil last_selection)
                          (not (and (== last_selection.start.column current_selection.start.column)
                                    (== last_selection.start.row current_selection.start.row)
                                    (== last_selection.end.column current_selection.end.column)
                                    (== last_selection.end.row current_selection.end.row)))))
             (progn
                (inc idx)
                (= last_selection current_selection)
                (= current_selection (find_last_paren editor current_selection.start))
                ))
          
          (aif current_selection
             {
               `start_row: it.start.row
               `start_col: it.start.column
               `end_row: it.end.row
               `end_col: it.end.column
               })
             ))
   {
     `usage: ["editor:object" "pos:object"]
     `description: "Given an editor and a position, returns the determined root form for the position."
     `tags: ["selection" "editor" "root" "form" "position"]
     })

(defun select_to_root_form (editor pos)
   (if editor
       (let
          ((cpos (-> editor `getCursorPosition))
           (pos (if pos
                    (select_root_form editor pos)
                     (select_root_form editor cpos))))
          (when pos
             (-> editor.selection `clearSelection)
             (-> editor.selection `setSelectionAnchor pos.start_row pos.start_col)
             (-> editor.selection `selectTo pos.end_row (+ pos.end_col 1))
             true))
       (throw TypeError "editor must be provided to select_to_root_form"))
   {
       description: (+ "Given an editor and an optional position, will select the complete form (to a depth of 0) if possible. "
                        "If given a position object with a row and column value, the function will use that instead.  If "
                        "succesful, the value true will be returned.  If no editor is provided, the function will throw a "
                        "TypeError.")
       usage: ["editor:object" "pos:?object"]
       tags: ["editor" "selection" "form" "lisp" "editing"]
   })


(defun get_juno_autocompletions (editor session pos prefix callback)
   (let
      ((root_form (select_root_form editor pos))
       (collect_error (fn (e)
                         true))
       (text_data (+ "" (-> editor.session `getTextRange (new ace.Range root_form.start_row root_form.start_col root_form.end_row root_form.end_col)) ")"))
       (tokens (reader text_data { `suppress_throw_on_error: true on_error: collect_error  } )))
      
      (= tokens (make_autocompletion_scores (process_tree_symbols tokens prefix)))
      (callback null tokens))
   {
       `usage: ["editor:object" "session:object" "pos:object" "prefix:text" "callback:fn" ]
       `description: "Internally used by the editor for autocompletion."
       `tags: ["ace" "editor" "autocomplete" ]
   })
 
(defun clone_edit_session (session)
   (let
      ((s (new ace.EditSession (-> session `getDocument)
                               (-> session `getMode)))
       (undoManager (-> session `getUndoManager)))
      (-> s `setUndoManager undoManager)
      (-> s `setTabSize (-> session `getTabSize))
      (-> s `setUseSoftTabs (-> session `getUseSoftTabs))
      (-> s `setOverwrite (-> session `getOverwrite))
      (-> s `setBreakpoints (-> session `getBreakpoints))
      (-> s `setUseWrapMode (-> session `getUseWrapMode))
      (-> s `setUseWorker (-> session `getUseWorker))
      (-> s `setWrapLimitRange session.$wrapLimitRange.min session.$wrapLimitRange.max)
      (set_prop s session.$foldData
         (-> session `$cloneFoldData))
      s))

(defun eval_selected_text_in_place (ctl options)
   (progn
      (let
         ((text (-> ctl `get_selected_text))
          (editor (or ctl.editor
                      options.editor
                      (throw TypeError "eval_selected_text_in_place: no editor for provided control")))
          (selection (-> ctl `get_selection))  ;; range to replace with results
          (evaluator nil)
          (result nil))
         (= evaluator
            (cond
               (is_function? options.evaluator)
               options.evaluator
               ctl.get_evaluator
               (-> ctl `get_evaluator)))
         (assert (is_function? evaluator) "eval_selected_text_in_place: no evaluator found for control or in provided options.")
         (= result (evaluator text false true true))
         (log "result: " result)
         (= result
            (cond
               (is_object? result)
               (if options.as_json
                  (JSON.stringify result nil 2)
                  (+ "" (as_lisp result)))
               (is_string? result)
               result
               else
               (+ "" (as_lisp result))))
         (try 
            (-> (-> editor `getSession) `replace selection result)
            (catch Error (e)
               (progn
                  (-> (-> editor `getSession) `replace selection text)
                  (-> ctl `display_context_message (+ "Error on replace: " e.message))
                  (log (+ (dtext "Couldn't replace text in editor") ":" (prop ctl.options `name) ": " e.message))
                  (log e))))
         ))
   {
     description: (+ "Given a control with an editor, the selected text is evaluated " 
                     "using the editors evaluator.  The evaluated selection is replaced with the result."  
                     "An optional 'evaluator' function can be passed to be used as the evaluator instead "
                     "of the controls default evaluator.  If 'as_json' as true, then the result will be "
                     "written as a JSON object in the editor.")
     usage: ["control:object" "options:?object"]
     tags: ["editor" "control" "text" "evaluation" "replacement" "eval" "buffer"]
   })

(defun set_scroll_speed (ctl value)
   (if ctl.editor
      (progn
         (-> ctl.editor `setScrollSpeed (clamp value 1 10))
         (set_prop ctl.options
            `scroll_speed
            (clamp value 1 10))
         (-> ctl.editor `getScrollSpeed))
      (progn
         (log "set_scroll_speed: no editor for control: " ctl.name)))

   {
       description: (+ "Sets the scroll speed for the editor by taking a control with an " 
                       "editor and a value between 1 and 10, where 10 will scroll the fastest "
                       "and 1 will be the slowest scroll value.  Default speed is 5.  " 
                       "Return value will be the new scroll speed value.")
       usage: ["control:object" "value:number"]
       tags: ["editor" "scroll" "speed"]
   })

(defmacro defcontrol (name control_args allocations control_options)
   (let
      ((declared_allocations (each allocations first))
       (required_allocations [(quote render)])
       (user_allocations allocations)
       (cname (-> name `substr 2))
       (meta { `description: (or control_options.description "No description")
               `tags: (or control_options.tags [`control `ui `DOM ])
               `usage: (if (is_array? control_options.usage)
                           (conj control_options.usage
                                 [ "options:object" ])
                           nil) })
       (args (progn
                (cond
                   (is_array? control_args)
                   (conj control_args [ (quote options) ])
                   else
                   (throw SyntaxError (+ "defcontrol: " cname ": missing/malformed control arguments - check syntax")))))
       (control_options (if (is_object? control_options)
                            control_options
                            {}))
       (control_bar? (if control_options.control_bar
                        true)))            
       (assert name "control name is required: check syntax for defcontrol")
       (if (< (length (reduce (d declared_allocations)
                         (contains? d required_allocations)))
              (length required_allocations))
           (throw SyntaxError (+ "defcontrol: " cname " missing required declarations: must have render")))
       (cond
          (contains? (quote id) declared_allocations)
          (throw SyntaxError (+ "defcontrol: " cname " cannot declare id - to pass a custom ID to the control, pass id in options when instantiating the control."))
          (contains? (quote initialize) declared_allocations)
          (throw SyntaxError (+ "defcontrol: " cname " cannot declare initialize - use on_initialize")))
       
  ;; ok, now create the form to be returned..
      `(defun ,#name ,#args
          (let
             ((self {})
              (options (or options {}))
              (name (compute_name_for_control (or options.name ,#(from_key (desym_ref name)))))
              (id (or options.id 
                      (generate_id ,#name)))
              (initialized false)
              (title_span (span { `class: "juno-title" } name))
              (command_button (commands_button id))
              (content_view (div { } "uninitialized.."))
              (resize (fn ()
                         (progn
                            (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                               (set_style [[ "width" (+ "" new_width "px") ]
                                           [ "height" (+ "" new_height "px") ]]
                                          view)
                               
                               (when options.on_resize
                                  (options.on_resize self))
                               ,#(if control_options.render_on_resize
                                     `(do_render)
                                     true)
                               ,#(if (contains? (quote on_resize) declared_allocations)
                                     `(on_resize self)
                                     [])
                               true))))
              ,@user_allocations
              (control_status (if ,#control_bar?
                                  (div { `class: "juno-buffer-bar" }
                                   command_button
                                   (cond 
                                      (is_array? options.additional_elements)
                                      options.additional_elements
                                      else
                                      title_span)
                                   ,#(if (contains? (quote control_bar_elements) declared_allocations)
                                         (progn
                                            (prop (prop allocations (index_of (quote control_bar_elements) declared_allocations)) 1))
                                         []))
                                  nil))
              (do_render (fn ()
                            (let
                               ((new_view (render self)))
                               (if (and new_view
                                        (not (== content_view new_view)))
                                   (-> content_view `replaceChildren new_view))
                               (if _on_render
                                   (_on_render self)))))
              (resize_observer (new ResizeObserver resize))
              (view (control_frame (to_object
                                       [[`id id]
                                        [ `style ,#(or control_options.frame_style nil)]
                                        [`events ,#control_options.events ]])
                     (if ,#control_bar?
                         control_status
                         [])
                     content_view))
              
              (_on_render (fn ()
                             ,#(if (contains? (quote on_render) declared_allocations)
                                `(on_render self)
                                nil)))
                             
              (_on_focus (fn ()                           
                           (progn
                            ,#(if control_bar?
                                `(add_class "juno-focused" control_status)
                                `[])
                            ,#(if (contains? (quote on_focus) declared_allocations)
                                `(on_focus self)))))
                                  ,
              (_on_destroy (fn ()                                     
                             (progn
                              ,#(if (contains? (quote on_destroy) declared_allocations)
                                  `(on_destroy self)
                                  `true))))
              
              (_to_json (function ()
                           (progn
                              ,#(if (contains? (quote to_json) declared_allocations)
                                    `(to_json)
                                    `[(quote ,#name) ,@control_args options]))))
              (initialize (function ()
                             (progn
                                (when (and view.parentElement
                                           (not initialized))
                                   (= initialized true)
                                   (-> resize_observer `observe view.parentElement)                                   
                                   ,#(if (contains? (quote on_initialize) declared_allocations)
                                         `(on_initialize self)
                                         true)
                                   (do_render))))))
             (set_prop options
                `id id
                `name name)
             ,@(when (is_array? control_options.expose)
                  (for_each (method_set control_options.expose)
                     (destructuring_bind (method_name method_reference)
                        method_set
                     `(set_prop self
                         ,#method_name ,#method_reference))))
             ,#(if (contains? (quote menu_items) declared_allocations)
                   `(set_prop self
                       `menu_items menu_items)
                   [])
             ,#(if control_bar?
                  `(set_prop self
                      `show_control_bar 
                      (fn (state)
                         (progn
                            (if state
                               (remove_class "juno-display-none" control_status)
                               (add_class "juno-display-none" control_status))
                            (resize))))
                  `[])
             ;; finally set the required self options
             (set_prop self
                `options options
                `name name
                `type ,#(desym_ref name)
                `view view
                `resize resize                
                `initialize initialize
                `toJSON _to_json
                `on_destroy _on_destroy
                `on_focus _on_focus)
             ;; and return the self
             self)
          ,#meta))
   {
       `description: (+ "The macro defcontrol creates a function in the current namespace that implements the specified "
                        "control features passed to the macro.  The macro handles most of the boiler plate for a basic "
                        "control, combining the passed allocations and options to produce a standardized control "
                        "constructor.  The macro is similar in shape to a defun+let form with some differences.<br><br>"
                        "Like the defun macro, the first argument provides the name of the control that it will be used " 
                        "to construct the name and type of the control.  Also similar to defun, the second argument is "
                        "an array containing any arguments for the control.  Note that, mandatorily, an options argument "
                        "will be appended as the last argument of the argument list, so an empty array passed will "
                        "cause the control only to have an options argument.<br><br>"
                        "The next argument is a series of allocation forms that are integrated into a let allocation "
                        "structure, and so should be in the same form as the allocation block of the let operator.  For "
                        "example, ((render (fn () (div { } \"My View\")))) would meet the minimal requirement for a "
                        "control to be constructed.  The caller of this macro can have as many allocation forms as needed "
                        "to implement the required behavior of the emitted control.  To note that there are "
                        "symbols that made available to these provided forms in the evaluation context of the form that "
                        "can be referenced and used by the user provided forms:<br>"
                        "self:object - The interface object returned.<br>"
                        "content_view:Element - The control's view (not including the control_bar.  Effectively the contents of "
                        "the control view.<br>"
                        "do_render:function - Calls the (render) function provided to the macro.  User code can call this "
                        "function when a redraw is required.<br>"
                        "initialized:boolean - This value is true if the function is initialized or false if it hasn't " 
                        "yet been.<br>"
                        "options:object - The options object passed to the control on instantiation.<br>"
                        "<br><br>"
                        "There are multiple functions that are called upon certain events, which allow the caller to build "
                        "customized behavior and hook into the system when needed.  These functions are specified in the "
                        "allocation forms provided to the macro and are all optional except for render:<br>"
                        "render:function - This function returns the DOM structure assigned to content_view and is what is "
                        "drawn in the control's content container.  If the function returns nil, nothing is done.  Can be "
                        "used in conjunction with the on_render below, which acts on the already drawn view.<br>"
                        "on_focus:function - When a focusing event occurs to the control, this function is called with the "
                        "self object of the macro.<br>"
                        "on_render:function - If this function is specified it will act as the render function so as to "
                        "manipulate an already built view, via the content_view in scope symbol, which is the contents of the "
                        "controls view.<br>"
                        "on_resize:function - A resize function to invoke if a forced resize is required.<br>"
                        "control_bar_elements:array - If the control is specified with the control_bar control_options set to "
                        "true, the Elements in this array will be placed into the control bar after any runtime additional_elements "
                        "provided to the options object.<br>"
                        "menu_items:function - A function that is called on demand that should return an array containing "
                        "pairs of [menu_text menu_function] that implement any command functionality for the menu.<br>"
                        "on_destroy:function - When the control receives a destroy call, this user provided function will be "
                        "called with the self object.<br>"
                        "on_initialize:function - Upon initialization, this function will be called with the self function. It "
                        "should be expected that the initialization should be called only once for a control lifespan.<br>"
                        "to_json:function - This synchronous function call can be used to provide a customization hook "
                        "for the control.  The return value must be a structure that can be serialized into JSON form.<br><br>"
                        "The final object, control_options is meta data and other flags for the macro:<br>"
                        "expose:array - An array of pairs that specify [ `function_handle function_to_call ] that are placed "
                        "on the self interface and provide the API for the control.  In order for a resource in the control "
                        "scope to be accessed, it must be specified in this option, otherwise the function remains effectively "
                        "private to the control.<br>"
                        "usage:array - The argument specification for the macro"
                        "description:string - The description of the control that is registered in the Environment.<br>"
                        "control_bar:boolean - If a control bar is to be displayed on the top of the control, set this to "
                        "true.<br>"
                        "frame_style:string - Any custom style attributes to apply to the control frame.  These "
                        "should be formatted in the CSS manner: eg.  \"overflow: hidden;\"")
       `usage: ["name:symbol" "control_arguments:array" "allocations:array" "control_options:object"]
       `tags: ["control" "define" "controls" "ui"]
   })


(defun recalc_names_for_path (path_to_value)
   (let
      ((ctls (get_editors_for_path path_to_value)))
      (for_each (ctl ctls)
         (when ctl.recalculate_name
            (-> ctl `recalculate_name)))))

;; manages the` destruction of editors that are interested in the same path
;; one of them is the primary, the rest of them will be linked to their ids







(defun get_primary_editor_in_group (controls)
   (let
      ((primaries (reduce (editor (or controls []))
                      (when (not (-> editor `get_linked))
                         editor))))
      (first primaries)))

(defun get_editors_for_filename (filename)
   (when (is_string? filename)
      (reduce (control (current_controls))
         (when (and control
                    control.editor
                    control.options.filename
                    (== control.options.filename filename))
            control))))
   

(defun rename_editor_group (path)
   (try 
      (let
         ((editors (get_editors_for_path path))
          (primary_id nil)
          (primary (reduce (editor (or editors []))
                      (when (not (-> editor `get_linked))
                         editor))))
         (assert (not (> primary.length 1)) "rename_editor_group: multiple primary editors. This is a bug.")
         (= primary (first primary))  ;; take the primary editor or nil 
         (cond 
            (== editors.length 0)
            true ;; nothing for us to do
            (== editors.length 1)
            (progn
               (-> (first editors) `set_unlinked)
               (-> (first editors) `set_name (-> (first editors) `group_name) true))
            else
            (progn
               (unless primary                ;; unless we already have a primary...
                  (= primary (take editors))) ;; take the first editor and make it the primary
               (= primary_id primary.options.id)
               (-> primary `set_name (-> primary `group_name) true)
               (-> primary `set_unlinked)
               (for_each (editor editors)
                  (when (not (== editor primary))
                     (-> editor `set_linked primary.options.id)
                     (-> editor `set_name (-> primary `group_name)))))))
      (catch Error (e)
         (log "rename_editor_group: error: " e.message))))

(defun clone_text_editor_control (editor_control)
   (let
      ((id editor_control.options.id)
       (new_name (if editor_control.group_name
                     (-> editor_control `group_name))))
      (declare (function text_editor)
               (global text_editor))
      (assert new_name "clone_text_editor_control: unable to get group name of the editor to clone")
      (when (and editor_control.editor id)
         (alert_on_error "Unable to clone the editor"
                         (text_editor (+ {} ;; start options 
                                         editor_control.options ;; take existing options..
                                         { `id: (gen_id "text_editor")
                                           `clone_with_editor_id: id }))))))

(defun select_evaluator ()
  (let
      ((idx -1)
       (dups (new Set))
       (new_name nil)
       (selected_idx nil)
       (available (reduce (control (flatten (control_tree $root_controls)))
                          (when control.evaluate
                            (if (-> dups `has (or control.name "Untitled"))
                              (progn
                               (= new_name (+ (or control.name "Untitled")
                                             "-" idx))
                               (-> dups `add new_name)
                               [ (inc idx) new_name
                                 control ])
                              (progn
                               (-> dups `add control.name)
                               [ (inc idx) control.name control ])))))
       (selection_box (select { }
                              (map (fn (v)
                                     (option { `value: v.0 } v.1))
                                     (or available [])))))
    (= selected_idx
       (request_user_input (dtext "Select an available evaluator")
                           nil
                           { input: selection_box }))
    (when selected_idx
        (prop (prop available selected_idx) 2))))

(defun text_editor (options)
   (aif (and (not options.clone_with_editor_id)
             (get_control_by_name options.name))
        it
        (let
           ((options (+ {}  ;; default is an empty code editing buffer for lisp
                         { mode: "juno" 
                           id: (generate_id "text_editor")   ;; id can be provided and will overide this generated ID 
                           content: "" }
                         (if (is_object? options)
                            options
                            (progn
                               (notify "Invalid options object provided to editor - check config")))))
            (resize_observer nil)
            (group_name nil)
            (intf {})
            (initialized false)
            (config_value (function (key default_value)
                             (or (prop options key)
                                 (resolve_path [ `editor key ] *env_config*)
                                 default_value)))
            (buffer_commands_button (commands_button options.id))
            (evaluator_span (span { `class: "juno-evaluator" `title: (dtext "Name of the evaluator assigned to this buffer") } "-"))
            (nav_back_button (button { `title: (dtext "Go back to previous line position history") `style: "float: right" } "<"))
            (nav_forward_button (button { `disabled: true `title: (dtext "Go forward in line position history") `style: "float: right" } ">"))
            ;; if we have a namespace in options use that for referencing paths 
            (nseval (if (not (blank? options.namespace))   
                        (-> Environment `get_namespace_handle options.namespace)
                        Environment))  
            (is_dirty? false)
            (col_pos_span (span { `title: "Position (Row Column)" `style: "float: right;margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } "[0 0]"))
            (locked_span (span { `title: (dtext "Read Only?") `style: "display: inline-block; width: 20px;padding-left: 5px; padding-right: 5px;" } 
                               (if options.read_only
                                        "RO"
                                        "")))
            (mode "-")
            (mode_span (span { `class: "juno-mode" `title: "Current Editing Mode" `style: "float: right; margin-right: 15px; display: inline-block; padding-left: 5px; padding-right: 5px;" } mode))
            (title_span (span { `class: "juno-title" } options.name))
            (control_bar (or options.control_bar
                             (div { `class: "juno-buffer-bar" }
                                  buffer_commands_button
                                  title_span
                                  (span { `title: "Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } nseval.namespace)
                                  evaluator_span
                                  locked_span
                                  nav_forward_button
                                  nav_back_button
                                  mode_span
                                  col_pos_span)))
            (parent_view nil)
            (context_clear_timer nil)
            (display_context_message (function (value)
                                        (if (and (blank? value)
                                                 context_clear_timer)
                                            nil
                                            (progn
                                               (when context_clear_timer
                                                  (clearTimeout context_clear_timer))
                                               (= context_clear_timer nil)
                                               (when (not (blank? value))
                                                  (= context_clear_timer (setTimeout (fn () (= context_clear_timer nil)) 3000)))  ;; delay for clearing the message to quickly if a blank comes in
                                               (cond
                                                  (is_element? value)
                                                  (-> help_context_elem
                                                     `replaceChildren value)
                                                  else
                                                  (-> help_context_elem
                                                     `replaceChildren (span { `style: "display: inline-block; text-overflow: ellipsis; width: 100%; overflow: hidden" } (+ "" value))))))))
            (check_observer (fn ()
                               (when (not (== view.parentElement parent_view))
                                  (-> resize_observer `disconnect)
                                  (-> resize_observer `observe view.parentElement)
                                  (= parent_view view.parentElement))))
            
            (help_context_elem (div { `class: "juno-help-context" } ""))
            (context_bar (div { `class: "juno-context-bar" }
                              help_context_elem))
            (offset_depth 46)
            (editor_div (div { `class: "opacity-0" `style: (+ "height: calc(100% - " offset_depth  "px); width: 100%; overflow: hidden;font-family:var(--main-mono-space);") }))
            
            (view (div { `control_id: options.id `style: "overflow: hidden; height: calc(100% - 10px); display: inline-block; width: inherit;" }
                       control_bar
                       editor_div
                       context_bar))
            (evaluator nil)
            (perform_resize (fn ()
                               (when view.parentElement
                                  (check_observer)
                                  (html/set_style [["width" "calc(100% - 2px)"];           (+ "" (- (prop view.parentElement `offsetWidth) 2) "px")]
                                                   ["height" (+ "" (- (prop view.parentElement `offsetHeight) 2) "px")]]
                                                  view)
                                  (set_style [["height" (+ "calc(100% - " (+ (Math.max 0 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] editor_div)
                                  (when editor
                                     (-> editor `resize)))))
            
            (editor nil)  ;; the editor object
            (set_read_only (fn (read_only?)
                              (progn
                                 (-> editor `setReadOnly read_only?)
                                 (if read_only?
                                    (set_prop locked_span
                                       `innerText 
                                       (dtext "RO"))
                                    (set_prop locked_span
                                       `innerText 
                                       (dtext ""))))))
            (set_evaluator (fn (evaluator_function)
                              (when evaluator_function
                                 (= evaluator evaluator_function)
                                 (dispatch_event { command: "editor_change"
                                                   source: options.id
                                                   args: [ { `option: "evaluator" `value: evaluator_function } ] })
                                 (aif (get_keybinding "editor" "evaluate_selection")
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (-> editor.commands `addCommand
                                         {
                                           `name: "evaluate_selection"
                                           `bindKey: { `win: "Shift-Enter" `mac: "Shift-Enter" }
                                           `exec: evaluate_selection
                                           })))))
            (set_mode (fn (mode_name)
                         (progn
                            (defvar identifier_regex (new RegExp "[A-Za-z*+0-9_\\$\\u00A2-\\uFFFF]+"))
                            (set_prop options
                               `mode
                               mode_name)
                            (cond
                               (== options.mode "juno")
                               (progn
                                  (console.log "mode to juno")
                                  (-> editor.session `setMode "ace/mode/juno")
                                  (-> editor `setOptions {
                                                           `enableBasicAutocompletion:  [{ identifierRegexps: [ identifier_regex ]
                                                                                                             getCompletions: (fn (editor session pos prefix callback)
                                                                                                                                (get_juno_autocompletions editor session pos prefix callback)) }]
                                                           enableLiveAutocompletion: true
                                                           enableSnippets: true
                                                           }))
                               (== options.mode "javascript")
                               (progn
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })
                                  (-> editor.session `setMode "ace/mode/javascript"))
                               (== options.mode "css")
                               (progn
                                  (-> editor.session `setMode "ace/mode/css")
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true }))
                               options.mode
                               (progn
                                  (-> editor.session `setMode options.mode)
                                  (-> editor `setOptions {
                                                           `enableLiveAutocompletion: true
                                                           `enableBasicAutocompletion: true })))
                            
                            (set_prop mode_span
                               `innerText
                               options.mode)
                            (dispatch_event { command: "editor_change"
                                              source: options.id
                                              args: [ { `option: "mode" `value: options.mode } ] })
                            (when options.on_mode_set
                               (options.on_mode_set mode_name)))))
            
            (set_theme (fn (theme_name)
                          (progn
                             (-> editor `setTheme (+ "ace/theme/" theme_name))
                             (set_prop options
                                `theme
                                theme_name)
                             (dispatch_event { command: "editor_change"
                                               source: options.id
                                               args: [ { `option: "theme" `value: theme_name } ] })
                             (when options.on_theme_set
                                (options.on_theme_set theme_name)))))
            
            (set_overscroll (fn (state)
                                    (if state
                                       (progn
                                          (-> editor `setOption `scrollPastEnd true)
                                          (set_prop options
                                             `overscroll
                                             true)
                                          true)
                                       (progn
                                          (-> editor `setOption `scrollPastEnd false)
                                          (set_prop options
                                             `overscroll
                                             false)
                                          false))))
            
            (set_name (fn (new_name force)
                              (progn
                                 ;; if we are not already called the new name go ahead and process the new name
                                 (when (and (not (blank? new_name))
                                            (not (== (get_control_by_name new_name) intf)))
                                    (set_prop options
                                       `name
                                       (if force
                                          new_name
                                          (compute_name_for_control new_name)))
                                    (set_prop intf
                                       `name
                                       options.name)
                                    (dispatch_event { command: "editor_change"
                                                      source: options.id
                                                      args: [ { `option: "name" `value: options.name } ] }))
                                 (set_prop title_span
                                    `innerText
                                    options.name)
                                 options.name)))
            
            (evaluate_selection (function (editor)
                                   (let
                                      ((rval nil)
                                       (copytext (if options.repl_mode
                                                     (-> editor `getValue)
                                                     (-> editor `getCopyText))))
                                      (if (blank? copytext)
                                          (if (not options.repl_mode)
                                              (display_context_message (dtext "Please highlight text to evaluate")))
                                          (try
                                             (progn
                                                (= rval (evaluator copytext nil (not options.repl_mode)))
                                                (-> rval `then
                                                   (function (val)
                                                      (progn
                                                         (try
                                                            (and options.on_evaluation
                                                               (-> options `on_evaluation copytext val))
                                                            (catch Error (e)
                                                               (log_error (+ "" options.name ": Received error from on_evaluation")
                                                                          e)))
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof val Error)
                                                                           (display_context_message (+ (subtype val)
                                                                                                       (if val.message (+ ":" val.message)
                                                                                                           "")))
                                                                           (is_function? val)
                                                                           (display_context_message (+ "<- " (subtype val)))
                                                                           else
                                                                           (progn
                                                                              (defvar chopped (as_lisp val))
                                                                              (if (> chopped.length 200)
                                                                                  (= chopped (+ (-> chopped `substr 0 200) "...")))
                                                                              (display_context_message (+ "<- " chopped)))))
                                                                     100)))
                                                   (function (e)
                                                      (progn
                                                         (notify "Failure on evaluation")
                                                         (setTimeout (fn ()
                                                                        (cond
                                                                           (instanceof e Error)
                                                                           (display_context_message (+ (subtype e)
                                                                                                       (if e.message (+ ":" e.message)
                                                                                                           "")))
                                                                           else
                                                                           (display_context_message "Evaluation Failure")))
                                                                     100)))))
                                             (catch Error (e)
                                                (progn
                                                   (notify (+ (dtext "Unhandled error") ": " e.message ))
                                                   (console.error e))))))))
            
            (font_size (config_value `font_size 14))
            (increase_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.min 200 (+ font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size))))
            (decrease_font_size (function ()
                                   (when font_size
                                      (= font_size (Math.max 1 (- font_size 1)))
                                      (set_prop options
                                         `font_size font_size)
                                      (console.log "editor: options: " options)
                                      (-> editor `setFontSize font_size))))
            (select_form_root (fn ()
                                 (progn
                                    (select_to_root_form editor)
                                    nil)))
            (evaluate_root_form (fn ()
                                   (let
                                      ((cpos (current_position)))
                                      (select_form_root)
                                      (evaluate_selection editor)
                                      (sleep 0.02)
                                      (-> editor.selection `clearSelection)
                                      (-> editor `navigateTo cpos.row cpos.column)
                                      )))
            
            (select_current_form (fn ()
                                    (select_to_current_form editor)))
            (get_selected_text (function ()
                                  (-> editor `getSelectedText)))
            (get_selection_object (function ()
                              (-> editor.selection `getRange)))
            (get_lines (function (from to)
                          (-> editor.selection `getLines from to)))
            (is_selected? (function ()
                             (progn
                                (defvar rng (get_selection_object))
                                (not (and (== rng.start.row rng.end.row)
                                          (== rng.start.column rng.end.column))))))
            (last_bracket_match nil)
            (active_lisp_operator nil) ;; the last active lisp operator
           
            (find_active_lisp_operator (function ()
                                          (let
                                             ((new_op nil)
                                              (rnge (or (-> editor.session `getBracketRange (-> editor `getCursorPosition))
                                                        (find_last_paren editor)))
                                              (usage nil))
                                             (if rnge
                                                (progn
                                                   (= last_bracket_match rnge)
                                                   (= new_op (first (split_by *whitespace_regexp* (-> editor.session `getTextRange last_bracket_match))))
                                                   
                                                   (when (not (== new_op active_lisp_operator))
                                                      (= active_lisp_operator new_op)
                                                      (= usage (decorative_usage active_lisp_operator))
                                                      (if usage
                                                         (-> help_context_elem
                                                            `replaceChildren usage)
                                                         (-> help_context_elem `replaceChildren))
                                                      (when usage
                                                         (dispatch_event { `command: "display_usage" `source: options.id `args: [active_lisp_operator] }))
                                                      (when options.on_new_lisp_operator
                                                         (options.on_new_lisp_operator active_lisp_operator))))
                                                (progn
                                                   (= active_lisp_operator nil)
                                                   (-> help_context_elem
                                                      `replaceChildren)
                                                   (when options.on_new_lisp_operator
                                                      (options.on_new_lisp_operator nil)))))))
            
            (indent_row (function (row_number options)
                           (indent_editor_line editor row_number options)))
            
            (indent_current_row (function (editor)
                                   (when (== *last_focus* intf)
                                      (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                         (if (not (is_selected?))
                                             (progn
                                                (defvar row_number (prop (-> editor `getCursorPosition)
                                                                         `row))
                                                (console.log "tab: start: single line: " row_number)
                                                (indent_row row_number { `apply: true }))
                                             (indent_editor_selection editor))))))
            
            (bind_key (fn (key_command func)
                         (aif (get_keybinding "editor" key_command)
                              (progn
                                 (-> editor.commands `addCommand
                                    (to_ace_keybinding key_command it func))))))
            
            ;; signal ready for saving
            (request_save (function ()
                             (progn
                                (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] }))))
            
            ;; handle the results of the save
            (save_complete (function (event_obj)
                              (progn
                                 (if options.create_mode
                                    (delete_prop options `create_mode))
                                 (display_context_message (+ "Saved " (cond
                                                                         (and (== event_obj.args.0.type "path")
                                                                              (is_array? event_obj.args.0.target))
                                                                         (join "~" event_obj.args.0.target)
                                                                         (== event_obj.args.0.type "filename")
                                                                         event_obj.args.0.target)))
                                 (log "editor: save_complete: " (clone event_obj))
                                 (remove_class "juno-needs-save" title_span)
                                 (delete_prop options `create_mode)
                                 (= is_dirty? false)
                                 (when options.on_save
                                    (-> options `on_save intf)))))
            (split_editor (fn (dir)
                             (let
                                ((new_editor nil))
                             (cond
                                (== dir "vertical")
                                (progn
                                   (= new_editor (clone_text_editor_control intf))
                                   (alert_on_error "Unable to split"
                                                   (container_view_operation "split_right" intf new_editor)))
                                (== dir "horizontal")
                                (progn
                                   (= new_editor (clone_text_editor_control intf))
                                   (alert_on_error "Unable to split"
                                                   (container_view_operation "split_below" intf new_editor)))
                                else
                                (alert_box "Invalid Split Request" "Split commands  must be vertical or horizontal")))))
            ;; position tracking 
            (position_history [])
            (position_history_idx 0)
            (current_position (fn ()
                                  (-> editor `getCursorPosition)))
            (set_cursor_position (fn (pos)
                                    (progn
                                       (-> editor `navigateTo pos.row pos.column)
                                       (-> editor `scrollToLine pos.row true nil))))
            (update_position (function ()
                                (when editor
                                   (defvar current_pos (-> editor `getCursorPosition))
                                
                                   (set_prop col_pos_span
                                      `innerText
                                      (+ "[" current_pos.row " " current_pos.column "]"))
                                   (set_prop options `cursor_position current_pos)
                                   
                                   ;; record our position history so we can go back 
                                   ;; if we are less then 8 rows difference, then 
                                   ;; update it, otherwise push it onto the stack
                                   (try
                                      (progn
                                         (when (isNaN position_history_idx)
                                             (log "text_editor: update_position: position_history_idx isNaN!")
                                             (= position_history_idx (- position_history.length 1))
                                             (set_disabled nav_forward_button))
                                         (defvar last_pos (prop position_history position_history_idx))
                                         
                                         (if (> (Math.abs (- current_pos.row (prop last_pos `row)))
                                                8)
                                            (progn
                                               (inc position_history_idx)
                                               (-> position_history `splice position_history_idx 0 current_pos)
                                               ;(log "update_position: recorded position" position_history_idx (prop last_pos `row) (Math.abs (- current_pos.row (prop last_pos `row))))
                                               (when (> position_history.length 40)
                                                  (take position_history)
                                                  (= position_history_idx (clamp position_history_idx 0 position_history.length))))
                                                  
                                            (progn
                                               (-> position_history `splice position_history_idx 1 current_pos))))
                                      (catch Error (e)
                                         (log "ERROR on position history update: " e.message))))))
            (go_backward_in_position (fn ()
                                        (progn
                                           (= position_history_idx (Math.max 0 (- position_history_idx 1)))
                                           (set_enabled nav_forward_button)
                                           (set_cursor_position (prop position_history position_history_idx)))))
            (go_forward_in_position (fn ()
                                        (progn
                                           (= position_history_idx (Math.min (- position_history.length 1) (+ position_history_idx 1)))
                                           (when (== position_history_idx (- position_history.length 1))
                                              (set_disabled nav_forward_button))
                                           (set_cursor_position (prop position_history position_history_idx)))))
                                           
            (on_focus (fn ()
                         (progn
                            (when (not (== *last_focus* intf))
                               (focus_to intf.editor))
                            (setq *last_focus* intf)
                            (add_class "juno-focused" control_bar))))
            
            (orig_bindings nil)
            (build_key_bindings (fn (editor)
                                   (progn
                                      (console.log "building_key_bindings")
                                      ;; we need to remove any keybinding that interferes with our globals and then
                                      ;; rebuild to the right scope
                                      (= orig_bindings (clone (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor)))
                                      ;(defglobal *orig_key_bindings* orig_bindings)
                                      (when options.on_save
                                         (bind_key "on_save" request_save))
                                      (bind_key "increase_font_size" increase_font_size)
                                      (bind_key "decrease_font_size" decrease_font_size)
                                      (bind_key "select_form_root" select_form_root)
                                      (bind_key "select_current_form" select_current_form)
                                      (bind_key "indent_current_row" indent_current_row)
                                      (bind_key "evaluate_selection" evaluate_selection)
                                      (bind_key "evaluate_root_form" evaluate_root_form)
                                      (bind_key "evaluate_selected_in_place" (fn (editor)
                                                                                (progn
                                                                                   (setTimeout (fn ()
                                                                                                  (try
                                                                                                     (progn
                                                                                                        (defvar rval (eval_selected_text_in_place (get_control_by_editor editor)))
                                                                                                        true)
                                                                                                     (catch Error (e)
                                                                                                        (display_context_message "Error on evaluation: " e.message))))
                                                                                               10)
                                                                                   true)))
                                      
                                      (when (is_array? options.commands)
                                         (for_each (command options.commands)
                                            (do
                                               (console.log "optional commands: " command.name command)
                                               (-> editor.commands `addCommand
                                                  (to_ace_keybinding command.name command)))))
                                      true)))
            
            (linked_editor_name nil)
            (linked_editor nil)
            (data_type nil)
            (data_type_defaults { String: "" 
                                     array:[] 
                                     object: {} })
            ;; based on the contents of the options object set the editor's content 
            (set_content (fn ()
                            (let
                               ((content nil))
                               (if options.data_type
                                  (if (eq undefined (prop data_type_defaults options.data_type))
                                      (throw TypeError (+ "Invalid data_type specified: must be either: " (join ", " (keys data_type_defaults))))))
                               (cond
                                  ;; do we have a filename?
                                  (and (is_string? options.filename)
                                       is_served?)
                                  (try
                                     (progn
                                        ;(log "text_editor: requesting file: " options.filename)
                                        (if options.create_mode
                                           (= content "")
                                           (= content (-> (fetch (+ "/files/" options.filename)) `text)))
                                        
                                        (if (is_string? content)
                                            (progn
                                               
                                               (-> editor `setValue content -1))
                                            (progn
                                               (-> editor `setValue "")
                                               (= content "")
                                               (display_context_message (+ "NOTICE: unable to fetch file: " options.filename " (editor set to local value)"))))
                                        (set_prop options 
                                           `path
                                           (conj [ `filesystem ] (split_by "/" options.filename))))
                                        
                                     (catch Error (e)
                                        (progn
                                           (-> editor `setValue "")
                                           (= content content)
                                           (display_context_message (+ "ERROR on fetching: " options.filename " (editor set to local value)  " e.message))
                                           (log "Error on fetching file: " options.filename ": " e)
                                           (set_prop options 
                                              `path
                                              (conj [ `filesystem ] (split_by "/" options.filename))))))
                                  
                                  ;; if we are given a filename, but we are not online we can't edit it
                                  ;; if we have previous content we can edit off line, but with a notice to the user 
                                  (and (is_string? options.filename)
                                       options.content)
                                  (progn
                                     (-> editor `setValue options.content -1)
                                     (= content options.content)
                                     (alert_box "Warning: Using cached content"
                                                (div { `style: "" }
                                                     (dtext "The application isn't online, so the specified content cannot be fetched.")
                                                     (dtext "The last stored value is being used, but this may not match the remote content.")
                                                     (br)
                                                     (dtext "Information loss could occur if this editor's contents are subsequently saved to the server.")
                                                     (dtext "Be careful!")))
                                     (set_prop options 
                                           `path
                                           (conj [ `filesystem ] (split_by "/" options.filename)))
                                     (display_context_message (+ "Warning: Cached value of an online file")))
                                  (is_array? options.path)
                                  (progn
                                     (= content (resolve_path options.path nseval.global_ctx.scope))
                                     (when (eq nil content)
                                        (= content (or options.content 
                                                       (and options.data_type
                                                            (prop data_type_defaults options.data_type))
                                                       ""))
                                        (make_path options.path nseval.global_ctx.scope content)
                                        (display_context_message (+ "New path: " (join "~" options.path) " with content type " (sub_type content))))
                                     (if (not (== "String" (sub_type content)))
                                         (-> editor `setValue (pretty_print content))
                                         (-> editor `setValue content -1)))
                                  (is_string? options.content)
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue content -1))
                                  (or (is_object? options.content)
                                      (is_array? options.content))
                                  (progn
                                     (= content options.content)
                                     (-> editor `setValue (pretty_print content))))
                               (assert (is_value? content) "assertion failure: content is not set in set_content")
                               (= data_type
                                  (sub_type content))
                               (set_prop options
                                  `data_type
                                  data_type)
                               ;; at this point content should be loaded and displayed and 
                               ;; data_type should be properly set for the content that
                               ;; is being edited
                               options)))
            (set_display_control_bar (fn (state)
                                        (progn
                                           (if state
                                              (remove_class "juno-display-none" control_bar)
                                              (add_class "juno-display-none" control_bar))
                                           (perform_resize))))
            (set_evaluator_control (fn (control)
                                      (if control.evaluate
                                         (progn
                                            (set_evaluator control.evaluate)
                                            (set_prop options
                                               `evaluator_id
                                               control.options.id)
                                            (if control.name
                                               (set_prop evaluator_span
                                                  `innerText
                                                  (+ "⭢ " control.name)))))))
            (menu_items (function ()
                                [(if options.path
                                  [(+ (dtext "Save to") " " (last options.path))
                                   (fn (e) (request_save))]
                                  [])
                                 [(dtext "Split Vertically") 
                                  (fn (e)
                                     (split_editor `vertical)) ]
                                 [(dtext "Split Horizontally")
                                  (fn (e)
                                     (split_editor `horizontal))]
                                 [(dtext "Select Evaluator")
                                   (fn (e)
                                      (progn
                                         (aif (select_evaluator)
                                              (progn
                                                 (set_evaluator_control it)
                                                 (notify (+ (dtext "Evaluator set to ") it.name))))))]
                                 
                                 [(dtext "Increase Font Size") increase_font_size]
                                 [(dtext "Decrease Font Size") decrease_font_size]
                                 (if (-> editor `getReadOnly)
                                     [ (dtext "Allow Editing" ) (fn () (-> intf `set_read_only false)) ]
                                     [ (dtext "Set Read-Only Mode") (fn () (-> intf `set_read_only true)) ])
                                 [(dtext "Set Edit Mode")
                                  [["Juno" (fn () (-> intf `set_mode "juno"))]
                                   ["Javascript" (fn () (-> intf `set_mode "javascript")) ]
                                   ["Text" (fn () (-> intf `set_mode "text"))]
                                   ["CSS" (fn () (-> intf `set_mode "css"))]
                                   ["JSON" (fn () (-> intf `set_mode "json"))]]]
                                 [(dtext "Set Editor Theme") 
                                  (for_each (theme *editor_themes*)
                                         [theme  (fn () (-> intf `set_theme theme))])]]))

            ;; main initialization routine
            (initialize_editor (fn ()
                                  (when (not initialized)
                                     (let
                                        ((comps nil)
                                         (content nil)
                                         (start_time (time_in_millis))
                                         (extension nil))
                                        (setq initialized true)
                                        (setq parent_view view.parentElement)
                                        (setq editor
                                           (ace.edit editor_div))
                                        
                                        ;(log "initialize_editor: " options.mode " options: " (clone options))
                                        
                                        ;; ensure that the Ace language tools extension is loaded
                                        
                                        (defglobal LangTools (-> ace `require "ace/ext/language_tools"))
                                        
                                        ;; if we are not explicitly told to link to another editor...
                                        ;; we need to check to ensure we are not editing a path or file that is already
                                        ;; open by another editor.
                                        
                                        ;; is there already an editor with the same path or filename?
                                        ;; if so, become a linked editor to it
                                        
                                        (when (not options.clone_with_editor_id)
                                           (cond
                                              (and options.path
                                                 (> (get_editors_for_path options.path) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path options.path)))
                                                 (assert primary "initialize_editor: BUG: multiple editors for path but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))
                                              (and options.filename
                                                 (> (get_editors_for_filename options.filename) 0))
                                              (progn
                                                 (defvar primary (get_primary_editor_in_group (get_editors_for_path (get_editors_for_filename options.filename))))
                                                 (assert primary "initialize_editor: BUG: multiple editors for filename but no primary found!")
                                                 (set_prop options
                                                    `clone_with_editor_id
                                                    primary))))
                                           
                                           
                                        ;; are we a cloned editor?
                                        
                                        (when options.clone_with_editor_id
                                           (let ((control_to_clone (get_control_by_id options.clone_with_editor_id))
                                                 (new_session nil))
                                              (if (eq nil control_to_clone)
                                                  (log "editor: cannot find editor to clone, id: " options.clone_with_editor_id))
                                              (when (and control_to_clone
                                                         control_to_clone.editor)
                                                 (= new_session (clone_edit_session control_to_clone.editor.session))
                                                 (= linked_editor control_to_clone.options.id)
                                                 (= linked_editor_name control_to_clone.options.name)
                                                 (-> editor `setSession new_session))))

                                        ;; behavior setup for the actual editor component
                                        (when options.on_focus
                                           (-> editor `on `focus options.on_focus))
                                        (when options.on_blur
                                           (-> editor `on `blur options.on_blur))
                                        (when options.read_only
                                           (-> editor `setReadOnly true))
                                        (when options.on_click
                                           (-> editor `on `click options.on_click))
                                        (unless linked_editor
                                           (-> editor.session `setUseSoftTabs true)
                                           (-> editor.session `setUseWorker true)
                                           (-> editor.session `setUseSoftTabs true))
                                        
                                        (-> editor `setShowFoldWidgets true)
                                        
                                        ;; set the extension if we haven't been given a specific option mode
                                        ;; if we have filename use that to determine what the mode is
                                        
                                        (when (and (eq nil options.mode)
                                                   (is_string? options.filename))
                                           (= comps (split_by "." options.filename))
                                           (when (> comps.length 1)
                                              (= extension (edit_mode_for_extension (last comps)))
                                              (set_prop options
                                                 `mode
                                                 extension)))
                                        
                                        (set_mode options.mode)
                                        
                                        ;; set the theme for the new editor
                                        (cond
                                           (is_string? options.theme)
                                           (setTimeout (fn () (progn
                                                              (-> intf `set_theme options.theme)
                                                              (remove_class "opacity-0" editor_div))) 50)
                                           else
                                           (aif (resolve_path [ `editor `default_theme ] *env_config*)
                                                (setTimeout (fn ()
                                                               (progn
                                                                  (-> intf `set_theme it)
                                                                  (remove_class "opacity-0" editor_div))) 50)))
                                        
                                        ;; build the key bindings
                                        (build_key_bindings editor)
                                        
                                        (-> editor `setOptions {
                                                                 `showFoldWidgets: true
                                                                 `cursorStyle: "wide"
                                                                 `firstLineNumber: (or options.first_line_number 0)
                                                                 `useSoftTabs: true
                                                                 `highlightActiveWord: true
                                                                 })
                                        
                                        ;; if this editor is primary, and not linked to another editor,
                                        ;; get the content from the specified source or path
                                        (if (not linked_editor)
                                            (set_content))
                                               
                                        (cond 
                                           (and options.clone_with_editor_id
                                              (get_control_by_id options.clone_with_editor_id))
                                           (progn
                                              (defvar primary (get_control_by_id options.clone_with_editor_id))
                                              (when primary.group_name
                                                 (set_prop options
                                                    `group_name
                                                    (-> primary `group_name))))
                                           (eq nil options.group_name)
                                           (set_prop options
                                              `group_name
                                              (or options.group_name 
                                                          options.name
                                                          (and (is_array? options.path)
                                                               (last options.path))
                                                          (and (is_string? options.filename)
                                                               (last (split_by "/" options.filename)))
                                                          "Untitled Buffer")))
                                        
                                        (set_name options.group_name)
                                        
                                        ;; set up the default font size
                                        
                                        (if (eq nil font_size)
                                            (= font_size (parseInt (-> editor `getFontSize)))
                                            (-> editor `setFontSize font_size))
                                        
                                        (set_prop options
                                           `font_size
                                           font_size)
                                        
                                        ;; default to overscoll mode, but TODO: this should be an global default
                                        (unless (== options.overscroll false)
                                           (-> editor `setOption `scrollPastEnd true))
                                        
                                        ;; load up the token iterator extension...
                                        (defglobal TokenIterator (prop (-> ace `require "ace/token_iterator") `TokenIterator))
                                        
                                        ;; set up change events for hints and contexual help
                                        
                                        (-> editor `on `change (function (val)
                                                                  (progn
                                                                     (add_class "juno-needs-save" title_span)
                                                                     (= is_dirty? true)
                                                                     (when (== (prop (-> editor.session `getMode) `$id) "ace/mode/juno")
                                                                        (when (not linked_editor)
                                                                           (handle_lisp_format_event val editor))
                                                                        (find_active_lisp_operator))
                                                                     (when (not linked_editor)
                                                                        (dispatch_event { command: "editor_change"
                                                                                          source: options.id
                                                                                          args: [ val ] }))
                                                                     (update_position)
                                                                     (when options.on_change
                                                                        (options.on_change editor val)))))
                                        ;; resize
                                        (-> editor `resize true)
                                        ;; reset the undo manager now that th content is loaded
                                        
                                        (unless options.clone_with_editor_id
                                           (try
                                              (aif (-> editor.session `getUndoManager)
                                                   (-> it `reset))
                                              (catch Error (e)
                                                 (log "ERROR on undo manager:" e message))))
                                        
                                        ;; expose the editor in our interface
                                        (set_prop intf `editor editor)
                                        
                                        (when (is_object? options.on_mode_set)
                                           (options.on_mode_set options.mode))
                                        
                                        ;; signal our mode change
                                        
                                        (dispatch_event { command: "editor_change"
                                                          source: options.id
                                                          args: [ { `option: "mode" `value: options.mode } ] })
                                        
                                        ;; scroll speed of the editor
                                        (cond
                                           (is_number? options.scroll_speed)
                                           (set_scroll_speed intf options.scroll_speed)
                                           (is_number? (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                           (progn
                                              ;(log "setting scroll speed: " (resolve_path [ `editor `scroll_speed ] *env_config* ))
                                              (set_scroll_speed intf (resolve_path [ `editor `scroll_speed ] *env_config* )))
                                           else
                                           (set_scroll_speed intf 5))  ;; default scroll speed is 5
                                        
                                        (set_prop options
                                           `scroll_speed
                                           (-> editor `getScrollSpeed))
                                        
                                        ;; when we are linked move to our current position of the other editor
                                        (when linked_editor
                                           (defvar pos (-> (prop (get_control_by_id linked_editor) `editor)
                                                           `getCursorPosition))
                                           (-> editor `navigateTo  pos.row pos.column)
                                           (-> editor `scrollToLine pos.row true nil))
                                        
                                        (push position_history
                                           (-> editor `getCursorPosition))
                                        
                                        (when options.on_initialized
                                           (options.on_initialized intf))
                                        (attach_event_listener view
                                           `keyup
                                           (function (e)
                                              (progn
                                                 (update_position))))
                                        
                                        (if (== options.display_control_bar false)
                                            (set_display_control_bar false))
                                        
                                        (attach_event_listener nav_forward_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_forward_in_position))))
                                        
                                        (attach_event_listener nav_back_button
                                           `click
                                           (fn (e)
                                              (progn
                                                 (handle_event e)
                                                 (go_backward_in_position))))
                                        
                                        ;; setup the evaluator if it is ready
                                        (setTimeout (fn ()
                                                       (let
                                                          ((count 10)
                                                           (evaluator_control nil))
                                                          ;; unless we have been explicitly given an evaluator, use the system repl
                                                          (if options.evaluator_id
                                                             (progn
                                                                (= evaluator_control (get_control_by_id options.evaluator_id))
                                                                (while (and (> count 0)
                                                                            (not evaluator_control))
                                                                   (progn
                                                                      (sleep 1)
                                                                      (dec count)
                                                                      (= evaluator_control (get_control_by_id options.evaluator_id))))
                                                                (if evaluator_control
                                                                   (set_evaluator_control evaluator_control)
                                                                   (notify "Unable to set evalator control for the buffer - id not found")))
                                                             (when *system_repl*
                                                                (display_context_message (+ "Evaluator for this buffer is " (prop *system_repl* `name)))
                                                                (set_evaluator_control *system_repl*)))))
                                                    100)
                                        ;(log "initialize_editor: " (clone options.name) (+ ": (" (last_n_chars 5 options.id) "): initialization complete:") (clone options))
                                        intf)))))
           
           (declare (function compute_name_for_control select_evaluator)
                    (global compute_name_for_control select_evaluator))
           (if (not (is_symbol? `$ace_editor))
               (throw TypeError "$ace_editor symbol not found, and is required for this editor."))
           
           (set_style [["height" (+ "calc(100% - " (+ (Math.max 12 control_bar.offsetHeight) (Math.max 40 context_bar.offsetHeight))  "px)") ]] 
                      editor_div )
           
           (= resize_observer (new ResizeObserver perform_resize))
           (= intf
              {
                `view: view
                `editor: editor  ;; control must be initialized before the editor can be used
                `set: (fn (text)
                         (-> editor `setValue text))
                `get: (fn (text)
                         (-> editor `getValue))
                `get_selection: get_selection_object
                `get_selected_text: get_selected_text
                `is_selected?: is_selected?
                `group_name: (fn ()
                                  options.group_name)
                `type: `text_editor
                `can_hide?: (fn ()
                               (progn
                                  ;(log "editor: can_hide? " (get_editors_for_path options.path) "<= 1 can hide" options.path)
                                  (< (length (get_editors_for_path options.path)) 2)))
                
                `set_display_control_bar: set_display_control_bar
                `on_destroy: (fn ()
                                (progn
                                   (cond
                                      (and options.path
                                         (> (length (get_editors_for_path options.path)) 1)
                                         (-> intf `get_linked))
                                      true  ;; in this case we are a linked editor so we are only really removing a view, not the primary editor control
                                      (not is_dirty?)
                                      true
                                      is_dirty?
                                      (progn
                                         (defvar response
                                            (request_user_input options.name
                                                                "text"
                                                                { input: (div { value: "remove" } 
                                                                              (dtext "The contents of this editor haven't been stored. Really remove?")) }))
                                         ;(log (+ "editor: " options.name ": user response: ") response)
                                         response))))
                `destroy: (fn ()
                             (when editor
                                
                                (defvar others_and_me (if options.path
                                                          (get_editors_for_path options.path)
                                                          []))
                                (defvar my_path (clone options.path))
                                ;(log "editor: " options.name ": got destroy..dispatching event: others and me: " others_and_me.length (< others_and_me.length 2))
                                ;(log "editor: remaining editors for path: " (each (get_editors_for_path options.path) `options))
                                (dispatch_event { `command: "destroy_control" `source: options.id `args: [  ]  })
                                (-> editor `destroy)
                                (= editor nil)
                                ;; effectively de-register ourselves from the group of editors
                                (set_prop options
                                   `path
                                   nil
                                   `group_name
                                   nil
                                   `filename
                                   nil)   
                                (= intf nil)
                                (when my_path
                                   (rename_editor_group my_path))))
                `set_evaluator: (fn (new_evaluator)
                                   (when (is_function? new_evaluator)
                                      (set_prop options
                                         `evaluator
                                         new_evaluator)
                                      (set_evaluator)))
                `needs_save?: (fn ()
                                is_dirty?)
                `set_mode: set_mode
                `get_mode: (fn ()
                              options.mode)
                `set_theme: set_theme
                `set_overscroll: set_overscroll
                `split_vertical: (fn ()
                                    (split_editor `vertical))
                `split_horizontal: (fn ()
                                     (split_editor `horizontal))
                `display_context_message: display_context_message
                `get_evaluator: (fn ()
                                   options.evaluator)
                `get_position_detail: (fn ()
                                         { current: (-> editor `getCursorPosition)
                                           idx: position_history_idx
                                           history: position_history
                                         })
                `resize: (fn ()
                            (perform_resize))
                `bind_key: bind_key
                `key_bindings: (fn ()
                                  (resolve_path [ `keyBinding `$defaultHandler `commandKeyBinding ] editor))
                `save: (function ()
                          (request_save))
                `on_save_complete: (function (event_obj)
                                      (save_complete event_obj))
                `increase_font_size: increase_font_size
                `decrease_font_size: decrease_font_size
                `menu_items: menu_items
                `get_active_lisp_operator: (fn ()
                                              (find_active_lisp_operator))
                `set_read_only: set_read_only
                `get_current_pos: (fn ()
                                     (current_position))
                `set_editor_option: (fn (editor_option_name value)
                                       (when (is_string? editor_option_name)
                                          (-> editor `setOption editor_option_name value)))
                `options: options
                `set_evaluator_control: set_evaluator_control 
                `on_focus: (if options.disallow_control_focus
                              nil
                              on_focus)
                `name: options.name
                `set_name: set_name
                `get_linked: (fn ()
                                options.clone_with_editor_id)
                `set_linked: (fn (id)
                                (set_prop options
                                   `clone_with_editor_id
                                   id))
                `set_unlinked: (function ()
                                  (progn
                                     (= linked_editor nil)
                                     (delete_prop options
                                                  `clone_with_editor_id)
                                     options))
                
                `toJSON: (function ()
                            (progn
                               (set_prop options
                                  `content
                                  (-> editor `getValue))
                            `(text_editor ,#options)))
                `initialize: (fn ()
                                (when view.parentElement
                                   (console.log "editor: performing initialization")
                                   (-> resize_observer `observe view.parentElement)
                                   (try
                                      (initialize_editor)
                                      (catch Error (e)
                                         (log "ERROR on init: " e.message))))) })))) 



  

(defun compute_name_for_editor (title path_to_value)
   (let
      ((others (get_editors_for_path path_to_value))
       (counter 2))
      ;(log "compute_name_for_editor: # of editors for base title: " title ": " others.length "  path: " path_to_value)
      ;(log "compute_name_for_editor: basename found: " (get_control_by_name title))
      (cond 
         (== others.length 0)
         title
         (not (get_control_by_name title))
         (progn
            ;(log "compute_name_for_editor: returning: " title)
            title)
         else
         (progn
            (while (get_control_by_name (+ title " - " counter ""))
               (inc counter))
            ;(log "compute_name_for_editor: returning: " (+ title " - " counter))
            (+ title " - " counter "")))))

(defun compute_name_for_control (name)
   (if (and (is_string? name)
            (not (blank? name)))
       (let
           ((ctl_exists? (get_control_by_name name))
            (counter 2))
          (cond
             (not ctl_exists?)
             name
             else
             (progn
                (while (get_control_by_name (+ name " - " counter ""))
                   (inc counter))
                (+ name " - " counter "")))))
   {
       `description: (+ "Given a proposed name for a control, if the name isn't " 
                        "used by another control, will return the provided name. "
                        "Otherwise, the function will return a unique non-used "
                        "name by appending a digit, starting with 2 on the control "
                        "name.  The new name will then be returned.")
       `tags: ["control" "name" "ui" "identifier"]
       `usage: ["name:string"]
   })


       

(defcontrol log_view ()
      ((output_container (div { `class: "juno-log-output juno-scrollbar" `style: "scroll-behavior: smooth;" } ))       
       (options (or options { `display_options: { include_prototypes: false }}))
       (name (or options.name (name_control "log_view")))
       (parent_view nil)
       (set_show_prototypes (fn (state)
                                  (progn                                                                      
                                   (set_prop options.display_options
                                             `include_prototypes
                                             state)
                                   (log_message "show prototypes: " options.display_options.include_prototypes))))
       (display_modes [ `tree `juno `json ])
       (set_display_mode (fn (mode)
                            (progn
                               (cond 
                                  (is_number? mode)
                                  (set_prop options.display_options
                                     `display_mode
                                     (clamp mode 0 (max_index display_modes)))
                                  (and (is_string? mode)
                                       (> (index_of mode display_modes) -1))
                                  (progn
                                     (set_prop options.display_options
                                             `display_mode
                                             (prop display_modes (index_of mode display_modes))))
                                  else
                                  (throw TypeError (+ "invalid display_mode - need string or number - got: " mode)))
                               (log_message "set display mode: " (prop display_modes options.display_options.display_mode)))))
                            
       (render (fn ()
                  ;(div { `tabindex: 0  `style: "background: white; color: var(--control-color); overflow: hidden; margin: 0px; padding: 0px; height: inherit; width: 100%;" }
                       output_container))
       (set_display_command_button 
          (fn (state)
             (progn
                (if state
                   (remove_class "juno-display-none" command_button)
                   (add_class "juno-display-none" command_button)))))
       (on_initialize (fn ()
                      (try
                         (progn
                            (= parent_view view.parentElement)
                            (set_style [["display" "block"]
                                        ["background" "var(--log-result-bg-color)"]
                                        ["height" "100%"]
                                        ["width" "100% ;"]
                                        ] content_view)
                            
                            (when (eq nil (prop options `display_options))
                               (set_prop options
                                  `display_options
                                 { include_prototypes: false display_mode: 0 }))
                            (when (eq nil (resolve_path [ `display_options `display_mode ] options))
                               (set_path [ `display_options `display_mode ] options 0))
                            (if (eq nil options.display_options.show_timestamps)
                                (set_show_timestamps false)
                                (set_show_timestamps options.display_options.show_timestamps))
                            (if options.hide_command_button
                                (set_display_command_button (not options.hide_command_button))))
                         (catch Error (e)
                            (notify (+ "Error: " e.message))))))
       ;; override the default resize (typically we use on_resize )
       (resize (fn ()
                         (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 5))
                                (new_width  (- (prop view.parentElement `offsetWidth) 0)))
                             (when (and hide_state
                                        (> new_height 5))
                                (= hide_state false)
                                (set_prop output_container
                                   `scrollTop
                                   1000000)
                                (set_prop view
                                   `scrollTop
                                   0)))))
       
       (add_result (fn (result command_text error_state)
                      (progn
                         (assert initialized "log_view not initialized")
                         (defvar appended_element nil)
                         (when (not (eq nil command_text))
                           
                            (-> output_container
                               `append
                               (if (> command_text.length 100)
                                   (details {  class: "juno-result" }
                                            (summary { `tabindex: 0 `class: "juno-code-value" } (+ (-> command_text `substr 0 100) "..."))
                                            (pre { `tabindex: 0 `class: "juno-code-value" }
                                                 command_text))
                                   (div {  class: "juno-result" }
                                        (pre { `tabindex: 0 `class: "juno-code-value" }
                                              command_text)))))
                        
                            (-> output_container
                            `append
                            (= appended_element
                               (div { `class: "juno-log-message"
                                      `style: (+ " margin-top: 0px; font-family: var(--main-mono-space); "
                                                 (if (eq nil command_text)
                                                     "border-top: 1px solid #00000020; padding: 5px;"
                                                     "border-left: 3px solid #0167835e; padding: 5px; margin-bottom: 5px; border-bottom: 1px solid transparent;")) }
                                 (value_to_dom result options.display_options))))
                         (when (> appended_element.parentElement.children.length 
                                  (or options.max_log_lines
                                     *env_config*.application.max_log_lines
                                     10))
                            (-> (first appended_element.parentElement.children)
                                `remove))
                         
                         (set_prop appended_element.parentElement
                                `scrollTop
                                1000000)
                      (set_prop view
                                `scrollTop
                                0)
                      result)))
       (set_max_log_lines (fn (val)
                            (when (is_number? val)
                              (set_prop options
                                        `max_log_lines
                                        val)
                              (while (> output_container.children.length options.max_log_lines)
                                (-> (first output_container.children)
                                    `remove))
                              true)))
       (set_show_timestamps (fn (state)
                                      (if state
                                         (progn
                                            (= ts_hidden_state "")
                                            (set_prop options.display_options
                                               `show_timestamps true)
                                            (when view  ;; surround in try catch in case we aren't completely ready
                                               (try
                                                  (apply remove_class "juno-display-none" (or (-> view `querySelectorAll ".juno-timestamp") []))
                                                  (catch Error (e)
                                                     nil))))
                                              
                                         (progn
                                            (set_prop options.display_options
                                               `show_timestamps false)
                                            (= ts_hidden_state "juno-display-none")
                                            (when view
                                               (try
                                                  (apply add_class "juno-display-none" (-> view `querySelectorAll ".juno-timestamp"))
                                                  (catch Error (e)
                                                     nil)))))))
       (menu_items (fn ()
                     [[(dtext "Clear Log")
                       (fn ()
                                 (-> output_container `replaceChildren))]
                      [(dtext "Set Max Log Lines")
                       (fn ()
                         (aif (request_user_input (+ (dtext "Enter the number of log lines to keep") ":") `number { `default_value: (or options.max_log_lines
                                                                                                                                        *env_config*.application.max_log_lines) })
                              (set_max_log_lines it)))]
                      [(+ (dtext "Display Mode") "...")
                       [[(dtext "Tree")
                        (fn ()
                           (set_display_mode 0))]
                       [(dtext "Juno")
                        (fn ()
                           (set_display_mode 1))]
                       [(dtext "JSON")
                        (fn ()
                           (set_display_mode 2))]]]
                           
                      [(if (blank? ts_hidden_state)
                           (dtext "Hide Timestamps")
                           (dtext "Show Timestamps"))
                       (fn ()
                          (if (blank? ts_hidden_state)
                              (set_show_timestamps false)
                              (set_show_timestamps true)))]
                      [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                       (fn ()
                          (set_show_prototypes (not options.display_options.include_prototypes)))]]))
       (hide_state nil)
       (ts_hidden_state "")
       (on_hide (fn ()
                   (progn
                      (= hide_state true))))
                      
       (on_focus (fn ()
                   (progn  
                      (= hide_state false)
                      (add_class "juno-focused" control_status)))) ;; we know that is the command bar
       
       (log_message (fn (highlight_color `& args)
                      (progn
                         (defvar display_mode (or options.display_options.display_mode 0))
                         (add_result (div { tabindex: 0 style: (+ "display: flex; justify-content: flex-start; align-items: flex-start; " (if (is_string? highlight_color) (+ "background: " highlight_color) "")) }
                                          (div { class: (+ "juno-timestamp " ts_hidden_state) `timestamp: (time_in_millis)  } (formatted_date (new Date)))
                                          (div { style: "display: flex; justify-content: flex-start; align-items: flex-start; " }
                                               (for_each (v args)
                                                  (cond
                                                     (is_string? v)
                                                     (div { `tabindex: 0 `class: "juno-value juno-type-string" `style: "display: inline-block; padding-left: 10px" } v)
                                                     (is_number? v)
                                                     (div { `tabindex: 0 `class: "juno-value juno-type-number" `style: "display: inline-block; padding-left: 10px" } v)
                                                     (or (== v true) (== v false))
                                                     (div { `tabindex: 0 `class: "juno-value juno-type-boolean" `style: "display: inline-block; padding-left: 10px" } v)
                                                     else
                                                     (div { `tabindex: 0 `class: "juno-value" `style: "display: inline-block; padding-left: 10px" } 
                                                          (cond
                                                             true ;(== display_mode 0)
                                                             (value_to_dom v)
                                                             (== display_mode 1)
                                                             (pre (pretty_print v))
                                                             (== display_mode 2)
                                                             (pre (JSON.stringify v nil 2)))
                                                             )))))
                                     nil nil)
                       nil)))
       (log_standard (fn (`& args)
                        (try 
                           (apply log_message nil args)
                           (catch Error (e)
                              (log "Error: " e.message)))))
       (log_problem (fn (error_message error_instance)
                     (log_message "#FF404010" error_message error_instance))))
    {
        expose: [[`set_show_timestamps set_show_timestamps]
                 [`set_show_prototypes set_show_prototypes]
                 [`clear (function ()
                            (-> output_container `replaceChildren))]
                 [`set_display_command_button set_display_command_button]
                 [`set_display_mode set_display_mode]
                 [`display_mode (function ()
                                   (prop display_modes options.display_options.display_mode))]
                 [`display_modes (function ()
                                    display_modes)]
                 [`output_container output_container]
                 [`control_bar control_status]
                 [`append add_result]
                 [`log_message log_standard ]
                 [`log_error log_problem ]]
        frame_style: "overflow: hidden;"
        control_bar: true
        usage: ["options:object"]
        
    })



;(new_juno_repl { `remote_repl: "ws://localhost:56432/connect_repl" })

(defun visual_repl (options)
  (let
      ((options (or options {}))
       (name (compute_name_for_control (or options.name "Visual REPL")))
       (resize_observer nil)
       (id (or options.id (generate_id "repl")))
       (namespace_span  (span { `title: "REPL Namespace" `class: "juno-namespace" `style: "display:inline-block; padding-left: 30px; padding-right: 5px;" } (current_namespace)))
       (display_mode_span (span { `title: (dtext "Display Mode") `class: "juno-mode" style: "float: right;"} "INIT"))
       (location_span (span { `title: "Location" `style: "float: right; display:inline-block; padding-left: 10px; padding-right: 10px;" } 
                          (if options.remote_repl
                                   "Connecting"
                                   "Browser")))
       (control_button (commands_button id));  { `title: "REPL Commands" } "⋯"))
       (title_span (span { `class: "juno-title" } name))
       (show_prototype_details_button (button { `title: (dtext "Show Object Prototype Detail") } "P"))
       (path_span (span { `tabindex: 0 `title: (dtext "Click to copy focused path")  `class: "juno-path" } ""))
       (current_env Environment)
       (error_state nil)
       (remote_command_timeout 120000) ;; 2 minute default
       (initialized false)       
       (intf nil)       
       (toggle_prototype_detail (function ()
                                          (progn                                           
                                           (set_prop options.display_options
                                                     `include_prototypes
                                                     (not options.display_options.include_prototypes))
                                           (set_prop output_control.options.display_options                                                     
                                                     `include_prototypes options.display_options.include_prototypes)
                                           (if options.display_options.include_prototypes
                                             (add_class "juno-button-on" show_prototype_details_button)
                                             (remove_class "juno-button-on" show_prototype_details_button)))))
       (output_control (progn
                          (log_view { `display_options: (or options.display_options { `show_timestamps: false } )
                                                         `hide_command_button: true
                                                         `additional_elements: [ control_button title_span show_prototype_details_button namespace_span display_mode_span path_span location_span] `id: id })))
       (history (if (is_array? options.history)
                  options.history
                  []))
       (clog (fn (`& args)
               (progn
                  (apply console.log args)
                  (-> intf `log (apply div { `style: "display: flex;" }
                                       (for_each (val args)
                                          (div { `style: "padding-right: 10px" } (value_to_dom val)))))
                  nil)))
       (push_history (fn (lisp_text)
                       (progn
                        (push history
                                lisp_text)
                        (= history_idx history.length)
                        (when (> history.length (or options.max_history_size
                                                    50))
                          (take history)))))
       (history_idx 0) 
       (history_prior_entry (fn ()
                              (when (> history.length 0)
                                 (dec history_idx)
                                 (when (or (< history_idx 0)
                                           (>= history_idx history.length))
                                    (= history_idx history.length))
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (-> input_container `set (prop history history_idx)))
                               )))
       (history_next_entry (fn ()
                              (when (> history.length 0)
                                 (inc history_idx)
                                 (if (== history_idx history.length)
                                     (-> input_container `set "")
                                     (progn
                                        (if (>= history_idx history.length)
                                            (= history_idx 0))
                                        (-> input_container `set (prop history history_idx)))))))
       (clear_output (fn ()
                       (-> output_control `clear)))
       (clear_history (fn ()
                        (progn
                         (= history [])
                         (= history_idx 0))))
       
       (repl_key_bindings (function ()
                                    (map (function (kb)
                                             (destructuring_bind (command_name bindings)
                                                 kb                                                                                                                  
                                                 { name: command_name
                                                   mac: (prop bindings `mac)
                                                   win: (prop bindings `win)
                                                  exec: (function (editor)
                                                                  (-> intf command_name editor)) }))                                                                                                                                                                  
                                         (or (pairs *key_bindings*.repl) []))))
       (repl_ws nil)
       (request_id 0)
       (requests {})
       (open_remote_evaluator (fn ()
                                 (if options.remote_repl
                                    (progn
                                       (= repl_ws
                                          (http/create_websocket options.remote_repl
                                                            {
                                                              `on_message: (fn (event)
                                                                             (try
                                                                                (let
                                                                                   ((data nil)
                                                                                    (pdata nil)
                                                                                    (resolver nil))
                                                                                   
                                                                                   (try 
                                                                                      (= data (JSON.parse event.data))
                                                                                      (catch Error (e)
                                                                                         (progn
                                                                                            (clog "Unable to parse json data: " e.message)
                                                                                            (= data event.data))))
                                                                                   ;(clog "<-" event.data)
                                                                                   (cond
                                                                                      (and (is_object? data)
                                                                                           data.req_id)
                                                                                      (progn
                                                                                         (if (prop requests data.req_id)
                                                                                             (progn
                                                                                                (= pdata (prop requests data.req_id))
                                                                                                (remove_prop requests data.req_id)
                                                                                                (clearTimeout (third pdata)) ;; remove the timeout
                                                                                                (if (== data.rval "OK")
                                                                                                    (progn
                                                                                                       (= resolver (first pdata))
                                                                                                       (resolver data nil))
                                                                                                    (progn
                                                                                                       (= resolver (first pdata)) ;; we will resolve the promise and handle the error in our remote eval result function.
                                                                                                       (resolver data true))))
                                                                                             (progn
                                                                                                ;; received a request but it is not tied to a request we made, could be a log message
                                                                                                (if (== data.rval "OK")
                                                                                                    (clog data.result)
                                                                                                    (clog data.message)))))
                                                                                      (and (is_object? data)
                                                                                           data.result)
                                                                                      (clog "[message]:" data.result)
                                                                                      else
                                                                                      (clog data)))
                                                                                (catch Error (e)
                                                                                   (clog "Unable to process received message: " e.message))))
                                                              `on_open: (fn (event)
                                                                           (progn
                                                                              (clog (+ "Connected to Remote REPL: " options.remote_repl))
                                                                              (try 
                                                                                 (set_prop location_span
                                                                                    `innerText (prop (send_wait "(hostname)") `result))
                                                                                 (catch Error (e)
                                                                                    (clog "Unable to determine remote hostname: " e)))))
                                                              `on_close: (fn (event)
                                                                            (clog "Interface is now closed"))
                                                              `on_error: (fn (event)
                                                                            (clog "Error on WS:" event))
                                                            }))
                                       (defglobal *repl_ws* repl_ws)
                                       ))))
       (send_wait (fn (lisp_text)
                     (let
                        ((rval nil))
                        (assert (and (instanceof repl_ws WebSocket)
                                     (== repl_ws.readyState repl_ws.OPEN))
                                "Websocket is not open")
                       (try
                          (= rval (new Promise 
                                       (fn (resolve reject)
                                          (let
                                             ((my_request_id (inc request_id))
                                              (timer nil))
                                             (= timer (setTimeout (fn ()
                                                                     (progn
                                                                        (clog "timeout occurred")
                                                                        (reject { `rval: "FAIL" `message: (+ "Timeout on request id: " my_request_id) })))
                                                                  remote_command_timeout))
                                             ;; set the request id in request object, and then wait to resolve the promise until results are returned, or a timeout occurs
                                             (set_prop requests
                                                my_request_id
                                                (list resolve reject timer))
                                             (try 
                                                (http/send_to_ws repl_ws
                                                                 { `command: "eval"
                                                                   `req_id: request_id
                                                                   `args: [ lisp_text ] })
                                                (catch Error (e)
                                                   (clog "ERROR on send_to_ws: " e)))
                                             true))))
                             (catch Error (e)
                                (log (+ "Error on send_wait: " e))))
                       rval)))
                                                
       (process_remote_eval_result (fn (result)
                                      (if (is_object? result)
                                          (try
                                             (let
                                                ((is_system_error? (== "FAIL" result.rval))
                                                 (is_compiler_error? (and (resolve_path [ `result 0 `error ] result)
                                                                          (resolve_path [ `result 0 `message ] result))))
                                                (cond
                                                   is_system_error?
                                                   (progn
                                                      (div { `style: "border-left: 5px solid red; padding: 5px;" } 
                                                           (+ result.result_type ": " result.message)
                                                           (value_to_dom result)))
                                                   is_compiler_error?
                                                   (progn
                                                      (notify (+ "Error: " is_compiler_error?))
                                                      (div { `style: "border-left: 5px solid red; padding: 5px;" }
                                                           (if (== (length result.result) 1)
                                                               (value_to_dom result.result.0)
                                                               (value_to_dom result.result))))
                                                   
                                                   (ends_with? "unction" result.result_type)
                                                   (remote_function_to_dom result.result)
                                                   result.needs_eval
                                                   (eval_struct (JSON.parse result.result))
                                                   else
                                                   result.result))
                                             (catch Error (e)
                                                (list e.message result)))
                                          result)))

       (evaluator (fn (lisp_text no_eval no_clear no_log)
                    (let
                        ((result nil)
                         (display_mode (-> output_control `display_mode)))
                      (setq error_state nil)
                      (if options.remote_repl
                         (progn
                            (try
                               (progn
                                  (= result (send_wait lisp_text)))
                               (catch Error (e)
                                  (do
                                     (= error_state true)
                                     (when e.message
                                        (notify (+ "Error: " e.message))))))
                            (console.log "remote: <-" result)
                            (cond 
                               (== display_mode "juno")
                               (= result (pre (pretty_print result)))
                               (== display_mode "JSON")
                               (= result (pre (JSON.stringify result nil 2))))
                            (when (is_object? result)
                               (set_prop namespace_span
                                  `innerText
                                  (or result.namespace "Unknown!")))
                            (unless no_log
                               (-> output_control `append (process_remote_eval_result result) lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set "")))
                            
                         (progn
                            (setq current_env (-> Environment `get_namespace_handle (current_namespace)))
                            (try
                               (= result (if no_eval
                                             lisp_text
                                             (-> current_env `evaluate lisp_text {} { `throw_on_error: true })))
                               (catch Error (ex)
                                  (do
                                     (= error_state true)
                                     (notify (+ "Error: " ex.message))
                                     (= result ex))))
                            (console.log "<-" result)
                            (cond 
                               (== display_mode "juno")
                               (= result (pre (pretty_print result)))
                               (== display_mode "JSON")
                               (= result (pre (JSON.stringify result nil 2))))
                            (set_prop namespace_span
                               `innerText
                               (current_namespace))
                            (unless no_log
                               (-> output_control `append result lisp_text error_state))
                            (if (and (not error_state)
                                     (not no_log)
                                     (not no_clear))
                                (-> input_container `set ""))))
                      result)))
                             
       (input_container (text_editor 
                                  {
                                   mode: "juno"                                                                                                                             
                                   on_change: (function (editor val)
                                                        (progn
                                                         true))
                                   name: (+ name "-" "input")
                                   theme: options.theme
                                   id: id
                                   evaluator_id: id
                                   disallow_control_focus: true
                                   clone_with_editor_id: options.clone_with_editor_id
                                   repl_mode: true
                                   display_control_bar: false
                                   on_evaluation: (fn (lisp_text results)
                                                     (push_history lisp_text))
                                   commands: (repl_key_bindings)
                                   on_initialized: (fn (control)
                                                       (when initialized
                                                          (try
                                                             (-> control.editor `focus)
                                                             (catch Error (e)
                                                                (log "error on focus: " e.message)))))
                                                       }))

       (sview (split_view_horizontal
                                 output_control
                                 input_container
                                 { `ratio: (or options.ratio 0.7) `id: id } ))  ;; 80/20 top-bottom
       
       (view sview.view)
       (non_whitespace_regex (new RegExp "\\\\s"))
       (on_focus (fn ()
                   (progn
                    ;(-> input_container.editor `focus) ;; bring focus to the repl
                    (add_class "juno-focused" output_control.control_bar )
                    (set_prop intf
                       `editor
                       (resolve_path [ `editor_container `editor ] intf)))))
       (on_blur (fn ()
                  (progn
                   true)))
       (destroy (fn ()
                  (if options.locked
                     (throw EvalError (+ "" options.name " is marked as locked and cannot be destroyed"))
                     (progn
                        (if options.remote_repl
                            (try
                               (progn
                                  (log "remote_repl state: " repl_ws.readyState)
                                  (when (== repl_ws.readyState repl_ws.OPEN)
                                     (log "remote_repl: closing open connection on destroy. ")
                                     (-> repl_ws `close))
                                  (log "remote_repl state: clean up complete."))
                               (catch Error (e)
                                  (log "remote_repl: couldn't close the socket: " e.message))))
                           
                        (-> input_container `destroy)))))
       (menu_items (fn ()
                     [[(dtext "Clear Output Log")
                       (function ()
                                 (clear_output))]
                      [(dtext "Clear REPL History")
                       (function ()
                                 (clear_history))]
                      [(if options.display_options.include_prototypes
                         (dtext "Hide Object Prototype Detail")
                         (dtext "Show Object Prototype Detail"))
                       (function ()
                                 (toggle_prototype_detail))]
                      
                      
                      [(if output_control.options.display_options.show_timestamps
                         (dtext "Hide Timestamps")
                         (dtext "Show Timestamps"))
                       (function ()
                                 (progn
                                    (if output_control.options.display_options.show_timestamps
                                       (-> output_control `set_show_timestamps false)
                                       (-> output_control `set_show_timestamps true))
                                    (set_prop options.display_options
                                              `show_timestamps
                                              output_control.options.display_options.show_timestamps)))]
                      [(dtext "Set Max Log Lines")
                       (fn ()
                         (aif (request_user_input (+ (dtext "Enter the number of log lines to keep") ":") `number { `default_value: (or options.max_log_lines
                                                                                                                                        *env_config*.application.max_log_lines) })
                              (-> output_control `set_max_log_lines it)))]
                      [(+ (dtext "Set Display Mode") "...")
                       [[(dtext "Tree")
                        (fn ()
                           (progn
                              (-> output_control `set_display_mode 0)
                              (set_prop options.display_options `display_mode 0)
                              (set_prop display_mode_span
                                 `innerText (-> output_control `display_mode))))]
                       [(dtext "Juno")
                        (fn ()
                           (progn
                              (-> output_control `set_display_mode 1)
                              (set_prop options.display_options `display_mode 1)
                              (set_prop display_mode_span
                                 `innerText (-> output_control `display_mode))))]
                       [(dtext "JSON")
                        (fn ()
                           (progn
                              (-> output_control `set_display_mode 2)
                              (set_prop options.display_options `display_mode 2)
                              (set_prop display_mode_span
                                 `innerText (-> output_control `display_mode))))]]]
                      [(dtext "Set Editor Theme") (for_each (theme *editor_themes*)
                                                            [theme  (fn ()
                                                                      (progn
                                                                       (set_prop options `theme theme)
                                                                       (-> input_container `set_theme theme)))])]]))
       (initialize (fn ()
                     (progn
                      (if initialized
                        false
                        (progn
                         (= initialized true)
                         (console.log "repl initializing")
                         (try
                            (-> output_control `initialize)
                            (catch Error (e)
                               (notify e.message)))
                         (when (eq nil options.display_options)
                           (set_prop options
                                     `display_options
                                     { `include_prototypes: false 
                                       `show_timestamps: output_control.options.display_options.show_timestamps 
                                       `display_mode: (or output_control.options.display_options.display_mode 0)
                                     }))
                         
                         (if options.display_options.include_prototypes
                           (add_class "juno-button-on" show_prototype_details_button))
                         (try
                            (if options.remote_repl
                               (progn
                                  (clog  (html/div { `style: "display: flex padding: 5px" }                
                                                                       (html/span { `style: "font-weight: bold; display: inline-block;" } "connecting to: ")
                                                                       (html/span { `style: "display: inline-block; margin-left: 10px;" }
                                                                                  options.remote_repl )))
                                  
                                  (open_remote_evaluator)))
                            (catch Error (e)
                               (clog "Cannot open remote REPL: " e.message)))
                         (unless options.remote_repl
                            (-> output_control `append (html/div { `style: "display: flex padding: 5px" }
                                                                 (html/span { `style: "font-weight: bold; display: inline-block;" } "Juno REPL")
                                                                 (html/span { `style: "display: inline-block; margin-left: 10px;" }
                                                                            "Version: " Environment.build_version   ))))
                         
                         ;; set the computed name
                         (set_prop options
                            `name
                            name)
                         (log output_control.options)
                         (setTimeout (fn ()
                                        (set_prop display_mode_span
                                           `innerText (-> output_control `display_mode)))
                                     100)
                         ;; become the system_repl if none is yet defined
                         (if (eq nil *system_repl*)
                             (progn
                                (= *system_repl* intf)
                                (set_prop options
                                   `locked true)
                                (setTimeout (fn ()
                                               (progn
                                                  (-> input_container `display_context_message (+ "*system_repl* / REPL Mode: Press Shift-Enter to evaluate editor contents"))))
                                            250))
                             (setTimeout (fn ()
                                            (-> input_container `display_context_message "REPL Mode: Press Shift-Enter to evaluate editor contents")
                                            250)))
                         true))))))

       (attach_event_listener output_control.output_container
                           `focusin
                           (function (e)
                             (progn
                              (handle_event e)
                              (console.log "output-control: focus: " (-> e.srcElement `getAttribute "lpath") e.srcElement)
                              (aif (-> e.srcElement `getAttribute "lpath")
                                   (progn
                                    (set_prop path_span
                                             `innerText
                                             (+ "[ " (join " "
                                                           (for_each (v (split_by "~" it))
                                                                     (cond (> (length (scan_str non_whitespace_regex v)) 0)
                                                                           (+ "\"" v "\"")
                                                                           (isNaN (new Number v))
                                                                           (+ "`" v)
                                                                           else
                                                                           v)))
                                                           " ]"))
                                    (console.log "setting path span:: " it))
                                   (progn
                                    (console.log "clearing path span")
                                    (set_prop path_span
                                             `innerText
                                             ""))))))
     
    (attach_event_listener show_prototype_details_button
                           `click
                           (fn (e)
                             (progn
                              (handle_event e)
                              (toggle_prototype_detail))))
    
    (attach_event_listener path_span
                           `click
                           (fn (e)
                             (progn
                              (copy_text_to_clipboard path_span.innerText)
                              (notify (+ (dtext "Copied") " " path_span.innerText)))))

    ;; by changing the split_view type value, we prevent this control from being split or
    ;; controls being swapped
    
    (set_prop sview
              `type
              "REPL_split")
    (set_prop output_control
       `on_focus
       nil)
    (set_prop options
              `id
              id)
                   
    (= intf {
             `view: view
             `options: options
             `name: name             
             `editor_container: input_container             
             `editor: nil ;; will be filled in on initialization 
             `history_next_entry: history_next_entry
             `history_prior_entry: history_prior_entry
             `command_history: (function ()
                                        history)
             `clear_history: (function ()
                                       (clear_history))
             `clear_output: clear_output             
             `initialize: initialize
             `destroy: destroy
             `on_hide: (fn ()
                         (when (is_function? output_control.on_hide)
                            (-> output_control `on_hide)))
             `type: "visual_repl"
             `resize: (fn ()
                       (-> sview `resize))
             `menu_items: menu_items                           
             `on_focus: on_focus
             `on_blur: on_blur           
             `set_theme: (fn (theme_name)
                           (when (contains? theme_name *editor_themes*)
                             (set_prop options `theme theme_name)
                             (-> input_container `set_theme theme_name)))
             `toJSON: (function ()
                                (progn
                                 (set_prop options
                                           `history
                                           [(quote quotel) history])
                                `(visual_repl ,#(or options { `ratio: sview.options.ratio } ))))
             `controls: (fn () [ input_container output_control])
             `output_container: output_control.view
             `log: (fn (val)
                     (-> output_control `log_message val))
             `log_error: (fn (error_message error)
                            (-> output_control `log_error error_message error))
             `evaluate: (fn (lisp_text no_eval no_clear no_log)
                          (evaluator lisp_text no_eval no_clear no_log))
             })
    intf)) 


;; singleton - if it already exists, just return the control
;; otherwise make it 
(defun control_holding_tank (initial_controls options)
   (aif (get_control_by_name "Holding Tank")
        it
        (let
           ((my_controls (if (and initial_controls
                                  (is_array? initial_controls))
                             (to_object
                                (reduce (control initial_controls)
                                   (when control.options.id
                                      [control.options.id control])))
                             {}))
            (options (or options {}))
            (intf {})
            (name (or options.name
                      "Holding Tank"))
            (initialized false)
            (id (or options.id (generate_id "holding_tank")))
            (title_span (span { `class: "juno-title" } (dtext "Holding Tank") " - " (dtext "non-displayed controls")))
            (buffer_commands_button (commands_button id))
            (control_status (div {  `class: "juno-buffer-bar" }
                                 buffer_commands_button
                                 (cond (is_array? options.additional_elements)
                                    options.additional_elements
                                    else
                                    title_span
                                    )))
            (perform_resize (fn ()
                               (when view.parentElement
                                  (when (not initialized)
                                     (initialize))
                                  (render_view))))
            (resize_observer nil)
            (add_control (fn (control)
                            (when (not (== control intf))
                               (assert (and control.type control.options.id) "Invalid control provided")
                               (set_prop my_controls
                                  control.options.id
                                  control)
                               ;(log "control_holding_tank: " control.options.name  "can_hide?" (and control.can_hide? (-> control `can_hide?)))
                               (if (and (not (resolve_path [ `options `locked ] control))
                                        (or (== control.type "empty_control")  ;; don't store the empty controls since they are placeholders
                                            control.options.temporary          ;; or if the control is marked temporary
                                            (and control.can_hide?       ;; does the control want to be hidden?
                                               (not (-> control `can_hide?)))))
                                   (progn
                                      (when *app_menu_control*
                                         (-> *app_menu_control* `remove_menu control.options.name))
                                      (remove_control control.options.id)
                                      (if control.destroy
                                         (-> control `destroy))
                                      (when (== *last_focus* control)
                                         (== *last_focus* nil))
                                      (default_focus))
                                   (progn  ;; control is going to storage - call on_hide if it has it
                                      (when (is_function? control.on_hide)
                                         (-> control `on_hide))))
                               (render_view)
                               control)
                            ))
            (remove_control (fn (id)
                               (if (is_object? id)
                                   (aif (prop my_controls id.options.id)
                                        (progn
                                           (remove_prop my_controls id.options.id)
                                           (render_view)))
                                   (aif (prop my_controls id)
                                        (progn
                                           (remove_prop my_controls id)
                                           (render_view))
                                        (notify "The requested control wasn't found")))))
            (first_button nil)
            (render_view (fn ()
                            (progn
                               (= first_button nil)
                               (-> control_view
                                  `replaceChildren
                                  (table { `tabindex: 0 `style: "width: 100%" }
                                         (thead
                                            (th (dtext "Name")) (th (dtext "Type")) (th (dtext "Needs Save?")) (th (dtext "Actions")))
                                         (tbody
                                            (for_each (control (values my_controls))
                                               (tr
                                                  (td control.name)
                                                  (td control.type)
                                                  (td (if (and control.needs_save?
                                                               (-> control `needs_save?))
                                                          (dtext "Yes")
                                                          ""))
                                                  
                                                  (td { `for_control_id: control.options.id }
                                                      (progn
                                                         (defvar b (button { `tabindex: 0 } (dtext "View")))
                                                         (if (not first_button)
                                                             (= first_button b))
                                                         b)
                                                      (button { `tabindex: 0 `style: "float: right" } (dtext "Close Control")))))))))))
            (handle_button_event (fn (elem)
                                    (aif (and elem.parentElement
                                              (-> elem.parentElement `getAttribute "for_control_id"))
                                         (progn
                                            (console.log "holding_tank: button_event: " elem.innerText elem)
                                            (cond
                                               (== elem.innerText (dtext "View"))
                                               (swap_control intf (get_control_by_id it))
                                               (== elem.innerText (dtext "Close Control"))
                                               (container_view_operation "destroy" (get_control_by_id it)))))))
            
            (initialize (fn ()
                           (when (and view.parentElement
                                      (not initialized))
                              (= initialized true)
                              (-> resize_observer `observe view.parentElement)
                              (console.log "holding_tank: in initialization: " options view.parentElement)
                              (if options.in_tree
                                 (progn
                                    (console.log "holding_tank: in tree and setting view up to block..and calling render")
                                    (set_style [["display" "block"]] view)
                                    (render_view)
                                    (focus_to first_button))
                                 (-> (get_by_id "body")
                                     `append view)))))
            (dirty_controls_interval nil)
            (num_dirties 0)
            (before_unload_listener (function (e)
                                       (progn
                                          (-> e `preventDefault)
                                          (set_prop e `returnValue (+ "There are " num_dirties " items that require saves. Are you sure you want to quit?"))
                                          e)))
            (on_focus (fn ()
                         (progn
                            (add_class "juno-focused" control_status ))))
            (control_view (div { `style: "overflow: scroll; margin: 0px; padding: 0px; height: 100%; width: 100%;background: var(--control-bg-color);" }))
            (show (fn ()
                     (let
                        ((root_control (if *last_focus*
                                           (top_frame *last_focus*)
                                           (prop $root_controls 1)))
                         (current_parent (if view.parentElement
                                             (control_position (control_for_dom_element view))
                                             { `child: intf `parent: nil `child_position: 0 }))
                         (target_control (if root_control.controls
                                             (first (-> root_control `controls)))))
                        (console.log "holding_tank: show: " root_control "current_parent: " current_parent "target_control: " target_control)
                        (console.log "holding_tank: do I have a parent_element: " (parents_for_control intf))
                        (cond
                           (eq current_parent.parent nil)
                           (progn
                              (set_prop options
                                 `in_tree
                                 true)
                              (set_style [["display" "block"]] view)
                              (container_view_operation "split_below" target_control intf { `ratio: 0.7 })
                              (set_focus_to intf)
                              (focus_to first_button))
                           current_parent.parent
                           (progn
                              (set_style [["display" "block"]] view)
                              (set_prop options
                                 `in_tree
                                 true)
                              (set_focus_to intf)
                              (focus_to first_button))))))
            (hide (fn ()
                     (progn
                        (console.log "holding_tank: hide: " view.parentElement)
                        (when view.parentElement
                           (container_view_operation "hide" intf)
                           (remove_prop options
                              `in_tree)
                           (set_style [["display" "none"]] view)
                           (-> (get_by_id "body")
                               `append view)))))
            
            
            (view (div { `tabindex: 0 `control_id: id `style: "display: none;  overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                       control_status
                       control_view)))
           
           (attach_event_listener view
              `click
              (fn (e)
                 (when (== e.srcElement.tagName "BUTTON")
                    (handle_button_event e.srcElement))))
           (attach_event_listener view
              `keyup
              (fn (e)
                 (when (== e.key "Escape")
                    (hide))))
           (set_prop options
              `id id
              `name name)
           (= dirty_controls_interval
              (setInterval (fn ()
                              (let
                                 ((dirties (try
                                              (reduce (c (current_controls))
                                                 (if (and c.needs_save?
                                                          (-> c `needs_save?))
                                                     c))
                                              (catch Error (e)
                                                 (progn
                                                    (when dirty_controls_interval
                                                       (clearInterval dirty_controls_interval))
                                                    (log_error "dirty_controls_interval: stopping due to error: " e)
                                                    [])))))
                                 (cond
                                    (and (> dirties.length 0)
                                         (== num_dirties 0))
                                     (progn
                                        (= num_dirties dirties.length)
                                        (log "# buffer saves required: " num_dirties)
                                        (addEventListener `beforeunload before_unload_listener { capture: true }))
                                     (and (== dirties.length 0)
                                          (> num_dirties 0))
                                     (progn
                                        (= num_dirties 0)
                                        (log "# buffer saves required: " 0)
                                        (removeEventListener `beforeunload before_unload_listener { capture: true })))))
                           2000))

           (= resize_observer (new ResizeObserver perform_resize))
           
           (= intf
              {
                `view: view
                `type: "holding_tank"
                `id: id
                `name: options.name
                `initialize: initialize
                `on_focus: on_focus
                `controls: (fn ()
                              (values my_controls))
                `add_control: add_control
                `has_control?: (fn (thing) (if (is_string? thing)
                                           (prop my_controls thing)
                                           (prop my_controls thing.options.id)))
                `remove_control: remove_control
                `name: options.name
                `hide: hide
                `show: show
                
                `resize: perform_resize
                `options: options
                `toJSON: (function ()
                            `(control_holding_tank ,#(values my_controls)  ,#options ))
                })
           intf))
   {
     `usage: ["initial_controls:array" "options:object"]
     `description: (+ "The control holding tank is a is a singleton control that 'holds' any "
                      "control (except itself) that is currently not displayed.  Once instantiated "
                      "any new instantiations of the control holding tank will return the "
                      "previously instantiated control for the namespace.  All arguments will be "
                      "ignored after the initial instantiation call as the global instance will be "
                      "returned. Controls are added to the holding tank by the container_view_operation "
                      "function which manages the view state.  The holding tank can be checked for a "
                      "control being held by it by calling the has_control? function. ")
     `tags: ["ui" "controls" "hidden" "container" "holding"]
     })

(defun empty_selection_control (options)
   (let
      ((existing_control (last (holding_tank_controls))))
      (if existing_control
         existing_control
     (let
        ((options (or options {
                               `name: "Empty Selection" 
                               }))
         (id (or options.id (generate_id "empty")))
         (title_span (span { `class: "juno-title" } (if options.title options.title "Select Control")))
         (buffer_commands_button (commands_button id))
         (control_status (div {  `class: "juno-buffer-bar" }
                              buffer_commands_button
                              (cond (is_array? options.additional_elements)
                                  options.additional_elements
                                  else
                                  title_span
                                  )))
         (resize_observer nil)         
         (initialized false)
         (parent_view nil)
         (check_observer (fn ()
                         (when (not (== view.parentElement parent_view))
                           (-> resize_observer `disconnect)
                           (-> resize_observer `observe view.parentElement)
                           (= parent_view view.parentElement))))
         (perform_resize (fn ()
                           (when view.parentElement
                             (check_observer)
                           (let
                               ((new_height (- (prop view.parentElement `offsetHeight) 20))
                                (new_width  (- (prop view.parentElement `offsetWidth) 5)))
                             
                             (set_style [[ "width" (+ "" new_width "px") ]
                                         [ "height" (+ "" new_height "px") ]]
                                        view)))))
         (initialize (fn ()
                       (when (and view.parentElement
                                  (not initialized))
                         (= initialized true)
                         (= parent_view view.parentElement)
                         (-> resize_observer `observe view.parentElement))))
         (on_focus (fn ()
                   (progn
                     ;; bring focus to the repl
                    (add_class "juno-focused" control_status ))))
         (control_view (div { `class: "juno-empty-content" } ""))
         (view (div { `tabindex: 0 `control_id: id `style: "overflow: hidden; margin: 0px; padding: 0px; height: 100%; width: 100%;" }
                  control_status
                  control_view)))
                             
        (set_prop options
                  `id
                  id)
        (= resize_observer (new ResizeObserver perform_resize))
        
        
       {
           `view: view
           `type: "empty_control"
           `id: id
           `initialize: initialize
           `on_focus: on_focus
           `name: options.name
           `resize: perform_resize
           `options: options
           `toJSON: (function ()
                      `[empty_selection_control ,#options ])
        }))))

(defun find_common_prefix (candidates match_to)
   (let
      ((result [])
       (subset nil)
       (match_to match_to))
      (cond
         (== (length candidates) 0)
         ""
         (== (length candidates) 1)
         (first candidates)
         
         (not (blank? match_to))
         (progn
            (while (progn
                      (= subset (reduce (c candidates)
                                   (when (starts_with? match_to c)
                                      c)))
                      (and (< subset.length 2)
                           (> match_to.length 0)))
               (= match_to (chop match_to)))
            
            (find_common_prefix subset))
         else
         (progn
            (= candidates (sort candidates))  ;; make sure the candidates are sorted
            (for_each (idx (range (length candidates.0)))
               (if (== (prop (first candidates) idx)
                       (prop (last candidates) idx))
                   (push result (prop (first candidates) idx))
                   (break)))           
            (join "" result)))))

(defun place_caret_at_end (el)
   (progn
      (javascript |
                  el.focus();
                  if (typeof window.getSelection != "undefined"
                             && typeof document.createRange != "undefined") {
                     var range = document.createRange();
                     range.selectNodeContents(el);
                     range.collapse(false);
                     var sel = window.getSelection();
                     sel.removeAllRanges();
                     sel.addRange(range);
                     }
                  | )
      true))

(defun next_hidden_control (backward?)
   (let
      ((candidates (holding_tank_controls))
       (cmd (if backward? 
                first
                last))
       (new_ctl nil))
   (if (> candidates.length 0)
      (progn 
         (= new_ctl (cmd candidates))
         (swap_control *last_focus* new_ctl)
         ;; control will get the on_focus event, but we want to default
         ;; focus into the editor for this operation
         (when new_ctl.editor
            (focus_to new_ctl.editor)))
      (notify (dtext "No controls are in the holding tank."))))
   {
     `usage: ["backward?:boolean"]
     `description: (+ "If backward? is false (default) swap the current control " 
                      "with the last control in the holding tank. Otherwise "
                      "swap with the first control in the holding tank. "
                      "If there are no controls, notifies the user that there are "
                      "no other non-displayed controls to swap to.")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     })

(defun next_displayed_control (backward?)
      (let
      ((next_index nil)
       (displayed_root_control (reduce (ctl (uniq (flatten (control_tree $root_controls))))
                                  (if (and (not (-> (control_holding_tank) `has_control? ctl))
                                           (== ctl.type "control_container"))
                                      ctl)))
       (candidates (reduce (ctl (current_controls true displayed_root_control))
                      (unless (or (-> (control_holding_tank) `has_control? ctl)  ;; we only want controls that are able to take a direct focus
                                  (== ctl.type "control_container")
                                  (== ctl.type "split_view_vertical")
                                  (== ctl.type "split_view_horizontal"))
                         ctl)))
       (dir (if backward? 
                -2
                1))
       (new_ctl nil))
   (if (> candidates.length 0)
      (progn 
         (map (fn (ctl idx)
                 (if (== ctl *last_focus*)
                     (= next_index (% (+ idx dir) (length candidates)))))
              candidates)
         (when next_index
            (= new_ctl (prop candidates next_index))
            (set_focus_to new_ctl)
            ;; control will get the on_focus event, but we want to default
            ;; focus into the editor for this operation if the control has an editor
            (if new_ctl.editor
               (focus_to new_ctl.editor))))
      (notify (dtext "No controls are in the holding tank."))))
   {
     `usage: ["backward?:boolean"]
     `description: (+ "If backward? is false (default) swap the current control " 
                      "with the next control in the displayed control tree. Otherwise "
                      "swap with the first control in the holding tank. "
                      "If there are no controls, notifies the user that there are "
                      "no other non-displayed controls to swap to.")
     `tags: ["ui" "controls" "swap" "buffers" "editor" "next"]
     })

(defmacro on_key_down_event (e view `& key_to_action_pairs)
   (let
      ((acc []))     
      ;(assert (and e view key_to_action_pairs)
       ;       "Invalid syntax for on_key_down_event")
      (for_each (key_to_action_pair key_to_action_pairs)
                        (destructuring_bind (key action)
                           key_to_action_pair
                           (if (== key "otherwise")
                               (push acc true)
                               (push acc `(== kcode ,#key)))
                           (push acc action)))
      `(attach_event_listener 
          view
          `keydown
          (function (e)
             (let
                ((kcode e.key))
                (cond
                   ,@acc))))))



(defcontrol tree_browser ()
   ((options (or (and (is_object? options)
                          options)
                     (throw SyntaxError "options object is required for tree_browser")))
    (stack [])
    (initial_render false)
    (title_span (span { spellcheck: false `contenteditable: true `tabindex: 0 `style: "caret-color: red; outline: none; display: inline-block; font-size: 1.1em; font-weight: bold; font-family: var(--main-mono-space); min-width: 10px; border: 1px dotted goldenrod; padding-left: 5px; padding-right: 5px" } ""))
    (caps_lock_span (span { `class: "juno-display-none" `style: "margin-left: 20px; padding-top: 2px; padding-left: 5px; padding-right: 5px; padding-bottom: 2px; border-radius: 3px; border: 1px solid var(--main-color); " } (dtext "caps lock")))
    (on_destroy (fn (self)
                  (progn
                   (when options.on_destroy                     
                     (options.on_destroy self))
                   true)))
    (current_pos 0)
    (content_view (div { `style: "" `class: "juno-symbol-browser" }))
    (get_current_stack (fn ()
                           (clone stack)))
    (select_text (dtext (or options.select_text
                            "Press Enter To Open")))
    (ol_for_pos (fn (pos)
                   (let
                      ((target_col nil))
                      (= target_col (-> content_view `querySelector (+ "ol[pos='" (if pos pos 0) "']")))
                      target_col)))
    
    (select_child (fn (ol_elem selected_child_text)
                     (when selected_child_text
                        (for_each (child ol_elem.children)
                           (if (and (is_element? child)
                                    (== (get_attribute child "path_value") selected_child_text))
                               (add_class "juno-selected" child)
                               (remove_class "juno-selected" child))))))
    (path_sep (fn ()
                 (or options.path_separator "/")))
    
    (num_ol_elems (fn ()
                    (length content_view.children)))
                       
    
    (create_ol_at_pos (fn (pos)
                         (try
                            (let
                               ((stack_value_at_pos (prop stack pos))
                                (contents (get_possibles pos)))
                               (ol { `style: (if (not (is_array? contents))
                                                 "width: 100%; max-width: 100%; position: relative;"
                                                 "height: calc(100% - 20px);  position: relative;")
                                            `pos: pos }
                                   contents))
                            (catch Error (e)
                               (log "ERROR: create_ol_at_pos: " pos "" e.message)))))
    
    (find_value (fn (elem key)
                   (let
                      ((v nil))
                      (cond
                         (= v (get_attribute elem key))
                         v
                         elem.parentElement
                         (find_value elem.parentElement key)
                         else
                         nil))))
    
    (get_specifics_for_event (fn (e)
                                (let
                                   ((elem e.srcElement)
                                    (path_value (find_value elem "path_value"))
                                    (pos (int (find_value elem "pos"))))
                                   (set_path_at pos path_value))))
    
    (set_path_at (fn (pos path_value)
                    (when path_value
                       (cond
                          (== pos stack.length) ;; at end
                          (progn
                             (push stack path_value)
                             (render_stack))
                          (< pos stack.length)
                          (progn
                             (= stack (-> stack `slice 0 pos))
                             (push stack path_value)
                             (clear_suffix)
                             (render_stack))
                          else
                          (log "set_path_at: unhandled: " pos path_value)))))
    (is_at_leaf false)
    (was_at_leaf false)
    (at_leaf (fn ()
                (progn 
                   is_at_leaf)))
                   ;(log "at_leaf?: is_at_leaf: " is_at_leaf (not (has_class? "filtered-hidden" instruction_div)))
                   ;(not (has_class? "filtered-hidden" instruction_div)))))
    
    (get_path_components (fn (raw)
                            (let
                               ((text (or title_span.innerText ""))
                                (ps (path_sep)))
                               (if raw
                                  text
                                  (progn
                                     (if (ends_with? ps text)
                                         (= text (chop text)))
                                     (split_by ps text))))))
    (get_suffix (fn ()
                   (let
                      ((comps (get_path_components)))
                      (if (> comps.length stack.length)
                          (last comps)
                          ""))))
    
    (clear_suffix (fn ()
                     (let
                        ((elem (ol_for_pos stack.length))
                         (ps (path_sep)))
                        
                           (set_prop title_span
                              `innerText (+ (join ps stack)
                                            (if (and (> stack.length 0)
                                                     (not (at_leaf)))
                                                ps
                                                "")))
                        (if elem
                            (for_each (c elem.children)
                               (remove_class "filtered-lower-opacity" c))))))
                        
    (get_matches (fn (k highlight?)
                    (let
                       ((num_matches 0)
                        (pos stack.length)
                        (addl (if (blank? k) "" k))
                        (suffix (+ (get_suffix) addl))
                        (matched [])
                        (first_match nil)
                        (not_matched []))                       
                       (if (< pos 0)
                           []
                           (aif (ol_for_pos pos)
                                (for_each (c it.children)
                                   (progn
                                      (if (and (not (blank? suffix))
                                               (starts_with? suffix c.innerText))
                                          (push matched
                                                c)
                                          (push not_matched
                                                c))))))
                       (= last_matched matched)
                       (when highlight?
                          
                          
                          (for_each (elem not_matched)
                             (add_class "filtered-lower-opacity" elem))
                           (for_each (elem matched)
                              (remove_class "filtered-lower-opacity" elem)))
                       (= first_match matched.0)
                       (when first_match
                          (set_prop first_match.parentElement
                             `scrollTop
                             (- (prop first_match `offsetTop) 10)))
                       matched)))
    
    (get_last_column_values (fn ()
                               (let
                                  ((elem (ol_for_pos stack.length)))
                                  (if elem
                                      (for_each (c elem.children)
                                         (prop c `innerText))
                                      []))))
    
    (matched_as_text (fn (matched)
                        (map (fn (v)
                                v.innerText)
                             matched)))
    (last_suffix nil)
    (caps_lock_timer nil)
    (last_matched [])
    (select_matches (fn (k)
                       (let
                          ((text nil)
                           (in_reverse (== k "Backspace"))
                           (matched nil)
                           (prefix nil)
                           (suffix nil)
                           (exact_match nil)
                           (existing_suffix nil)
                           (ps (path_sep))
                           (last_path nil)
                           (at_leaf? (at_leaf)))                         
                          ;; are we going forward or backwards?
                          ;; if forwards, determine if we pressed a delim key or a regular key
                          ;; if we pressed a delim key, and the final path segment matches an element in the column, push that value to the stack, and redraw the columns and the title_span
                          ;; if we pressed a regular key, find the common prefixes, write that to the title_span,
                          ;; ...and follow the filter process.
                          ;; if we matched to a leaf, display the instruction_div 
                          
                          ;; if backwards, determine if we are at a leaf or not
                          ;; if we are, remove the character from the title_span, pop the stack, find the common prefix, write that to the title_span, follow the filter process
                          ;; if we are not, remove the character, find the common prefix, write that to the title_span and 
                          ;; follow the filter process
                          
                          ;; Filter process:
                          ;; Determine the amount of matched elements at the last path segment
                          ;; if 1 match then append the value to the path and redraw the title and the column selectors
                          ;; if >1 then find the common prefix, and append the common prefix to the title_span
                          ;; ..and highlight the matching values in the column
                          ;; if 0 matches don't append the character since it cannot contribute to narrowing the selection
                         
                          (cond
                             in_reverse
                             (progn 
                                (= was_at_leaf at_leaf?)
                                (when at_leaf? ;; if we are at leaf state, remove the final value from the stack
                                    (pop stack)
                                   
                                    (= is_at_leaf false)
                                    (add_class "filtered-hidden" instruction_div))
                                (if options.allow_non_matches
                                   (run_validations))
                                ;; find the common prefix with one character removed
                                (= existing_suffix (get_suffix))                    
                                (when (not (blank? existing_suffix))
                                   (if options.allow_non_matches
                                      (= prefix (chop existing_suffix))
                                      (= prefix (find_common_prefix (get_last_column_values) (chop existing_suffix)))))
                                (when (== prefix last_suffix)
                                    ;; we had this value last backspace, so we need to go back further
                                    (= prefix "")
                                    (= last_suffix nil))
                                (cond
                                   (and options.allow_non_matches
                                        (blank? prefix))
                                   (progn
                                      (if (blank? last_suffix)
                                          (progn
                                             (pop stack)
                                             (render_stack))
                                          (progn 
                                             (clear_suffix)
                                             (render_title prefix)
                                             true)))
                                   (blank? existing_suffix)  ;; there is no suffix, so pop the stack 
                                   (progn        
                                      (pop stack)
                                      (try
                                         (clear_suffix)
                                         (catch Error (e)
                                            (log "ERROR on clear_suffux: " e.message)))
                                      (try
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR on render stack: " e.message))))
                                   
                                   (blank? prefix)  ;; when no common prefix remove the suffix altogether
                                   ;; we will have to rebuild the title_span explicitly otherwise suffix will be preserved
                                   (progn
                                      (clear_suffix)
                                      (render_stack))
                                      ;; clear all the matches..
                                   (> (length prefix) 0)
                                   (progn
                                      (clear_suffix)
                                      (render_stack prefix true)
                                      (= last_suffix prefix)
                                      (get_matches "" true))
                                   else
                                   ;; just clear the last suffix 
                                   (progn
                                      (= last_suffix nil))))
                                ;; if we were at a leaf, we are no longer so remove the leaf node from the stack
                             
                             (and (not options.allow_non_matches)
                                  (or (== k ps)
                                      (== k "Tab")))
                             (progn
                                (= matched (get_matches "" true))
                                (= last_path (last (get_path_components)))
                                
                               (cond 
                                  ;; if there is only one match 
                                  (and (> (length title_span.innerText) 0)
                                       (== (length matched) 1)
                                       (not (ends_with? ps title_span.innerText)))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))
                                  ;; if there are multiple matches, but in those matches there is an exact match
                                  (and (> (length title_span.innerText) 0)
                                       (== (length (reduce (t (matched_as_text matched))
                                                      (== last_path (first (split_by "\n" t)))))
                                           1))
                                  (progn
                                     (push stack
                                        (get_suffix))
                                     (render_stack)
                                     (clear_suffix)
                                     (place_caret_at_end title_span))))
                                  
                                     
                             else
                             (progn
                                (if options.allow_non_matches
                                   (if (or (== k "Tab")
                                           (== k ps))
                                       (= matched (get_matches "" true))
                                       (= matched (get_matches k true)))
                                   (= matched (get_matches k true)))
                                (= last_matched matched)  
                                (cond                                  
                                   (and (not (== k ps))
                                        (not (== k "Tab"))
                                        (not (> k.length 1))
                                        options.allow_non_matches)
                                   (progn
                                      (= prefix (+ (or (get_suffix) "") k))
                                      (render_title prefix)
                                      (when options.validate_selection
                                        (run_validations)))
                                   (== (length matched) 1)  ;; ok we matched only 1 so go ahead and put it into the stack
                                   (progn
                                      (push stack 
                                            (first (split_by "\n" matched.0.innerText)))
                                      (try 
                                         (render_stack)
                                         (catch Error (e)
                                            (log "ERROR: " e.message))))
                                   
                                   (and ;options.allow_non_matches
                                        (> (length matched) 1)
                                        (or (== k "Tab")
                                            (== k ps)))
                                   (progn
                                      (= prefix (get_suffix))
                                      (= exact_match (first (reduce (v matched)
                                                               (when (== (first (split_by "\n" v.innerText)) prefix)
                                                                  prefix))))
                                      (if exact_match
                                         (progn
                                            (push stack
                                               (first (split_by "\n" matched.0.innerText)))
                                            (try (render_stack)
                                               (catch Error (e)
                                                  (log "ERROR: " e.message))))
                                         (progn
                                            ;; find the common prefix and render title
                                            (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                            ;; subtract suffix
                                            (render_title prefix))))
                                   (> (length matched) 1)  ;; multiple matches, so add the character to the suffix
                                   (progn
                                      ;; find the common prefix and render title
                                      (= prefix (find_common_prefix (matched_as_text matched) (get_suffix)))
                                      ;; subtract suffix                                                                            
                                      (render_title prefix)))))
                          (= last_suffix (get_suffix))
                           true)))
                                   
                                ;; if it is a control type type don't display
    (select_button (button { `tabindex: 0 `class: "juno-primary" `style: "font-weight: bold;margin-right: 20px;" } (or options.select_button_text "Select")))
    (instruction_div (span {`style: "float: right; margin-right: 30px; padding-left: 8px; padding-right: 8px; font-weight: bold; color: var(--value-modified-color);"  `class: "filtered-hidden"  } 
                           select_button
                           select_text))
    (prefix_div (span { `style: "font-size: 1.1em; margin-right: 8px;" } (dtext "Select or Type:")))
    (open_selection (fn ()
                       (when (and (not (has_class? "filtered-hidden" instruction_div))
                                  options.on_select
                                  (if options.allow_non_matches
                                     (options.on_select (get_path_components))
                                     (options.on_select stack))))))
    (handle_enter_event (fn (e)
                           (cond
                              (== e.srcElement title_span)
                              (progn
                                 (handle_event e)
                                 (open_selection))
                              else
                              (get_specifics_for_event e))))
   
    (on_initialize (fn (self)
                      (progn
                          (on_key_down_event e view
                             ("Enter" (progn
                                         (handle_enter_event e)))
                                         
                             ("Escape" (progn
                                          (handle_event e)
                                          (destroy_control self)))
                             ("Tab" (progn
                                       (if (or options.allow_non_matches
                                               (not (at_leaf)))
                                           (handle_event e))
                                       (select_matches e.key)))
                             (`otherwise (progn 
                                            (when (== e.srcElement title_span)
                                               (handle_event e)
                                               (if (or (== e.key "CapsLock") 
                                                       (-> e `getModifierState "CapsLock"))
                                                   (progn
                                                      (when caps_lock_timer
                                                         (clearTimeout caps_lock_timer))
                                                      (= caps_lock_timer 
                                                         (setTimeout (fn () (add_class "juno-display-none" caps_lock_span)) 1000))
                                                      (remove_class "juno-display-none" caps_lock_span))
                                                   (add_class "juno-display-none" caps_lock_span))
                                               
                                               (select_matches e.key)
                                               ))))
                         
                         (-> title_span.parentElement
                             `appendChild
                             instruction_div)
                         (-> title_span.parentElement
                            `appendChild
                            caps_lock_span)
                         (-> title_span.parentElement `insertBefore
                             prefix_div title_span)
                         (attach_event_listener select_button
                            `click
                            (fn (e)
                               (progn
                                  (handle_event e)
                                  (open_selection))))
                         (add_class "juno-highlighted" title_span.parentElement)
                         (attach_event_listener content_view
                                                `click
                                                get_specifics_for_event ))))
    
    (get_possibles (fn (pos)
                       (cond 
                          (is_function? options.get_possibles_elem)
                          (-> options `get_possibles_elem pos)
                          (is_function? options.get_possibles)  ;;  returns either a single obj with keys or an array of those objects
                          ;; keys: ctype has_children? title path_value  and view
                          (let
                                ((idx -1)
                                 (val nil)
                                 (filter_text (last (split_by (or options.path_separator "/") title_span.innerText))))
                                (= val (-> options `get_possibles pos self))
                                (if (not (is_array? val))
                                    (progn
                                       ;(remove_class "filtered-hidden"  instruction_div)
                                       (= is_at_leaf true))
                                    (progn
                                       (= is_at_leaf false)
                                       ;(add_class "filtered-hidden" instruction_div) 
                                       ))
                                (if (and options.allow_non_matches
                                         options.validate_selection)
                                    (run_validations)
                                    (if is_at_leaf
                                       (remove_class "filtered-hidden"  instruction_div)
                                       (add_class "filtered-hidden" instruction_div)))
                                    
                                (cond
                                   (is_array? val)
                                   (for_each (obj val)
                                      (progn
                                         (inc idx)
                                         
                                         (li { `tabindex: 0
                                                `ctype: (or obj.ctype "sym" )
                                               `title: obj.title
                                               `class: (+ "juno-list-item " 
                                                          (if obj.has_children? "juno-list-item-has-children " "") 
                                                          (if (and (not (blank? filter_text))
                                                                   (not (starts_with? filter_text obj.path_value)))
                                                              "filtered-lower-opacity"
                                                              ""))
                                               `style: (or obj.style
                                                           "")
                                               `path_value: obj.path_value
                                               } 
                                               (if obj.view 
                                                   obj.view 
                                                   idx))))
                                         
                                   (is_object? val)
                                   (li { `tabindex: 0
                                         `ctype: (or val.ctype "sym" )
                                         `title: val.title
                                         `class: (+ "juno-list-item " (if val.has_children? "juno-list-item-has-children " "") (if val.class val.class ""))
                                         `style:  (+ "height: calc(100% - 20px); " (if val.style val.style ""))
                                         `path_value: (or val.path_value nil)
                                         } (if val.view val.view idx))
                                   (is_string? val)
                                   (pre { `tabindex: 0 `ctype: "string" `style: "min-width: 200px; overflow: scroll; width: calc(100% - 50px);" }
                                    val)
                                   else
                                   (pre { `tabindex: 0 `ctype: (subtype val) `style: "min-width: 200px;overflow: scroll; width: calc(100% - 50px);" }
                                    (value_to_dom val))))
                           else
                           (div { } "Missing get_possibles function or get_possibles_elem in options"))))
    (run_validations (fn ()
                        (when (and options.allow_non_matches
                                   options.validate_selection)
                           (if (-> options `validate_selection (get_path_components true) (at_leaf) last_matched)
                               (remove_class "filtered-hidden" instruction_div)
                               (add_class "filtered-hidden" instruction_div)))))
                           
                            
    (render_title (fn (new_suffix)
                     (let
                        ((suffix (or new_suffix (get_suffix) ""))
                         (ps (path_sep)))
                        (set_prop title_span
                           `innerText
                           (+ (join ps stack)
                              (cond 
                                 (at_leaf)
                                 ""
                                 (and (blank? suffix)
                                      (> stack.length 0)
                                      (if (and options.allow_non_matches
                                               options.validate_selection)
                                          (not (-> options `validate_selection (get_path_components true) (at_leaf) last_matched))
                                          true))
                                 ps
                                 (== stack.length 0)
                                 (+ "" suffix)
                                 else
                                 (+ ps suffix))))
                        (run_validations)
                        (place_caret_at_end title_span))))
    
    (render_stack (fn (prefix no_rerender)
                     (let
                        ((ol_elem nil)
                         (new_ol_elem nil))
                        
                        (if (or (not no_rerender)
                                was_at_leaf)
                        (when (> (num_ol_elems) stack.length)
                           (try
                           (for_each (pos (range_inc  stack.length (num_ol_elems)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (when ol_elem
                                    (-> ol_elem `remove))))
                           (catch Error (e)
                              (log "Error on: stack render p1: " e.message)))))
                        ;; is the stack already drawn, or do we need to render it?
                        (try
                           (for_each (pos (range (+ stack.length 1)))
                              (progn
                                 (= ol_elem (ol_for_pos pos))
                                 (if ol_elem
                                    (select_child ol_elem (prop stack pos))
                                    (progn
                                       (= new_ol_elem (create_ol_at_pos pos))
                                       (if new_ol_elem
                                          (-> content_view `append
                                             (create_ol_at_pos pos)))))))
                           (catch Error (e)
                              (log "Error on: stack render p2: " e.message)))
                        (try
                           (render_title prefix)
                           (catch Error (e)
                              (log "Error on render_title: " e.message))))))
    
    (on_render (fn (self broaden)
                       (let
                          ((next_elem nil))
                          ;(render_stack)
                          nil)))
                          
    (render (fn ()
               (if (not initial_render)
                   (progn
                      (= initial_render true)
                      (render_stack)
                      content_view)
                   nil))))
   {
     `control_bar: true
     `expose: [[`get_current_stack get_current_stack]]
     })



(defun file_tree_browser(options)
    (let
       ((create_mode options.create_mode)
        (render_entry (fn (entry)
                         (let
                              ((etype (fn (entry)
                                         (cond
                                                entry.isDirectory "directory"
                                                entry.isFile "file"
                                                entry.isSymlink "symlink")))
                               (rval nil))
                              (= rval
                               {
                                 `has_children?: entry.isDirectory
                                 `path_value: entry.name
                                 `class: (etype entry)
                                 `ctype: "sym"
                                 `view: (div { `style: "display: inline-block; width: 100%;"
                                               `class: (+ "juno-type-file-entry " (etype entry)) }
                                               entry.name
                                               (if entry.isDirectory
                                                    (span { `style: "display: inline-block; float: right" } "▸")
                                                      "")) })
                              ;(log "render_entry: entry rval: " rval rval.view.outerHTML)
                              rval)))
        
        (get_possibles (fn (pos control)
                           (let
                              ((next_values (if (== pos 0)
                                                (http/list_files "/")
                                                (http/list_files (join "/" (-> control `get_current_stack))))))
                              (when (is_array? next_values)
                                 (sort next_values { `key:`name }))
                              (= next_values (clone next_values))
                              (cond
                                 (is_array? next_values)
                                 (for_each (entry next_values)
                                    (render_entry entry))
                                 (instanceof next_values Blob)
                                 {
                                   `has_children?: false
                                   `ctype: "file"
                                   `style: "width: calc(100% - 10px) !important;"
                                   `view: (div { `style: "display: inline-block; width: calc(100% - 50px); height: 100%; overflow: hidden" }
                                               (div { `style: "height: calc(100% - 30px); overflow: scroll;" }
                                                    (pre {} (-> next_values `text)))
                                               (div { `style: "padding: 10px;" }
                                                    []))  ;; placeholder for any additional information about the file
                                   }
                                 else
                                 {
                                   `has_children?: false
                                   `ctype: "file"
                                   `view: (pre {} (sub_type next_values))
                                   }))))
        
        (control (tree_browser (+ { `path_separator: "/"
                                    `render_entry: render_entry
                                    `get_possibles: get_possibles
                                    allow_non_matches: (if create_mode true false)
                                    select_text: (if create_mode
                                                    "Press Enter To Create"
                                                    "Press Enter To Open")
                                    select_button_text: (if create_mode
                                                           "Create"
                                                           "Open")
                                    validate_selection: (fn (path at_leaf matches)
                                                           (try
                                                              (progn
                                                                 ;(log "v:" path  "at_leaf: " at_leaf "# m: " (length matches))
                                                                 (cond
                                                                    at_leaf
                                                                    false
                                                                    (ends_with? "/" path)
                                                                    false
                                                                    (== 0 (length path))
                                                                    false
                                                                    (and (is_array? matches)
                                                                         (== (length matches) 1)
                                                                         (== (first (split_by "\n" (prop (first matches) `innerText)))
                                                                             (last (split_by "/" path))))
                                                                    false
                                                                    else
                                                                    true))
                                                              (catch Error (e)
                                                                 (progn
                                                                    (log "Error: " e.message)
                                                                    false))))
                                    }
                                    (if (is_object? options)
                                        options
                                        {})))))
       
       control))



(defun save_active_buffer (save_all)
  (cond
    save_all
    (for_each (control (select_controls (fn (ctl) (is_function? (prop ctl `save)))))
              (-> control `save))
    (and *last_focus*
         (prop *last_focus* `save))
    (-> *last_focus* `save)
    *last_focus*         
    (notify (+ "" (or (prop *last_focus* `name) "Unnamed") " " (dtext "doesn't have a save method") "."))
    else
    (notify (dtext "There isn't an active control."))))
    
    
(defun split_control (dir)
   (alert_on_error "Unable to perform split"
                   (let
                      ((target *last_focus*))
                      (if (eq nil target)
                          (throw Error "No Focused Control to split"))
                      (cond
                         (and (== dir "vertical")
                              (prop target `split_vertical))
                         (-> target `split_vertical)
                         (and (== dir "horizontal")
                              (prop target `split_horizontal))
                         (-> target `split_horizontal)
                         (and (== dir "vertical")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_right" target (last (-> (control_holding_tank) `controls)))
                         (and (== dir "horizontal")
                              (> (length (-> (control_holding_tank) `controls)) 0))
                         (container_view_operation "split_below" target (last (-> (control_holding_tank) `controls)))
                         else
                         (notify (+ "No controls to split to" (prop target.options `name) " cannot be split"))))))


(defcontrol line_display ()
   ((menu_items (fn ()
                   [["Test" (fn ()
                               (notify "Notify Test Menu"))]]))
    (current_value (or "Not Set"))
    (set (fn (val)
            (progn
               (= current_value val)
               (do_render))))
    (render (fn ()
               (div { `class: "juno-mono-space" `style: "white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" }
                current_value))))
   {
       `buffer_bar: false
       `expose: [[`set set]]
       `usage: []
   })


(defun build_documentation_datalist ()
   (let
      ((keywords (new Set))
       (dlist_id "documentation_datalist")
       (dlist nil))
      (for_each (pset (pairs *tags_to_meta*))
         (progn
            (-> keywords `add pset.0)
            (-> keywords `add (first (split_by "/" pset.1.0)))
            (for_each (`target pset.1)
               (-> keywords `add (second (split_by "/" target))))))
      (= dlist (datalist { `id: dlist_id } (for_each (keyword (sort (to_array keywords)))
                            (option keyword))))
      (aif (get_by_id dlist_id)
          (-> it `remove))
      (-> (first (get_by_tag "body"))
          `append dlist)))

(defglobal *building_document_index* false)

(defun build_tag_index ()
   (unless *building_document_index*
      (setq *building_document_index* true)
      (let
         ((new_db {})
          (stime (time_in_millis))
          (env nil)
          (is_reindex? (if (== (length (keys *tags_to_meta*)) 0)
                           false
                           true)))
         (for_each (ns (namespaces))
            (progn
               (= env (-> Environment `get_namespace_handle ns))
               (for_each (pset (pairs env.definitions))
                  (destructuring_bind (name def)
                     pset
                     (when def.tags
                        (when is_reindex?
                           (sleep 0.005))
                        (for_each (tag def.tags)
                           (when (and (is_string? tag)
                                      (not (== tag "constructor")))
                              (if (eq nil (prop new_db tag))
                                  (set_prop new_db
                                     tag
                                     []))
                              (assert (prop new_db tag) (+ "Error: tag " tag " should be a place in new_db"))
                              (push (prop new_db tag)
                                    (+ "" ns "/" name)))))))))
         (= *tags_to_meta*
            new_db)
         (build_documentation_datalist)
         (if (> __VERBOSITY__ 2)
             (log (+ "build_tag_index: time to index: " (- (time_in_millis) stime) "ms  " (if is_reindex? " (throttled)" ""))))
         (setq *building_document_index* false)))
      
   {
     `description: "Builds or rebuilds the tag index as held in *tags_to_meta* for use by the documentation facility."
     `tags: ["help" "index" "tags" "rebuild" "documentation" ]
     `usage: []
   })

(defun search_documentation_index (search_text target_element)
   (if (and (is_string? search_text)
              (> search_text.length 1)
              (is_element? target_element))
      (let
         ((results_by_ns {})
          (target nil)
          (ns nil)
          (sym nil)
          (not_found (fn () true))
          (comps []))
         ;(log "searching for " search_text)
      ;; do we have tags?
      (when (prop  *tags_to_meta* search_text)
         (for_each (command (prop  *tags_to_meta* search_text))
            (progn
               (= comps (split_by "/" command))
               (= ns (first comps))
               ;(log "ns: " ns comps.1)
               (if (eq nil (prop results_by_ns ns))
                   (set_prop results_by_ns
                      ns
                      {}))
               (set_prop (prop results_by_ns ns)
                         comps.1
                         (resolve_path [ `definitions comps.1 ] (-> Environment `get_namespace_handle ns))))))
      (for_each (ns (namespaces))
         (progn
            (= comps (split_by "/" search_text))
            (if (> comps.length 1)
                (= sym (second comps))
                (= sym (first comps)))
            (unless (resolve_path [ ns sym ] results_by_ns)
               (aif (resolve_path [ `definitions sym ] (-> Environment `get_namespace_handle ns))
                    (progn
                       (make_path [ ns sym ] results_by_ns it)))
               (aif (resolve_path [ `global_ctx `scope sym ] (-> Environment `get_namespace_handle ns))
                    (progn
                       (make_path [ ns sym ] results_by_ns 
                                  {
                                      `name: sym
                                      `description: (+ "Undocumented: " (sub_type it))
                                  }))))))
      (when (> __VERBOSITY__ 0)
         (log "search_documentation_index: results:" results_by_ns))
      
      (try
         (= target
            (div
               (for_each (ns_title (keys results_by_ns))
                  [(details { `open: true `style: "margin-bottom: 10px;"  }
                            (summary { style: "font-size: 1.2em; color: var(--namespace-color); font-weight: bold" } ns_title)
                            (table { `style: "width: 100%;font-size: 1.1em; background: var(--editor-bg-color);" }
                                   (thead
                                      (tr (th { `style: " padding: 5px;" } "Symbol Name") 
                                          (th { `style: "width: 100%; padding: 5px;" } "Description")))
                                   (tbody
                                      (for_each (pset (sort (pairs (prop results_by_ns ns_title))
                                                            { `key: [ 0 ] }))
                                         (destructuring_bind (k meta_obj)
                                            pset
                                            (when k
                                               
                                               (defvar desc "")
                                               (defvar stype (try 
                                                                (or (first (reduce (m (meta_for_symbol k true))
                                                                              (when (and (== m.namespace ns_title)
                                                                                         m.type)
                                                                                 m.type)))
                                                                    (progn
                                                                       (defvar tmp (-> Environment `get_global (+ ns_title "/" k) not_found))
                                                                       (if (== tmp not_found)
                                                                           "undefined"
                                                                           (sub_type tmp))))
                                                                (catch Error (e)
                                                                   "unknown")))
                                               (tr { `style: " vertical-align:top;" }
                                                   (td { `class: (+ "juno-requires " "juno-type-" (lowercase stype))
                                                         `tabindex: 0 
                                                         `title: stype
                                                         `style: "line-height: 1.5em; min-width: 200px; cursor: pointer; border-bottom: 1px solid var(--main-accent-line); padding-bottom: 10px; margin-bottom: 10px; padding-right: 5px; font-weight: bold; text-align: right; vertical-align:top;" } 
                                                       k)
                                                   (td { `style: "line-height: 1.5em; border-bottom: 1px solid var(--main-accent-line); margin-bottom: 10px;vertical-align:top;  padding-bottom: 10px; width: calc(100% - 150px);" }
                                                       (or (and meta_obj.description
                                                                (try 
                                                                   (progn
                                                                      (= desc (prop (unpack_description meta_obj.description) `innerText))
                                                                      (if (> desc.length 150)
                                                                          (= desc (+ (-> desc `substr 0 150) "...")))
                                                                      (div { `style: "" }
                                                                           desc))
                                                                          
                                                                   (catch Error (e)
                                                                      (+ "error: " e.message " - can't unpack description"))))
                                                           "(No Description)")))))))))])))
         (catch Error (e)
            (log "ERROR: " e.message e)))
      (-> target_element `replaceChildren target)
      (setTimeout (fn ()
                     (focus_to target.children.0.children.0))
                  50))
      (log "Inproper args to search_documentation_index: " search_text)))


;; place holder for the control reference by juno_documentation_control
(defun toggle_help_panel ()
   true)

(defcontrol juno_documentation_control ()
   ((definition_view (div { `class: "juno-log-output" `style: "margin-top: 15px; padding: 5px; overflow: scroll; width: calc(100% - 20px);" } "Help Introduction"))
    (search_input (input { `type: "search" `list: "documentation_datalist" `placeholder: (dtext "Search Documentation") `style: "font-weight: bold; display: inline-block; padding: 10px; width: calc(100% - 10px); border: 0px; background: var(--editor-bg-color); color: var(--main-color);" } ))
    (search_bar_elem (div { `style: "display: inline-block; width: calc(100% - 0px);height: 20px;" }
                          search_input))
    (search_result_view (div { `style: "overflow: scroll; height: calc(100% - 10px);  width: calc(100% - 20px); " }
                             (div { `style: "width: 100%; text-align: center; margin-top: 15px; padding: 10px; font-size: 1.2em;" } (dtext "Type Search Text and Press Enter"))))
    (search_view (div { `style: "display: inline-block; height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden; padding: 5px;" 
                        `class: "juno-display-none" } 
                      (div { `style: "display: inline-block; margin-top: 15px; font-weight: bold; padding: 5px; font-size: 1.2em;" }  
                           (dtext "Search Results"))
                      search_result_view))
    (upper_content_view (div { `class: "juno-log-output" `style: "padding: 5px;height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden;" } 
                             search_bar_elem
                             search_view
                             definition_view))
    (content_view (div { `class: "juno-log-output" `style: "padding: 5px;height: calc(100% - 15px); width: calc(100% - 10px); overflow: hidden;" } 
                   upper_content_view))
    (view (div { `class: "juno-log-output" `style: "padding: 5px; width: calc(100% - 20px); overflow: hidden;"} 
          content_view))
    (name "Juno Documentation")
    (title_span (span { `style: "font-weight: bold; margin-right: 15px;" } (dtext "Documentation")))
    (pin_button (button { } (dtext "Pin")))
    (history_button (button { } (dtext "History")))
    (pinned? (fn ()
                (or (has_class? "juno-button-on" pin_button)
                    (not (has_class? "juno-display-none" search_view)))))
    (history [])
    (history_max_length 15)
    (current_symbol nil)
    (handle_click (fn (e)
                     (cond
                        (has_class? "juno-requires"  e.srcElement)
                        (progn
                           (show_documentation e.srcElement.value))
                        (has_class? "juno-tag" e.srcElement)
                        (progn
                           (-> self `search_by_tag e.srcElement.innerText)))))
    (control_bar_elements [pin_button history_button])
    (render_command_elem (fn (command)
                            (let
                               ((results (describe command true)))
                               (for_each (meta_obj (or results ()))
                                  (format_help meta_obj { `on_click: handle_click } )))))
    
    (render_help (fn (command)
                    (div { `class: "" `style: "overflow-x: hidden;" }
                         (for_each (v (to_array (or (render_command_elem command) [])))
                            (div { `style: "padding: 5px; margin-bottom: 10px; background: var(--editor-bg-color);" }
                                 v)))))
    (search_by_tag (fn (tagname)
                      (progn
                         (set_prop search_input `value tagname)
                         (enable_search)
                         (search_documentation_index tagname search_result_view))))
    (remove_all_priors (fn (command)
                          (progn
                             (for_each (elem (-> history_content_view `querySelectorAll (+ "[command='" command "']")))
                                (try
                                   (if (is_element? elem)
                                       (-> elem.parentElement `remove))
                                   (catch Error (e)
                                      (log "ERROR: on remove: " e.message (sub_type elem)))))
                             (when (contains? command history)  ;; if history contains the command name already, remove it and display it first
                                  (defvar idx (index_of command history))
                                  (if (< idx 0)
                                      (notify "cannot find history item, even though contains? said it was there.")
                                      (-> history `splice idx 1))))))
    
    (message_receiver (fn (event_obj force)
                         (let
                            ((first_arg (let
                                           ((comps (split_by "(" event_obj.args.0)))
                                           (or (second comps)
                                               (first comps))))
                             (num_found_in_history_view 0)
                             (dup_remover {})
                             (new_view nil))
                            ;; deal with recording the history 
                            (when first_arg
                               ;; if there is anything in the history view that matches it, remove it so we can put it back on top
                               (remove_all_priors first_arg)
                               (= num_found_in_history_view (length (to_array (-> history_content_view `querySelectorAll (+ "[command='" first_arg "']")))))
                               
                               (push history
                                  first_arg)
                               (if (pinned?)
                                   (-> history_content_view `prepend (render_help first_arg))
                                   (if (> (length history) 1)
                                       (-> history_content_view `prepend (render_help (prop history (- (length history) 2)))))))
                            
                            ;; if the history is too long, prune it
                            (when (> (length history) history_max_length)
                               (take history)
                               (aif (last history_content_view.children)
                                    (-> it `remove)))
                            
                            
                            (when (or (and force first_arg)
                                      (and first_arg
                                         (not (pinned?))))
                               (= current_symbol first_arg)
                               (-> definition_view `replaceChildren
                                  (render_help current_symbol))))))
    
    (handler_function_id (gen_id "hid"))
    (history_mode? (fn ()
                      (has_class? "juno-button-on" history_button)))
    (history_content_view (div { `style: "overflow: scroll; height: calc(100% - 10px); width: calc(100% - 20px;) overflow: scroll;" } ))
    (history_view (div { `class: "juno-log-output" `style: "height: calc(100% - 10px); width: calc(100% - 10px); overflow: hidden; padding: 5px;" } 
                       history_content_view))
    (show_documentation (fn (text)
                           (progn
                              (hide_search_view)
                              (message_receiver { `args: [ text ] }))))
    (take_focus (fn ()
                   (focus_to search_input)))
    (split_view nil)
    (show_history (fn (show?)
                       (let
                          ()
                          (if show? ;; update our button
                             (add_class "juno-button-on" history_button)
                             (remove_class "juno-button-on" history_button))
                          (cond
                             (and (history_mode?)
                                  (is_control? split_view))
                             nil ;; already showing
                             (and (history_mode?)
                                  (eq nil split_view))
                             (progn
                                (-> upper_content_view `remove)
                                (= split_view
                                   (split_view_horizontal upper_content_view history_view))
                                (-> content_view
                                   `replaceChildren
                                   split_view.view))
                             (not (history_mode?))
                             (progn
                                (-> split_view.view `remove)
                                (-> split_view `destroy)
                                (= split_view nil)
                                (-> content_view
                                   `replaceChildren
                                   upper_content_view))))))
                             
    (reindex_timer nil)                      
    (is_displayed? (fn ()
                      (progn
                         (defvar ctl_holding_tank (control_holding_tank))
                         (if (->  ctl_holding_tank `has_control? self)
                             false
                             true))))
    (render (fn ()
               (if (not initialized)
                   view)))
    (on_render (fn ()
                  (when current_symbol
                     (-> definition_view `replaceChildren
                        content_view))))
    (enable_search (fn ()
                      (progn
                         (remove_class "juno-display-none" search_view)
                         )))
    
    (hide_search_view (fn ()
                         (progn
                            (add_class "juno-display-none" search_view))))
                           
    (on_initialize (fn (anything_here)
                      (progn
                         
                         (register_event_handler nil "display_usage" handler_function_id message_receiver)
                         (attach_event_listener pin_button
                            `click
                            (fn (e)
                               (if (has_class? "juno-button-on" pin_button)
                                   (remove_class "juno-button-on" pin_button)
                                   (add_class "juno-button-on" pin_button))))
                         (attach_event_listener history_button
                            `click
                            (fn (e)
                               (progn
                                  (show_history (not (history_mode?))))))
                         
                         (attach_event_listener search_input
                            `click
                            (fn (e)
                               (progn
                                  (sleep 0.05)
                                  (if (blank? search_input.value)
                                      (hide_search_view)
                                      (enable_search)))))
                         (attach_event_listener search_input
                            `keydown
                            (fn (e)
                                  (cond
                                     (and (== e.key "Escape")
                                          e.shiftKey)
                                     (progn
                                        (handle_event e)
                                        (toggle_help_panel))
                                     (== e.key "Escape")
                                     (progn
                                        (handle_event e)
                                        (set_prop search_input
                                           `value
                                           "")
                                        (hide_search_view)))))
                         (attach_event_listener search_input
                            `keyup
                            (fn (e)
                               (progn
                                  (when (== e.key "Enter")
                                     (search_documentation_index e.srcElement.value search_result_view))
                                  (if (> (length search_input.value) 0)
                                      (enable_search)
                                      (hide_search_view)))))
                         (attach_event_listener view`
                            `keyup
                            (fn (e)
                               (cond
                                  (and (== e.key "Enter")
                                       (has_class? "juno-requires" e.srcElement))
                                  (show_documentation e.srcElement.innerText)
                                  (and (== e.key "Enter")
                                       (has_class? "juno-tag" e.srcElement))
                                  (search_by_tag e.srcElement.innerText)
                                  (== e.key "Escape")
                                  (focus_to search_input))))
                         (attach_event_listener search_result_view
                            `click
                            (fn (e)
                               (when (has_class? "juno-requires" e.srcElement)
                                  (show_documentation e.srcElement.innerText))))
                         (build_tag_index)
                         (= reindex_timer
                            (setInterval build_tag_index 60000))
                         anything_here)))
    (on_destroy (fn (anything_here)
                   (progn
                      (remove_event_handler nil "display_usage" handler_function_id)
                      (if reindex_timer
                         (clearInterval reindex_timer))
                      true)))
    (set_pinned (fn (value)
                  
                   (cond
                      (== value current_symbol)
                      (add_class "juno-button-on" pin_button)
                      (is_string? value)
                      (progn
                         (add_class "juno-button-on" pin_button)
                         (message_receiver { args: [ value ] } true))
                      else
                      (add_class "juno-button-on" pin_button))))
    (release_pin (fn ()
                    (remove_class "juno-button-on" pin_button)))
    
    )
   {
     `control_bar: true
     `expose: [[ `set_pinned set_pinned]
               [ `search_by_tag search_by_tag ]
               [ `is_displayed? is_displayed? ]
               [ `take_focus take_focus ]
               [ `get_history (function () (clone history)) ]]
     `usage: []
     })

;; hide the documentation control behind a singleton function

(defun juno_documentation (options)
   (aif (get_control_by_name "Juno Documentation")
        it
        (juno_documentation_control options))
   {
       `tags: ["help" "control" "show" "search" "tags" "documentation" ]
       `usage: ["options:object"]
       `description: "Creates a new documentation control if none exists and return it, otherwise returns the existing documentation control."
   })


(defun toggle_help_panel (focus_to_help?)
   (progn
      (defvar ctl_holding (control_holding_tank))
      (defvar focused *last_focus*)
      (try
         (cond
            (-> ctl_holding `has_control? (juno_documentation))
            (progn
               ((fn () (place_control `right (juno_documentation))))
               (when (not focus_to_help?)
                  (setTimeout (fn ()
                                 (progn
                                    (focus_to_editor focused))) 5)))
            (get_control_by_name "Juno Documentation")
            (hide_control (juno_documentation))
            else
            (progn
               (defvar ctl (juno_documentation))
               ((fn () (place_control `right ctl)))
               (when (not focus_to_help?)
                  (setTimeout (fn ()
                                 (progn
                                    (focus_to_editor focused))) 5))))
               
         (catch Error (e)
            (notify (+ "Unable to open help panel: " e.message)))))
   {
     `description: "Shows the documentation panel if it is not displayed."
     `tags: ["help" "show" "documentation" ]
     `usage: []
     })

(defun show_help_panel (focus_to_search)
   (let
      ((ctl (get_control_by_name "Juno Documentation")))
      (cond
         (and ctl (-> ctl `is_displayed?))
         true
         else
         (progn
            (toggle_help_panel true)))
      (if focus_to_search
         (setTimeout (fn () 
                        (progn
                           (= ctl (get_control_by_name "Juno Documentation"))
                           (-> ctl `take_focus)) 20))))
   {
     `description: "Shows the documentation panel if it is not displayed."
     `tags: ["help" "show" "documentation" ]
     `usage: []
     })
        
             
     
  

(defun *help_menu_function* ()
  [["Toggle Documentation" (fn () 
                              (toggle_help_panel)) ]])

(defun tag_selector (options tags)
   (let
      ((sorted_tag_names (sort (keys *tags_to_meta*)))
       (tag_dlist_id (gen_id `tags))
       (tag_dlist (datalist { `id: tag_dlist_id }
                         (for_each (t sorted_tag_names)
                            (option t))))
       (tag_view (div { `style: "display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start;" }))
       (current_tag nil)
       (extra_space (if (is_number? options.extra_space)
                        options.extra_space
                        2))
       (empty_text (or options.empty_text "name?"))
       (tag_content (fn ()
                       (uniq (reduce (text (each tag_view.children `value))
                                (unless (== empty_text text)
                                   text)))))
       
       (focus_to_tag (fn (tag)
                        (try
                           (progn
                              (-> tag `select))
                           (catch Error (e)
                              (log "error: " e.message)))))
       
       (already_have_tag? (fn (text)
                             (let
                                ((found nil))
                                (for_each (elem (or tag_view.children []))
                                   (when (== elem.value text)
                                      (= found elem)
                                      (break)))
                                found)))
       (value_count (fn (text)
                       (let
                          ((count 0))
                          (for_each (elem (or tag_view.children []))
                             (when (== elem.value text)
                                (inc count)))
                          ;(log "Count is: " count text)
                          count)))
       (prune_empties (fn ()
                         (for_each (t (or tag_view.children []))
                            (if (== t.value empty_text)
                                (-> t `remove)))))
       (adjust_size (fn (elem)
                       (try
                          (if (== elem document.activeElement)
                              (progn
                                 (set_style [["width" (+ "" (+  extra_space elem.value.length) "ch")]] elem))
                              (progn
                                 (set_style [["width" (+ "" (+  2 elem.value.length) "ch")]] elem)))
                          (catch Error (e)
                             (log "ERROR: " e.message)))))
       (new_tag (fn (text focus?)
                   (aif (already_have_tag? text)
                       (if focus? 
                          (focus_to_tag it)
                          false)
                       (let
                          ((tag (input { tabindex: 0
                                         class: "juno-editable"
                                         style: "padding: 5px;margin-right: 10px;"   
                                         list: tag_dlist_id
                                         contenteditable: true
                                         value: text }
                                        )))
                          (adjust_size tag)
                          (-> tag_view `append
                             tag)
                          (when focus?
                             (sleep 0.001)
                             (focus_to_tag tag))))))
       
       (view (div { `style: "position: relative;" }
                  tag_dlist
                  tag_view)))
      
      (attach_event_listener tag_view
         `keydown
         (fn (e)  ;; don't allow spaces in tags
            (cond 
               (or (== e.key "Enter")
                   (contains? e.key "/[]{}():;.,<>|\\\\=`~"))
               (handle_event e)
               (and (== e.key " ")
                    (not (== e.srcElement (last tag_view.children))))
               (handle_event e)
               ;; if we are at the end and we have a `blank?` ie. empty_text (default `name?`), release the focus 
               (and (== e.key "Tab")
                    (== e.srcElement (last tag_view.children))
                    (== e.srcElement.value empty_text))
               (progn
                  (if (> (length tag_view.children) 1)
                      (-> e.srcElement `remove)))
               
               ;; if we have a filled out tag, and are on the last tag, create a new one with tab or space is pressed
               (and (or (== e.key "Tab")
                        (== e.key " "))
                    (not e.shiftKey)     
                    (== e.srcElement (last tag_view.children))
                    (> (length e.srcElement.value) 1))
               (progn
                  (handle_event e)
                  (new_tag empty_text true))
               (and (== e.key "Tab")
                    e.shiftKey
                    (== e.srcElement.value empty_text))
               (progn
                  (handle_event e)
                  (let
                     ((prior e.srcElement.previousSibling))
                     (-> e.srcElement `remove)
                     (if prior
                        (focus_to_tag prior))))
               (and (== e.key "Backspace")   ;; remove when tag has no content
                    (== e.srcElement.value empty_text))
               (let
                  ((prior e.srcElement.previousSibling)
                   (next e.srcElement.nextSibling))
                  (handle_event e)
                  (-> e.srcElement `remove)
                  (cond
                     prior
                     (focus_to_tag prior)
                     next
                     (focus_to_tag next)
                     (== (length tag_view.children) 0)
                     (new_tag empty_text true))))))
              
               
                    
      
      (attach_event_listener tag_view
         `keyup
         (fn (e)
            (progn
               (cond
                  (and (== e.key "Backspace") 
                       (blank? e.srcElement.value))
                  (progn
                     (set_prop e.srcElement `value empty_text)
                     (focus_to_tag e.srcElement)))
               (adjust_size e.srcElement)
               (if (> (value_count e.srcElement.value) 1)
                   (add_class "juno-input-error" e.srcElement )
                   (remove_class "juno-input-error" e.srcElement))
               (set_prop e.srcElement
                  `value
                  (lowercase e.srcElement.value))
               (when options.on_change
                  (-> options `on_change (tag_content))))))
      
      (attach_event_listener tag_view
         `focusin
         (fn (e)
            (progn
               (focus_to_tag e.srcElement))))
      
      (attach_event_listener view
         `focusout
         (fn (e)
            (progn
               (adjust_size e.srcElement)
               (when options.on_change
                  (-> options.on_change (tag_content))
               ))))
      
      (if (and (is_array? tags)
               (> tags.length 0))
          (for_each (tag (or tags []))
             (new_tag tag))
          (new_tag empty_text))
      ;(setTimeout (fn () (focus_to_tag tag_view.children.0)) 10)
      view)
   {
     `description: (+ "Creates a simple DOM Element for creating or editing an "
                      "array of tags (unique strings).  Uses the *tags_to_meta* "
                      "object as a dependency to build the data list selections "
                      "for the tags.  Given an initial array of tags, these "
                      "provided tags will be presented, otherwise a new tag "
                      "with the empty text will be generated and displayed as "
                      "a means to start creating a list of tags.<br>"
                      "Options:<br>"
                      "empty_text:string - When a new tag is generated this "
                      "provided text is shown.  The default is 'name?'<br>"
                      "extra_space:number - How many characters to optionally "
                      "pad the input elements, since the width of the elements "
                      "are measured by the 'ch' unit.<br>"
                      "on_change:function - When a change occurs to a tag, "
                      "or when a tag is removed or created, this function " 
                      "is called with an array of strings, representing the "
                      "tag set that the user is editing.<br>")
     `usage: ["options:object" "tags:array"]
     `tags: ["view" "DOM" "tags" "edit" "manage" "tag" "element"]
     })

(defun_sync get_cursor_position (element)
  (javascript | {
                  let position = 0;
                  const isSupported = typeof window.getSelection !== "undefined";
                  if (isSupported) {
                       const selection = window.getSelection();
                       if (selection.rangeCount !== 0) {
                              const range = window.getSelection().getRangeAt(0);
                              const preCaretRange = range.cloneRange();
                              preCaretRange.selectNodeContents(element);
                              preCaretRange.setEnd(range.endContainer, range.endOffset);
                              position = preCaretRange.toString().length;
                              }
                       }
                  return position;
                  } |))

(defun_sync get_caret_coordinates ()
   (javascript | {
                   let x = 0,
                   y = 0;
                   const isSupported = typeof window.getSelection !== "undefined";
                   if (isSupported) {
                                      const selection = window.getSelection();
                                      if (selection.rangeCount !== 0) {
                                                                        const range = selection.getRangeAt(0).cloneRange();
                                                                        range.collapse(true);
                                                                        const rect = range.getClientRects()[0];
                                                                        if (rect) {
                                                                                    x = rect.left;
                                                                                    y = rect.top;
                                                                                    }
                                                                        }
                                      }
                   return { x, y };
                   } | ))

(defun_sync element_to_lisp (element options)
   (if (is_element? element)
       (let
          ((tag_name (if (is_function? options.tagname_for_element)
                         (-> options `tagname_for_element element)
                         element.tagName))
           (ns (if (is_string? options.use_ns)
                   (+ options.use_ns "/")
                   ""))
           (elem_as_lisp (list (+ "=:" ns (lowercase tag_name))))
           (acc [])
           (nodes nil)
           (ptype nil)
           (val nil)
           (attrib_list (prop element `attributes))
           (attribs {}))
          (for_each (attrib_num (range (length attrib_list)))
             (progn
                (set_prop attribs
                   (resolve_path [ `attributes attrib_num `name ] element)
                   (resolve_path [ `attributes attrib_num `value ] element))))
          (push elem_as_lisp
             attribs)
          (= nodes element.childNodes)
          (for_each (cnum (range (length nodes)))
             (cond 
                (== 3 (resolve_path [ cnum `nodeType ] nodes))
                (push elem_as_lisp
                   (if (is_function? options.on_text)
                       (-> options `on_text (resolve_path [ cnum `nodeValue] nodes) nodes)
                       (resolve_path [ cnum `nodeValue] nodes)))
                (== 1 (resolve_path [ cnum `nodeType ] nodes))
                (push elem_as_lisp
                   (element_to_lisp (resolve_path [ cnum ] nodes) options))))
          (if (is_function? options.on_element_complete)
              (-> options `on_element_complete elem_as_lisp)
              elem_as_lisp))
       [ "UNKNOWN:" element ])
   {
     `description: (+ "Given a DOM element, returns the lisp represenation of the DOM element.<br>"
                      "If provided with an options object, the following keys are applicable:<br>"
                      "tagname_for_element:(fn element) - For every new element encountered in the "
                      "provided tree, will be called with the new element.  The function should "
                      "return a string value to be used for the tagname as opposed to the original "
                      "element tagName value.<br>"
                      "use_ns:string - Qualify the emitted tag symbols with the provided namespace.<br> "
                      "on_text:(function text nodes) - Will be called on a text node with the text and "
                      "and the sibling nodes.<br>"
                      "on_element_complete:(function array) - Will be called with the quoted lisp form "
                      "that was constructed.  The function can then manipulate the completed form "
                      "prior to it being placed in the returned lisp form.  Note that this function "
                      "is called for every completed element, not just the final return value.")
     `usage: ["element:element" "options:object"]
     `tags: ["DOM" "ui" "serialize" "serialization" "view" "element" ]
   })




;; verbs for our editing command language

(defun get_selection ()
   (-> window `getSelection))

(defun_sync get_range (selection index)
   (-> selection `getRangeAt (or index 0)))

(defmacro remove_all_ranges (selection)
   `(-> ,#selection `removeAllRanges))

(defmacro collapse_to_start (selection)
   `(-> ,#selection `collapseToStart))

(defmacro collapse_to_end (selection)
   `(-> ,#selection `collapseToEnd))

(defun_sync select_element (elem)
   (-> (get_selection) `selectAllChildren elem))

(defun_sync move_to_point (point_obj)
   (progc
      (when point_obj.selection
         (focus_to (if (== point_obj.pos_type 1)
                       point_obj.pos_node
                       point_obj.pos_node.parentElement))
         (defvar selection (get_selection))
         (remove_all_ranges selection)
         (-> selection `addRange point_obj.range))))
         
(defun_sync move_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `move dir (or granularity "character"))))))

(defun_sync extend_from_point (dir granularity)
   (progc
      (let
         ((selection (get_selection)))
         (when selection
            (-> selection `modify `extend dir (or granularity "character"))))))

(defun point_for (root_element)
   (let
      ((selection (get_selection))
       (selrange (get_range selection))
       (selected_node selrange.startContainer)
       (offset selrange.startOffset)
       (position (progn
                    (if (== selrange.startContainer.nodeType 3)
                        (progn
                           (get_cursor_position selrange.startContainer.parentElement))
                        selrange.endOffset)))
       (current_element selected_node)
       (path []))
      (while (and (not (eq current_element nil))
                  (not (== current_element root_element)))
         (progn
            (prepend path current_element)
            (= current_element current_element.parentElement)))
      { dom_path: path
        position: position
        pos_type: selected_node.nodeType
        pos_node: selected_node
        selection: selection
        range: selrange
        }))

(defun_sync select_node_at_point ()
   (let
      ((selection (get_selection))
       (selrange (get_range selection)))
      (if (== selrange.startContainer.nodeType 3)
         (-> selection `selectAllChildren selrange.startContainer.parentElement)
         (-> selection `selectAllChildren selrange.startContainer))))
       
      
(defun_sync get_text_around_point (point)
   (let
      ((text [])
       (elem nil))
      (progc
         (when point
            (cond 
               (== point.pos_type 1)
               (progn
                  (= elem point.pos_node))
               (== point.pos_type 3)
               (progn
                  (= elem point.pos_node.parentElement))))
         (when elem
            (push text
               (-> elem.innerText `substr 0 point.position))
            (push text
               (-> elem.innerText `substr point.position)))
         text))
   {
       description: (+ "Given a point object,returns an array that can "
                       "contain up to two strings.  The first value, at position "
                       "0, is the element text pior to the point's position. "
                       "The second value is the text of the element after "
                       "the point's position.")
       usage: ["point_object:object"]
       tags: ["DOM" "point" "edit" "selection" "editor" "select"]
   })
         
            
               
(defun_sync point_tag_path (point)
   (for_each (c point.dom_path)
      (progn
         (if (== 1 c.nodeType)
             c.tagName
             "text")))
   {
       `description: "Given a point object, returns the tag names that comprise the path to the point."
       `usage: ["point:object"]
       `tags: ["point" "editor" "DOM" "selection" "select"]
   })



(defun insert_elem_at_point (elem under_root)
      (try
         (let
            ((selection (get_selection))
             (selrange (-> selection `getRangeAt 0))
             (parent_element (if (== selrange.startContainer.nodeType 3)  ;; text node
                                 selrange.startContainer.parentElement
                                 selrange.startContainer))
             (offset selrange.startOffset)
             (remaining_text nil))
            ;; extend it from the current point
            
            (-> selrange `setEndBefore parent_element.nextSibling)
            (= remaining_text (-> selrange `toString))
            (-> selection `deleteFromDocument)
            (= selection (get_selection))
            (remove_all_ranges selection)
            (-> selection `addRange selrange)
            (-> parent_element `append elem remaining_text)
            (collapse_to_start selection))
         (catch Error (e)
            (log (+ "ERROR: insert_elem_at_point:" e.message)))))


(defun_sync point_under_element_tag? (tag_name point)
   (contains? tag_name (point_tag_path point))
   {
       description: (+ "Returns true if the provided editor point is in a "
                        "DOM tree containing the provided tagname, otherwise false.")
       usage: ["tag_name:string" "point:object"]
       tags: ["editor" "point" "cursor" "DOM" "tree" "element"]
   })

(defparameter *markdown_rules*
   {
     reload_rules:{
         on_event: `keydown
         key_sequence: "Alt-L"
         handle_event: true
         qualifier: (fn (point ctl)
                       true)
         exec: (fn (point ctl event)
                  (progn
                     (notify (+ "Reloading Markdown Rules: " ctl.name))
                     (-> ctl `reload_rules)))
         
     }
     
     on_blank:{
         on_event: `keyup
         key_sequence: "Backspace"
         handle_event: false
         qualifier: (fn (point ctl)
                       (progn
                          (defvar text (prop (-> ctl `get_root_element) `innerText))
                          (or (blank? text)
                              (== text "\n"))))
         exec: (fn (point ctl event)
                  (progn
                     (doc_exec `insertHTML "<div>Enter text!</div>")
                     (move_point `backward `character)
                     (select_node_at_point)))
     }
     insert_pre:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keyup
         
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "```"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-P"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: false       ;; we don't care about handling the event
         
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are already in a pre
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     ;(move_to_point point)
                     (doc_exec `insertHTML "<pre style='min-height: 2.4ch;'></pre><div ><br></div>" true)
                     (move_to_point point)
                     (move_point `forward `character)))
         
     }
     ;; the next two rules implement the handling of newlines in the preformatted text node
     ;; the keydown acts to cancel the default behavior of the event 
     ;; the keyup then performs the correct newline behavior for insertion of newlines
     insert_return_in_pre_down:{
         on_event: `keydown   ;; intercept the enter key in PRE tags to ignore any action on Enter
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                        (progn
                           (point_under_element_tag? "PRE" point)))
         handle_event: true
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_return_in_pre_up:{
         on_event: `keyup   ;; intercept the enter key in PRE tags to add a newline vs. a new element
         key_sequence: "Enter"
         qualifier: (fn (point ctl)   ;; we must be in a PRE tag
                       (progn
                          false))
         handle_event: true
         exec: (fn (point ctl event)
                  (progc
                     (defvar at_end ;; if we are at the end of the node, insert two newlines, otherwise just a single node
                        (cond 
                           (== point.pos_type 3)
                           (== (length point.pos_node.textContent) point.position)
                           (== point.pos_type 1)
                           false))
                     (log "at_end? " at_end)
                     (if at_end 
                        (doc_exec `insertHTML "\n\n")
                        (doc_exec `insertHTML "\n"))))
     }
     insert_header: {
         on_event: `keyup
         prior_text_sequence: "# "
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point)))
         handle_event: true
         remove_if_prior: true
         exec: (fn (point ctl event)
                  (progc
                     (let 
                        ((preceeding_text (aif (prop (get_text_around_point point) 0)
                                               (last (split_by " " it))
                                               ""))
                         (hash_details (first (scan_str (new RegExp "[#]+$") preceeding_text)))
                         (num_hashes (if hash_details
                                         (length (prop hash_details 0))
                                         0))
                         ;; add one because our rule triggered so it deleted one and the space
                         (tag_name (+ "H" (clamp (+ num_hashes 1) 1 5)))
                         (point nil))   
                        
                        ;; since we have asked the editor to remove the matching text we are going to 
                        ;; remove the remaining and use that as a way to compute the Heading element we
                        ;; will add
                        (when (> num_hashes 0)
                           (for_each (c (range num_hashes))
                              (extend_from_point `backward `character))
                           (doc_exec `delete nil))
                        (doc_exec `insertHTML (+ "<" tag_name ">Heading</" tag_name ">"))
                        (move_point `backward `character)
                        (= point (point_for (-> ctl `get_root_element)))
                        (select_node_at_point)
                        )))
     }  
      insert_section:{   
         ;; on_event specifies what events cause this rule to be checked
         on_event: `keydown
         
         ;; prior_text_sequences are the buffer contents prior to point that 
         ;; initiate the firing of the rule..
         prior_text_sequence: "%SCT"    ;; when three backticks 
         post_text_sequence: nil
         key_sequence: "Ctrl-Alt-S"     ;; or when they control-option-p or control-alt-p
         remove_if_prior: true     ;; remove sequence from buffer if prior to point if true
         handle_event: true       ;; we don't care about handling the event
         
         ;; qualifiers specify if the rule can be executed by returning true or false.  
         ;; True to execute, false to ignore in current position or context
         qualifier: (fn (point ctl)
                       (not (point_under_element_tag? "PRE" point))) ;; don't fire if we are in a pre tag
         
         ;; exec is the function that is evaluated when the rule is qualified to be fired
         exec: (fn (point ctl event) 
                  (progc
                     (defvar insert_point point)
                     (doc_exec `insertHTML "<br><details tabindex=0 open><summary>Summary Text</summary>Detail Text</details>" true)
                     (move_to_point insert_point)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (move_point `forward `character)
                     (select_node_at_point)
                     ))
     }
      insert_horizontal_rule:{
          on_event: `keyup
          handle_event: true
          remove_if_prior: true
          prior_text_sequence: "---"    ;; when three dashes 
          qualifier: (fn (point ctl)
                        (progn
                           (not (point_under_element_tag? "PRE" point))))
          exec: (fn (point ctl event)
                   (progc
                      (sleep 0.001)
                      (doc_exec `insertHTML "<hr/>")
                      ;(move_point `forward `character)
                      ;(move_point `forward `character)
                      ;(select_node_at_point)
                      ))
                        
          
      }
   })

;; placeholder
(defun wait_for_file_selection ()
   true)
   
(defcontrol DOM_editor ()
   ((starter  (div { } "Start Typing!"))
    (root_elem (div { `contenteditable: true `tabindex: 0 }
                    starter))
    (document_view (div {  `class: "juno-editable" `style: "height: calc(100% - 5px); overflow: scroll; background: var(--editor-bg-color);  line-height: 1.5em; font-size: 1.1em;  padding: 5px; margin-top: 0px;margin-bottom: 0px"} 
                        root_elem))
        
    (position_elem (div { `style: "padding: 5px;color: darkblue;" } ))
    (depth_elem (div { `style: "padding: 5px; color: green;" } ))
    (path_elem (div { `style: "padding: 5px; " } ))
    (key_history_elem (div { `style: "padding: 5px;" }))
    (text_around_elem (div { `style: "padding: 5px;" }))
    (status_elem (div { `style: "border-bottom: 1px solid var(--main-accent-line-hover); padding: 5px; display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start" }
                      position_elem
                      depth_elem
                      path_elem
                      text_around_elem
                      key_history_elem))
    (debug_offset_height "10px")
    (debug_elem (div { `style: (+ " padding: 5px; overflow:scroll; height: calc(100% - " debug_offset_height ");") } ))
    (debug_container_elem (div { `style: "height: calc(100% - 10px); overflow: hidden;" }
                               status_elem
                               debug_elem))
    (sview (if options.debug
               (split_view_horizontal document_view  debug_container_elem)
               { 
                 `view: document_view 
                 }))
    (content_view (div { `style: "background: var(--control-bg-color); overflow: hidden; width: 100%; height: 100%;" }
                       sview.view))
    (rules nil)
    (collection_timer nil)
    (key_sequence_rules { keyup: {} keydown: {} })
    (prior_text_rules { keyup: {} keydown: {} })
    (post_text_rules { keyup: {}  keydown: {} })
    (load_rule (fn (name rule)
                  (let
                     ((lookup_rule (+ { name: (or name "Unnamed Rule") `remove_if_prior: (or rule.remove_if_prior false) }
                                      (if (is_function? rule.qualifier)
                                         { `qualifier: rule.qualifier }
                                         {})
                                      { `text_sequence: rule.prior_text_sequence }
                                      (if (is_function? rule.exec)
                                          { `exec: rule.exec }
                                          { `exec: (eval `(fn ()
                                                             (notify (+ "Rule " ,#name " has no exec rule")))) })
                                      (if rule.handle_event
                                         { `handle_event: true }
                                         {}))))
                     (when rule.prior_text_sequence
                        (make_path [ rule.on_event rule.prior_text_sequence ] prior_text_rules lookup_rule))
                     ;(when rule.post_text_sequence
                      ;  (make_path [ rule.on_event rule.post_text_sequence ] post_text_rules lookup_rule))
                     (when rule.key_sequence
                        (make_path [ rule.on_event rule.key_sequence ] key_sequence_rules lookup_rule)))))
    (load_rules (fn ()
                   (progn
                      (cond 
                         (is_array? options.rules)
                         (= rules (resolve_path options.rules Environment.context.scope))
                         (is_function? options.rules)
                         (= rules (-> options `rules self)))
                      (= key_sequence_rules { keyup: {} keydown: {} })
                      (= prior_text_rules { keyup: {} keydown: {} })
                      (= post_text_rules { keyup: {} keydown: {} })
                      (for_each (pset (pairs rules))
                         (destructuring_bind (name rule)
                            pset
                            (load_rule name rule))))))
    (active_rules (fn ()
                     prior_text_rules))
    (current_point nil)
    (last_event_context nil)
    (render (fn ()
               content_view))
    (set_filename (fn (fname)
                     (if (is_string? fname)
                         (progn
                            (set_prop options
                               `filename
                               fname)
                            (set_prop options
                               `path
                               (conj [ `filesystem ] (split_by "/" fname)))
                            (set_prop title_span
                               `innerText
                               (get_editor_file_basename self)))
                         (notify "Require a string for the filename"))))
    (save_as (fn ()
                (let
                   ((fname (wait_for_file_selection true)))
                   (when (not (blank? fname))
                      (set_filename fname)
                      (request_save)))))
    (on_focus (fn (self)
                (progc
                   (focus_to root_elem)
                   (when current_point
                      (move_to_point current_point)))))
                      
               
    (process_rules_for_event (fn (event)
                                (let
                                   ((text (get_text_around_point current_point))
                                    (on_event event.type)
                                    (prior_text_sequence (or text.0 ""))
                                    (next_text_sequence text.1)
                                    (key_sequence (clone (key_history))))
                                   
                                   ;; spaces show up as character code 160, so we need to move it to space to make
                                   ;; any matches succeed that are terminated by a space
                                   ;; note that this could probably be changed in the get_text_around_point function
                                   ;; but that needs to be thought through...
                                   
                                   (when (and (is_string? text.0)
                                              (== (-> (last_n_chars 1 text.0) `charCodeAt) 160))
                                       (set_prop text 
                                          0
                                          (+ (chop text.0) " ")))
                                   
                                   ;; next find the rule to eval if any...
                                   ;; from the most specific to the least
                                   (for_each (n [ 3 2 1 ])
                                      (progn 
                                         (aif (resolve_path [ on_event (join " " (last_n n key_sequence)) ] key_sequence_rules)
                                              (when (qualify_and_run it `key_sequence event)
                                                 (break)))))
                                   (for_each (n [ 4 3 2 1 ])
                                      (progc
                                         (when (>= (length text.0) n) 
                                            (aif (resolve_path [ on_event (last_n_chars n text.0) ] prior_text_rules)
                                                (when (qualify_and_run it `prior_text event)
                                                   (break)))))))))
     ;; when a rule is identified by process_rules_for_event as matching
     ;; the qualify_and_run function will make check to see if it is qualified
     ;; to run and then run the rule 
    (qualify_and_run (fn (rule identified_by event)
                        (progc
                           (defvar qualified? 
                              (if (is_function? rule.qualifier)
                                  (-> rule `qualifier current_point self) ;; only run it if qualifier returns true
                                  true)) ;; otherwise default run it since no qualifier
                           (if qualified?
                              (progn
                                 (when rule.handle_event
                                    (handle_event event))
                                 (when (and rule.remove_if_prior
                                            (== identified_by "prior_text"))
                                    
                                    ;; remove the text that qualified it
                                    ;; however we can delete the complete element if we are at the same position (offset) 
                                    ;; in the current element being edited as the length of the text sequence to remove.
                                    (if (> current_point.position (length rule.text_sequence))
                                        (progn   ;; just extend the selection backward and remove the text..
                                           (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (= current_point (point_for root_elem)))
                                        (progn ;; in this case we will remove the whole node that contains the trigger text
                                               ;; so we need to move backward to the prior node so the rule works consistently.
                                            (for_each (`n (range (length rule.text_sequence)))
                                              (progn
                                                 (extend_from_point "backward" `character)))
                                           (doc_exec `delete nil)
                                           (move_point `backward `character)
                                           (= current_point (point_for root_elem)))))
                                 (when (== identified_by `key_sequence)
                                    (= key_history_acc []))
                                 ;; then call the rule!
                                 (-> rule `exec current_point self)
                                 true)
                              false))))
    (key_history_acc [])
    (key_history_length 4)
    (key_history (function ()
                    key_history_acc))
    (is_dirty? false)
    (add_to_key_history (function (key)
                           (progn
                              (unless (contains? key (list "Shift" "Alt" "Ctrl" "Command")) ;; don't grab just the special key downs
                                 (push key_history_acc key)
                                 (while (> key_history_acc.length key_history_length)
                                    (take key_history_acc))))))
    (key_down_event (fn (event)
                       (progc
                          (let
                             ((status (point_for root_elem))
                              (key event.key))
                             (when (or (and (== key.length 1)
                                            (not event.metaKey))
                                       (or (== key "Backspace")
                                           (== key "Enter")))
                                (when (not is_dirty?)
                                    (add_class "juno-needs-save" title_span))
                                (= is_dirty? true))
                             
                                
                             (cond
                               (== key "Escape")
                               (progn
                                  (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                               else
                               (progn
                                  (add_to_key_history (get_key_code event))
                                  (= last_event_context (process_rules_for_event event))
                                  key))))))
    
    (key_up_event (fn (event)
                      (progc
                         (let
                            ((status (point_for root_elem))
                             (key event.key)
                             (path_comps (for_each (c status.dom_path)
                                            (progn
                                               (if (== 1 c.nodeType)
                                                   c.tagName
                                                   "text")))))
                            (= current_point status)
                            (= last_event_context (process_rules_for_event event))
                            
                            
                            
                            (set_prop position_elem
                               `innerText
                               status.position)
                            (set_prop depth_elem
                               `innerText (length status.dom_path))
                            ;(-> path_elem `replaceChildren
                            ;  (div { } (join ":" (key_history))))
                            (set_prop key_history_elem
                               `innerText
                               (join ":" (key_history)))
                            (set_prop text_around_elem
                               `innerText
                               (join ":" (get_text_around_point status)))
                            (-> path_elem `replaceChildren
                               (div { } (for_each (name path_comps)
                                       (span {`style: "padding-right: 5px" } name))))
                                  
                            (when collection_timer
                               (clearTimeout collection_timer))
                            (= collection_timer
                               (setTimeout
                                  (fn ()
                                     (set_prop options
                                        `content
                                        (element_to_lisp root_elem { use_ns: `html } )))
                                  1000))
                               
                            (-> debug_elem `replaceChildren
                               (pre (JSON.stringify (element_to_lisp root_elem) "\n" 2)))
                            ))))
    
    (request_save (function ()
                        (progn
                           (save_event_handler { command: "save_request" source: options.id args: [{ path: options.path }] }))))
    
    (menu_items (fn ()
                   [(if options.filename
                        [(+ "Save " (get_editor_file_basename self)) (fn (e) (request_save))]
                        [])
                    ["Save as..." (fn (e) (save_as)) ]]))
    
    (error_state false)                   
    (on_initialize (fn ()
                      (progc
                         (let
                            ((remote_content nil)
                             (extension nil))
                            (cond
                               options.filename
                               (progn
                                  (try
                                     (progn
                                        
                                        (= remote_content (-> (fetch (+ "/files/" options.filename)) `text))
                                        ;(log "remote_content: " remote_content)
                                        (when remote_content
                                           (= remote_content (eval (JSON.parse remote_content)))
                                           (set_filename options.filename)
                                           (-> root_elem `replaceWith remote_content)
                                           (= root_elem document_view.children.0)))
                                     (catch Error (e)
                                        (progn
                                           (alert_box (+ "Unable to open: " options.filename " - " e.message))
                                           (= error_state true)))))
                               options.content
                               (progn
                                  (-> root_elem `replaceWith options.content)
                                  (= root_elem document_view.children.0)))
                                     
                            (load_rules)
                            ;(log "loaded rules: key_sequence_rules: " key_sequence_rules)
                            ;(log "loaded rules: prior_text_rules: " prior_text_rules)
                            
                            
                            (attach_event_listener content_view
                               `keyup
                               (fn (e) (key_up_event e)))
                            
                            (attach_event_listener content_view
                               `keydown
                               (fn (e)
                                  (key_down_event e)))
                            (set_attribute root_elem
                               `contenteditable "true")
                            (set_attribute root_elem
                               `tabindex 0)
                            (set_style [["height" "100%"]] root_elem)
                            (if options.hide_control_bar
                               (-> self `show_control_bar false))
                            
                            (setTimeout (fn ()
                                           (progn
                                              (cond
                                                 error_state  ;; unable to initialize - so remove ourselves
                                                 (destroy_control self)
                                                 (or options.content
                                                    options.filename)
                                                 (progn
                                                    (select_element root_elem)
                                                    (collapse_to_start (get_selection)))
                                                 else
                                                 (select_element starter))))
                                        100))))))
   {
       control_bar: true
       expose: [[`active_rules active_rules]
                [`reload_rules load_rules]
                [`save request_save]
                [`editor {} ]  ;; just to indicate we are an editor type component
                [`get (fn ()
                         (element_to_lisp root_elem)) ]
                [`needs_save? (function ()
                                 is_dirty?)]
                [`on_save_complete (function (event_obj)
                                      (progn
                                         (remove_class "juno-needs-save" title_span)
                                         (= is_dirty? false)))]
                [`get_root_element (fn () root_elem)]]
   })



(defun DOM_to_markdown (quoted_dom _acc _ctx)
   (let
      ((acc (or _acc []))
       (ctx (new_ctx _ctx))
       (process_children (fn (children)
                            (progn
                               ;(log "->" children)
                               (for_each (child (or children []))
                                  (DOM_to_markdown child acc ctx)))))
       (tag nil))
      ;(log "DOM_to_markdown: " (getf_ctx ctx `tag) (getf_ctx ctx `in_pre))
      (cond
         (is_array? quoted_dom)
         (progn
            (= tag (if (is_reference? (first quoted_dom))
                       (first quoted_dom)
                       nil))
            (if (not (eq nil ctx.parent))
                (= ctx (new_ctx ctx)))
            (setf_ctx ctx `tag tag)
            (log "quoted_dom: " (is_reference? (first quoted_dom)) (getf_ctx ctx `tag) (rest quoted_dom))
            (cond
               (and tag
                  (== tag (quote div)))
               (progn 
                  (process_children (rest quoted_dom))
                  (push acc "<br>"))
               (and tag
                  (== tag (quote pre)))
               (progn
                  (setf_ctx ctx `in_pre true)
                  (push acc "```")
                  (process_children (rest quoted_dom))
                  (push acc "```<br>"))
               (and tag
                  (== tag (quote hr))
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (push acc "---")
                  (push acc "<br>"))
               (and tag
                  (starts_with? (+ "=:" "h") tag)
                  (not (getf_ctx ctx `in_pre)))
               (progn
                  (push acc (join "" (for_each (r (range (int (-> tag `substr 3))))
                                        "#")))
                  (push acc " ")
                  (process_children (rest quoted_dom))
                  (push acc "<br>"))
                  
               
               (and tag
                  (not (getf_ctx ctx `in_pre)))
               (process_children (rest quoted_dom))))
         (is_string? quoted_dom)
         (progn
            (log "adding from " (getf_ctx ctx `tag) quoted_dom)
            (push acc quoted_dom)))
      acc))

(defcontrol meta_editor ()
   ((meta_struct (or options.content
                           {
                             description: ""
                             name: "Unnamed"
                             type: "unknown"
                             namespace: (current_namespace)
                             usage: []
                             tags: []
                             }))
    (usage (for_each (arg (or meta_struct.usage []))
              (progn
                 (defvar comps (split_by ":" arg))
                 (cond
                    (and (> comps.length 1)
                         (starts_with? "?" (second comps)))
                    [comps.0 (-> comps.1 `substr 1) true ]
                    (> comps.length 1)
                    [comps.0 comps.1 false ]
                    (== comps.length 1)
                    [comps.0 "" false ]))))
    
    (starter_span (div {  `tabindex: 0 `contenteditable: true  } (dtext "Enter text")))
    (desc (if (> meta_struct.description.length 0)
              (unpack_description meta_struct.description)
              starter_span))
    (name_editable (if options.allow_name_edits
                       true
                       true))
    (dlist_type_id (gen_id "types"))
    (dlist_types (datalist { `id: dlist_type_id }
                           (option `AsyncFunction)
                           (option `Function)
                           (option `object)
                           (option `string)
                           (option `number)
                           (option `boolean)
                           (option `array)))
    
    (symbol_type_elem (input { `class: `juno-editable `list: dlist_type_id `title: "Type" `tabindex: 0 `placeholder: "Type" `style: "font-size: 0.9em; width: 150px; padding: 5px;  font-weight: bold" `value: meta_struct.type }))
    (save_button (button (dtext "Save")))
    (monofont  "font-family: var(--main-mono-space);")
    (close_button (button (dtext "Close")))
    (new_arg_button (button { `style: "min-width: 30px; margin-left: 10px; margin-top: 10px; padding: 5px; "  `title: (dtext "Add New Argument") } "+"))
    (title_span (span { `style: "font-weight: bold; margin-right: 15px;" } options.name))
    (description_editor (DOM_editor { rules: [ `*markdown_rules* ] 
                                      hide_control_bar: true  } ))
    (description_section (details { `open: true  `style:"flex-grow: 1;" }
                                  (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Description"))
                                  (div { `style: "height: calc(100% - 30px); width: 100%;" } 
                                       description_editor.view)))
    (namespace_elem (span { `class: "juno-namespace" `style: "font-weight: bold;"} meta_struct.namespace))
    (name_edit_span (span (+ {} 
                             (if name_editable
                                { `contenteditable: true }
                                {})
                             { `class: "juno-editable" `tabindex: 0 `style: "font-weight: bold;" }) 
                          meta_struct.name))
    (tag_selection (tag_selector { `on_change: (fn (tags)
                                                  (progn
                                                     (set_prop meta_struct
                                                        `tags
                                                        tags)
                                                     (refresh_output))) }
                                 meta_struct.tags))
    (last_usage_elem nil)
    (refresh_usage (fn ()
                     (progn 
                        (= last_usage_elem nil)
                        (-> usage_elem `replaceChildren
                           (div { 
                                  `style: "line-height: 1.5em; font-size: 1.0em;  padding: 5px; max-width: 500px;" }
                                  (map (fn (arg idx total)
                                          (progn
                                             (log "idx: " idx total (as_lisp arg))
                                             (defvar pe (make_pair_editor arg idx total))
                                             (if (== idx (- total 1))
                                                 (= last_usage_elem pe.children.0))
                                             (-> pe `prepend (button { `style: "background: #FF000020; padding: 5px;"
                                                                       `remove_path: (join "~" [ `usage idx ]) } "-"))
                                             pe))
                                       usage)
                                  (if (== usage.length 0)
                                      [ 
                                       (div { } new_arg_button "Press + to add arguments") ]
                                      new_arg_button)
                                  ))
                        (when last_usage_elem 
                           (setTimeout (fn ()
                                          (focus_to last_usage_elem)
                                          20))))))
    
    (make_pair_editor (fn (arg idx total)
                         (pair_editor arg
                                      { `style: "border: 1px inset #ffffff;"
                                        `placeholder_0: "ArgName"
                                        `placeholder_1: "ArgType"
                                        `list_1: dlist_type_id
                                        `additional_elements: [ (checkbox (+ { `checkbox: { `path: (join "~" [ idx "2" ]) }}
                                                                             (if arg.2
                                                                                { `value: true }
                                                                                {}))
                                                                          "Optional")
                                                              ]
                                        `path: [ idx ]
                                        `on_change: (fn (path value)
                                                       (progn
                                                          
                                                          (make_path path usage value)
                                                          (cond
                                                              (and (== path.1 "2")
                                                                   (== value "false"))
                                                               (set_path path usage false)
                                                              (and (== path.1 "2")
                                                                   (== value "true"))
                                                              (set_path path usage true)
                                                              (== path.1 "2")
                                                              (set_path path usage false))
                                                          (log "pe: on_change: " path usage value)
                                                          (set_prop
                                                             meta_struct
                                                             `usage (map (fn (vals)
                                                                            (if (== vals.2 true)
                                                                                (+ vals.0 ":?" vals.1)
                                                                                (+ vals.0 ":" vals.1)))
                                                                            usage))
                                                          (show_updated_help)))
                                                          
                                                          
                                                         
                                        })))
    (usage_elem (div { `style: "min-height: 40px;" } ))
    (usage_section (details { `open: true  }
                            (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Usage"))
                                 usage_elem))
    (tag_section (details { `open: true }
                          (summary { `style: "font-weight: bold; padding: 5px;" } (dtext "Tags"))
                                tag_selection))
    (rendered_content_elem (div { `class: "juno-control" } "Live View"))
    
    (main_view (div { `class: "juno-control"  `style: "display: flex; flex-direction: column; align-items: stretch; padding-top: 5px; margin-left: 5px; min-height: 50%" } 
                    (h3 { `style: "display: flex; justify-content: space-between; align-items: center; " } 
                        (span (span { `style: "color: var(--namespace-color); " } meta_struct.namespace ) "/" name_edit_span)
                           symbol_type_elem)
                    (hr { `style: "light-hr" })
                    usage_section
                    description_section
                    tag_section
                    dlist_types))
    
    ;; output display: how the content is rendered in the output pane (lower)
    ;; mode 0 is the rendered display
    ;; mode 1 is a lisp view
    ;; mode 2 is a json view
    ;; mode 3 is a debug mode
    (output_display_modes [ "As Rendered" "Lisp" "JSON" "Debug" ])
    (output_display_mode 0) 
    (set_output_display_mode (fn (mode)
                                (try
                                   (progn
                                      (= output_display_mode (clamp mode
                                                                    0
                                                                    (max_index output_display_modes)))
                                      (refresh_output))
                                   (catch Error (e)
                                      (log_error e)))))
    
    (emit_as_formatted_lisp (fn ()
                               (let
                                  ((out (process_out)))
                                  (when (and (is_string? out.description)
                                             (> out.description.length 30))
                                     (set_prop out
                                        `description
                                        `(+ ,@(word_wrap out.description))))
                                  (pretty_print out))))
    (copy_as_formatted_lisp (fn ()
                               (progn
                                  (copy_text_to_clipboard (emit_as_formatted_lisp))
                                  (notify "Copied as lisp text to clipboard"))))
    (process_out (fn ()
                    (let
                       ((output (clone meta_struct)))
                       
                       (set_prop output
                          `usage (for_each (arg_desc usage)
                                    (if arg_desc.2
                                       (+ arg_desc.0 ":?" arg_desc.1)
                                       (+ arg_desc.0 ":" arg_desc.1))))
                       output)))
    (ok_grab_focus true)
    (on_blur (fn ()
                (= ok_grab_focus true)))
    (on_focus (fn (e)
                 (when ok_grab_focus
                    (= ok_grab_focus false)
                    ;(focus_to description_elem)
                    )))
    (table_regex (new RegExp "(^[a-zA-Z0-9?]+:[a-zA-Z0-9]+[ ]*-[ ]*)(.+)"))
    (show_updated_help (fn ()
                          (-> rendered_content_elem
                                    `replaceChildren 
                                    (div { `style: "background: var(--editor-bg-color); padding: 5px;" } 
                                         (format_help meta_struct)))))
    (process_current (fn (elem)
                        (let
                           ((content nil)
                            (live_content nil))
                           
                           (cond
                              true 
                              (progn
                                 (= live_content (join "" (DOM_to_markdown (-> description_editor `get))))
                                 ;; split into an array with roughly 80 column formatting for injection into source
                                 (if (> (length live_content) 60)
                                     (= live_content (flatten 
                                                        (conj [ (quote +) ]
                                                              (for_each (line (word_wrap live_content 80))
                                                                 (+ line " " ))))))
                                 (set_prop meta_struct
                                          `description live_content)
                                 ;(log "process_current: usage: " usage)
                                 (try 
                                    (progn 
                                       true) ;(log "Meta Struct: " meta_struct))
                                    (catch Error (e)
                                       (log "ERROR: " e.message)))
                                 
                                 (refresh_output))))))
    
    (sview (split_view_horizontal  main_view  rendered_content_elem  ))
    
    (content_view (div { `class: "juno-control" `style: "width: calc(100% - 2px); height: calc(100% - 2px); overflow: hidden; border-bottom: 3px solid black;" } 
                       sview.view))
    (select_name_edit_span (fn ()
                              (let
                                 ((selection (-> window `getSelection))
                                  (mrange nil))
                                 (try
                                    (progn
                                       (-> selection `removeAllRanges)
                                       (= mrange (new Range))
                                       (-> mrange `selectNodeContents name_edit_span)
                                       (-> selection `addRange mrange)
                                       true)
                                    (catch Error (e)
                                       (log "ERROR: " e.message))))))
    (control_bar_elements [(div { `style: "display:inline-block; float: right" } save_button close_button) ])
    (selection nil)
    (refresh_output (fn ()
                       (cond
                          (== output_display_mode 0)
                          (show_updated_help)
                          (== output_display_mode 1)
                          (-> rendered_content_elem
                             `replaceChildren (pre (as_lisp (process_out))))
                          (== output_display_mode 2)
                          (-> rendered_content_elem
                             `replaceChildren (pre (JSON.stringify (process_out) "\n" 2)))
                          (== output_display_mode 3)
                          (-> rendered_content_elem
                             `replaceChildren (pre "DESCRIPTION")))))
    (on_initialize (fn (intf)
                   (progn
                      (when true
                         (= initialized true)
                         (-> sview `initialize)
                         (set_prop options
                            `name
                            (+ "Meta Editor - " meta_struct.name))
                         (set_prop title_span
                            `innerText
                             (+ name_edit_span.innerText
                                  " - Meta Editor"))
                         
                         (attach_event_listener view
                            `keydown
                            (fn (e)
                               (cond
                                  (== e.key "Enter")
                                  (progn
                                     (process_current))
                                  (== e.key "Escape")
                                  (progn
                                     (if options.on_close
                                        (-> options `on_close self))
                                     (destroy_control self))
                                  
                                 
                                     )))
                         
                         
                         (-> description_editor `initialize)
                         ;; cancel or manage certain key events on the name...
                         (attach_event_listener name_edit_span
                            `keydown
                            (fn (e)
                               (cond
                                  (== e.key "Enter")
                                  (handle_event e)
                                  (== e.key "Escape")
                                  (progn
                                     (handle_event e)
                                     ;(focus_to description_elem)
                                     )
                                  (== e.key " ")
                                  (handle_event e))))
                         (attach_event_listener name_edit_span
                            `keyup
                            (fn (e)
                               (progn
                                  (cond
                                     (blank? name_edit_span.innerText)
                                     (progn
                                        (set_prop name_edit_span
                                           `innerText
                                           (dtext "Unnamed"))
                                        (select_name_edit_span))
                                     else
                                     (set_prop meta_struct
                                        `name
                                        name_edit_span.innerText))
                                  (set_prop title_span
                                     `innerText
                                     (+ name_edit_span.innerText
                                  " - Meta Editor")))))
                                  
                         (attach_event_listener name_edit_span
                            `focus
                            (fn (e)
                               (select_name_edit_span)))
                         (attach_event_listener usage_elem
                            `click
                            (fn (e)
                               (progn
                                  (aif (getAttribute e.srcElement `remove_path)
                                       (progn
                                          (log "remove: " (getAttribute e.srcElement `remove_path))
                                          (-> usage `splice (last (split_by "~" it)) 1)
                                          (refresh_usage))))))
                         (refresh_usage)
                         (attach_event_listener new_arg_button
                            `click
                            (fn ()
                               (progn
                                  (push usage
                                     ["" "" false])
                                  (refresh_usage))))
                         (attach_event_listener close_button
                            `click
                            (fn (e)
                               (progn
                                  (if options.on_close
                                     (-> options `on_close self))
                                  (destroy_control self))))
                         
                         (attach_event_listener symbol_type_elem
                            `change
                            (fn (e)
                               (set_prop meta_struct
                                  `type
                                  (if (blank? symbol_type_elem.value)
                                      (dtext "Unknown")
                                      symbol_type_elem.value))))))))
   (menu_items (fn (menu_title)
                   (progn
                      ;(log "menu_args?" menu_title)
                      [[(dtext "Copy as formatted lisp") (fn () (copy_as_formatted_lisp))]
                       ["Set Display Mode"
                        [["Rendered View" (fn () (set_output_display_mode 0))]
                         ["Lisp" (fn () (set_output_display_mode 1))]
                         ["JSON" (fn () (set_output_display_mode 2))]
                         ["Debug" (fn () (set_output_display_mode 3))]]]])))
    (render (fn ()
                content_view)))
   {
     control_bar: true
     expose: [["get" process_out]
              ["set_output_display_mode" set_output_display_mode]]
     })

(defun handle_app_click_event (e)
  (let
      ((elem e.srcElement)
       (elem_type e.srcElement.tagName)       
       (control_id (get_attribute elem "control_id"))
       (control (if control_id
                  (get_control_by_id control_id)))
       (parents (each (parents_for_control control) `name)))
    (cond
      (and (has_class? "juno-command-button" elem)
           (== elem_type "BUTTON")           
           control)
      ;; a command button was clicked show the menu for the control
      (let
          ((control_menu (conj (if (is_function? control.menu_items)
                                 (-> control `menu_items)
                                 [[]])
                               [[(dtext "Swap") (reduce (other_control (current_controls true))
                                                         (unless (or (== other_control control)
                                                                     (eq nil other_control.name)
                                                                     (contains? other_control.name parents))
                                                                 [other_control.name (fn () (swap_control control other_control)) ]))]
                                [(dtext "Hide") (fn ()
                                                  (hide_control control))]
                                ["--" nil]
                                [(dtext "Close Control")
                                 (fn ()
                                    (destroy_control control))]])))
        (make_menu elem control_menu)))))

      
                                                
(defun app_menu(global_menu_path options)
  (let
      ((view nil)
       (options (either options {}))
       (top_levels [])
       (menu_trees (resolve_path global_menu_path Environment.global_ctx.scope))
       (id (or options.id (generate_id "app_menu")))
       (intf {})
       (menu_trees (or menu_trees []))
       (compute_top_levels (fn ()
                             (progn
                                
                                (defvar headers (each menu_trees `0))
                                (if (== nil (get_control_by_name (last headers)))
                                    (pop headers))
                                
                                headers)))
                                    
       (help_idx nil)
       (add_menu (fn (menu)
                   (let
                       ((existing_idx (index_of menu.0 top_levels)))
                     (if (== existing_idx -1)
                       (push menu_trees
                             menu)
                       (-> menu_trees `splice existing_idx 1 menu))
                     (set_path global_menu_path Environment.context.scope menu_trees)
                     (build_view))))
       (remove_menu (fn (menu_text)
                      (let
                          ((existing_idx (index_of menu_text top_levels)))                           
                        (when (and (> existing_idx -1)
                                   (prop view.children existing_idx))
                          (-> (prop view.children existing_idx)
                              `remove)
                          (-> menu_trees `splice existing_idx 1))
                        (set_path global_menu_path Environment.context.scope menu_trees))))
       (show_sub_menu (fn (e)
                         (let
                            ((idx (-> e.srcElement `getAttribute `idx))
                             (menu_header (if (== e.srcElement.tagName "SPAN")
                                              e.srcElement.parentElement
                                              e.srcElement))
                             (pos (-> menu_header `getBoundingClientRect))
                             (help_menu_function nil)
                             (on_select (fn ()
                                           (when menu_header
                                              (remove_class "juno-menu-selected" menu_header))))
                             (mview nil)
                             (menu nil))
                            (aif (get_by_id "cmenu")
                                 (-> it `remove))
                            (remove_class "juno-menu-selected" menu_header)
                            (when idx
                               (add_class "juno-menu-selected" menu_header)
                               (if (== (parseInt idx) help_idx)
                                   (= help_menu_function *help_menu_function*)
                                   (= help_menu_function nil))
                               (console.log "app_menu: clicked: " idx "help_idx: " help_idx (prop menu_trees (parseInt idx)))
                               (aif (or help_menu_function
                                        (resolve_path [ (parseInt idx) 1 ] menu_trees))
                                    (progn
                                       (cond
                                          help_menu_function
                                          (= menu (menu_tree (it) { `on_select: on_select } ))
                                          (is_function? it)
                                          ;; if the underlying menu is a function, call the function to get..
                                          ;; up to the minute menu contents
                                          (= menu (menu_tree (it (first (prop menu_trees (parseInt idx)))) { `on_select: on_select } ))
                                          ;; other wise it is a standard menu, which may not rehydrate well depending
                                          ;; on how it was created..
                                          else
                                          (= menu (menu_tree it { `on_select: on_select } )))
                                       (= mview (div { `id: `cmenu `class: "juno-menu" `style: " z-index: 30" }
                                                     menu.view))
                                       (set_style [["position" "absolute"]
                                                   ["left" (+ "" (Math.max 0 pos.left 0) "px")]
                                                   ["top" (+ "" (Math.max 0 pos.bottom ) "px") ]]
                                                  mview)
                                       (-> (get_by_id "body") `appendChild
                                           mview))
                                    (progn
                                       (remove_class "juno-menu-selected" menu_header)
                                       (notify "Unable to find menu resource")))))))
       (build_view (fn ()
                       (let
                           ((new_view nil)
                            (header_elem nil))
                         (= top_levels (compute_top_levels))
                         (unless options.disable_help
                                 (push top_levels
                                       "Help")
                                 (= help_idx (- (length top_levels) 1)))
                         
                         (= new_view
                            (ul { `id: id `class: "pure-menu-list" `style: "margin-left: 10px" }
                                (if (> top_levels.length 0)
                                  (map (fn (top_level idx)
                                         (li { `idx: idx  `class: "juno-menu-header juno-main-menu-header" }
                                             (span { `idx: idx `class: "juno-menu-item" } (dtext top_level))))
                                       top_levels)
                                  [])))
                         (map (fn (child)
                                 (progn
                                    (attach_event_listener child
                                       `mouseenter
                                       (fn (e)
                                          (progn
                                             (when (get_by_id "cmenu") ;; if the menu is already showing show the new menu, otherwise don't do anything
                                                (remove_class "juno-menu-selected" new_view.children)
                                                (show_sub_menu e)))))
                                    (attach_event_listener child
                                       `mouseleave
                                       (fn (e)
                                          true))))
                              new_view.children)
                         (attach_event_listener new_view
                                                `click
                                                show_sub_menu)
                                                                        
                         
                         (if view.parentElement
                           (-> view `replaceWith new_view))
                         (= view new_view)
                         view))))
    
    
    (build_view)
    (set_prop options
              `id
              id)
    (set_prop intf
              `view view
              `add_menu add_menu
              `remove_menu remove_menu
              `type "app_menu"
              `toJSON (function ()
                                `(app_menu ,#global_menu_path ,#options)))
    (setq *app_menu_control* intf)
    intf))

(defun app_header (controls options)
  (let
      ((existing_header (-> document `querySelector "header"))
       (intf nil))
    (when (eq existing_header nil)
      (-> (first (get_by_tag "body"))
          `prepend
          (= existing_header (header { `id: "page-header" class: "juno-page-header" }))))
    (when options.app_title
      (-> existing_header `appendChild (span { `class: "juno-header" } options.app_title)))
    (for_each (`elem controls)
              (progn
               (cond
                 elem.view
                 (-> existing_header `appendChild elem.view)
                 (is_element? elem)
                 (-> existing_header `appendChild elem)
                 else
                 (create_dom_element "span" elem))))
    (set_prop options
              `id
              (or options.id "app-header"))
   
    (= intf
       {     
        `options: options
        `controls: controls
        `type: "app_header"
        `toJSON: (function ()
                           `(app_header ,#controls ,#options))
        })
    
    intf))


(defun build_starter_environment ()
  (if is_served?
    (progn
     (log "building starter environment")
     (floating_div (iframe { width: 500 height: 300
                   `style: "width: 90%; min-width: 500px; overflow: scroll; border: 0px solid transparent;"
                   src: (+ "/env/starter.html?theme=" (resolve_path [ `application `global_theme ] *env_config*))} )))))


(defun controls_by_parent ()
    (let
        ((acc [])
         (current { `root: [] })
         (found_control {})
         (control_identity (fn (control)
                                 (and control
                                      (or control.name
                                          control.options.id
                                          "Untitled"))))
         (collect_control (fn (control parent)
                              (when (and control.options.id 
                                         (not (prop found_control control.options.id)))
                                 (when (and parent
                                            (not control.name))
                                     (cond
                                         parent.name
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.name "-" control.type))
                                         parent.type
                                         (set_prop control
                                                   `name
                                                   (+ "" parent.type "-" control.type))))
                                 (cond
                                     (and parent
                                          (not (prop current (control_identity parent))))
                                     (set_prop current 
                                               (control_identity parent)
                                               [ control ])
                                     (and parent
                                          (prop current (control_identity parent)))
                                     (push (prop current (control_identity parent))
                                               control)
                                     (eq nil parent)
                                     (push (prop current `root)
                                               control))
                                 (set_prop found_control
                                           control.options.id
                                           control)))))
        (for_each (controls (or $root_controls []))
           (control_tree controls collect_control))
        current))

(defun all_global_controls (namespace)
   (let
      ((env_handle (if namespace 
                       (-> Environment `get_namespace_handle namespace)
                       nil)))
      (if namespace
          (reduce (pset (pairs env_handle.context.scope))
             (destructuring_bind (symbol_name symbol_value)
                pset
                (if (is_control? symbol_value)
                    symbol_name)))
          (flatten (for_each (namespace (namespaces))
                      (for_each (ctl (all_global_controls namespace))
                         (+ namespace "/" ctl))))))
   {
     `description: (+ "Returns all controls in the global context.  If provided " 
                      "with a namespace, it will return only the controls for "
                      "that namespace, otherwise it will return all controls "
                      "in every namespace in a fully qualified form.")
     `usage: ["namespace:?string"]
     `tags: [`controls `ui `global]
     })

;; old
;(defun serialize_controls (controls)
;  [(quote quote) [(quote quote) (JSON.parse (JSON.stringify controls))]])


;; new
(defun serialize_controls (controls)
  [(quote quote) (JSON.parse (JSON.stringify controls))])



(defun save_control_image ()
  (progn

   (log (dtext "Saving Application State.."))
   (set_focus_to nil)
   (defvar system_repl *system_repl*)
   (defvar results nil)
   (= *system_repl* nil)
   
   (= *serialized_controls* (serialize_controls $root_controls))
      ;[(quote quote) [(quote quote) (JSON.parse (JSON.stringify $root_controls))]])
   (console.log "*serialized_controls*: " *serialized_controls*)
   (= results (save_image))
   (= *system_repl* system_repl)
   (log (dtext "Save Application State Results: ") results)
   (log (dtext "Complete"))))

(defun rehydrate_controls (container serialized_controls)
  (let
      ((control nil))
    (for_each (`serialized_control serialized_controls)
      (progn
       (= control (eval serialized_control))
       (when (and control.view
                  (not control.view.parentElement))
         (-> container
             `append control.view))
       (push $root_controls
             control)
       (when control.initialize
         (-> control `initialize))))))



(defun_sync to_indent (str)
    (join "" (for_each (c (range str.length))
                       " ")))

           
(defun_sync juno_format_handler (line tab base_indent)
   "")  ;; we let the control take care of this since it has better visibility to prior lines




(defun new_buffer (options)
  (let
      ((options (cond
                   (is_array? options)
                   { `path: options `mode: "juno"}
                   (is_object? options)
                   (+ (if options.filename
                          {}
                          { `mode: `juno })
                      options)  ;; if options has mode specified and we don't have a filename, it will override the default juno mode
                   (is_string? options)
                   { `path: [ options ] `mode: "juno" }
                   else
                   { `mode: "juno" }))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (symbol_data (if options.path
                        { `path: options.path `namespace: (or options.namespace (current_namespace)) }
                        (symbol_chooser "Select a symbol to edit" options.mode)))
       (target_ns symbol_data.namespace)
       (target_env nil))
      (console.log "new_buffer: for: " options target_ns symbol_data)
      
    (when target_ns
      (= target_env (-> Environment `get_namespace_handle symbol_data.namespace)))
    (when (and target_env (not (resolve_path symbol_data.path target_env.global_ctx.scope)))
       (console.log "new_buffer: target symbol doesn't exist: creating it")
       (set_path symbol_data.path target_env.global_ctx.scope ""))
    (when symbol_data.path
      (cond
         (is_top_control? target_container)
         (container_view_operation "split_right" (first (-> target_container `controls))
                                   (text_editor (+ { name: (last symbol_data.path) namespace: target_ns path: symbol_data.path mode: options.mode } options) ))
         else
         (swap_control target_container (text_editor (+ { name: (last symbol_data.path) namespace: target_ns path: symbol_data.path mode: options.mode } options ))))))
  {
      `description: (+ "Opens a new editor, if possible, in the currently focused control.  If necessary, it may "
                       "split the view to the right for the new editor.  If no options are provided, the user "
                       "will be prompted for a symbol to edit.  Options can be: <br>"
                       "string: is considered a symbol name and the function will open or create the " 
                       "specified symbol in the current namespace global context.<br>"
                       "array: is considered a path to access, and if the path is present will open the path.  If not, "
                       "will attempt to create the final value in the path as a string for editing.<br>"
                       "object: if an object, the object can contain:<br>"
                       "  path: array: the path to the symbol to be edited.  If the final path segment doesn't exist "
                       "it will create it.<br>"
                       "  namespace: string: the namespace to use for accessing the provided path.<br>"
                       "  mode: the mode to open the editor in. The default mode is Juno.<br>")
      `tags: ["editor" "edit" "buffer" "control"]
      `usage: ["options:object?"]
  })

(defun new_top_level_frame ()
   (let
      ((ctl (empty_selection_control))
       (new_frame (control_container ctl { `root_frame: true } )))
      (push $root_controls
         new_frame)
      (if (> (length (-> (control_holding_tank) `controls)) 0)
          (swap_control ctl (last (-> (control_holding_tank) `controls))))))

(defun new_juno_repl (options)
   (let
      ((name (compute_name_for_control "Juno REPL"))
       (target_container (or options.control_to_replace *last_focus*  (default_focus)))
       (remote_repl (if (is_string? options.remote_repl)
                        options.remote_repl)))
      (alert_on_error "REPL Error"
                      (cond
                         (is_top_control? target_container)
                         (container_view_operation "split_right" (first (-> target_container `controls)) (visual_repl { `name: name `remote_repl: remote_repl }))
                         else
                         (swap_control target_container (visual_repl { `name: name `remote_repl: remote_repl })))))
   {
       usage: ["options:?object"]
       description: (+ "Creates a new REPL in the current frame.  If provided with a `control_to_replace "
                       "in options, it will replace that control with the new REPL, with the replaced control "
                       "being put in the holding tank if the replaced control is allowed."
                       "If no target is provided, the function will split the top frame, replacing the " 
                       "currently focused control.")
       tags: [ "REPL" "create" "new" "control"]
   })
   

(defun wait_for_file_selection (create_mode) 
   (new Promise (fn (resolve reject)
                   (let
                       ((selection nil)
                        (target_control (or *last_focus* (default_focus)))
                        (control (file_tree_browser { 
                                                      create_mode: create_mode                          
                                                      on_select: (fn (stack)
                                                                    (progn
                                                                     (= selection (join "/" stack))
                                                                     (if (> stack.length 0)
                                                                       (progn
                                                                        (destroy_control control)))))
                                                                        
                                                     on_destroy: (fn (self)
                                                                    (progn
                                                                     (setTimeout (fn ()
                                                                                    (progn
                                                                                       (set_focus_to target_control)
                                                                                       (resolve selection))
                                                                                    20))
                                                                     true)) })))

                     (place_control `below control)
                     (set_focus_to control))))
   {
       `description: (+ "Opens a file tree browser for selection of a file.  Once the a " 
                        "file is chosen, or the selection is cancelled via escape, then either "
                        "the selected path is returned, or nil if cancelled or closed.<br>If "
                        "the create_mode flag is true, the behavior is modified in the "
                        "selection control where path completions aren't automatically "
                        "used, instead the user must press tab to complete the selection. "
                        "This allows for the user to select a file that may not be "
                        "present on the filesystem for purposes of creation.  By default the "
                        "create_mode flag is set to false.")
       `usage:["create_mode:?boolean"]
       `tags: ["UI" "DOM" "file" "editor" "select" "open"]
   })



(defun edit_file (options)
   (let
      ((options (cond 
                   (and (is_object? options)
                        options.filename)
                   options
                   (and (is_object? options)
                        options.create_mode)
                   (+ {} 
                      options
                      { filename: (wait_for_file_selection true) })
                   else
                    (progn
                       {
                           filename: (wait_for_file_selection)
                       })))
       (symbol_path (cond
                       (is_array? options.path)
                       options.path
                       (is_string? options.filename)
                       (conj ["filesystem"] (split_by "/" options.filename))))
       (rval nil)
       (data_to_save (or options.initial_data ""))
       (acc []))
      (if (eq options.filename nil)
          (return nil))
      (assert (and symbol_path options.filename) "Invalid options to edit_file")
      
      ;; if we are given a create mode, make the shell of a file
      (if (and options.create_mode
               (> (length data_to_save) 0) )
         (try
            (progn
               (= rval (http/send_files "/save_file" (http/data_to_file options.filename data_to_save "text/plain")))
               (if (and rval
                        (== rval.rval "OK"))
                   (log "Created empty file: " options.filename)
                   (throw Error rval.message)))
            (catch Error (e)
               (progn
                  (alert_box (dtext "Unable to Create File")
                             (+ "" options.filename ": "
                                e.message))
                  (set_prop options
                             `filename
                             nil)))))
            
      (if (eq options.filename nil)
          (return nil))
      
      (if (and (starts_with? "filesystem" symbol_path)
               (eq nil (resolve_path symbol_path Environment.global_ctx.scope)))
          (progn
             (for_each (comp (chop symbol_path))
                (progn
                   (push acc comp)
                   (set_path acc Environment.global_ctx.scope {})))
             (push acc (last symbol_path))
             (set_path acc Environment.global_ctx.scope "")))
      (set_prop options
         `path
         symbol_path)
      (alert_on_error "File Open Error"
         (new_buffer options)))
   {
       `description: (+ "If provided an options object with a filename key and file path value, "
                        "the function will attempt to fetch and present that file for editing. "
                        "If an error is encountered, the error will be presented to the user "
                        "in a popup window and nil returned.  If called with no options, the "
                        "function will prompt the user to select a file via a file_tree_browser "
                        "control.  If create_mode is true in the options, then a new file "
                        "creation will be attempted and an editor returned for that.  If a "
                        "new file cannot be created, the user will be warned and nil will "
                        "be returned.")
       `usage: ["options:object"]
       `tags: ["DOM" "ui" "file" "edit" "open"]
   })
       


  
;; control behavior for unsaved controls in remote mode
;; if a control that is a buffer is to be saved to a file:
;;  1.  select a file to create
;;  2.  make a new editor with the contents of the old control as a proper file
;;  3.  swap with old control. 
;; if we do not have a host and are running locally, 
;;  1.  Establish an export_as name and save the file to that, but retain the existing editor

(defun handle_save_file (control options)
  (let
      ((fname (when control
                (or (and options.no_prompt
                         (is_string? control.options.filename)
                         control.options.filename)
                    (and options.remote
                       (wait_for_file_selection true))
                    (and (not options.remote)
                         (request_user_input (dtext "Download Buffer To Local File") 
                                             `text
                                             { `placeholder: (dtext "Name Of File")
                                                            `value: (aif (resolve_path [ `options `export_as ] control)
                                                                         it
                                                                         nil) })))))
       (rval nil))
      (declare (function wait_for_file_selection)
               (global wait_for_file_selection))
    
    (when (and (not (blank? fname))
               control
               control.get)
       (cond
          (and options.remote
               fname)
          (progn
             (alert_on_error "Cannot Create File"
                (progn
                   (= rval (http/send_files "/save_file" (http/data_to_file fname (or (-> control `get) ""))))
                   (if (and rval
                            (== rval.rval "OK"))
                       (progn
                          (= rval rval.results)
                          (notify "File saved")
                          (when (== rval.length 1)
                             ;; we made the file, now open a new buffer to it and swap with the old control
                             (edit_file { `filename: fname `control_to_replace: control })))
                       (progn
                          (log "ERROR on file creation: " rval)
                          (throw rval.message))))))
          fname
          (alert_on_error "Cannot Save Locally"
             (= rval (save_locally fname (-> control `get)
                                   "application/text"))
             (when rval
                (set_path_value control [ `options `export_as ] fname)
                (if control.display_context_message
                   (-> control `display_context_message (+ (dtext "Exported as: ") fname))))
             (log "Local save returned: " rval)))))
  {
   `usage: ["control:object" "options:?object"]
   `description: (+ "Given a control and an optional options object, will call the control's "
                    "`get method for the data value, and saves the value returned by the get "
                    "operation.  If the remote option is true and there is no options.filename "
                    "set, the user will be prompted with a chooser.  If the file is to be saved "
                    "locally, the user will be asked for a name to export it as, and the file "
                    "will be downloaded from the browser to the local environment and placed "
                    "in the default download folder of the browser.<br>"
                    "When a file is saved remotely, a new editor is established that is now "
                    "linked to the remote file and further saves for that buffer will be "
                    "defaulted to that filename.  If local, on subsequent saves the user will "
                    "be prompted to confirm the filename, or choose another."
                    "<br>Options are: <br>"
                    "remote:boolean - Attempt to save the file to the hosting server.<br>"
                    "no_prompt:boolean - If a filename is already established via options.filename "
                    "do not prompt for a new filename.")
   `tags: ["save" "file" "control"]
   })    

(defun set_key_binding (scope name desc)
  (let
      ((target (resolve_path [ scope ] *key_bindings*))
       (key_mode (get_operating_platform)))
    (progn
     (set_prop target
               name
               desc)
     (set_prop *key_bindings*.active
               (prop desc key_mode) 
               (prop desc `exec))))
  {
      `description: (+ "Given a scope for the keybinding, a command name key, and a description object, "
                       "establishes the binding in the *key_bindings* and in the environment as active. "
                       "<br>The description object should contain the following keys:<br>"
                       "description:text - A human readable description of what the key binding does.<br>"
                       "exec:fn - The function to execute when the key binding occurs. Some exec entries " 
                       "can be nil if the control has an internal function for the command name.<br>"
                       "mac:text - The key sequence to use on environments running on MacOS<br>"
                       "win:text - The key sequence to use when running on Windows or Linux (or non Mac environments)<br>")
      `usage: ["scope:string" "name:string" "desc:object"]
      `tags: ["keys" "bindings" "settings" "configuration" "config" ]
                       
  })
  
;; build a more sophisticated keyword_mapper
(defun_sync keyword_mapper (token)
   (progn
      (defvar details nil)
      (defvar rval
         (cond
            (contains? token *formatting_rules*.keywords)
            "keyword"
            (progn
               (setq details
                     (first (meta_for_symbol token true)))
               details.type)
            (lowercase details.type)
            else
            "identifier"))      
      rval))

;; and redirect the core/keyword_mapper


(use_quoted_initializer
 (defun_sync core/keyword_mapper (token)
   (user/keyword_mapper token)))

(defun gen_file_menu ()
   [["New..." [(if is_served?
                   ["File" (fn (e) (edit_file { `create_mode: true }))]
                   [])
               ["Juno REPL" (fn (e) (new_juno_repl))]
               (if is_served? 
                  ["Juno Remote REPL" (fn (e) (new_juno_repl { `remote_repl: (+ "ws://" window.location.host "/connect_repl") }))]
                  [])
               ["--" nil]
               ["Juno Lisp Editor" (fn (e) (new_buffer { `type: "juno" }))]
               ["Javascript Editor" (fn (e) (new_buffer { `type: "javascript" })) ]
               ["CSS Editor" (fn (e) (new_buffer { `type: "css" })) ]
               ["Text Editor" (fn (e) (new_buffer { `type: "text" })) ]
               ["JSON Editor" (fn (e) (new_buffer { `type: "json" }))]]]
    (if is_served?
       ["Open File" edit_file ]
       [])
    (if (resolve_path [ `get ] *last_focus*) 
        ["--" nil]
        [])
    (if (and is_served?
             *last_focus*
             (resolve_path [ `options `filename ] *last_focus*))
        [(+ (dtext "Close ") (get_editor_file_basename *last_focus*))
         (fn () (close_file *last_focus*)) ]
        [])
    (if (and *last_focus*
             is_served?
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [(+ (dtext "Save") " "
            (or (aif (resolve_path [ `options `filename ] *last_focus*)
                     (last (split_by "/" it)))
                (resolve_path [ `options `name ] *last_focus*)
                ""))
         (fn (e) (save_active_buffer))]
        [])
    (if (and *last_focus*
             (is_function? (prop *last_focus* `get)) ;; does it have a get method for the text
             (prop *last_focus* `name))  ;; and a name to identify it
        [(+ (dtext "Save As")
            "...")
         [(if is_served?
              [(dtext "New Server File") (fn (e) (handle_save_file *last_focus* { `remote: true }))]
              [])
          [(dtext "Local File") (fn (e) (handle_save_file *last_focus*))]]]
        [])
    ["--" nil]
    ["Save Environment" (fn (e) (save_control_image)) ]
    (if is_served?
       ["Generate Starter Environment" build_starter_environment]
       [])
    ["Load File Into Environment" (fn (e) (-> resource_loader_button `click)) ]
    (if *global_themes*
       ["--" nil]
       [])
    (if *global_themes*
       ["Set Global Theme" (for_each (theme_name (keys *global_themes*))
                              [theme_name (fn ()
                                             (set_global_theme theme_name))])]
       [])])

(defun gen_layout_menu ()
   (let
      ((menu_acc [])
       (idx 0)
       (holding_tank (get_control_by_name "Holding Tank"))
       (control_to_place (fn ()
                            (if (and (prop *last_focus* `editor) ;; if we are in an editor, (but not repl) split it
                                     (not (== (prop *last_focus* `type) "visual_repl")))
                                (clone_text_editor_control *last_focus*) 
                                (empty_selection_control)))) ;; otherwise pull the last control out of storage
                             
       (root_ctls (new Set)))
      (conj
         ;[["New Frame" (fn ()
                          ;(new_top_level_frame))]]
         (reduce (pset (pairs (controls_by_parent)))
            (destructuring_bind (key controls)
               pset
               (console.log "key: " key "is the holding tank?" (== (get_control_by_name key) holding_tank) controls  )
               (cond
                  (== key "root")
                  (progn
                     (for_each (control controls)
                        (-> root_ctls `add control.name))
                     nil)
                  
                  (and (-> root_ctls `has key)
                       (not (== key "Holding Tank")))
                  [key (for_each (operation ["Split Right" "Split Bottom" "Show" "Hide"])
                          (progn
                             (defvar control (get_control_by_name key))
                             [(dtext operation)
                              (cond
                                 (and (> idx 1)
                                      (== operation "--"))
                                 nil
                                 (== operation "Split Right")
                                 (fn ()
                                    (place_control "right" (control_to_place)))
                                 (== operation "Split Bottom")
                                 (fn ()
                                    (place_control "below" (control_to_place)))
                                 (or (and (== operation "Show")
                                          (-> holding_tank `has_control? control))
                                     (and (== operation "Hide")
                                          (not (-> holding_tank `has_control? control)))
                                     (and (== operation "Close Control")
                                          (-> holding_tank `has_control? control)))
                                 (progn
                                    (when (-> holding_tank `has_control? control)
                                       (inc idx))
                                    (fn ()
                                       (container_view_operation (to_key operation)
                                                                 (get_control_by_name key)
                                                                 nil))))]))]
                  
                  (not (== key "Holding Tank"))
                  [key (for_each (operation ["Split Above" "Split Below" "Split Left" "Split Right"])
                          [(dtext operation) (fn ()
                                  (progn
                                     (console.log key "operation: " operation controls)
                                     (container_view_operation (to_key operation)
                                                               (get_control_by_name key)
                                                               (control_to_place))))])]))))))

(defun gen_controls_menu ()
  (progn
   (defvar holding_tank (get_control_by_name "Holding Tank"))                
   (defvar holding_tank_visible? (if (prop (control_position holding_tank) `parent)
                                     true
                                     false))
   (conj 
        (reduce (control (current_controls))
            (when (and control.on_focus
                       control.options.id)
              (defvar is_displayed? (and (not (== holding_tank control))
                                         (not (-> holding_tank `has_control? control))))
              [(or control.name "Untitled") 
               (reduce (operation ["Show" "Focus" "Hide" "--" "Close Control"])
                       (cond
                         (== control.name "Holding Tank")                              
                         (cond
                           (== operation "Focus")
                           [(dtext "Show")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `show))]
                           (and holding_tank_visible?
                                (== operation "Hide"))
                           [(dtext "Hide")
                            (fn (e)
                              (-> (get_control_by_name "Holding Tank")
                                  `hide))]
                           else
                           nil)
                         else
                         [(dtext operation)
                          (cond
                            (and (not is_displayed?)
                                 (== operation "Show"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (show_control it)))
                            (and is_displayed? (== operation "Focus"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (set_focus_to it)))
                            (and is_displayed? (== operation "--"))
                            nil
                            (and is_displayed? (== operation "Hide"))
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "hide" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id)))))
                            (== operation "Close Control")
                            (fn (e)
                              (aif (get_control_by_id control.options.id)
                                   (container_view_operation "destroy" it)
                                   (notify (+ "Unable to find control " (or control.name control.options.id))))))]))]))
        [[(dtext "Monitor Control Tree") 
          (fn ()
            (progn
             (monitor_control_tree)))  ]])))



(defun user/*initializer* ()
  (let
      ((header nil)       
       (scripts (-> (page_header) `querySelectorAll "script[id]"))                     
       (scratch_editor nil)
       (page_frame nil)
       (control nil)
       (key_mode (get_operating_platform))
       (repl_split nil))
                                                               
    (console.log "user/*initializer is running." )
    
    ;(defglobal main_menu_button (li  { `class: "juno-menu-header" }
     ;                                        (span { `class: "juno-menu-item" `style: "" } "File")))

    (defglobal resource_loader_button (file_picker_button "" load_files))    
    (set_style [["position" "absolute"]
                ["top" "-100px"]
                ["left" "-100px"]
                ["width" "1px"]
                ["height" "1px"]] resource_loader_button)
    
    (-> (get_by_id "body") `appendChild resource_loader_button)
       
    (defvalue $root_controls [])
    
    
    
    ;; the root container which controls are added to..
    (defglobal juno_container
      (div { `style: "height: inherit; width: inherit; position: relative; overflow:hidden;" }))

    
    (set_prop *env_config*.editor
       `extensions_to_mode
       {
         `js: `javascript
         `lisp: `juno
         })
    
    (attach_event_listener juno_container `click
                           (fn (e)
                             (progn
                              (defvar menu (get_by_id `cmenu))
                              (when menu (-> menu `remove)))))
    
    (set_prop *env_config*.export
	      `save_path
	      nil)
            
    (attach_event_listener juno_container
                           `focusin
                           (fn (e)
                             (process_focus_chain e)))

    (-> (get_by_id "body") `appendChild juno_container)

    
    (set_prop *formatting_rules*
       `allocating_forms {
                           `let: (fn (tree)
                                    (progn
                                       (flatten (list (resolve_multi_path [ 1 `* 0 ] tree)))))
                           `defun: (fn (tree)
                                      (progn
                                         (conj (list (resolve_path [ 1 ] tree))
                                               (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defun_sync: (fn (tree)
                                           (progn
                                              (conj (list (resolve_path [ 1 ] tree))
                                                    (flatten (list (resolve_path [ 2 ] tree) ) ))))
                           `defmacro: (fn (tree)
                                         (progn
                                            (conj (list (resolve_path [ 1 ] tree))
                                                  (flatten (list (resolve_path [ 2 ] tree))))))
                           `function: (fn (tree)
                                         (flatten (list (resolve_path [ 1 ] tree) )))
                           `fn: (fn (tree)
                                   (flatten (list (resolve_path [ 1 ] tree) )))
                           `lambda: (fn (tree)
                                       (flatten (list (resolve_path [ 1 ] tree) )))
                           `destructuring_bind: (fn (tree)
                                                   (progn
                                                      (flatten (list (resolve_path [ 1 ] tree)))))
                           `defvar: (fn (tree)
                                        (flatten (list (prop tree 1))))
                           `for_each: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `for_with: (fn (tree)
                                         (list (resolve_path [ 1 0 ] tree)))
                           `reduce: (fn (tree)
                                       (list (resolve_path [ 1 0 ] tree)))
                           `reduce_sync: (fn (tree)
                                            (list (resolve_path [ 1 0 ] tree)))
                           `defglobal: (fn (tree)
                                          (list (prop tree 1)))
                           `defparameter: (fn (tree)
                                             (list (prop tree 1)))
                           
                           })
    
    
    ;; initialize or rehydrate the controls
    (if (== (length *serialized_controls*) 0)
      (progn       
       (console.log "initializing control surface")
       ;; take in the global default theme, but don't impact the setting for the sub themes
       (set_global_theme *env_config*.application.global_theme { `suppress_set_sub_theme: true `suppress_cascade: true })
       (defglobal $repl (visual_repl { `name: "Juno REPL"  `display_options: { `show_timestamps: true }}))
       (try
         (= scratch_editor
            (text_editor { name: "*scratch*" 
                          namespace: "user" 
                          path: [ `*scratch* ] 
                          mode: `juno }))
         (catch Error (e)
           (console.error "error on constructing scratch editor: " e)))

       (push *main_menu*   ;; using a wrapper function allows us to change the menu more dynamically
             [ "File" (fn ()
                         (gen_file_menu))])
                         
       
       (push *main_menu*            
             ["Controls" (fn ()
                        (gen_controls_menu))])
       (push *main_menu*
             ["Layout"
               (fn ()
                  (gen_layout_menu))])
       
       (push $root_controls
             (app_header [(app_menu [ `*main_menu* ])]
                         { `app_title: "Seedling" }))
       (setq page_frame ;; or surface which can be named in the upper right or middle
             (control_container nil {                                     
                                     `root_frame: true
                                     }))

       
       (set_prop *key_bindings*.global
                 "open_new_buffer" { win: "Command-Enter"
                                     mac: "Command-Enter"
                                     description: "New Juno Buffer"
                                     exec: (fn () (new_buffer { type: "juno" }))
                                    }
                 "save_file" { win: "Ctrl-S"
                               mac: "Command-S"
                               description: "Save File"
                               exec: (fn () (save_active_buffer))                              
                              }
                 "open_file" { win: "Ctrl-O"
                               mac: "Command-O"
                               description: "Open File"
                               exec: (fn () (edit_file))
                              }
                 "toggle_documentation" { win: "Shift-Escape"
                                        mac: "Shift-Escape"
                                        description: "Show Help Panel"
                                        exec: (fn () 
                                                 (toggle_help_panel)) }
                 "search_documentation" { win: "Alt-H"
                                          mac: "Alt-H"
                                          description: "Search Documentation"
                                          exec: (fn () 
                                                  (show_help_panel true)) }
                 "open_meta_editor" {
                                      `win: "Alt-M"
                                      `mac: "Alt-M"
                                      `exec: (fn () (place_control `right (meta_editor)))
                                      `description: "Opens the meta editor"
                                      }
                 
                 "save_environment" { win: "Ctrl-Shift-S"
                                      mac: "Command-Shift-S"
                                      description: "Saves the current state of the application"
                                      exec: (fn () (save_control_image))
                                     } 
                 "next_hidden_control" { win: "Alt-Shift-Period"
                                         mac: "Command-Shift-Period"
                                         description: "Next Hidden Control"
                                         exec: (fn () (next_hidden_control))
                                         }
                 "prior_hidden_control" { win: "Alt-Shift-Comma"
                                          mac: "Command-Shift-Comma"
                                          description: "Prior Hidden Control"
                                          exec: (fn () (next_hidden_control true))
                                          }
                 "next_displayed_control" { win: "Alt-Period"
                                            mac: "Command-Period"
                                            description: "Next Displayed Control"
                                            exec: (fn () (next_displayed_control))
                                            }
                 "split_vertically" {
                                       win: "Ctrl-Backslash|Alt-3"
                                       mac: "Ctrl-Backslash|Alt-3"
                                       description: "Split the current control to the right"
                                       exec: (fn () (split_control `vertical))
                                      }
                 "split_horizontally" {
                                       win: "Alt-Backslash|Alt-2"
                                       mac: "Alt-Backslash|Alt-2"
                                       description: "Split the current control downward"
                                       exec: (fn () (split_control `horizontal))
                                      }
                  "close_panel" {
                                       win: "Alt-0"
                                       mac: "Alt-0"
                                       description: "Close the currently focused panel and put the control into the holding tank."
                                       exec: (fn () (hide_control *last_focus*))
                                      }
                  "close_control" {
                                       win: "Alt-D"
                                       mac: "Alt-D"
                                       description: "Close (Destroy) the control in the currently focused panel."
                                       exec: (fn () (hide_control *last_focus* true true))
                                      }
                  "clear_repl_output" {
                                        win: "Alt-Shift-K"
                                        mac: "Command-Shift-K"
                                        description: "Clears the system repl output pane."
                                        exec: (fn () (-> *system_repl* `clear_output))
                                        })
       ;; the execs are nil because the editor will use the key of the object to assign the correct
       ;; internal function
       
       (set_prop *key_bindings*.editor
                 "evaluate_selection" { win: "Shift-Enter"
                                        mac: "Shift-Enter"
                                        description: "Evaluate the current selected text"
                                        exec: nil
                                       }
                 "on_save" {  description: "Invokes save for the currently focused control"
                              win: "Ctrl-s"
                              mac: "Command-s"
                              exec: nil
                            }
                 "increase_font_size" {
                                       description: "Increase the font size of the current editor"
                                       win: "Ctrl-Shift-="
                                       mac: "Ctrl-Shift-="
                                       exec: nil
                                       }
                 "decrease_font_size" {
                                       description: "Decrease the font size of the current editor"
                                       win: "Ctrl-Shift--"
                                       mac: "Ctrl-Shift--"
                                       exec: nil
                                       }
                 "select_form_root" {
                                     description: "select_form_root"
                                     win: "Ctrl-Shift-Enter"
                                     mac: "Ctrl-Shift-Enter" 
                                     exec: nil }
                 "select_current_form" {
                                        description: "select_current_form"
                                        win: "Ctrl-Enter"
                                        mac: "Ctrl-Enter" 
                                        }
                 "evaluate_root_form" {
                                        description: "Evaluates the current form at the cursor position."
                                        win: "Alt-C"
                                        mac: "Alt-C"
                                        exec: nil
                                        }
                 "indent_current_row" {
                                       description: "Indent the row at the cursor position"
                                       win: "tab"
                                       mac: "tab"
                                       exec: nil
                                       }
                 "evaluate_selected_in_place" {
                                                description: "Evaluates and then replaces the selected text with the results of the evaluation."
                                                win: "Alt-R"
                                                mac: "Alt-R"
                                                exec: nil
                                                })
                 
       
       
                 
       (-> juno_container
           `append page_frame.view)

       (-> page_frame `initialize)
       
       (-> page_frame `set_content 0
           (split_view_vertical scratch_editor
                                $repl))
       
       (console.log "initializer: *last_top_frame*: " *last_top_frame*)
       
       (push $root_controls page_frame)
       ;; the holding tank contains the controls  that are still needed but not
       ;; presently displayed 
       (push $root_controls (control_holding_tank [] {}))
       
       (-> scratch_editor
           `set_evaluator_control $repl)
       
       (when (blank? (prop *env_config*.export `save_prefix))
         (set_prop *env_config*.export
                   `save_prefix
                   "seedling"))
       
       (-> juno_container
           `append page_frame.view)
       (-> (control_holding_tank) `add_control (juno_documentation))
       (-> page_frame `initialize))
      (progn     
       (console.log "serialized controls: " *serialized_controls*)
       (rehydrate_controls juno_container *serialized_controls*)))
    
    (default_focus)
    ;; setup key bindings
    (set_prop *key_bindings*
              `active
              {})  ;; reset out and copy
    (for_each (desc (values (prop *key_bindings* `global)))
       (progn
          (for_each (key_combo (split_by "|" (prop desc key_mode)))
             (set_prop *key_bindings*.active
                key_combo
                (prop desc `exec)))))

     (attach_event_listener juno_container
                           `click
                           (fn (e)
                             (handle_app_click_event e)))
    
    (attach_event_listener (first (get_by_tag `body))
                           `keydown
                           (function (e)
                             (progn                              
                              (defvar kcode (get_key_code e))
                              (when *log_key_events* (log "key_code:" kcode "->" (prop *key_bindings*.active kcode)))
                              ;(console.log "kcode is: " kcode)
                              (aif (prop *key_bindings*.active kcode)
                                   (progn
                                    (handle_event e)
                                    (try 
                                       (it)
                                       (catch Error (e)
                                          (progn
                                             (log_error (+ "Base Catch: " e.message))
                                             (log_error e))))))
                              )))
    
    (attach_event_listener document
       `blur
       (fn (event)
          (progn
             (setq *document_focused* false)
             (dispatch_event { command: "blur"
                               source: "document"
                               args: [ ] }))))
    (attach_event_listener document
       `focus
       (fn (event)
          (progn
             (setq *document_focused* true)
             (dispatch_event { command: "focus"
                               source: "document"
                               args: [ ] }))))
    
    
    
    (notify (+ "Hello " *namespace* ))
    true))






