;; *scratch* buffer

(when (not (contains? "sys" (namespaces)))
   (create_namespace `sys))

(declare (namespace `sys))

(if_compile_time_defined `Deno
   (progn
      (let
         ((status (Deno.permissions.query { name: "run" })))
         (unless (== status.state "granted")
            (warn "sys namespace requires run permissions which are not active.")
            (warn "Evaluate (sys/request) to request.")))
      
      (defun exec (command options)
         (let
            ((arg_set (cond
                         (is_string? command)
                         (split_by " " command)
                         (is_array? command)
                         command
                         else
                         (throw TypeError "system: invalid command format: must be string or array")))
             (options (cond
                         (is_object? options)
                         options
                         (eq nil options)
                         {}
                         else
                         (throw TypeError "system: options must be an object if provided")))
             (process_info nil))
            (= process_info (Deno.run (+ {
                                           cmd: arg_set
                                           stdout: "piped"
                                           stderr: "piped"
                                           }
                                        options)))
            process_info)
         {
           `description: (+ "The exec function spawns a subprocess using the `Deno.run` facility.  "
                            "The command and the arguments to execute is provided as a string or an array of "
                            "strings (which form the command), and returns a `Process` object which contains "
                            "details about the spawned process, including process id, resource id, `stdout`, "
                            "`stderr` and `stdin` streams.  <br>For more details on this command see the "
                            "documentation for Deno.run and Deno.Process.<br>Example:```(text_decode (-> "
                            "(sys/exec \"uptime\") `output))```<br><br> ")
           `usage: ["command:string|array" "options:object"]
           `tags: ["exec" "run" "process" "subprocess" "command"]
           
           })
      
      (defun system (command)
         (let
            ((result (exec command))
             (status (-> result `status))
             (rval nil))
            (= rval
               (+ {
                    stdout: (aif (-> result `output)
                                 (decode_text it)
                                 nil)
                    stderr: (aif (-> result `stderrOutput)
                                 (decode_text it))
                    }
                 status))
            (-> result `close)
            rval)
         {
           `description: (+ "Given a command string or an array with the command and arguments, the "
                            "system function calls the sys/exec function with the command, collects the "
                            "results and returns a serializable object.  This facility provides a simple "
                            "mechanism for running external commands and collecting the return values prior "
                            "to further operations.  The returned simple object contains:<br>stdout:string - "
                            "The standard output that the evaluated command returned. <br>stderr:string - "
                            "Any error output that was produced by the executed command.<br>success:boolean "
                            "- If the command returned 0, then success will be 0.  <br>code:integer - The "
                            "return code of the process.<br>")
           `usage: ["command:string|array"]
           `tags: ["exec" "run" "process" "subprocess" "command"]
           })
      
      (defun request ()
         (Deno.permissions.request { name: "run" })
         {
           `description: "Requests 'run' permissions from the virtual machine."
           `usage: []
           `tags: ["permissions" "run" "process" "subproces"]
           })
      
      (defun compile_executable (options)
            (let
               ((perms (permissions))
                (options (or options {
                                       }))
                (perm_flags (cond
                               (is_array? options.permissions)
                               (for_each (p options.permissions)
                                  (+ "--allow-" p))
                               else
                               (reduce (p (pairs (permissions)))
                                  (destructuring_bind (name status)
                                     p
                                     (when (== status "granted")
                                        (+ "--allow-" name))))))
                (emit_file (cond
                                      options.emit_as
                                      options.emit_as
                                      (resolve_path [ `export `save_executable ] *env_config*)
                                      (resolve_path [ `export `save_executable ] *env_config*)
                                      else
                                      (+ "juno." *env_config*.build)))
                (command (join " "
                               (flatten
                                  ["deno compile"
                                   perm_flags
                                   (if (is_array? options.additional_args)
                                       options.additional_args
                                       [])
                                   "-o"
                                   emit_file
                                   (if (and (is_string? options.target)
                                            (not (blank? options.target)))
                                       ["-t" options.target]
                                       [])
                                   (cond
                                      (is_string? options.source)
                                      options.source
                                      (resolve_path [ `export `save_path ] *env_config*)
                                      (resolve_path [ `export `save_path ] *env_config*)
                                      else
                                      (throw TypeError "compile_executable: cannot resolve the source option: check env_config or provide source in options"))])))
                (result nil))
               
               (if (== perms.run "granted")
                   (progn
                      (= result (system command))
                      (if result.success
                         {
                             success: true
                             emitted: emit_file
                         }
                         result))
                   (progn
                      {
                        `success: false
                        `stderr: "Invalid permissions: require run permissions, evaluate (sys/request) to request access at the console."
                        `stdout: ""
                        })))
            {
              description: (+ "The compile_executable function generates a stand-alone executable from "
                              "a source javascript file.  This can be useful for bundling and distributing "
                              "into a single runtime the application logic and all dependencies.  The output "
                              "varies on the options object provided.  If no options are provided, the "
                              "`*env_config*` object is referenced for default locations and names, and the "
                              "current permission set is used for the emitted binary.  If successful, an "
                              "object is returned with `sucess` set to `true` and an `emitted` key indicating "
                              "where the binary was written.<br><br>#### Options <br><br>emit_as:string - A "
                              "path name to the location to which to write the binary executable file.  By "
                              "default this value is sourced from `*env_config*.exports.save_executable`.  If "
                              "that is not present, then the file is emitted in the current directory with the "
                              "form `juno.{*env_config*.build}`.  <br>permissions:array - A list of "
                              "permissions to be allowed in the emitted executable file.  The current "
                              "permissions can be accessed with the `(permissions)` function.  Include only "
                              "the key names, such as `read` or `net` that you wish to retain in the emitted "
                              "binary.<br>additional_args:array - A list of command line arguments to be "
                              "passed to the Deno compile command.<br>source:string - The source file to be "
                              "used as the bundled image.  By default this value is taken from "
                              "`*env_config*.exports.save_path` <br>target:string - The target architecture to "
                              "emit as.  See `deno compile --help` to see the full list of values "
                              "available.<br> ")
              usage: ["options:object"]
              tags: ["compile" "build" "image" "save" "executable" "export" ]
              })

      
      (unless (resolve_path [ `export `save_executable ] *env_config*)
         (set_path [ `export `save_executable ] *env_config* "bin/juno"))
      (register_feature "system")
      true)
   (progn
      (warn "The sys module requires a Deno runtime.")
      (delete_namespace "sys")
      
      false))


