<!doctype html><html><head title='Seedling'><style id='juno-css'>body { `font-family: "-apple-system,BlinkMacSystemFont,'Segoe UI','Helvetica Neue',Helvetica,sans-serif;" }</style> <script id='juno-core'  type='module'>// Source: undefined  
// Build Time: 2023-03-10 08:42:30
// Version: 2023.03.10.08.42
export const DLISP_ENV_VERSION='2023.03.10.08.42';




function check_true(val) {
  return val||0===val
}
function get_next_environment_id() {
    globalThis.dlisp_environment_count++;
    return globalThis.dlisp_environment_count;
}
function get_outside_global(refname) {  try {    let tfn = new Function("{ if (typeof " + refname + " === 'undefined') { return undefined } else { return "+refname+" } }");    return tfn();  } catch (ex) {    return undefined;  }}
function subtype(value) {  if (value === null) return "null";
  else if (value === undefined) return "undefined";
  else if (value instanceof Array) return "array";
  else if (value.constructor && value.constructor!=null && value.constructor.name!=='Object') {
    return value.constructor.name;
  }
  return typeof value;
}
function lisp_writer(obj,depth,max_depth,env) {
  if (depth===undefined) depth=0;
  if (max_depth===undefined) max_depth=1502;
  const bracketStyles=['[',']','(',')','{','}'];
  let bracketStyle=0;
  let text='';
  let type = subtype(obj);
  //if (depth === 0) console.log("lisp_writer:->",obj);
  if (type === undefined) {
    type = "UNKNOWN"
  }
  if (max_depth && (depth > max_depth)) {
    return "...";
  }
  if (depth > 500) {
    console.warn("lisp_writer: depth bomb: object: ",type);
    throw new Error("recursion too deep");
  }
 
  if (obj===undefined) return 'undefined';
  if (obj===null) return 'null';
  if (typeof obj==='number') return obj;
  if (typeof obj==='function') {
    return "(javascript "+JSON.stringify(obj.toString())+")";
  } // technically this shouldn't be a JSON object but this is a convenience for us..
  if (obj instanceof Array) {
      
    if (obj.length > 0 && (typeof obj[0] === 'string' || obj[0] instanceof String) && obj[0].startsWith("=:")) { // && env && (typeof env.get_global(obj[0].substr(2), null) ) === 'function') {
      bracketStyle = 2;
    }
    text += bracketStyles[bracketStyle];
    // determine if we have any objects or arrays in the list
    for (let i in obj) {
      if (i > 0) text += ' ';
      
      text += lisp_writer(obj[i],depth+4,max_depth, env);
    }
    text += bracketStyles[bracketStyle+1];
    return text;
  } else if (obj instanceof RegExp) {
    return "(new RegExp "+JSON.stringify(obj.source)+" `"+obj.flags+")";
  } else if (obj instanceof Date) {
    return "(new Date \""+obj.toISOString()+"\")";
  } else if (typeof obj ==='object') {
    // object {}
    if (obj.constructor && obj.constructor.name !== "Object") {
      if (typeof Element != 'undefined') {
        if (obj instanceof Element) {
          let clist = Array.from(obj.classList).join(" ");
          if (obj.id) {
            return obj.constructor.name+"/"+obj.tagName.toLowerCase()+"#"+obj.id;
          } else {
            return obj.constructor.name+"/"+obj.tagName.toLowerCase()+"."+clist;
          }
        } else {
          return "" + obj.constructor.name + "";
        }
      } else {
        return "" + obj.constructor.name + "";
      }
    }
    bracketStyle=4;
    text+=bracketStyles[bracketStyle];
    let keys = Object.keys(obj);
    for (let i in keys) {
      if (i > 0) text+= ' ';
      if (typeof obj[keys[i]]=="symbol") {
	      text+=lisp_writer(keys[i], depth+4, max_depth, env)+": \"<symbol>\"";
      } else {
          if ((typeof keys[i] === 'string' || keys[i] instanceof String) && keys[i].indexOf(" ")==-1 && keys[i].indexOf("/")==-1 && !keys[i].startsWith("=:")) {
             text+=keys[i]+":"+lisp_writer(obj[keys[i]],depth+4, max_depth, env);
          } else {
    	     text+=lisp_writer(keys[i], depth+4, max_depth, env)+":"+lisp_writer(obj[keys[i]],depth+4, max_depth, env)
          }
      }
    }
    text += bracketStyles[bracketStyle+1];
    //if (depth === 0) console.log("lisp_writer: <- [ object ]",text);
    return text;
  } else if (typeof obj === 'string') {
    // string    
    if (obj==="=:") return obj;
    else if (obj==="=:##") return ",#";
    else if (obj==="=$,@") return "=$,@";
    else if (obj.startsWith("=:")) return obj.substr(2);
    
    obj = obj.replaceAll("\"","\\\"");        
    obj = obj.replaceAll("'","\\'");        
    obj = obj.replaceAll("\n",'\\n');
    obj = obj.replaceAll("\r",'\\r');
    obj = obj.replaceAll("\f",'\\f');
    obj = obj.replaceAll("\b",'\\b');			         
    
    //if (depth == 0) console.log("lisp_writer: <-",'"'+obj+'"');
    
    return '"'+obj+'"';
    
    
  } else {
    //if (depth === 0) console.log("lisp_writer: <- [ other ]",obj);
    return obj; // numbers and booleans
  }
}
function clone(src,depth) {
        if (src===null) {
            return null;
        }
        depth = depth || 0;
        if (depth >= 500) {
          throw new EvalError("too deep");
        }
        if (src===undefined) {
            return undefined;
        } else if (src === null) {
	    return null;
	} else if (src instanceof Function ) {
            return src; 
        } else if (src==this) {
          return this;	
        } else if (src.constructor===String) {	  
	  return src.toString();
	} else if (src.constructor===Number) {
	  return src;
	} else if (src.constructor===Boolean) {
	  return src;
	} else if ((src.constructor===Array)||(src.constructor===Object)) {
	  let obj;
	  if (src.constructor===Array) {
	    obj=[];
	  } else {
	    obj={}
	  }
          for (let idx in src) {
	    obj[idx]=clone(src[idx],depth+1);
	  }
	  return obj;
	} else {
	  return src;
	}
}
class LispSyntaxError extends SyntaxError {
  constructor(json_structure) {
    super(JSON.stringify(json_structure));
    this.name = 'LispSyntaxError';
  }
}


if (typeof AsyncFunction === "undefined") {
  globalThis.AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
}
export async function init_dlisp(Environment)  {
{
    await async function(){
        globalThis["subtype"]=subtype;
        globalThis["check_true"]=check_true;
        globalThis["clone"]=clone;
        globalThis["lisp_writer"]=lisp_writer;
        globalThis["get_next_environment_id"]=get_next_environment_id;
        globalThis["LispSyntaxError"]=LispSyntaxError;
        return globalThis;
        
    }();
    if (check_true (("undefined"===typeof dlisp_environment_count))){
        await async function(){
            globalThis["dlisp_environment_count"]=0;
            return globalThis;
            
        }()
    };
    {
        let symname;
        symname=await (async function(){
             return "dlisp_env" 
        })();
        {
            await async function(){
                globalThis[symname]=async function(opts) {
                    let subtype=function subtype(value) {  if (value === null) return "null";
  else if (value === undefined) return "undefined";
  else if (value instanceof Array) return "array";
  else if (value.constructor && value.constructor!=null && value.constructor.name!=='Object') {
    return value.constructor.name;
  }
  return typeof value;
};
                    let get_object_path=function(refname) {        if (check_true ((( refname["indexOf"].call(refname,".")>-1)|| ( refname["indexOf"].call(refname,"[")>-1)))){
            {
                let chars;
                let comps;
                let mode;
                let name_acc;
                chars=(refname).split("");
                comps=[];
                mode=0;
                name_acc=[];
                 ( function() {
                    let __for_body__18=function(c) {
                        return   (function(){
                            if (check_true (((c===".")&& (mode===0)))) {
                                {
                                    if (check_true (((name_acc && name_acc.length)>0))){
                                        {
                                            (comps).push((name_acc).join(""))
                                        }
                                    };
                                    return name_acc=[]
                                }
                            } else if (check_true (((mode===0)&& (c==="[")))) {
                                {
                                    mode=1;
                                    if (check_true (((name_acc && name_acc.length)>0))){
                                        {
                                            (comps).push((name_acc).join(""))
                                        }
                                    };
                                    return name_acc=[]
                                }
                            } else if (check_true (((mode===1)&& (c==="]")))) {
                                {
                                    mode=0;
                                    (comps).push((name_acc).join(""));
                                    return name_acc=[]
                                }
                            } else {
                                return (name_acc).push(c)
                            }
                        } )()
                    };
                    let __array__19=[],__elements__17=chars;
                    let __BREAK__FLAG__=false;
                    for(let __iter__16 in __elements__17) {
                        __array__19.push( __for_body__18(__elements__17[__iter__16]));
                        if(__BREAK__FLAG__) {
                             __array__19.pop();
                            break;
                            
                        }
                    }return __array__19;
                     
                })();
                if (check_true (((name_acc && name_acc.length)>0))){
                    (comps).push((name_acc).join(""))
                };
                return comps
            }
        } else {
            return  ( function(){
                let __array_op_rval__20=refname;
                 if (__array_op_rval__20 instanceof Function){
                    return  __array_op_rval__20() 
                } else {
                    return [__array_op_rval__20]
                }
            })()
        }
    };
                    let get_outside_global=function get_outside_global(refname) {  try {    let tfn = new Function("{ if (typeof " + refname + " === 'undefined') { return undefined } else { return "+refname+" } }");    return tfn();  } catch (ex) {    return undefined;  }};
                    ;
                    opts=await (async function(){
                        if (check_true ((opts===undefined))){
                            return new Object()
                        } else {
                            return opts
                        }
                    })();
                    let namespace=(opts.namespace|| "core");
                    ;
                    let in_boot=true;
                    ;
                    let pending_loads=new Object();
                    ;
                    let parent_environment=await (async function(){
                        if (check_true ((namespace==="core"))){
                            return null
                        } else {
                            return opts.parent_environment
                        }
                    })();
                    ;
                    let active_namespace=namespace;
                    ;
                    let contained=(opts.contained|| false);
                    ;
                    let Environment={
                        global_ctx:{
                            scope:new Object(),name:namespace
                        },build_version:(opts.env_version|| DLISP_ENV_VERSION),definitions:(opts.definitions|| new Object()),declarations:(opts.declarations|| {
                            safety:{
                                level:2
                            }
                        })
                    };
                    ;
                    if (check_true (("undefined"===typeof Element))){
                        await async function(){
                            globalThis["Element"]=function() {
                                return false
                            };
                            return globalThis;
                            
                        }()
                    };
                    let id=await get_next_environment_id();
                    ;
                    await async function(){
                        Environment["context"]=Environment.global_ctx;
                        return Environment;
                        
                    }();
                    let unset_compiler=async function() {
                        throw new EvalError(("compiler must be set for "+ namespace));
                        
                    };
                    ;
                    let compiler=unset_compiler;
                    ;
                    let compiler_operators=new Set();
                    ;
                    let special_identity=async function(v) {
                        return v
                    };
                    ;
                    let MAX_SAFE_INTEGER=9007199254740991;
                    ;
                    await async function(){
                        Environment.global_ctx.scope["MAX_SAFE_INTEGER"]=MAX_SAFE_INTEGER;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["MAX_SAFE_INTEGER"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let LispSyntaxError=globalThis.LispSyntaxError;
                    ;
                    await async function(){
                        Environment.global_ctx.scope["LispSyntaxError"]=LispSyntaxError;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["LispSyntaxError"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let sub_type=subtype;
                    ;
                    await async function(){
                        Environment.global_ctx.scope["sub_type"]=sub_type;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["sub_type"]={
                            core_lang:true,description:"Returns a string the determined actual type of the provided value.",usage:["value:*"],tags:["type","class","prototype","typeof","instanceof"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let __VERBOSITY__=0;
                    ;
                    await async function(){
                        Environment.global_ctx.scope["__VERBOSITY__"]=__VERBOSITY__;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["__VERBOSITY__"]={
                            core_lang:true,description:"Set __VERBOSITY__ to a positive integer for verbose console output of system activity.",tags:["debug","compiler","environment","global"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let int=parseInt;
                    ;
                    await async function(){
                        Environment.global_ctx.scope["int"]=int;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["int"]={
                            core_lang:true,usage:"value:string|number",description:"Convenience method for parseInt, should be used in map vs. directly calling parseInt, which will not work directly",tags:["conversion","number"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let float=parseFloat;
                    ;
                    await async function(){
                        Environment.global_ctx.scope["float"]=float;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["float"]={
                            core_lang:true,usage:"value:string|number",description:"Convenience method for parseFloat, should be used in map vs. directly calling parseFloat, which will not work directly",tags:["conversion","number"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let values=new Function("...args","{\n                         let acc = [];\n                         for (let _i in args) {\n                                let value = args[_i];\n                                let type = subtype(value);\n                                if (value instanceof Set)  {\n                                     acc = acc.concat(Array.from(value));\n                                     } else if (type==='array') {\n                                      acc = acc.concat(value);\n                                      } else if (type==='object') {\n                                       acc = acc.concat(Object.values(value))\n                                       } else {\n                                        acc = acc.concat(value);\n                                        }\n                                }\n                         return acc;\n                         }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["values"]=values;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["values"]={
                            core_lang:true,description:("Given a container, returns a list containing the values of each supplied argument. Note that for objects, only the values are returned, not the keys. "+ "If given multiple values, the returned value is a concatentation of all containers provided in the arguments."),usage:["arg0:*","argn:*"],tags:["array","container","object","keys","elements"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let pairs=new Function("obj","{\n                        if (subtype(obj)==='array') {\n                             let rval = [];\n                             for (let i = 0; i < obj.length; i+=2) {\n                                    rval.push([obj[i],obj[i+1]]);\n                                    }\n                             return rval;\n                             } else {\n                              let keys = Object.keys(obj);\n                              let rval = keys.reduce(function(acc,x,i) {\n                                                               acc.push([x,obj[x]])\n                                                               return acc;\n                                                               },[]);\n                              return rval;\n                              }\n                        }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["pairs"]=pairs;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["pairs"]={
                            core_lang:true,description:"Given a passed object or array, returns a list containing a 2 element list for each key/value pair of the supplied object.",tags:["array","container","object"],usage:["obj:object"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let keys=new Function("obj","{  return Object.keys(obj);  }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["keys"]=keys;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["keys"]={
                            core_lang:true,description:"Given an object, returns the keys of the object.",tags:["object","values","keys","indexes","container"],usage:["obj:object"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let take=new Function("place","{ return place.shift() }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["take"]=take;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["take"]={
                            core_lang:true,description:"Takes the first value off the list, and returns the value.",tags:["array","container","mutate","first"],usage:["place:container"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let prepend=new Function("place","thing","{ return place.unshift(thing) }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["prepend"]=prepend;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["prepend"]={
                            core_lang:true,description:"Places the value argument onto the first of the list (unshift) and returns the list.",tags:["array","mutate","container"],usage:["place:array","thing:*"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let first=new Function("x","{ return x[0] }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["first"]=first;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["first"]={
                            core_lang:true,description:"Given an array, returns the first element in the array.",usage:["x:array"],tags:["array","container","elements"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let last=new Function("x","{ return x[x.length - 1] }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["last"]=last;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["last"]={
                            core_lang:true,description:"Given an array, returns the last element in the array.",usage:["x:array"],tags:["array","container","elements","end"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let length=new Function("obj","{\n                         if(obj instanceof Array) {\n                             return obj.length;\n                             } else if (obj instanceof Set) {\n                              return obj.size;\n                              } else if ((obj === undefined)||(obj===null)) {\n                               return 0;\n                               } else if (typeof obj==='object') {\n                                return Object.keys(obj).length;\n                                } else if (typeof obj==='string') {\n                                 return obj.length;\n                                 }\n                         return 0;\n                         }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["length"]=length;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["length"]={
                            core_lang:true,description:("Returns the length of the supplied type (array, object, set, string, number). "+ "If the supplied value is nil or a non-container type, returns 0."),tags:["size","elements","container","dimension","array","set","string","number"],usage:["thing:container"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let conj=new Function("...args","{   let list = [];\n                       if (args[0] instanceof Array) {\n                            list = args[0];\n                            } else {\n                             list = [args[0]];\n                             }\n                       args.slice(1).map(function(x) {\n                                          list = list.concat(x);\n                                          });\n                       return list;\n                       }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["conj"]=conj;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["conj"]={
                            core_lang:true,description:("Conjoins or concatenates things (typically arrays) together and returns an array. "+ "Examples:<br>"+ "(conj [ 1 2 ] [ 3 4 ]) => [ 1 2 3 4 ]<br>"+ "(conj [ 1 2 ] 3 4 ) => [ 1 2 3 4 ]<br>"+ "(conj 1 2 [ 3 4 ]) => [ 1 2 3 4 ]<br>"+ "(conj { `abc: 123 } [ 2 3]) => [ { abc: 123 }, 2, 3 ]<br>"+ "(conj [ 1 2 3 [ 4 ]] [ 5 6 [ 7 ]]) => [ 1 2 3 [ 4 ] 5 6 [ 7 ] ]"),tags:["elements","concat","array","conjoin","append"],usage:["arg0:*","argN:*"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let reverse=new Function("container","{ return container.slice(0).reverse() }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["reverse"]=reverse;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["reverse"]={
                            core_lang:true,usage:["container:list"],description:"Returns a copy of the passed list as reversed.  The original is not changed.",tags:["list","sort","order"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let map=new AsyncFunction("lambda","array_values","{ try {\n                      let rval = [],\n                      tl = array_values.length;\n                      for (let i = 0; i < array_values.length; i++) {\n                             rval.push(await lambda.apply(this,[array_values[i], i, tl]));\n                             }\n                      return rval;\n                      } catch (ex) {\n                       if (lambda === undefined || lambda === null) {\n                             throw new ReferenceError(\"map: lambda argument (position 0) is undefined or nil\")\n                             } else if (array_values === undefined || array_values === null) {\n                              throw new ReferenceError(\"map: container argument (position 1) is undefined or nil\")\n                              } else if (!(lambda instanceof Function)) {\n                               throw new ReferenceError(\"map: lambda argument must be a function: received: \"+ typeof lambda)\n                               } else if (!(array_values instanceof Array)) {\n                                throw new ReferenceError(\"map: invalid array argument, received: \" + typeof array_values)\n                                } else {\n                                 // something else just pass on the error\n                                 throw ex;\n                                 }\n                       }\n                 }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["map"]=map;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["map"]={
                            core_lang:true,description:("Provided a function as a first argument, map calls the function "+ "(item, current_index, total_length) with each element from the second argument, which should be a list. Returns a new list containing the return values resulting from evaluating."),tags:["array","container","elements","iteration"],usage:["lambda:function","elements:array"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let bind=new Function("func,this_arg","{ return func.bind(this_arg) }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["bind"]=bind;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["bind"]={
                            core_lang:true,description:"Given a function and a this value, the bind function returns a new function that has its this keyword set to the provided value in this_arg.",usage:["func:function","this_arg:*"],tags:["bind","this","function"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let to_object=new Function("array_values","{\n                         let obj={}\n                         array_values.forEach((pair)=>{\n                                                 obj[pair[0]]=pair[1]\n                                                 });\n                         return obj;\n                         }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["to_object"]=to_object;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["to_object"]={
                            core_lang:true,description:("Given an array of pairs in the form of [[key value] [key value] ...], constructs an "+ "object with the first array element of the pair as the key and the second "+ "element as the value. A single object is returned."),usage:["paired_array:array"],tags:["conversion","object","array","list","pairs"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let to_array=async function(container) {
                        return await async function(){
                            if (check_true ((container instanceof Array))) {
                                return container
                            } else if (check_true (await (await get_global("is_set?"))(container))) {
                                {
                                    let acc=[];
                                    ;
                                    await container["forEach"].call(container,async function(v) {
                                        return (acc).push(v)
                                    });
                                    return acc
                                }
                            } else if (check_true ((container instanceof String || typeof container==='string'))) {
                                return (container).split("")
                            } else if (check_true ((container instanceof Object))) {
                                return await pairs(container)
                            } else {
                                return await (async function(){
                                    let __array_op_rval__44=container;
                                     if (__array_op_rval__44 instanceof Function){
                                        return await __array_op_rval__44() 
                                    } else {
                                        return [__array_op_rval__44]
                                    }
                                })()
                            }
                        } ()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["to_array"]=to_array;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["to_array"]={
                            core_lang:true,description:("Given a container of type Array, Set, Object, or a string, "+ "it will convert the members of the container to an array form, "+ "and return a new array with the values of the provided container. "+ "In the case of an object, the keys and values will be contained in "+ "paired arrays in the returned array.  A string will be split into "+ "individual characters. If provided a different "+ "type other than the listed values above, the value will be placed "+ "in an array as a single element."),usage:["container:*"],tags:["array","conversion","set","object","string","pairs"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let slice=function(target,from,to) {
                        return   (function(){
                            if (check_true (to)) {
                                return  target["slice"].call(target,from,to)
                            } else if (check_true (from)) {
                                return  target["slice"].call(target,from)
                            } else {
                                throw new SyntaxError("slice requires 2 or 3 arguments");
                                
                            }
                        } )()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["slice"]=slice;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["slice"]={
                            core_lang:true,description:"Given an array, with a starting index and an optional ending index, slice returns a new array containing the elements in the range of provided indices.",usage:["target:array","from:number","to:number"],tags:["array","slicing","dimensions","subset"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let rest=function(x) {
                        return   (function(){
                            if (check_true ((x instanceof Array))) {
                                return  x["slice"].call(x,1)
                            } else if (check_true ((x instanceof String || typeof x==='string'))) {
                                return  x["substr"].call(x,1)
                            } else {
                                return null
                            }
                        } )()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["rest"]=rest;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["rest"]={
                            core_lang:true,description:"Returns a new array containing the elements in the 2nd through last position (the tail) of the provided array.",usage:["x:array"],tags:["array","subset","slice","tail","end"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let second=new Function("x","{ return x[1] }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["second"]=second;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["second"]={
                            core_lang:true,description:"Returns the second element in the provided array (the element at index 1)",tags:["array","subset","element","first"],usage:["x:array"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let third=new Function("x","{ return x[2] }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["third"]=third;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["third"]={
                            core_lang:true,description:"Returns the third element in the provided array (the element at index 2)",tags:["array","subset","element","first"],usage:["x:array"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let chop=new Function("x","{ if (x instanceof Array) { return x.slice(0, x.length-1) } else { return x.substr(0,x.length-1) } }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["chop"]=chop;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["chop"]={
                            core_lang:true,description:"Returns a new container containing all items except the last item.  This function takes either an array or a string.",usage:["container:array|string"],tags:["array","slice","subset","first","string"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let chomp=new Function("x","{ return x.substr(x.length-1) }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["chomp"]=chomp;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["chomp"]={
                            core_lang:true,description:"Given a string returns a new string containing all characters except the last character.",usage:["x:string"],tags:["slice","subset","string"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let not=new Function("x","{ if (check_true(x)) { return false } else { return true } }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["not"]=not;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["not"]={
                            core_lang:true,description:"Returns the logical opposite of the given value.  If given a truthy value, a false is returned.  If given a falsey value, true is returned.",usage:["x:*"],tags:["logic","not","inverse"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let push=new Function("place","thing","{ return place.push(thing) }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["push"]=push;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["push"]={
                            core_lang:true,description:"Given an array as a place, and an arbitrary value, appends (pushes) the value to the end of the array.",usage:["place:array","thing:*"],tags:["array","mutate","append","concat","pop"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let pop=new Function("place","{ return place.pop() }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["pop"]=pop;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["pop"]={
                            core_lang:true,description:"Given an array as an arguments, removes the last value from the given array and returns it.",usage:["place:array"],tags:["array","mutate","take","remove","push"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let list=async function(...args) {
                        return args
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["list"]=list;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["list"]={
                            core_lang:true,description:"Given a set of arbitrary arguments, returns an array containing the provided arguments. If no arguments are provided, returns an empty array.",usage:["arg0:*","argN:*"],tags:["array","container","elements"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let flatten=new Function("x","{ return x.flat(999999999999) } ");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["flatten"]=flatten;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["flatten"]={
                            core_lang:true,description:"Given a nested array structure, returns a flattened version of the array",usage:["x:array"],tags:["array","container","flat","tree"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let jslambda=function(...args) {
                        return  ( function(){
                            let __apply_args__69= flatten(args);
                            return ( Function).apply(this,__apply_args__69)
                        })()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["jslambda"]=jslambda;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["jslambda"]={
                            core_lang:true,description:("Proxy for Javascript Function.  Given a set of string based arguments, all but the last are considered arguments to the "+ "function to be defined.  The last argument is considered the body of the function and should be provided as a string of "+ "javascript. Returns a javascript function. <br>"+ "(jslambda (`a `b) \"{ return a+b }\")<br>"+ "(jslambda () \"{ return new Date() }\")"),usage:["argument_list:array","argn:string"],tags:["javascript","embed","function"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let join=function(...args) {
                        return   (function(){
                            if (check_true ((args.length===1))) {
                                return  args['0']["join"].call(args['0'],"")
                            } else {
                                return  args['1']["join"].call(args['1'],args['0'])
                            }
                        } )()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["join"]=join;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["join"]={
                            core_lang:true,description:("Given an optional joining string and an array of strings, returns a string containing the "+ "elements of the array interlaced with the optional joining string.<br>"+ "(join \",\" [ \"red\" \"fox\" ]) -> \"red,fox\"<br>"+ "(join [\"red\" \"fox\"]) -> redfox"),tags:["array","combine","split","string","text"],usage:["joining_string?:string","container:array"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let lowercase=function(x) {
                        return  x["toLowerCase"]()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["lowercase"]=lowercase;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["lowercase"]={
                            core_lang:true,description:"Given a string, converts all capital characters to lowercase characters.",tags:["string","text","uppercase","case","convert"],usage:["text:string"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let uppercase=function(x) {
                        return  x["toUpperCase"]()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["uppercase"]=uppercase;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["uppercase"]={
                            core_lang:true,description:"Given a string, converts all capital characters to uppercase characters.",tags:["string","text","lowercase","case","convert"],usage:["text:string"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let log=function(...args) {
                        return  ( function(){
                            return ( console.log).apply(this,args)
                        })()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["log"]=log;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["log"]={
                            core_lang:true,description:("log is a shorthand call for console.log by default, and serves to provide a base "+ "abstraction for logging.  Log behavior can be changed by redefining log to "+ "better suit the environmental context.  For example, writing log output to a file "+ "or HTML container."),usage:["args0:*","argsN:*"],tags:["logging","console","output"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let split=new Function("container","token","{ return container.split(token) }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["split"]=split;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["split"]={
                            core_lang:true,description:("Given a string to partition and a string for a splitting token, return an array whose elements "+ "are the text found between each splitting token. <br>"+ "(split \"red,fox\" \",\") => [ \"red\" \"fox\" ]"),tags:["partition","join","separate","string","array"],usage:["string_to_split:string","split_token:string"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let split_by=new Function("token","container","{ return container.split(token) }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["split_by"]=split_by;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["split_by"]={
                            core_lang:true,description:("Given a string for a splitting token and a string to partition, return an array whose elements "+ "are the text found between each splitting token. <br>"+ "(split_by \",\" \"red,fox\") => [ \"red\" \"fox\" ]"),tags:["partition","join","separate","string","array"],usage:["split_token:string","string_to_split:string"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_object_ques_=new Function("x","{ return x instanceof Object }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_object?"]=is_object_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_object?"]={
                            core_lang:true,description:"for the given value x, returns true if x is an Javascript object type.",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_array_ques_=new Function("x","{ return x instanceof Array }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_array?"]=is_array_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_array?"]={
                            core_lang:true,description:"for the given value x, returns true if x is an array.",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_number_ques_=function(x) {
                        return ( subtype(x)==="Number")
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_number?"]=is_number_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_number?"]={
                            core_lang:true,description:"for the given value x, returns true if x is a number.",usage:["arg:value"],tags:["type","condition","subtype","value","what","function"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_function_ques_=function(x) {
                        return (x instanceof Function)
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_function?"]=is_function_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_function?"]={
                            core_lang:true,description:"for the given value x, returns true if x is a function.",usage:["arg:value"],tags:["type","condition","subtype","value","what","function"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_set_ques_=new Function("x","{ return x instanceof Set }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_set?"]=is_set_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_set?"]={
                            core_lang:true,description:"for the given value x, returns true if x is a set.",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_element_ques_=new Function("x","{ return x instanceof Element }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_element?"]=is_element_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_element?"]={
                            core_lang:true,description:"for the given value x, returns true if x is an Element object",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_string_ques_=function(x) {
                        return ((x instanceof String)|| (typeof x==="string"))
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_string?"]=is_string_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_string?"]={
                            core_lang:true,description:"for the given value x, returns true if x is a String object",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_nil_ques_=function(x) {
                        return (x===null)
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_nil?"]=is_nil_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_nil?"]={
                            core_lang:true,description:"for the given value x, returns true if x is exactly equal to nil.",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_regex_ques_=function(x) {
                        return ( sub_type(x)==="RegExp")
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_regex?"]=is_regex_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_regex?"]={
                            core_lang:true,description:"for the given value x, returns true if x is a Javascript regex object",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let is_date_ques_=function(x) {
                        return ( sub_type(x)==="Date")
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["is_date?"]=is_date_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["is_date?"]={
                            core_lang:true,description:"for the given value x, returns true if x is a Date object.",usage:["arg:value"],tags:["type","condition","subtype","value","what"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let ends_with_ques_=new Function("val","text","{ if (text instanceof Array) { return text[text.length-1]===val } else if (subtype(text)=='String') { return text.endsWith(val) } else { return false }}");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["ends_with?"]=ends_with_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["ends_with?"]={
                            core_lang:true,description:"for a given string or array, checks to see if it ends with the given start_value.  Non string args return false.",usage:["end_value:value","collection:array|string"],tags:["string","text","list","array","filter","reduce"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let starts_with_ques_=new Function("val","text","{ if (text instanceof Array) { return text[0]===val } else if (subtype(text)=='String') { return text.startsWith(val) } else { return false }}");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["starts_with?"]=starts_with_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["starts_with?"]={
                            core_lang:true,description:"for a given string or array, checks to see if it starts with the given start_value.  Non string args return false.",usage:["start_value:value","collection:array|string"],tags:["string","text","list","array","filter","reduce","begin"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let delete_prop=new Function("obj","...args","{\n                           if (args.length == 1) {\n                                return delete obj[args[0]];\n                                } else {\n                                 while (args.length > 0) {\n                                         let prop = args.shift();\n                                         delete obj[prop];\n                                         }\n                                 }\n                           return obj;\n                           }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["delete_prop"]=delete_prop;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["delete_prop"]={
                            core_lang:true,description:("Removes the key or keys of the provided object, and returns the modified object.<br>Example:<br>"+ "(defglobal foo { abc: 123 def: 456 ghi: 789 })<br>"+ "(delete_prop foo `abc `def) => { ghi: 789 }<br>"),usage:["obj:objects","key0:string","keyN?:string"],tags:["delete","keys","object","remove","remove_prop","mutate"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let blank_ques_=function(val) {
                        return ((val==null)|| ((val instanceof String || typeof val==='string')&& (val==="")))
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["blank?"]=blank_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["blank?"]={
                            core_lang:true,description:"Given a value, if it is equal (via eq) to nil or to \"\" (an empty string), returns true, otherwise false.",usage:["val:*"],tags:["string","empty","text"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let contains_ques_=new Function("value","container","{ if (!value && !container) { return false }\n                         else if (container === null) { throw new TypeError(\"contains?: passed nil/undefined container value\"); }\n                                            else if (container instanceof Array) return container.includes(value);\n                                            else if (container instanceof Set) return container.has(value);\n                                            else if ((container instanceof String) || typeof container === \"string\") {\n                                                     if (subtype(value) === \"Number\") return container.indexOf(\"\"+value)>-1;\n                                                     else return container.indexOf(value)>-1;\n                                                     }\n                                            else throw new TypeError(\"contains?: passed invalid container type: \"+subtype(container)) }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["contains?"]=contains_ques_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["contains?"]={
                            core_lang:true,description:("Given a target value and container value (array, set, or string), checks if the container has the value. "+ "If it is found, true is returned, otherwise false if returned.  "),tags:["string","array","set","has","includes","indexOf"],usage:["value:*","container:array|set|string"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let make_set=function(vals) {
                        if (check_true ((vals instanceof Array))){
                            return new Set(vals)
                        } else {
                            {
                                let vtype;
                                vtype= sub_type(vals);
                                return   (function(){
                                    if (check_true ((vtype==="Set"))) {
                                        return new Set(vals)
                                    } else if (check_true ((vtype==="object"))) {
                                        return new Set( values(vals))
                                    }
                                } )()
                            }
                        }
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["make_set"]=make_set;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["make_set"]={
                            core_lang:true,description:("If given an array, a new Set is returned containing the elements of the array. "+ "If given an object, a new Set is returned containing the values of the object, and the keys are discarded. "+ "If given a set, new Set is created and returend  from the values of the old set."),usage:["vals:array|object|set"],tags:["array","set","object","values","convert"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let meta_for_symbol=function(quoted_symbol,search_mode) {
                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){
                            {
                                let local_data=(Environment.global_ctx.scope[quoted_symbol]|| Environment.definitions[quoted_symbol]);
                                ;
                                let acc=[];
                                ;
                                if (check_true (search_mode)){
                                    {
                                        if (check_true (local_data)){
                                            {
                                                (acc).push( ( get_global("add"))({
                                                    namespace:namespace,name:quoted_symbol,type: subtype(local_data)
                                                }, ( function(){
                                                    let it;
                                                    it=Environment.definitions[quoted_symbol];
                                                    if (check_true (it)){
                                                        return it
                                                    } else {
                                                        return new Object()
                                                    }
                                                })()))
                                            }
                                        };
                                        if (check_true (parent_environment)){
                                            {
                                                {
                                                    let __collector;
                                                    let __result;
                                                    let __action;
                                                    __collector=[];
                                                    __result=null;
                                                    __action=function(info) {
                                                        return (acc).push(info)
                                                    };
                                                    ;
                                                     ( function() {
                                                        let __for_body__121=function(__item) {
                                                            __result= __action(__item);
                                                            if (check_true (__result)){
                                                                return (__collector).push(__result)
                                                            }
                                                        };
                                                        let __array__122=[],__elements__120= ( function() {
                                                            {
                                                                 let __call_target__= parent_environment["meta_for_symbol"].call(parent_environment,quoted_symbol,true), __call_method__="flat";
                                                                return  __call_target__[__call_method__].call(__call_target__,1)
                                                            } 
                                                        })();
                                                        let __BREAK__FLAG__=false;
                                                        for(let __iter__119 in __elements__120) {
                                                            __array__122.push( __for_body__121(__elements__120[__iter__119]));
                                                            if(__BREAK__FLAG__) {
                                                                 __array__122.pop();
                                                                break;
                                                                
                                                            }
                                                        }return __array__122;
                                                         
                                                    })();
                                                    __collector
                                                }
                                            }
                                        };
                                        if (check_true (( length( keys(children))>0))){
                                            {
                                                {
                                                    let __collector;
                                                    let __result;
                                                    let __action;
                                                    __collector=[];
                                                    __result=null;
                                                    __action=function(details) {
                                                        return (acc).push(details)
                                                    };
                                                    ;
                                                     ( function() {
                                                        let __for_body__125=function(__item) {
                                                            __result= __action(__item);
                                                            if (check_true (__result)){
                                                                return (__collector).push(__result)
                                                            }
                                                        };
                                                        let __array__126=[],__elements__124= ( function(){
                                                            let ____collector__127=  function(){
                                                                return []
                                                            };
                                                            let ____result__128=  function(){
                                                                return null
                                                            };
                                                            let ____action__129=  function(){
                                                                return function(child_data) {
                                                                    if (check_true ( not((child_data['0']=== ( get_global("current_namespace"))())))){
                                                                        {
                                                                            return  child_data['1']["meta_for_symbol"].call(child_data['1'],quoted_symbol)
                                                                        }
                                                                    }
                                                                }
                                                            };
                                                            {
                                                                let __collector= ____collector__127();
                                                                ;
                                                                let __result= ____result__128();
                                                                ;
                                                                let __action= ____action__129();
                                                                ;
                                                                ;
                                                                 ( function() {
                                                                    let __for_body__132=function(__item) {
                                                                        __result= __action(__item);
                                                                        if (check_true (__result)){
                                                                            return (__collector).push(__result)
                                                                        }
                                                                    };
                                                                    let __array__133=[],__elements__131= pairs(children);
                                                                    let __BREAK__FLAG__=false;
                                                                    for(let __iter__130 in __elements__131) {
                                                                        __array__133.push( __for_body__132(__elements__131[__iter__130]));
                                                                        if(__BREAK__FLAG__) {
                                                                             __array__133.pop();
                                                                            break;
                                                                            
                                                                        }
                                                                    }return __array__133;
                                                                     
                                                                })();
                                                                return __collector
                                                            }
                                                        })();
                                                        let __BREAK__FLAG__=false;
                                                        for(let __iter__123 in __elements__124) {
                                                            __array__126.push( __for_body__125(__elements__124[__iter__123]));
                                                            if(__BREAK__FLAG__) {
                                                                 __array__126.pop();
                                                                break;
                                                                
                                                            }
                                                        }return __array__126;
                                                         
                                                    })();
                                                    __collector
                                                }
                                            }
                                        };
                                        return acc
                                    }
                                } else {
                                    {
                                        quoted_symbol= ( function(){
                                            if (check_true ( starts_with_ques_( ( function(){
                                                 return "=:" 
                                            })(),quoted_symbol))){
                                                return  quoted_symbol["substr"].call(quoted_symbol,2)
                                            } else {
                                                return quoted_symbol
                                            }
                                        })();
                                        {
                                            let it;
                                            it=Environment.definitions[quoted_symbol];
                                            if (check_true (it)){
                                                return  ( get_global("add"))({
                                                    namespace:namespace,type: sub_type(local_data),name:quoted_symbol
                                                },it)
                                            } else {
                                                return null
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["meta_for_symbol"]=meta_for_symbol;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["meta_for_symbol"]={
                            core_lang:true,description:("Given a quoted symbol and a boolean indicating whether or not all namespaces should be searched, returns "+ "the meta data associated with the symbol for each environment.  If search mode is requested, the value returned "+ "is an array, since there can be symbols with the same name in different environments. If no values are found "+ "an empty array is returned.  If not in search mode, meta_for_symbol searches the current namespace "+ "only, and if a matching symbol is found, returns an object with all found metadata, otherwise nil is returned."),usage:["quoted_symbol:string","search_mode:boolean"],tags:["describe","meta","help","definition","symbol","metadata"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let describe=async function(quoted_symbol,search_mode) {
                        let internal_results=await meta_for_symbol(quoted_symbol,true);
                        ;
                        if (check_true (((internal_results instanceof Array)&& internal_results['0']))){
                            if (check_true (search_mode)){
                                return internal_results
                            } else {
                                return await first(internal_results)
                            }
                        } else {
                            {
                                let external_results=await get_outside_global(quoted_symbol);
                                ;
                                if (check_true (external_results)){
                                    {
                                        let detail={
                                            location:"external",type:await subtype(external_results),name:quoted_symbol,namespace:"EXTERNAL",description:("This is not a bound symbol within the Juno Environment.  "+ "If it is to be used, it is recommended to create a reference to it with "+ "`(defglobal "+ quoted_symbol+ " "+ quoted_symbol+ " { `description: \"...\" })`")
                                        };
                                        ;
                                        if (check_true (search_mode)){
                                            return await (async function(){
                                                let __array_op_rval__136=detail;
                                                 if (__array_op_rval__136 instanceof Function){
                                                    return await __array_op_rval__136() 
                                                } else {
                                                    return [__array_op_rval__136]
                                                }
                                            })()
                                        } else {
                                            return detail
                                        }
                                    }
                                } else {
                                    return null
                                }
                            }
                        }
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["describe"]=describe;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["describe"]={
                            core_lang:true,description:"Given a quoted symbol returns the relevant metadata pertinent to the current namespace context.",usage:["quoted_symbol:string","search_mode:boolean"],tags:["meta","help","definition","symbol","metadata","info","meta_for_symbol"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let undefine=function(quoted_symbol) {
                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){
                            {
                                let namespace_identity;
                                let parent_call;
                                let child_call;
                                let target_symbol;
                                namespace_identity=(quoted_symbol).split("/");
                                parent_call=null;
                                child_call=null;
                                target_symbol=null;
                                ;
                                return   (function(){
                                    if (check_true ((((namespace_identity.length===1)&& Environment.global_ctx.scope[namespace_identity['0']])|| ((namespace_identity.length>1)&& (namespace_identity['0']===namespace))))) {
                                        {
                                            target_symbol= ( function(){
                                                if (check_true ((namespace_identity.length>1))){
                                                    return namespace_identity['1']
                                                } else {
                                                    return namespace_identity['0']
                                                }
                                            })();
                                             delete_prop(Environment.definitions,target_symbol);
                                            if (check_true (Environment.global_ctx.scope[target_symbol])){
                                                return  delete_prop(Environment.global_ctx.scope,target_symbol)
                                            } else {
                                                return false
                                            }
                                        }
                                    } else if (check_true (((namespace_identity.length>1)&& parent_environment))) {
                                        {
                                            parent_call= parent_environment["get_global"].call(parent_environment,"undefine");
                                            return (parent_call)(quoted_symbol)
                                        }
                                    } else if (check_true (((namespace_identity.length>1)&& children[namespace_identity['0']]))) {
                                        {
                                            child_call= ( function() {
                                                {
                                                     let __call_target__=children[namespace_identity['0']], __call_method__="get_global";
                                                    return  __call_target__[__call_method__].call(__call_target__,"undefine")
                                                } 
                                            })();
                                            return  child_call(quoted_symbol)
                                        }
                                    } else {
                                        return false
                                    }
                                } )()
                            }
                        } else {
                            throw new SyntaxError("undefine requires a quoted symbol");
                            
                        }
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["undefine"]=undefine;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["undefine"]={
                            core_lang:true,description:("Given a quoted symbol removes the symbol and any definition information from the namespace. "+ "If the namespace is fully-qualified, then the symbol will be removed from the specified namespace "+ "instead of the currently active namespace. If the symbol is successfully removed, the function "+ "will return true, otherwise if it is not found, false will be returned.  Note that if the "+ "specified symbol is non-qualified, but exists in a different, accessible namespace, but the "+ "symbol isn't present in the current namespace, the symbol will not be deleted.  The environment "+ "is not searched and therefore symbols have to be explicitly fully-qualified for any effect "+ "of this function outside the current namespace."),usage:["quoted_symbol:string"],tags:["symbol","delete","remove","unintern","reference","value"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let eval_exp=async function(expression) {
                        return await (async function(){
                            let __array_op_rval__141=expression;
                             if (__array_op_rval__141 instanceof Function){
                                return await __array_op_rval__141() 
                            } else {
                                return [__array_op_rval__141]
                            }
                        })()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["eval_exp"]=eval_exp;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["eval_exp"]={
                            core_lang:true,description:("Evaluates the given expression and returns the value."),usage:["expression:*"],tags:["eval","evaluation","expression"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let indirect_new=function(...args) {
                        
                             {
                               let targetClass = args[0];
                               if (subtype(targetClass)==="String") {
                                    let tmpf=new Function("{ return "+targetClass+" }");
                                    targetClass = tmpf();
                                    }
                               if (args.length==1) {
                                    let f = function(Class) {
                                                      return new (Function.prototype.bind.apply(Class, args));
                                                      }
                                    let rval = f.apply(this,[targetClass]);
                                    return rval;
                                    } else {
                                     let f = function(Class) {
                                                       return new (Function.prototype.bind.apply(Class, args));
                                                       }
                                     let rval = f.apply(this,[targetClass].concat(args.slice(1)));
                                     return rval;
                                     }
                               } 
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["indirect_new"]=indirect_new;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["indirect_new"]={
                            core_lang:true,description:("Used by the compiler for implementation of the new operator and shouldn't be directly called by "+ "user programs.  The new operator should be called instead."),usage:["arg0:*","argsN:*"],tags:["system","compiler","internal"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let range=function(...args) {
                        let from_to;
                        let step;
                        let idx;
                        let acc;
                        from_to= ( function(){
                            if (check_true (args['1'])){
                                return [parseInt(args['0']),parseInt(args['1'])]
                            } else {
                                return [0,parseInt(args['0'])]
                            }
                        })();
                        step= ( function(){
                            if (check_true (args['2'])){
                                return parseFloat(args['2'])
                            } else {
                                return 1
                            }
                        })();
                        idx=from_to['0'];
                        acc=[];
                         ( get_global("assert"))((step>0),"range: step must be > 0");
                         ( get_global("assert"))((from_to['1']>=from_to['0']),"range: lower bound must be greater or equal than upper bound");
                         ( function(){
                             let __test_condition__146=function() {
                                return (idx<from_to['1'])
                            };
                            let __body_ref__147=function() {
                                (acc).push(idx);
                                return idx+=step
                            };
                            let __BREAK__FLAG__=false;
                            while( __test_condition__146()) {
                                  __body_ref__147();
                                 if(__BREAK__FLAG__) {
                                     break;
                                    
                                }
                            } ;
                            
                        })();
                        return acc
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["range"]=range;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["range"]={
                            core_lang:true,usage:["start_or_end:number","end:number","step:number"],description:("Range has a variable form depending on the amount of arguments provided to the function when "+ "calling it. If provided one argument, range will produce an array from 0 up to, but not including "+ "the provided value. If given two arguments, the first argument will be the starging value and "+ "the last value will be used as the upper bounding value, returning an array with elements starting "+ "at the start value and up to, but not including the bounding value. If given a third value, the "+ "value will be interpreted as the step value, and the returned array will contain values that "+ "increment by the step amount.  Range will throw an error if a negative range is specified. "+ "For negative ranges see neg_range."+ "<br><br>Examples:<br>"+ "(range 5) -> [ 0 1 2 3 4 ]<br>"+ "(range 10 15) -> [ 10 11 12 13 14 ]<br>"+ "(range 10 20) -> [ 10 12 14 16 18 ]<br>"+ "(range -5 0) -> [ -5 -4 -3 -2 -1 ]<br>"+ "(range -3 3) -> [ -3, -2, -1, 0, 1, 2 ]<br>")
                        };
                        return Environment.definitions;
                        
                    }()];
                    let add=new Function("...args","{\n                   let acc;\n                   if (typeof args[0]===\"number\") {\n                        acc = 0;\n                        } else if (args[0] instanceof Array) {\n                         return args[0].concat(args.slice(1));\n                         } else if (typeof args[0]==='object') {\n                          let rval = {};\n                          for (let i in args) {\n                                 if (typeof args[i] === 'object') {\n                                      for (let k in args[i]) {\n                                             rval[k] = args[i][k];\n                                             }\n                                      }\n                                 }\n                          return rval;\n                          } else {\n                           acc = \"\";\n                           }\n                   for (let i in args) {\n                          acc += args[i];\n                          }\n                   return acc;\n                   }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["add"]=add;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["add"]={
                            core_lang:true,description:("Add is an overloaded function that, based on the first argument provided, determines how to 'add' the arguments. "+ "If provided a number as a first argument, then it will assume the rest of the arguments are numbers and add them "+ "to the first, returning the numerical sum of the arguments. If an object, it will merge the keys of the provided "+ "arguments, returning a combined object.  Be aware that if merging objects, if arguments that have the same keys "+ "the argument who appears last with the key will prevail.  If called with an array as a first argument, the "+ "subsequent arguments will be added to the first via 'concat'.  If strings, the strings will be joined into a "+ "single string and returned.<br>"+ "(add 1 2 3) => 6<br>"+ "(add { `abc: 123 `def: 345 } { `def: 456 }) => { abc: 123, def: 456 }"+ "(add [ 1 2 3 ] [ 4 5 6] 7) => [ 1, 2, 3, [ 4, 5, 6 ], 7 ]<br>"+ "(add \"abc\" \"def\") => \"abcdef\"<br><br>"+ "Note that add doesn't typically need to explicily called.  The compiler will try and determine the best "+ "way to handle adding based on the arguments to be added, so the + operator should be used instead, since "+ "it gives the compiler an opportunity to inline if possible."),usage:["arg0:*","argN:*"],tags:["add","+","sum","number","addition","merge","join","concat"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let merge_objects=new Function("x","{\n                             let rval = {};\n                             for (let i in x) {\n                                    if (typeof i === 'object') {\n                                         for (let k in x[i]) {\n                                                rval[k] = x[i][k];\n                                                }\n                                         }\n                                    }\n                             return rval;\n                             }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["merge_objects"]=merge_objects;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["merge_objects"]={
                            core_lang:true,description:("Merge objects takes an array of objects and returns an object whose keys and values are "+ "the sum of the provided objects (same behavior as add with objects).  If objects have the "+ "same keys, the last element in the array with the duplicate key will be used to provide the "+ "value for that key."),usage:["objects:array"],tags:["add","merge","keys","values","objects","value"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let index_of=new Function("value","container",("{ return container.indexOf(value) }"));
                    ;
                    await async function(){
                        Environment.global_ctx.scope["index_of"]=index_of;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["index_of"]={
                            core_lang:true,description:"Given a value and an array container, returns the index of the value in the array, or -1 if not found.",usage:["value:number|string|boolean","container:array"],tags:["find","position","index","array","contains"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let resolve_path=new Function("path,obj","{\n                            if (typeof path==='string') {\n                                 path = path.split(\".\");\n                                 }\n                            let s=obj;\n                            return path.reduce(function(prev, curr) {\n                                                         return prev ? prev[curr] : undefined\n                                                         }, obj || {})\n                            }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["resolve_path"]=resolve_path;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["resolve_path"]={
                            core_lang:true,description:("Given a path and a tree structure, which can be either an array or an object, "+ "traverse the tree structure and return the value at the path if it exists, otherwise "+ "undefined is returned.<br>"+ "(resolve_path [ 2 1 ] [ 1 2 [ 3 4 5 ] 6 7]) => 4)"),usage:["path:array","tree_structure:array|object"],tags:["find","position","index","path","array","tree","contains","set_path"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let min_value=new Function("elements","{ return Math.min(...elements); }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["min_value"]=min_value;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["min_value"]={
                            core_lang:true,description:"Returns the minimum value in the provided array of numbers.",usage:["elements:array"],tags:["min","max_value","array","elements","minimum","number"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let max_value=new Function("elements","{ return Math.max(...elements); }");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["max_value"]=max_value;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["max_value"]={
                            core_lang:true,description:"Returns the maximum value in the provided array of numbers.",usage:["elements:array"],tags:["min","max_value","array","elements","minimum","number"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let interlace=async function(...args) {
                        let min_length;
                        let rlength_args;
                        let rval;
                        min_length=await (async function(){
                             return await min_value(await (async function(){
                                 return await map(length,args) 
                            })()) 
                        })();
                        rlength_args=await range(await length(args));
                        rval=[];
                        await (async function() {
                            let __for_body__164=async function(i) {
                                return await (async function() {
                                    let __for_body__168=async function(j) {
                                        return (rval).push(await (async function(){
                                            let __targ__170=args[j];
                                            if (__targ__170){
                                                 return(__targ__170)[i]
                                            } 
                                        })())
                                    };
                                    let __array__169=[],__elements__167=rlength_args;
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__166 in __elements__167) {
                                        __array__169.push(await __for_body__168(__elements__167[__iter__166]));
                                        if(__BREAK__FLAG__) {
                                             __array__169.pop();
                                            break;
                                            
                                        }
                                    }return __array__169;
                                     
                                })()
                            };
                            let __array__165=[],__elements__163=await range(min_length);
                            let __BREAK__FLAG__=false;
                            for(let __iter__162 in __elements__163) {
                                __array__165.push(await __for_body__164(__elements__163[__iter__162]));
                                if(__BREAK__FLAG__) {
                                     __array__165.pop();
                                    break;
                                    
                                }
                            }return __array__165;
                             
                        })();
                        return rval
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["interlace"]=interlace;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["interlace"]={
                            core_lang:true,usage:["list0:array","list1:array","listn?:array"],description:"Returns a list containing a consecutive values from each list, in argument order.  I.e. list0.0 list1.0 listn.0 list0.1 list1.1 listn.1 ...",tags:["list","array","join","merge"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let trim=function(x) {
                        return  x["trim"]()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["trim"]=trim;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["trim"]={
                            core_lang:true,description:"Removes leading and trailing spaces from the provided string value.",usage:["value:string"],tags:["string","spaces","clean","squeeze","leading","trailing","space"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let assert=function(assertion_form,failure_message) {
                        if (check_true (assertion_form)){
                            return assertion_form
                        } else {
                            throw new EvalError((failure_message|| "assertion failure"));
                            
                        }
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["assert"]=assert;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["assert"]={
                            core_lang:true,description:"If the evaluated assertion form is true, the result is returned, otherwise an EvalError is thrown with the optionally provided failure message.",usage:["form:*","failure_message:string?"],tags:["true","error","check","debug","valid","assertion"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let unquotify=async function(val) {
                        let dval;
                        dval=val;
                        if (check_true (await starts_with_ques_("\"",dval))){
                            dval=await dval["substr"].call(dval,1,(dval.length- 2))
                        };
                        if (check_true (await starts_with_ques_("=:",dval))){
                            dval=await dval["substr"].call(dval,2)
                        };
                        return dval
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["unquotify"]=unquotify;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["unquotify"]={
                            core_lang:true,description:"Removes binding symbols and quotes from a supplied value.  For use in compile time function such as macros.",usage:["val:string"],tags:["macro","quote","quotes","desym"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let or_args=async function(argset) {
                        let is_true;
                        is_true=false;
                        await (async function() {
                            let __for_body__181=async function(elem) {
                                if (check_true (elem)){
                                    {
                                        is_true=true;
                                        return __BREAK__FLAG__=true;
                                        return
                                    }
                                }
                            };
                            let __array__182=[],__elements__180=argset;
                            let __BREAK__FLAG__=false;
                            for(let __iter__179 in __elements__180) {
                                __array__182.push(await __for_body__181(__elements__180[__iter__179]));
                                if(__BREAK__FLAG__) {
                                     __array__182.pop();
                                    break;
                                    
                                }
                            }return __array__182;
                             
                        })();
                        return is_true
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["or_args"]=or_args;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["or_args"]={
                            core_lang:true,description:"Provided an array of values, returns true if any of the values are true, otherwise will return false.",usage:["argset:array"],tags:["or","true","false","array","logic"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let special_operators=async function() {
                        return await make_set(await (async function(){
                             return await compiler([],{
                                special_operators:true,env:Environment
                            }) 
                        })())
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["special_operators"]=special_operators;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["special_operators"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let defclog=async function(opts) {
                        let style;
                        style=("padding: 5px;"+ await (async function(){
                            if (check_true (opts.background)){
                                return ("background: "+ opts.background+ ";")
                            } else {
                                return ""
                            }
                        })()+ await (async function(){
                            if (check_true (opts.color)){
                                return ("color: "+ opts.color+ ";")
                            }
                        })()+ "");
                        return async function(...args) {
                            return await (async function(){
                                let __target_arg__189=[].concat(await conj(await (async function(){
                                    let __array_op_rval__190=style;
                                     if (__array_op_rval__190 instanceof Function){
                                        return await __array_op_rval__190() 
                                    } else {
                                        return [__array_op_rval__190]
                                    }
                                })(),args));
                                if(!__target_arg__189 instanceof Array){
                                    throw new TypeError("Invalid final argument to apply - an array is required")
                                }let __pre_arg__191=("%c"+ await (async function(){
                                    if (check_true (opts.prefix)){
                                        return opts.prefix
                                    } else {
                                        return (args).shift()
                                    }
                                })());
                                __target_arg__189.unshift(__pre_arg__191);
                                return (console.log).apply(this,__target_arg__189)
                            })()
                        }
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["defclog"]=defclog;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["defclog"]={
                            core_lang:true,description:("Given a description object, containing specific keys, returns a customized console logging "+ "function implements the given requested properties.<br>Options<br>"+ "prefix:string:The prefix to log prior to any supplied user arguments.<br>"+ "color:string:The text color to use on the prefix (or initial argument if no prefix)<br>"+ "background:string:The background coloe to use on the prefix (or initial argument if no prefix)<br>"),usage:["options:object"],tags:["log","logging","console","utility"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let NOT_FOUND=new ReferenceError("not found");
                    ;
                    await async function(){
                        Environment.global_ctx.scope["NOT_FOUND"]=NOT_FOUND;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["NOT_FOUND"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let check_external_env_default=await (async function(){
                        if (check_true ((namespace==="core"))){
                            return true
                        } else {
                            return false
                        }
                    })();
                    ;
                    await async function(){
                        Environment.global_ctx.scope["check_external_env_default"]=check_external_env_default;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["check_external_env_default"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let _star_namespace_star_=namespace;
                    ;
                    await async function(){
                        Environment.global_ctx.scope["*namespace*"]=_star_namespace_star_;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["*namespace*"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let pending_ns_loads=new Object();
                    ;
                    await async function(){
                        Environment.global_ctx.scope["pending_ns_loads"]=pending_ns_loads;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["pending_ns_loads"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let pend_load=async function(from_namespace,target_namespace,symbol,initializer) {
                        if (check_true ((null==pending_ns_loads[from_namespace]))){
                            {
                                await async function(){
                                    pending_ns_loads[from_namespace]=[];
                                    return pending_ns_loads;
                                    
                                }()
                            }
                        };
                        (pending_ns_loads[from_namespace]).push({
                            symbol:symbol,source_ns:from_namespace,target_ns:target_namespace,initializer:await (async function(){
                                 return ["=:quote",initializer] 
                            })()
                        });
                        return initializer
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["pend_load"]=pend_load;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["pend_load"]={
                            core_lang:true,description:("When used as an initializer wrapper via the use_symbols macro, the wrapped "+ "initializer will not be loaded until the from_namespace is loaded to ensure "+ "that the wrapped initializer won't fail due to not yet loaded dependencies."),usage:["from_namespace:string","target_namespace:string","symbol:string","initializer:array"],tags:["symbol","definitions","namespace","scope","dependency","dependencies","require"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let load_pends=async function(from_namespace) {
                        if (check_true (pending_ns_loads[from_namespace])){
                            {
                                let acc=[];
                                ;
                                acc=await (async function() {
                                    let __for_body__207=async function(load_instruction) {
                                        return ["=:use_symbols",load_instruction.source_ns,[load_instruction.symbol],load_instruction.target_ns]
                                    };
                                    let __array__208=[],__elements__206=pending_ns_loads[from_namespace];
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__205 in __elements__206) {
                                        __array__208.push(await __for_body__207(__elements__206[__iter__205]));
                                        if(__BREAK__FLAG__) {
                                             __array__208.pop();
                                            break;
                                            
                                        }
                                    }return __array__208;
                                     
                                })();
                                await console.log("load_pends: ",from_namespace,"->",acc);
                                (await Environment.eval(await async function(){
                                    return acc
                                }(),null));
                                return true
                            }
                        }
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["load_pends"]=load_pends;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["load_pends"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let symbols=async function(opts) {
                        return await async function(){
                            if (check_true ((null==opts))) {
                                return await keys(Environment.global_ctx.scope)
                            } else if (check_true (opts.unique)) {
                                {
                                    let no_includes=await make_set(await conj(["meta_for_symbol","describe","undefine","*namespace*","pend_load","symbols","set_global","get_global","symbol_definition","compile","env_log","evaluate_local","evaluate","eval_struct","set_compiler","clone","eval","add_escape_encoding","get_outside_global","as_lisp","lisp_writer","clone_to_new","save_env","null","compiler"],built_ins));
                                    ;
                                    {
                                        let __collector;
                                        let __result;
                                        let __action;
                                        __collector=[];
                                        __result=null;
                                        __action=async function(sym) {
                                            if (check_true (await no_includes["has"].call(no_includes,sym))){
                                                return null
                                            } else {
                                                return sym
                                            }
                                        };
                                        ;
                                        await (async function() {
                                            let __for_body__213=async function(__item) {
                                                __result=await __action(__item);
                                                if (check_true (__result)){
                                                    return (__collector).push(__result)
                                                }
                                            };
                                            let __array__214=[],__elements__212=await keys(Environment.global_ctx.scope);
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__211 in __elements__212) {
                                                __array__214.push(await __for_body__213(__elements__212[__iter__211]));
                                                if(__BREAK__FLAG__) {
                                                     __array__214.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__214;
                                             
                                        })();
                                        return __collector
                                    }
                                }
                            }
                        } ()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["symbols"]=symbols;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["symbols"]={
                            core_lang:true,description:("Returns an array of the defined global symbols for the local environment.  "+ "If opts.unique is true, only symbols that are not part of the built ins are "+ "included."),usage:["opts:object"],tags:["symbol","names","definitions","values","scope"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let set_global=function(refname,value,meta,is_constant,target_namespace,contained_req) {
                          (function(){
                            if (check_true ( not((typeof refname==="string")))) {
                                throw new TypeError("reference name must be a string type");
                                
                            } else if (check_true (((Environment===value)|| (Environment.global_ctx===value)|| (Environment.global_ctx.scope===value)))) {
                                {
                                    throw new EvalError("cannot set the environment scope as a global value");
                                    
                                }
                            }
                        } )();
                        if (check_true ( resolve_path( ( function(){
                            let __array_op_rval__217=refname;
                             if (__array_op_rval__217 instanceof Function){
                                return  __array_op_rval__217("constant") 
                            } else {
                                return [__array_op_rval__217,"constant"]
                            }
                        })(),Environment.definitions))){
                            {
                                throw new TypeError(("Assignment to constant variable "+ refname));
                                
                            }
                        };
                        let namespace_identity= ( function(){
                            if (check_true (target_namespace)){
                                return  ( function(){
                                    let __array_op_rval__218=target_namespace;
                                     if (__array_op_rval__218 instanceof Function){
                                        return  __array_op_rval__218(refname) 
                                    } else {
                                        return [__array_op_rval__218,refname]
                                    }
                                })()
                            } else {
                                return (refname).split("/")
                            }
                        })();
                        ;
                        return   (function(){
                            if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace===namespace_identity['0']))))) {
                                return  parent_environment["set_global"].call(parent_environment,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'],(contained|| contained_req))
                            } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {
                                {
                                    if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){
                                        return  ( function() {
                                            {
                                                 let __call_target__=children[namespace_identity['0']], __call_method__="set_global";
                                                return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'])
                                            } 
                                        })()
                                    } else {
                                        throw new EvalError(("namespace "+ namespace_identity['0']+ " doesn't exist"));
                                        
                                    }
                                }
                            } else {
                                try {
                                    let comps= get_object_path( ( function(){
                                        if (check_true ((1===namespace_identity.length))){
                                            return namespace_identity['0']
                                        } else {
                                            return namespace_identity['1']
                                        }
                                    })());
                                    ;
                                      (function(){
                                        Environment.global_ctx.scope[comps['0']]=value;
                                        return Environment.global_ctx.scope;
                                        
                                    })();
                                    if (check_true (((meta instanceof Object)&&  not((meta instanceof Array))))){
                                        {
                                            if (check_true (is_constant)){
                                                {
                                                      (function(){
                                                        meta["constant"]=true;
                                                        return meta;
                                                        
                                                    })()
                                                }
                                            };
                                              (function(){
                                                Environment.definitions[comps['0']]=meta;
                                                return Environment.definitions;
                                                
                                            })()
                                        }
                                    } else {
                                        if (check_true (is_constant)){
                                            {
                                                  (function(){
                                                    Environment.definitions[comps['0']]={
                                                        constant:true
                                                    };
                                                    return Environment.definitions;
                                                    
                                                })()
                                            }
                                        }
                                    };
                                    return Environment.global_ctx.scope[comps['0']]
                                } catch (__exception__219) {
                                    if (__exception__219 instanceof Error) {
                                        let e=__exception__219;
                                        {
                                            {
                                                let message=("Error: set_global: "+ _star_namespace_star_+ "symbol name: "+ refname+ ": "+ e.message);
                                                ;
                                                 console.error(message,[]);
                                                  (function(){
                                                    e["message"]=message;
                                                    return e;
                                                    
                                                })();
                                                throw e;
                                                
                                            }
                                        }
                                    }
                                }
                            }
                        } )()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["set_global"]=set_global;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["set_global"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let get_global=function(refname,value_if_not_found,suppress_check_external_env,target_namespace,path_comps,contained_req) {
                        return   (function(){
                            if (check_true ( not((typeof refname==="string")))) {
                                throw new TypeError("reference name must be a string type");
                                
                            } else if (check_true ((refname==="Environment"))) {
                                return Environment
                            } else if (check_true ( compiler_operators["has"].call(compiler_operators,refname))) {
                                return special_identity
                            } else {
                                {
                                    let namespace_identity;
                                    let comps;
                                    let refval;
                                    let symbol_name;
                                    let check_external_env;
                                    namespace_identity= ( function(){
                                        if (check_true (target_namespace)){
                                            return  ( function(){
                                                let __array_op_rval__227=target_namespace;
                                                 if (__array_op_rval__227 instanceof Function){
                                                    return  __array_op_rval__227(refname) 
                                                } else {
                                                    return [__array_op_rval__227,refname]
                                                }
                                            })()
                                        } else {
                                            return (refname).split("/")
                                        }
                                    })();
                                    comps=(path_comps||  get_object_path( ( function(){
                                        if (check_true ((1===namespace_identity.length))){
                                            return namespace_identity['0']
                                        } else {
                                            return namespace_identity['1']
                                        }
                                    })()));
                                    refval=null;
                                    symbol_name=null;
                                    check_external_env= ( function(){
                                        if (check_true (suppress_check_external_env)){
                                            return false
                                        } else {
                                            return check_external_env_default
                                        }
                                    })();
                                    return   (function(){
                                        if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {
                                            return  parent_environment["get_global"].call(parent_environment,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps,(contained|| contained_req))
                                        } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {
                                            {
                                                if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){
                                                    return  ( function() {
                                                        {
                                                             let __call_target__=children[namespace_identity['0']], __call_method__="get_global";
                                                            return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps)
                                                        } 
                                                    })()
                                                } else {
                                                    {
                                                        throw new EvalError(("namespace "+ namespace_identity['0']+ " doesn't exist"));
                                                        
                                                    }
                                                }
                                            }
                                        } else {
                                            {
                                                refval=Environment.global_ctx.scope[comps['0']];
                                                if (check_true (((undefined===refval)&& (namespace_identity.length===1)&& parent_environment))){
                                                    {
                                                        let rval= parent_environment["get_global"].call(parent_environment,refname,value_if_not_found,suppress_check_external_env,null,comps,(contained|| contained_req));
                                                        ;
                                                        return rval
                                                    }
                                                } else {
                                                    {
                                                        if (check_true (((undefined===refval)&& check_external_env))){
                                                            refval= ( function(){
                                                                if (check_true (check_external_env)){
                                                                    return ( get_outside_global(comps['0'])|| NOT_FOUND)
                                                                } else {
                                                                    return NOT_FOUND
                                                                }
                                                            })()
                                                        };
                                                        return   (function(){
                                                            if (check_true (((NOT_FOUND===refval)&&  not((undefined===value_if_not_found))))) {
                                                                return value_if_not_found
                                                            } else if (check_true ((NOT_FOUND===refval))) {
                                                                {
                                                                    throw new ReferenceError(("symbol not found: "+  ( function(){
                                                                        if (check_true ((namespace_identity.length>1))){
                                                                            return  add(namespace,"/",namespace_identity['1'])
                                                                        } else {
                                                                            return  add(namespace,"/",namespace_identity['0'])
                                                                        }
                                                                    })()));
                                                                    
                                                                }
                                                            } else if (check_true ((comps.length===1))) {
                                                                return refval
                                                            } else if (check_true ((comps.length>1))) {
                                                                {
                                                                    return  resolve_path( rest(comps),refval)
                                                                }
                                                            } else {
                                                                {
                                                                     console.warn("get_global: condition fall through: ",comps);
                                                                    return NOT_FOUND
                                                                }
                                                            }
                                                        } )()
                                                    }
                                                }
                                            }
                                        }
                                    } )()
                                }
                            }
                        } )()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["get_global"]=get_global;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["get_global"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let symbol_definition=async function(symname,target_namespace) {
                        let namespace_identity;
                        namespace_identity=await (async function(){
                            if (check_true (target_namespace)){
                                return await (async function(){
                                    let __array_op_rval__230=target_namespace;
                                     if (__array_op_rval__230 instanceof Function){
                                        return await __array_op_rval__230(symname) 
                                    } else {
                                        return [__array_op_rval__230,symname]
                                    }
                                })()
                            } else {
                                if (check_true ((await length(symname)>2))){
                                    return (symname).split("/")
                                } else {
                                    return await (async function(){
                                        let __array_op_rval__231=symname;
                                         if (__array_op_rval__231 instanceof Function){
                                            return await __array_op_rval__231() 
                                        } else {
                                            return [__array_op_rval__231]
                                        }
                                    })()
                                }
                            }
                        })();
                        return await async function(){
                            if (check_true ((namespace_identity.length===1))) {
                                {
                                    let it;
                                    it=Environment.definitions[symname];
                                    if (check_true (it)){
                                        return it
                                    } else {
                                        if (check_true (parent_environment)){
                                            return await parent_environment["symbol_definition"].call(parent_environment,symname)
                                        }
                                    }
                                }
                            } else if (check_true ((namespace_identity['0']===namespace))) {
                                return Environment.definitions[symname]
                            } else if (check_true (parent_environment)) {
                                return await parent_environment["symbol_definition"].call(parent_environment,namespace_identity['1'],namespace_identity['0'])
                            } else if (check_true ((namespace_identity.length===2))) {
                                return await (async function() {
                                    {
                                         let __call_target__=children[namespace_identity['0']], __call_method__="symbol_definition";
                                        return await __call_target__[__call_method__].call(__call_target__,namespace_identity['1'])
                                    } 
                                })()
                            } else {
                                return undefined
                            }
                        } ()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["symbol_definition"]=symbol_definition;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["symbol_definition"]={
                            core_lang:true,description:("Given a symbol name and an optional namespace, either as a fully qualified path "+ "or via the target_namespace argument, returns definition information about the "+ "retquested symbol.  "+ "Used primarily by the compiler to find metadata for a specific symbol during compilation."),usage:["symname:string","namespace:string"],tags:["compiler","symbols","namespace","search","context","environment"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let compile=async function(json_expression,opts) {
                        let out;
                        opts=await add({
                            env:Environment
                        },opts,{
                            meta:await (async function(){
                                if (check_true ((opts&& opts.meta))){
                                    return true
                                } else {
                                    return false
                                }
                            })()
                        });
                        out=null;
                        out=await (async function(){
                             return await compiler(json_expression,opts) 
                        })();
                        return await async function(){
                            if (check_true (((out instanceof Array)&& out['0'].ctype&& (out['0'].ctype==="FAIL")))) {
                                return out
                            } else if (check_true (opts.meta)) {
                                return out
                            } else {
                                return out['1']
                            }
                        } ()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["compile"]=compile;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["compile"]={
                            core_lang:true,description:("Compiles the given JSON or quoted lisp and returns a string containing "+ "the lisp form or expression as javascript.<br>"+ "If passed the option { meta: true } , an array is returned containing compilation metadata "+ "in element 0 and the compiled code in element 1."),usage:["json_expression:*","opts:object"],tags:["macro","quote","quotes","desym","compiler"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let env_log=await (async function(){
                         return await defclog({
                            prefix:("env"+ id),background:"#B0F0C0"
                        }) 
                    })();
                    ;
                    await async function(){
                        Environment.global_ctx.scope["env_log"]=env_log;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["env_log"]={
                            core_lang:true,description:"The environment logging function used by the environment.",usage:["arg0:*","argN:*"]
                        };
                        return Environment.definitions;
                        
                    }()];
                    let evaluate_local=async function(expression,ctx,opts) {
                        let compiled;
                        let error_data;
                        let requires;
                        let precompiled_assembly;
                        let result;
                        opts=(opts|| new Object());
                        compiled=null;
                        error_data=null;
                        requires=null;
                        precompiled_assembly=null;
                        result=null;
                        if (check_true (opts.compiled_source)){
                            compiled=expression
                        } else {
                            try {
                                compiled=await (async function(){
                                     return await compiler(await (async function(){
                                        if (check_true (opts.json_in)){
                                            return expression
                                        } else {
                                            return await Environment["read_lisp"].call(Environment,expression,{
                                                source_name:opts.source_name
                                            })
                                        }
                                    })(),{
                                        env:Environment,ctx:ctx,formatted_output:true,source_name:opts.source_name,throw_on_error:opts.throw_on_error,on_final_token_assembly:async function(val) {
                                            return precompiled_assembly=val
                                        },error_report:(opts.error_report|| null),quiet_mode:(opts.quiet_mode|| false)
                                    }) 
                                })()
                            } catch (__exception__238) {
                                if (__exception__238 instanceof Error) {
                                    let e=__exception__238;
                                    {
                                        {
                                            if (check_true (opts.throw_on_error)){
                                                {
                                                    throw e;
                                                    
                                                }
                                            };
                                            if (check_true ((e instanceof LispSyntaxError))){
                                                {
                                                    await async function(){
                                                        e["message"]=await JSON.parse(e.message);
                                                        return e;
                                                        
                                                    }()
                                                }
                                            };
                                            await async function(){
                                                if (check_true ((e instanceof LispSyntaxError))) {
                                                    return error_data=await add({
                                                        error:"LispSyntaxError"
                                                    },e.message)
                                                } else {
                                                    error_data={
                                                        error:await sub_type(e),message:e.message,stack:e.stack,form:await (async function(){
                                                             return await async function(){
                                                                if (check_true (((expression instanceof String || typeof expression==='string')&& (expression.length>100)))) {
                                                                    return await add(await expression["substr"].call(expression,0,100),"...")
                                                                } else {
                                                                    return await (await get_global("as_lisp"))(expression)
                                                                }
                                                            } () 
                                                        })(),parent_forms:[],source_name:opts.source_name,invalid:true
                                                    }
                                                }
                                            } ();
                                            if (check_true (opts.error_report)){
                                                await (async function(){
                                                    let __array_op_rval__240=opts.error_report;
                                                     if (__array_op_rval__240 instanceof Function){
                                                        return await __array_op_rval__240(error_data) 
                                                    } else {
                                                        return [__array_op_rval__240,error_data]
                                                    }
                                                })()
                                            } else {
                                                await console.error("Compilation Error: ",error_data)
                                            };
                                            compiled=await (async function(){
                                                 return [{
                                                    error:true
                                                },null] 
                                            })()
                                        }
                                    }
                                }
                            }
                        };
                        return await async function(){
                            if (check_true ((null==compiled))) {
                                return null
                            } else if (check_true ((compiled['0'].ctype==="FAIL"))) {
                                {
                                    if (check_true (opts.error_report)){
                                        {
                                            await (async function(){
                                                let __array_op_rval__241=opts.error_report;
                                                 if (__array_op_rval__241 instanceof Function){
                                                    return await __array_op_rval__241(compiled['1']) 
                                                } else {
                                                    return [__array_op_rval__241,compiled['1']]
                                                }
                                            })()
                                        }
                                    };
                                    return await async function(){
                                        if (check_true ((compiled['1'] instanceof Error))) {
                                            throw compiled['1'];
                                            
                                        } else if (check_true ((compiled['1']['0'] instanceof Error))) {
                                            throw compiled['1']['0'];
                                            
                                        } else if (check_true (((compiled['1']['0'] instanceof Object)&& (compiled['1']['0'].error==="SyntaxError")))) {
                                            {
                                                let new_error=new SyntaxError(compiled['1']['0'].message);
                                                ;
                                                await async function(){
                                                    new_error["from"]=compiled['1']['0'];
                                                    return new_error;
                                                    
                                                }();
                                                throw new_error;
                                                
                                            }
                                        } else {
                                            return compiled['1']
                                        }
                                    } ()
                                }
                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))&& parent_environment))) {
                                return await parent_environment["evaluate_local"].call(parent_environment,compiled,ctx,await add(new Object(),opts,{
                                    compiled_source:true
                                }))
                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))))) {
                                if (check_true (children[compiled['0'].namespace])){
                                    return await (async function() {
                                        {
                                             let __call_target__=children[compiled['0'].namespace], __call_method__="evaluate_local";
                                            return await __call_target__[__call_method__].call(__call_target__,compiled,ctx,await add(new Object(),opts,{
                                                compiled_source:true
                                            }))
                                        } 
                                    })()
                                } else {
                                    throw new EvalError(("unknown namespace "+ compiled['0'].namespace+ " assignment"));
                                    
                                }
                            } else {
                                {
                                    if (check_true (opts.on_compilation_complete)){
                                        await (async function(){
                                            let __array_op_rval__243=opts.on_compilation_complete;
                                             if (__array_op_rval__243 instanceof Function){
                                                return await __array_op_rval__243(compiled) 
                                            } else {
                                                return [__array_op_rval__243,compiled]
                                            }
                                        })()
                                    };
                                    try {
                                        if (check_true (((compiled instanceof Array)&& (compiled['0'] instanceof Object)&& compiled['0'].ctype&& await not((compiled['0'].ctype instanceof String || typeof compiled['0'].ctype==='string'))))){
                                            {
                                                await async function(){
                                                    compiled['0']["ctype"]=await subtype(compiled['0'].ctype);
                                                    return compiled['0'];
                                                    
                                                }()
                                            }
                                        };
                                        result=await (async function(){
                                             return await async function(){
                                                if (check_true (compiled.error)) {
                                                    throw new Error((await get_global("indirect_new"))(compiled.error,compiled.message));
                                                    
                                                } else if (check_true ((compiled['0'].ctype&& (await contains_ques_("block",compiled['0'].ctype)|| (compiled['0'].ctype==="assignment")|| (compiled['0'].ctype==="__!NOT_FOUND!__"))))) {
                                                    if (check_true (await (async function(){
                                                        let __array_op_rval__246=compiled['0'].has_lisp_globals;
                                                         if (__array_op_rval__246 instanceof Function){
                                                            return await __array_op_rval__246() 
                                                        } else {
                                                            return [__array_op_rval__246]
                                                        }
                                                    })())){
                                                        {
                                                            await async function(){
                                                                compiled[1]=new AsyncFunction("Environment",("{ "+ compiled['1']+ "}"));
                                                                return compiled;
                                                                
                                                            }();
                                                            return await (async function(){
                                                                let __array_op_rval__248=compiled['1'];
                                                                 if (__array_op_rval__248 instanceof Function){
                                                                    return await __array_op_rval__248(Environment) 
                                                                } else {
                                                                    return [__array_op_rval__248,Environment]
                                                                }
                                                            })()
                                                        }
                                                    } else {
                                                        {
                                                            await async function(){
                                                                compiled[1]=new AsyncFunction(("{"+ compiled['1']+ "}"));
                                                                return compiled;
                                                                
                                                            }();
                                                            return await (async function(){
                                                                let __array_op_rval__250=compiled['1'];
                                                                 if (__array_op_rval__250 instanceof Function){
                                                                    return await __array_op_rval__250() 
                                                                } else {
                                                                    return [__array_op_rval__250]
                                                                }
                                                            })()
                                                        }
                                                    }
                                                } else if (check_true ((compiled['0'].ctype&& (("AsyncFunction"===compiled['0'].ctype)|| ("statement"===compiled['0'].ctype)|| ("objliteral"===compiled['0'].ctype))))) {
                                                    {
                                                        if (check_true (await (async function(){
                                                            let __array_op_rval__251=compiled['0'].has_lisp_globals;
                                                             if (__array_op_rval__251 instanceof Function){
                                                                return await __array_op_rval__251() 
                                                            } else {
                                                                return [__array_op_rval__251]
                                                            }
                                                        })())){
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new AsyncFunction("Environment",("{ return "+ compiled['1']+ "} "));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__253=compiled['1'];
                                                                     if (__array_op_rval__253 instanceof Function){
                                                                        return await __array_op_rval__253(Environment) 
                                                                    } else {
                                                                        return [__array_op_rval__253,Environment]
                                                                    }
                                                                })()
                                                            }
                                                        } else {
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new AsyncFunction(("{ return "+ compiled['1']+ "}"));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__255=compiled['1'];
                                                                     if (__array_op_rval__255 instanceof Function){
                                                                        return await __array_op_rval__255() 
                                                                    } else {
                                                                        return [__array_op_rval__255]
                                                                    }
                                                                })()
                                                            }
                                                        }
                                                    }
                                                } else if (check_true ((compiled['0'].ctype&& ("Function"===compiled['0'].ctype)))) {
                                                    {
                                                        if (check_true (await (async function(){
                                                            let __array_op_rval__256=compiled['0'].has_lisp_globals;
                                                             if (__array_op_rval__256 instanceof Function){
                                                                return await __array_op_rval__256() 
                                                            } else {
                                                                return [__array_op_rval__256]
                                                            }
                                                        })())){
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new Function("Environment",("{ return "+ compiled['1']+ "} "));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__258=compiled['1'];
                                                                     if (__array_op_rval__258 instanceof Function){
                                                                        return await __array_op_rval__258(Environment) 
                                                                    } else {
                                                                        return [__array_op_rval__258,Environment]
                                                                    }
                                                                })()
                                                            }
                                                        } else {
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new Function(("{ return "+ compiled['1']+ "}"));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__260=compiled['1'];
                                                                     if (__array_op_rval__260 instanceof Function){
                                                                        return await __array_op_rval__260() 
                                                                    } else {
                                                                        return [__array_op_rval__260]
                                                                    }
                                                                })()
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    return compiled['1']
                                                }
                                            } () 
                                        })()
                                    } catch (__exception__244) {
                                        if (__exception__244 instanceof Error) {
                                            let e=__exception__244;
                                            {
                                                {
                                                    if (check_true (true)){
                                                        {
                                                            let details={
                                                                error:e.name,message:e.message,expanded_source:await (await get_global("pretty_print"))(await (async function(){
                                                                     return await (await get_global("detokenize"))(precompiled_assembly) 
                                                                })()),compiled:compiled['1']
                                                            };
                                                            ;
                                                            console.log("Syntax Error: ",details);
                                                            await async function(){
                                                                e["details"]=details;
                                                                return e;
                                                                
                                                            }()
                                                        }
                                                    };
                                                    if (check_true ((opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4)))){
                                                        {
                                                            if (check_true (e.details)){
                                                                await env_log("caught error: ",e.details)
                                                            } else {
                                                                await env_log("caught error: ",e.name,e.message,e)
                                                            }
                                                        }
                                                    };
                                                    if (check_true ((false&& (await sub_type(e)==="SyntaxError")&& (opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4))))){
                                                        await console.log(compiled['1'])
                                                    };
                                                    if (check_true (opts.error_report)){
                                                        {
                                                            await (async function(){
                                                                let __array_op_rval__262=opts.error_report;
                                                                 if (__array_op_rval__262 instanceof Function){
                                                                    return await __array_op_rval__262(await (async function(){
                                                                        if (check_true (e.details)){
                                                                            return e.details
                                                                        } else {
                                                                            return {
                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack
                                                                            }
                                                                        }
                                                                    })()) 
                                                                } else {
                                                                    return [__array_op_rval__262,await (async function(){
                                                                        if (check_true (e.details)){
                                                                            return e.details
                                                                        } else {
                                                                            return {
                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack
                                                                            }
                                                                        }
                                                                    })()]
                                                                }
                                                            })()
                                                        }
                                                    };
                                                    result=e;
                                                    if (check_true ((await not(opts.catch_errors)|| (ctx&& ctx.in_try)))){
                                                        {
                                                            throw result;
                                                            
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                    return result
                                }
                            }
                        } ()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["evaluate_local"]=evaluate_local;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["evaluate_local"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let evaluate=async function(expression,ctx,opts) {
                        return await async function(){
                            if (check_true ((namespace===active_namespace))) {
                                return await evaluate_local(expression,ctx,opts)
                            } else if (check_true ((namespace==="core"))) {
                                return await (async function() {
                                    {
                                         let __call_target__=children[active_namespace], __call_method__="evaluate";
                                        return await __call_target__[__call_method__].call(__call_target__,expression,ctx,opts)
                                    } 
                                })()
                            }
                        } ()
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["evaluate"]=evaluate;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["evaluate"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let eval_struct=async function(lisp_struct,ctx,opts) {
                        let rval;
                        rval=null;
                        if (check_true (lisp_struct instanceof Function)){
                            rval=await (async function(){
                                let __array_op_rval__267=lisp_struct;
                                 if (__array_op_rval__267 instanceof Function){
                                    return await __array_op_rval__267() 
                                } else {
                                    return [__array_op_rval__267]
                                }
                            })()
                        } else {
                            rval=await (async function(){
                                 return await evaluate(lisp_struct,ctx,await add({
                                    json_in:true
                                },(opts|| new Object()))) 
                            })()
                        };
                        return rval
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["eval_struct"]=eval_struct;
                        return Environment.global_ctx.scope;
                        
                    }();
                    [await async function(){
                        Environment.definitions["eval_struct"]={
                            core_lang:true
                        };
                        return Environment.definitions;
                        
                    }()];
                    let built_ins=["MAX_SAFE_INTEGER","LispSyntaxError","sub_type","__VERBOSITY__","int","float","values","pairs","keys","take","prepend","first","last","length","conj","reverse","map","bind","to_object","to_array","slice","rest","second","third","chop","chomp","not","push","pop","list","flatten","jslambda","join","lowercase","uppercase","log","split","split_by","is_object?","is_array?","is_number?","is_function?","is_set?","is_element?","is_string?","is_nil?","is_regex?","is_date?","ends_with?","starts_with?","blank?","contains?","make_set","eval_exp","indirect_new","get_import_entry","range","add","merge_objects","index_of","resolve_path","delete_prop","load_pends","min_value","max_value","interlace","trim","assert","unquotify","or_args","pending_ns_loads","special_operators","defclog","NOT_FOUND","check_external_env_default","built_ins","reader"];
                    ;
                    await async function(){
                        Environment.global_ctx.scope["built_ins"]=built_ins;
                        return Environment.global_ctx.scope;
                        
                    }();
                    let set_compiler=async function(compiler_function) {
                        let new_ops;
                        new_ops=await (async function(){
                            let __array_op_rval__271=compiler_function;
                             if (__array_op_rval__271 instanceof Function){
                                return await __array_op_rval__271([],{
                                    special_operators:true,env:Environment
                                }) 
                            } else {
                                return [__array_op_rval__271,[],{
                                    special_operators:true,env:Environment
                                }]
                            }
                        })();
                        if (check_true (await is_set_ques_(new_ops))){
                            {
                                compiler_operators=new_ops;
                                compiler=compiler_function;
                                await async function(){
                                    Environment.global_ctx.scope["compiler"]=compiler;
                                    return Environment.global_ctx.scope;
                                    
                                }();
                                await (await get_global("register_feature"))("compiler")
                            }
                        } else {
                            {
                                await console.error("Invalid compiler function: invalid operators returned. Not installing.");
                                throw new EvalError("Invalid compiler function");
                                
                            }
                        };
                        return compiler
                    };
                    ;
                    await async function(){
                        Environment.global_ctx.scope["set_compiler"]=set_compiler;
                        return Environment.global_ctx.scope;
                        
                    }();
                    await async function(){
                        Environment.global_ctx.scope["clone"]=async function(val) {
                            if (check_true ((val===Environment))){
                                return Environment
                            } else {
                                return await clone(val,0,Environment)
                            }
                        };
                        return Environment.global_ctx.scope;
                        
                    }();
                    await async function(){
                        Environment["get_global"]=get_global;
                        Environment["set_global"]=set_global;
                        Environment["symbol_definition"]=symbol_definition;
                        Environment["namespace"]=namespace;
                        return Environment;
                        
                    }();
                    let children=(opts.children|| new Object());
                    ;
                    let children_declarations=(opts.children_declarations|| new Object());
                    ;
                    if (check_true ((namespace==="core"))){
                        {
                            if (check_true (await not(Environment.global_ctx.scope["*env_config*"]))){
                                {
                                    await async function(){
                                        Environment.global_ctx.scope["*env_config*"]={
                                            export:{
                                                save_path:"js/juno.js",default_namespace:"core",include_source:false
                                            },features:[],build:DLISP_ENV_VERSION,imports:new Object()
                                        };
                                        return Environment.global_ctx.scope;
                                        
                                    }()
                                }
                            };
                            let current_namespace=function() {
                                return active_namespace
                            };
                            ;
                            let create_namespace=async function(name,options,defer_initialization) {
                                return await async function(){
                                    if (check_true (await not((name instanceof String || typeof name==='string')))) {
                                        throw new TypeError("namespace name must be a string");
                                        
                                    } else if (check_true (children[name])) {
                                        throw new EvalError("namespace already exists");
                                        
                                    } else {
                                        {
                                            let child_env;
                                            options=(options|| new Object());
                                            child_env=await (async function(){
                                                 return await dlisp_env({
                                                    parent_environment:Environment,namespace:name,contained:options.contained,defer_initialization:defer_initialization
                                                }) 
                                            })();
                                            if (check_true (child_env.evaluate)){
                                                {
                                                    await child_env["set_compiler"].call(child_env,compiler);
                                                    await async function(){
                                                        children[name]=child_env;
                                                        return children;
                                                        
                                                    }();
                                                    await async function(){
                                                        children_declarations[name]=new Object();
                                                        return children_declarations;
                                                        
                                                    }();
                                                    await child_env["evaluate_local"].call(child_env,"(for_each (sym built_ins) (delete_prop Environment.context.scope sym))");
                                                    await child_env["evaluate_local"].call(child_env,"(for_each (sym built_ins) (delete_prop Environment.definitions sym))");
                                                    if (check_true (options.contained)){
                                                        await async function(){
                                                            let __target_obj__279=children_declarations[name];
                                                            __target_obj__279["contained"]=true;
                                                            return __target_obj__279;
                                                            
                                                        }()
                                                    };
                                                    await async function(){
                                                        let __target_obj__280=children_declarations[name];
                                                        __target_obj__280["serialize_with_image"]=await (async function(){
                                                            if (check_true ((false===options.serialize_with_image))){
                                                                return false
                                                            } else {
                                                                return true
                                                            }
                                                        })();
                                                        return __target_obj__280;
                                                        
                                                    }();
                                                    return name
                                                }
                                            } else {
                                                {
                                                    await console.error("ENV: couldn't create the child environment. Received: ",child_env);
                                                    throw new EvalError(("unable to create namespace "+ name));
                                                    
                                                }
                                            }
                                        }
                                    }
                                } ()
                            };
                            ;
                            let set_namespace=async function(name) {
                                return await async function(){
                                    if (check_true (await not((name instanceof String || typeof name==='string')))) {
                                        throw new TypeError("namespace name must be a string");
                                        
                                    } else if (check_true ((await not(("core"===name))&& (null==children[name])))) {
                                        throw new EvalError(("namespace "+ name+ " doesn't exist"));
                                        
                                    } else {
                                        {
                                            if (check_true ((name==="core"))){
                                                {
                                                    active_namespace="core"
                                                }
                                            } else {
                                                {
                                                    active_namespace=name
                                                }
                                            };
                                            return name
                                        }
                                    }
                                } ()
                            };
                            ;
                            let delete_namespace=async function(name) {
                                return await async function(){
                                    if (check_true (await not((name instanceof String || typeof name==='string')))) {
                                        throw new TypeError("namespace name must be a string");
                                        
                                    } else if (check_true (("core"===name))) {
                                        throw new EvalError("core namespace cannot be removed");
                                        
                                    } else if (check_true ((null==children[name]))) {
                                        throw new EvalError(("namespace "+ name+ "doesn't exist"));
                                        
                                    } else if (check_true ((name===await current_namespace()))) {
                                        throw new EvalError("namespace is the current namespace");
                                        
                                    } else {
                                        {
                                            await (await get_global("remove_prop"))(children,name);
                                            await (async function() {
                                                let __for_body__283=async function(k) {
                                                    if (check_true (await starts_with_ques_(k,name))){
                                                        {
                                                            return await (await get_global("remove_prop"))(Environment.global_ctx._star_env_config_star_.imports,k)
                                                        }
                                                    }
                                                };
                                                let __array__284=[],__elements__282=(await resolve_path(["global_ctx","scope","*env_config*","imports"],Environment)|| []);
                                                let __BREAK__FLAG__=false;
                                                for(let __iter__281 in __elements__282) {
                                                    __array__284.push(await __for_body__283(__elements__282[__iter__281]));
                                                    if(__BREAK__FLAG__) {
                                                         __array__284.pop();
                                                        break;
                                                        
                                                    }
                                                }return __array__284;
                                                 
                                            })();
                                            return name
                                        }
                                    }
                                } ()
                            };
                            ;
                            await async function(){
                                Environment.global_ctx.scope["create_namespace"]=create_namespace;
                                Environment.global_ctx.scope["set_namespace"]=set_namespace;
                                Environment.global_ctx.scope["delete_namespace"]=delete_namespace;
                                Environment.global_ctx.scope["namespaces"]=function() {
                                    return  add( keys(children),"core")
                                };
                                Environment.global_ctx.scope["current_namespace"]=current_namespace;
                                return Environment.global_ctx.scope;
                                
                            }()
                        }
                    };
                    let get_namespace_handle=function(name) {
                        return   (function(){
                            if (check_true ((namespace===name))) {
                                return Environment
                            } else if (check_true ((namespace==="core"))) {
                                if (check_true (((name instanceof String || typeof name==='string')&& children[name]))){
                                    return children[name]
                                }
                            } else if (check_true (parent_environment)) {
                                return  parent_environment["get_namespace_handle"].call(parent_environment,name)
                            } else {
                                throw new Error("invalid namespace handle requested");
                                
                            }
                        } )()
                    };
                    ;
                    let included_globals=async function() {
                        return {
                            definitions:await (async function(){
                                 return { "MAX_SAFE_INTEGER":{ "core_lang":true
                            },"LispSyntaxError":{ "core_lang":true
                        },"sub_type":{ "core_lang":true,"description":"Returns a string the determined actual type of the provided value.","usage":["value:*"],"tags":["type","class","prototype","typeof","instanceof"]
                    },"__VERBOSITY__":{ "core_lang":true,"description":"Set __VERBOSITY__ to a positive integer for verbose console output of system activity.","tags":["debug","compiler","environment","global"]
                },"int":{ "core_lang":true,"usage":"value:string|number","description":"Convenience method for parseInt, should be used in map vs. directly calling parseInt, which will not work directly","tags":["conversion","number"]
            },"float":{ "core_lang":true,"usage":"value:string|number","description":"Convenience method for parseFloat, should be used in map vs. directly calling parseFloat, which will not work directly","tags":["conversion","number"]
        },"values":{ "core_lang":true,"description":"Given a container, returns a list containing the values of each supplied argument. Note that for objects, only the values are returned, not the keys. If given multiple values, the returned value is a concatentation of all containers provided in the arguments.","usage":["arg0:*","argn:*"],"tags":["array","container","object","keys","elements"]
    },"pairs":{ "core_lang":true,"description":"Given a passed object or array, returns a list containing a 2 element list for each key/value pair of the supplied object.","tags":["array","container","object"],"usage":["obj:object"]
},"keys":{ "core_lang":true,"description":"Given an object, returns the keys of the object.","tags":["object","values","keys","indexes","container"],"usage":["obj:object"]
},"take":{ "core_lang":true,"description":"Takes the first value off the list, and returns the value.","tags":["array","container","mutate","first"],"usage":["place:container"]
},"prepend":{ "core_lang":true,"description":"Places the value argument onto the first of the list (unshift) and returns the list.","tags":["array","mutate","container"],"usage":["place:array","thing:*"]
},"first":{ "core_lang":true,"description":"Given an array, returns the first element in the array.","usage":["x:array"],"tags":["array","container","elements"]
},"last":{ "core_lang":true,"description":"Given an array, returns the last element in the array.","usage":["x:array"],"tags":["array","container","elements","end"]
},"length":{ "core_lang":true,"description":"Returns the length of the supplied type (array, object, set, string, number). If the supplied value is nil or a non-container type, returns 0.","tags":["size","elements","container","dimension","array","set","string","number"],"usage":["thing:container"]
},"conj":{ "core_lang":true,"description":"Conjoins or concatenates things (typically arrays) together and returns an array. Examples:<br>(conj [ 1 2 ] [ 3 4 ]) => [ 1 2 3 4 ]<br>(conj [ 1 2 ] 3 4 ) => [ 1 2 3 4 ]<br>(conj 1 2 [ 3 4 ]) => [ 1 2 3 4 ]<br>(conj { `abc: 123 } [ 2 3]) => [ { abc: 123 }, 2, 3 ]<br>(conj [ 1 2 3 [ 4 ]] [ 5 6 [ 7 ]]) => [ 1 2 3 [ 4 ] 5 6 [ 7 ] ]","tags":["elements","concat","array","conjoin","append"],"usage":["arg0:*","argN:*"]
},"reverse":{ "core_lang":true,"usage":["container:list"],"description":"Returns a copy of the passed list as reversed.  The original is not changed.","tags":["list","sort","order"]
},"map":{ "core_lang":true,"description":"Provided a function as a first argument, map calls the function (item, current_index, total_length) with each element from the second argument, which should be a list. Returns a new list containing the return values resulting from evaluating.","tags":["array","container","elements","iteration"],"usage":["lambda:function","elements:array"]
},"bind":{ "core_lang":true,"description":"Given a function and a this value, the bind function returns a new function that has its this keyword set to the provided value in this_arg.","usage":["func:function","this_arg:*"],"tags":["bind","this","function"]
},"to_object":{ "core_lang":true,"description":"Given an array of pairs in the form of [[key value] [key value] ...], constructs an object with the first array element of the pair as the key and the second element as the value. A single object is returned.","usage":["paired_array:array"],"tags":["conversion","object","array","list","pairs"]
},"to_array":{ "core_lang":true,"description":"Given a container of type Array, Set, Object, or a string, it will convert the members of the container to an array form, and return a new array with the values of the provided container. In the case of an object, the keys and values will be contained in paired arrays in the returned array.  A string will be split into individual characters. If provided a different type other than the listed values above, the value will be placed in an array as a single element.","usage":["container:*"],"tags":["array","conversion","set","object","string","pairs"]
},"slice":{ "core_lang":true,"description":"Given an array, with a starting index and an optional ending index, slice returns a new array containing the elements in the range of provided indices.","usage":["target:array","from:number","to:number"],"tags":["array","slicing","dimensions","subset"]
},"rest":{ "core_lang":true,"description":"Returns a new array containing the elements in the 2nd through last position (the tail) of the provided array.","usage":["x:array"],"tags":["array","subset","slice","tail","end"]
},"second":{ "core_lang":true,"description":"Returns the second element in the provided array (the element at index 1)","tags":["array","subset","element","first"],"usage":["x:array"]
},"third":{ "core_lang":true,"description":"Returns the third element in the provided array (the element at index 2)","tags":["array","subset","element","first"],"usage":["x:array"]
},"chop":{ "core_lang":true,"description":"Returns a new container containing all items except the last item.  This function takes either an array or a string.","usage":["container:array|string"],"tags":["array","slice","subset","first","string"]
},"chomp":{ "core_lang":true,"description":"Given a string returns a new string containing all characters except the last character.","usage":["x:string"],"tags":["slice","subset","string"]
},"not":{ "core_lang":true,"description":"Returns the logical opposite of the given value.  If given a truthy value, a false is returned.  If given a falsey value, true is returned.","usage":["x:*"],"tags":["logic","not","inverse"]
},"push":{ "core_lang":true,"description":"Given an array as a place, and an arbitrary value, appends (pushes) the value to the end of the array.","usage":["place:array","thing:*"],"tags":["array","mutate","append","concat","pop"]
},"pop":{ "core_lang":true,"description":"Given an array as an arguments, removes the last value from the given array and returns it.","usage":["place:array"],"tags":["array","mutate","take","remove","push"]
},"list":{ "description":"Unlike languages like Common-Lisp and other lisps that use proper lists, the Juno language doesn't have a true list type.  All sequential collections are in arrays because the underlying language, Javascript, doesn't have a true list structure.  The list operator here is for backward compatibility with older versions of this language that explicitly used the term as part of a way to construct an array.","usage":["item0:*","item1:*","itemN:*"],"tags":[],"type":"Special"
},"flatten":{ "core_lang":true,"description":"Given a nested array structure, returns a flattened version of the array","usage":["x:array"],"tags":["array","container","flat","tree"]
},"jslambda":{ "core_lang":true,"description":"Proxy for Javascript Function.  Given a set of string based arguments, all but the last are considered arguments to the function to be defined.  The last argument is considered the body of the function and should be provided as a string of javascript. Returns a javascript function. <br>(jslambda (`a `b) \"{ return a+b }\")<br>(jslambda () \"{ return new Date() }\")","usage":["argument_list:array","argn:string"],"tags":["javascript","embed","function"]
},"join":{ "core_lang":true,"description":"Given an optional joining string and an array of strings, returns a string containing the elements of the array interlaced with the optional joining string.<br>(join \",\" [ \"red\" \"fox\" ]) -> \"red,fox\"<br>(join [\"red\" \"fox\"]) -> redfox","tags":["array","combine","split","string","text"],"usage":["joining_string?:string","container:array"]
},"lowercase":{ "core_lang":true,"description":"Given a string, converts all capital characters to lowercase characters.","tags":["string","text","uppercase","case","convert"],"usage":["text:string"]
},"uppercase":{ "core_lang":true,"description":"Given a string, converts all capital characters to uppercase characters.","tags":["string","text","lowercase","case","convert"],"usage":["text:string"]
},"log":{ "core_lang":true,"description":"log is a shorthand call for console.log by default, and serves to provide a base abstraction for logging.  Log behavior can be changed by redefining log to better suit the environmental context.  For example, writing log output to a file or HTML container.","usage":["args0:*","argsN:*"],"tags":["logging","console","output"]
},"split":{ "core_lang":true,"description":"Given a string to partition and a string for a splitting token, return an array whose elements are the text found between each splitting token. <br>(split \"red,fox\" \",\") => [ \"red\" \"fox\" ]","tags":["partition","join","separate","string","array"],"usage":["string_to_split:string","split_token:string"]
},"split_by":{ "core_lang":true,"description":"Given a string for a splitting token and a string to partition, return an array whose elements are the text found between each splitting token. <br>(split_by \",\" \"red,fox\") => [ \"red\" \"fox\" ]","tags":["partition","join","separate","string","array"],"usage":["split_token:string","string_to_split:string"]
},"is_object?":{ "core_lang":true,"description":"for the given value x, returns true if x is an Javascript object type.","usage":["arg:value"],"tags":["type","condition","subtype","value","what"]
},"is_array?":{ "core_lang":true,"description":"for the given value x, returns true if x is an array.","usage":["arg:value"],"tags":["type","condition","subtype","value","what"]
},"is_number?":{ "core_lang":true,"description":"for the given value x, returns true if x is a number.","usage":["arg:value"],"tags":["type","condition","subtype","value","what","function"]
},"is_function?":{ "core_lang":true,"description":"for the given value x, returns true if x is a function.","usage":["arg:value"],"tags":["type","condition","subtype","value","what","function"]
},"is_set?":{ "core_lang":true,"description":"for the given value x, returns true if x is a set.","usage":["arg:value"],"tags":["type","condition","subtype","value","what"]
},"is_element?":{ "core_lang":true,"description":"for the given value x, returns true if x is an Element object","usage":["arg:value"],"tags":["type","condition","subtype","value","what"]
},"is_string?":{ "core_lang":true,"description":"for the given value x, returns true if x is a String object","usage":["arg:value"],"tags":["type","condition","subtype","value","what"]
},"is_nil?":{ "name":"is_nil?","fn_args":"[\"value\"]","description":"for the given value x, returns true if x is exactly equal to nil.","usage":["arg:value"],"tags":["type","condition","subtype","value","what"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"is_regex?":{ "name":"is_regex?","fn_args":"(x)","description":"for the given value x, returns true if x is a Javascript regex object","usage":["arg:value"],"tags":["type","condition","subtype","value","what"],"requires":["sub_type"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"is_date?":{ "name":"is_date?","fn_args":"(x)","description":"for the given value x, returns true if x is a Date object.","usage":["arg:value"],"tags":["type","condition","subtype","value","what"],"requires":["sub_type"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"ends_with?":{ "core_lang":true,"description":"for a given string or array, checks to see if it ends with the given start_value.  Non string args return false.","usage":["end_value:value","collection:array|string"],"tags":["string","text","list","array","filter","reduce"]
},"starts_with?":{ "core_lang":true,"description":"for a given string or array, checks to see if it starts with the given start_value.  Non string args return false.","usage":["start_value:value","collection:array|string"],"tags":["string","text","list","array","filter","reduce","begin"]
},"delete_prop":{ "core_lang":true,"description":"Removes the key or keys of the provided object, and returns the modified object.<br>Example:<br>(defglobal foo { abc: 123 def: 456 ghi: 789 })<br>(delete_prop foo `abc `def) => { ghi: 789 }<br>","usage":["obj:objects","key0:string","keyN?:string"],"tags":["delete","keys","object","remove","remove_prop","mutate"]
},"blank?":{ "core_lang":true,"description":"Given a value, if it is equal (via eq) to nil or to \"\" (an empty string), returns true, otherwise false.","usage":["val:*"],"tags":["string","empty","text"]
},"contains?":{ "core_lang":true,"description":"Given a target value and container value (array, set, or string), checks if the container has the value. If it is found, true is returned, otherwise false if returned.  ","tags":["string","array","set","has","includes","indexOf"],"usage":["value:*","container:array|set|string"]
},"make_set":{ "core_lang":true,"description":"If given an array, a new Set is returned containing the elements of the array. If given an object, a new Set is returned containing the values of the object, and the keys are discarded. If given a set, new Set is created and returend  from the values of the old set.","usage":["vals:array|object|set"],"tags":["array","set","object","values","convert"]
},"meta_for_symbol":{ "core_lang":true,"description":"Given a quoted symbol and a boolean indicating whether or not all namespaces should be searched, returns the meta data associated with the symbol for each environment.  If search mode is requested, the value returned is an array, since there can be symbols with the same name in different environments. If no values are found an empty array is returned.  If not in search mode, meta_for_symbol searches the current namespace only, and if a matching symbol is found, returns an object with all found metadata, otherwise nil is returned.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["describe","meta","help","definition","symbol","metadata"]
},"describe":{ "core_lang":true,"description":"Given a quoted symbol returns the relevant metadata pertinent to the current namespace context.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["meta","help","definition","symbol","metadata","info","meta_for_symbol"]
},"undefine":{ "core_lang":true,"description":"Given a quoted symbol removes the symbol and any definition information from the namespace. If the namespace is fully-qualified, then the symbol will be removed from the specified namespace instead of the currently active namespace. If the symbol is successfully removed, the function will return true, otherwise if it is not found, false will be returned.  Note that if the specified symbol is non-qualified, but exists in a different, accessible namespace, but the symbol isn't present in the current namespace, the symbol will not be deleted.  The environment is not searched and therefore symbols have to be explicitly fully-qualified for any effect of this function outside the current namespace.","usage":["quoted_symbol:string"],"tags":["symbol","delete","remove","unintern","reference","value"]
},"eval_exp":{ "core_lang":true,"description":"Evaluates the given expression and returns the value.","usage":["expression:*"],"tags":["eval","evaluation","expression"]
},"indirect_new":{ "core_lang":true,"description":"Used by the compiler for implementation of the new operator and shouldn't be directly called by user programs.  The new operator should be called instead.","usage":["arg0:*","argsN:*"],"tags":["system","compiler","internal"]
},"range":{ "core_lang":true,"usage":["start_or_end:number","end:number","step:number"],"description":"Range has a variable form depending on the amount of arguments provided to the function when calling it. If provided one argument, range will produce an array from 0 up to, but not including the provided value. If given two arguments, the first argument will be the starging value and the last value will be used as the upper bounding value, returning an array with elements starting at the start value and up to, but not including the bounding value. If given a third value, the value will be interpreted as the step value, and the returned array will contain values that increment by the step amount.  Range will throw an error if a negative range is specified. For negative ranges see neg_range.<br><br>Examples:<br>(range 5) -> [ 0 1 2 3 4 ]<br>(range 10 15) -> [ 10 11 12 13 14 ]<br>(range 10 20) -> [ 10 12 14 16 18 ]<br>(range -5 0) -> [ -5 -4 -3 -2 -1 ]<br>(range -3 3) -> [ -3, -2, -1, 0, 1, 2 ]<br>"
},"add":{ "core_lang":true,"description":"Add is an overloaded function that, based on the first argument provided, determines how to 'add' the arguments. If provided a number as a first argument, then it will assume the rest of the arguments are numbers and add them to the first, returning the numerical sum of the arguments. If an object, it will merge the keys of the provided arguments, returning a combined object.  Be aware that if merging objects, if arguments that have the same keys the argument who appears last with the key will prevail.  If called with an array as a first argument, the subsequent arguments will be added to the first via 'concat'.  If strings, the strings will be joined into a single string and returned.<br>(add 1 2 3) => 6<br>(add { `abc: 123 `def: 345 } { `def: 456 }) => { abc: 123, def: 456 }(add [ 1 2 3 ] [ 4 5 6] 7) => [ 1, 2, 3, [ 4, 5, 6 ], 7 ]<br>(add \"abc\" \"def\") => \"abcdef\"<br><br>Note that add doesn't typically need to explicily called.  The compiler will try and determine the best way to handle adding based on the arguments to be added, so the + operator should be used instead, since it gives the compiler an opportunity to inline if possible.","usage":["arg0:*","argN:*"],"tags":["add","+","sum","number","addition","merge","join","concat"]
},"merge_objects":{ "core_lang":true,"description":"Merge objects takes an array of objects and returns an object whose keys and values are the sum of the provided objects (same behavior as add with objects).  If objects have the same keys, the last element in the array with the duplicate key will be used to provide the value for that key.","usage":["objects:array"],"tags":["add","merge","keys","values","objects","value"]
},"index_of":{ "core_lang":true,"description":"Given a value and an array container, returns the index of the value in the array, or -1 if not found.","usage":["value:number|string|boolean","container:array"],"tags":["find","position","index","array","contains"]
},"resolve_path":{ "core_lang":true,"description":"Given a path and a tree structure, which can be either an array or an object, traverse the tree structure and return the value at the path if it exists, otherwise undefined is returned.<br>(resolve_path [ 2 1 ] [ 1 2 [ 3 4 5 ] 6 7]) => 4)","usage":["path:array","tree_structure:array|object"],"tags":["find","position","index","path","array","tree","contains","set_path"]
},"min_value":{ "name":"min_value","fn_args":"(v)","usage":["values:list"],"description":"Given an array of numbers, returns the smallest value found.  Any non-numbers in the array are ignored.  If there are no numbers in the list, 0 is returned.","requires":["MAX_SAFE_INTEGER","not","sub_type"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"max_value":{ "name":"max_value","fn_args":"(v)","usage":["values:list"],"description":"Given an array of numbers, returns the largest value found.  Any non-numbers in the array are ignored.  If there are no numbers in the list, 0 is returned.","requires":["not","sub_type"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"interlace":{ "core_lang":true,"usage":["list0:array","list1:array","listn?:array"],"description":"Returns a list containing a consecutive values from each list, in argument order.  I.e. list0.0 list1.0 listn.0 list0.1 list1.1 listn.1 ...","tags":["list","array","join","merge"]
},"trim":{ "core_lang":true,"description":"Removes leading and trailing spaces from the provided string value.","usage":["value:string"],"tags":["string","spaces","clean","squeeze","leading","trailing","space"]
},"assert":{ "core_lang":true,"description":"If the evaluated assertion form is true, the result is returned, otherwise an EvalError is thrown with the optionally provided failure message.","usage":["form:*","failure_message:string?"],"tags":["true","error","check","debug","valid","assertion"]
},"unquotify":{ "core_lang":true,"description":"Removes binding symbols and quotes from a supplied value.  For use in compile time function such as macros.","usage":["val:string"],"tags":["macro","quote","quotes","desym"]
},"or_args":{ "core_lang":true,"description":"Provided an array of values, returns true if any of the values are true, otherwise will return false.","usage":["argset:array"],"tags":["or","true","false","array","logic"]
},"special_operators":{ "core_lang":true
},"defclog":{ "core_lang":true,"description":"Given a description object, containing specific keys, returns a customized console logging function implements the given requested properties.<br>Options<br>prefix:string:The prefix to log prior to any supplied user arguments.<br>color:string:The text color to use on the prefix (or initial argument if no prefix)<br>background:string:The background coloe to use on the prefix (or initial argument if no prefix)<br>","usage":["options:object"],"tags":["log","logging","console","utility"]
},"NOT_FOUND":{ "core_lang":true
},"check_external_env_default":{ "core_lang":true
},"*namespace*":{ "core_lang":true
},"pending_ns_loads":{ "core_lang":true
},"pend_load":{ "core_lang":true,"description":"When used as an initializer wrapper via the use_symbols macro, the wrapped initializer will not be loaded until the from_namespace is loaded to ensure that the wrapped initializer won't fail due to not yet loaded dependencies.","usage":["from_namespace:string","target_namespace:string","symbol:string","initializer:array"],"tags":["symbol","definitions","namespace","scope","dependency","dependencies","require"]
},"load_pends":{ "core_lang":true
},"symbols":{ "core_lang":true,"description":"Returns an array of the defined global symbols for the local environment.  If opts.unique is true, only symbols that are not part of the built ins are included.","usage":["opts:object"],"tags":["symbol","names","definitions","values","scope"]
},"set_global":{ "core_lang":true
},"get_global":{ "core_lang":true
},"symbol_definition":{ "core_lang":true,"description":"Given a symbol name and an optional namespace, either as a fully qualified path or via the target_namespace argument, returns definition information about the retquested symbol.  Used primarily by the compiler to find metadata for a specific symbol during compilation.","usage":["symname:string","namespace:string"],"tags":["compiler","symbols","namespace","search","context","environment"]
},"compile":{ "core_lang":true,"description":"Compiles the given JSON or quoted lisp and returns a string containing the lisp form or expression as javascript.<br>If passed the option { meta: true } , an array is returned containing compilation metadata in element 0 and the compiled code in element 1.","usage":["json_expression:*","opts:object"],"tags":["macro","quote","quotes","desym","compiler"]
},"env_log":{ "core_lang":true,"description":"The environment logging function used by the environment.","usage":["arg0:*","argN:*"]
},"evaluate_local":{ "core_lang":true
},"evaluate":{ "core_lang":true
},"eval_struct":{ "core_lang":true
},"+":{ "description":"The plus operator takes an arbitrary number of arguments and attempts to 'add' them together. Of all the mathematical operators, this is the only one that is overloaded in terms of the type of values it can take.  The adding operation undertaken by the + operator is determined by the first argument in the argument list. The operator accepts the following types: <br>numbers, Objects, arrays and Strings.<br> If the argument type is a number (or declared to be a number), then the normal infix mathematical expression will be constructed in the emitted javascript, otherwise the synchronous add function will be used to handle the addition in a dynamic fashion during execution. <br><br>Adding Objects<br>When two objects are added together, a new Object is constructed with the keys and values from each object in successive order from the argument list.  If a later object contains the same key as an earlier object, the later object's value will be used and will overwrite the earlier value of the same key. <br>Example: (+ { abc: 123 def: 456 } { abc: 789 }) -> { abc: 789 def: 456 }<br>If a non-object type is encountered after starting with an object it is ignored.<br><br>Adding Arrays<br>If an array is the first argument to the operator, all subsequent argument values are appended to the first array and the first array is returned as the result.  The types of the subsequent arguments are not interrogated unlike with Object addition, and are simply concatenated to the first argument.  <br>Example: (+ [ 1 2 3 ] [ 4 5 6] 7 8) <-  [ 1 2 3 [ 4 5 6 ] 7 8 ]<br><br>Adding Strings<br>A new string is returned as a result of adding all subsequent arguments together.  If a subsequent argument is a string, or is an object with a toString method defined, it is appended to the result as expected.  Otherwise, the default string representation in the prototype chain will be used, which may not be what is expected.<br>Example: ```(+ \"This is the result: \" (fn (v) (+ 1 2))) <- \"This is the result: async function(v) {\n return (1+ 2)\n}\"```<\nExample: ( + \"1\" \"2\" ) <- \"12\" <br>Example: (+ \"John\" \"Jingleheimer\") <- \"JohnJingleheimer\"<br>Example: (+ \"An object:\" { abc: 123 }) <- \"An object: [object Object]\"<br>","usage":["arg0:*","argN:*"],"tags":["special","add","+","addition","arithmetic"],"type":"Special"
},"-":{ "description":"Subtracts from the first argument all subsequent arguments and returns the result.","usage":["arg0:*","argN:*"],"tags":["special","subtract","-","arithmetic"],"type":"Special"
},"/":{ "description":"Arithmetically divides the first argument (dividend) by all subsequent arguments (divisors) and returns the result.","usage":["dividend:number","argN:number"],"tags":["special","division","divide","arithmetic"],"type":"Special"
},"*":{ "description":"Multiplies the first argument with all subsequent arguments, returning the result.","usage":["arg0:number","argN:number"],"tags":["special","multiplication","arithmetic"],"type":"Special"
},"**":{ "description":"The exponentiation operator raises the first argument to the power of the second argument.","usage":["base:number","exponent:number"],"tags":["special","exponent","base","power","arithmetic"],"type":"Special"
},"%":{ "description":"Modulo (Remainder) divides the first argument by the second argument and returns the remainder from the division operation.","usage":["dividend:number","divisor:number"],"tags":["special","remainder","modulo","division","arithmetic"],"type":"Special"
},"<<":{ "description":"The << operator performs a leftward shift of the bits of the first argument by the amount of the second argument.","usage":["value:number","amount_to_shift_left:number"],"tags":["special","shift","bit","left"],"type":"Special"
},">>":{ "description":"The << operator performs a rightward shift of the bits of the first argument by the amount of the second argument.","usage":["value:number","amount_to_shift_right:number"],"tags":["special","shift","bit","right"],"type":"Special"
},"and":{ "description":"Each argument to the and operator is evaluated, and upon the first value that is a Javascript false (or an equivalent false, such as nil, undefined or 0), the encountered false is returned.  If all values are equivalent to true , then the final argument is returned. Equivalent to && in Javascript.","usage":["arg0:*","argN:*"],"tags":["logic","condition","true","false","&&"],"type":"Special"
},"or":{ "description":"","usage":["arg0:*","argN:*"],"tags":["logic","condition","true","false","||"],"type":"Special"
},"apply":{ "description":"Apply calls the specified function (first argument) with the subsequent arguments.  The last argument must be an array, which contains the remaining arguments. <br>Example: (apply add 1 2 [ 3 4 5]) <- 15<br>","usage":["function_to_call:function","arg0:*","argN:array"],"tags":["function","arguments","array","call"],"type":"Special"
},"call":{ "description":"Given a target object, a function to call, calls the function in the target object with the target object as the this value. The remaining arguments are provided as arguments to the method being called. A synonym for call is the -> operation.The result of the call is returned.","usage":["target:object","function_to_call:text","argsN:*"],"tags":["function","call","->","this","object"],"type":"Special"
},"->":{ "description":"Given a target object, a function to call, calls the function in the target object with the target object as the this value. The remaining arguments are provided as arguments to the method being called. A synonym for -> is the call operation.The result of the call is returned.","usage":["target:object","function_to_call:text","argsN:*"],"tags":["object","function","call","->","this"],"type":"Special"
},"set_prop":{ "description":"Sets a property on the designated place (an object) using the key as the property name and the provided value as the value.The operator returns the object that was modified.","usage":["place:object","key0:string|number","value0:*","keyN:string","valueN:*"],"tags":[],"type":"Special"
},"prop":{ "description":"Returns a property on the designated place (an object) using the key as the property name.  If the key isn't found, undefined is returned.","usage":["place:object","key:string|number"],"tags":[],"type":"Special"
},"=":{ "description":"Sets the target symbol to the provided value and returns the value.   A Reference error is thrown if the symbol is undeclared.","usage":["target:symbol","value:*"],"tags":["assignment","set","value"],"type":"Special"
},"setq":{ "description":"Sets the target symbol to the provided value and returns the value.   A Reference error is thrown if the symbol is undeclared.","usage":["target:symbol","value:*"],"tags":["assignment","set","value"],"type":"Special"
},"==":{ "description":"Represents the Javascript === operator and returns true if the operands are equal and of the same type, otherwise false.","usage":["value0:*","value1:*"],"tags":["equality","equivalence","equal","eq"],"type":"Special"
},"eq":{ "description":"Represents the Javascript == operator and returns true if the operands are \"equal\".  This is a looser definition of equality then ===, and different types can be considered equal if the underlying value is the same.<br>Example: (== 5 \"5\") is considered the same.","usage":["value0:*","value1:*"],"tags":["equality","equivalence","equal","eq"],"type":"Special"
},">":{ "description":"Returns true if the left value is greater than the right value, otherwise returns false.","usage":["value_left:number","value_right:number"],"tags":["equivalence","equal","comparison","gt"],"type":"Special"
},"<":{ "description":"Returns true if the left value is smaller than the right value, otherwise returns false.","usage":["value_left:number","value_right:number"],"tags":["equivalence","equal","comparison","lt"],"type":"Special"
},">=":{ "description":"Returns true if the left value is greater than or equal to the right value, otherwise returns false.","usage":["value_left:number","value_right:number"],"tags":["equivalence","equal","comparison","gt"],"type":"Special"
},"<=":{ "description":"Returns true if the left value is less than or equal to the right value, otherwise returns false.","usage":["value_left:number","value_right:number"],"tags":["equivalence","equal","comparison","gt"],"type":"Special"
},"new":{ "description":"Given a constructor function and arguments, returns an instantiated object of the requested type.","usage":["constructor:function","argN:*"],"tags":["constructor","instantiation","object","class"],"type":"Special"
},"progn":{ "description":["=:+","The block operator evaluates all forms in the order they were provided and returns the last value.","If the block operator is a top level form, then the forms are evaluated as top level forms, in ","which the form is compiled and immediately evaluated. The results of any side effects of the ","compiled form are therefore available to subsequent processing.<br>","The block operator introduces a new lexical scope boundary (in JS the equivalence { } ) such that symbols ","defined locally to the block via defvar will not be visible to blocks above it, only subforms and ","blocks defined within it."],"usage":["form0:*","form1:*","formN:*"],"tags":["block","progn","do","scope"],"type":"Special"
},"do":{ "description":["=:resolve_path",["definitions","progn"],["=:Environment.get_namespace_handle","core"]],"usage":["form0:*","form1:*","formN:*"],"tags":["block","progn","do","scope"],"type":"Special"
},"progl":{ "description":"Like progn, progl is a block operator, but doesn't establish a new scope boundary in the contained forms.It also doesn't return any values, but acts as a means by which to manipulate quoted forms (for example in a macro).","usage":["form0:*","form1:*","formN:*"],"tags":["block","progn","do"],"type":"Special"
},"break":{ "description":"The break operator is a flow control mechanism used to stop the iteration of a for_each or while loop. It should be used as a direct subform of the for_each or while.","usage":[],"tags":["block","flow","control"],"type":"Special"
},"inc":{ "description":"Increment the target symbol by the default value of 1 or the provided amount as a second argument. The operator returns the new value of the target symbol.","usage":["target:symbol","amount:?number"],"tags":["increment","count","dec"],"type":"Special"
},"dec":{ "description":"Decrement the target symbol by the default value of 1 or the provided amount as a second argument. The operator returns the new value of the target symbol.","usage":["target:symbol","amount:?number"],"tags":["decrement","count","inc"],"type":"Special"
},"try":{ "description":"An expression or block surrounded by a try-catch error clause which throws an Error or subclass of Error is checked against all (but at least 1) catch expressions that match the type of error which has been thrown. If the error type is matched by a handler for that type, the catch expression is evaluated. If a handler for the error type or the error's prototype chain isn't found, the exception is rethrown, for potential interception by handlers further up the stack heirarchy.  In the following example, the specific error thrown is caught locally.  If an error was thrown that wasn't specifically Deno.errors.NotFound, the error would be rethrown: ```(try\n   (write_text_file \"/will/not/work.txt\" \"No permissions\")\n   (catch Deno.errors.NotFound (e)\n     (+ \"CAUGHT: type: \" (subtype e) \"MESSAGE: \" e.message)))```<- \"CAUGHT: type:  NotFound MESSAGE:  No such file or directory (os error 2), open '/will/not/work.txt'\"<br>\nAn example of multiple catches for the same try block:```(try\n  (throw Error \"ERROR MESSAGE\")\n  (catch TypeError (e)\n    (progn\n      (log \"Caught TypeError: \" e.message)\n      \"ERROR 1\"))\n  (catch Error (e)\n    (progn\n        (log \"Caught BaseError: \" e.message)\n        \"ERROR 2\")))```<- \"ERROR 2\"<br><br>The try-catch constructs returns the last value of the try block or the return value from a matched catch block, otherwise there is no local return.<br>Example:```(let\n   ((result (try\n              (throw Error \"Invalid!\") ; just throw to demonstrate the catch return\n              (catch Error (e)\n                  e.message))))\n   result)```<- \"Invalid!\"","usage":["expression:*","error-clause0:array","error-clauseN:array"],"tags":["catch","error","throw","flow","control"],"type":"Special"
},"throw":{ "description":"Given a type as a symbol and a message, constructs an object instance of the specified type and then throws the object.  The thrown object should be lexically enclosed in a try-catch form otherwise the unhandled throw may cause an exit of the runtime (dependent on the runtime environment behavior for uncaught objects.<br>See also: try<br>","usage":["type:symbol","message:string"],"tags":["flow","control","error","exceptions","try","catch"],"type":"Special"
},"catch":{ "description":["=:resolve_path",["definitions","try"],["=:Environment.get_namespace_handle","core"]],"usage":["error_type:*","allocation:array","expression:*"],"tags":["flow","control","error","exceptions","try","throw"],"type":"Special"
},"let":{ "description":"Let is the primary means in which to allocate new bindings, and operate on the declared bindings. The binding forms are evaluated sequentially, but the declared symbols are available for all allocation forms, regardless of position in the sequence of binding forms.  Once all the bindings have been evaluated, the expressions are evaluated in an implicit progn block, with the result of the evaluation of the last expression being returned to the caller.  Note that even though a symbol binding may be accessible to all expressions in the allocation forms, the referenced symbol may not be initialized and have a value of undefined, so caution must be taken to not reference values in prior to initialization.  Syntactically, all symbols allocated in let must be defined an initial value, and so the form (let ((a)) (= a 1)) is invalid.<br><br>Example:```(let\n  ((a 2)      ; b, and f are visible at this point but b and f are undefined\n   (f (fn ()  ; when f is called, a and b will be defined and have value\n        (* a b)))\n   (b 21))    ; once b's init form completes b will be set to the value 21\n  (log \"a is: \" a \" b is: \" b)   ; first block expression - all allocatoins complete\n  (f))         ; last block expression, f will be called and return 42```<- 42<br>Note that the above example doesn't contain an optional declaration form, which must come after the allocations and before the block expressions.<br><br>Another consideration when using let is that within the allocation forms, any references to symbols that are lexically scoped outside the let have their values available.  If the contained let re-binds an existing symbol, the new binding will have lexical precedence and the value of the rebound symbol will be determined by the result of the init-form of the allocation.This same rule applies to global values: if a let rebinds a global symbol in an allocation, the symbol referenced in the let scope will be the local value, and not the global.  This is defined as shadowing.<br>Example: ```(let\n  ((a_binding 1))\n  (log \"outer: a_binding: \" a_binding)\n  (let ;; start inner let\n     ((b_binding 2)\n      (a_binding 3))  ;  a is rebound to 3\n     (log \"inner: a_binding: \" a_binding \" b_binding: \" b_binding)\n     a_binding)\n  (log \"outer: a_binding: \" a_binding) ; outer binding again\n  a_binding)\nout: \"outer: a_binding: \" 1 \nout: \"inner: a_binding: \" 2 \"b_binding: \" 3\nout: \"outer: a_binding: \" 1 ```<br>Declarations can be placed after the allocation form and prior to the expressions comprising the block:```(defun handler (options)\n   (let\n      ((validator options.validator)\n       (user_input (request_user_input \"Enter your value\")))\n      (declare (function validator))\n      (validator user_input)))```<br>In the above the declare provides an optimization hint for the compiler.  Without the declare, the compiler would have to insert code that checks at runtime whether or not the options.validator value is a function prior to calling it, resulting in less execution efficiency. ","usage":["allocations:array","declarations:?expression","expression0:*","expressionN:*"],"tags":["compiler","allocation","symbol","initializing","scope","declaration"],"type":"Special"
},"defvar":{ "description":"Define a symbol in the local block scope. The operation doesn't have a return value and a SyntaxError will be thrown by the compiler if the result of a defvar operation is used as part of an assignment form.","usage":["name:symbol","value:*"],"tags":["allocation","define","var","reference","symbol"],"type":"Special"
},"defconst":{ "description":"Define a constant in either the local scope or global scope.  The defconst operator can be used in both subforms and at the toplevel to specify that a symbol value be treated as a constant.  When top-level, the metadata will indicate that the defined symbol is a constant.  Any attempted changes to the value of the symbol will result in a TypeError being thrown.<br>Example:```(defconst ghi \"Unchanging\")\n<- \"Unchanging\"\n\n(= ghi \"Hi there\")\n<- TypeError Assignment to constant variable ghi```<br>","usage":["name:symbol","value:*"],"tags":["allocation","symbol","define","constant","const"],"type":"Special"
},"while":{ "description":"The while operator checks the return value of a test_expression and if the result of the test is true (or a result equivalent to true), it will then evaluate the body expression. If the result is false, then the while loop doesn't evaluate the body_expression and completes.  Once the body expression is evaluated, the test expression will be evaluated again and the cycle will continue, potentially forever, so it is important to be careful to have a means to break out or the execution environment may not ever return.  The body of the while is not a block, so if there are multiple expressions to be evaluated as part of the body expression they must be wrapped in a progn block operator. The break operator can be used to `break out` of the loop in addition to the test expression returning false.<br>There is no return value from a while loop; it should be considered undefined.<br>Example:```(let\n  ((i 10)\n   (count 0))\n  (while (> i 0)\n    (progn\n      (inc count i)\n      (dec i)))\n  ; note: there is no return value from while\n  count)\n<- 55```","usage":["test_expression:*","body_expression:array"],"tags":["flow","control","loop","break","for_each"],"type":"Special"
},"for_each":{ "description":"The for_each operator provides a simple loop variable that allocates a symbol which is assigned the next value in the returned array from the init form in the allocation. It then evaluates the body expression with the symbol in scope.  It will continue to loop, with the allocated symbol being defined successive values until the end of the array is reached, or a (break) operator is encountered in the body expression. Unlike while, the for_each operator is a collector, and all values returned from the body_expression will be returned as an array from for_each.<br>Example:```(for_each (r (range 5))\n     (* r 2))\n<- [0 2 4 6 8]```<br>","usage":["allocation_form","body_expression:array"],"tags":["flow","control","loop","break","while"],"type":"Special"
},"if":{ "description":"The conditional if operator evaluates the provided test form and if the result of the evaluation is true, evaluates and returns the results of the if_true form, otherwise the if form will evaluate and return the result of the if_false form.<br>Example:```(progn\n   (defvar name (request_user_input \"Enter your name:\"))\n   (if (blank? name)\n        \"No Name Entered\"\n        (+ \"Hello \" name)))\n```","usage":["test_form:*","if_true:*","if_false:*"],"tags":["flow","control","condition","logic","cond","branching"],"type":"Special"
},"cond":{ "description":"The cond operator evaluates test expressions sequentially, until either a true value is returned or the end of the test expressions are reached.  If a test expression returns true, the if_true expression following the test expression is evaluated and the result returned.  If no expressions match, then nil is returned.  There is a special keyword available in the cond form, else, which is syntactic sugar for true, that can be used to always have a default value.  The else or true test expression should always be the final test expression otherwise a SyntaxError will result. <br>Example:```(let\n  ((name (request_user_input \"Enter your first name name:\")))\n  (cond\n    (blank? name)  ; first test\n    \"Hello there no-name!\"\n    (< (length name) 12)  ; second test\n    (+ \"Hello there \" name \"!\")\n    else  ; the default\n    (+ \"Hello there \" name \"! Your first name is long.\")))```<br>","usage":["test_expr0:*","if_true_expr0:*","test_expr1:*","if_true_expr1:*","test_exprN:*","if_true_exprN:*"],"tags":["flow","control","condition","logic","if","branching"],"type":"Special"
},"fn":{ "description":"There are multiple types of functions that can be created depending on the requirements of the use case:<br>The lambda and fn operators create asynchronous functions. The fn is shorthand for lambda and can be used interchangably.<br>The function keyword creates a synchronous function. <br>The => operator creates Javascript arrow functions.<br>All definitions return a form which contains the compiled body expression. The provided argument array maps  the symbol names to bound symbols available within the body expression. The body expression is evaluated with the bound symbols containing the values of arguments provided at time the function is called and the result of the body expression is returned from the function call.<br>Typically, the body expression is a progn with multiple forms, however, this is not always necessary if the function being defined can be contained in a single form.  With the exception of arrow functions, functions always establish a new block scope, and any arguments that have the same symbolic names as globals or variables in the closure that defines the function will be shadowed.<br><br>Once defined, the function is stored in compiled form, meaning that if inspected, the javascript that comprises function will be returned as opposed to the source code of the function.<br>There is a special operator for the arguments that can be used to capture all remaining arguments of a function, the quoted &.  If the `& is included in the argument list of a function, all remaining run time values at the index of the `& operator will be returned as part of the symbol following the `& operator.  This symbol should be the last symbol in a argument list.<br>Example of an asynchronous function:```(fn (a b)     ;; a and b are the arguments that are bound\n   (/ (+ a b) 2)) ;; the body expression that acts on the bound arguments a and b```<br><br>Example with the ampersand argument operator used in a synchronous function:```(function (initial `& vals)\n   (/ (+ initial (apply add vals))\n      (+ 1 (length vals))))```<br>In the above example, add was used in the apply because the + operator isn't a true function.<br>Arrow functions do not define their own scope and should be used as anonymous functions within let and scoped blocks.<br>Example:```(let\n  ((i 0)\n   (my_incrementor (=> (v)\n                     (inc i v)))\n   (my_decrementor (=> (v)\n                     (dec i v))))\n  (my_incrementor 4)\n  (my_decrementor 2)\n  i)```<- 2<br><br>","usage":["arguments:array","body_expression:*"],"tags":["function","lambda","fn","call","apply","scope","arrow","lambda"],"type":"Special"
},"function":{ "description":["=:resolve_path",["definitions","fn"],["=:Environment.get_namespace_handle","core"]],"usage":["arguments:array","body_expression:*"],"tags":["function","lambda","fn","call","apply","scope","arrow","lambda"],"type":"Special"
},"=>":{ "description":["=:resolve_path",["definitions","fn"],["=:Environment.get_namespace_handle","core"]],"usage":["arguments:array","body_expression:*"],"tags":["function","lambda","fn","call","apply","scope","arrow","lambda"],"type":"Special"
},"lambda":{ "description":["=:resolve_path",["definitions","fn"],["=:Environment.get_namespace_handle","core"]],"usage":["arguments:array","body_expression:*"],"tags":["function","lambda","fn","call","apply","scope","arrow","lambda"],"type":"Special"
},"defglobal":{ "description":"Defines a global variable in the current namespace, or if preceded by a namespace qualifier, will place the variable in the designated namespace.  The metadata value is an optional object that provides information about the defined symbol for purposes of help, rehydration, and other context.  The metadata object tags are arbitrary, but depending on the type of value being referenced by the symbol, there are some reserved keys that are used by the system itself.<br>Example:```(defglobal *global_var* \"The value of the global.\"\n           { description: \"This is a global in the current namespace\"\n             tags: [ `keywords `for `grouping ] }\n```<br>The key/value pairs attached to a symbol are arbitrary and can be provided for purposes of description or use by users or programatic elements.","usage":["name:symbol","value:*","metadata:object"],"tags":["function","lambda","fn","call","apply","scope","arrow","lambda"],"type":"Special"
},"yield":{ "description":"Note that the yield operator and generator functions aren't official yet and are still requiring development work and testing due to how to structure the emitted code to ensure that the yield is placed within a function* structure vs. a typical function.","usage":["value:*"],"tags":["generator","experimental"],"type":"Special"
},"for_with":{ "description":"The for_with operator provides a simple loop variable that allocates a symbol which is assigned the next value from the iterator function in the init form in the allocation. It then evaluates the body expression with the symbol in scope.  It will continue to loop, with the allocated symbol being defined successive values until the end of the array is reached, or a (break) operator is encountered in the body expression. Unlike for_each, the for_with operator is not a collector, and there is no return value and attempting to assign the return value will not work.<br>Example:```(for_with (next_val (generator instream))\n     (log (-> text_decoder `decode next_val)))\n```<br>","usage":["allocation_form","body_expression:array"],"tags":["iteration","generator","loop","flow","control"],"type":"Special"
},"Environment":{ "description":"The Environment object facilitates the runtime capabilities of the Juno system.","usage":[],"tags":[],"type":"Special","license":"Copyright (c) 2022-2023, Kina, LLC\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
},"defmacro":{ "description":"Defines the provided name as a compile time macro function in the current namespace environment. The parameters in the lambda list are destructured and bound to the provided names which are then available in the macro function.  The forms are used as the basis for the function with the final form expected to return a quoted form which is then as the expansion of the macro by the compiler. The body of forms are explicitly placed in a progn block.  Like with functions and defglobal, if the final argument to defmacro is an object, this will be used for the metadata associated with with the bound symbol provided as name.<br><br>#### Example <br>```(defmacro unless (condition `& forms)\n  `(if (not ,#condition)\n       (progn \n         ,@forms))) ```<br><br><br>In the above example the macro unless is defined.  Passed arguments must be explicitly unquoted or an error may be thrown because the arguments condition and forms *may* not be defined in the final compilation environment.  Note that if the symbols used by the macro are defined in the final compilation scope, that this may cause unexpected behavior due to the form being placed into the compilation tree and then acting on those symbols. <br>Be aware that if a macro being defined returns an object (not an array) you should explicitly add the final metadata form to explictly ensure appropriate interpretation of the argument positions.<br>Since a macro is a function that is defined to operate at compile time vs. run time, the rules of declare apply.  Declaration operate normally and should be the first form in the block, or if using let, the first form after the allocation block of the let. ","usage":["name:symbol","lambda_list:array","forms:array","meta?:object"],"eval_when":{ "compile_time":true
},"tags":["macro","define","compile","function"],"requires":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"read_lisp":{ "requires":["reader"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"desym":{ "eval_when":{ "compile_time":true
},"name":"desym","macro":true,"fn_args":"(val)","description":"Given a value or arrays of values, return the provided symbol in it's literal, quoted form, e.g. (desym myval) => \"myval\"","usage":["val:string|array"],"tags":["symbol","reference","literal","desymbolize","dereference","deref","desym_ref"],"requires":["as_lisp","is_string?","is_array?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"desym_ref":{ "eval_when":{ "compile_time":true
},"name":"desym_ref","macro":true,"fn_args":"(val)","description":["=:+","Given a value will return the a string containing the desymbolized value or values. ","Example: <br>","(defglobal myvar \"foo\")<br>","(defglobal myarr [ (quote myvar) ])<br>","(desym_ref myarr) <- (myvar)<br>","(desym_ref myarr.0) <- myvar<br>","(subtype (desym_ref myarr.0)) <- \"String\""],"usage":["val:*"],"tags":["symbol","reference","syntax","dereference","desym","desym_ref"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"deref":{ "eval_when":{ "compile_time":true
},"name":"deref","macro":true,"fn_args":"(val)","description":["=:+","If the value that the symbol references is a binding value, aka starting with '=:', then return the symbol value ","instead of the value that is referenced by the symbol. This is useful in macros where a value in a form is ","to be used for it's symbolic name vs. it's referenced value, which may be undefined if the symbol being ","de-referenced is not bound to any value. <br>","Example:<br>","Dereference the symbolic value being held in array element 0:<br>","(defglobal myvar \"foo\")<br>","(defglobal myarr [ (quote myvar) ])<br>","(deref my_array.0) => \"my_var\"<br>","(deref my_array) => [ \"=:my_var\" ]<br>","<br>In the last example, the input to deref isn't a string and so it returns the value as is.  See also desym_ref."],"tags":["symbol","reference","syntax","dereference","desym","desym_ref"],"usage":["symbol:string"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"when":{ "eval_when":{ "compile_time":true
},"name":"when","macro":true,"fn_args":"(condition \"&\" mbody)","description":["=:+","Similar to if, but the body forms are evaluated in an implicit progn, if the condition form or expression is true. ","The function when will return the last form value.  There is no evaluation of the body if the conditional expression ","is false."],"usage":["condition:*","body:*"],"tags":["if","condition","logic","true","progn","conditional"],"requires":["slice"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"if_compile_time_defined":{ "eval_when":{ "compile_time":true
},"name":"if_compile_time_defined","macro":true,"fn_args":"(quoted_symbol exists_form not_exists_form)","description":"If the provided quoted symbol is a defined symbol at compilation time, the exists_form will be compiled, otherwise the not_exists_form will be compiled.","tags":["compile","defined","global","symbol","reference"],"usage":["quoted_symbol:string","exists_form:*","not_exists_form:*"],"requires":["describe"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defexternal":{ "eval_when":{ "compile_time":true
},"name":"defexternal","macro":true,"fn_args":"(name value)","description":"Given a name and a value, defexternal will add a globalThis property with the symbol name thereby creating a global variable in the javascript environment.","tags":["global","javascript","globalThis","value"],"usage":["name:string","value:*"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defun":{ "eval_when":{ "compile_time":true
},"name":"defun","macro":true,"fn_args":"(name lambda_list body meta)","description":["=:+","Defines a top level function in the current environment.  Given a name, lambda_list,","body, and a meta data description, builds, compiles and installs the function in the","environment under the provided name.  The body isn't an explicit progn, and must be","within a block structure, such as progn, let or do."],"usage":["name:string:required","lambda_list:array:required","body:array:required","meta:object"],"tags":["function","lambda","define","environment"],"requires":["or_args","length","flatten","destructure_list","decomp_symbol","unquotify","add","as_lisp"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"decomp_symbol":{ "name":"decomp_symbol","fn_args":"(quoted_sym)","requires":["split_by","first","each","describe"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defun_sync":{ "eval_when":{ "compile_time":true
},"name":"defun_sync","macro":true,"fn_args":"(name args body meta)","description":["=:+","Creates a top level synchronous function as opposed to the default via defun, which creates an asynchronous top level function.","Doesn't support destructuring bind in the lambda list (args). ","Given a name, an argument list, a body and symbol metadata, will establish a top level synchronous function.  If the name is ","fully qualified, the function will be compiled in the current namespace (and it's lexical environment) and placed in the ","specified namespace."],"usage":["name:string","args:array","body:*","meta:object"],"tags":["define","function","synchronous","toplevel"],"requires":["add","unquotify","as_lisp"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"macroexpand":{ "name":"macroexpand","fn_args":"(quoted_form)","description":"Given a quoted form, will perform the macro expansion and return the expanded form.","usage":["quoted_form:*"],"tags":["macro","expansion","debug","compile","compilation"],"requires":["current_namespace","first","meta_for_symbol","is_function?","resolve_path"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"macroexpand_all":{ "name":"macroexpand_all","fn_args":"(quoted_form)","description":["=:+","Given a quoted form, will recursively expand all macros in the quoted form ","and return the expanded form structure"],"usage":["quoted_form:*"],"tags":["macro","expansion","debug","compile","compilation"],"requires":["detokenize","tokenize_lisp"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"check_type":{ "eval_when":{ "compile_time":true
},"name":"check_type","macro":true,"fn_args":"(thing type_name error_string)","description":"If the type of thing (ascertained by sub_type) are not of the type type_name, will throw a TypeError with the optional error_string as the error message.","usage":["thing:*","type_name:string","error_string:string"],"tags":["types","validation","type","assert"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"get_object_path":{ "name":"get_object_path","fn_args":"(refname)","description":"get_object_path is used by the compiler to take a string based notation in the form of p[a][b] or p.a.b and returns an array of the components.","tags":["compiler"],"usage":["refname:string"],"requires":["split_by","push","join"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"do_deferred_splice":{ "name":"do_deferred_splice","fn_args":"(tree)","description":"Internally used by the compiler to facilitate splice operations on arrays.","usage":["tree:*"],"tags":["compiler","build"],"requires":["join","is_array?","push","is_object?","pairs"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"define":{ "eval_when":{ "compile_time":true
},"name":"define","macro":true,"fn_args":"[\"&\" defs]","usage":["declaration:array","declaration:array*"],"description":["=:+","Given 1 or more declarations in the form of (symbol value ?metadata), ","creates a symbol in global scope referencing the provided value.  If a ","metadata object is provided, this is stored as a the symbol's metadata."],"tags":["symbol","reference","definition","metadata","environment"],"requires":["slice","push","as_lisp","is_object?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defbinding":{ "eval_when":{ "compile_time":true
},"name":"defbinding","macro":true,"fn_args":"[\"&\" args]","description":["=:+","Defines a global binding to a potentially native function.  This macro ","facilitates the housekeeping by keeping track of the source form ","used (and stored in the environment) so that the save environment ","facility can capture the source bindings and recreate it in the initializer ","function on rehydration.<br>","The macro can take an arbitrary amount of binding arguments, with the form: ","(symbol_name (fn_to_bind_to this))"],"usage":["binding_set0:array","binding_setN:array"],"tags":["toplevel","global","bind","environment","initialize"],"requires":["slice","is_array?","push","*namespace*","is_string?","starts_with?","is_object?","add"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"define_env":{ "eval_when":{ "compile_time":true
},"name":"define_env","macro":true,"fn_args":"[\"&\" defs]","description":["=:+","define_env is a macro used to provide a dual definition on the top level: it creates a symbol via defvar in the ","constructed scope as well as placing a reference to the defined symbol in the scope object."],"usage":["definitions:array"],"tags":["environment","core","build"],"requires":["slice","push","as_lisp","is_object?","add"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"type":{ "name":"type","fn_args":"(x)","usage":["value:*"],"description":"returns the type of value that has been passed.  Deprecated, and the sub_type function should be used.","tags":["types","value","what"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"destructure_list":{ "name":"destructure_list","fn_args":"(elems)","description":"Destructure list takes a nested array and returns the paths of each element in the provided array.","usage":["elems:array"],"tags":["destructuring","path","array","nested","tree"],"requires":["push","is_array?","map","add","is_object?","pairs","is_string?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"destructuring_bind":{ "eval_when":{ "compile_time":true
},"name":"destructuring_bind","macro":true,"fn_args":"(bind_vars expression \"&\" forms)","description":["=:+","The macro destructuring_bind binds the variable symbols specified in bind_vars to the corresponding ","values in the tree structure resulting from the evaluation of the provided expression.  The bound ","variables are then available within the provided forms, which are then evaluated.  Note that ","destructuring_bind only supports destructuring arrays. Destructuring objects is not supported."],"usage":["bind_vars:array","expression:array","forms:*"],"tags":["destructure","array","list","bind","variables","allocation","symbols"],"requires":["slice","random_int","destructure_list","is_array?","starts_with?","push","assert","is_value?","first","resolve_path","add","is_object?","second","join","conj","range","length"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"split_by_recurse":{ "name":"split_by_recurse","fn_args":"(token container)","usage":["token:string","container:string|array"],"description":["=:+","Like split_by, splits the provided container at ","each token, returning an array of the split ","items.  If the container is an array, the function ","will recursively split the strings in the array ","and return an array containing the split values ","of that array.  The final returned array may contain ","strings and arrays."],"tags":["split","nested","recursion","array","string"],"requires":["is_string?","split_by","is_array?","map","split_by_recurse"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defun_sync_ds":{ "eval_when":{ "compile_time":true
},"name":"defun_sync_ds","macro":true,"fn_args":"(name lambda_list body meta)","description":["=:+","Defines a top level function in the current environment.  Given a name, lambda_list,","body, and a meta data description, builds, compiles and installs the function in the","environment under the provided name.  The body isn't an explicit progn, and must be","within a block structure, such as progn, let or do."],"usage":["name:string:required","lambda_list:array:required","body:array:required","meta:object"],"tags":["function","lambda","define","environment"],"requires":["or_args","length","flatten","destructure_list","decomp_symbol","unquotify","add","as_lisp"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"no_await":{ "eval_when":{ "compile_time":true
},"name":"no_await","macro":true,"fn_args":"(form)","description":["=:+","For the provided form in an asynchronous context, forces the compiler flag ","to treat the form as synchronous, thus avoiding an await call.  The return ","value may be impacted and result in a promise being returned ","as opposed to a resolved promise value."],"usage":["no_await:array"],"tags":["compiler","synchronous","await","promise"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"reduce":{ "eval_when":{ "compile_time":true
},"name":"reduce","macro":true,"fn_args":"[(elem item_list) form]","description":["=:+","Provided a first argument as a list which contains a binding variable name and a list, ","returns a list of all non-null return values that result from the evaluation of the second list."],"usage":["allocator:array","forms:*"],"tags":["filter","remove","select","list","array"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"reduce_sync":{ "eval_when":{ "compile_time":true
},"name":"reduce_sync","macro":true,"fn_args":"[(elem item_list) form]","description":"Provided a first argument as a list which contains a binding variable name and a list, returns a list of all non-null return values that result from the evaluation of the second list.","usage":["allocator:array","forms:*"],"tags":["filter","remove","select","list","array"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"bind_function":{ "description":"Reference bind and so has the exact same behavior.  Used for Kina legacy code. See bind description.","requires":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"is_error?":{ "name":"is_error?","fn_args":"(val)","description":"Returns true if the passed value is a instance of an Error type, otherwise returns false.","usage":["val:*"],"tags":["Error","types","predicate","type","instanceof"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"is_reference?":{ "eval_when":{ "compile_time":true
},"name":"is_reference?","macro":true,"fn_args":"(val)","description":["=:+","Returns true if the quoted value is a binding string; in JSON notation this would be a string starting with \"=:\". ","Note that this function doesn't check if the provided value is a defined symbol, but only if it has been ","described in the JSON structure as a bounding string."],"usage":["val:string"],"tags":["reference","JSON","binding","symbol","predicate"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"scan_str":{ "name":"scan_str","fn_args":"(regex search_string)","description":["=:+","Using a provided regex and a search string, performs a regex ","exec using the provided regex argument on the string argument. ","Returns an array of results or an empty array, with matched ","text, index, and any capture groups."],"usage":["regex:RegExp","text:string"],"tags":["regex","string","match","exec","array"],"requires":["is_regex?","not","push","to_object","keys"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"remove_prop":{ "name":"remove_prop","fn_args":"(obj key)","usage":["obj:object","key:*"],"description":["=:+","If the provided key exists, removes the key from the provided object, ","and returns the removed value if the key exists, otherwise returned undefined."],"tags":["object","key","value","mutate","delete_prop","remove"],"requires":["not","delete_prop"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"object_methods":{ "name":"object_methods","fn_args":"(obj)","description":"Given a instantiated object, get all methods (functions) that the object and it's prototype chain contains.","usage":["obj:object"],"tags":["object","methods","functions","introspection","keys"],"requires":["map","is_function?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"expand_dot_accessor":{ "name":"expand_dot_accessor","fn_args":"(val ctx)","description":"Used for compilation. Expands dotted notation of a.b.0.1 to a[\"b\"][0][1]","usage":["val:string","ctx:object"],"tags":["compiler","system"],"requires":["split_by","take","is_object?","contains?","object_methods","not","join","conj","flatten","is_number?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"from_mixed_case":{ "name":"from_mixed_case","fn_args":"(mixed_case_key)","description":["=:+","<br><br>Given a mixed case string, will return the standardized key format ","representation of the string. For example, the string `myVariable` will be ","returned as `my_variable` with this function. A TypeError will be thrown if a ","non-string argument is provided. "],"usage":["mixed_case_key:string"],"tags":["key","convert","snake","mixed","case","format"],"requires":["is_string?","split_by","push","lowercase","join"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"to_mixed_case":{ "name":"to_mixed_case","fn_args":"(snake_case_key)","description":["=:+","<br><br>Given a snake case string, will return a mixed case key format ","representation of the string. For example, the string `my_variable` will be ","returned as `myVariable` with this function. A TypeError will be thrown if a ","non-string argument is provided. "],"usage":["snake_case_key:string"],"tags":["key","convert","snake","mixed","case","format"],"requires":["is_string?","split_by","push","uppercase","join"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"new_ctx":{ "name":"new_ctx","fn_args":"(ctx)","description":"Used for compilation. Given a context structure, provides a utility function for retrieving a context value based on a provided identifier.","usage":["ctx:?object"],"tags":["compiler","system","context","ctx","setf_ctx"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"getf_ctx":{ "name":"getf_ctx","fn_args":"(ctx name _value)","description":"Used for compilation. Given a context structure, provides a utility function for retrieving a context value based on a provided identifier.","usage":["ctx:object","name:string"],"tags":["compiler","system","context","ctx","new_ctx","setf_ctx"],"requires":["is_string?","not","getf_ctx"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"setf_ctx":{ "name":"setf_ctx","fn_args":"(ctx name value)","description":"Used for compilation. Given a context structure, provides a utility function for setting a context place with value.","usage":["ctx:object","name:string","value:*"],"tags":["compiler","system","context","ctx","new_ctx","getf_ctx"],"requires":["getf_ctx"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"set_path":{ "name":"set_path","fn_args":"(path obj value)","description":["=:+","Given a path value as an array, a tree structure, and a value, ","sets the value within the tree at the path value, potentially overriding any existing value at that path.<br><br>","(defglobal foo [ 0 2 [ { `foo: [ 1 4 3 ] `bar: [ 0 1 2 ] } ] 3 ])<br>","(set_path [ 2 0 `bar 1 ] foo 10) => [ 0 10 2 ]<br>","foo => [ 0 2 [ { foo: [ 1 4 3 ] bar: [ 0 10 2 ] } ] 3 ]"],"tags":["resolve_path","make_path","path","set","tree","mutate"],"usage":["path:array","tree:array|object","value:*"],"requires":["pop","resolve_path"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"make_path":{ "name":"make_path","fn_args":"(target_path root_obj value _pos)","description":["=:+","Given a target_path array, a target object and a value to set, ","constructs the path to the object, constructing where ","required.  If the path cannot be made due to a ","non-nil, non-object value encountered at one of ","the path segments, the function will throw a TypeError, ","otherwise it will return the provided value if successful."],"usage":["path:array","root_obj:object","value:*"],"tags":["set_path","path","set","object","resolve_path","mutate"],"requires":["take","push","set_path","resolve_path","is_object?","first","make_path","as_lisp","add"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"minmax":{ "name":"minmax","fn_args":"(container)","usage":["container:array"],"description":"Given an array of numbers returns an array containing the smallest and the largest values found in the provided array. ","tags":["list","number","range","value"],"requires":["MAX_SAFE_INTEGER","is_array?","length","is_number?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"aif":{ "eval_when":{ "compile_time":true
},"name":"aif","macro":true,"fn_args":"(test_expr eval_when_true eval_when_false)","description":["=:+","Anaphoric If - This macro defines a scope in which the symbol `it is used ","to store the evaluation of the test form or expression.  It is then available ","in the eval_when_true form and, if provided, the eval_when_false expression."],"usage":["test_expression:*","eval_when_true:*","eval_when_false:*?"],"tags":["conditional","logic","anaphoric","if","it"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"ifa":{ "eval_when":{ "compile_time":true
},"name":"ifa","macro":true,"fn_args":"(test thenclause elseclause)","description":"Similar to if, the ifa macro is anaphoric in binding, where the it value is defined as the return value of the test form. Use like if, but the it reference is bound within the bodies of the thenclause or elseclause.","usage":["test:*","thenclause:*","elseclause:*"],"tags":["cond","it","if","anaphoric"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"map_range":{ "name":"map_range","fn_args":"(n from_range to_range)","usage":["n:number","from_range:array","to_range:array"],"tags":["range","scale","conversion"],"description":["=:+","Given an initial number n, and two numeric ranges, maps n from the first range ","to the second range, returning the value of n as scaled into the second range. "],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"range_inc":{ "name":"range_inc","fn_args":"(start end step)","description":["=:+","Similar to range, but is end inclusive: [start end] returning an array containing values from start, including end. ","vs. the regular range function that returns [start end).  ","If just 1 argument is provided, the function returns an array starting from 0, up to and including the provided value."],"usage":["start:number","end?:number","step?:number"],"tags":["range","iteration","loop"],"requires":["range","add"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"HSV_to_RGB":{ "name":"HSV_to_RGB","fn_args":"(h s v)","description":["=:+","Given a hue, saturation and brightness, all of which ","should be values between 0 and 1, returns an object ","containing 3 keys: r, g, b, with values between 0 and 255, ","representing the corresponding red, green and blue values ","for the provided hue, saturation and brightness."],"usage":["hue:number","saturation:number","value:number"],"tags":["color","conversion","hue","saturation","brightness","red","green","blue","rgb"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"color_for_number":{ "name":"color_for_number","fn_args":"(num saturation brightness)","usage":["number:number","saturation:float","brightness:float"],"description":"Given an arbitrary integer, a saturation between 0 and 1 and a brightness between 0 and 1, return an RGB color string","tags":["ui","color","view"],"requires":["map_range","HSV_to_RGB"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"flatten_ctx":{ "name":"flatten_ctx","fn_args":"(ctx _var_table)","description":"Internal usage by the compiler, flattens the hierarchical context structure to a single level. Shadowing rules apply.","usage":["ctx_object:object"],"tags":["system","compiler"],"requires":["keys","not","contains?","flatten_ctx"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"identify_symbols":{ "name":"identify_symbols","fn_args":"(quoted_form _state)","requires":["is_array?","push","identify_symbols","is_string?","starts_with?","as_lisp","describe","is_object?","values"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"unless":{ "eval_when":{ "compile_time":true
},"name":"unless","macro":true,"fn_args":"(condition \"&\" forms)","description":"opposite of if, if the condition is false then the forms are evaluated","usage":["condition:array","forms:array"],"tags":["if","not","ifnot","logic","conditional"],"requires":["slice"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"use_quoted_initializer":{ "eval_when":{ "compile_time":true
},"name":"use_quoted_initializer","macro":true,"fn_args":"[\"&\" forms]","description":["=:+","The macro `use_quoted_initializer` preserves the source form in the ","symbol definition object.When the environment is saved, any source forms that ","wish to be preserved through theserialization process should be in the body of ","this macro.  This is a necessity for globalobjects that hold callable ","functions, or functions or structures that require initializers,such as things ","that connect or use environmental resources. "],"usage":["forms:array"],"tags":["compilation","save_env","export","source","use","compiler","compile"],"requires":["slice","is_array?","is_object?","resolve_path","set_path","warn","is_string?","macroexpand"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"but_last":{ "name":"but_last","fn_args":"(arr)","description":["=:+","Given an array, returns all elements except the final element. This ","function is the inverse of `last`. If there are less than 2 elements in the ","array (0 or 1 elements), then an empty array is returned. If a non-array is ","provided, the function will throw a `TypeError`. "],"usage":["arr:array"],"tags":["array","last","elements","front","head","rest"],"requires":["is_array?","slice","sub_type"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"random_int":{ "name":"random_int","fn_args":"[\"&\" \"args\"]","description":["=:+","Returns a random integer between 0 and the argument. ","If two arguments are provided then returns an integer ","between the first argument and the second argument."],"usage":["arg1:number","arg2?:number"],"tags":["rand","number","integer"],"requires":["length","add"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"resolve_multi_path":{ "name":"resolve_multi_path","fn_args":"(path obj not_found)","tags":["path","wildcard","tree","structure"],"usage":["path:array","obj:object","not_found:?*"],"description":["=:+","Given a list containing a path to a value in a nested array, return the value at the given ","path. If the value * is in the path, the path value is a wild card if the passed object ","structure at the path position is a vector or list."],"requires":["is_object?","length","first","not","is_array?","resolve_multi_path","rest","values"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"delete_path":{ "name":"delete_path","fn_args":"(path obj)","description":["=:+","Given a path and an target object, removes the specified value ","at the path and returns the original object, which will have been modified. ","If the value isn't found, there are no modifications to the object and the ","object is returned.  Will throw a TypeError if the obj argument isn't an ","object type, of if the path isn't an array with at least one element."],"usage":["path:array","obj:object"],"tags":["path","delete","remove","object","resolve","modify","value"],"requires":["pop","not","is_array?","is_object?","length","is_value?","delete_prop","resolve_path"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"symbol_tree":{ "name":"symbol_tree","fn_args":"(quoted_form _state _current_path)","description":"Given a quoted form as input, isolates the symbols of the form in a tree structure so dependencies can be seen.","usage":["quoted_form:quote"],"tags":["structure","development","analysis"],"requires":["unquotify","resolve_multi_path","is_array?","push","map","symbol_tree","conj","add","is_string?","starts_with?","is_object?","pairs"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"except_nil":{ "name":"except_nil","fn_args":"[\"items\"]","description":"Takes the passed list or set and returns a new list that doesn't contain any undefined or nil values.  Unlike no_empties, false values and blank strings will pass through.","usage":["items:list|set"],"tags":["filter","nil","undefined","remove","no_empties"],"requires":["not","sub_type","push"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"each":{ "name":"each","fn_args":"(items property)","description":["=:+","Provided a list of items, provide a property name or ","a list of property names to be extracted and returned from the source array as a new list.","If property is an array, and contains values that are arrays, those arrays will be treated as a path."],"usage":["items:list","property:string|list|function|AsyncFunction"],"tags":["pluck","element","only","list","object","property"],"requires":["is_string?","is_number?","except_nil","sub_type","is_array?","push","resolve_path","is_function?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"replace":{ "name":"replace","fn_args":"[\"&\" args]","description":["=:+","Given at least 3 arguments, finds the first  argument, and replaces with the second argument, operating on the third plus argument.  ","This function will act to replace and find values in strings, arrays and objects.  When replacing values in strings, be aware that ","only the first matching value will be replaced.  To replace ALL values in strings, use a RegExp with the `g flag set, such as ","(new RegExp \"Target String\" `g).  For example, the following replaces all target values in the target string:<br>","(replace (new RegExp \"Indiana\" `g) \"Illinois\" \"The address of the location in Indiana has now been changed to 123 Main Street, Townville, Indiana.\")"],"usage":["target:string|regexp","replacement:string|number","container:string|array|object"],"tags":["replace","find","change","edit","string","array","object"],"requires":["slice","push","replace","keys","not","first"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"get_symbol_details_for_ns":{ "name":"get_symbol_details_for_ns","fn_args":"(namespace symbol_name)","description":"Given a namespace and a symbol name returns the details for the specific symbol in the namespace if found, or nil if not.","tags":["namespace","symbol","find","meta","details"],"usage":["namespace:string","symbol_name:string"],"requires":["is_string?","first","push","meta_for_symbol"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"env_encode_string":{ "name":"env_encode_string","fn_args":"(text)","requires":["push"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"cl_encode_string":{ "name":"cl_encode_string","fn_args":"(text)","requires":["is_string?","replace","add","split_by","join"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"fn_signature":{ "name":"fn_signature","fn_args":"(f)","description":["=:+","For a given function as an argument, returns an object with a ","type key containing the function type (async, sync) and an args ","key with an array for the arguments.  Note that a string value which ","is the result of a function serialized with the function's ","toString() method can also be passed."],"usage":["f:function|string"],"tags":["function","signature","arity","inspect"],"requires":["is_function?","is_string?","trim","first","split_by","replace","starts_with?","second","chop","index_of"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"path_to_js_syntax":{ "name":"path_to_js_syntax","fn_args":"(comps)","description":"Used by the compiler, converts an array containing the components of a path to Javascript syntax, which is then returned as a string.","usage":["comps:array"],"tags":["compiler","path","js","javascript"],"requires":["is_array?","join","map","int","starts_with?","sub_type"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"first_is_upper_case?":{ "name":"first_is_upper_case?","fn_args":"(str_val)","description":"Returns true if the first character of the provided string is an uppercase value in the range [A-Z]. ","usage":["str_val:string"],"tags":["string","case","uppercase","capitalized"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"safe_access_2":{ "name":"safe_access_2","fn_args":"(token ctx sanitizer_fn)","requires":["split_by","push","take","join","expand_dot_accessor","flatten"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"safe_access":{ "name":"safe_access","fn_args":"(token ctx sanitizer_fn)","requires":["split_by","push","take","expand_dot_accessor","join","flatten"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"compile_to_js":{ "eval_when":{ "compile_time":true
},"name":"compile_to_js","macro":true,"fn_args":"(quoted_form)","description":["=:+","Given a quoted form, returns an array with two elements, element 0 is the compilation metadata, ","and element 1 is the output Javascript as a string."],"usage":["quoted_form:*"],"tags":["compilation","source","javascript","environment"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"evaluate_compiled_source":{ "eval_when":{ "compile_time":true
},"name":"evaluate_compiled_source","macro":true,"fn_args":"(compiled_source)","description":["=:+","The macro evaluate_compiled_source takes the direct output of the compiler, ","which can be captured using the macro compile_to_js, and performs the ","evaluation of the compiled source, thereby handling the second half of the ","compile then evaluate cycle.  This call will return the results of ","the evaluation of the compiled code assembly."],"usage":["compiled_source:array"],"tags":["compilation","compile","eval","pre-compilation"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"form_structure":{ "name":"form_structure","fn_args":"(quoted_form max_depth)","description":["=:+","Given a form and an optional max_depth positive number, ","traverses the passed JSON form and produces a nested array structure that contains","the contents of the form classified as either a \"symbol\", \"number\", \"string\", \"boolean\", \"array\", \"object\", or the elem itself. ","The returned structure will mirror the passed structure in form, except with the leaf contents ","being replaced with generalized categorizations."],"tags":["validation","compilation","structure"],"usage":["quoted_form:*","max_depth:?number"],"requires":["MAX_SAFE_INTEGER","is_array?","is_object?","map","add","pairs","is_string?","starts_with?","is_number?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"validate_form_structure":{ "name":"validate_form_structure","fn_args":"(validation_rules quoted_form)","description":["=:+","Given a validation rule structure and a quoted form to analyze returns an object with ","two keys, valid and invalid, which are arrays containing the outcome of the rule ","evaluation, a rule_count key containing the total rules passed, and an all_passed key","which will be set to true if all rules passed, otherwise it will fail.","If the rule evaluates successfully, valid is populated with the rule path, ","otherwise the rule path is placed in the invalid array.<br><br>","Rule structure is as follows:<br><code>","[ [path [validation validation ...] \"rule_name\"] [path [validation ...] \"rule_name\"] ]<br>","</code>","where path is an array with the index path and ","validation is a single argument lambda (fn (v) v) that must either ","return true or false. If true, the validation is considered correct, ","false for incorrect.  The result of the rule application will be put in the valid array, ","otherwise the result will be put in invalid."],"tags":["validation","rules","form","structure"],"usage":["validation_rules:array","quoted_form:*"],"requires":["length","is_array?","resolve_path","not","push"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"*compiler_syntax_rules*":{ "requires":["is_array?","not","length","rest"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"tokenize_lisp":{ "name":"tokenize_lisp","fn_args":"(quoted_source)","description":["=:+","Given a quoted source, returns the compilation tokens for the source, prior ","to the actual compilation step. Any functions that are specified as ","compile_time for eval_when, such as macros, will be expanded and the results of ","the expansions will be in the returned token form. "],"usage":["quoted_source:*"],"tags":["compilation","compiler","tokenize","token","tokens","precompiler"],"requires":["current_namespace","compiler"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"detokenize":{ "name":"detokenize","fn_args":"(token)","description":["=:+","Converts the provided compiler tokens to a JSON structure representing ","the original source tree. "],"usage":["token_structure:object|array"],"tags":["compilation","compiler","tokenize","token","tokens","precompiler"],"requires":["is_array?","detokenize","is_object?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"describe_all":{ "name":"describe_all","fn_args":"[]","description":"Returns an object with all defined symbols as the keys and their corresponding descriptions.","usage":[],"tags":["env","environment","symbol","symbols","global","globals"],"requires":["add","to_object","describe","symbols"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"is_value?":{ "name":"is_value?","fn_args":"(val)","description":"Returns true for anything that is not nil or undefined or false.","usage":["val:*"],"tags":["if","value","truthy",false,true],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"sort":{ "name":"sort","fn_args":"(elems options)","description":["=:+","Given an array of elements, and an optional options object, returns a new sorted array.","With no options provided, the elements are sorted in ascending order.  If the key ","reversed is set to true in options, then the elements are reverse sorted. ","<br>","An optional synchronous function can be provided (defined by the comparitor key) which is expected to take ","two values and return the difference between them as can be used by the sort method of ","JS Array.  Additionally a key value can be provided as either a string (separated by dots) or as an array ","which will be used to bind (destructure) the a and b values to be compared to nested values in the elements ","of the array.","<br>","<br>","Options:<br>","reversed:boolean:if true, the elements are reverse sorted.  Note that if a comparitor function is provided, then ","this key cannot be present, as the comparitor should deal with the sorting order.<br>","key:string|array:A path to the comparison values in the provided elements. If a string, it is provided as period ","separated values.  If it is an array, each component of the array is a successive path value in the element to be ","sorted. <br>","comparitor:function:A synchronous function that is to be provided for comparison of two elements.  It should take ","two arguments, and return the difference between the arguments, either a positive or negative."],"usage":["elements:array","options:object?"],"tags":["array","sorting","order","reverse","comparison","objects"],"requires":["is_object?","is_function?","is_string?","assert","is_array?","not","path_to_js_syntax","get_object_path","conj"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"and*":{ "name":"and*","fn_args":"[\"&\" vals]","description":["=:+","Similar to and, but unlike and, values that ","are \"\" (blank) or NaN are considered to be true.","Uses is_value? to determine if the value should be considered to be true.","Returns true if the given arguments all are considered a value, ","otherwise false.  If no arguments are provided, returns undefined."],"usage":["val0:*","val1:*","val2:*"],"tags":["truth","and","logic","truthy"],"requires":["slice","not","is_value?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"or*":{ "name":"or*","fn_args":"[\"&\" vals]","description":["=:+","Similar to or, but unlike or, values that ","are \"\" (blank) or NaN are considered to be true.","Uses is_value? to determine if the value should be considered to be true.","Returns true if the given arguments all are considered a value, ","otherwise false.  If no arguments are provided, returns undefined."],"usage":["val0:*","val1:*","val2:*"],"tags":["truth","or","logic","truthy"],"requires":["slice","is_value?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"either":{ "name":"either","fn_args":"[\"&\" args]","description":["=:+","Similar to or, but unlike or, returns the first non nil ","or undefined value in the argument list whereas or returns ","the first truthy value."],"usage":["values:*"],"tags":["nil","truthy","logic","or","undefined"],"requires":["slice","not"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"sanitize_js_ref_name":{ "name":"sanitize_js_ref_name","fn_args":"(symname)","requires":["not","is_string?","split_by","push","contains?","join"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"is_symbol?":{ "eval_when":{ "compile_time":true
},"name":"is_symbol?","macro":true,"fn_args":"(symbol_to_find)","usage":["symbol:string|*"],"description":["=:+","If provided a quoted symbol, will return true if the symbol can be found ","in the local or global contexts."],"tags":["context","env","def"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defvalue":{ "eval_when":{ "compile_time":true
},"name":"defvalue","macro":true,"fn_args":"(sym value meta)","description":["=:+","If the provided symbol is already defined as an accessible ","global value from the current namespace it will return the ","defined value, otherwise it will define the global in the ","current (implicit) namespace or the explicitly referenced ","namespace.  Returns the newly defined value or previously ","defined value."],"usage":["sym:symbol|string","value:*","meta:?object"],"tags":["allocation","reference","symbol","value","set","reference","global"],"requires":["is_object?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defparameter":{ "eval_when":{ "compile_time":true
},"name":"defparameter","macro":true,"fn_args":"(sym value meta)","description":["=:+","Defines a global that is always reset to the provided value, ","when called or when the image is reloaded, ensuring that the ","initial value is always set to a specific value.  If the value ","is already defined, it will be overwritten.  To set a symbol in ","an explicit namespace, provide a fully qualified symbol name ","in the form of namspace/symname as the symbol to be defined. ","Returns the defined value."],"usage":["sym:symbol|string","value:*","meta:?object"],"tags":["allocation","reference","symbol","value","set","reference","global"],"requires":["is_object?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"get_function_args":{ "name":"get_function_args","fn_args":"(f)","description":"Given a javascript function, return a list of arg names for that function","usage":["function:function"],"tags":["function","introspect","introspection","arguments"],"requires":["scan_str","is_object?","map","ends_with?","chop","split_by","second"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"findpaths":{ "name":"findpaths","fn_args":"(value structure)","requires":["is_array?","map","is_object?","conj","push","pairs"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"warn":{ "description":"Prefixes a warning symbol prior to the arguments to the console.  Otherwise the same as console.log.","usage":["args0:*","argsN:*"],"tags":["log","warning","error","signal","output","notify","defclog"],"initializer":["=:defclog",{ "prefix":"  "
}],"requires":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"success":{ "description":"Prefixes a green checkmark symbol prior to the arguments to the console.  Otherwise the same as console.log.","usage":["args0:*","argsN:*"],"tags":["log","warning","notify","signal","output","ok","success","defclog"],"initializer":["=:defclog",{ "color":"green","prefix":"  "
}],"requires":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"in_background":{ "eval_when":{ "compile_time":true
},"name":"in_background","macro":true,"fn_args":"[\"&\" forms]","description":["=:+","Given a form or forms, evaluates the forms in the background, with ","the function returning true immediately prior to starting the forms."],"usage":["forms:*"],"tags":["eval","background","promise","evaluation"],"requires":["slice"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"set_compiler":{ "name":"set_compiler","fn_args":"(compiler_function)","description":["=:+","Given a compiled compiler function, installs the provided function as the ","environment's compiler, and returns the compiler function."],"usage":["compiler_function:function"],"tags":["compilation","environment","compiler"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"show":{ "name":"show","fn_args":"(thing)","usage":["thing:function"],"description":"Given a name to a compiled function, returns the source of the compiled function.  Otherwise just returns the passed argument.","tags":["compile","source","javascript","js","display"],"requires":["is_function?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"export_symbols":{ "eval_when":{ "compile_time":true
},"name":"export_symbols","macro":true,"fn_args":"[\"&\" args]","usage":["arg0:string|array","argN:string|array"],"description":["=:+","The export_symbols macro facilitates the Javascript module export functionality.  ","To make available defined lisp symbols from the current module the export_symbols ","macro is called with it's arguments being either the direct symbols or, if an ","argument is an array, the first is the defined symbol within the lisp environment ","or current module and the second element in the array is the name to be exported ","as.  For example: <br> ","(export lisp_symbol1 lisp_symbol2) ;; exports lisp_symbol1 and lisp_symbol2 directly. <br>","(export (lisp_symbol1 external_name)) ;; exports lisp_symbol1 as 'external_name`. <br>","(export (initialize default) symbol2) ;; exports initialize as default and symbol2 as itself."],"tags":["env","enviroment","module","export","import","namespace","scope"],"requires":["slice","length","is_array?","push","is_string?","starts_with?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"register_feature":{ "name":"register_feature","fn_args":"(feature)","description":"Adds the provided string to the *env_config* features.  Features are used to mark what functionality is present in the environment.","tags":["environment","modules","libraries","namespaces"],"usage":["feature:string"],"requires":["not","contains?","*env_config*","push"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"uniq":{ "name":"uniq","fn_args":"(values)","description":["=:+","Given a list of values, returns a new list with unique, deduplicated values. ","If the values list contains complex types such as objects or arrays, set the ","handle_complex_types argument to true so they are handled appropriately. "],"usage":["values:list"],"tags":["list","dedup","duplicates","unique","values"],"requires":["map","to_array"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"time_in_millis":{ "eval_when":{ "compile_time":true
},"name":"time_in_millis","macro":true,"fn_args":"[]","usage":[],"tags":["time","milliseconds","number","integer","date"],"description":"Returns the current time in milliseconds as an integer","requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"defns":{ "name":"defns","fn_args":"(name options)","usage":["name:string","options:object"],"description":["=:+","Given a name and an optional options object, creates a new namespace ","identified by the name argument.  If the options object is provided, the following keys are available:","<br>","ignore_if_exists:boolean:If set to true, if the namespace is already defined, do not return an error ","and instead just return with the name of the requested namespace. Any other options are ignored and ","the existing namespace isn't altered.","contained:boolean:If set to true, the newly defined namespace will not have visibility to other namespaces ","beyond 'core' and itself.  Any fully qualified symbols that reference other non-core namespaces will ","fail.","serialize_with_image:boolean:If set to false, if the environment is saved, the namespace will not be ","included in the saved image file.  Default is true."],"tags":["namespace","environment","define","scope","context"],"requires":["is_string?","contains?","namespaces","create_namespace"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"use_ns":{ "eval_when":{ "compile_time":true
},"name":"use_ns","macro":true,"fn_args":"(name)","usage":["name:symbol"],"description":"Sets the current namespace to the provided name.  Returns the name of the new namespace if succesful, otherwise an Eval error is thrown","tags":["namespace","environment","scope","change","set"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"bind_and_call":{ "name":"bind_and_call","fn_args":"(target_object this_object method \"&\" args)","usage":["target_object:object","this_object:object","method:string","args0:*","argsn:*"],"description":"Binds the provided method of the target object with the this_object context, and then calls the object method with the optional provided arguments.","tags":["bind","object","this","context","call"],"requires":["slice","bind"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"clamp":{ "name":"clamp","fn_args":"(value min max)","description":["=:+","Given a numeric value, along with minimum and maximum values for the provided value, ","the function will return the value if between the bounding values, otherwise ","the closest bounding value will be returned.  If the value is above the provided ","maximum, then the maximum will be returned.  If the value is below the minimum, then ","the minimum value is returned."],"tags":["value","number","min","max","bounds","boundary","range"],"usage":["value:number","min:number","max:number"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"save_locally":{ "name":"save_locally","fn_args":"(fname data content_type)","description":["=:+","Provided a filename, a data buffer, and a MIME type, such as \"text/javascript\", ","triggers a browser download of the provided data with the filename.  Depending ","on the browser configuration, the data will be saved to the configured ","user download directory, or prompt the user for a save location. "],"usage":["filename:string","data:*","content_type:string"],"tags":["save","download","browser"],"requires":["document"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"fetch_text":{ "name":"fetch_text","fn_args":"(url)","description":["=:+","Given a url, returns the text content of that url. ","This function is a helper function for the import macro."],"usage":["url:string"],"tags":["fetch","text","string"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"import":{ "eval_when":{ "compile_time":true
},"name":"import","macro":true,"fn_args":"[\"&\" args]","description":["=:+","Dynamically load the contents of the specified source file (including ","path) into the Lisp environment in the current namespace.<br>If the file is a ","Lisp source, it will be evaluated as part of the load and the final result ","returned.<br>If the file is a JS source, it will be loaded into the ","environment and a handle returned. When importing non-Lisp sources (javascript ","or typescript), import requires a binding symbol in an array as the first ","argument.<br>The allowed extensions are `.lisp`, `.js`, `.json`, `.juno`, and ","if the JS platform is Deno, `.ts` is allowed.  Otherwise an `EvalError` will be ","thrown due to a non-handled file type.<br><br>#### Examples - Server ","<br><br>When on a server instance the path can be relative:```(import ","\"tests/compiler_tests.lisp\")```<br><br>For a remote Javascript/Typescript ","resource:```(import (logger) ","\"https://deno.land/std@0.148.0/log/mod.ts\")```<br><br>For a local ","Javascript/Typescript resource:```(import (logger) ","\"/absolute/path/to/library.js\")\n```<br><br>Note that this is a dynamic import. ","<br><br>#### Example - Browser <br><br>With the browser, to import, the ","environment should be hosted for access to served resources:```(import ","\"/pkg/doc_generation.juno\")```<br><br><br> "],"tags":["compile","read","io","file","get","fetch","load","dynamic_import"],"usage":["binding_symbols:array","filename:string"],"requires":["slice","last","contains?","not","starts_with?","ends_with?","length","is_array?","push","current_namespace"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"system_date_format":{ "description":"The system date format structure that is used by the system_date_formatter.If modified, the system_date_formatter, which is a Intl.DateTimeFormat object should be reinitialized by calling (new Intl.DateTimeFormat [] system_date_format).","tags":["time","date","system"],"requires":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"system_date_formatter":{ "initializer":["=:new","=:Intl.DateTimeFormat",[],{ "weekday":"long","year":"numeric","month":"2-digit","day":"2-digit","hour":"numeric","minute":"numeric","second":"numeric","fractionalSecondDigits":3,"hourCycle":"h24","hour12":false,"timeZoneName":"short"
}],"tags":["time","date","system"],"description":"The instantiation of the system_date_format.  See system_date_format for additional information.","requires":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"tzoffset":{ "name":"tzoffset","fn_args":"[]","description":"Returns the number of seconds the local timezone is offset from GMT","usage":[],"tags":["time","date","timezone"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"date_components":{ "name":"date_components","fn_args":"(date_value date_formatter)","usage":["date_value:Date","date_formatter:DateTimeFormat?"],"description":"Given a date value, returns an object containing a the current time information broken down by time component. Optionally pass a Intl.DateTimeFormat object as a second argument.","tags":["date","time","object","component"],"requires":["is_date?","to_object","map","bind_and_call","system_date_formatter"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"formatted_date":{ "name":"formatted_date","fn_args":"(dval date_formatter)","usage":["dval:Date","date_formatter:DateTimeFormat?"],"description":"Given a date object, return a formatted string in the form of: \"yyyy-MM-d HH:mm:ss\".  Optionally pass a Intl.DateTimeFormat object as a second argument.","tags":["date","format","time","string"],"requires":["date_components","join","values"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"*LANGUAGE*":{ "requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"dtext":{ "name":"dtext","fn_args":"(default_text)","usage":["text:string","key:string?"],"description":["=:+","Given a default text string and an optional key, if a key ","exists in the global object *LANGUAGE*, return the text associated with the key. ","If no key is provided, attempts to find the default text as a key in the *LANGUAGE* object. ","If that is a nil entry, returns the default text."],"tags":["text","multi-lingual","language","translation","translate"],"requires":["*LANGUAGE*"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"nth":{ "name":"nth","fn_args":"(idx collection)","description":["=:+","Based on the index or index list passed as the first argument, ","and a collection as a second argument, return the specified values ","from the collection. If an index value is negative, the value ","retrieved will be at the offset starting from the end of the array, ","i.e. -1 will return the last value in the array."],"tags":["filter","select","pluck","object","list","key","array"],"usage":["idx:string|number|array","collection:list|object"],"requires":["is_array?","map","nth","is_number?","length","add"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"max_index":{ "name":"max_index","fn_args":"(container)","description":["=:+","Given a container, typically an Array or derivative, ","return the max index value, calculated as length - 1.<br>"],"usage":["container:array"],"tags":["length","array","container","max","index","range","limit"],"requires":["length"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"decode_text":{ "name":"decode_text","fn_args":"(buffer)","description":"Given a source buffer, such as a Uint8Array, decode into utf-8 text.","usage":["buffer:ArrayBuffer"],"tags":["decode","encode","string","array","text"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"encode_text":{ "name":"encode_text","fn_args":"(text)","description":"Given a source buffer, such as a Uint8Array, decode into utf-8 text.","usage":["buffer:ArrayBuffer"],"tags":["decode","encode","string","array","text"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"hostname":{ "name":"hostname","fn_args":"[]","description":"Returns the hostname of the system the environment is running on.","usage":[],"tags":["hostname","server","environment"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"use_symbols":{ "eval_when":{ "compile_time":true
},"name":"use_symbols","macro":true,"fn_args":"(namespace symbol_list target_namespace)","description":["=:+","Given a namespace and an array of symbols (quoted or unquoted), ","the macro will faciltate the binding of the symbols into the ","current namespace."],"usage":["namespace:string|symbol","symbol_list:array","target_namespace?:string"],"tags":["namespace","binding","import","use","symbols"],"requires":["is_string?","starts_with?","push","current_namespace"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"use_unique_symbols":{ "name":"use_unique_symbols","fn_args":"(namespace)","description":["=:+","This function binds all symbols unique to the provided ","namespace identifier into the current namespace. Returns ","the amount of symbol bound."],"usage":["namespace:string"],"tags":["namespace","binding","import","use","symbols"],"requires":["is_string?","length"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"sort_dependencies":{ "name":"sort_dependencies","fn_args":"[]","description":["=:+","Returns an object containing two keys, `namespaces` and `symbols`, each ","being arrays that contains the needed load order to satisfy the dependencies ","for the current environment with all namespaces. For symbols, the array is ","sorted in terms of dependencies: a symbol appearing with a higher index value ","will mean that it is dependent on symbols at a lower index value, with the ","first symbol having no dependencies, and the final element having the most ","dependencies. For example, if the final symbol in the returned array is to be ","compiled, symbols at a lower index must be defined prior to compiling the final ","symbol.<br>The namespaces reflect the same rule: a lower indexed namespace must ","be loaded prior to a higher indexed namespace. "],"usage":[],"tags":["symbol","symbols","dependencies","requirements","order","compile"],"requires":["index_of","push","decomp_symbol","pairs","conj","not","namespaces","contains?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"symbols_by_namespace":{ "name":"symbols_by_namespace","fn_args":"(options)","description":["=:+","<br><br>By default, when called with no options, the `symbols_by_namespace` ","function returns an object with a key for each namespace, with an array ","containing the symbols (in a string format) defined in that ","namespace.<br>There is an optional `options` object argument which can modify ","the returned results and format.<br><br>#### Options ","<br><br>include_meta:function -If true, will return the meta data associated ","with each symbol from the Environment definitions. The output format is ","changed in this situation: instead of an array being returned, an object with ","the symbol names as keys and the meta data values as their value is returned. "],"usage":["options:object"],"tags":["symbols","namespace"],"requires":["to_object","conj","add","pairs","sub_type","sort","push","uniq","keys","namespaces"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"*formatting_rules*":{ "requires":["flatten","resolve_multi_path","conj","resolve_path"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"all_globals":{ "name":"all_globals","fn_args":"[]","usage":[],"description":"Returns a set of all global symbols, regardless of namespace.","tags":["editor","globals","autocomplete"],"requires":["keys","resolve_path","namespaces"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"process_tree_symbols":{ "name":"process_tree_symbols","fn_args":"(tree prefix _ctx)","usage":["tree:*"],"description":["=:+","Given a JSON structure, such as produced by the reader, returns an object containing the various determined types of the provided structure:<br>","allocations:array - All locally allocated symbols<br>","symbols:array - All identified symbols<br>","keywords:array - All keywords used in the structure","literals:array - All identified literals (i.e. not a symbol)","globals:array - All referenced globals"],"tags":["editor","usage","scope","structure"],"requires":["as_lisp","not","is_array?","process_tree_symbols","contains?","*formatting_rules*","meta_for_symbol","length","is_string?","starts_with?","is_number?","is_function?","is_object?","pairs","to_array"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"keys*":{ "name":"keys*","fn_args":"(obj)","description":["=:+","Like keys, but where keys uses Object.keys, keys* uses the function Object.getOwnpropertynames and returns the ","prototype keys as well."],"usage":["obj:Object"],"tags":["object","array","keys","property","properties","introspection"],"requires":["is_object?","first","push","flatten"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"pairs*":{ "name":"pairs*","fn_args":"(obj)","description":"Like pairs, but where keys uses Object.keys, pairs* returns the key-value pairs prototype heirarchy as well.","usage":["obj:Object"],"tags":["object","array","keys","property","properties","introspection","values"],"requires":["is_object?","keys*"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"for":{ "eval_when":{ "compile_time":true
},"name":"for","macro":true,"fn_args":"[(symbol_list array_ref) \"&\" body_forms]","description":["=:+","The for macro provides a facility for looping through arrays, ","destructuring their contents into local symbols that can be used in a block. ","The `for` macro is a higher level construct than the `for_each` operator, as it ","allows for multiple symbols to be mapped into the contents iteratively, vs. ","for_each allowing only a single symbol to be bound to each top level element in ","the provided array.<br>The symbol_list is provided as the lambda list to a ","`destructuring_bind` if multiple symbols are provided, otherwise, if only a ","single variable is provided, the `for` macro will convert to a for_each call, ","with the `body_forms` enclosed in a `progn` block.<br><br>#### Examples ","<br><br>An example of a multiple bindings is below. The values of `positions` ","are mapped (destructured) into x, y, w and h, respectively, each iteration ","through the loop mapping to the next structured element of the array:```(let\n ","((positions\n      [[[1 2] [5 3]]\n       [[6 3] [10 2]]]))\n  (for ([[x y] [w h]] ","positions)\n       (log \"x,y,w,h=\" x y w h)\n       (+ \"\" x \",\" y \"+\"  w \",\" h ",")))```<br><br>Upon evaluation the log output is as follows:```\"x,y,w,h=\" 1 2 5 ","3```<br>```\"x,y,w,h=\" 6 3 10 2```<br><br>The results returned from the ","call:```[\"1,2+5,3\"\n \"6,3+10,2\"]```<br><br>Notice that the `for` body is wrapped ","in an explicit `progn` such that the last value is accumulated and returned ","from the `for` operation.<br>An example of single bindings, which essentially ","transforms into a `for_each` call with an implicit `progn` around the body ","forms. This form is essentially a convenience call around `for_each`.```(for ","(x [1 2 3])\n     (log \"x is: \" x) \n     (+ x 2))```<br><br>Both the log form ","and the final body form `(+ x 2)` are the body forms and will be evaluated in ","sequence, the final form results accumulating to be returned to the ","caller.<br>Log output from the above:```\"x is: \" 1\n\"x is: \" 2\n\"x is: \" ","3```<br><br>Return value:```[3 4 5]```<br>"],"usage":["allocations_and_values:array","body_forms:*"],"tags":["iteration","loop","for","array","destructuring"],"requires":["slice","is_array?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"word_wrap":{ "name":"word_wrap","fn_args":"(text ncols)","description":["=:+","Given a string of text and an optional column length ","returns an array of lines wrapped at or before the ","column length.  If no column length is provided, ","the default is 80."],"usage":["text:string","ncols:?number"],"tags":["text","string","wrap","format"],"requires":["split_by","length","push","join","add"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"progc":{ "eval_when":{ "compile_time":true
},"name":"progc","macro":true,"fn_args":"[\"&\" forms]","description":["=:+","This macro wraps the provided forms in a ","try-catch, and returns the last value if ","no errors, like progn, or if an error ","occurs, logs to the console.  Simple ","help for debugging."],"tags":["debug","error","catch","handler","progn","eval"],"usage":["forms:*"],"requires":["slice"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"reverse_string":{ "name":"reverse_string","fn_args":"(text)","description":"Given a string, returns the characters in reverse order.","usage":["text:string"],"tags":["string","text","reverse","modify"],"requires":["join","split_by"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"last_n_chars":{ "name":"last_n_chars","fn_args":"(n text)","description":"For a given string, returns the last n characters as a string.","usage":["n:number","text:string"],"tags":["string","text","last","amount","end","tail"],"requires":["is_string?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"last_n":{ "name":"last_n","fn_args":"(n arr)","description":"For a given array, returns the last n elements as an array.","usage":["n:number","arr:array"],"tags":["array","list","text","last","amount","end","tail"],"requires":["is_array?"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"analyze_text_line":{ "name":"analyze_text_line","fn_args":"(line)","description":["=:+","Given a line of text, analyzes the text for form/block openers, identified as ","(,{,[ and their corresponding closers, which correspod to ),},].  It then returns ","an object containing the following: <br><br>","{ delta:int   - a positive or negative integer that is represents the positive or negative depth change, <br>","  final_type: string - the final delimiter character found which can either be an opener or a closer, <br>","  final_pos: int - the position of the final delimiter, <br>","  line: string - the line of text analyzed, <br>","  indent: int - the indentation space count found in the line, <br>","  openers: array - an array of integers representing all column positions of found openers in the line.<br>","  closers: array - an array of integers representing all column positions of found closers in the line. }<br><br>","The function does not count opening and closing tokens if they appear in a string."],"tags":["text","tokens","form","block","formatting","indentation"],"usage":["line:string"],"requires":["not","push","split_by"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"calculate_indent_rule":{ "name":"calculate_indent_rule","fn_args":"(delta movement_needed)","description":["=:+","Given a delta object as returned from analyze_text_line, and an integer representing the ","the amount of tree depth to change, calculates the line indentation required for the ","given delta object, and creates an indent property in the delta object containing ","the given amount of spaces to prepend to the line.  References the *formatting_rules* ","object as needed to determine minor indentation from standard indentation, as well as ","which symbols are identified as keywords.  Returns the provided delta object with the ","indent key added."],"tags":["indentation","text","formatting"],"usage":["delta:object","movement_needed:int"],"requires":["first","not","blank?","push","split_by","contains?","meta_for_symbol","starts_with?","*formatting_rules*","length","built_ins"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"format_lisp_line":{ "name":"format_lisp_line","fn_args":"(line_number get_line)","description":["=:+","Given a line number and an accessor function (synchronous), returns a","a text string representing the computed indentation for the provided ","line number. The get_line function to be provided will be called with ","a single integer argument representing a requested line number from ","the text buffer being analyzed.  The provided get_line function should ","return a string representing the line of text from the buffer containing ","the requested line. Once the string is returned, it is mandatory to update ","the line buffer with the updated indented string, otherwise the function ","will not work properly."],"tags":["formatting","indentation","text","indent"],"usage":["line_number:integer","get_line:function"],"requires":["is_function?","trim","analyze_text_line","calculate_indent_rule","join","range"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"set_default":{ "eval_when":{ "compile_time":true
},"name":"set_default","macro":true,"fn_args":"(path value)","description":["=:+","Given a path to a value in the *env_config* object, and a value to set, creates or sets the value ","at the provided path position.  The path can be in the following forms:<br>","path.to.default_value:symbol - A period delimited non-quoted symbol<br>","[ `path `to `default_value ] - An array with quoted values or strings, in the standard path format.<br>","\"path.to.default_value\" - A string delimited by periods<br>","\"path~to~default_value\" - A string delimited by the path delimiter ~<br>","<br>","The value returned from the macro is the new default value as set in the *env_config*.<br>"],"tags":["default","defaults","set","application","editor","repl"],"usage":["path:symbol|string|array","value:*"],"requires":["is_string?","starts_with?","contains?","split_by","as_lisp"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"get_default":{ "name":"get_default","fn_args":"(key alt_val)","description":["=:+","Given a path (array form) to a key in `*env_config*` , returns the ","value at the path. If the value cannot be found, will return `undefined`. If ","the second argument is provided, `alt_val`, that value will be returned if the ","provided path isn't found. "],"usage":["key:array","alt_val:*"],"tags":["settings","config","defaults","default","environment","env","application"],"requires":["is_array?","resolve_multi_path","*env_config*"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"traverse":{ "name":"traverse","fn_args":"(structure operator_function _path)","description":["=:+","Given a structure such as an object or an array, and an operator ","function argument, the function will recursively call the operator function ","with the value and the path to each value in the structure. The operator ","function can choose to operate on the value at the path by calling `set_path` ","for the root object, or otherwise examine the value and the path. The return ","value of the operator function is ignored. The operator function signature is ","called with `(value path_to_value)` as a signature.<br><br> "],"usage":["structure:object","operator_function:function"],"tags":["recursion","recurse","structure","object","array","search","find"],"requires":["is_array?","map","traverse","conj","is_object?","pairs"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"all_global_functions":{ "name":"all_global_functions","fn_args":"[]","description":"Returns a Set object of all accessible functions in the environment, including all namespaces.","usage":[],"tags":["global","function","scope","environment"],"requires":["is_function?","pairs","namespaces"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"pretty_print":{ "name":"pretty_print","fn_args":"(in_struct report_callout)","description":["=:+","The pretty_print function attempts to format the presented input, provided ","either as a string or JSON. The return is a string with the formatted input."],"tags":["format","pretty","lisp","display","output"],"usage":["input:array|string"],"requires":["is_object?","as_lisp","is_string?","split_by","*formatting_rules*","all_global_functions","push","join","contains?","ends_with?","not","starts_with?","last","last_n","format_lisp_line","range"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"get_dependencies":{ "name":"get_dependencies","fn_args":"(global_symbol _deps _req_ns _externs)","description":["=:+","<br><br>Given a symbol in string form, returns the global dependencies that the ","symbol is dependent on in the runtime environment. The return structure is in ","the form:```{\n  dependencies: []\n  namespaces: []   \n  externals: ","[]\n}```<br><br>The return structure will contain all the qualified and ","non-qualified symbols referenced by the provided target symbol, plus the ","dependencies of the required symbols.<br>The needed namespace environments ","are also returned in the `namespaces` value.\n<br>References to external global ","Javascript values are listed in the `externals` result. These values are ","defined as dependencies for the provided symbol, but are not defined in a Juno ","Environment.<br> "],"usage":["quoted_symbol:string"],"tags":["dependencies","tree","required","dependency"],"requires":["split_by","second","first","current_namespace","not","get_dependencies","to_array"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"pad_left":{ "name":"pad_left","fn_args":"(value pad_amount padchar)","description":["=:+","<br><br>Given a value (number or text). an amount to pad, and an optional ","character to use a padding value, returns a string that will contain pad amount ","leading characters of the padchar value.<br><br>#### Example <br>```(pad_left ","23 5 `0)\n<- \"00023\"\n\n(pad_left 4 5)\n<- \"    4\"```<br> "],"usage":["value:number|string","pad_amount:number","padchar:?string"],"tags":["pad","string","text","left"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"symbol_dependencies":{ "name":"symbol_dependencies","fn_args":"(symbol_array)","description":["=:+","Given an array of symbols in string form, returns the global dependencies that the ","symbols are dependent on in the runtime environment. The return structure is in ","the form:```{\n  dependencies: []\n  namespaces: []\n}```<br><br>The return ","structure will contain all the qualified and non-qualified symbols referenced ","by the provided target symbol, plus the dependencies of the required ","symbols.<br>The needed namespace environments are also returned in the ","namespaces value.<br> "],"usage":["quoted_symbol:array"],"tags":["dependencies","tree","required","dependency"],"requires":["is_array?","get_dependencies","to_array"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"keyword_mapper":{ "name":"keyword_mapper","fn_args":"(token)","requires":["contains?","*formatting_rules*"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"with_each_entry":{ "eval_when":{ "compile_time":true
},"name":"with_each_entry","macro":true,"fn_args":"[(binding_sym) iteration_form \"&\" body_forms]","description":["=:+","Given a binding symbol, a form or symbol that resolves to an iteration ","object with a `next` function, and the body forms to be used with the ","binding_symbol, will call the binding forms for every value in the iterator, ","with the binding symbol being set to the next value each time through the ","loop.<br><br>#### Example <br>```(with_each_value (entries)\n   (-> ","request_headers `entries) ;; will return an iterator\n   (if (== entries.0 ","\"content-type\")\n       (= content_type entries.1)))```<br><br><br> "],"usage":["binding_sym:array","iteration_form:*","body_forms:*"],"tags":["iteration","loop","iterator","entries","flow","values"],"requires":["slice"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"operating_system":{ "name":"operating_system","fn_args":"[]","description":"Returns a text string of the operating system name: darwin, linux, windows","usage":[],"tags":["os","environment","build","platform","env"],"requires":["resolve_path"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"platform_architecture":{ "name":"platform_architecture","fn_args":"[]","description":"Returns a text string of the underlying hardware architecture, for example aarch64 or X86_64.","usage":[],"tags":["os","platform","architecture","hardware","type","build"],"requires":["resolve_path"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"platform":{ "name":"platform","fn_args":"[]","description":"Returns an object with keys for 'target', 'arch', 'os' and 'vendor'.  ","usage":[],"tags":["os","platform","architecture","hardware","type","build"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"exit":{ "name":"exit","fn_args":"(return_code)","description":"Exits the system and returns the provided integer return code","usage":["return_code:?number"],"tags":["exit","quit","return","leave"],"requires":[],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"permissions":{ "name":"permissions","fn_args":"[]","requires":["to_object"],"externals":["Error","SyntaxError","Array","ReferenceError","Set","Object","TypeError","clone","RangeError","Math","parseInt","console","subtype","TextEncoder","TextDecoder","Uint8Array","RegExp","String","isNaN","Function","LispSyntaxError","window","Blob","fetch","EvalError","URL","Intl","Date","Deno"],"source_name":"core.lisp"
},"compiler":{ "requires":["take","is_array?","is_string?","is_function?","get_object_path","is_object?","blank?","delete_prop","scan_str","keys","is_element?","chop","as_lisp","resolve_path","push","split_by","safe_access","expand_dot_accessor","pairs","pop","assert","rest","setf_ctx","prepend","ends_with?","range","join","path_to_js_syntax","get_outside_global","to_array","bind_function","each","read_lisp","warn","make_set","last_n"],"externals":["clone","LispSyntaxError","console","Object","Set","Function","AsyncFunction","Array","Boolean","SyntaxError","TypeError","RegExp","Error","JSON","ReferenceError","EvalError","subtype","String","parseInt","isNaN","globalThis","Math","check_true"],"source_name":"compiler.lisp"
},"set_repl":{ "name":"set_repl","fn_args":"(key value)","description":"Given a configuration key and a value, sets the provided REPL config key to the value.","usage":["key:string","value:*"],"tags":["repl","config"],"requires":["set_path","*env_config*"],"externals":["Deno","TextDecoder","TextEncoder","prompt","JSON","console","Error","LispSyntaxError"],"source_name":"./src/repl.lisp"
},"repl_config":{ "name":"repl_config","fn_args":"[]","description":["=:+","Returns the environment configuration options that are ","available for the repl and their current settings."],"tags":["repl","config"],"usage":[],"requires":["add","resolve_path","*env_config*"],"externals":["Deno","TextDecoder","TextEncoder","prompt","JSON","console","Error","LispSyntaxError"],"source_name":"./src/repl.lisp"
},"$":{ "requires":[],"externals":["Deno","TextDecoder","TextEncoder","prompt","JSON","console","Error","LispSyntaxError"],"source_name":"./src/repl.lisp"
},"$$":{ "requires":[],"externals":["Deno","TextDecoder","TextEncoder","prompt","JSON","console","Error","LispSyntaxError"],"source_name":"./src/repl.lisp"
},"$$$":{ "requires":[],"externals":["Deno","TextDecoder","TextEncoder","prompt","JSON","console","Error","LispSyntaxError"],"source_name":"./src/repl.lisp"
},"if_undefined":{ "eval_when":{ "compile_time":true
},"name":"if_undefined","macro":true,"fn_args":"(value replacer)","description":"If the first value is undefined, return the second value","usage":["value:*","replacer:*"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"str":{ "name":"str","fn_args":"[\"&\" \"args\"]","description":"Joins arguments into a single string separated by spaces and returns a single string.","usage":["arg0:string","argn:string"],"tags":["string","join","text"],"requires":["slice","join"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"COPY_DATA":{ "requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"on_nil":{ "eval_when":{ "compile_time":true
},"name":"on_nil","macro":true,"fn_args":"(nil_form value)","usage":["nil_form:form","value:*"],"description":"If the value argument is not nil or not undefined, return the value, otherwise evaluate the provided nil_form and return the results of the evaluation of the nil_form.","tags":["condition","nil","eval","undefined"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"on_empty":{ "eval_when":{ "compile_time":true
},"name":"on_empty","macro":true,"fn_args":"(on_empty_form value)","usage":["empty_form:form","value:*"],"description":"If the value argument is not an empty array, an empty object, nil or undefined, return the value, otherwise evaluate the provided empty_form and return the results of the evaluation of the empty_form.","tags":["condition","empty","list","array","object","eval","undefined"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"sum":{ "eval_when":{ "compile_time":true
},"name":"sum","macro":true,"fn_args":"(vals)","description":["=:+","Given an array of values, add up the contents of the array in an applied add operation.  ","If these are numbers, they will be added arithmetically.  ","If given strings, they will be joined together (appended). ","If given a first value of an array, all subsequent values will be added into the array. ","If given an array of objects, all the keys/values will be merged and a single object retuned."],"usage":["vals:array"],"tags":["add","join","summation","numbers"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"options_and_args":{ "name":"options_and_args","fn_args":"(arg_array)","usage":["arg_array:array"],"tags":["arguments","options"],"description":["=:+","Given an array of values, returns an array containing two values.  ","If the value at position 0 in the provided array is an non nil object, ","it will be in the position 0 of the returned value and the remaining ","values will be in position 1 of the returned array.","If the value at position 0 in the provided array is not an object type,","the value in position 0 of the returned array will be nil and ","all values will be placed in the returned array in position 1."],"requires":["is_array?","type","slice","null"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"enum":{ "name":"enum","fn_args":"(value_list)","usage":["value_list:array"],"description":"Given a list of string values, returns an object with each value in the list corresponding to a numerical value.","tags":["enumeration","values"],"requires":["assert","is_array?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"gen_id":{ "name":"gen_id","fn_args":"(prefix)","usage":["prefix:string"],"tags":["web","html","identification"],"description":"Given a prefix returns a element safe unique id","requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"macros":{ "name":"macros","fn_args":"[]","usage":[],"description":"Returns the list of currently defined macros.  This function takes no arguments.","tags":["environment","macro","defined"],"requires":["push","pairs"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"pluck":{ "eval_when":{ "compile_time":true
},"name":"pluck","macro":true,"fn_args":"(fields data)","description":"Similar to the 'each' commmand, given the set of desired fields as a first argument, and the data as the second argument, return only the specified fields from the supplied list of data","usage":["fields:string|array","data:array"],"tags":["list","each","filter","only","object"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"objects_from_list":{ "name":"objects_from_list","fn_args":"(key_path objects)","usage":["key_path:string|array","objects:array"],"description":"Given a path (string or array), and an array of object values, the function returns a new object with keys named via the value at the given path, and the object as the value.","tags":["list","object","conversion","transform"],"requires":["is_array?","resolve_path"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"pairs_from_list":{ "name":"pairs_from_list","fn_args":"(value_list size)","usage":["value:list","size?:number"],"description":"Given a list, segment the passed list into sub list (default in pairs) or as otherwise specified in the optional size","tags":["list","pairs","collect"],"requires":["push","length"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"reorder_keys":{ "name":"reorder_keys","fn_args":"(key_list obj)","description":"Given a list of keys, returns a new object that has the keys in the order of the provided key list.","usage":["key_list:array","obj:object"],"tags":["list","object","key","order"],"requires":["keys","nth","to_object","pairs_from_list","interlace"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"only":{ "name":"only","fn_args":"(fields data)","usage":["fields:array","data:array|object"],"description":"Given an array of objects, or a single object, return objects only containing the specified keys and the corresponging value.","tags":["pluck","filter","select","object","each","list","objects","keys"],"requires":["is_array?","map","reorder_keys","is_object?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"sleep":{ "name":"sleep","fn_args":"(seconds)","usage":["seconds:number"],"tags":["time","timing","pause","control"],"description":"Pauses execution for the number of seconds provided to the function.","requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"from_universal_time":{ "name":"from_universal_time","fn_args":"(seconds)","description":"Given a universal_time_value (i.e. seconds from Jan 1 1900) returns a Date object.","usage":["seconds:number"],"tags":["date","time","universal","1900"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"+=":{ "eval_when":{ "compile_time":true
},"name":"+=","macro":true,"fn_args":"(symbol \"&\" args)","usage":["symbol:*","arg0:*","argn?:*"],"description":"Appends in place the arguments to the symbol, adding the values of the arguments to the end.","tags":["append","mutate","text","add","number"],"requires":["slice"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"minmax_index":{ "name":"minmax_index","fn_args":"(container)","usage":["container:array"],"description":"Given an array of numbers returns an array containing the indexes of the smallest and the largest values found in the provided array.","tags":["list","number","range","value","index"],"requires":["MAX_SAFE_INTEGER","is_array?","length","is_number?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"invert_pairs":{ "name":"invert_pairs","fn_args":"(value)","description":"Given an array value containing pairs of value, as in [[1 2] [3 4]], invert the positions to be: [[2 1] [4 3]]","usage":["value:array"],"tags":["array","list","invert","flip","reverse","swap"],"requires":["is_array?","map"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"noop":{ "name":"noop","fn_args":"(val)","usage":["val:*"],"description":"No operation, just returns the value.  To be used as a placeholder operation, such as in apply_operator_list.","tags":["apply","value"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"apply_list_to_list":{ "name":"apply_list_to_list","fn_args":"(operator list1 list2)","usage":["operator:function","modifier_list:array","target_list:array"],"description":["=:+","Given an operator (function), a list of values to be applied (modifier list), and a list of source values (the target), ","returns a new list (array) that contains the result of calling the operator function with ","each value from the target list with the values from the modifier list. The operator function is called ","with <code>(operator source_value modifer_value)</code>."],"tags":["map","list","array","apply","range","index"],"requires":["map","length"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"apply_operator_list":{ "name":"apply_operator_list","fn_args":"(modifier_list target_list)","usage":["operator_list:array","target_list:array"],"description":["=:+","<p>Note: Deprecated.Given a list containing quoted functions (modifier list), and a list of source values (the target), ","returns a new list (array) that contains the result of calling the relative index of the modifier functions with ","the value from the relative index from the target list. The modifiers are applied in the following form: ","<code>(modifier_function target_value)</code>.</p>","<p>If the modifer_list is shorter than the target list, the modifer_list index cycles back to 0 (modulus).</p>"],"tags":["map","list","array","apply","range","index"],"example":["=:quote",["=:apply_operator_list",["first","+"],["John","Smith"]]],"deprecated":true,"requires":["map","length"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"range_overlap?":{ "name":"range_overlap?","fn_args":"(range_a range_b)","description":"Given two ranges in the form of [low_val high_val], returns true if they overlap, otherwise false.  The results are undefined if the range values are not ordered from low to high.","usage":["range_a:array","range_b:array"],"tags":["range","iteration","loop"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"remaining_in_range":{ "name":"remaining_in_range","fn_args":"(value check_range)","usage":["value:number","check_range:array"],"description":"Given a value, and an array containing a start and end value, returns the remaining amount of positions in the given range.  If the value isn't in range, the function will return nil.","tags":["range","iteration","loop"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"form_id":{ "name":"form_id","fn_args":"(name)","usage":["name:string"],"description":"Given a standard string returns a compliant HTML ID suitable for forms.","requires":["replace","join","split","lowercase"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"from_key":{ "name":"from_key","fn_args":"(value sep? ignore?)","usage":["value:string","separator?:string"],"description":["=:+","Takes a key formatted value such as \"last_name\" and returns a \"prettier\" string that contains spaces ","in place of the default separator, '_' and each word's first letter is capitalized. ","An optional separator argument can be provided to use an alternative separator token.<br>E.G. last_name becomes \"Last Name\"."],"tags":["string","split","key","hash","record","form","ui"],"requires":["is_string?","dtext","join","split_by"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"from_key1":{ "name":"from_key1","fn_args":"(v)","description":"Useful for calling with map, since this function prevents the other values being passed as arguments by map from being passed to the from_key function.","tags":["map","function","key","pretty","ui","to_key"],"usage":["value:string"],"requires":["from_key"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"to_key":{ "name":"to_key","fn_args":"(value sep? ignore?)","usage":["value:string","separator?:string"],"description":["=:+","Takes a value such as \"Last Name\" and returns a string that has the spaces removed and the characters replaced ","by the default separator, '_'.  Each word is converted to lowercase characters as well.","An optional separator argument can be provided to use an alternative separator token.<br>E.G. \"Last Name\" becomes \"last_name\"."],"tags":["string","split","key","hash","record","form","ui"],"requires":["is_string?","lowercase","split_by","join"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"is_object_or_function?":{ "requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"extend":{ "name":"extend","fn_args":"(target_object source_object)","description":"Given a target object and a source object, add the keys and values of the source object to the target object.","usage":["target_object:object","source_object:object"],"tags":["object","extension","keys","add","values"],"requires":["is_object?","pairs"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"no_empties":{ "name":"no_empties","fn_args":"[\"items\"]","description":"Takes the passed list or set and returns a new list that doesn't contain any undefined, nil or empty values","usage":["items:list|set"],"tags":["filter","nil","undefined","remove","except_nil"],"requires":["sub_type","not","push"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"first_with":{ "name":"first_with","fn_args":"(prop_list data_value)","usage":["property_list:array","data:object|array"],"description":"Given a list of properties or indexes and a data value, sequentially looks through the property list and returns the first non-null result.","tags":["list","array","index","properties","search","find"],"requires":["not"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"fixed":{ "name":"fixed","fn_args":"(v p)","description":"Given a floating point value and an optional precision value, return a string corresponding to the desired precision.  If precision is left out, defaults to 3.","usage":["value:number","precision?:number"],"tags":["format","conversion"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"hide":{ "name":"hide","fn_args":"(value)","requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"array_to_object":{ "name":"array_to_object","fn_args":"(input_array)","usage":["list_to_process:array"],"tags":["list","array","object","convert"],"description":"Takes the provided list and returns an object with the even indexed items as keys and odd indexed items as values.","requires":["length","take","type","add"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"split_text_in_array":{ "name":"split_text_in_array","fn_args":"(split_element input_array)","usage":["split_element:text","input_array:array"],"tags":["text","string","split","separate","parse"],"description":"Takes the provided array, and split_element, and returns an array of arrays which contain the split text strings of the input list.","requires":["is_string?","push","split","null"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"words_and_quotes":{ "name":"words_and_quotes","fn_args":"(text)","description":"Given a text string, separates the words and quoted words, returning quoted words as their isolated string.","tags":["text","string","split","separate","parse"],"usage":["text:string"],"requires":["not","map","join","no_empties","split_by","trim"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"split_words":{ "name":"split_words","fn_args":"(text_string)","description":"Like words and quotes, splits the text string into words and quoted words, but the unquoted words are split by spaces.  Both the unquoted words and the quoted words inhabit their own array.","usage":["text:string"],"tags":["text","string","split","separate","words","parse"],"requires":["no_empties","map","split_by","trim","words_and_quotes"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"from_style_text":{ "name":"from_style_text","fn_args":"(text)","usage":["text:string"],"description":"Given a string or text in the format of an Element style attribute: \"css_attrib:value; css_attrib2:value\", split into pairs containing attribute name and value.","tags":["text","css","style","pairs","string","array","list","ui","html"],"requires":["no_empties","map","trim","split_by","replace","flatten","words_and_quotes"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"sha1":{ "name":"sha1","fn_args":"(text)","description":"Given a text string as input, returns a SHA-1 hash digest string of the given input.","usage":["text:string"],"tags":["digest","crypto","hash","comparison"],"requires":["is_string?","push","range","join"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"remove_if":{ "name":"remove_if","fn_args":"(f container)","usage":["f:function","container:array"],"tags":["collections","reduce","filter","where","list","array","reduce"],"description":"Given a function with a single argument, if that function returns true, the value will excluded from the returned array.  Opposite of filter.","requires":["not","push"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"filter":{ "name":"filter","fn_args":"(f container)","usage":["f:function","container:array"],"tags":["collections","reduce","reject","where","list","array","reduce"],"description":"Given a function with a single argument, if that function returns true, the value will included in the returned array, otherwise it will not.  Opposite of reject.","requires":["push"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"add_days":{ "name":"add_days","fn_args":"(date_obj num_days)","usage":["date_obj:Date","num_days:number"],"description":"Given a date object and the number of days (either positive or negative) modifies the given date object to the appropriate date value, and returns the date object.","tags":["date","time","duration","days","add"],"requires":["add"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"day_of_week":{ "name":"day_of_week","fn_args":"(dval)","description":"Given a date object, returns the day of the week for that date object","usage":["date:Date"],"tags":["time","week","date","day"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"add_hours":{ "name":"add_hours","fn_args":"(date_obj hours)","usage":["date_obj:Date","hours:number"],"description":"Given a date object and the number of hours (either positive or negative) modifies the given date object to the appropriate date value, and returns the date object.","tags":["date","time","duration","hours","add"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"clear_time":{ "name":"clear_time","fn_args":"(date_obj)","usage":["date_obj:Date"],"description":"Given a date object, modifies the date object by clearing the time value and leaving the date value.  Returns the date object.","tags":["date","time","duration","midnight","add"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"yesterday":{ "name":"yesterday","fn_args":"[]","description":"This function returns an array with two Date values.  The first, in index 0, is the start of the prior day (yesterday midnight), and the second is 24 hours later, i.e. midnight from last night.","usage":[],"tags":["time","date","range","prior","hours","24"],"requires":["clear_time","add_days","add_hours"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"next_sunday":{ "name":"next_sunday","fn_args":"(dval)","usage":["date:Date?"],"description":"Called with no arguments returns a date representing the upcoming sunday at midnight, 12:00 AM.  If given a date, returns the next sunday from the given date.","tags":["time","date","range","next","week","24"],"requires":["clear_time","add_days","day_of_week"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"last_sunday":{ "name":"last_sunday","fn_args":"(dval)","usage":["date:Date?"],"description":"Called with no arguments returns a date representing the prior sunday at midnight, 12:00 AM.  If given a date, returns the prior sunday from the given date.","tags":["time","date","range","prior","week","24"],"requires":["clear_time","add_days","day_of_week"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"day_before_yesterday":{ "name":"day_before_yesterday","fn_args":"[]","description":"This function returns an array with two Date values.  The first, in index 0, is the start of the day before yesterday (midnight), and the second is 24 later.","usage":[],"tags":["time","date","range","prior","hours","24"],"requires":["clear_time","add_days"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"last_week":{ "name":"last_week","fn_args":"[]","description":"This function returns an array with two Date values.  The first, in index 0, is the start of the prior week at midnight, and the second is 7 days later, at midnight.","usage":[],"tags":["time","date","range","prior","hours","24"],"requires":["clear_time","add_days","next_sunday","last_sunday"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"midnight-to-midnight":{ "name":"midnight-to-midnight","fn_args":"(dval)","description":"This function returns an array with two Date values.  The first, in index 0, is the start of the prior day (yesterday midnight), and the second is 24 hours later, i.e. midnight from last night.","usage":["val:Date"],"tags":["time","date","range","prior","hours","24"],"requires":["clear_time","add_hours"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"date_to_string":{ "name":"date_to_string","fn_args":"(date_val str_layout)","description":["=:+","Given a date value and a formatted template string, return a string representation of the date based on the formatted template string.","<br>","E.g. (date_to_string (new Date) \"yyyy-MM-dd HH:mm:ss\")<br>","<table>","<tr><td>","yyyy","</td><td>","Four position formatted year, e.g. 2021","</td></tr>","<tr><td>","yy","</td><td>","Two position formatted year, e.g. 21","</td></tr>","<tr><td>","dd","</td><td>","Two position formatted day of month, e.g. 03","</td></tr>","<tr><td>","d","</td><td>","1 position numeric day of month, e.g. 3","</td></tr>","<tr><td>","MM","</td><td>","Two position formatted month number, e.g. 06","</td></tr>","<tr><td>","M","</td><td>","One or two position formatted month number, e.g. 6 or 10","</td></tr>","<tr><td>","HH","</td><td>","Two position formatted 24 hour number, e.g. 08","</td></tr>","<tr><td>","H","</td><td>","One position formatted 24 hour, e.g 8","</td></tr>","<tr><td>","hh","</td><td>","Two position formatted 12 hour clock, e.g. 08","</td></tr>","<tr><td>","h","</td><td>","One position formatted 12 hour clock, e.g 8","</td></tr>","<tr><td>","mm","</td><td>","Minutes with 2 position width, eg. 05","</td></tr>","<tr><td>","m","</td><td>","Minutes with 1 or 2 positions, e.g 5 or 15.","</td></tr>","<tr><td>","ss","</td><td>","Seconds with 2 positions, e.g 03 or 25.","</td></tr>","<tr><td>","s","</td><td>","Seconds with 1 or 2 positions, e.g 3 or 25.","</td></tr>","<tr><td>","sss","</td><td>","Milliseconds with 3 digits, such as 092 or 562.","</td></tr>","<tr><td>","TZ","</td><td>","Include timezone abbreviated, e.g. GMT+1.","</td></tr>","<tr><td>","D","</td><td>","Weekday abbreviated to 1 position, such as T for Tuesday or Thursday, or W for Wednesday (in certain locales)","</td></tr>","<tr><td>","DD","</td><td>","Weekday shortened to 3 positions, such as Fri for Friday.","</td></tr>","<tr><td>","DDD","</td><td>","Full name of weekday, such as Saturday.","</td></tr>","</table>"],"usage":["date_val:Date","formatted_string:string"],"tags":["time","date","string","text","format","formatted"],"requires":["is_string?","split_by","push","date_components","join"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"is_even?":{ "name":"is_even?","fn_args":"(x)","usage":["value:number"],"description":"If the argument passed is an even number, return true, else returns false.","tags":["list","filter","modulus","odd","number"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"is_odd?":{ "name":"is_odd?","fn_args":"(x)","usage":["value:number"],"description":"If the argument passed is an odd number, return true, else returns false.","tags":["list","filter","modulus","even","number"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"set_path_value":{ "name":"set_path_value","fn_args":"(root path value)","description":"Given an object (the root), a path array, and a value to set, sets the value at the path point in the root object.","usage":["root:object","path:list","value:*"],"tags":["object","path","resolve","assign"],"requires":["is_array?","last","resolve_path","chop"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"has_items?":{ "name":"has_items?","fn_args":"(value)","usage":["value:list"],"description":"Returns true if the list provided has a length greater than one, or false if the list is 0 or nil","tags":["list","values","contains"],"requires":["not","length"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"match_all_js":{ "requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"match_all":{ "name":"match_all","fn_args":"(regex_str search_string)","usage":["regex_str:string","search_string:string"],"description":"Given a regex expression as a string, and the string to search through, returns all matched items via matchAll.","tags":["match","regex","string","find","scan"],"requires":["match_all_js"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"chop_front":{ "name":"chop_front","fn_args":"(container amount)","usage":["container:array|string","amount:integer"],"mutates":false,"tags":["text","string","list","reduce"],"description":"Given a string or array, returns a new container with the first value removed from the provided container.  An optional amount can be provided to remove more than one value from the container.","requires":["is_string?","is_array?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"compile_lisp":{ "name":"compile_lisp","fn_args":"(text)","usage":["text:string"],"description":"Given an input string of lisp text, returns a JSON structure ready for evaluation.","requires":["reader"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"has_the_keys?":{ "name":"has_the_keys?","fn_args":"(key_list obj)","usage":["key_list:list","object_to_check:object"],"description":"Given a provided key_list, validate that each listed key or dotted-path-notation value exist in the object.","example":[[["=:quotem",["=:has_the_keys?",["type","values.sub_transaction_id"],{ "type":"Transaction","group":"Receivables","values":{ "sub_transaction_id":1242424
}
}]],true]],"requires":["resolve_path"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"demarked_number":{ "name":"demarked_number","fn_args":"(value separator precision no_show_sign)","usage":["value:number","separator:string","precision:number","no_show_sign:boolean"],"description":["=:+","Given a numeric value, a separator string, such as \",\" and a precision value ","for the fractional-part or mantissa of the value, the demarked_number function will return a string with a formatted value. ","Default value for precision is 2 if not provided.","If no_show_sign is true, there will be no negative sign returned, which can be useful for alternative formatting.  See compile_format."],"tags":["format","conversion","currency"],"requires":["reverse","split","length","not","range","join","chop_front"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"measure_time":{ "eval_when":{ "compile_time":true
},"name":"measure_time","macro":true,"fn_args":"[\"&\" forms]","usage":["form:list"],"tags":["time","measurement","debug","timing"],"description":"Given a form as input, returns an object containing time taken to evaluate the form in milliseconds with the key time and a result key with the evaluation results.","requires":["slice"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"compare_list_ends":{ "name":"compare_list_ends","fn_args":"(l1 l2)","usage":["array1:array","array2:array"],"tags":["comparision","values","list","array"],"description":"Compares the ends of the provided flat arrays, where the shortest list must match completely the tail end of the longer list. Returns true if the comparison matches, false if they don't.","requires":["length","reverse","map"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"hsv_to_rgb":{ "usage":["hsv_values:array"],"description":"Takes an array with three values corresponding to hue, saturation and brightness. Each value should be between 0 and 1.  The function returns an array with three values corresponding to red, green and blue.","tags":["colors","graphics","rgb","conversion"],"requires":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"rgb_to_text":{ "name":"rgb_to_text","fn_args":"(rgb)","usage":["rgb_values:array"],"description":["=:+","Given an array with 3 values ranging from 0 to 1, corresponding to the \"red\",\"green\",\"blue\" values of the described color, ","the function returns a string in the form of FFFFFF."],"tags":["colors","graphics"],"requires":["join","length"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"text_to_rgb":{ "name":"text_to_rgb","fn_args":"(rgb_string)","usage":["rgb_string:string"],"description":"Given an RGB hex color string in the form of \"FFFFFF\", returns an array containing [ red green blue ] in the set [ 0 1 ].","tags":["colors","graphics"],"requires":["join","nth"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"rgb_to_hsv":{ "name":"rgb_to_hsv","fn_args":"(rgb)","description":["=:+","Takes an array with three values corresponding to red, green and blue: [red green blue].","Each value should be between 0 and 1 (i.e the set [0 1]) ","The function returns an array with three values corresponding to [hue saturation value] in the set [0 1]."],"usage":["rgb_values:array"],"tags":["colors","graphics","rgb","conversion","hsv"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"tint_rgb":{ "name":"tint_rgb","fn_args":"(rgb tint_factor)","description":["=:+","Given an array containing three values between 0 and 1 corresponding to red, ","green and blue, apply the provided tint factor to the color and return the result as an rgb array.","The provided tint factor should be in the range 0 (for no tint) to 1 (full tint)."],"usage":["rgb_value:array","tint_factor:number"],"tags":["colors","graphics"],"requires":["add"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"shade_rgb":{ "name":"shade_rgb","fn_args":"(rgb shade_factor)","description":["=:+","Given an array containing three values between 0 and 1 corresponding to red, ","green and blue, apply the provided tint factor to the color and return the result as an rgb array.","The provided tint factor should be in the range 0 (for no tint) to 1 (full tint)."],"usage":["rgb_value:array","tint_factor:number"],"tags":["colors","graphics"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"modify_color_ts":{ "name":"modify_color_ts","fn_args":"(rgb factor)","description":["=:+","Given an array containing three values between 0 and 1 corresponding to red, ","green and blue, apply the provided factor to the color and return the result as an rgb array.","The provided factor should be in the range -1 to 1: -1 to 0 applies shade to the color and 0 to 1 applies tinting to the color."],"usage":["rgb_value:array","tint_factor:number"],"tags":["colors","graphics"],"requires":["tint_rgb","shade_rgb"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"is_lower?":{ "name":"is_lower?","fn_args":"(v)","usage":["value:string"],"description":"Given a string as an argument, returns true if the first character of the string is a lowercase character value (ASCII), and false otherwise.","tags":["text","string","lowercase","uppercase"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"is_upper?":{ "name":"is_upper?","fn_args":"(v)","usage":["value:string"],"description":"Given a string as an argument, returns true if the first character of the string is an uppercase character value (ASCII), and false otherwise.","tags":["text","string","lowercase","uppercase"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"camel_case_to_lower":{ "name":"camel_case_to_lower","fn_args":"(val)","usage":[],"description":"Given a camel case string such as camelCase, returns the equivalent lowercase/underscore: camel_case.","tags":["text","string","conversion","lowercase","uppercase"],"requires":["join","map","is_upper?","lowercase","is_lower?","split"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"scan_list":{ "name":"scan_list","fn_args":"(regex container)","description":["=:+","Scans a list for the provided regex expression and returns the indexes in the list where it is found.  ","The provided regex expression can be a plain string or a RegExp object."],"usage":["regex:string","container:list"],"tags":["search","index","list","regex","array","string"],"requires":["not","sub_type","is_string?","push"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"gather_up_prop":{ "name":"gather_up_prop","fn_args":"(key values)","usage":["key:string","values:array|object"],"description":"Given a key and an object or array of objects, return all the values associated with the provided key.","tags":["key","property","objects","iteration"],"requires":["is_array?","no_empties","map","gather_up_prop","is_object?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"sum_up_prop":{ "name":"sum_up_prop","fn_args":"(key values)","usage":["key:string","values:array|object"],"description":"Given a key and an object or array of objects, return the total sum amount of the given key.","tags":["sum","key","property","objects","iteration"],"requires":["sum","flatten","gather_up_prop"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"scan_for":{ "name":"scan_for","fn_args":"(non_nil_prop list_of_objects)","description":"Given a property name and a list of objects, find the first object with the non-nil property value specified by non_nil_prop. Returns the value of the non-nil property.","usage":["non_nil_prop:string","list_of_objects:array"],"tags":["find","scan","object","list","array","value"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"make_sort_buckets":{ "name":"make_sort_buckets","fn_args":"[]","usage":[],"description":["=:+","Called with no arguments, this function returns a function that when called with a ","category and a value, will store that value under the category name in an array, ","which acts as an accumulator of items for that category.  In this mode, the function ","returns the passed item to be stored.<br><br>","When the returned function is called with no arguments, the function returns the ","object containing all passed categories as its keys, with the values being the accumulated","items passed in previous calls."],"tags":["objects","accumulator","values","sorting","categorize","categorization","buckets"],"requires":["push"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"bytes_from_int_16":{ "requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"int_16_from_bytes":{ "requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"truncate":{ "name":"truncate","fn_args":"(len value trailer)","description":["=:+","Given a length and a string or an array, return the value ","with a length no more than then the provided value. If ","the value is a string an optional trailer string can be ","provided that will be appeneded to the truncated string."],"usage":["len:number","value:array|string","trailer:string?"],"tags":["array","string","length","max","min"],"requires":["is_string?","add","is_array?"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"parse_csv":{ "name":"parse_csv","fn_args":"(csv_data options)","description":["=:+","Given a text file of CSV data and an optional options value, parse and return a JSON structure of the CSV data as nested arrays.","<br>","Options can contain the following values:<br>","<table><tr><td>separator</td><td>A text value for the separator to use.  ","The default is a comma.</td></tr><tr><td>interruptions</td><td>If set to true, ","will pause regularly during processing for 1/10th of a second to allow other event queue activities to occur.</td>","</tr><tr><td>notifier</td><td>If interruptions is true, notifier will be triggered with ","the progress of work as a percentage of completion (0 - 1), the current count and the total rows.</td></tr></table>"],"usage":["csv_data:string","options:object?"],"tags":["parse","list","values","table","tabular","csv"],"requires":["is_array?","is_string?","split_by","replace","sleep","reverse","scan_str","push","length"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"to_csv":{ "name":"to_csv","fn_args":"[\"rows\" delimiter]","description":["=:+","Given a list of rows, which are expected to be lists themselves, ","join the contents of the rows together via , and then join the rows ","together into a csv buffer using a newline, then returned as a string."],"usage":["rows:list","delimiter:string"],"tags":["csv","values","report","comma","serialize","list"],"requires":["join","map","is_string?","contains?","replace"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"squeeze":{ "name":"squeeze","fn_args":"(s)","usage":["string_value:string"],"description":"Returns a string that has all spaces removed from the supplied string value.","tags":["text","space","trim","remove"],"requires":["replace"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"ensure_keys":{ "name":"ensure_keys","fn_args":"(keylist obj default_value)","description":["=:+","Given a list of key values, an object (or nil) and an optional default value to be ","assigned each key, ensures that the object returned has the specified keys (if not already set) set to either ","the specified default value, or nil."],"usage":["keylist","obj:object","default_value:*?"],"tags":["object","keys","values","required","key"],"requires":[],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"show_time_in_words":{ "description":"Given an integer value representing seconds of a time duration, return a string representing the time in words, such as 2 mins.  If the key longForm is set to true in options return full words instead of contracted forms.  For example min vs. minute.","usage":["seconds:integer","options:object"],"tags":["time","date","format","string","elapsed"],"requires":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"ago":{ "name":"ago","fn_args":"(dval)","usage":["dval:Date"],"description":"Given a date object, return a formatted string in English with the amount of time elapsed from the provided date.","tags":["date","format","time","string","elapsed"],"requires":["show_time_in_words"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"lifespan":{ "name":"lifespan","fn_args":"(dval)","usage":["dval:Date"],"description":"Given a date object, return a formatted string in English with the amount of time until the specified date.","tags":["date","format","time","string","elapsed"],"requires":["show_time_in_words"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"rotate_right":{ "name":"rotate_right","fn_args":"(array_obj)","description":["=:+","Given an array, takes the element at the last ","position (highest index), removes it and places ","it at the front (index 0) and returns the array. "],"usage":["array_obj:array"],"tags":["array","rotation","shift","right"],"requires":["prepend","pop"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"rotate_left":{ "name":"rotate_left","fn_args":"(array_obj)","description":["=:+","Given an array, takes the element at the first ","position (index 0), removes it and places ","it at the front (highest index) and returns the array. "],"usage":["array_obj:array"],"tags":["array","rotation","shift","left"],"requires":["push","take"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"interpolate":{ "name":"interpolate","fn_args":"(from to steps)","description":"Returns an array of length steps which has ascending or descending values inclusive of from and to.","usage":["from:number","to:number","steps:number"],"tags":["range","interpolation","fill"],"requires":["assert","is_number?","push"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"unload_core_ext":{ "name":"unload_core_ext","fn_args":"[]","requires":["log"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"documentation_coverage":{ "name":"documentation_coverage","fn_args":"(ns)","description":["=:+","This function returns the coverage details for the documentation of ","global symbols by assessing how many descriptions are registered as part of a ","namespace's symbol meta data. The lower the coverage score the less documented ","a namespace is. The returned data is contained in an object with the total ","symbol count, the coverage ratio (number-of-documented-symbols / ","total-symbols), the amounts of good and missing documentation and the symbols ","grouped as arrays that represent completed and missing documentation ","respectively. "],"usage":["namespace:?string"],"tags":["documentation","coverage","help","namespace"],"requires":["push","pairs"],"externals":["ReferenceError","Object","Date","Promise","setTimeout","Math","Error","RegExp","Function","parseFloat","clone","TextEncoder","crypto","DataView","TypeError","subtype","isNaN","Intl","parseInt","console"],"source_name":"src/core-ext.lisp"
},"*lz_string_contents*":{ "requires":["read_text_file"],"externals":[],"source_name":"pkg/lz-string.juno"
},"LZString":{ "initializer":["=:eval",["=:function",[],["=:javascript"," {// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.4\n\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nconst LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\nreturn LZString;\n\n\n\n\n}"]]],"license":"Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\nThis work is free. You can redistribute it and/or modify it\nunder the terms of the WTFPL, Version 2\nFor more information see LICENSE.txt or http://www.wtfpl.net/\n\nFor more information, the home page:\nhttp://pieroxy.net/blog/pages/lz-string/testing.html","requires":["*lz_string_contents*"],"source_name":"pkg/lz-string.juno"
},"html_package":{ "requires":["env_encode_string","read_text_file"],"externals":[],"source_name":"pkg/save_browser_env.juno"
},"style_css":{ "requires":["read_text_file"],"externals":[],"source_name":"pkg/save_browser_env.juno"
},"*global_themes*":{ "requires":["read_text_file"],"externals":[],"source_name":"pkg/save_browser_env.juno"
},"browser_initializer":{ "requires":["LZString","read_text_file"],"externals":[],"source_name":"pkg/save_browser_env.juno"
},"browser_repl_package":{ "requires":["read_text_file"],"externals":[],"source_name":"pkg/save_browser_env.juno"
},"load":{ "name":"load","fn_args":"(filename)","description":["=:+","Compile and load the contents of the specified lisp filename (including path) into the Lisp environment. ","The file contents are expected to be Lisp source code in text format."],"tags":["compile","read","io","file"],"usage":["filename:string"],"requires":["path","evaluate","read_text_file"],"externals":["Deno","EvalError","JSON"],"source_name":"src/base-io.lisp"
},"with_fs_events":{ "eval_when":{ "compile_time":true
},"name":"with_fs_events","macro":true,"fn_args":"[(event_binding location) body]","description":["=:+","This function sets up a watcher scope for events on a filesystem. ","The symbol passed to the event_binding is bound to new events that occur ","at the provided location.  Once an event occurs, the body forms are executed."],"usage":["event_binding:symbol","location:string","body:array"],"tags":["file","filesystem","events","io","watch"],"requires":[],"externals":["Deno","EvalError","JSON"],"source_name":"src/base-io.lisp"
},"compile_buffer":{ "name":"compile_buffer","fn_args":"(input_buffer export_function_name options)","description":["=:+","Given an input lisp file, and an optional initalizer function name and options ","object, compile the lisp file into a javascript file. The options object will ","allow the specification of an output path and filename, given by the key ","output_file.  If the initializer function isn't specified it is named ","initializer, which when used with load, will be automatically called ","one the file is loaded.  Otherwise the initializer function should be ","called when after dynamically importing, using dynamic_import. If the ","options object is to be used, with a default initializer, nil should be ","used as a placeholder for the initializer_function name.<br><br>","Options are as follows:<br><br>","js_headers: array: If provided, this is an array of strings that represent","lines to be inserted at the top of the file.","include_source: boolean: If provided will append the block forms and ","expressions within the text as comments.","output_file: string: If provided the path and filename of the compiled ","javascript file to be produced.","include_boilerplate: boolean: If set to false explicity, the boilerplate","code will be not be included in the build.","<br><br>","NOTE: this function's API is unstable and subject to change due to ","the early phase of this language."],"usage":["input_file:string","initializer_function:string?","options:object?"],"tags":["compile","environment","building","javascript","lisp","file","export"],"requires":["add","is_object?","map","pairs","length","scan_str","push","is_array?","compiler","warn","contains?","is_string?","join","not","write_text_file","success"],"externals":["Date","RegExp","SyntaxError","console","JSON"],"source_name":"src/build-tools.lisp"
},"compile_file":{ "name":"compile_file","fn_args":"(lisp_file export_function_name options)","requires":["path","read_text_file","read_lisp","compile_buffer","add"],"externals":["Date","RegExp","SyntaxError","console","JSON"],"source_name":"src/build-tools.lisp"
},"rebuild_env":{ "name":"rebuild_env","fn_args":"(opts)","description":["=:+","Builds the lisp environment from the Lisp sources and produces the Javascript output files ","necessary for initializing the environment. Options: <br>","source_dir:string:The directory of the Lisp sources, the default is './src'.<br>","output_dir:string:The directory to where the output Javascript files are placed.  The default is './js'.<br>","include_source:boolean:If true, the compiler will include comments of the lisp source (not fully supported yet).<br>","version_tag:string:A string based label signifying the text to use as the version.  If not specified, the version ","tag uses the format year.month.day.hour.minute.<br>"],"usage":["options:object?"],"tags":["compile","export","build","environment","javascript"],"requires":["date_components","not","blank?","join","formatted_date","path","*namespace*","push","success","compile_file"],"externals":["Date","RegExp","SyntaxError","console","JSON"],"source_name":"src/build-tools.lisp"
},"*system_initializer*":{ "name":"*system_initializer*","fn_args":"[]","requires":["namespaces","*namespace*","reader","browser_repl_package"],"externals":["console","clone","globalThis"],"source_name":"pkg/save_browser_env.juno"
},"*env_template*":{ "requires":["LZString","read_text_file"],"externals":["console","clone","globalThis"],"source_name":"pkg/save_browser_env.juno"
},"included_libs":{ "requires":[],"externals":["console","clone","globalThis","Error","RegExp"],"source_name":"pkg/save_browser_env.juno"
},"included_editor_assets_old":{ "requires":[],"externals":["console","clone","globalThis","Error","RegExp"],"source_name":"pkg/save_browser_env.juno"
},"included_editor_assets":{ "requires":[],"externals":["console","clone","globalThis","Error","RegExp"],"source_name":"pkg/save_browser_env.juno"
}
} 
})(),declarations:{
    safety:{
        level:2
    }
},config:{
    export:{
        save_path:"js/juno.js",default_namespace:"user",include_source:false,save_executable:"bin/juno"
    },features:["compiler","repl","core-ext","html","build-tools","browser","http_client"],build:"2023.03.09.15.50",imports:new Object(),repl:new Object(),editor:{
        default_theme:"juno_light",font_size:14,themes:["chrome","cobalt","crimson_editor","dracula","earth_tones","gruvbox","idle_fingers","juno_light","katzenmilch","kuroir","solarized_dark","solarized_light"]
    },application:{
        menu_timeout:2500,global_theme:"juno_light",max_log_lines:100,name:"Seedling"
    }
},imports:new Object(),symbols:await ( async function(){let __obj__1=new Object();__obj__1["MAX_SAFE_INTEGER"]=9007199254740991;__obj__1["LispSyntaxError"]=LispSyntaxError;__obj__1["sub_type"]=subtype;__obj__1["__VERBOSITY__"]=0;__obj__1["int"]=parseInt;__obj__1["float"]=parseFloat;__obj__1["values"]=function anonymous(...args
) {
{
                         let acc = [];
                         for (let _i in args) {
                                let value = args[_i];
                                let type = subtype(value);
                                if (value instanceof Set)  {
                                     acc = acc.concat(Array.from(value));
                                     } else if (type==='array') {
                                      acc = acc.concat(value);
                                      } else if (type==='object') {
                                       acc = acc.concat(Object.values(value))
                                       } else {
                                        acc = acc.concat(value);
                                        }
                                }
                         return acc;
                         }
};__obj__1["pairs"]=function anonymous(obj
) {
{
                        if (subtype(obj)==='array') {
                             let rval = [];
                             for (let i = 0; i < obj.length; i+=2) {
                                    rval.push([obj[i],obj[i+1]]);
                                    }
                             return rval;
                             } else {
                              let keys = Object.keys(obj);
                              let rval = keys.reduce(function(acc,x,i) {
                                                               acc.push([x,obj[x]])
                                                               return acc;
                                                               },[]);
                              return rval;
                              }
                        }
};__obj__1["keys"]=function anonymous(obj
) {
{  return Object.keys(obj);  }
};__obj__1["take"]=function anonymous(place
) {
{ return place.shift() }
};__obj__1["prepend"]=function anonymous(place,thing
) {
{ return place.unshift(thing) }
};__obj__1["first"]=function anonymous(x
) {
{ return x[0] }
};__obj__1["last"]=function anonymous(x
) {
{ return x[x.length - 1] }
};__obj__1["length"]=function anonymous(obj
) {
{
                         if(obj instanceof Array) {
                             return obj.length;
                             } else if (obj instanceof Set) {
                              return obj.size;
                              } else if ((obj === undefined)||(obj===null)) {
                               return 0;
                               } else if (typeof obj==='object') {
                                return Object.keys(obj).length;
                                } else if (typeof obj==='string') {
                                 return obj.length;
                                 }
                         return 0;
                         }
};__obj__1["conj"]=function anonymous(...args
) {
{   let list = [];
                       if (args[0] instanceof Array) {
                            list = args[0];
                            } else {
                             list = [args[0]];
                             }
                       args.slice(1).map(function(x) {
                                          list = list.concat(x);
                                          });
                       return list;
                       }
};__obj__1["reverse"]=function anonymous(container
) {
{ return container.slice(0).reverse() }
};__obj__1["map"]=async function anonymous(lambda,array_values
) {
{ try {
                      let rval = [],
                      tl = array_values.length;
                      for (let i = 0; i < array_values.length; i++) {
                             rval.push(await lambda.apply(this,[array_values[i], i, tl]));
                             }
                      return rval;
                      } catch (ex) {
                       if (lambda === undefined || lambda === null) {
                             throw new ReferenceError("map: lambda argument (position 0) is undefined or nil")
                             } else if (array_values === undefined || array_values === null) {
                              throw new ReferenceError("map: container argument (position 1) is undefined or nil")
                              } else if (!(lambda instanceof Function)) {
                               throw new ReferenceError("map: lambda argument must be a function: received: "+ typeof lambda)
                               } else if (!(array_values instanceof Array)) {
                                throw new ReferenceError("map: invalid array argument, received: " + typeof array_values)
                                } else {
                                 // something else just pass on the error
                                 throw ex;
                                 }
                       }
                 }
};__obj__1["bind"]=function anonymous(func,this_arg
) {
{ return func.bind(this_arg) }
};__obj__1["to_object"]=function anonymous(array_values
) {
{
                         let obj={}
                         array_values.forEach((pair)=>{
                                                 obj[pair[0]]=pair[1]
                                                 });
                         return obj;
                         }
};__obj__1["to_array"]=async function(container) {
                        return await async function(){
                            if (check_true ((container instanceof Array))) {
                                return container
                            } else if (check_true (await (await get_global("is_set?"))(container))) {
                                {
                                    let acc=[];
                                    ;
                                    await container["forEach"].call(container,async function(v) {
                                        return (acc).push(v)
                                    });
                                    return acc
                                }
                            } else if (check_true ((container instanceof String || typeof container==='string'))) {
                                return (container).split("")
                            } else if (check_true ((container instanceof Object))) {
                                return await pairs(container)
                            } else {
                                return await (async function(){
                                    let __array_op_rval__44=container;
                                     if (__array_op_rval__44 instanceof Function){
                                        return await __array_op_rval__44() 
                                    } else {
                                        return [__array_op_rval__44]
                                    }
                                })()
                            }
                        } ()
                    };__obj__1["slice"]=function(target,from,to) {
                        return   (function(){
                            if (check_true (to)) {
                                return  target["slice"].call(target,from,to)
                            } else if (check_true (from)) {
                                return  target["slice"].call(target,from)
                            } else {
                                throw new SyntaxError("slice requires 2 or 3 arguments");
                                
                            }
                        } )()
                    };__obj__1["rest"]=function(x) {
                        return   (function(){
                            if (check_true ((x instanceof Array))) {
                                return  x["slice"].call(x,1)
                            } else if (check_true ((x instanceof String || typeof x==='string'))) {
                                return  x["substr"].call(x,1)
                            } else {
                                return null
                            }
                        } )()
                    };__obj__1["second"]=function anonymous(x
) {
{ return x[1] }
};__obj__1["third"]=function anonymous(x
) {
{ return x[2] }
};__obj__1["chop"]=function anonymous(x
) {
{ if (x instanceof Array) { return x.slice(0, x.length-1) } else { return x.substr(0,x.length-1) } }
};__obj__1["chomp"]=function anonymous(x
) {
{ return x.substr(x.length-1) }
};__obj__1["not"]=function anonymous(x
) {
{ if (check_true(x)) { return false } else { return true } }
};__obj__1["push"]=function anonymous(place,thing
) {
{ return place.push(thing) }
};__obj__1["pop"]=function anonymous(place
) {
{ return place.pop() }
};__obj__1["list"]=async function(...args) {
                        return args
                    };__obj__1["flatten"]=function anonymous(x
) {
{ return x.flat(999999999999) } 
};__obj__1["jslambda"]=function(...args) {
                        return  ( function(){
                            let __apply_args__69= flatten(args);
                            return ( Function).apply(this,__apply_args__69)
                        })()
                    };__obj__1["join"]=function(...args) {
                        return   (function(){
                            if (check_true ((args.length===1))) {
                                return  args['0']["join"].call(args['0'],"")
                            } else {
                                return  args['1']["join"].call(args['1'],args['0'])
                            }
                        } )()
                    };__obj__1["lowercase"]=function(x) {
                        return  x["toLowerCase"]()
                    };__obj__1["uppercase"]=function(x) {
                        return  x["toUpperCase"]()
                    };__obj__1["log"]=function(...args) {
                        return  ( function(){
                            return ( console.log).apply(this,args)
                        })()
                    };__obj__1["split"]=function anonymous(container,token
) {
{ return container.split(token) }
};__obj__1["split_by"]=function anonymous(token,container
) {
{ return container.split(token) }
};__obj__1["is_object?"]=function anonymous(x
) {
{ return x instanceof Object }
};__obj__1["is_array?"]=function anonymous(x
) {
{ return x instanceof Array }
};__obj__1["is_number?"]=function(x) {
                        return ( subtype(x)==="Number")
                    };__obj__1["is_function?"]=function(x) {
                        return (x instanceof Function)
                    };__obj__1["is_set?"]=function anonymous(x
) {
{ return x instanceof Set }
};__obj__1["is_element?"]=function anonymous(x
) {
{ return x instanceof Element }
};__obj__1["is_string?"]=function(x) {
                        return ((x instanceof String)|| (typeof x==="string"))
                    };__obj__1["is_nil?"]=async function(value) {
    return (null===value)
};__obj__1["is_regex?"]=async function(x) {
    return (await (await Environment.get_global("sub_type"))(x)==="RegExp")
};__obj__1["is_date?"]=async function(x) {
    return (await (await Environment.get_global("sub_type"))(x)==="Date")
};__obj__1["ends_with?"]=function anonymous(val,text
) {
{ if (text instanceof Array) { return text[text.length-1]===val } else if (subtype(text)=='String') { return text.endsWith(val) } else { return false }}
};__obj__1["starts_with?"]=function anonymous(val,text
) {
{ if (text instanceof Array) { return text[0]===val } else if (subtype(text)=='String') { return text.startsWith(val) } else { return false }}
};__obj__1["delete_prop"]=function anonymous(obj,...args
) {
{
                           if (args.length == 1) {
                                return delete obj[args[0]];
                                } else {
                                 while (args.length > 0) {
                                         let prop = args.shift();
                                         delete obj[prop];
                                         }
                                 }
                           return obj;
                           }
};__obj__1["blank?"]=function(val) {
                        return ((val==null)|| ((val instanceof String || typeof val==='string')&& (val==="")))
                    };__obj__1["contains?"]=function anonymous(value,container
) {
{ if (!value && !container) { return false }
                         else if (container === null) { throw new TypeError("contains?: passed nil/undefined container value"); }
                                            else if (container instanceof Array) return container.includes(value);
                                            else if (container instanceof Set) return container.has(value);
                                            else if ((container instanceof String) || typeof container === "string") {
                                                     if (subtype(value) === "Number") return container.indexOf(""+value)>-1;
                                                     else return container.indexOf(value)>-1;
                                                     }
                                            else throw new TypeError("contains?: passed invalid container type: "+subtype(container)) }
};__obj__1["make_set"]=function(vals) {
                        if (check_true ((vals instanceof Array))){
                            return new Set(vals)
                        } else {
                            {
                                let vtype;
                                vtype= sub_type(vals);
                                return   (function(){
                                    if (check_true ((vtype==="Set"))) {
                                        return new Set(vals)
                                    } else if (check_true ((vtype==="object"))) {
                                        return new Set( values(vals))
                                    }
                                } )()
                            }
                        }
                    };__obj__1["meta_for_symbol"]=function(quoted_symbol,search_mode) {
                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){
                            {
                                let local_data=(Environment.global_ctx.scope[quoted_symbol]|| Environment.definitions[quoted_symbol]);
                                ;
                                let acc=[];
                                ;
                                if (check_true (search_mode)){
                                    {
                                        if (check_true (local_data)){
                                            {
                                                (acc).push( ( get_global("add"))({
                                                    namespace:namespace,name:quoted_symbol,type: subtype(local_data)
                                                }, ( function(){
                                                    let it;
                                                    it=Environment.definitions[quoted_symbol];
                                                    if (check_true (it)){
                                                        return it
                                                    } else {
                                                        return new Object()
                                                    }
                                                })()))
                                            }
                                        };
                                        if (check_true (parent_environment)){
                                            {
                                                {
                                                    let __collector;
                                                    let __result;
                                                    let __action;
                                                    __collector=[];
                                                    __result=null;
                                                    __action=function(info) {
                                                        return (acc).push(info)
                                                    };
                                                    ;
                                                     ( function() {
                                                        let __for_body__121=function(__item) {
                                                            __result= __action(__item);
                                                            if (check_true (__result)){
                                                                return (__collector).push(__result)
                                                            }
                                                        };
                                                        let __array__122=[],__elements__120= ( function() {
                                                            {
                                                                 let __call_target__= parent_environment["meta_for_symbol"].call(parent_environment,quoted_symbol,true), __call_method__="flat";
                                                                return  __call_target__[__call_method__].call(__call_target__,1)
                                                            } 
                                                        })();
                                                        let __BREAK__FLAG__=false;
                                                        for(let __iter__119 in __elements__120) {
                                                            __array__122.push( __for_body__121(__elements__120[__iter__119]));
                                                            if(__BREAK__FLAG__) {
                                                                 __array__122.pop();
                                                                break;
                                                                
                                                            }
                                                        }return __array__122;
                                                         
                                                    })();
                                                    __collector
                                                }
                                            }
                                        };
                                        if (check_true (( length( keys(children))>0))){
                                            {
                                                {
                                                    let __collector;
                                                    let __result;
                                                    let __action;
                                                    __collector=[];
                                                    __result=null;
                                                    __action=function(details) {
                                                        return (acc).push(details)
                                                    };
                                                    ;
                                                     ( function() {
                                                        let __for_body__125=function(__item) {
                                                            __result= __action(__item);
                                                            if (check_true (__result)){
                                                                return (__collector).push(__result)
                                                            }
                                                        };
                                                        let __array__126=[],__elements__124= ( function(){
                                                            let ____collector__127=  function(){
                                                                return []
                                                            };
                                                            let ____result__128=  function(){
                                                                return null
                                                            };
                                                            let ____action__129=  function(){
                                                                return function(child_data) {
                                                                    if (check_true ( not((child_data['0']=== ( get_global("current_namespace"))())))){
                                                                        {
                                                                            return  child_data['1']["meta_for_symbol"].call(child_data['1'],quoted_symbol)
                                                                        }
                                                                    }
                                                                }
                                                            };
                                                            {
                                                                let __collector= ____collector__127();
                                                                ;
                                                                let __result= ____result__128();
                                                                ;
                                                                let __action= ____action__129();
                                                                ;
                                                                ;
                                                                 ( function() {
                                                                    let __for_body__132=function(__item) {
                                                                        __result= __action(__item);
                                                                        if (check_true (__result)){
                                                                            return (__collector).push(__result)
                                                                        }
                                                                    };
                                                                    let __array__133=[],__elements__131= pairs(children);
                                                                    let __BREAK__FLAG__=false;
                                                                    for(let __iter__130 in __elements__131) {
                                                                        __array__133.push( __for_body__132(__elements__131[__iter__130]));
                                                                        if(__BREAK__FLAG__) {
                                                                             __array__133.pop();
                                                                            break;
                                                                            
                                                                        }
                                                                    }return __array__133;
                                                                     
                                                                })();
                                                                return __collector
                                                            }
                                                        })();
                                                        let __BREAK__FLAG__=false;
                                                        for(let __iter__123 in __elements__124) {
                                                            __array__126.push( __for_body__125(__elements__124[__iter__123]));
                                                            if(__BREAK__FLAG__) {
                                                                 __array__126.pop();
                                                                break;
                                                                
                                                            }
                                                        }return __array__126;
                                                         
                                                    })();
                                                    __collector
                                                }
                                            }
                                        };
                                        return acc
                                    }
                                } else {
                                    {
                                        quoted_symbol= ( function(){
                                            if (check_true ( starts_with_ques_( ( function(){
                                                 return "=:" 
                                            })(),quoted_symbol))){
                                                return  quoted_symbol["substr"].call(quoted_symbol,2)
                                            } else {
                                                return quoted_symbol
                                            }
                                        })();
                                        {
                                            let it;
                                            it=Environment.definitions[quoted_symbol];
                                            if (check_true (it)){
                                                return  ( get_global("add"))({
                                                    namespace:namespace,type: sub_type(local_data),name:quoted_symbol
                                                },it)
                                            } else {
                                                return null
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };__obj__1["describe"]=async function(quoted_symbol,search_mode) {
                        let internal_results=await meta_for_symbol(quoted_symbol,true);
                        ;
                        if (check_true (((internal_results instanceof Array)&& internal_results['0']))){
                            if (check_true (search_mode)){
                                return internal_results
                            } else {
                                return await first(internal_results)
                            }
                        } else {
                            {
                                let external_results=await get_outside_global(quoted_symbol);
                                ;
                                if (check_true (external_results)){
                                    {
                                        let detail={
                                            location:"external",type:await subtype(external_results),name:quoted_symbol,namespace:"EXTERNAL",description:("This is not a bound symbol within the Juno Environment.  "+ "If it is to be used, it is recommended to create a reference to it with "+ "`(defglobal "+ quoted_symbol+ " "+ quoted_symbol+ " { `description: \"...\" })`")
                                        };
                                        ;
                                        if (check_true (search_mode)){
                                            return await (async function(){
                                                let __array_op_rval__136=detail;
                                                 if (__array_op_rval__136 instanceof Function){
                                                    return await __array_op_rval__136() 
                                                } else {
                                                    return [__array_op_rval__136]
                                                }
                                            })()
                                        } else {
                                            return detail
                                        }
                                    }
                                } else {
                                    return null
                                }
                            }
                        }
                    };__obj__1["undefine"]=function(quoted_symbol) {
                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){
                            {
                                let namespace_identity;
                                let parent_call;
                                let child_call;
                                let target_symbol;
                                namespace_identity=(quoted_symbol).split("/");
                                parent_call=null;
                                child_call=null;
                                target_symbol=null;
                                ;
                                return   (function(){
                                    if (check_true ((((namespace_identity.length===1)&& Environment.global_ctx.scope[namespace_identity['0']])|| ((namespace_identity.length>1)&& (namespace_identity['0']===namespace))))) {
                                        {
                                            target_symbol= ( function(){
                                                if (check_true ((namespace_identity.length>1))){
                                                    return namespace_identity['1']
                                                } else {
                                                    return namespace_identity['0']
                                                }
                                            })();
                                             delete_prop(Environment.definitions,target_symbol);
                                            if (check_true (Environment.global_ctx.scope[target_symbol])){
                                                return  delete_prop(Environment.global_ctx.scope,target_symbol)
                                            } else {
                                                return false
                                            }
                                        }
                                    } else if (check_true (((namespace_identity.length>1)&& parent_environment))) {
                                        {
                                            parent_call= parent_environment["get_global"].call(parent_environment,"undefine");
                                            return (parent_call)(quoted_symbol)
                                        }
                                    } else if (check_true (((namespace_identity.length>1)&& children[namespace_identity['0']]))) {
                                        {
                                            child_call= ( function() {
                                                {
                                                     let __call_target__=children[namespace_identity['0']], __call_method__="get_global";
                                                    return  __call_target__[__call_method__].call(__call_target__,"undefine")
                                                } 
                                            })();
                                            return  child_call(quoted_symbol)
                                        }
                                    } else {
                                        return false
                                    }
                                } )()
                            }
                        } else {
                            throw new SyntaxError("undefine requires a quoted symbol");
                            
                        }
                    };__obj__1["eval_exp"]=async function(expression) {
                        return await (async function(){
                            let __array_op_rval__141=expression;
                             if (__array_op_rval__141 instanceof Function){
                                return await __array_op_rval__141() 
                            } else {
                                return [__array_op_rval__141]
                            }
                        })()
                    };__obj__1["indirect_new"]=function(...args) {
                        
                             {
                               let targetClass = args[0];
                               if (subtype(targetClass)==="String") {
                                    let tmpf=new Function("{ return "+targetClass+" }");
                                    targetClass = tmpf();
                                    }
                               if (args.length==1) {
                                    let f = function(Class) {
                                                      return new (Function.prototype.bind.apply(Class, args));
                                                      }
                                    let rval = f.apply(this,[targetClass]);
                                    return rval;
                                    } else {
                                     let f = function(Class) {
                                                       return new (Function.prototype.bind.apply(Class, args));
                                                       }
                                     let rval = f.apply(this,[targetClass].concat(args.slice(1)));
                                     return rval;
                                     }
                               } 
                    };__obj__1["range"]=function(...args) {
                        let from_to;
                        let step;
                        let idx;
                        let acc;
                        from_to= ( function(){
                            if (check_true (args['1'])){
                                return [parseInt(args['0']),parseInt(args['1'])]
                            } else {
                                return [0,parseInt(args['0'])]
                            }
                        })();
                        step= ( function(){
                            if (check_true (args['2'])){
                                return parseFloat(args['2'])
                            } else {
                                return 1
                            }
                        })();
                        idx=from_to['0'];
                        acc=[];
                         ( get_global("assert"))((step>0),"range: step must be > 0");
                         ( get_global("assert"))((from_to['1']>=from_to['0']),"range: lower bound must be greater or equal than upper bound");
                         ( function(){
                             let __test_condition__146=function() {
                                return (idx<from_to['1'])
                            };
                            let __body_ref__147=function() {
                                (acc).push(idx);
                                return idx+=step
                            };
                            let __BREAK__FLAG__=false;
                            while( __test_condition__146()) {
                                  __body_ref__147();
                                 if(__BREAK__FLAG__) {
                                     break;
                                    
                                }
                            } ;
                            
                        })();
                        return acc
                    };__obj__1["add"]=function anonymous(...args
) {
{
                   let acc;
                   if (typeof args[0]==="number") {
                        acc = 0;
                        } else if (args[0] instanceof Array) {
                         return args[0].concat(args.slice(1));
                         } else if (typeof args[0]==='object') {
                          let rval = {};
                          for (let i in args) {
                                 if (typeof args[i] === 'object') {
                                      for (let k in args[i]) {
                                             rval[k] = args[i][k];
                                             }
                                      }
                                 }
                          return rval;
                          } else {
                           acc = "";
                           }
                   for (let i in args) {
                          acc += args[i];
                          }
                   return acc;
                   }
};__obj__1["merge_objects"]=function anonymous(x
) {
{
                             let rval = {};
                             for (let i in x) {
                                    if (typeof i === 'object') {
                                         for (let k in x[i]) {
                                                rval[k] = x[i][k];
                                                }
                                         }
                                    }
                             return rval;
                             }
};__obj__1["index_of"]=function anonymous(value,container
) {
{ return container.indexOf(value) }
};__obj__1["resolve_path"]=function anonymous(path,obj
) {
{
                            if (typeof path==='string') {
                                 path = path.split(".");
                                 }
                            let s=obj;
                            return path.reduce(function(prev, curr) {
                                                         return prev ? prev[curr] : undefined
                                                         }, obj || {})
                            }
};__obj__1["min_value"]=async function(v) {
    let m;
    m=(await Environment.get_global("MAX_SAFE_INTEGER"));
    if (check_true (await (await Environment.get_global("not"))((await (await Environment.get_global("sub_type"))(v)==="array")))){
        throw new TypeError("argument is not an array");
        
    };
    await (async function() {
        let __for_body__92=async function(x) {
            if (check_true (await (await Environment.get_global("not"))(await isNaN(x)))){
                return m=await Math.min(x,m)
            }
        };
        let __array__93=[],__elements__91=v;
        let __BREAK__FLAG__=false;
        for(let __iter__90 in __elements__91) {
            __array__93.push(await __for_body__92(__elements__91[__iter__90]));
            if(__BREAK__FLAG__) {
                 __array__93.pop();
                break;
                
            }
        }return __array__93;
         
    })();
    if (check_true ((m===(await Environment.get_global("MAX_SAFE_INTEGER"))))){
        return 0
    } else {
        return m
    }
};__obj__1["max_value"]=async function(v) {
    let m;
    m=0;
    if (check_true (await (await Environment.get_global("not"))((await (await Environment.get_global("sub_type"))(v)==="array")))){
        throw new TypeError("argument is not an array");
        
    };
    await (async function() {
        let __for_body__88=async function(x) {
            if (check_true (await (await Environment.get_global("not"))(await isNaN(x)))){
                return m=await Math.max(x,m)
            }
        };
        let __array__89=[],__elements__87=v;
        let __BREAK__FLAG__=false;
        for(let __iter__86 in __elements__87) {
            __array__89.push(await __for_body__88(__elements__87[__iter__86]));
            if(__BREAK__FLAG__) {
                 __array__89.pop();
                break;
                
            }
        }return __array__89;
         
    })();
    return m
};__obj__1["interlace"]=async function(...args) {
                        let min_length;
                        let rlength_args;
                        let rval;
                        min_length=await min_value(await (async function(){
                             return await map(length,args) 
                        })());
                        rlength_args=await range(await length(args));
                        rval=[];
                        await (async function() {
                            let __for_body__164=async function(i) {
                                return await (async function() {
                                    let __for_body__168=async function(j) {
                                        return (rval).push(await (async function(){
                                            let __targ__170=args[j];
                                            if (__targ__170){
                                                 return(__targ__170)[i]
                                            } 
                                        })())
                                    };
                                    let __array__169=[],__elements__167=rlength_args;
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__166 in __elements__167) {
                                        __array__169.push(await __for_body__168(__elements__167[__iter__166]));
                                        if(__BREAK__FLAG__) {
                                             __array__169.pop();
                                            break;
                                            
                                        }
                                    }return __array__169;
                                     
                                })()
                            };
                            let __array__165=[],__elements__163=await range(min_length);
                            let __BREAK__FLAG__=false;
                            for(let __iter__162 in __elements__163) {
                                __array__165.push(await __for_body__164(__elements__163[__iter__162]));
                                if(__BREAK__FLAG__) {
                                     __array__165.pop();
                                    break;
                                    
                                }
                            }return __array__165;
                             
                        })();
                        return rval
                    };__obj__1["trim"]=function(x) {
                        return  x["trim"]()
                    };__obj__1["assert"]=function(assertion_form,failure_message) {
                        if (check_true (assertion_form)){
                            return assertion_form
                        } else {
                            throw new EvalError((failure_message|| "assertion failure"));
                            
                        }
                    };__obj__1["unquotify"]=async function(val) {
                        let dval;
                        dval=val;
                        if (check_true (await starts_with_ques_("\"",dval))){
                            dval=await dval["substr"].call(dval,1,(dval.length- 2))
                        };
                        if (check_true (await starts_with_ques_("=:",dval))){
                            dval=await dval["substr"].call(dval,2)
                        };
                        return dval
                    };__obj__1["or_args"]=async function(argset) {
                        let is_true;
                        is_true=false;
                        await (async function() {
                            let __for_body__181=async function(elem) {
                                if (check_true (elem)){
                                    {
                                        is_true=true;
                                        return __BREAK__FLAG__=true;
                                        return
                                    }
                                }
                            };
                            let __array__182=[],__elements__180=argset;
                            let __BREAK__FLAG__=false;
                            for(let __iter__179 in __elements__180) {
                                __array__182.push(await __for_body__181(__elements__180[__iter__179]));
                                if(__BREAK__FLAG__) {
                                     __array__182.pop();
                                    break;
                                    
                                }
                            }return __array__182;
                             
                        })();
                        return is_true
                    };__obj__1["special_operators"]=async function() {
                        return await make_set(await (async function(){
                             return await compiler([],{
                                special_operators:true,env:Environment
                            }) 
                        })())
                    };__obj__1["defclog"]=async function(opts) {
                        let style;
                        style=("padding: 5px;"+ await (async function(){
                            if (check_true (opts.background)){
                                return ("background: "+ opts.background+ ";")
                            } else {
                                return ""
                            }
                        })()+ await (async function(){
                            if (check_true (opts.color)){
                                return ("color: "+ opts.color+ ";")
                            }
                        })()+ "");
                        return async function(...args) {
                            return await (async function(){
                                let __target_arg__189=[].concat(await conj(await (async function(){
                                    let __array_op_rval__190=style;
                                     if (__array_op_rval__190 instanceof Function){
                                        return await __array_op_rval__190() 
                                    } else {
                                        return [__array_op_rval__190]
                                    }
                                })(),args));
                                if(!__target_arg__189 instanceof Array){
                                    throw new TypeError("Invalid final argument to apply - an array is required")
                                }let __pre_arg__191=("%c"+ await (async function(){
                                    if (check_true (opts.prefix)){
                                        return opts.prefix
                                    } else {
                                        return (args).shift()
                                    }
                                })());
                                __target_arg__189.unshift(__pre_arg__191);
                                return (console.log).apply(this,__target_arg__189)
                            })()
                        }
                    };__obj__1["NOT_FOUND"]=new Object();__obj__1["check_external_env_default"]=true;__obj__1["*namespace*"]="core";__obj__1["pending_ns_loads"]=new Object();__obj__1["pend_load"]=async function(from_namespace,target_namespace,symbol,initializer) {
                        if (check_true ((null==pending_ns_loads[from_namespace]))){
                            {
                                await async function(){
                                    pending_ns_loads[from_namespace]=[];
                                    return pending_ns_loads;
                                    
                                }()
                            }
                        };
                        (pending_ns_loads[from_namespace]).push({
                            symbol:symbol,source_ns:from_namespace,target_ns:target_namespace,initializer:await (async function(){
                                 return ["=:quote",initializer] 
                            })()
                        });
                        return initializer
                    };__obj__1["load_pends"]=async function(from_namespace) {
                        if (check_true (pending_ns_loads[from_namespace])){
                            {
                                let acc=[];
                                ;
                                acc=await (async function() {
                                    let __for_body__207=async function(load_instruction) {
                                        return ["=:use_symbols",load_instruction.source_ns,[load_instruction.symbol],load_instruction.target_ns]
                                    };
                                    let __array__208=[],__elements__206=pending_ns_loads[from_namespace];
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__205 in __elements__206) {
                                        __array__208.push(await __for_body__207(__elements__206[__iter__205]));
                                        if(__BREAK__FLAG__) {
                                             __array__208.pop();
                                            break;
                                            
                                        }
                                    }return __array__208;
                                     
                                })();
                                await console.log("load_pends: ",from_namespace,"->",acc);
                                (await Environment.eval(await async function(){
                                    return acc
                                }(),null));
                                return true
                            }
                        }
                    };__obj__1["symbols"]=async function(opts) {
                        return await async function(){
                            if (check_true ((null==opts))) {
                                return await keys(Environment.global_ctx.scope)
                            } else if (check_true (opts.unique)) {
                                {
                                    let no_includes=await make_set(await conj(["meta_for_symbol","describe","undefine","*namespace*","pend_load","symbols","set_global","get_global","symbol_definition","compile","env_log","evaluate_local","evaluate","eval_struct","set_compiler","clone","eval","add_escape_encoding","get_outside_global","as_lisp","lisp_writer","clone_to_new","save_env","null","compiler"],built_ins));
                                    ;
                                    {
                                        let __collector;
                                        let __result;
                                        let __action;
                                        __collector=[];
                                        __result=null;
                                        __action=async function(sym) {
                                            if (check_true (await no_includes["has"].call(no_includes,sym))){
                                                return null
                                            } else {
                                                return sym
                                            }
                                        };
                                        ;
                                        await (async function() {
                                            let __for_body__213=async function(__item) {
                                                __result=await __action(__item);
                                                if (check_true (__result)){
                                                    return (__collector).push(__result)
                                                }
                                            };
                                            let __array__214=[],__elements__212=await keys(Environment.global_ctx.scope);
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__211 in __elements__212) {
                                                __array__214.push(await __for_body__213(__elements__212[__iter__211]));
                                                if(__BREAK__FLAG__) {
                                                     __array__214.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__214;
                                             
                                        })();
                                        return __collector
                                    }
                                }
                            }
                        } ()
                    };__obj__1["set_global"]=function(refname,value,meta,is_constant,target_namespace,contained_req) {
                          (function(){
                            if (check_true ( not((typeof refname==="string")))) {
                                throw new TypeError("reference name must be a string type");
                                
                            } else if (check_true (((Environment===value)|| (Environment.global_ctx===value)|| (Environment.global_ctx.scope===value)))) {
                                {
                                    throw new EvalError("cannot set the environment scope as a global value");
                                    
                                }
                            }
                        } )();
                        if (check_true ( resolve_path( ( function(){
                            let __array_op_rval__217=refname;
                             if (__array_op_rval__217 instanceof Function){
                                return  __array_op_rval__217("constant") 
                            } else {
                                return [__array_op_rval__217,"constant"]
                            }
                        })(),Environment.definitions))){
                            {
                                throw new TypeError(("Assignment to constant variable "+ refname));
                                
                            }
                        };
                        let namespace_identity= ( function(){
                            if (check_true (target_namespace)){
                                return  ( function(){
                                    let __array_op_rval__218=target_namespace;
                                     if (__array_op_rval__218 instanceof Function){
                                        return  __array_op_rval__218(refname) 
                                    } else {
                                        return [__array_op_rval__218,refname]
                                    }
                                })()
                            } else {
                                return (refname).split("/")
                            }
                        })();
                        ;
                        return   (function(){
                            if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace===namespace_identity['0']))))) {
                                return  parent_environment["set_global"].call(parent_environment,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'],(contained|| contained_req))
                            } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {
                                {
                                    if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){
                                        return  ( function() {
                                            {
                                                 let __call_target__=children[namespace_identity['0']], __call_method__="set_global";
                                                return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'])
                                            } 
                                        })()
                                    } else {
                                        throw new EvalError(("namespace "+ namespace_identity['0']+ " doesn't exist"));
                                        
                                    }
                                }
                            } else {
                                try {
                                    let comps= get_object_path( ( function(){
                                        if (check_true ((1===namespace_identity.length))){
                                            return namespace_identity['0']
                                        } else {
                                            return namespace_identity['1']
                                        }
                                    })());
                                    ;
                                      (function(){
                                        Environment.global_ctx.scope[comps['0']]=value;
                                        return Environment.global_ctx.scope;
                                        
                                    })();
                                    if (check_true (((meta instanceof Object)&&  not((meta instanceof Array))))){
                                        {
                                            if (check_true (is_constant)){
                                                {
                                                      (function(){
                                                        meta["constant"]=true;
                                                        return meta;
                                                        
                                                    })()
                                                }
                                            };
                                              (function(){
                                                Environment.definitions[comps['0']]=meta;
                                                return Environment.definitions;
                                                
                                            })()
                                        }
                                    } else {
                                        if (check_true (is_constant)){
                                            {
                                                  (function(){
                                                    Environment.definitions[comps['0']]={
                                                        constant:true
                                                    };
                                                    return Environment.definitions;
                                                    
                                                })()
                                            }
                                        }
                                    };
                                    return Environment.global_ctx.scope[comps['0']]
                                } catch (__exception__219) {
                                    if (__exception__219 instanceof Error) {
                                        let e=__exception__219;
                                        {
                                            {
                                                let message=("Error: set_global: "+ _star_namespace_star_+ "symbol name: "+ refname+ ": "+ e.message);
                                                ;
                                                 console.error(message,[]);
                                                  (function(){
                                                    e["message"]=message;
                                                    return e;
                                                    
                                                })();
                                                throw e;
                                                
                                            }
                                        }
                                    }
                                }
                            }
                        } )()
                    };__obj__1["get_global"]=function(refname,value_if_not_found,suppress_check_external_env,target_namespace,path_comps,contained_req) {
                        return   (function(){
                            if (check_true ( not((typeof refname==="string")))) {
                                throw new TypeError("reference name must be a string type");
                                
                            } else if (check_true ((refname==="Environment"))) {
                                return Environment
                            } else if (check_true ( compiler_operators["has"].call(compiler_operators,refname))) {
                                return special_identity
                            } else {
                                {
                                    let namespace_identity;
                                    let comps;
                                    let refval;
                                    let symbol_name;
                                    let check_external_env;
                                    namespace_identity= ( function(){
                                        if (check_true (target_namespace)){
                                            return  ( function(){
                                                let __array_op_rval__227=target_namespace;
                                                 if (__array_op_rval__227 instanceof Function){
                                                    return  __array_op_rval__227(refname) 
                                                } else {
                                                    return [__array_op_rval__227,refname]
                                                }
                                            })()
                                        } else {
                                            return (refname).split("/")
                                        }
                                    })();
                                    comps=(path_comps||  get_object_path( ( function(){
                                        if (check_true ((1===namespace_identity.length))){
                                            return namespace_identity['0']
                                        } else {
                                            return namespace_identity['1']
                                        }
                                    })()));
                                    refval=null;
                                    symbol_name=null;
                                    check_external_env= ( function(){
                                        if (check_true (suppress_check_external_env)){
                                            return false
                                        } else {
                                            return check_external_env_default
                                        }
                                    })();
                                    return   (function(){
                                        if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {
                                            return  parent_environment["get_global"].call(parent_environment,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps,(contained|| contained_req))
                                        } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {
                                            {
                                                if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){
                                                    return  ( function() {
                                                        {
                                                             let __call_target__=children[namespace_identity['0']], __call_method__="get_global";
                                                            return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps)
                                                        } 
                                                    })()
                                                } else {
                                                    {
                                                        throw new EvalError(("namespace "+ namespace_identity['0']+ " doesn't exist"));
                                                        
                                                    }
                                                }
                                            }
                                        } else {
                                            {
                                                refval=Environment.global_ctx.scope[comps['0']];
                                                if (check_true (((undefined===refval)&& (namespace_identity.length===1)&& parent_environment))){
                                                    {
                                                        let rval= parent_environment["get_global"].call(parent_environment,refname,value_if_not_found,suppress_check_external_env,null,comps,(contained|| contained_req));
                                                        ;
                                                        return rval
                                                    }
                                                } else {
                                                    {
                                                        if (check_true (((undefined===refval)&& check_external_env))){
                                                            refval= ( function(){
                                                                if (check_true (check_external_env)){
                                                                    return ( get_outside_global(comps['0'])|| NOT_FOUND)
                                                                } else {
                                                                    return NOT_FOUND
                                                                }
                                                            })()
                                                        };
                                                        return   (function(){
                                                            if (check_true (((NOT_FOUND===refval)&&  not((undefined===value_if_not_found))))) {
                                                                return value_if_not_found
                                                            } else if (check_true ((NOT_FOUND===refval))) {
                                                                {
                                                                    throw new ReferenceError(("symbol not found: "+  ( function(){
                                                                        if (check_true ((namespace_identity.length>1))){
                                                                            return  add(namespace,"/",namespace_identity['1'])
                                                                        } else {
                                                                            return  add(namespace,"/",namespace_identity['0'])
                                                                        }
                                                                    })()));
                                                                    
                                                                }
                                                            } else if (check_true ((comps.length===1))) {
                                                                return refval
                                                            } else if (check_true ((comps.length>1))) {
                                                                {
                                                                    return  resolve_path( rest(comps),refval)
                                                                }
                                                            } else {
                                                                {
                                                                     console.warn("get_global: condition fall through: ",comps);
                                                                    return NOT_FOUND
                                                                }
                                                            }
                                                        } )()
                                                    }
                                                }
                                            }
                                        }
                                    } )()
                                }
                            }
                        } )()
                    };__obj__1["symbol_definition"]=async function(symname,target_namespace) {
                        let namespace_identity;
                        namespace_identity=await (async function(){
                            if (check_true (target_namespace)){
                                return await (async function(){
                                    let __array_op_rval__230=target_namespace;
                                     if (__array_op_rval__230 instanceof Function){
                                        return await __array_op_rval__230(symname) 
                                    } else {
                                        return [__array_op_rval__230,symname]
                                    }
                                })()
                            } else {
                                if (check_true ((await length(symname)>2))){
                                    return (symname).split("/")
                                } else {
                                    return await (async function(){
                                        let __array_op_rval__231=symname;
                                         if (__array_op_rval__231 instanceof Function){
                                            return await __array_op_rval__231() 
                                        } else {
                                            return [__array_op_rval__231]
                                        }
                                    })()
                                }
                            }
                        })();
                        return await async function(){
                            if (check_true ((namespace_identity.length===1))) {
                                {
                                    let it;
                                    it=Environment.definitions[symname];
                                    if (check_true (it)){
                                        return it
                                    } else {
                                        if (check_true (parent_environment)){
                                            return await parent_environment["symbol_definition"].call(parent_environment,symname)
                                        }
                                    }
                                }
                            } else if (check_true ((namespace_identity['0']===namespace))) {
                                return Environment.definitions[symname]
                            } else if (check_true (parent_environment)) {
                                return await parent_environment["symbol_definition"].call(parent_environment,namespace_identity['1'],namespace_identity['0'])
                            } else if (check_true ((namespace_identity.length===2))) {
                                return await (async function() {
                                    {
                                         let __call_target__=children[namespace_identity['0']], __call_method__="symbol_definition";
                                        return await __call_target__[__call_method__].call(__call_target__,namespace_identity['1'])
                                    } 
                                })()
                            } else {
                                return undefined
                            }
                        } ()
                    };__obj__1["compile"]=async function(json_expression,opts) {
                        let out;
                        opts=await add({
                            env:Environment
                        },opts,{
                            meta:await (async function(){
                                if (check_true ((opts&& opts.meta))){
                                    return true
                                } else {
                                    return false
                                }
                            })()
                        });
                        out=null;
                        out=await (async function(){
                             return await compiler(json_expression,opts) 
                        })();
                        return await async function(){
                            if (check_true (((out instanceof Array)&& out['0'].ctype&& (out['0'].ctype==="FAIL")))) {
                                return out
                            } else if (check_true (opts.meta)) {
                                return out
                            } else {
                                return out['1']
                            }
                        } ()
                    };__obj__1["env_log"]=async function(...args) {
                            return await (async function(){
                                let __target_arg__189=[].concat(await conj(await (async function(){
                                    let __array_op_rval__190=style;
                                     if (__array_op_rval__190 instanceof Function){
                                        return await __array_op_rval__190() 
                                    } else {
                                        return [__array_op_rval__190]
                                    }
                                })(),args));
                                if(!__target_arg__189 instanceof Array){
                                    throw new TypeError("Invalid final argument to apply - an array is required")
                                }let __pre_arg__191=("%c"+ await (async function(){
                                    if (check_true (opts.prefix)){
                                        return opts.prefix
                                    } else {
                                        return (args).shift()
                                    }
                                })());
                                __target_arg__189.unshift(__pre_arg__191);
                                return (console.log).apply(this,__target_arg__189)
                            })()
                        };__obj__1["evaluate_local"]=async function(expression,ctx,opts) {
                        let compiled;
                        let error_data;
                        let requires;
                        let precompiled_assembly;
                        let result;
                        opts=(opts|| new Object());
                        compiled=null;
                        error_data=null;
                        requires=null;
                        precompiled_assembly=null;
                        result=null;
                        if (check_true (opts.compiled_source)){
                            compiled=expression
                        } else {
                            try {
                                compiled=await (async function(){
                                     return await compiler(await (async function(){
                                        if (check_true (opts.json_in)){
                                            return expression
                                        } else {
                                            return await Environment["read_lisp"].call(Environment,expression,{
                                                source_name:opts.source_name
                                            })
                                        }
                                    })(),{
                                        env:Environment,ctx:ctx,formatted_output:true,source_name:opts.source_name,throw_on_error:opts.throw_on_error,on_final_token_assembly:async function(val) {
                                            return precompiled_assembly=val
                                        },error_report:(opts.error_report|| null),quiet_mode:(opts.quiet_mode|| false)
                                    }) 
                                })()
                            } catch (__exception__238) {
                                if (__exception__238 instanceof Error) {
                                    let e=__exception__238;
                                    {
                                        {
                                            if (check_true (opts.throw_on_error)){
                                                {
                                                    throw e;
                                                    
                                                }
                                            };
                                            if (check_true ((e instanceof LispSyntaxError))){
                                                {
                                                    await async function(){
                                                        e["message"]=await JSON.parse(e.message);
                                                        return e;
                                                        
                                                    }()
                                                }
                                            };
                                            await async function(){
                                                if (check_true ((e instanceof LispSyntaxError))) {
                                                    return error_data=await add({
                                                        error:"LispSyntaxError"
                                                    },e.message)
                                                } else {
                                                    error_data={
                                                        error:await sub_type(e),message:e.message,stack:e.stack,form:await (async function(){
                                                             return await async function(){
                                                                if (check_true (((expression instanceof String || typeof expression==='string')&& (expression.length>100)))) {
                                                                    return await add(await expression["substr"].call(expression,0,100),"...")
                                                                } else {
                                                                    return await (await get_global("as_lisp"))(expression)
                                                                }
                                                            } () 
                                                        })(),parent_forms:[],source_name:opts.source_name,invalid:true
                                                    }
                                                }
                                            } ();
                                            if (check_true (opts.error_report)){
                                                await (async function(){
                                                    let __array_op_rval__240=opts.error_report;
                                                     if (__array_op_rval__240 instanceof Function){
                                                        return await __array_op_rval__240(error_data) 
                                                    } else {
                                                        return [__array_op_rval__240,error_data]
                                                    }
                                                })()
                                            } else {
                                                await console.error("Compilation Error: ",error_data)
                                            };
                                            compiled=await (async function(){
                                                 return [{
                                                    error:true
                                                },null] 
                                            })()
                                        }
                                    }
                                }
                            }
                        };
                        return await async function(){
                            if (check_true ((null==compiled))) {
                                return null
                            } else if (check_true ((compiled['0'].ctype==="FAIL"))) {
                                {
                                    if (check_true (opts.error_report)){
                                        {
                                            await (async function(){
                                                let __array_op_rval__241=opts.error_report;
                                                 if (__array_op_rval__241 instanceof Function){
                                                    return await __array_op_rval__241(compiled['1']) 
                                                } else {
                                                    return [__array_op_rval__241,compiled['1']]
                                                }
                                            })()
                                        }
                                    };
                                    return await async function(){
                                        if (check_true ((compiled['1'] instanceof Error))) {
                                            throw compiled['1'];
                                            
                                        } else if (check_true ((compiled['1']['0'] instanceof Error))) {
                                            throw compiled['1']['0'];
                                            
                                        } else if (check_true (((compiled['1']['0'] instanceof Object)&& (compiled['1']['0'].error==="SyntaxError")))) {
                                            {
                                                let new_error=new SyntaxError(compiled['1']['0'].message);
                                                ;
                                                await async function(){
                                                    new_error["from"]=compiled['1']['0'];
                                                    return new_error;
                                                    
                                                }();
                                                throw new_error;
                                                
                                            }
                                        } else {
                                            return compiled['1']
                                        }
                                    } ()
                                }
                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))&& parent_environment))) {
                                return await parent_environment["evaluate_local"].call(parent_environment,compiled,ctx,await add(new Object(),opts,{
                                    compiled_source:true
                                }))
                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))))) {
                                if (check_true (children[compiled['0'].namespace])){
                                    return await (async function() {
                                        {
                                             let __call_target__=children[compiled['0'].namespace], __call_method__="evaluate_local";
                                            return await __call_target__[__call_method__].call(__call_target__,compiled,ctx,await add(new Object(),opts,{
                                                compiled_source:true
                                            }))
                                        } 
                                    })()
                                } else {
                                    throw new EvalError(("unknown namespace "+ compiled['0'].namespace+ " assignment"));
                                    
                                }
                            } else {
                                {
                                    if (check_true (opts.on_compilation_complete)){
                                        await (async function(){
                                            let __array_op_rval__243=opts.on_compilation_complete;
                                             if (__array_op_rval__243 instanceof Function){
                                                return await __array_op_rval__243(compiled) 
                                            } else {
                                                return [__array_op_rval__243,compiled]
                                            }
                                        })()
                                    };
                                    try {
                                        if (check_true (((compiled instanceof Array)&& (compiled['0'] instanceof Object)&& compiled['0'].ctype&& await not((compiled['0'].ctype instanceof String || typeof compiled['0'].ctype==='string'))))){
                                            {
                                                await async function(){
                                                    compiled['0']["ctype"]=await subtype(compiled['0'].ctype);
                                                    return compiled['0'];
                                                    
                                                }()
                                            }
                                        };
                                        result=await (async function(){
                                             return await async function(){
                                                if (check_true (compiled.error)) {
                                                    throw new Error((await get_global("indirect_new"))(compiled.error,compiled.message));
                                                    
                                                } else if (check_true ((compiled['0'].ctype&& (await contains_ques_("block",compiled['0'].ctype)|| (compiled['0'].ctype==="assignment")|| (compiled['0'].ctype==="__!NOT_FOUND!__"))))) {
                                                    if (check_true (await (async function(){
                                                        let __array_op_rval__246=compiled['0'].has_lisp_globals;
                                                         if (__array_op_rval__246 instanceof Function){
                                                            return await __array_op_rval__246() 
                                                        } else {
                                                            return [__array_op_rval__246]
                                                        }
                                                    })())){
                                                        {
                                                            await async function(){
                                                                compiled[1]=new AsyncFunction("Environment",("{ "+ compiled['1']+ "}"));
                                                                return compiled;
                                                                
                                                            }();
                                                            return await (async function(){
                                                                let __array_op_rval__248=compiled['1'];
                                                                 if (__array_op_rval__248 instanceof Function){
                                                                    return await __array_op_rval__248(Environment) 
                                                                } else {
                                                                    return [__array_op_rval__248,Environment]
                                                                }
                                                            })()
                                                        }
                                                    } else {
                                                        {
                                                            await async function(){
                                                                compiled[1]=new AsyncFunction(("{"+ compiled['1']+ "}"));
                                                                return compiled;
                                                                
                                                            }();
                                                            return await (async function(){
                                                                let __array_op_rval__250=compiled['1'];
                                                                 if (__array_op_rval__250 instanceof Function){
                                                                    return await __array_op_rval__250() 
                                                                } else {
                                                                    return [__array_op_rval__250]
                                                                }
                                                            })()
                                                        }
                                                    }
                                                } else if (check_true ((compiled['0'].ctype&& (("AsyncFunction"===compiled['0'].ctype)|| ("statement"===compiled['0'].ctype)|| ("objliteral"===compiled['0'].ctype))))) {
                                                    {
                                                        if (check_true (await (async function(){
                                                            let __array_op_rval__251=compiled['0'].has_lisp_globals;
                                                             if (__array_op_rval__251 instanceof Function){
                                                                return await __array_op_rval__251() 
                                                            } else {
                                                                return [__array_op_rval__251]
                                                            }
                                                        })())){
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new AsyncFunction("Environment",("{ return "+ compiled['1']+ "} "));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__253=compiled['1'];
                                                                     if (__array_op_rval__253 instanceof Function){
                                                                        return await __array_op_rval__253(Environment) 
                                                                    } else {
                                                                        return [__array_op_rval__253,Environment]
                                                                    }
                                                                })()
                                                            }
                                                        } else {
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new AsyncFunction(("{ return "+ compiled['1']+ "}"));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__255=compiled['1'];
                                                                     if (__array_op_rval__255 instanceof Function){
                                                                        return await __array_op_rval__255() 
                                                                    } else {
                                                                        return [__array_op_rval__255]
                                                                    }
                                                                })()
                                                            }
                                                        }
                                                    }
                                                } else if (check_true ((compiled['0'].ctype&& ("Function"===compiled['0'].ctype)))) {
                                                    {
                                                        if (check_true (await (async function(){
                                                            let __array_op_rval__256=compiled['0'].has_lisp_globals;
                                                             if (__array_op_rval__256 instanceof Function){
                                                                return await __array_op_rval__256() 
                                                            } else {
                                                                return [__array_op_rval__256]
                                                            }
                                                        })())){
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new Function("Environment",("{ return "+ compiled['1']+ "} "));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__258=compiled['1'];
                                                                     if (__array_op_rval__258 instanceof Function){
                                                                        return await __array_op_rval__258(Environment) 
                                                                    } else {
                                                                        return [__array_op_rval__258,Environment]
                                                                    }
                                                                })()
                                                            }
                                                        } else {
                                                            {
                                                                await async function(){
                                                                    compiled[1]=new Function(("{ return "+ compiled['1']+ "}"));
                                                                    return compiled;
                                                                    
                                                                }();
                                                                return await (async function(){
                                                                    let __array_op_rval__260=compiled['1'];
                                                                     if (__array_op_rval__260 instanceof Function){
                                                                        return await __array_op_rval__260() 
                                                                    } else {
                                                                        return [__array_op_rval__260]
                                                                    }
                                                                })()
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    return compiled['1']
                                                }
                                            } () 
                                        })()
                                    } catch (__exception__244) {
                                        if (__exception__244 instanceof Error) {
                                            let e=__exception__244;
                                            {
                                                {
                                                    if (check_true (true)){
                                                        {
                                                            let details={
                                                                error:e.name,message:e.message,expanded_source:await (await get_global("pretty_print"))(await (async function(){
                                                                     return await (await get_global("detokenize"))(precompiled_assembly) 
                                                                })()),compiled:compiled['1']
                                                            };
                                                            ;
                                                            console.log("Syntax Error: ",details);
                                                            await async function(){
                                                                e["details"]=details;
                                                                return e;
                                                                
                                                            }()
                                                        }
                                                    };
                                                    if (check_true ((opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4)))){
                                                        {
                                                            if (check_true (e.details)){
                                                                await env_log("caught error: ",e.details)
                                                            } else {
                                                                await env_log("caught error: ",e.name,e.message,e)
                                                            }
                                                        }
                                                    };
                                                    if (check_true ((false&& (await sub_type(e)==="SyntaxError")&& (opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4))))){
                                                        await console.log(compiled['1'])
                                                    };
                                                    if (check_true (opts.error_report)){
                                                        {
                                                            await (async function(){
                                                                let __array_op_rval__262=opts.error_report;
                                                                 if (__array_op_rval__262 instanceof Function){
                                                                    return await __array_op_rval__262(await (async function(){
                                                                        if (check_true (e.details)){
                                                                            return e.details
                                                                        } else {
                                                                            return {
                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack
                                                                            }
                                                                        }
                                                                    })()) 
                                                                } else {
                                                                    return [__array_op_rval__262,await (async function(){
                                                                        if (check_true (e.details)){
                                                                            return e.details
                                                                        } else {
                                                                            return {
                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack
                                                                            }
                                                                        }
                                                                    })()]
                                                                }
                                                            })()
                                                        }
                                                    };
                                                    result=e;
                                                    if (check_true ((await not(opts.catch_errors)|| (ctx&& ctx.in_try)))){
                                                        {
                                                            throw result;
                                                            
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                    return result
                                }
                            }
                        } ()
                    };__obj__1["evaluate"]=async function(expression,ctx,opts) {
                        return await async function(){
                            if (check_true ((namespace===active_namespace))) {
                                return await evaluate_local(expression,ctx,opts)
                            } else if (check_true ((namespace==="core"))) {
                                return await (async function() {
                                    {
                                         let __call_target__=children[active_namespace], __call_method__="evaluate";
                                        return await __call_target__[__call_method__].call(__call_target__,expression,ctx,opts)
                                    } 
                                })()
                            }
                        } ()
                    };__obj__1["eval_struct"]=async function(lisp_struct,ctx,opts) {
                        let rval;
                        rval=null;
                        if (check_true (lisp_struct instanceof Function)){
                            rval=await (async function(){
                                let __array_op_rval__267=lisp_struct;
                                 if (__array_op_rval__267 instanceof Function){
                                    return await __array_op_rval__267() 
                                } else {
                                    return [__array_op_rval__267]
                                }
                            })()
                        } else {
                            rval=await (async function(){
                                 return await evaluate(lisp_struct,ctx,await add({
                                    json_in:true
                                },(opts|| new Object()))) 
                            })()
                        };
                        return rval
                    };__obj__1["built_ins"]=["MAX_SAFE_INTEGER","LispSyntaxError","sub_type","__VERBOSITY__","int","float","values","pairs","keys","take","prepend","first","last","length","conj","reverse","map","bind","to_object","to_array","slice","rest","second","third","chop","chomp","not","push","pop","list","flatten","jslambda","join","lowercase","uppercase","log","split","split_by","is_object?","is_array?","is_number?","is_function?","is_set?","is_element?","is_string?","is_nil?","is_regex?","is_date?","ends_with?","starts_with?","blank?","contains?","make_set","eval_exp","indirect_new","get_import_entry","range","add","merge_objects","index_of","resolve_path","delete_prop","load_pends","min_value","max_value","interlace","trim","assert","unquotify","or_args","pending_ns_loads","special_operators","defclog","NOT_FOUND","check_external_env_default","built_ins","reader"];__obj__1["set_compiler"]=async function(compiler_function) {
    await Environment["set_compiler"].call(Environment,compiler_function);
    return compiler_function
};__obj__1["clone"]=async function(val) {
                            if (check_true ((val===Environment))){
                                return Environment
                            } else {
                                return await clone(val,0,Environment)
                            }
                        };__obj__1["*env_config*"]={export:{save_path:"js/juno.js",default_namespace:"user",include_source:false,save_executable:"bin/juno"},features:["compiler","repl","core-ext","io","Deno","build-tools","system","http_client"],build:"2023.03.09.15.50",imports:await ( async function(){let __obj__2=new Object();__obj__2["core/readline_mod"]={symbol:"readline_mod",namespace:"core",location:"https://deno.land/x/readline/mod.ts"};__obj__2["core/streams"]={symbol:"streams",namespace:"core",location:"https://deno.land/std/streams/conversion.ts"};__obj__2["core/path"]={symbol:"path",namespace:"core",location:"https://deno.land/std@0.110.0/path/mod.ts"};return __obj__2;})(),repl:new Object(),editor:{default_theme:"juno_light",font_size:14,themes:["chrome","cobalt","crimson_editor","dracula","earth_tones","gruvbox","idle_fingers","juno_light","katzenmilch","kuroir","solarized_dark","solarized_light"]},application:{menu_timeout:2500,global_theme:"juno_light",max_log_lines:100,name:"Seedling"}};__obj__1["create_namespace"]=async function(name,options,defer_initialization) {
                                return await async function(){
                                    if (check_true (await not((name instanceof String || typeof name==='string')))) {
                                        throw new TypeError("namespace name must be a string");
                                        
                                    } else if (check_true (children[name])) {
                                        throw new EvalError("namespace already exists");
                                        
                                    } else {
                                        {
                                            let child_env;
                                            options=(options|| new Object());
                                            child_env=await (async function(){
                                                 return await dlisp_env({
                                                    parent_environment:Environment,namespace:name,contained:options.contained,defer_initialization:defer_initialization
                                                }) 
                                            })();
                                            if (check_true (child_env.evaluate)){
                                                {
                                                    await child_env["set_compiler"].call(child_env,compiler);
                                                    await async function(){
                                                        children[name]=child_env;
                                                        return children;
                                                        
                                                    }();
                                                    await async function(){
                                                        children_declarations[name]=new Object();
                                                        return children_declarations;
                                                        
                                                    }();
                                                    await child_env["evaluate_local"].call(child_env,"(for_each (sym built_ins) (delete_prop Environment.context.scope sym))");
                                                    await child_env["evaluate_local"].call(child_env,"(for_each (sym built_ins) (delete_prop Environment.definitions sym))");
                                                    if (check_true (options.contained)){
                                                        await async function(){
                                                            let __target_obj__279=children_declarations[name];
                                                            __target_obj__279["contained"]=true;
                                                            return __target_obj__279;
                                                            
                                                        }()
                                                    };
                                                    await async function(){
                                                        let __target_obj__280=children_declarations[name];
                                                        __target_obj__280["serialize_with_image"]=await (async function(){
                                                            if (check_true ((false===options.serialize_with_image))){
                                                                return false
                                                            } else {
                                                                return true
                                                            }
                                                        })();
                                                        return __target_obj__280;
                                                        
                                                    }();
                                                    return name
                                                }
                                            } else {
                                                {
                                                    await console.error("ENV: couldn't create the child environment. Received: ",child_env);
                                                    throw new EvalError(("unable to create namespace "+ name));
                                                    
                                                }
                                            }
                                        }
                                    }
                                } ()
                            };__obj__1["set_namespace"]=async function(name) {
                                return await async function(){
                                    if (check_true (await not((name instanceof String || typeof name==='string')))) {
                                        throw new TypeError("namespace name must be a string");
                                        
                                    } else if (check_true ((await not(("core"===name))&& (null==children[name])))) {
                                        throw new EvalError(("namespace "+ name+ " doesn't exist"));
                                        
                                    } else {
                                        {
                                            if (check_true ((name==="core"))){
                                                {
                                                    active_namespace="core"
                                                }
                                            } else {
                                                {
                                                    active_namespace=name
                                                }
                                            };
                                            return name
                                        }
                                    }
                                } ()
                            };__obj__1["delete_namespace"]=async function(name) {
                                return await async function(){
                                    if (check_true (await not((name instanceof String || typeof name==='string')))) {
                                        throw new TypeError("namespace name must be a string");
                                        
                                    } else if (check_true (("core"===name))) {
                                        throw new EvalError("core namespace cannot be removed");
                                        
                                    } else if (check_true ((null==children[name]))) {
                                        throw new EvalError(("namespace "+ name+ "doesn't exist"));
                                        
                                    } else if (check_true ((name===await current_namespace()))) {
                                        throw new EvalError("namespace is the current namespace");
                                        
                                    } else {
                                        {
                                            await (await get_global("remove_prop"))(children,name);
                                            await (async function() {
                                                let __for_body__283=async function(k) {
                                                    if (check_true (await starts_with_ques_(k,name))){
                                                        {
                                                            return await (await get_global("remove_prop"))(Environment.global_ctx._star_env_config_star_.imports,k)
                                                        }
                                                    }
                                                };
                                                let __array__284=[],__elements__282=(await resolve_path(["global_ctx","scope","*env_config*","imports"],Environment)|| []);
                                                let __BREAK__FLAG__=false;
                                                for(let __iter__281 in __elements__282) {
                                                    __array__284.push(await __for_body__283(__elements__282[__iter__281]));
                                                    if(__BREAK__FLAG__) {
                                                         __array__284.pop();
                                                        break;
                                                        
                                                    }
                                                }return __array__284;
                                                 
                                            })();
                                            return name
                                        }
                                    }
                                } ()
                            };__obj__1["namespaces"]=function() {
                                    return  add( keys(children),"core")
                                };__obj__1["current_namespace"]=function() {
                                return active_namespace
                            };__obj__1["eval"]=async function(expression) {
                        return await (async function(){
                            let __array_op_rval__141=expression;
                             if (__array_op_rval__141 instanceof Function){
                                return await __array_op_rval__141() 
                            } else {
                                return [__array_op_rval__141]
                            }
                        })()
                    };__obj__1["reader"]=async function(text,opts) {    return await async function(){
        if (check_true ((undefined==text))) {
            throw new EvalError(("reader: received undefined, text must be a string."));
            
        } else if (check_true (await (await Environment.get_global("not"))((text instanceof String || typeof text==='string')))) {
            throw new EvalError(("reader: received "+ await (await Environment.get_global("sub_type"))(text)+ ": text must be a string."));
            
        } else {
            {
                let output_structure;
                let idx;
                let error_collector;
                let symbol_collector;
                let throw_on_error;
                let line_number;
                let column_number;
                let source_name;
                let len;
                let debugmode;
                let in_buffer;
                let in_code;
                let in_quotes;
                let in_long_text;
                let in_comment;
                let in_single_quote;
                let reading_object;
                let mode;
                let symbol_start;
                let cpath;
                let ctx;
                let last_final_column_num;
                let symbol_receiver;
                let add_symbol;
                let local_text;
                let position;
                let read_table;
                let get_char;
                let error;
                let handle_escape_char;
                let process_word;
                let registered_stop_char;
                let handler_stack;
                let handler;
                let c;
                let next_c;
                let depth;
                let stop;
                let read_block;
                output_structure=[];
                idx=-1;
                error_collector=[];
                symbol_collector=new Object();
                throw_on_error=await (await Environment.get_global("not"))((opts && opts["suppress_throw_on_error"]));
                line_number=0;
                column_number=0;
                source_name=await (async function(){
                    if (check_true ((opts && opts["source_name"]))){
                        return (opts && opts["source_name"])
                    } else {
                        return "anonymous"
                    }
                })();
                opts=(opts|| new Object());
                len=(await (await Environment.get_global("length"))(text)- 1);
                debugmode=await (async function(){
                     return await async function(){
                        if (check_true ((opts && opts["verbose"]))) {
                            return true
                        } else if (check_true (((opts && opts["verbose"])===false))) {
                            return false
                        } else if (check_true (((await Environment.get_global("__VERBOSITY__"))>6))) {
                            return true
                        } else {
                            return false
                        }
                    } () 
                })();
                in_buffer=(text).split("");
                in_code=0;
                in_quotes=1;
                in_long_text=2;
                in_comment=3;
                in_single_quote=4;
                reading_object=false;
                mode=in_code;
                symbol_start=null;
                cpath=[];
                ctx={
                    scope:{
                        op_chain:[]
                    },parent:null
                };
                last_final_column_num=0;
                symbol_receiver=await (async function(){
                    if (check_true ((opts && opts["symbol_receiver"]) instanceof Function)){
                        return (opts && opts["symbol_receiver"])
                    }
                })();
                add_symbol=async function(symbol,_ctx) {
                    if (check_true (await (await Environment.get_global("not"))(await (await Environment.get_global("ends_with?"))(":",symbol)))){
                        {
                            {
                                let ccol;
                                let cline;
                                let real_sym;
                                ccol=await (async function(){
                                    if (check_true ((column_number===0))){
                                        return (last_final_column_num- (symbol && symbol.length))
                                    } else {
                                        return (column_number- (symbol && symbol.length))
                                    }
                                })();
                                cline=await (async function(){
                                    if (check_true ((column_number===0))){
                                        return (line_number- 1)
                                    } else {
                                        return line_number
                                    }
                                })();
                                real_sym=await (await Environment.get_global("first"))((symbol).split("."));
                                if (check_true ((null==symbol_collector[real_sym]))){
                                    return await async function(){
                                        symbol_collector[real_sym]=await (async function(){
                                             return [await (async function(){
                                                let __array_op_rval__2=cline;
                                                 if (__array_op_rval__2 instanceof Function){
                                                    return await __array_op_rval__2(ccol,await (async function(){
                                                        if (check_true (_ctx)){
                                                            return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                        } else {
                                                            return null
                                                        }
                                                    })(),await (await Environment.get_global("but_last"))(cpath)) 
                                                } else {
                                                    return [__array_op_rval__2,ccol,await (async function(){
                                                        if (check_true (_ctx)){
                                                            return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                        } else {
                                                            return null
                                                        }
                                                    })(),await (await Environment.get_global("but_last"))(cpath)]
                                                }
                                            })()] 
                                        })();
                                        return symbol_collector;
                                        
                                    }()
                                } else {
                                    return (symbol_collector[real_sym]).push(await (async function(){
                                        let __array_op_rval__3=cline;
                                         if (__array_op_rval__3 instanceof Function){
                                            return await __array_op_rval__3(ccol,await (async function(){
                                                if (check_true (_ctx)){
                                                    return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                } else {
                                                    return null
                                                }
                                            })(),await (await Environment.get_global("but_last"))(cpath)) 
                                        } else {
                                            return [__array_op_rval__3,ccol,await (async function(){
                                                if (check_true (_ctx)){
                                                    return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                } else {
                                                    return null
                                                }
                                            })(),await (await Environment.get_global("but_last"))(cpath)]
                                        }
                                    })())
                                }
                            }
                        }
                    }
                };
                local_text=async function() {
                    let start;
                    let end;
                    start=await Math.max(0,(idx- 10));
                    end=await Math.min(await (await Environment.get_global("length"))(in_buffer),(idx+ 10));
                    return (await (await Environment.get_global("slice"))(in_buffer,start,end)).join("")
                };
                position=async function(offset) {
                    return ("line: "+ line_number+ " column: "+ await (async function(){
                        if (check_true (offset)){
                            return (column_number+ offset)
                        } else {
                            return column_number
                        }
                    })())
                };
                read_table=await (await Environment.get_global("add"))(new Object(),await (async function(){
                    if (check_true ((opts && opts["read_table_entries"]))){
                        return (opts && opts["read_table_entries"])
                    } else {
                        return new Object()
                    }
                })(),await ( async function(){
                    let __obj__4=new Object();
                    __obj__4["("]=[")",async function(block,_ctx) {
                        return block
                    }];
                    __obj__4["["]=["]",async function(block,_ctx) {
                        return block
                    }];
                    __obj__4["{"]=["}",async function(block,_ctx) {
                        let obj;
                        let __idx__5= async function(){
                            return -1
                        };
                        let key_mode;
                        let need_colon;
                        let value_mode;
                        let key;
                        let value;
                        let cpos;
                        let state;
                        let block_length;
                        {
                            obj=new Object();
                            let idx=await __idx__5();
                            ;
                            key_mode=0;
                            need_colon=1;
                            value_mode=2;
                            key=null;
                            value=null;
                            cpos=null;
                            state=key_mode;
                            block_length=(await (await Environment.get_global("length"))(block)- 1);
                            reading_object=false;
                            await (async function(){
                                 let __test_condition__6=async function() {
                                    return (idx<block_length)
                                };
                                let __body_ref__7=async function() {
                                    idx+=1;
                                    key=block[idx];
                                    if (check_true (((key instanceof Array)&& ((key && key.length)===2)&& ((key && key["0"])==="=:quotem")&& ((key && key["1"]) instanceof String || typeof (key && key["1"])==='string')))){
                                        {
                                            key=(key && key["1"])
                                        }
                                    };
                                    if (check_true (((key instanceof String || typeof key==='string')&& await (await Environment.get_global("starts_with?"))("=:",key)&& (await (await Environment.get_global("length"))(key)>2)))){
                                        key=await key["substr"].call(key,2)
                                    };
                                    return await async function(){
                                        if (check_true (await (await Environment.get_global("blank?"))(key))) {
                                            return await error("missing object key",("blank or nil key: "+ block[idx]))
                                        } else if (check_true (await (await Environment.get_global("is_number?"))(key))) {
                                            {
                                                idx+=1;
                                                return await async function(){
                                                    obj[key]=block[idx];
                                                    return obj;
                                                    
                                                }()
                                            }
                                        } else if (check_true (((key instanceof String || typeof key==='string')&& await (await Environment.get_global("contains?"))(":",key)&& await (await Environment.get_global("not"))(await (await Environment.get_global("ends_with?"))(":",key))))) {
                                            {
                                                cpos=await key["indexOf"].call(key,":");
                                                value=await key["substr"].call(key,(cpos+ 1));
                                                key=await key["substr"].call(key,0,cpos);
                                                value=await process_word((value).split(""),0,_ctx);
                                                return await async function(){
                                                    obj[key]=value;
                                                    return obj;
                                                    
                                                }()
                                            }
                                        } else {
                                            {
                                                idx+=1;
                                                if (check_true (await (await Environment.get_global("ends_with?"))(":",key))){
                                                    key=await (await Environment.get_global("chop"))(key)
                                                } else {
                                                    {
                                                        if (check_true ((block[idx]===":"))){
                                                            idx+=1
                                                        } else {
                                                            await error("missing colon",("expected colon for: "+ key))
                                                        }
                                                    }
                                                };
                                                return await async function(){
                                                    obj[key]=block[idx];
                                                    return obj;
                                                    
                                                }()
                                            }
                                        }
                                    } ()
                                };
                                let __BREAK__FLAG__=false;
                                while(await __test_condition__6()) {
                                     await __body_ref__7();
                                     if(__BREAK__FLAG__) {
                                         break;
                                        
                                    }
                                } ;
                                
                            })();
                            return obj
                        }
                    },async function() {
                        return reading_object=true
                    }];
                    __obj__4["\""]=["\"",async function(block) {
                        return ["quotes",block]
                    }];
                    return __obj__4;
                    
                })());
                get_char=async function(pos) {
                    return in_buffer[pos]
                };
                error=async function(type,message,offset) {
                    if (check_true (throw_on_error)){
                        throw new LispSyntaxError({
                            message:message,position:await position(offset),pos:{
                                line:line_number,column:(column_number+ (offset|| 0))
                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                        });
                        
                    } else {
                        if (check_true ((opts && opts["on_error"]) instanceof Function)){
                            {
                                return await (async function(){
                                    let __array_op_rval__11=(opts && opts["on_error"]);
                                     if (__array_op_rval__11 instanceof Function){
                                        return await __array_op_rval__11({
                                            message:message,position:await position(offset),pos:{
                                                line:line_number,column:(column_number+ (offset|| 0))
                                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                                        }) 
                                    } else {
                                        return [__array_op_rval__11,{
                                            message:message,position:await position(offset),pos:{
                                                line:line_number,column:(column_number+ (offset|| 0))
                                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                                        }]
                                    }
                                })()
                            }
                        }
                    }
                };
                handle_escape_char=async function(c) {
                    let ccode;
                    ccode=await c["charCodeAt"].call(c,0);
                    return await async function(){
                        if (check_true ((ccode===34))) {
                            return c
                        } else if (check_true ((ccode===92))) {
                            return c
                        } else if (check_true ((c==="t"))) {
                            return await String.fromCharCode(9)
                        } else if (check_true ((c==="n"))) {
                            return await String.fromCharCode(10)
                        } else if (check_true ((c==="r"))) {
                            return await String.fromCharCode(13)
                        } else if (check_true ((c==="f"))) {
                            return c
                        } else if (check_true ((c==="b"))) {
                            return c
                        } else {
                            return c
                        }
                    } ()
                };
                process_word=async function(word_acc,backtick_mode,_ctx) {
                    let word;
                    let word_as_number;
                    word=(word_acc).join("");
                    word_as_number=await Number(word);
                    if (check_true (debugmode)){
                        {
                            await console.log("process_word: ",word,word_as_number,backtick_mode)
                        }
                    };
                    return await async function(){
                        if (check_true (("true"===word))) {
                            return true
                        } else if (check_true (("false"===word))) {
                            return false
                        } else if (check_true ((":"===word))) {
                            return word
                        } else if (check_true ((",@"===word))) {
                            return "=$,@"
                        } else if (check_true (((",#"===word)|| ("##"===word)))) {
                            return "=:##"
                        } else if (check_true (("=$,@"===word))) {
                            return "=$,@"
                        } else if (check_true (("=:##"===word))) {
                            return "=:##"
                        } else if (check_true (await isNaN(word_as_number))) {
                            {
                                return await async function(){
                                    if (check_true ((word==="=:"))) {
                                        {
                                            return "=:"
                                        }
                                    } else if (check_true (((backtick_mode===0)&& await (await Environment.get_global("ends_with?"))(")",word)))) {
                                        {
                                            await error("trailing character","unexpected trailing parenthesis 2");
                                            return ""
                                        }
                                    } else if (check_true (((backtick_mode===0)&& await (await Environment.get_global("ends_with?"))("]",word)))) {
                                        {
                                            await error("trailing character","unexpected trailing bracket 2");
                                            return ""
                                        }
                                    } else if (check_true (await (await Environment.get_global("contains?"))(word,await (async function(){
                                         return ["=:(",await (async function(){
                                             return "=:)" 
                                        })(),await (async function(){
                                             return "=:'" 
                                        })()] 
                                    })()))) {
                                        {
                                            return word
                                        }
                                    } else if (check_true ((backtick_mode===1))) {
                                        return word
                                    } else {
                                        {
                                            if (check_true (symbol_receiver)){
                                                {
                                                    await add_symbol(word,_ctx)
                                                }
                                            };
                                            return await (await Environment.get_global("add"))(await (async function(){
                                                 return "=:" 
                                            })(),word)
                                        }
                                    }
                                } ()
                            }
                        } else if (check_true (await (await Environment.get_global("is_number?"))(word_as_number))) {
                            return word_as_number
                        } else {
                            {
                                console.log("reader: ",await position()," what is this?",word,word_acc,await local_text());
                                return word
                            }
                        }
                    } ()
                };
                registered_stop_char=null;
                handler_stack=[];
                handler=null;
                c=null;
                next_c=null;
                depth=0;
                stop=false;
                read_block=async function(_depth,_ctx) {
                    let acc;
                    let word_acc;
                    let operator;
                    let old_ctx;
                    let backtick_mode;
                    let escape_mode;
                    let last_c;
                    let block_return;
                    acc=[];
                    word_acc=[];
                    operator=null;
                    old_ctx=null;
                    backtick_mode=0;
                    escape_mode=0;
                    last_c=null;
                    _ctx=_ctx;
                    block_return=null;
                    depth=_depth;
                    await (async function(){
                         let __test_condition__12=async function() {
                            return (await (await Environment.get_global("not"))(stop)&& (idx<len))
                        };
                        let __body_ref__13=async function() {
                            idx+=1;
                            escape_mode=await Math.max(0,(escape_mode- 1));
                            c=await get_char(idx);
                            next_c=await get_char((idx+ 1));
                            if (check_true ((c==="\n"))){
                                {
                                    line_number+=1;
                                    last_final_column_num=column_number;
                                    column_number=0
                                }
                            };
                            if (check_true (debugmode)){
                                {
                                    await console.log(_depth,"  ",c," ",next_c," ",mode,"",escape_mode," ",await (await Environment.get_global("as_lisp"))(acc),await (await Environment.get_global("as_lisp"))(word_acc),(acc && acc.length),(cpath).join("."))
                                }
                            };
                            await async function(){
                                if (check_true (((next_c===undefined)&& await (await Environment.get_global("not"))((await (async function(){
                                    let __targ__14=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__14){
                                         return(__targ__14)[0]
                                    } 
                                })()===undefined))&& (await (await Environment.get_global("not"))((c===await (async function(){
                                    let __targ__15=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__15){
                                         return(__targ__15)[0]
                                    } 
                                })()))|| ((handler_stack && handler_stack.length)>1))))) {
                                    return await error("premature end",("premature end: expected: "+ await (async function(){
                                        let __targ__16=await (await Environment.get_global("last"))(handler_stack);
                                        if (__targ__16){
                                             return(__targ__16)[0]
                                        } 
                                    })()))
                                } else if (check_true (((next_c===undefined)&& (mode===in_quotes)&& await (await Environment.get_global("not"))((await c["charCodeAt"]()===34))))) {
                                    await error("premature end","premature end: expected: \"")
                                } else if (check_true (((next_c===undefined)&& (mode===in_long_text)&& await (await Environment.get_global("not"))((c==="|"))))) {
                                    await error("premature end","premature end: expected: |")
                                } else if (check_true (((mode===in_code)&& (_depth===1)&& (next_c===")")&& (c===")")))) {
                                    {
                                        await error("trailing character","unexpected trailing parenthesis")
                                    }
                                }
                            } ();
                            await async function(){
                                if (check_true (((c==="\n")&& (mode===in_comment)))) {
                                    {
                                        mode=in_code;
                                        return __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((92===await c["charCodeAt"].call(c,0))&& (mode===in_long_text)))) {
                                    {
                                        (word_acc).push(c);
                                        (word_acc).push(c)
                                    }
                                } else if (check_true (((mode>0)&& (escape_mode===1)&& (92===await c["charCodeAt"].call(c,0))))) {
                                    {
                                        (word_acc).push(c)
                                    }
                                } else if (check_true (((mode>0)&& (92===await c["charCodeAt"].call(c,0))))) {
                                    {
                                        escape_mode=2
                                    }
                                } else if (check_true (((mode>0)&& (escape_mode===1)))) {
                                    {
                                        (word_acc).push(await handle_escape_char(c))
                                    }
                                } else if (check_true (((mode===in_long_text)&& (escape_mode===0)&& (c==="|")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_quotes)&& (escape_mode===0)&& (c==="\"")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_single_quote)&& (escape_mode===0)&& (c==="'")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((c==="|")&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_long_text;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                block_return=await (async function(){
                                                     return ["=:quotem",block_return] 
                                                })();
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true (((c==="\"")&& (escape_mode===0)&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_quotes;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true (((c==="'")&& (escape_mode===0)&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_single_quote;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true ((mode===in_comment))) {
                                    false
                                } else if (check_true (((c===";")&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_comment;
                                        await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx)
                                    }
                                } else if (check_true (((mode===in_code)&& (await (await Environment.get_global("length"))(handler_stack)>0)&& (c===await (async function(){
                                    let __targ__17=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__17){
                                         return(__targ__17)[0]
                                    } 
                                })())))) {
                                    {
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_code)&& read_table[c]&& await (await Environment.get_global("first"))(read_table[c])))) {
                                    {
                                        if (check_true (await (async function(){
                                            let __targ__18=read_table[c];
                                            if (__targ__18){
                                                 return(__targ__18)[2]
                                            } 
                                        })())){
                                            {
                                                handler=await (async function(){
                                                    let __targ__19=read_table[c];
                                                    if (__targ__19){
                                                         return(__targ__19)[2]
                                                    } 
                                                })();
                                                await (async function(){
                                                    let __array_op_rval__20=handler;
                                                     if (__array_op_rval__20 instanceof Function){
                                                        return await __array_op_rval__20() 
                                                    } else {
                                                        return [__array_op_rval__20]
                                                    }
                                                })();
                                                handler=null
                                            }
                                        };
                                        (handler_stack).push(read_table[c]);
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                                                backtick_mode=0;
                                                word_acc=[]
                                            }
                                        };
                                        old_ctx=_ctx;
                                        _ctx=await (async function(){
                                             return await (await Environment.get_global("new_ctx"))(_ctx) 
                                        })();
                                        (cpath).push(0);
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        handler=await (async function(){
                                            let __targ__21=(handler_stack).pop();
                                            if (__targ__21){
                                                 return(__targ__21)[1]
                                            } 
                                        })();
                                        block_return=await (async function(){
                                            let __array_op_rval__22=handler;
                                             if (__array_op_rval__22 instanceof Function){
                                                return await __array_op_rval__22(block_return,_ctx) 
                                            } else {
                                                return [__array_op_rval__22,block_return,_ctx]
                                            }
                                        })();
                                        (cpath).pop();
                                        _ctx=old_ctx;
                                        if (check_true (await (await Environment.get_global("not"))((undefined===block_return)))){
                                            {
                                                if (check_true ((backtick_mode===1))){
                                                    {
                                                        block_return=await (async function(){
                                                             return ["=:quotem",block_return] 
                                                        })();
                                                        backtick_mode=0
                                                    }
                                                };
                                                (acc).push(block_return)
                                            }
                                        }
                                    }
                                } else if (check_true (((mode===in_code)&& (c==="`")))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        backtick_mode=1
                                    }
                                } else if (check_true (((mode===in_code)&& (c===":")&& ((word_acc && word_acc.length)===0)&& ((acc && acc.length)>0)&& (await (await Environment.get_global("last"))(acc) instanceof String || typeof await (await Environment.get_global("last"))(acc)==='string')))) {
                                    (acc).push(await (await Environment.get_global("add"))((acc).pop(),":"))
                                } else if (check_true (((mode===in_code)&& (last_c===",")&& ((c==="#")|| (c==="@"))))) {
                                    {
                                        (word_acc).push(c);
                                        (acc).push(await process_word(word_acc,null,_ctx));
                                        word_acc=[]
                                    }
                                } else if (check_true (((mode===in_code)&& ((c===" ")|| (await c["charCodeAt"].call(c,0)===10)|| (await c["charCodeAt"].call(c,0)===9)|| ((c===",")&& await (await Environment.get_global("not"))((next_c==="@"))&& await (await Environment.get_global("not"))((next_c==="#"))))))) {
                                    {
                                        if (check_true ((((acc && acc.length)===0)&& ((word_acc && word_acc.length)>0)))){
                                            {
                                                await async function(){
                                                    let __target_obj__23=(_ctx && _ctx["scope"]);
                                                    __target_obj__23["op_chain"]=await (await Environment.get_global("conj"))(await (async function(){
                                                         return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain") 
                                                    })(),(word_acc).join(""));
                                                    return __target_obj__23;
                                                    
                                                }()
                                            }
                                        };
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                if (check_true ((backtick_mode===1))){
                                                    {
                                                        (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                                                        backtick_mode=0
                                                    }
                                                } else {
                                                    (acc).push(await process_word(word_acc,null,_ctx))
                                                };
                                                word_acc=[]
                                            }
                                        };
                                        (cpath).pop();
                                        (cpath).push(await (await Environment.get_global("length"))(acc))
                                    }
                                } else if (check_true (((mode===in_code)&& (await c["charCodeAt"].call(c,0)===13)))) {
                                    false
                                } else {
                                    {
                                        (word_acc).push(c)
                                    }
                                }
                            } ();
                            column_number+=1;
                            return last_c=c
                        };
                        let __BREAK__FLAG__=false;
                        while(await __test_condition__12()) {
                             await __body_ref__13();
                             if(__BREAK__FLAG__) {
                                 break;
                                
                            }
                        } ;
                        
                    })();
                    if (check_true (((word_acc && word_acc.length)>0))){
                        {
                            (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                            word_acc=[]
                        }
                    };
                    return acc
                };
                if (check_true (debugmode)){
                    {
                        await console.log("read->",in_buffer);
                        await console.log("D  CHAR NC "," M","ESC","ACC","WORDACC","ACCL")
                    }
                };
                output_structure=await read_block(0,ctx);
                if (check_true (debugmode)){
                    {
                        await console.log("read<-",await (async function(){
                             return await clone(output_structure) 
                        })())
                    }
                };
                if (check_true ((opts && opts["symbol_receiver"]))){
                    {
                        await (async function(){
                            let __array_op_rval__24=(opts && opts["symbol_receiver"]);
                             if (__array_op_rval__24 instanceof Function){
                                return await __array_op_rval__24({
                                    source_name:source_name,symbols:symbol_collector
                                }) 
                            } else {
                                return [__array_op_rval__24,{
                                    source_name:source_name,symbols:symbol_collector
                                }]
                            }
                        })()
                    }
                };
                if (check_true (((output_structure instanceof Array)&& (await (await Environment.get_global("length"))(output_structure)>1)))){
                    {
                        (output_structure).unshift(await (async function(){
                             return "=:iprogn" 
                        })());
                        return await (await Environment.get_global("first"))(await (async function(){
                            let __array_op_rval__25=output_structure;
                             if (__array_op_rval__25 instanceof Function){
                                return await __array_op_rval__25() 
                            } else {
                                return [__array_op_rval__25]
                            }
                        })())
                    }
                } else {
                    return await (await Environment.get_global("first"))(output_structure)
                }
            }
        }
    } ()
};__obj__1["add_escape_encoding"]=async function(text) {        if (check_true ((text instanceof String || typeof text==='string'))){            let chars;            let acc;            chars=(text).split("");            acc=[];            await (async function() {                let __for_body__3=async function(c) {                     return  await async function(){                        if (check_true( ((await c["charCodeAt"].call(c,0)===34)))) {                            (acc).push(await String.fromCharCode(92));                             return  (acc).push(c)                        } else  {                             return (acc).push(c)                        }                    } ()                };                let __array__4=[],__elements__2=chars;                let __BREAK__FLAG__=false;                for(let __iter__1 in __elements__2) {                    __array__4.push(await __for_body__3(__elements__2[__iter__1]));                    if(__BREAK__FLAG__) {                         __array__4.pop();                        break;                                            }                }return __array__4;                             })();             return  (acc).join("")        } else {              return text        }    };__obj__1["get_outside_global"]=function get_outside_global(refname) {  try {    let tfn = new Function("{ if (typeof " + refname + " === 'undefined') { return undefined } else { return "+refname+" } }");    return tfn();  } catch (ex) {    return undefined;  }};__obj__1["as_lisp"]=lisp_writer;__obj__1["lisp_writer"]=lisp_writer;__obj__1["clone_to_new"]=async function(options) {
                        let new_env;
                        let my_children;
                        let my_children_declarations;
                        new_env=null;
                        my_children=null;
                        my_children_declarations=null;
                        await env_log(namespace,"cloning: # children: ",await length(children));
                        new_env=await (async function(){
                             return await dlisp_env({
                                env:await (async function(){
                                     return await clone(Environment) 
                                })(),children:await (async function(){
                                     return await clone(children) 
                                })(),children_declarations:await (async function(){
                                     return await clone(children_declarations) 
                                })()
                            }) 
                        })();
                        await env_log(namespace,"constructed: ",await new_env["id"]());
                        return new_env
                    };__obj__1["save_env"]=async function(options) {
                        let new_env;
                        let my_children;
                        let env_constructor;
                        let dcomps;
                        let version_tag;
                        let build_time;
                        let build_headers;
                        let child_env;
                        let want_buffer;
                        let comp_buffer;
                        let sorted_dependencies;
                        let child_export_order;
                        let preserve_imports;
                        let include_source;
                        let exports;
                        let src;
                        let target_insertion_path;
                        let output_path;
                        new_env=null;
                        my_children=null;
                        env_constructor=null;
                        dcomps=await (async function(){
                             return await (await get_global("date_components"))(new Date()) 
                        })();
                        options=(options|| new Object());
                        version_tag=await (async function(){
                            if (check_true (await not(await blank_ques_(opts.version_tag)))){
                                return opts.version_tag
                            } else {
                                return (await (async function(){
                                    let __array_op_rval__328=dcomps.year;
                                     if (__array_op_rval__328 instanceof Function){
                                        return await __array_op_rval__328(dcomps.month,dcomps.day,dcomps.hour,dcomps.minute) 
                                    } else {
                                        return [__array_op_rval__328,dcomps.month,dcomps.day,dcomps.hour,dcomps.minute]
                                    }
                                })()).join(".")
                            }
                        })();
                        build_time=await (async function(){
                             return await (await get_global("formatted_date"))(new Date()) 
                        })();
                        build_headers=[];
                        child_env=null;
                        want_buffer=(options.want_buffer|| false);
                        comp_buffer=null;
                        sorted_dependencies=await (async function(){
                             return await (await get_global("sort_dependencies"))() 
                        })();
                        child_export_order=null;
                        preserve_imports=await (async function(){
                            if (check_true ((options&& (options.preserve_imports===false)))){
                                return false
                            } else {
                                return true
                            }
                        })();
                        include_source=false;
                        exports=[];
                        src=await (async function(){
                            if (check_true (await Environment["get_global"].call(Environment,"*env_skeleton*",null))){
                                return await clone(await Environment["get_global"].call(Environment,"*env_skeleton*"))
                            } else {
                                return await (await get_global("reader"))(await (async function(){
                                     return await (await get_global("read_text_file"))("./src/environment.lisp") 
                                })())
                            }
                        })();
                        target_insertion_path=null;
                        output_path=null;
                        if (check_true (Environment.global_ctx.scope["*env_skeleton*"])){
                            {
                                await (await get_global("register_feature"))("*env_skeleton*")
                            }
                        };
                        target_insertion_path=await first(await (async function(){
                             return await (await get_global("findpaths"))(await (async function(){
                                 return "=:included_globals" 
                            })(),src) 
                        })());
                        if (check_true (await not((target_insertion_path instanceof Array)))){
                            throw new EvalError("Unable to find the first included_globals symbol");
                            
                        };
                        target_insertion_path=await conj(await chop(target_insertion_path),[2]);
                        if (check_true (options.include_source)){
                            {
                                include_source=true
                            }
                        };
                        await env_log(namespace,"cloning: # children: ",await length(children));
                        await env_log(namespace,"preserve_imports: ",preserve_imports);
                        exports=await export_symbol_set(await (async function(){
                            if (check_true (options.do_not_include)){
                                return {
                                    do_not_include:options.do_not_include
                                }
                            }
                        })());
                        child_export_order=await (async function(){
                            let __collector;
                            let __result;
                            let __action;
                            __collector=[];
                            __result=null;
                            __action=async function(cname) {
                                if (check_true (await not((cname==="core")))){
                                    {
                                        return await (async function(){
                                            let __array_op_rval__329=cname;
                                             if (__array_op_rval__329 instanceof Function){
                                                return await __array_op_rval__329(children[cname]) 
                                            } else {
                                                return [__array_op_rval__329,children[cname]]
                                            }
                                        })()
                                    }
                                }
                            };
                            ;
                            await (async function() {
                                let __for_body__332=async function(__item) {
                                    __result=await __action(__item);
                                    if (check_true (__result)){
                                        return (__collector).push(__result)
                                    }
                                };
                                let __array__333=[],__elements__331=sorted_dependencies.namespaces;
                                let __BREAK__FLAG__=false;
                                for(let __iter__330 in __elements__331) {
                                    __array__333.push(await __for_body__332(__elements__331[__iter__330]));
                                    if(__BREAK__FLAG__) {
                                         __array__333.pop();
                                        break;
                                        
                                    }
                                }return __array__333;
                                 
                            })();
                            return __collector
                        })();
                        await console.log("save_env: child_export_order: ",await (async function(){
                             return await (await get_global("each"))(child_export_order,0) 
                        })());
                        my_children=await to_object(await (async function(){
                            let __collector;
                            let __result;
                            let __action;
                            __collector=[];
                            __result=null;
                            __action=async function(child) {
                                if (check_true (await resolve_path(await (async function(){
                                    let __array_op_rval__334=child['0'];
                                     if (__array_op_rval__334 instanceof Function){
                                        return await __array_op_rval__334("serialize_with_image") 
                                    } else {
                                        return [__array_op_rval__334,"serialize_with_image"]
                                    }
                                })(),children_declarations))){
                                    {
                                        await env_log("checking ",namespace,"checking for: ",await add(child['0'],"/*on_serialization*"));
                                        if (check_true (await not(((typeof await add(child['0'],"/*on_serialization*")==="undefined")|| (await Environment["get_global"].call(Environment,await add(child['0'],"/*on_serialization*"),ReferenceError)===ReferenceError))))){
                                            {
                                                await child['1']["evaluate"].call(child['1'],("("+ child['0']+ "/*on_serialization*)"))
                                            }
                                        };
                                        child_env=await child['1']["compile"].call(child['1'],await child['1']["export_symbol_set"].call(child['1'],await add(new Object(),await (async function(){
                                            if (check_true (options.do_not_include)){
                                                return {
                                                    do_not_include:await (async function(){
                                                        let comps;
                                                        comps=null;
                                                        {
                                                            let ____collector__335= async function(){
                                                                return []
                                                            };
                                                            let ____result__336= async function(){
                                                                return null
                                                            };
                                                            let ____action__337= async function(){
                                                                return async function(symbol) {
                                                                    return await async function(){
                                                                        if (check_true (await contains_ques_("/",symbol))) {
                                                                            {
                                                                                comps=(symbol).split("/");
                                                                                if (check_true ((comps['0']===child['0']))){
                                                                                    return comps['1']
                                                                                }
                                                                            }
                                                                        } else {
                                                                            return symbol
                                                                        }
                                                                    } ()
                                                                }
                                                            };
                                                            {
                                                                let __collector=await ____collector__335();
                                                                ;
                                                                let __result=await ____result__336();
                                                                ;
                                                                let __action=await ____action__337();
                                                                ;
                                                                ;
                                                                await (async function() {
                                                                    let __for_body__340=async function(__item) {
                                                                        __result=await __action(__item);
                                                                        if (check_true (__result)){
                                                                            return (__collector).push(__result)
                                                                        }
                                                                    };
                                                                    let __array__341=[],__elements__339=options.do_not_include;
                                                                    let __BREAK__FLAG__=false;
                                                                    for(let __iter__338 in __elements__339) {
                                                                        __array__341.push(await __for_body__340(__elements__339[__iter__338]));
                                                                        if(__BREAK__FLAG__) {
                                                                             __array__341.pop();
                                                                            break;
                                                                            
                                                                        }
                                                                    }return __array__341;
                                                                     
                                                                })();
                                                                return __collector
                                                            }
                                                        }
                                                    })()
                                                }
                                            } else {
                                                return new Object()
                                            }
                                        })(),{
                                            no_compiler:true
                                        })),{
                                            throw_on_error:true
                                        });
                                        return await (async function(){
                                            let __array_op_rval__342=child['0'];
                                             if (__array_op_rval__342 instanceof Function){
                                                return await __array_op_rval__342(await (async function(){
                                                     return [["=:quotel",child['1'].definitions],await (async function(){
                                                         return ["=:quotel",await (async function(){
                                                             return ["=:javascript",child_env] 
                                                        })()] 
                                                    })()] 
                                                })()) 
                                            } else {
                                                return [__array_op_rval__342,await (async function(){
                                                     return [["=:quotel",child['1'].definitions],await (async function(){
                                                         return ["=:quotel",await (async function(){
                                                             return ["=:javascript",child_env] 
                                                        })()] 
                                                    })()] 
                                                })()]
                                            }
                                        })()
                                    }
                                }
                            };
                            ;
                            await (async function() {
                                let __for_body__345=async function(__item) {
                                    __result=await __action(__item);
                                    if (check_true (__result)){
                                        return (__collector).push(__result)
                                    }
                                };
                                let __array__346=[],__elements__344=child_export_order;
                                let __BREAK__FLAG__=false;
                                for(let __iter__343 in __elements__344) {
                                    __array__346.push(await __for_body__345(__elements__344[__iter__343]));
                                    if(__BREAK__FLAG__) {
                                         __array__346.pop();
                                        break;
                                        
                                    }
                                }return __array__346;
                                 
                            })();
                            return __collector
                        })());
                        await (await get_global("set_path"))(target_insertion_path,src,await (async function(){
                             return ["=:fn",[],await to_object(await (async function(){
                                 return [["definitions",await (async function(){
                                     return ["=:quote",await (async function(){
                                        if (check_true (options.do_not_include)){
                                            return await to_object(await (async function(){
                                                let __collector;
                                                let __result;
                                                let __action;
                                                __collector=[];
                                                __result=null;
                                                __action=async function(defset) {
                                                    if (check_true (await not(await contains_ques_(defset['0'],options.do_not_include)))){
                                                        return await (async function(){
                                                            let __array_op_rval__347=defset['0'];
                                                             if (__array_op_rval__347 instanceof Function){
                                                                return await __array_op_rval__347(defset['1']) 
                                                            } else {
                                                                return [__array_op_rval__347,defset['1']]
                                                            }
                                                        })()
                                                    }
                                                };
                                                ;
                                                await (async function() {
                                                    let __for_body__350=async function(__item) {
                                                        __result=await __action(__item);
                                                        if (check_true (__result)){
                                                            return (__collector).push(__result)
                                                        }
                                                    };
                                                    let __array__351=[],__elements__349=await pairs(Environment.definitions);
                                                    let __BREAK__FLAG__=false;
                                                    for(let __iter__348 in __elements__349) {
                                                        __array__351.push(await __for_body__350(__elements__349[__iter__348]));
                                                        if(__BREAK__FLAG__) {
                                                             __array__351.pop();
                                                            break;
                                                            
                                                        }
                                                    }return __array__351;
                                                     
                                                })();
                                                return __collector
                                            })())
                                        } else {
                                            return await clone(Environment.definitions)
                                        }
                                    })()] 
                                })()],["declarations",await (async function(){
                                     return await clone(Environment.declarations) 
                                })()],["config",await (async function(){
                                    let exp_conf;
                                    exp_conf=await (async function(){
                                         return await clone(Environment.global_ctx.scope["*env_config*"]) 
                                    })();
                                    if (check_true (await not(preserve_imports))){
                                        {
                                            await async function(){
                                                exp_conf["imports"]=new Object();
                                                return exp_conf;
                                                
                                            }()
                                        }
                                    };
                                    if (check_true (options.features)){
                                        {
                                            await async function(){
                                                exp_conf["features"]=options.features;
                                                return exp_conf;
                                                
                                            }()
                                        }
                                    };
                                    return exp_conf
                                })()],["imports",await (async function(){
                                    if (check_true (preserve_imports)){
                                        return await to_object(await (async function() {
                                            let __for_body__356=async function(imp_source) {
                                                return await (async function(){
                                                    let __array_op_rval__358=imp_source.symbol;
                                                     if (__array_op_rval__358 instanceof Function){
                                                        return await __array_op_rval__358({
                                                            initializer:await (async function(){
                                                                 return ["=:javascript","new function () { return ",imp_source.symbol," }"] 
                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace
                                                        }) 
                                                    } else {
                                                        return [__array_op_rval__358,{
                                                            initializer:await (async function(){
                                                                 return ["=:javascript","new function () { return ",imp_source.symbol," }"] 
                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace
                                                        }]
                                                    }
                                                })()
                                            };
                                            let __array__357=[],__elements__355=await values((await resolve_path(["*env_config*","imports"],Environment.global_ctx.scope)|| new Object()));
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__354 in __elements__355) {
                                                __array__357.push(await __for_body__356(__elements__355[__iter__354]));
                                                if(__BREAK__FLAG__) {
                                                     __array__357.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__357;
                                             
                                        })())
                                    } else {
                                        return new Object()
                                    }
                                })()],["symbols",await (async function(){
                                     return ["=:javascript",await compile(await to_object(exports),{
                                        throw_on_error:true
                                    })] 
                                })()],["children_declarations",await (async function(){
                                     return ["=:fn",[],await clone(children_declarations)] 
                                })()],["child_load_order",await (async function(){
                                     return await (await get_global("each"))(child_export_order,0) 
                                })()],["children",my_children]] 
                            })())] 
                        })());
                        output_path=await (async function(){
                            if (check_true (options.want_buffer)){
                                return null
                            } else {
                                return (options.save_as|| await resolve_path(["*env_config*","export","save_path"],Environment.global_ctx.scope))
                            }
                        })();
                        if (check_true (output_path instanceof Function)){
                            output_path=await (async function(){
                                let __array_op_rval__359=output_path;
                                 if (__array_op_rval__359 instanceof Function){
                                    return await __array_op_rval__359() 
                                } else {
                                    return [__array_op_rval__359]
                                }
                            })()
                        };
                        if (check_true ((await not((output_path instanceof String || typeof output_path==='string'))&& output_path))){
                            throw new EvalError("invalid name for target for saving the environment.  Must be a string or function");
                            
                        };
                        return await async function(){
                            if (check_true ((want_buffer|| (output_path&& await ends_with_ques_(".js",output_path))))) {
                                {
                                    (build_headers).push(("// Build Time: "+ build_time));
                                    (build_headers).push(("// Version: "+ version_tag));
                                    (build_headers).push(("export const DLISP_ENV_VERSION='"+ version_tag+ "';"));
                                    await env_log("saving to: ",output_path);
                                    return await (await get_global("compile_buffer"))(src,"init_dlisp",{
                                        namespace:namespace,toplevel:true,include_boilerplate:false,verbose:false,bundle:true,want_buffer:want_buffer,imports:await (async function(){
                                            if (check_true (preserve_imports)){
                                                return await resolve_path(["*env_config*","imports"],Environment.global_ctx.scope)
                                            }
                                        })(),js_headers:await (async function(){
                                             return [await (await get_global("show"))(check_true),await (async function(){
                                                 return await (await get_global("show"))(get_next_environment_id) 
                                            })(),await (async function(){
                                                 return await (await get_global("show"))(get_outside_global) 
                                            })(),await (async function(){
                                                 return await (await get_global("show"))(subtype) 
                                            })(),await (async function(){
                                                 return await (await get_global("show"))(lisp_writer) 
                                            })(),await (async function(){
                                                 return await (await get_global("show"))(clone) 
                                            })(),await (async function(){
                                                 return await (await get_global("show"))(LispSyntaxError) 
                                            })()] 
                                        })(),bundle_options:{
                                            default_namespace:await resolve_path(["*env_config*","export","default_namespace"],Environment.global_ctx.scope)
                                        },output_file:output_path,include_source:(options.include_source|| await resolve_path(["*env_config*","export","include_source"],Environment.global_ctx.scope)),build_headers:build_headers
                                    })
                                }
                            } else if (check_true ((output_path&& await ends_with_ques_(".lisp",output_path)))) {
                                return await (await get_global("write_text_file"))(output_path,await JSON.stringify(src,null,4))
                            } else {
                                return src
                            }
                        } ()
                    };__obj__1["null"]=null;__obj__1["namespace_declarations"]=function() {
                                    return children_declarations
                                };__obj__1["set_namespace_declaration"]=function(namespace,key,value) {
                                    return  ( get_global("set_path"))( ( function(){
                                        let __array_op_rval__362=namespace;
                                         if (__array_op_rval__362 instanceof Function){
                                            return  __array_op_rval__362(key) 
                                        } else {
                                            return [__array_op_rval__362,key]
                                        }
                                    })(),children_declarations,value)
                                };__obj__1["defmacro"]=async function(name,lambda_list,...forms) {
    let macro_name;
    let macro_args;
    let macro_body;
    let final_form;
    let macro_meta;
    let complex_lambda_list;
    let source_details;
    macro_name=name;
    macro_args=lambda_list;
    macro_body=forms;
    final_form=await (await Environment.get_global("last"))(forms);
    macro_meta=await (async function(){
        if (check_true (((final_form instanceof Object)&& await (await Environment.get_global("not"))(await (await Environment.get_global("blank?"))((final_form && final_form["description"])))&& await (await Environment.get_global("not"))(await (await Environment.get_global("blank?"))((final_form && final_form["usage"])))))){
            return (forms).pop()
        }
    })();
    complex_lambda_list=await (async function(){
         return await (await Environment.get_global("or_args"))(await (async function() {
            let __for_body__51=async function(elem) {
                return (await (await Environment.get_global("length"))(await (await Environment.get_global("flatten"))(await (await Environment.get_global("destructure_list"))(elem)))>0)
            };
            let __array__52=[],__elements__50=lambda_list;
            let __BREAK__FLAG__=false;
            for(let __iter__49 in __elements__50) {
                __array__52.push(await __for_body__51(__elements__50[__iter__49]));
                if(__BREAK__FLAG__) {
                     __array__52.pop();
                    break;
                    
                }
            }return __array__52;
             
        })()) 
    })();
    source_details=await (await Environment.get_global("add"))({
        eval_when:{
            compile_time:true
        },name:await (async function(){
            if (check_true (await (await Environment.get_global("starts_with?"))("=:",name))){
                return await name["substr"].call(name,2)
            } else {
                return name
            }
        })(),macro:true,fn_args:await (await Environment.get_global("as_lisp"))(macro_args)
    },await (async function(){
        if (check_true (macro_meta)){
            return macro_meta
        } else {
            return new Object()
        }
    })());
    if (check_true (complex_lambda_list)){
        return ["=:defglobal",macro_name,["=:fn",["&","=:args"],["=:destructuring_bind",macro_args,"=:args",].concat(macro_body)],["=:quote",source_details]]
    } else {
        return ["=:defglobal",macro_name,["=:fn",macro_args,].concat(macro_body),["=:quote",source_details]]
    }
};__obj__1["read_lisp"]=async function(text,opts) {    return await async function(){
        if (check_true ((undefined==text))) {
            throw new EvalError(("reader: received undefined, text must be a string."));
            
        } else if (check_true (await (await Environment.get_global("not"))((text instanceof String || typeof text==='string')))) {
            throw new EvalError(("reader: received "+ await (await Environment.get_global("sub_type"))(text)+ ": text must be a string."));
            
        } else {
            {
                let output_structure;
                let idx;
                let error_collector;
                let symbol_collector;
                let throw_on_error;
                let line_number;
                let column_number;
                let source_name;
                let len;
                let debugmode;
                let in_buffer;
                let in_code;
                let in_quotes;
                let in_long_text;
                let in_comment;
                let in_single_quote;
                let reading_object;
                let mode;
                let symbol_start;
                let cpath;
                let ctx;
                let last_final_column_num;
                let symbol_receiver;
                let add_symbol;
                let local_text;
                let position;
                let read_table;
                let get_char;
                let error;
                let handle_escape_char;
                let process_word;
                let registered_stop_char;
                let handler_stack;
                let handler;
                let c;
                let next_c;
                let depth;
                let stop;
                let read_block;
                output_structure=[];
                idx=-1;
                error_collector=[];
                symbol_collector=new Object();
                throw_on_error=await (await Environment.get_global("not"))((opts && opts["suppress_throw_on_error"]));
                line_number=0;
                column_number=0;
                source_name=await (async function(){
                    if (check_true ((opts && opts["source_name"]))){
                        return (opts && opts["source_name"])
                    } else {
                        return "anonymous"
                    }
                })();
                opts=(opts|| new Object());
                len=(await (await Environment.get_global("length"))(text)- 1);
                debugmode=await (async function(){
                     return await async function(){
                        if (check_true ((opts && opts["verbose"]))) {
                            return true
                        } else if (check_true (((opts && opts["verbose"])===false))) {
                            return false
                        } else if (check_true (((await Environment.get_global("__VERBOSITY__"))>6))) {
                            return true
                        } else {
                            return false
                        }
                    } () 
                })();
                in_buffer=(text).split("");
                in_code=0;
                in_quotes=1;
                in_long_text=2;
                in_comment=3;
                in_single_quote=4;
                reading_object=false;
                mode=in_code;
                symbol_start=null;
                cpath=[];
                ctx={
                    scope:{
                        op_chain:[]
                    },parent:null
                };
                last_final_column_num=0;
                symbol_receiver=await (async function(){
                    if (check_true ((opts && opts["symbol_receiver"]) instanceof Function)){
                        return (opts && opts["symbol_receiver"])
                    }
                })();
                add_symbol=async function(symbol,_ctx) {
                    if (check_true (await (await Environment.get_global("not"))(await (await Environment.get_global("ends_with?"))(":",symbol)))){
                        {
                            {
                                let ccol;
                                let cline;
                                let real_sym;
                                ccol=await (async function(){
                                    if (check_true ((column_number===0))){
                                        return (last_final_column_num- (symbol && symbol.length))
                                    } else {
                                        return (column_number- (symbol && symbol.length))
                                    }
                                })();
                                cline=await (async function(){
                                    if (check_true ((column_number===0))){
                                        return (line_number- 1)
                                    } else {
                                        return line_number
                                    }
                                })();
                                real_sym=await (await Environment.get_global("first"))((symbol).split("."));
                                if (check_true ((null==symbol_collector[real_sym]))){
                                    return await async function(){
                                        symbol_collector[real_sym]=await (async function(){
                                             return [await (async function(){
                                                let __array_op_rval__2=cline;
                                                 if (__array_op_rval__2 instanceof Function){
                                                    return await __array_op_rval__2(ccol,await (async function(){
                                                        if (check_true (_ctx)){
                                                            return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                        } else {
                                                            return null
                                                        }
                                                    })(),await (await Environment.get_global("but_last"))(cpath)) 
                                                } else {
                                                    return [__array_op_rval__2,ccol,await (async function(){
                                                        if (check_true (_ctx)){
                                                            return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                        } else {
                                                            return null
                                                        }
                                                    })(),await (await Environment.get_global("but_last"))(cpath)]
                                                }
                                            })()] 
                                        })();
                                        return symbol_collector;
                                        
                                    }()
                                } else {
                                    return (symbol_collector[real_sym]).push(await (async function(){
                                        let __array_op_rval__3=cline;
                                         if (__array_op_rval__3 instanceof Function){
                                            return await __array_op_rval__3(ccol,await (async function(){
                                                if (check_true (_ctx)){
                                                    return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                } else {
                                                    return null
                                                }
                                            })(),await (await Environment.get_global("but_last"))(cpath)) 
                                        } else {
                                            return [__array_op_rval__3,ccol,await (async function(){
                                                if (check_true (_ctx)){
                                                    return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                } else {
                                                    return null
                                                }
                                            })(),await (await Environment.get_global("but_last"))(cpath)]
                                        }
                                    })())
                                }
                            }
                        }
                    }
                };
                local_text=async function() {
                    let start;
                    let end;
                    start=await Math.max(0,(idx- 10));
                    end=await Math.min(await (await Environment.get_global("length"))(in_buffer),(idx+ 10));
                    return (await (await Environment.get_global("slice"))(in_buffer,start,end)).join("")
                };
                position=async function(offset) {
                    return ("line: "+ line_number+ " column: "+ await (async function(){
                        if (check_true (offset)){
                            return (column_number+ offset)
                        } else {
                            return column_number
                        }
                    })())
                };
                read_table=await (await Environment.get_global("add"))(new Object(),await (async function(){
                    if (check_true ((opts && opts["read_table_entries"]))){
                        return (opts && opts["read_table_entries"])
                    } else {
                        return new Object()
                    }
                })(),await ( async function(){
                    let __obj__4=new Object();
                    __obj__4["("]=[")",async function(block,_ctx) {
                        return block
                    }];
                    __obj__4["["]=["]",async function(block,_ctx) {
                        return block
                    }];
                    __obj__4["{"]=["}",async function(block,_ctx) {
                        let obj;
                        let __idx__5= async function(){
                            return -1
                        };
                        let key_mode;
                        let need_colon;
                        let value_mode;
                        let key;
                        let value;
                        let cpos;
                        let state;
                        let block_length;
                        {
                            obj=new Object();
                            let idx=await __idx__5();
                            ;
                            key_mode=0;
                            need_colon=1;
                            value_mode=2;
                            key=null;
                            value=null;
                            cpos=null;
                            state=key_mode;
                            block_length=(await (await Environment.get_global("length"))(block)- 1);
                            reading_object=false;
                            await (async function(){
                                 let __test_condition__6=async function() {
                                    return (idx<block_length)
                                };
                                let __body_ref__7=async function() {
                                    idx+=1;
                                    key=block[idx];
                                    if (check_true (((key instanceof Array)&& ((key && key.length)===2)&& ((key && key["0"])==="=:quotem")&& ((key && key["1"]) instanceof String || typeof (key && key["1"])==='string')))){
                                        {
                                            key=(key && key["1"])
                                        }
                                    };
                                    if (check_true (((key instanceof String || typeof key==='string')&& await (await Environment.get_global("starts_with?"))("=:",key)&& (await (await Environment.get_global("length"))(key)>2)))){
                                        key=await key["substr"].call(key,2)
                                    };
                                    return await async function(){
                                        if (check_true (await (await Environment.get_global("blank?"))(key))) {
                                            return await error("missing object key",("blank or nil key: "+ block[idx]))
                                        } else if (check_true (await (await Environment.get_global("is_number?"))(key))) {
                                            {
                                                idx+=1;
                                                return await async function(){
                                                    obj[key]=block[idx];
                                                    return obj;
                                                    
                                                }()
                                            }
                                        } else if (check_true (((key instanceof String || typeof key==='string')&& await (await Environment.get_global("contains?"))(":",key)&& await (await Environment.get_global("not"))(await (await Environment.get_global("ends_with?"))(":",key))))) {
                                            {
                                                cpos=await key["indexOf"].call(key,":");
                                                value=await key["substr"].call(key,(cpos+ 1));
                                                key=await key["substr"].call(key,0,cpos);
                                                value=await process_word((value).split(""),0,_ctx);
                                                return await async function(){
                                                    obj[key]=value;
                                                    return obj;
                                                    
                                                }()
                                            }
                                        } else {
                                            {
                                                idx+=1;
                                                if (check_true (await (await Environment.get_global("ends_with?"))(":",key))){
                                                    key=await (await Environment.get_global("chop"))(key)
                                                } else {
                                                    {
                                                        if (check_true ((block[idx]===":"))){
                                                            idx+=1
                                                        } else {
                                                            await error("missing colon",("expected colon for: "+ key))
                                                        }
                                                    }
                                                };
                                                return await async function(){
                                                    obj[key]=block[idx];
                                                    return obj;
                                                    
                                                }()
                                            }
                                        }
                                    } ()
                                };
                                let __BREAK__FLAG__=false;
                                while(await __test_condition__6()) {
                                     await __body_ref__7();
                                     if(__BREAK__FLAG__) {
                                         break;
                                        
                                    }
                                } ;
                                
                            })();
                            return obj
                        }
                    },async function() {
                        return reading_object=true
                    }];
                    __obj__4["\""]=["\"",async function(block) {
                        return ["quotes",block]
                    }];
                    return __obj__4;
                    
                })());
                get_char=async function(pos) {
                    return in_buffer[pos]
                };
                error=async function(type,message,offset) {
                    if (check_true (throw_on_error)){
                        throw new LispSyntaxError({
                            message:message,position:await position(offset),pos:{
                                line:line_number,column:(column_number+ (offset|| 0))
                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                        });
                        
                    } else {
                        if (check_true ((opts && opts["on_error"]) instanceof Function)){
                            {
                                return await (async function(){
                                    let __array_op_rval__11=(opts && opts["on_error"]);
                                     if (__array_op_rval__11 instanceof Function){
                                        return await __array_op_rval__11({
                                            message:message,position:await position(offset),pos:{
                                                line:line_number,column:(column_number+ (offset|| 0))
                                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                                        }) 
                                    } else {
                                        return [__array_op_rval__11,{
                                            message:message,position:await position(offset),pos:{
                                                line:line_number,column:(column_number+ (offset|| 0))
                                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                                        }]
                                    }
                                })()
                            }
                        }
                    }
                };
                handle_escape_char=async function(c) {
                    let ccode;
                    ccode=await c["charCodeAt"].call(c,0);
                    return await async function(){
                        if (check_true ((ccode===34))) {
                            return c
                        } else if (check_true ((ccode===92))) {
                            return c
                        } else if (check_true ((c==="t"))) {
                            return await String.fromCharCode(9)
                        } else if (check_true ((c==="n"))) {
                            return await String.fromCharCode(10)
                        } else if (check_true ((c==="r"))) {
                            return await String.fromCharCode(13)
                        } else if (check_true ((c==="f"))) {
                            return c
                        } else if (check_true ((c==="b"))) {
                            return c
                        } else {
                            return c
                        }
                    } ()
                };
                process_word=async function(word_acc,backtick_mode,_ctx) {
                    let word;
                    let word_as_number;
                    word=(word_acc).join("");
                    word_as_number=await Number(word);
                    if (check_true (debugmode)){
                        {
                            await console.log("process_word: ",word,word_as_number,backtick_mode)
                        }
                    };
                    return await async function(){
                        if (check_true (("true"===word))) {
                            return true
                        } else if (check_true (("false"===word))) {
                            return false
                        } else if (check_true ((":"===word))) {
                            return word
                        } else if (check_true ((",@"===word))) {
                            return "=$,@"
                        } else if (check_true (((",#"===word)|| ("##"===word)))) {
                            return "=:##"
                        } else if (check_true (("=$,@"===word))) {
                            return "=$,@"
                        } else if (check_true (("=:##"===word))) {
                            return "=:##"
                        } else if (check_true (await isNaN(word_as_number))) {
                            {
                                return await async function(){
                                    if (check_true ((word==="=:"))) {
                                        {
                                            return "=:"
                                        }
                                    } else if (check_true (((backtick_mode===0)&& await (await Environment.get_global("ends_with?"))(")",word)))) {
                                        {
                                            await error("trailing character","unexpected trailing parenthesis 2");
                                            return ""
                                        }
                                    } else if (check_true (((backtick_mode===0)&& await (await Environment.get_global("ends_with?"))("]",word)))) {
                                        {
                                            await error("trailing character","unexpected trailing bracket 2");
                                            return ""
                                        }
                                    } else if (check_true (await (await Environment.get_global("contains?"))(word,await (async function(){
                                         return ["=:(",await (async function(){
                                             return "=:)" 
                                        })(),await (async function(){
                                             return "=:'" 
                                        })()] 
                                    })()))) {
                                        {
                                            return word
                                        }
                                    } else if (check_true ((backtick_mode===1))) {
                                        return word
                                    } else {
                                        {
                                            if (check_true (symbol_receiver)){
                                                {
                                                    await add_symbol(word,_ctx)
                                                }
                                            };
                                            return await (await Environment.get_global("add"))(await (async function(){
                                                 return "=:" 
                                            })(),word)
                                        }
                                    }
                                } ()
                            }
                        } else if (check_true (await (await Environment.get_global("is_number?"))(word_as_number))) {
                            return word_as_number
                        } else {
                            {
                                console.log("reader: ",await position()," what is this?",word,word_acc,await local_text());
                                return word
                            }
                        }
                    } ()
                };
                registered_stop_char=null;
                handler_stack=[];
                handler=null;
                c=null;
                next_c=null;
                depth=0;
                stop=false;
                read_block=async function(_depth,_ctx) {
                    let acc;
                    let word_acc;
                    let operator;
                    let old_ctx;
                    let backtick_mode;
                    let escape_mode;
                    let last_c;
                    let block_return;
                    acc=[];
                    word_acc=[];
                    operator=null;
                    old_ctx=null;
                    backtick_mode=0;
                    escape_mode=0;
                    last_c=null;
                    _ctx=_ctx;
                    block_return=null;
                    depth=_depth;
                    await (async function(){
                         let __test_condition__12=async function() {
                            return (await (await Environment.get_global("not"))(stop)&& (idx<len))
                        };
                        let __body_ref__13=async function() {
                            idx+=1;
                            escape_mode=await Math.max(0,(escape_mode- 1));
                            c=await get_char(idx);
                            next_c=await get_char((idx+ 1));
                            if (check_true ((c==="\n"))){
                                {
                                    line_number+=1;
                                    last_final_column_num=column_number;
                                    column_number=0
                                }
                            };
                            if (check_true (debugmode)){
                                {
                                    await console.log(_depth,"  ",c," ",next_c," ",mode,"",escape_mode," ",await (await Environment.get_global("as_lisp"))(acc),await (await Environment.get_global("as_lisp"))(word_acc),(acc && acc.length),(cpath).join("."))
                                }
                            };
                            await async function(){
                                if (check_true (((next_c===undefined)&& await (await Environment.get_global("not"))((await (async function(){
                                    let __targ__14=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__14){
                                         return(__targ__14)[0]
                                    } 
                                })()===undefined))&& (await (await Environment.get_global("not"))((c===await (async function(){
                                    let __targ__15=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__15){
                                         return(__targ__15)[0]
                                    } 
                                })()))|| ((handler_stack && handler_stack.length)>1))))) {
                                    return await error("premature end",("premature end: expected: "+ await (async function(){
                                        let __targ__16=await (await Environment.get_global("last"))(handler_stack);
                                        if (__targ__16){
                                             return(__targ__16)[0]
                                        } 
                                    })()))
                                } else if (check_true (((next_c===undefined)&& (mode===in_quotes)&& await (await Environment.get_global("not"))((await c["charCodeAt"]()===34))))) {
                                    await error("premature end","premature end: expected: \"")
                                } else if (check_true (((next_c===undefined)&& (mode===in_long_text)&& await (await Environment.get_global("not"))((c==="|"))))) {
                                    await error("premature end","premature end: expected: |")
                                } else if (check_true (((mode===in_code)&& (_depth===1)&& (next_c===")")&& (c===")")))) {
                                    {
                                        await error("trailing character","unexpected trailing parenthesis")
                                    }
                                }
                            } ();
                            await async function(){
                                if (check_true (((c==="\n")&& (mode===in_comment)))) {
                                    {
                                        mode=in_code;
                                        return __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((92===await c["charCodeAt"].call(c,0))&& (mode===in_long_text)))) {
                                    {
                                        (word_acc).push(c);
                                        (word_acc).push(c)
                                    }
                                } else if (check_true (((mode>0)&& (escape_mode===1)&& (92===await c["charCodeAt"].call(c,0))))) {
                                    {
                                        (word_acc).push(c)
                                    }
                                } else if (check_true (((mode>0)&& (92===await c["charCodeAt"].call(c,0))))) {
                                    {
                                        escape_mode=2
                                    }
                                } else if (check_true (((mode>0)&& (escape_mode===1)))) {
                                    {
                                        (word_acc).push(await handle_escape_char(c))
                                    }
                                } else if (check_true (((mode===in_long_text)&& (escape_mode===0)&& (c==="|")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_quotes)&& (escape_mode===0)&& (c==="\"")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_single_quote)&& (escape_mode===0)&& (c==="'")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((c==="|")&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_long_text;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                block_return=await (async function(){
                                                     return ["=:quotem",block_return] 
                                                })();
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true (((c==="\"")&& (escape_mode===0)&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_quotes;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true (((c==="'")&& (escape_mode===0)&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_single_quote;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true ((mode===in_comment))) {
                                    false
                                } else if (check_true (((c===";")&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_comment;
                                        await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx)
                                    }
                                } else if (check_true (((mode===in_code)&& (await (await Environment.get_global("length"))(handler_stack)>0)&& (c===await (async function(){
                                    let __targ__17=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__17){
                                         return(__targ__17)[0]
                                    } 
                                })())))) {
                                    {
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_code)&& read_table[c]&& await (await Environment.get_global("first"))(read_table[c])))) {
                                    {
                                        if (check_true (await (async function(){
                                            let __targ__18=read_table[c];
                                            if (__targ__18){
                                                 return(__targ__18)[2]
                                            } 
                                        })())){
                                            {
                                                handler=await (async function(){
                                                    let __targ__19=read_table[c];
                                                    if (__targ__19){
                                                         return(__targ__19)[2]
                                                    } 
                                                })();
                                                await (async function(){
                                                    let __array_op_rval__20=handler;
                                                     if (__array_op_rval__20 instanceof Function){
                                                        return await __array_op_rval__20() 
                                                    } else {
                                                        return [__array_op_rval__20]
                                                    }
                                                })();
                                                handler=null
                                            }
                                        };
                                        (handler_stack).push(read_table[c]);
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                                                backtick_mode=0;
                                                word_acc=[]
                                            }
                                        };
                                        old_ctx=_ctx;
                                        _ctx=await (async function(){
                                             return await (await Environment.get_global("new_ctx"))(_ctx) 
                                        })();
                                        (cpath).push(0);
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        handler=await (async function(){
                                            let __targ__21=(handler_stack).pop();
                                            if (__targ__21){
                                                 return(__targ__21)[1]
                                            } 
                                        })();
                                        block_return=await (async function(){
                                            let __array_op_rval__22=handler;
                                             if (__array_op_rval__22 instanceof Function){
                                                return await __array_op_rval__22(block_return,_ctx) 
                                            } else {
                                                return [__array_op_rval__22,block_return,_ctx]
                                            }
                                        })();
                                        (cpath).pop();
                                        _ctx=old_ctx;
                                        if (check_true (await (await Environment.get_global("not"))((undefined===block_return)))){
                                            {
                                                if (check_true ((backtick_mode===1))){
                                                    {
                                                        block_return=await (async function(){
                                                             return ["=:quotem",block_return] 
                                                        })();
                                                        backtick_mode=0
                                                    }
                                                };
                                                (acc).push(block_return)
                                            }
                                        }
                                    }
                                } else if (check_true (((mode===in_code)&& (c==="`")))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        backtick_mode=1
                                    }
                                } else if (check_true (((mode===in_code)&& (c===":")&& ((word_acc && word_acc.length)===0)&& ((acc && acc.length)>0)&& (await (await Environment.get_global("last"))(acc) instanceof String || typeof await (await Environment.get_global("last"))(acc)==='string')))) {
                                    (acc).push(await (await Environment.get_global("add"))((acc).pop(),":"))
                                } else if (check_true (((mode===in_code)&& (last_c===",")&& ((c==="#")|| (c==="@"))))) {
                                    {
                                        (word_acc).push(c);
                                        (acc).push(await process_word(word_acc,null,_ctx));
                                        word_acc=[]
                                    }
                                } else if (check_true (((mode===in_code)&& ((c===" ")|| (await c["charCodeAt"].call(c,0)===10)|| (await c["charCodeAt"].call(c,0)===9)|| ((c===",")&& await (await Environment.get_global("not"))((next_c==="@"))&& await (await Environment.get_global("not"))((next_c==="#"))))))) {
                                    {
                                        if (check_true ((((acc && acc.length)===0)&& ((word_acc && word_acc.length)>0)))){
                                            {
                                                await async function(){
                                                    let __target_obj__23=(_ctx && _ctx["scope"]);
                                                    __target_obj__23["op_chain"]=await (await Environment.get_global("conj"))(await (async function(){
                                                         return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain") 
                                                    })(),(word_acc).join(""));
                                                    return __target_obj__23;
                                                    
                                                }()
                                            }
                                        };
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                if (check_true ((backtick_mode===1))){
                                                    {
                                                        (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                                                        backtick_mode=0
                                                    }
                                                } else {
                                                    (acc).push(await process_word(word_acc,null,_ctx))
                                                };
                                                word_acc=[]
                                            }
                                        };
                                        (cpath).pop();
                                        (cpath).push(await (await Environment.get_global("length"))(acc))
                                    }
                                } else if (check_true (((mode===in_code)&& (await c["charCodeAt"].call(c,0)===13)))) {
                                    false
                                } else {
                                    {
                                        (word_acc).push(c)
                                    }
                                }
                            } ();
                            column_number+=1;
                            return last_c=c
                        };
                        let __BREAK__FLAG__=false;
                        while(await __test_condition__12()) {
                             await __body_ref__13();
                             if(__BREAK__FLAG__) {
                                 break;
                                
                            }
                        } ;
                        
                    })();
                    if (check_true (((word_acc && word_acc.length)>0))){
                        {
                            (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                            word_acc=[]
                        }
                    };
                    return acc
                };
                if (check_true (debugmode)){
                    {
                        await console.log("read->",in_buffer);
                        await console.log("D  CHAR NC "," M","ESC","ACC","WORDACC","ACCL")
                    }
                };
                output_structure=await read_block(0,ctx);
                if (check_true (debugmode)){
                    {
                        await console.log("read<-",await (async function(){
                             return await clone(output_structure) 
                        })())
                    }
                };
                if (check_true ((opts && opts["symbol_receiver"]))){
                    {
                        await (async function(){
                            let __array_op_rval__24=(opts && opts["symbol_receiver"]);
                             if (__array_op_rval__24 instanceof Function){
                                return await __array_op_rval__24({
                                    source_name:source_name,symbols:symbol_collector
                                }) 
                            } else {
                                return [__array_op_rval__24,{
                                    source_name:source_name,symbols:symbol_collector
                                }]
                            }
                        })()
                    }
                };
                if (check_true (((output_structure instanceof Array)&& (await (await Environment.get_global("length"))(output_structure)>1)))){
                    {
                        (output_structure).unshift(await (async function(){
                             return "=:iprogn" 
                        })());
                        return await (await Environment.get_global("first"))(await (async function(){
                            let __array_op_rval__25=output_structure;
                             if (__array_op_rval__25 instanceof Function){
                                return await __array_op_rval__25() 
                            } else {
                                return [__array_op_rval__25]
                            }
                        })())
                    }
                } else {
                    return await (await Environment.get_global("first"))(output_structure)
                }
            }
        }
    } ()
};__obj__1["desym"]=async function(val) {
        let strip;
        strip=async function(v) {
            return (""+ await (await Environment.get_global("as_lisp"))(v))
        };
        return await async function(){
            if (check_true ((val instanceof String || typeof val==='string'))) {
                return await strip(val)
            } else if (check_true ((val instanceof Array))) {
                return await (async function() {
                    let __for_body__9=async function(v) {
                        return await strip(v)
                    };
                    let __array__10=[],__elements__8=val;
                    let __BREAK__FLAG__=false;
                    for(let __iter__7 in __elements__8) {
                        __array__10.push(await __for_body__9(__elements__8[__iter__7]));
                        if(__BREAK__FLAG__) {
                             __array__10.pop();
                            break;
                            
                        }
                    }return __array__10;
                     
                })()
            } else {
                return val
            }
        } ()
    };__obj__1["desym_ref"]=async function(val) {
    return ["=:+","",["=:as_lisp",val]]
};__obj__1["deref"]=async function(val) {
    return ["=:let",[["=:mval",val]],["=:if",["=:and",["=:is_string?","=:mval"],["=:starts_with?","=:","=:mval"]],["=:->","=:mval","substr",2],"=:mval"]]
};__obj__1["when"]=async function(...args) {
    let condition;
    let mbody;
    condition=(args && args["0"]);
    mbody=await (await Environment.get_global("slice"))(args,1);
    return ["=:if",condition,["=:do",].concat(mbody)]
};__obj__1["if_compile_time_defined"]=async function(quoted_symbol,exists_form,not_exists_form) {
    if (check_true (await (await Environment.get_global("describe"))(quoted_symbol))){
        return exists_form
    } else {
        return (not_exists_form|| [])
    }
};__obj__1["defexternal"]=async function(name,value) {
    return ["=:let",[["=:symname",["=:desym",].concat(name)]],["=:do",["=:set_prop","=:globalThis","=:symname",value],["=:prop","=:globalThis","=:symname"]]]
};__obj__1["defun"]=async function(name,lambda_list,body,meta) {
    let fn_name;
    let fn_args;
    let fn_body;
    let fn_meta;
    let complex_lambda_list;
    let symbol_details;
    let source_details;
    fn_name=name;
    fn_args=lambda_list;
    fn_body=body;
    fn_meta=meta;
    complex_lambda_list=await (async function(){
         return await (await Environment.get_global("or_args"))(await (async function() {
            let __for_body__55=async function(elem) {
                return (await (await Environment.get_global("length"))(await (await Environment.get_global("flatten"))(await (await Environment.get_global("destructure_list"))(elem)))>0)
            };
            let __array__56=[],__elements__54=lambda_list;
            let __BREAK__FLAG__=false;
            for(let __iter__53 in __elements__54) {
                __array__56.push(await __for_body__55(__elements__54[__iter__53]));
                if(__BREAK__FLAG__) {
                     __array__56.pop();
                    break;
                    
                }
            }return __array__56;
             
        })()) 
    })();
    symbol_details=await (async function(){
         return await (await Environment.get_global("decomp_symbol"))(await (async function(){
             return await (await Environment.get_global("unquotify"))(name) 
        })()) 
    })();
    source_details=await (await Environment.get_global("add"))({
        name:(symbol_details && symbol_details["0"]),fn_args:await (await Environment.get_global("as_lisp"))(fn_args)
    },await (async function(){
        if (check_true (fn_meta)){
            {
                if (check_true ((fn_meta && fn_meta["description"]))){
                    await async function(){
                        fn_meta["description"]=(fn_meta && fn_meta["description"]);
                        return fn_meta;
                        
                    }()
                };
                return fn_meta
            }
        } else {
            return new Object()
        }
    })());
    if (check_true (complex_lambda_list)){
        return ["=:defglobal",fn_name,["=:fn",["&","=:args"],["=:destructuring_bind",fn_args,"=:args",fn_body]],["=:quote",source_details]]
    } else {
        return ["=:defglobal",fn_name,["=:fn",fn_args,fn_body],["=:quote",source_details]]
    }
};__obj__1["decomp_symbol"]=async function(quoted_sym) {
    let comps;
    comps=(quoted_sym).split("/");
    if (check_true (((comps && comps.length)===1))){
        return await (async function(){
            let __array_op_rval__11=(comps && comps["0"]);
             if (__array_op_rval__11 instanceof Function){
                return await __array_op_rval__11(await (await Environment.get_global("first"))(await (async function(){
                     return await (await Environment.get_global("each"))(await (async function(){
                         return await (await Environment.get_global("describe"))(quoted_sym,true) 
                    })(),"namespace") 
                })()),false) 
            } else {
                return [__array_op_rval__11,await (await Environment.get_global("first"))(await (async function(){
                     return await (await Environment.get_global("each"))(await (async function(){
                         return await (await Environment.get_global("describe"))(quoted_sym,true) 
                    })(),"namespace") 
                })()),false]
            }
        })()
    } else {
        return await (async function(){
            let __array_op_rval__12=(comps && comps["1"]);
             if (__array_op_rval__12 instanceof Function){
                return await __array_op_rval__12((comps && comps["0"]),true) 
            } else {
                return [__array_op_rval__12,(comps && comps["0"]),true]
            }
        })()
    }
};__obj__1["defun_sync"]=async function(name,args,body,meta) {
    let fn_name;
    let fn_args;
    let fn_body;
    let source_details;
    fn_name=name;
    fn_args=args;
    fn_body=body;
    source_details=await (await Environment.get_global("add"))({
        name:await (async function(){
             return await (await Environment.get_global("unquotify"))(name) 
        })(),fn_args:await (await Environment.get_global("as_lisp"))(fn_args)
    },await (async function(){
        if (check_true (meta)){
            return meta
        } else {
            return new Object()
        }
    })());
    return ["=:do",["=:defglobal",fn_name,["=:function",fn_args,fn_body],["=:quote",source_details]]]
};__obj__1["macroexpand"]=async function(quoted_form) {
    let macro_name;
    let working_env;
    let meta;
    let macro_func;
    macro_name=await (async function() { try {
        return await (quoted_form && quoted_form["0"])["substr"].call((quoted_form && quoted_form["0"]),2)
    } catch (__exception__13) {
        if (__exception__13 instanceof Error) {
            let e=__exception__13;
            {
                throw new Error("macroexpand: unable to determine macro: is the form quoted?");
                
            }
        }
    }
})();
working_env=await Environment["get_namespace_handle"].call(Environment,await (await Environment.get_global("current_namespace"))());
meta=await (await Environment.get_global("first"))(await (await Environment.get_global("meta_for_symbol"))(macro_name,true));
macro_func=await working_env["get_global"].call(working_env,((meta && meta["namespace"])+ "/"+ macro_name));
if (check_true ((macro_func instanceof Function&& await (await Environment.get_global("resolve_path"))(["eval_when","compile_time"],meta)))){
    {
        return await (async function(){
            let __apply_args__14=await (async function(){
                 return await quoted_form["slice"].call(quoted_form,1) 
            })();
            return ( macro_func).apply(this,__apply_args__14)
        })()
    }
} else {
    return quoted_form
}
};__obj__1["macroexpand_all"]=async function(quoted_form) {
    return await (await Environment.get_global("detokenize"))(await (async function(){
         return await (await Environment.get_global("tokenize_lisp"))(quoted_form) 
    })())
};__obj__1["check_type"]=async function(thing,type_name,error_string) {
    if (check_true (error_string)){
        return ["=:if",["=:not",["=:==",["=:sub_type",thing],type_name]],["=:throw","=:TypeError",error_string]]
    } else {
        return ["=:if",["=:not",["=:==",["=:sub_type",thing],type_name]],["=:throw","=:TypeError",["=:+","invalid type: required ",type_name," but got ",["=:sub_type",thing]]]]
    }
};__obj__1["get_object_path"]=function(refname) {
        if (check_true ((( refname["indexOf"].call(refname,".")>-1)|| ( refname["indexOf"].call(refname,"[")>-1)))){
            {
                let chars;
                let comps;
                let mode;
                let name_acc;
                chars=(refname).split("");
                comps=[];
                mode=0;
                name_acc=[];
                 ( function() {
                    let __for_body__18=function(c) {
                        return   (function(){
                            if (check_true (((c===".")&& (mode===0)))) {
                                {
                                    if (check_true (((name_acc && name_acc.length)>0))){
                                        {
                                            (comps).push((name_acc).join(""))
                                        }
                                    };
                                    return name_acc=[]
                                }
                            } else if (check_true (((mode===0)&& (c==="[")))) {
                                {
                                    mode=1;
                                    if (check_true (((name_acc && name_acc.length)>0))){
                                        {
                                            (comps).push((name_acc).join(""))
                                        }
                                    };
                                    return name_acc=[]
                                }
                            } else if (check_true (((mode===1)&& (c==="]")))) {
                                {
                                    mode=0;
                                    (comps).push((name_acc).join(""));
                                    return name_acc=[]
                                }
                            } else {
                                return (name_acc).push(c)
                            }
                        } )()
                    };
                    let __array__19=[],__elements__17=chars;
                    let __BREAK__FLAG__=false;
                    for(let __iter__16 in __elements__17) {
                        __array__19.push( __for_body__18(__elements__17[__iter__16]));
                        if(__BREAK__FLAG__) {
                             __array__19.pop();
                            break;
                            
                        }
                    }return __array__19;
                     
                })();
                if (check_true (((name_acc && name_acc.length)>0))){
                    (comps).push((name_acc).join(""))
                };
                return comps
            }
        } else {
            return  ( function(){
                let __array_op_rval__20=refname;
                 if (__array_op_rval__20 instanceof Function){
                    return  __array_op_rval__20() 
                } else {
                    return [__array_op_rval__20]
                }
            })()
        }
    };__obj__1["do_deferred_splice"]=async function(tree) {
    let rval;
    let idx;
    let tval;
    let deferred_operator;
    rval=null;
    idx=0;
    tval=null;
    deferred_operator=(["=","$","&","!"]).join("");
    return await async function(){
        if (check_true ((tree instanceof Array))) {
            {
                rval=[];
                await (async function(){
                     let __test_condition__21=async function() {
                        return (idx<(tree && tree.length))
                    };
                    let __body_ref__22=async function() {
                        tval=tree[idx];
                        if (check_true ((tval===deferred_operator))){
                            {
                                idx+=1;
                                tval=tree[idx];
                                rval=await rval["concat"].call(rval,await (async function(){
                                     return await do_deferred_splice(tval) 
                                })())
                            }
                        } else {
                            (rval).push(await (async function(){
                                 return await do_deferred_splice(tval) 
                            })())
                        };
                        return idx+=1
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__21()) {
                         await __body_ref__22();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                return rval
            }
        } else if (check_true ((tree instanceof Object))) {
            {
                rval=new Object();
                await (async function() {
                    let __for_body__25=async function(pset) {
                        return await async function(){
                            rval[(pset && pset["0"])]=await (async function(){
                                 return await do_deferred_splice((pset && pset["1"])) 
                            })();
                            return rval;
                            
                        }()
                    };
                    let __array__26=[],__elements__24=await (await Environment.get_global("pairs"))(tree);
                    let __BREAK__FLAG__=false;
                    for(let __iter__23 in __elements__24) {
                        __array__26.push(await __for_body__25(__elements__24[__iter__23]));
                        if(__BREAK__FLAG__) {
                             __array__26.pop();
                            break;
                            
                        }
                    }return __array__26;
                     
                })();
                return rval
            }
        } else {
            return tree
        }
    } ()
};__obj__1["define"]=async function(...args) {
    let defs;
    defs=await (await Environment.get_global("slice"))(args,0);
    {
        let acc;
        let symname;
        acc=await (async function(){
             return ["=:progl"] 
        })();
        symname=null;
        await (async function() {
            let __for_body__30=async function(defset) {
                (acc).push(await (async function(){
                     return ["=:defvar",(defset && defset["0"]),(defset && defset["1"])] 
                })());
                symname=(defset && defset["0"]);
                (acc).push(await (async function(){
                     return ["=:set_prop",await (async function(){
                         return "=:Environment.global_ctx.scope" 
                    })(),(""+ await (await Environment.get_global("as_lisp"))(symname)),symname] 
                })());
                if (check_true (((defset && defset["2"]) instanceof Object))){
                    {
                        return (acc).push(await (async function(){
                             return [["=:set_prop",await (async function(){
                                 return "=:Environment.definitions" 
                            })(),(""+ await (await Environment.get_global("as_lisp"))(symname)+ ""),(defset && defset["2"])]] 
                        })())
                    }
                }
            };
            let __array__31=[],__elements__29=defs;
            let __BREAK__FLAG__=false;
            for(let __iter__28 in __elements__29) {
                __array__31.push(await __for_body__30(__elements__29[__iter__28]));
                if(__BREAK__FLAG__) {
                     __array__31.pop();
                    break;
                    
                }
            }return __array__31;
             
        })();
        return acc
    }
};__obj__1["defbinding"]=async function(...args) {
    args=await (await Environment.get_global("slice"))(args,0);
    {
        let binding;
        let acc;
        binding=null;
        acc=await (async function(){
             return ["=:list"] 
        })();
        await (async function() {
            let __for_body__34=async function(bind_set) {
                return await async function(){
                    if (check_true (((bind_set instanceof Array)&& (((bind_set && bind_set.length)===2)|| ((bind_set && bind_set.length)===3))&& ((bind_set && bind_set["1"]) instanceof Array)&& ((bind_set && bind_set["1"] && bind_set["1"]["length"])===2)))) {
                        {
                            binding=await (async function(){
                                 return ["=:quotel",await (async function(){
                                     return ["=:bind",(bind_set && bind_set["1"] && bind_set["1"]["0"]),(bind_set && bind_set["1"] && bind_set["1"]["1"])] 
                                })()] 
                            })();
                            return (acc).push(await (async function(){
                                 return ["=:defglobal",((await Environment.get_global("*namespace*"))+ "/"+ await (async function(){
                                    let mval;
                                    mval=(bind_set && bind_set["0"]);
                                    if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                                        return await mval["substr"].call(mval,2)
                                    } else {
                                        return mval
                                    }
                                })()),await (async function(){
                                     return ["=:bind",(bind_set && bind_set["1"] && bind_set["1"]["0"]),(bind_set && bind_set["1"] && bind_set["1"]["1"])] 
                                })(),await (async function(){
                                    if (check_true (((bind_set && bind_set["2"]) instanceof Object))){
                                        return await (await Environment.get_global("add"))(new Object(),(bind_set && bind_set["2"]),{
                                            initializer:binding
                                        })
                                    } else {
                                        return {
                                            initializer:binding
                                        }
                                    }
                                })()] 
                            })())
                        }
                    } else {
                        throw new SyntaxError("defbinding received malform arguments");
                        
                    }
                } ()
            };
            let __array__35=[],__elements__33=args;
            let __BREAK__FLAG__=false;
            for(let __iter__32 in __elements__33) {
                __array__35.push(await __for_body__34(__elements__33[__iter__32]));
                if(__BREAK__FLAG__) {
                     __array__35.pop();
                    break;
                    
                }
            }return __array__35;
             
        })();
        return acc
    }
};__obj__1["define_env"]=async function(...args) {
    let defs;
    defs=await (await Environment.get_global("slice"))(args,0);
    {
        let acc;
        let symname;
        acc=await (async function(){
             return ["=:progl"] 
        })();
        symname=null;
        await (async function() {
            let __for_body__38=async function(defset) {
                (acc).push(await (async function(){
                     return ["=:defvar",(defset && defset["0"]),(defset && defset["1"])] 
                })());
                symname=(defset && defset["0"]);
                (acc).push(await (async function(){
                     return ["=:set_prop",await (async function(){
                         return "=:Environment.global_ctx.scope" 
                    })(),(""+ await (await Environment.get_global("as_lisp"))(symname)),symname] 
                })());
                if (check_true (((defset && defset["2"]) instanceof Object))){
                    return (acc).push(await (async function(){
                         return [["=:set_prop",await (async function(){
                             return "=:Environment.definitions" 
                        })(),(""+ await (await Environment.get_global("as_lisp"))(symname)+ ""),await (await Environment.get_global("add"))({
                            core_lang:true
                        },(defset && defset["2"]))]] 
                    })())
                } else {
                    return (acc).push(await (async function(){
                         return [["=:set_prop",await (async function(){
                             return "=:Environment.definitions" 
                        })(),(""+ await (await Environment.get_global("as_lisp"))(symname)+ ""),{
                            core_lang:true
                        }]] 
                    })())
                }
            };
            let __array__39=[],__elements__37=defs;
            let __BREAK__FLAG__=false;
            for(let __iter__36 in __elements__37) {
                __array__39.push(await __for_body__38(__elements__37[__iter__36]));
                if(__BREAK__FLAG__) {
                     __array__39.pop();
                    break;
                    
                }
            }return __array__39;
             
        })();
        return acc
    }
};__obj__1["type"]=async function(x) {
    return await async function(){
        if (check_true ((null===x))) {
            return "null"
        } else if (check_true ((undefined===x))) {
            return "undefined"
        } else if (check_true ((x instanceof Array))) {
            return "array"
        } else {
            return typeof x
        }
    } ()
};__obj__1["destructure_list"]=function(elems) {
        let idx;
        let acc;
        let passed_rest;
        let structure;
        let follow_tree;
        idx=0;
        acc=[];
        passed_rest=0;
        structure=elems;
        follow_tree=async function(elems,_path_prefix) {
            return   (function(){
                if (check_true ((passed_rest>0))) {
                    {
                        if (check_true ((passed_rest===1))){
                            (acc).push(_path_prefix)
                        };
                        return passed_rest+=1
                    }
                } else if (check_true ((elems instanceof Array))) {
                    return  ( Environment.get_global("map"))(async function(elem,idx) {
                        return  follow_tree(elem, ( Environment.get_global("add"))(_path_prefix,idx))
                    },elems)
                } else if (check_true ((elems instanceof Object))) {
                    return  ( function() {
                        let __for_body__42=function(pset) {
                            return  follow_tree((pset && pset["1"]), ( Environment.get_global("add"))(_path_prefix,(pset && pset["0"])))
                        };
                        let __array__43=[],__elements__41= ( Environment.get_global("pairs"))(elems);
                        let __BREAK__FLAG__=false;
                        for(let __iter__40 in __elements__41) {
                            __array__43.push( __for_body__42(__elements__41[__iter__40]));
                            if(__BREAK__FLAG__) {
                                 __array__43.pop();
                                break;
                                
                            }
                        }return __array__43;
                         
                    })()
                } else if (check_true (((elems instanceof String || typeof elems==='string')&& ("&"===elems)))) {
                    {
                        passed_rest+=1;
                        return (acc).push(["*",_path_prefix])
                    }
                } else {
                    return (acc).push(_path_prefix)
                }
            } )()
        };
         follow_tree(structure,[]);
        return acc
    };__obj__1["destructuring_bind"]=async function(...args) {
    let bind_vars;
    let expression;
    let forms;
    bind_vars=(args && args["0"]);
    expression=(args && args["1"]);
    forms=await (await Environment.get_global("slice"))(args,2);
    {
        let binding_vars;
        let preamble;
        let allocations;
        let passed_rest;
        let expr_result_var;
        let paths;
        let bound_expression;
        let acc;
        binding_vars=bind_vars;
        preamble=[];
        allocations=[];
        passed_rest=false;
        expr_result_var=("=:"+ "_expr_"+ await (await Environment.get_global("random_int"))(100000));
        paths=await (await Environment.get_global("destructure_list"))(binding_vars);
        bound_expression=await (async function(){
            if (check_true (((expression instanceof Array)&& await (await Environment.get_global("starts_with?"))("=:",(expression && expression["0"]))))){
                {
                    (allocations).push(await (async function(){
                         return [expr_result_var,expression] 
                    })());
                    return expr_result_var
                }
            } else {
                return expression
            }
        })();
        acc=await (async function(){
             return ["=:let"] 
        })();
        await (await Environment.get_global("assert"))(((bind_vars instanceof Array)&& await (async function(){
             return await (await Environment.get_global("is_value?"))(expression) 
        })()&& await (async function(){
             return await (await Environment.get_global("is_value?"))(forms) 
        })()),"destructuring_bind: requires 3 arguments");
        await (async function() {
            let __for_body__46=async function(idx) {
                if (check_true (("*"===await (await Environment.get_global("first"))(paths[idx])))){
                    {
                        (allocations).push(await (async function(){
                             return [await (await Environment.get_global("resolve_path"))(paths[await (await Environment.get_global("add"))(idx,1)],binding_vars),await (async function(){
                                 return await async function(){
                                    if (check_true ((bound_expression instanceof Object))) {
                                        return await (await Environment.get_global("slice"))(bound_expression,idx)
                                    } else {
                                        return ["=:slice",expression,await (await Environment.get_global("first"))(await (await Environment.get_global("second"))(paths[idx]))]
                                    }
                                } () 
                            })()] 
                        })());
                        return __BREAK__FLAG__=true;
                        return
                    }
                } else {
                    {
                        return (allocations).push(await (async function(){
                             return [await (await Environment.get_global("resolve_path"))(paths[idx],binding_vars),await (async function(){
                                 return await async function(){
                                    if (check_true ((bound_expression instanceof Object))) {
                                        return await (await Environment.get_global("resolve_path"))(paths[idx],bound_expression)
                                    } else {
                                        return (await (await Environment.get_global("conj"))(await (async function(){
                                            let __array_op_rval__48=bound_expression;
                                             if (__array_op_rval__48 instanceof Function){
                                                return await __array_op_rval__48() 
                                            } else {
                                                return [__array_op_rval__48]
                                            }
                                        })(),paths[idx])).join(".")
                                    }
                                } () 
                            })()] 
                        })())
                    }
                }
            };
            let __array__47=[],__elements__45=await (await Environment.get_global("range"))(await (await Environment.get_global("length"))(paths));
            let __BREAK__FLAG__=false;
            for(let __iter__44 in __elements__45) {
                __array__47.push(await __for_body__46(__elements__45[__iter__44]));
                if(__BREAK__FLAG__) {
                     __array__47.pop();
                    break;
                    
                }
            }return __array__47;
             
        })();
        (acc).push(allocations);
        acc=await (await Environment.get_global("conj"))(acc,forms);
        return acc
    }
};__obj__1["split_by_recurse"]=function(token,container) {
        return   (function(){
            if (check_true ((container instanceof String || typeof container==='string'))) {
                return (container).split(token)
            } else if (check_true ((container instanceof Array))) {
                return  ( Environment.get_global("map"))(async function(elem) {
                    return  ( Environment.get_global("split_by_recurse"))(token,elem)
                },container)
            }
        } )()
    };__obj__1["defun_sync_ds"]=async function(name,lambda_list,body,meta) {
    let fn_name;
    let fn_args;
    let fn_body;
    let fn_meta;
    let complex_lambda_list;
    let symbol_details;
    let source_details;
    fn_name=name;
    fn_args=lambda_list;
    fn_body=body;
    fn_meta=meta;
    complex_lambda_list=await (async function(){
         return await (await Environment.get_global("or_args"))(await (async function() {
            let __for_body__60=async function(elem) {
                return (await (await Environment.get_global("length"))(await (await Environment.get_global("flatten"))(await (await Environment.get_global("destructure_list"))(elem)))>0)
            };
            let __array__61=[],__elements__59=lambda_list;
            let __BREAK__FLAG__=false;
            for(let __iter__58 in __elements__59) {
                __array__61.push(await __for_body__60(__elements__59[__iter__58]));
                if(__BREAK__FLAG__) {
                     __array__61.pop();
                    break;
                    
                }
            }return __array__61;
             
        })()) 
    })();
    symbol_details=await (async function(){
         return await (await Environment.get_global("decomp_symbol"))(await (async function(){
             return await (await Environment.get_global("unquotify"))(name) 
        })()) 
    })();
    source_details=await (await Environment.get_global("add"))({
        name:(symbol_details && symbol_details["0"]),fn_args:await (await Environment.get_global("as_lisp"))(fn_args)
    },await (async function(){
        if (check_true (fn_meta)){
            {
                if (check_true ((fn_meta && fn_meta["description"]))){
                    await async function(){
                        fn_meta["description"]=(fn_meta && fn_meta["description"]);
                        return fn_meta;
                        
                    }()
                };
                return fn_meta
            }
        } else {
            return new Object()
        }
    })());
    if (check_true (complex_lambda_list)){
        return ["=:defglobal",fn_name,["=:function",["&","=:args"],["=:destructuring_bind",fn_args,"=:args",fn_body]],["=:quote",source_details]]
    } else {
        return ["=:defglobal",fn_name,["=:function",fn_args,fn_body],["=:quote",source_details]]
    }
};__obj__1["no_await"]=async function(form) {
    return ["=:progn",["=:defvar","=:__SYNCF__",true],form]
};__obj__1["reduce"]=async function(...args) {
    let elem;
    let item_list;
    let form;
    elem=(args && args["0"] && args["0"]["0"]);
    item_list=(args && args["0"] && args["0"]["1"]);
    form=(args && args["1"]);
    return ["=:let",[["=:__collector",[]],["=:__result","=:nil"],["=:__action",["=:fn",[].concat(elem),form]]],["=:declare",["=:function","=:__action"]],["=:for_each",["=:__item",item_list],["=:do",["=:=","=:__result",["=:__action","=:__item"]],["=:if","=:__result",["=:push","=:__collector","=:__result"]]]],"=:__collector"]
};__obj__1["reduce_sync"]=async function(...args) {
    let elem;
    let item_list;
    let form;
    elem=(args && args["0"] && args["0"]["0"]);
    item_list=(args && args["0"] && args["0"]["1"]);
    form=(args && args["1"]);
    return ["=:let",[["=:__collector",[]],["=:__result","=:nil"],["=:__action",["=:function",[].concat(elem),form]]],["=:declare",["=:function","=:__action"]],["=:for_each",["=:__item",item_list],["=:do",["=:=","=:__result",["=:__action","=:__item"]],["=:if","=:__result",["=:push","=:__collector","=:__result"]]]],"=:__collector"]
};__obj__1["bind_function"]=function anonymous(func,this_arg
) {
{ return func.bind(this_arg) }
};__obj__1["is_error?"]=function(val) {
        return (val instanceof Error)
    };__obj__1["is_reference?"]=async function(val) {
    return ["=:and",["=:is_string?",val],["=:>",["=:length",val],2],["=:starts_with?",["=:quote","=:"],val]]
};__obj__1["scan_str"]=function(regex,search_string) {
        let result;
        let last_result;
        let totals;
        let strs;
        result=null;
        last_result=null;
        totals=[];
        strs=(""+ search_string);
        if (check_true ( ( Environment.get_global("is_regex?"))(regex))){
            {
                  (function(){
                    regex["lastIndex"]=0;
                    return regex;
                    
                })();
                 ( function(){
                     let __test_condition__64=function() {
                        return ( ( function(){
                            result= regex["exec"].call(regex,strs);
                            return true
                        })()&& result&&  ( function(){
                            if (check_true (last_result)){
                                return  ( Environment.get_global("not"))(((result && result["0"])===(last_result && last_result["0"])))
                            } else {
                                return true
                            }
                        })())
                    };
                    let __body_ref__65=function() {
                        last_result=result;
                        return (totals).push( ( Environment.get_global("to_object"))( ( function() {
                            let __for_body__68=function(v) {
                                return  ( function(){
                                    let __array_op_rval__70=v;
                                     if (__array_op_rval__70 instanceof Function){
                                        return  __array_op_rval__70(result[v]) 
                                    } else {
                                        return [__array_op_rval__70,result[v]]
                                    }
                                })()
                            };
                            let __array__69=[],__elements__67= ( Environment.get_global("keys"))(result);
                            let __BREAK__FLAG__=false;
                            for(let __iter__66 in __elements__67) {
                                __array__69.push( __for_body__68(__elements__67[__iter__66]));
                                if(__BREAK__FLAG__) {
                                     __array__69.pop();
                                    break;
                                    
                                }
                            }return __array__69;
                             
                        })()))
                    };
                    let __BREAK__FLAG__=false;
                    while( __test_condition__64()) {
                          __body_ref__65();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })()
            }
        } else {
            throw new Error(new ReferenceError(("scan_str: invalid RegExp provided: "+ regex)));
            
        };
        return totals
    };__obj__1["remove_prop"]=async function(obj,key) {
    if (check_true (await (await Environment.get_global("not"))((undefined===obj[key])))){
        {
            {
                let val;
                val=obj[key];
                await (await Environment.get_global("delete_prop"))(obj,key);
                return val
            }
        }
    }
};__obj__1["object_methods"]=async function(obj) {
    let properties;
    let current_obj;
    properties=new Set();
    current_obj=obj;
    await (async function(){
         let __body_ref__264=async function() {
            await (await Environment.get_global("map"))(async function(item) {
                return await properties["add"].call(properties,item)
            },await Object.getOwnPropertyNames(current_obj));
            return current_obj=await Object.getPrototypeOf(current_obj)
        };
        let __BREAK__FLAG__=false;
        while(current_obj) { await __body_ref__264();
         if(__BREAK__FLAG__) {
             break;
            
        }
    } ;
    
})();
return await (async function() {
    {
         let __call_target__=await Array.from(await properties["keys"]()), __call_method__="filter";
        return await __call_target__[__call_method__].call(__call_target__,async function(item) {
            return item instanceof Function
        })
    } 
})()
};__obj__1["expand_dot_accessor"]=async function(val,ctx) {
    let comps;
    let find_in_ctx;
    let reference;
    let idx;
    let val_type;
    comps=(val).split(".");
    find_in_ctx=async function(the_ctx) {
        return await async function(){
            if (check_true (await (async function(){
                let __targ__73=(the_ctx && the_ctx["scope"]);
                if (__targ__73){
                     return(__targ__73)[reference]
                } 
            })())) {
                return await (async function(){
                    let __targ__74=(the_ctx && the_ctx["scope"]);
                    if (__targ__74){
                         return(__targ__74)[reference]
                    } 
                })()
            } else if (check_true ((the_ctx && the_ctx["parent"]))) {
                return await find_in_ctx((the_ctx && the_ctx["parent"]))
            }
        } ()
    };
    reference=(comps).shift();
    idx=0;
    val_type=await find_in_ctx(ctx);
    return await async function(){
        if (check_true ((0===(comps && comps.length)))) {
            return reference
        } else if (check_true (((val_type instanceof Object)&& await (await Environment.get_global("contains?"))((comps && comps["0"]),await (async function(){
             return await (await Environment.get_global("object_methods"))(val_type) 
        })())&& await (await Environment.get_global("not"))(await val_type["propertyIsEnumerable"].call(val_type,(comps && comps["0"])))))) {
            return val
        } else {
            return (await (await Environment.get_global("conj"))(await (async function(){
                let __array_op_rval__75=reference;
                 if (__array_op_rval__75 instanceof Function){
                    return await __array_op_rval__75() 
                } else {
                    return [__array_op_rval__75]
                }
            })(),await (await Environment.get_global("flatten"))(await (async function() {
                let __for_body__78=async function(comp) {
                    idx+=1;
                    if (check_true (((idx===1)&& (reference==="this")))){
                        return [".",comp]
                    } else {
                        if (check_true (await (await Environment.get_global("is_number?"))(comp))){
                            return ["[",comp,"]"]
                        } else {
                            return ["[\"",comp,"\"]"]
                        }
                    }
                };
                let __array__79=[],__elements__77=comps;
                let __BREAK__FLAG__=false;
                for(let __iter__76 in __elements__77) {
                    __array__79.push(await __for_body__78(__elements__77[__iter__76]));
                    if(__BREAK__FLAG__) {
                         __array__79.pop();
                        break;
                        
                    }
                }return __array__79;
                 
            })()))).join("")
        }
    } ()
};__obj__1["from_mixed_case"]=function(mixed_case_key) {
        let tokens;
        let acc;
        let ccode;
        tokens= ( function(){
            if (check_true ((mixed_case_key instanceof String || typeof mixed_case_key==='string'))){
                return (mixed_case_key).split("")
            } else {
                throw new TypeError("from_mixed_case: key argument must be a string");
                
            }
        })();
        acc=[];
        ccode=null;
         ( function() {
            let __for_body__82=function(t) {
                ccode= t["charCodeAt"].call(t,0);
                if (check_true (((ccode>=65)&& (ccode<=90)))){
                    {
                        (acc).push("_");
                        return (acc).push((t).toLowerCase())
                    }
                } else {
                    return (acc).push(t)
                }
            };
            let __array__83=[],__elements__81=tokens;
            let __BREAK__FLAG__=false;
            for(let __iter__80 in __elements__81) {
                __array__83.push( __for_body__82(__elements__81[__iter__80]));
                if(__BREAK__FLAG__) {
                     __array__83.pop();
                    break;
                    
                }
            }return __array__83;
             
        })();
        return (acc).join("")
    };__obj__1["to_mixed_case"]=function(snake_case_key) {
        let tokens;
        let acc;
        let upmode;
        tokens= ( function(){
            if (check_true ((snake_case_key instanceof String || typeof snake_case_key==='string'))){
                return (snake_case_key).split("")
            } else {
                throw new TypeError("to_mixed_case: key argument must be a string");
                
            }
        })();
        acc=[];
        upmode=false;
         ( function() {
            let __for_body__86=function(t) {
                return   (function(){
                    if (check_true ((t==="_"))) {
                        return upmode=true
                    } else if (check_true (upmode)) {
                        {
                            (acc).push((t).toUpperCase());
                            return upmode=false
                        }
                    } else {
                        return (acc).push(t)
                    }
                } )()
            };
            let __array__87=[],__elements__85=tokens;
            let __BREAK__FLAG__=false;
            for(let __iter__84 in __elements__85) {
                __array__87.push( __for_body__86(__elements__85[__iter__84]));
                if(__BREAK__FLAG__) {
                     __array__87.pop();
                    break;
                    
                }
            }return __array__87;
             
        })();
        return (acc).join("")
    };__obj__1["new_ctx"]=async function(ctx) {
    let __new_ctx__88= async function(){
        return {
            scope:new Object(),parent:null
        }
    };
    {
        let new_ctx=await __new_ctx__88();
        ;
        if (check_true (ctx)){
            {
                await async function(){
                    new_ctx["parent"]=ctx;
                    return new_ctx;
                    
                }()
            }
        };
        return new_ctx
    }
};__obj__1["getf_ctx"]=async function(ctx,name,_value) {
    if (check_true ((ctx&& (name instanceof String || typeof name==='string')))){
        return await async function(){
            if (check_true (await (await Environment.get_global("not"))((undefined===await (async function(){
                let __targ__90=(ctx && ctx["scope"]);
                if (__targ__90){
                     return(__targ__90)[name]
                } 
            })())))) {
                if (check_true (await (await Environment.get_global("not"))((_value===undefined)))){
                    {
                        await async function(){
                            let __target_obj__91=(ctx && ctx["scope"]);
                            __target_obj__91[name]=_value;
                            return __target_obj__91;
                            
                        }();
                        return _value
                    }
                } else {
                    return await (async function(){
                        let __targ__92=(ctx && ctx["scope"]);
                        if (__targ__92){
                             return(__targ__92)[name]
                        } 
                    })()
                }
            } else if (check_true ((ctx && ctx["parent"]))) {
                return await (await Environment.get_global("getf_ctx"))((ctx && ctx["parent"]),name,_value)
            } else {
                return undefined
            }
        } ()
    } else {
        throw new Error("invalid call to getf_ctx: missing argument/s");
        
    }
};__obj__1["setf_ctx"]=async function(ctx,name,value) {
    let found_val;
    found_val=await (async function(){
         return await (await Environment.get_global("getf_ctx"))(ctx,name,value) 
    })();
    if (check_true ((found_val===undefined))){
        await async function(){
            let __target_obj__93=(ctx && ctx["scope"]);
            __target_obj__93[name]=value;
            return __target_obj__93;
            
        }()
    };
    return value
};__obj__1["set_path"]=async function(path,obj,value) {
    let fpath;
    let idx;
    let rpath;
    let target_obj;
    fpath=await (async function(){
         return await clone(path) 
    })();
    idx=(fpath).pop();
    rpath=fpath;
    target_obj=null;
    target_obj=await (await Environment.get_global("resolve_path"))(rpath,obj);
    if (check_true (target_obj)){
        {
            return await async function(){
                target_obj[idx]=value;
                return target_obj;
                
            }()
        }
    } else {
        throw new RangeError(("set_path: invalid path: "+ path));
        
    }
};__obj__1["make_path"]=async function(target_path,root_obj,value,_pos) {
    let segment;
    let cval;
    let pos;
    target_path=await (async function(){
        if (check_true (_pos)){
            return target_path
        } else {
            return await clone(target_path)
        }
    })();
    segment=(target_path).shift();
    cval=null;
    pos=(_pos|| []);
    (pos).push(segment);
    return await async function(){
        if (check_true (((target_path && target_path.length)===0))) {
            {
                await (await Environment.get_global("set_path"))(pos,root_obj,value);
                return value
            }
        } else if (check_true (cval=await (await Environment.get_global("resolve_path"))(pos,root_obj))) {
            return await async function(){
                if (check_true (((cval instanceof Object)&& ((null==cval[await (await Environment.get_global("first"))(target_path)])|| (cval[await (await Environment.get_global("first"))(target_path)] instanceof Object)|| ((target_path && target_path.length)===1))))) {
                    return await (await Environment.get_global("make_path"))(target_path,root_obj,value,pos)
                } else {
                    throw new TypeError(("make_path: non-object encountered at "+ await (await Environment.get_global("as_lisp"))(await (await Environment.get_global("add"))(pos,await (await Environment.get_global("first"))(target_path)))));
                    
                }
            } ()
        } else {
            {
                await (await Environment.get_global("set_path"))(pos,root_obj,new Object());
                return await (await Environment.get_global("make_path"))(target_path,root_obj,value,pos)
            }
        }
    } ()
};__obj__1["minmax"]=async function(container) {
    let value_found=false;
    ;
    let smallest=(await Environment.get_global("MAX_SAFE_INTEGER"));
    ;
    let biggest=(-1* (await Environment.get_global("MAX_SAFE_INTEGER")));
    ;
    if (check_true ((container&& (container instanceof Array)&& (await (await Environment.get_global("length"))(container)>0)))){
        {
            await (async function() {
                let __for_body__25=async function(value) {
                    return (await (await Environment.get_global("is_number?"))(value)&& await (async function(){
                        value_found=true;
                        smallest=await Math.min(value,smallest);
                        return biggest=await Math.max(value,biggest)
                    })())
                };
                let __array__26=[],__elements__24=container;
                let __BREAK__FLAG__=false;
                for(let __iter__23 in __elements__24) {
                    __array__26.push(await __for_body__25(__elements__24[__iter__23]));
                    if(__BREAK__FLAG__) {
                         __array__26.pop();
                        break;
                        
                    }
                }return __array__26;
                 
            })();
            if (check_true (value_found)){
                return await (async function(){
                    let __array_op_rval__27=smallest;
                     if (__array_op_rval__27 instanceof Function){
                        return await __array_op_rval__27(biggest) 
                    } else {
                        return [__array_op_rval__27,biggest]
                    }
                })()
            } else {
                return null
            }
        }
    } else {
        return null
    }
};__obj__1["aif"]=async function(test_expr,eval_when_true,eval_when_false) {
    return ["=:let",[["=:it",test_expr]],["=:if","=:it",eval_when_true,eval_when_false]]
};__obj__1["ifa"]=async function(test,thenclause,elseclause) {
    return ["=:let",[["=:it",test]],["=:if","=:it",thenclause,elseclause]]
};__obj__1["map_range"]=function(n,from_range,to_range) {
        ;
        return ((to_range && to_range["0"])+ (((n- (from_range && from_range["0"]))/ ((from_range && from_range["1"])- (from_range && from_range["0"])))* ((to_range && to_range["1"])- (to_range && to_range["0"]))))
    };__obj__1["range_inc"]=function(start,end,step) {
        if (check_true (end)){
            return  ( Environment.get_global("range"))(start, ( Environment.get_global("add"))(end,1),step)
        } else {
            return  ( Environment.get_global("range"))( ( Environment.get_global("add"))(start,1))
        }
    };__obj__1["HSV_to_RGB"]=async function(h,s,v) {
     {
             var r, g, b, i, f, p, q, t;
             if (arguments.length === 1) {
                s = h.s, v = h.v, h = h.h;
             }
             i = Math.floor(h * 6);
             f = h * 6 - i;
             p = v * (1 - s);
             q = v * (1 - f * s);
             t = v * (1 - (1 - f) * s);
             switch (i % 6) {
                              case 0: r = v, g = t, b = p; break;
                              case 1: r = q, g = v, b = p; break;
                              case 2: r = p, g = v, b = t; break;
                              case 3: r = p, g = q, b = v; break;
                              case 4: r = t, g = p, b = v; break;
                              case 5: r = v, g = p, b = q; break;
                              }
             return {
                      r: Math.round(r * 255),
                      g: Math.round(g * 255),
                      b: Math.round(b * 255)
                      }
             } 
};__obj__1["color_for_number"]=async function(num,saturation,brightness) {
    let h;
    let pos;
    let color_key;
    let rgb;
    let v;
    h=await Math.abs(await parseInt(num));
    pos=(8% h);
    color_key=[0,4,1,5,2,6,3,7];
    rgb=null;
    v=color_key[pos];
    ;
    h=await (await Environment.get_global("map_range"))((360% (28* h)),[0,360],[0,1]);
    v=await (await Environment.get_global("map_range"))([v,[0,7],[0.92,1]]);
    rgb=await (async function(){
         return await (await Environment.get_global("HSV_to_RGB"))(h,saturation,brightness) 
    })();
    return ("#"+ await (async function() {
        {
             let __call_target__=await (rgb && rgb["r"])["toString"].call((rgb && rgb["r"]),16), __call_method__="padStart";
            return await __call_target__[__call_method__].call(__call_target__,2,"0")
        } 
    })()+ await (async function() {
        {
             let __call_target__=await (rgb && rgb["g"])["toString"].call((rgb && rgb["g"]),16), __call_method__="padStart";
            return await __call_target__[__call_method__].call(__call_target__,2,"0")
        } 
    })()+ await (async function() {
        {
             let __call_target__=await (rgb && rgb["b"])["toString"].call((rgb && rgb["b"]),16), __call_method__="padStart";
            return await __call_target__[__call_method__].call(__call_target__,2,"0")
        } 
    })())
};__obj__1["flatten_ctx"]=async function(ctx,_var_table) {
    let var_table;
    let ctx_keys;
    var_table=(_var_table|| new Object());
    ctx_keys=await (await Environment.get_global("keys"))(var_table);
    if (check_true ((ctx && ctx["scope"]))){
        {
            await (async function() {
                let __for_body__102=async function(k) {
                    if (check_true (await (await Environment.get_global("not"))(await (await Environment.get_global("contains?"))(k,ctx_keys)))){
                        {
                            return await async function(){
                                var_table[k]=await (async function(){
                                    let __targ__105=(ctx && ctx["scope"]);
                                    if (__targ__105){
                                         return(__targ__105)[k]
                                    } 
                                })();
                                return var_table;
                                
                            }()
                        }
                    }
                };
                let __array__103=[],__elements__101=await (await Environment.get_global("keys"))((ctx && ctx["scope"]));
                let __BREAK__FLAG__=false;
                for(let __iter__100 in __elements__101) {
                    __array__103.push(await __for_body__102(__elements__101[__iter__100]));
                    if(__BREAK__FLAG__) {
                         __array__103.pop();
                        break;
                        
                    }
                }return __array__103;
                 
            })();
            if (check_true ((ctx && ctx["parent"]))){
                {
                    await (await Environment.get_global("flatten_ctx"))((ctx && ctx["parent"]),var_table)
                }
            };
            return var_table
        }
    }
};__obj__1["identify_symbols"]=async function(quoted_form,_state) {
    let acc;
    acc=[];
    _state=await (async function(){
        if (check_true (_state)){
            return _state
        } else {
            return new Object()
        }
    })();
    debugger;
    ;
    await async function(){
        if (check_true ((quoted_form instanceof Array))) {
            {
                return await (async function() {
                    let __for_body__108=async function(elem) {
                        return (acc).push(await (async function(){
                             return await (await Environment.get_global("identify_symbols"))(elem,_state) 
                        })())
                    };
                    let __array__109=[],__elements__107=quoted_form;
                    let __BREAK__FLAG__=false;
                    for(let __iter__106 in __elements__107) {
                        __array__109.push(await __for_body__108(__elements__107[__iter__106]));
                        if(__BREAK__FLAG__) {
                             __array__109.pop();
                            break;
                            
                        }
                    }return __array__109;
                     
                })()
            }
        } else if (check_true (((quoted_form instanceof String || typeof quoted_form==='string')&& await (await Environment.get_global("starts_with?"))("=:",quoted_form)))) {
            (acc).push({
                name:await (await Environment.get_global("as_lisp"))(quoted_form),where:await (async function(){
                     return await (await Environment.get_global("describe"))(await (await Environment.get_global("as_lisp"))(quoted_form)) 
                })()
            })
        } else if (check_true ((quoted_form instanceof Object))) {
            await (async function() {
                let __for_body__112=async function(elem) {
                    return (acc).push(await (async function(){
                         return await (await Environment.get_global("identify_symbols"))(elem,_state) 
                    })())
                };
                let __array__113=[],__elements__111=await (await Environment.get_global("values"))(quoted_form);
                let __BREAK__FLAG__=false;
                for(let __iter__110 in __elements__111) {
                    __array__113.push(await __for_body__112(__elements__111[__iter__110]));
                    if(__BREAK__FLAG__) {
                         __array__113.pop();
                        break;
                        
                    }
                }return __array__113;
                 
            })()
        }
    } ();
    return ["=:quote",acc]
};__obj__1["unless"]=async function(...args) {
    let condition;
    let forms;
    condition=(args && args["0"]);
    forms=await (await Environment.get_global("slice"))(args,1);
    return ["=:if",["=:not",condition],["=:do",].concat(forms)]
};__obj__1["use_quoted_initializer"]=async function(...args) {
    let forms;
    forms=await (await Environment.get_global("slice"))(args,0);
    {
        let insert_initializer;
        insert_initializer=async function(form) {
            let meta=form[3];
            ;
            if (check_true ((null==form[3]))){
                meta=await async function(){
                    form[3]=new Object();
                    return form;
                    
                }()
            };
            return await async function(){
                if (check_true (((meta instanceof Array)&& (await (await Environment.get_global("resolve_path"))([3,1],form) instanceof Object)))) {
                    {
                        await (await Environment.get_global("set_path"))([3,1,"initializer"],form,await (async function(){
                             return ["=:quotel",await (async function(){
                                 return ["=:try",(form && form["2"]),["=:catch","=:Error",["=:e"],"=:e"]] 
                            })()] 
                        })());
                        return form
                    }
                } else if (check_true ((meta instanceof Object))) {
                    {
                        await async function(){
                            let __target_obj__115=(form && form["3"]);
                            __target_obj__115["initializer"]=await (async function(){
                                 return ["=:quotel",await (async function(){
                                     return ["=:try",(form && form["2"]),["=:catch","=:Error",["=:e"],"=:e"]] 
                                })()] 
                            })();
                            return __target_obj__115;
                            
                        }();
                        return form
                    }
                } else {
                    {
                        await (await Environment.get_global("warn"))("use_quoted_initializer: cannot quote ",await (async function(){
                            if (check_true (((form && form["2"]) instanceof String || typeof (form && form["2"])==='string'))){
                                return (form && form["2"])
                            } else {
                                return form
                            }
                        })());
                        return form
                    }
                }
            } ()
        };
        return await (async function() {
            let __for_body__118=async function(form) {
                form=await (async function(){
                     return await (await Environment.get_global("macroexpand"))(form) 
                })();
                if (check_true (((form instanceof Array)&& ((form && form["0"])==="=:defglobal")))){
                    {
                        return await insert_initializer(form)
                    }
                } else {
                    return form
                }
            };
            let __array__119=[],__elements__117=forms;
            let __BREAK__FLAG__=false;
            for(let __iter__116 in __elements__117) {
                __array__119.push(await __for_body__118(__elements__117[__iter__116]));
                if(__BREAK__FLAG__) {
                     __array__119.pop();
                    break;
                    
                }
            }return __array__119;
             
        })()
    }
};__obj__1["but_last"]=function(arr) {
        if (check_true ((arr instanceof Array))){
            return  ( Environment.get_global("slice"))(arr,0,((arr && arr.length)- 1))
        } else {
            throw new TypeError(("but_last: expected array, but received "+  ( Environment.get_global("sub_type"))(arr)));
            
        }
    };__obj__1["random_int"]=function(...args) {
        let top;
        let bottom;
        top=0;
        bottom=0;
        if (check_true (( ( Environment.get_global("length"))(args)>1))){
            {
                top= parseInt((args && args["1"]));
                bottom= parseInt((args && args["0"]))
            }
        } else {
            top= parseInt((args && args["0"]))
        };
        return  parseInt( ( Environment.get_global("add"))(( Math.random()* (top- bottom)),bottom))
    };__obj__1["resolve_multi_path"]=function(path,obj,not_found) {
        return   (function(){
            if (check_true ((obj instanceof Object))) {
                return   (function(){
                    if (check_true ((( ( Environment.get_global("length"))(path)===1)&& ("*"=== ( Environment.get_global("first"))(path))))) {
                        return (obj|| not_found)
                    } else if (check_true ((( ( Environment.get_global("length"))(path)===1)&& (obj[ ( Environment.get_global("first"))(path)] instanceof Object)))) {
                        return (obj[ ( Environment.get_global("first"))(path)]|| not_found)
                    } else if (check_true ((( ( Environment.get_global("length"))(path)===1)&&  ( Environment.get_global("not"))((obj[ ( Environment.get_global("first"))(path)] instanceof Object))&&  ( Environment.get_global("not"))((null==obj[ ( Environment.get_global("first"))(path)]))))) {
                        return obj[ ( Environment.get_global("first"))(path)]
                    } else if (check_true (((obj instanceof Array)&& ("*"=== ( Environment.get_global("first"))(path))))) {
                        return  ( function() {
                            let __for_body__122=function(val) {
                                return  ( Environment.get_global("resolve_multi_path"))( ( Environment.get_global("rest"))(path),val,not_found)
                            };
                            let __array__123=[],__elements__121=obj;
                            let __BREAK__FLAG__=false;
                            for(let __iter__120 in __elements__121) {
                                __array__123.push( __for_body__122(__elements__121[__iter__120]));
                                if(__BREAK__FLAG__) {
                                     __array__123.pop();
                                    break;
                                    
                                }
                            }return __array__123;
                             
                        })()
                    } else if (check_true (((obj instanceof Object)&& ("*"=== ( Environment.get_global("first"))(path))))) {
                        return  ( function() {
                            let __for_body__126=function(val) {
                                return  ( Environment.get_global("resolve_multi_path"))( ( Environment.get_global("rest"))(path),val,not_found)
                            };
                            let __array__127=[],__elements__125= ( Environment.get_global("values"))(obj);
                            let __BREAK__FLAG__=false;
                            for(let __iter__124 in __elements__125) {
                                __array__127.push( __for_body__126(__elements__125[__iter__124]));
                                if(__BREAK__FLAG__) {
                                     __array__127.pop();
                                    break;
                                    
                                }
                            }return __array__127;
                             
                        })()
                    } else if (check_true (( ( Environment.get_global("length"))(path)>1))) {
                        return  ( Environment.get_global("resolve_multi_path"))( ( Environment.get_global("rest"))(path),obj[ ( Environment.get_global("first"))(path)],not_found)
                    }
                } )()
            } else {
                return not_found
            }
        } )()
    };__obj__1["delete_path"]=function(path,obj) {
        let mpath;
        let key;
        let place_path;
        let place;
        mpath= ( function(){
             return  clone(path) 
        })();
        key=(mpath).pop();
        place_path=mpath;
        place=null;
        if (check_true ( ( Environment.get_global("not"))((path instanceof Array)))){
            {
                throw new TypeError("path must be an array when provided to delete_path");
                
            }
        };
        if (check_true ( ( Environment.get_global("not"))((obj instanceof Object)))){
            {
                throw new TypeError("Invalid object provided to delete_path");
                
            }
        };
        return   (function(){
            if (check_true ((( ( Environment.get_global("length"))(place_path)===0)&&  ( function(){
                 return  ( Environment.get_global("is_value?"))(key) 
            })()))) {
                {
                     ( Environment.get_global("delete_prop"))(obj,key);
                    return obj
                }
            } else if (check_true ((( ( Environment.get_global("length"))(place_path)>0)&&  ( function(){
                 return  ( Environment.get_global("is_value?"))(key) 
            })()))) {
                {
                    place= ( Environment.get_global("resolve_path"))(place_path,obj);
                    if (check_true ((place instanceof Object))){
                        {
                             ( Environment.get_global("delete_prop"))(place,key)
                        }
                    };
                    return obj
                }
            } else {
                throw new TypeError("delete_path: invalid path or object provided");
                
            }
        } )()
    };__obj__1["symbol_tree"]=async function(quoted_form,_state,_current_path) {
    let acc;
    let allocators;
    let uop;
    let get_allocations;
    let idx;
    let fval;
    let sym_paths;
    let is_root;
    acc=[];
    allocators={
        let:await (async function(){
             return [[1,"*",0]] 
        })(),defun:await (async function(){
             return [[1],[2,"*"]] 
        })()
    };
    uop=null;
    get_allocations=async function() {
        sym_paths=allocators[await (async function(){
             return await (await Environment.get_global("unquotify"))((quoted_form && quoted_form["0"])) 
        })()];
        if (check_true (sym_paths)){
            {
                return await (async function() {
                    let __for_body__130=async function(sym_path) {
                        fval=await (await Environment.get_global("resolve_multi_path"))(sym_path,quoted_form);
                        await console.log("Fval is: ",fval,"sym_path: ",sym_path,"current_path: ",_current_path," ",quoted_form);
                        uop=await (async function(){
                             return await (await Environment.get_global("unquotify"))((quoted_form && quoted_form["0"])) 
                        })();
                        if (check_true ((fval instanceof Array))){
                            return await (async function() {
                                let __for_body__134=async function(s) {
                                    s=await (async function(){
                                         return await (await Environment.get_global("unquotify"))(s) 
                                    })();
                                    if (check_true ((null==await (async function(){
                                        let __targ__136=(_state && _state["definitions"]);
                                        if (__targ__136){
                                             return(__targ__136)[fval]
                                        } 
                                    })()))){
                                        {
                                            await async function(){
                                                let __target_obj__137=(_state && _state["definitions"]);
                                                __target_obj__137[s]=[];
                                                return __target_obj__137;
                                                
                                            }()
                                        }
                                    };
                                    return (await (async function(){
                                        let __targ__138=(_state && _state["definitions"]);
                                        if (__targ__138){
                                             return(__targ__138)[s]
                                        } 
                                    })()).push({
                                        path:_current_path,op:uop
                                    })
                                };
                                let __array__135=[],__elements__133=fval;
                                let __BREAK__FLAG__=false;
                                for(let __iter__132 in __elements__133) {
                                    __array__135.push(await __for_body__134(__elements__133[__iter__132]));
                                    if(__BREAK__FLAG__) {
                                         __array__135.pop();
                                        break;
                                        
                                    }
                                }return __array__135;
                                 
                            })()
                        } else {
                            {
                                if (check_true ((null==await (async function(){
                                    let __targ__139=(_state && _state["definitions"]);
                                    if (__targ__139){
                                         return(__targ__139)[fval]
                                    } 
                                })()))){
                                    {
                                        await async function(){
                                            let __target_obj__140=(_state && _state["definitions"]);
                                            __target_obj__140[fval]=[];
                                            return __target_obj__140;
                                            
                                        }()
                                    }
                                };
                                return (await (async function(){
                                    let __targ__141=(_state && _state["definitions"]);
                                    if (__targ__141){
                                         return(__targ__141)[fval]
                                    } 
                                })()).push({
                                    path:_current_path,op:uop
                                })
                            }
                        }
                    };
                    let __array__131=[],__elements__129=sym_paths;
                    let __BREAK__FLAG__=false;
                    for(let __iter__128 in __elements__129) {
                        __array__131.push(await __for_body__130(__elements__129[__iter__128]));
                        if(__BREAK__FLAG__) {
                             __array__131.pop();
                            break;
                            
                        }
                    }return __array__131;
                     
                })()
            }
        }
    };
    idx=-1;
    fval=null;
    sym_paths=null;
    is_root=await (async function(){
        if (check_true ((_state==undefined))){
            return true
        } else {
            return false
        }
    })();
    _state=await (async function(){
        if (check_true (_state)){
            return _state
        } else {
            return {
                definitions:new Object()
            }
        }
    })();
    _current_path=(_current_path|| []);
    ;
    await console.log("symbol_tree: quoted_form: ",quoted_form,_current_path);
    await get_allocations();
    return await async function(){
        if (check_true ((quoted_form instanceof Array))) {
            {
                await (await Environment.get_global("map"))(async function(elem,idx) {
                    {
                        let it;
                        it=await (async function(){
                             return await (await Environment.get_global("symbol_tree"))(elem,_state,await (await Environment.get_global("conj"))(_current_path,idx)) 
                        })();
                        if (check_true (it)){
                            return (acc).push(it)
                        } else {
                            return 
                        }
                    }
                },quoted_form);
                if (check_true (is_root)){
                    return await (await Environment.get_global("add"))({
                        tree:acc
                    },_state)
                } else {
                    return acc
                }
            }
        } else if (check_true (((quoted_form instanceof String || typeof quoted_form==='string')&& await (await Environment.get_global("starts_with?"))("=:",quoted_form)))) {
            {
                return await (await Environment.get_global("unquotify"))(quoted_form)
            }
        } else if (check_true ((quoted_form instanceof Object))) {
            {
                await (async function() {
                    let __for_body__144=async function(pset) {
                        {
                            let it;
                            it=await (async function(){
                                 return await (await Environment.get_global("symbol_tree"))((pset && pset["1"]),_state,await (await Environment.get_global("conj"))(_current_path,await (async function(){
                                    let __array_op_rval__146=(pset && pset["1"]);
                                     if (__array_op_rval__146 instanceof Function){
                                        return await __array_op_rval__146() 
                                    } else {
                                        return [__array_op_rval__146]
                                    }
                                })())) 
                            })();
                            if (check_true (it)){
                                return (acc).push(it)
                            } else {
                                return 
                            }
                        }
                    };
                    let __array__145=[],__elements__143=await (await Environment.get_global("pairs"))(quoted_form);
                    let __BREAK__FLAG__=false;
                    for(let __iter__142 in __elements__143) {
                        __array__145.push(await __for_body__144(__elements__143[__iter__142]));
                        if(__BREAK__FLAG__) {
                             __array__145.pop();
                            break;
                            
                        }
                    }return __array__145;
                     
                })();
                if (check_true (is_root)){
                    return await (await Environment.get_global("add"))({
                        tree:acc
                    },_state)
                } else {
                    return acc
                }
            }
        }
    } ()
};__obj__1["except_nil"]=async function(items) {
    let acc=[];
    ;
    if (check_true (await (await Environment.get_global("not"))((await (await Environment.get_global("sub_type"))(items)==="array")))){
        items=[items]
    };
    await (async function() {
        let __for_body__61=async function(value) {
            if (check_true (await (await Environment.get_global("not"))((null==value)))){
                return (acc).push(value)
            }
        };
        let __array__62=[],__elements__60=items;
        let __BREAK__FLAG__=false;
        for(let __iter__59 in __elements__60) {
            __array__62.push(await __for_body__61(__elements__60[__iter__59]));
            if(__BREAK__FLAG__) {
                 __array__62.pop();
                break;
                
            }
        }return __array__62;
         
    })();
    return acc
};__obj__1["each"]=async function(items,property) {
    return await async function(){
        if (check_true (((property instanceof String || typeof property==='string')|| await (await Environment.get_global("is_number?"))(property)))) {
            return await (await Environment.get_global("except_nil"))(await (async function() {
                let __for_body__153=async function(item) {
                    if (check_true (item)){
                        {
                            return item[property]
                        }
                    }
                };
                let __array__154=[],__elements__152=(items|| []);
                let __BREAK__FLAG__=false;
                for(let __iter__151 in __elements__152) {
                    __array__154.push(await __for_body__153(__elements__152[__iter__151]));
                    if(__BREAK__FLAG__) {
                         __array__154.pop();
                        break;
                        
                    }
                }return __array__154;
                 
            })())
        } else if (check_true ((await (await Environment.get_global("sub_type"))(property)=="array"))) {
            {
                let __collector;
                let __result;
                let __action;
                __collector=[];
                __result=null;
                __action=async function(item) {
                    let nl=[];
                    ;
                    await (async function() {
                        let __for_body__157=async function(p) {
                            return await async function(){
                                if (check_true ((p instanceof Array))) {
                                    return (nl).push(await (await Environment.get_global("resolve_path"))(p,item))
                                } else if (check_true (p instanceof Function)) {
                                    return (nl).push(await (async function(){
                                        let __array_op_rval__159=p;
                                         if (__array_op_rval__159 instanceof Function){
                                            return await __array_op_rval__159(item) 
                                        } else {
                                            return [__array_op_rval__159,item]
                                        }
                                    })())
                                } else {
                                    return (nl).push(item[p])
                                }
                            } ()
                        };
                        let __array__158=[],__elements__156=property;
                        let __BREAK__FLAG__=false;
                        for(let __iter__155 in __elements__156) {
                            __array__158.push(await __for_body__157(__elements__156[__iter__155]));
                            if(__BREAK__FLAG__) {
                                 __array__158.pop();
                                break;
                                
                            }
                        }return __array__158;
                         
                    })();
                    return nl
                };
                ;
                await (async function() {
                    let __for_body__162=async function(__item) {
                        __result=await __action(__item);
                        if (check_true (__result)){
                            return (__collector).push(__result)
                        }
                    };
                    let __array__163=[],__elements__161=items;
                    let __BREAK__FLAG__=false;
                    for(let __iter__160 in __elements__161) {
                        __array__163.push(await __for_body__162(__elements__161[__iter__160]));
                        if(__BREAK__FLAG__) {
                             __array__163.pop();
                            break;
                            
                        }
                    }return __array__163;
                     
                })();
                return __collector
            }
        } else if (check_true ((await (await Environment.get_global("sub_type"))(property)=="AsyncFunction"))) {
            {
                let __collector;
                let __result;
                let __action;
                __collector=[];
                __result=null;
                __action=async function(item) {
                    return await (async function(){
                        let __array_op_rval__164=property;
                         if (__array_op_rval__164 instanceof Function){
                            return await __array_op_rval__164(item) 
                        } else {
                            return [__array_op_rval__164,item]
                        }
                    })()
                };
                ;
                await (async function() {
                    let __for_body__167=async function(__item) {
                        __result=await __action(__item);
                        if (check_true (__result)){
                            return (__collector).push(__result)
                        }
                    };
                    let __array__168=[],__elements__166=items;
                    let __BREAK__FLAG__=false;
                    for(let __iter__165 in __elements__166) {
                        __array__168.push(await __for_body__167(__elements__166[__iter__165]));
                        if(__BREAK__FLAG__) {
                             __array__168.pop();
                            break;
                            
                        }
                    }return __array__168;
                     
                })();
                return __collector
            }
        } else if (check_true ((await (await Environment.get_global("sub_type"))(property)=="Function"))) {
            {
                let __collector;
                let __result;
                let __action;
                __collector=[];
                __result=null;
                __action=async function(item) {
                    return await (async function(){
                        let __array_op_rval__169=property;
                         if (__array_op_rval__169 instanceof Function){
                            return await __array_op_rval__169(item) 
                        } else {
                            return [__array_op_rval__169,item]
                        }
                    })()
                };
                ;
                await (async function() {
                    let __for_body__172=async function(__item) {
                        __result=await __action(__item);
                        if (check_true (__result)){
                            return (__collector).push(__result)
                        }
                    };
                    let __array__173=[],__elements__171=items;
                    let __BREAK__FLAG__=false;
                    for(let __iter__170 in __elements__171) {
                        __array__173.push(await __for_body__172(__elements__171[__iter__170]));
                        if(__BREAK__FLAG__) {
                             __array__173.pop();
                            break;
                            
                        }
                    }return __array__173;
                     
                })();
                return __collector
            }
        } else {
            throw new TypeError(("each: strings, arrays, and functions can be provided for the property name or names to extract - received: "+ await (await Environment.get_global("sub_type"))(property)));
            
        }
    } ()
};__obj__1["replace"]=function(...args) {
        if (check_true (((args && args.length)<3))){
            throw new SyntaxError("Invalid syntax for replace: requires at least three arguments, target value or regex, the replacement value, and at least one value (object list or string)");
            
        } else {
            try {
                {
                    let target;
                    let replacement;
                    let work_values;
                    let value_type;
                    let sr_val;
                    let arg_value_type;
                    let rval;
                    target=(args && args["0"]);
                    replacement=(args && args["1"]);
                    work_values= ( Environment.get_global("slice"))(args,2);
                    value_type=null;
                    sr_val=null;
                    arg_value_type= subtype((args && args["2"]));
                    rval=[];
                     ( function() {
                        let __for_body__177=function(value) {
                            value_type= subtype(value);
                            if (check_true ((value_type==="Number"))){
                                {
                                    value_type="String";
                                    value=(""+ value)
                                }
                            };
                            return   (function(){
                                if (check_true ((value_type==="String"))) {
                                    return (rval).push( value["replace"].call(value,target,replacement))
                                } else if (check_true ((value_type==="array"))) {
                                    return  ( function() {
                                        let __for_body__181=function(elem) {
                                            return (rval).push( ( Environment.get_global("replace"))(target,replacement,elem))
                                        };
                                        let __array__182=[],__elements__180=value;
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__179 in __elements__180) {
                                            __array__182.push( __for_body__181(__elements__180[__iter__179]));
                                            if(__BREAK__FLAG__) {
                                                 __array__182.pop();
                                                break;
                                                
                                            }
                                        }return __array__182;
                                         
                                    })()
                                } else if (check_true ((value_type==="object"))) {
                                    {
                                        sr_val=new Object();
                                         ( function() {
                                            let __for_body__185=function(k) {
                                                if (check_true ( value["hasOwnProperty"].call(value,k))){
                                                    {
                                                        return   (function(){
                                                            sr_val[k]= ( Environment.get_global("replace"))(target,replacement,value[k]);
                                                            return sr_val;
                                                            
                                                        })()
                                                    }
                                                }
                                            };
                                            let __array__186=[],__elements__184= ( Environment.get_global("keys"))(value);
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__183 in __elements__184) {
                                                __array__186.push( __for_body__185(__elements__184[__iter__183]));
                                                if(__BREAK__FLAG__) {
                                                     __array__186.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__186;
                                             
                                        })();
                                        return rval= rval["concat"].call(rval,sr_val)
                                    }
                                }
                            } )()
                        };
                        let __array__178=[],__elements__176=work_values;
                        let __BREAK__FLAG__=false;
                        for(let __iter__175 in __elements__176) {
                            __array__178.push( __for_body__177(__elements__176[__iter__175]));
                            if(__BREAK__FLAG__) {
                                 __array__178.pop();
                                break;
                                
                            }
                        }return __array__178;
                         
                    })();
                    if (check_true (( ( Environment.get_global("not"))((arg_value_type==="array"))&&  ( Environment.get_global("not"))((arg_value_type==="object"))))){
                        return  ( Environment.get_global("first"))(rval)
                    } else {
                        return rval
                    }
                }
            } catch (__exception__174) {
                if (__exception__174 instanceof Error) {
                    let e=__exception__174;
                    {
                        return  console.error(("replace: "+ e))
                    }
                }
            }
        }
    };__obj__1["get_symbol_details_for_ns"]=function(namespace,symbol_name) {
        if (check_true (((namespace instanceof String || typeof namespace==='string')&& (symbol_name instanceof String || typeof symbol_name==='string')))){
            return  ( Environment.get_global("first"))( ( function(){
                let __collector;
                let __result;
                let __action;
                __collector=[];
                __result=null;
                __action=function(entry) {
                    if (check_true (((entry && entry["namespace"])===namespace))){
                        {
                            return entry
                        }
                    }
                };
                ;
                 ( function() {
                    let __for_body__190=function(__item) {
                        __result= __action(__item);
                        if (check_true (__result)){
                            return (__collector).push(__result)
                        }
                    };
                    let __array__191=[],__elements__189= ( Environment.get_global("meta_for_symbol"))(symbol_name,true);
                    let __BREAK__FLAG__=false;
                    for(let __iter__188 in __elements__189) {
                        __array__191.push( __for_body__190(__elements__189[__iter__188]));
                        if(__BREAK__FLAG__) {
                             __array__191.pop();
                            break;
                            
                        }
                    }return __array__191;
                     
                })();
                return __collector
            })())
        } else {
            throw new TypeError("get_symbol_for_ns: invalid arguments: must both be strings");
            
        }
    };__obj__1["env_encode_string"]=async function(text) {
    let te;
    let enc;
    let decl;
    let de;
    let bl;
    te=new TextEncoder();
    enc=await te["encode"].call(te,text);
    decl=[];
    de=new TextDecoder();
    bl=null;
    await (async function() {
        let __for_body__194=async function(b) {
            if (check_true ((b===92))){
                {
                    (decl).push(92);
                    (decl).push(92);
                    (decl).push(92);
                    return (decl).push(92)
                }
            } else {
                {
                    return (decl).push(b)
                }
            }
        };
        let __array__195=[],__elements__193=enc;
        let __BREAK__FLAG__=false;
        for(let __iter__192 in __elements__193) {
            __array__195.push(await __for_body__194(__elements__193[__iter__192]));
            if(__BREAK__FLAG__) {
                 __array__195.pop();
                break;
                
            }
        }return __array__195;
         
    })();
    return await de["decode"].call(de,new Uint8Array(decl))
};__obj__1["cl_encode_string"]=async function(text) {
    if (check_true ((text instanceof String || typeof text==='string'))){
        {
            let escaped;
            let nq;
            let step1;
            let snq;
            escaped=await (await Environment.get_global("replace"))(new RegExp("\n","g"),await (await Environment.get_global("add"))(await String.fromCharCode(92),"n"),text);
            escaped=await (await Environment.get_global("replace"))(new RegExp("\r","g"),await (await Environment.get_global("add"))(await String.fromCharCode(92),"r"),escaped);
            nq=(escaped).split(await String.fromCharCode(34));
            step1=(nq).join(await (await Environment.get_global("add"))(await String.fromCharCode(92),await String.fromCharCode(34)));
            snq=(step1).split(await String.fromCharCode(39));
            return step1
        }
    } else {
        return text
    }
};__obj__1["fn_signature"]=function(f) {
        if (check_true ((f instanceof Function|| (f instanceof String || typeof f==='string')))){
            {
                let sig;
                let arg_text;
                let comps;
                let descriptor;
                let fname;
                let ftype;
                let extends_class;
                let keyword_idx;
                let args;
                sig=( ( Environment.get_global("first"))(( ( Environment.get_global("replace"))("\n","", ( function(){
                    if (check_true (f instanceof Function)){
                        return  f["toString"]()
                    } else {
                        return f
                    }
                })())).split("{"))).trim();
                arg_text=null;
                comps=null;
                descriptor=null;
                fname=null;
                ftype=null;
                extends_class=null;
                keyword_idx=null;
                args=null;
                return   (function(){
                    if (check_true ( ( Environment.get_global("starts_with?"))("class",sig))) {
                        {
                            ftype="class";
                            descriptor=(sig).split(" ");
                            fname= ( Environment.get_global("second"))(descriptor);
                            if (check_true ((descriptor[3]==="extends"))){
                                extends_class=descriptor[4]
                            };
                            return {
                                name:fname,type:ftype,extends:extends_class
                            }
                        }
                    } else {
                        {
                            if (check_true (sig)){
                                {
                                    comps=(sig).split("(");
                                    descriptor=(( ( Environment.get_global("first"))(comps)|| "")).split(" ");
                                    arg_text=( ( Environment.get_global("chop"))( ( Environment.get_global("second"))(comps))|| "")
                                }
                            };
                            if (check_true (((descriptor && descriptor.length)>0))){
                                {
                                    keyword_idx= ( Environment.get_global("index_of"))("function",descriptor);
                                    if (check_true (keyword_idx)){
                                        {
                                            fname=( ( Environment.get_global("first"))( descriptor["slice"].call(descriptor,(keyword_idx+ 1),(keyword_idx+ 2)))|| "anonymous");
                                            ftype= ( function(){
                                                if (check_true ((keyword_idx===0))){
                                                    return "sync"
                                                } else {
                                                    return descriptor[(keyword_idx- 1)]
                                                }
                                            })()
                                        }
                                    }
                                }
                            };
                            if (check_true (arg_text)){
                                args= ( function() {
                                    let __for_body__198=function(a) {
                                        return (a).trim()
                                    };
                                    let __array__199=[],__elements__197=((arg_text).split(",")|| []);
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__196 in __elements__197) {
                                        __array__199.push( __for_body__198(__elements__197[__iter__196]));
                                        if(__BREAK__FLAG__) {
                                             __array__199.pop();
                                            break;
                                            
                                        }
                                    }return __array__199;
                                     
                                })()
                            } else {
                                args=[]
                            };
                            return {
                                name:fname,type:ftype,args:args
                            }
                        }
                    }
                } )()
            }
        } else {
            throw new TypeError("non-function supplied to fn_signature");
            
        }
    };__obj__1["path_to_js_syntax"]=async function(comps) {
    if (check_true ((comps instanceof Array))){
        if (check_true (((comps && comps.length)>1))){
            return (await (async function(){
                 return await (await Environment.get_global("map"))(async function(comp,idx) {
                    if (check_true ((idx===0))){
                        return comp
                    } else {
                        return await async function(){
                            if (check_true ((await isNaN(parseInt(comp))&& await (await Environment.get_global("starts_with?"))("\"",comp)))) {
                                return ("["+ comp+ "]")
                            } else if (check_true (await isNaN(parseInt(comp)))) {
                                return ("."+ comp)
                            } else {
                                return ("["+ "'"+ comp+ "'"+ "]")
                            }
                        } ()
                    }
                },comps) 
            })()).join("")
        } else {
            return (comps && comps["0"])
        }
    } else {
        throw new TypeError(("path_to_js_syntax: need array - given "+ await (await Environment.get_global("sub_type"))(comps)));
        
    }
};__obj__1["first_is_upper_case?"]=async function(str_val) {
    let rval=await str_val["match"].call(str_val,new RegExp("^[A-Z]"));
    ;
    if (check_true ((rval&& (rval && rval["0"])))){
        return true
    } else {
        return false
    }
};__obj__1["safe_access_2"]=async function(token,ctx,sanitizer_fn) {
    let comps;
    let acc;
    let acc_full;
    let pos;
    let rval;
    comps=null;
    acc=[];
    acc_full=[];
    pos=null;
    rval=null;
    comps=((token && token.name)).split(".");
    if (check_true (((comps && comps.length)===1))){
        return (token && token.name)
    } else {
        {
            await async function(){
                comps[0]=await (async function(){
                    let __array_op_rval__201=sanitizer_fn;
                     if (__array_op_rval__201 instanceof Function){
                        return await __array_op_rval__201((comps && comps["0"])) 
                    } else {
                        return [__array_op_rval__201,(comps && comps["0"])]
                    }
                })();
                return comps;
                
            }();
            await (async function(){
                 let __test_condition__202=async function() {
                    return ((comps && comps.length)>0)
                };
                let __body_ref__203=async function() {
                    (acc).push((comps).shift());
                    if (check_true (((comps && comps.length)>0))){
                        return (acc_full).push((["check_true(",await (async function(){
                             return await (await Environment.get_global("expand_dot_accessor"))((acc).join("."),ctx) 
                        })(),")"]).join(""))
                    } else {
                        return (acc_full).push(await (async function(){
                             return await (await Environment.get_global("expand_dot_accessor"))((acc).join("."),ctx) 
                        })())
                    }
                };
                let __BREAK__FLAG__=false;
                while(await __test_condition__202()) {
                     await __body_ref__203();
                     if(__BREAK__FLAG__) {
                         break;
                        
                    }
                } ;
                
            })();
            rval=await (await Environment.get_global("flatten"))(["(",(acc_full).join(" && "),")"]);
            return rval
        }
    }
};__obj__1["safe_access"]=async function(token,ctx,sanitizer_fn) {
    let comps;
    let acc;
    let acc_full;
    let pos;
    let rval;
    comps=null;
    acc=[];
    acc_full=[];
    pos=null;
    rval=null;
    comps=((token && token.name)).split(".");
    if (check_true (((comps && comps.length)===1))){
        return (token && token.name)
    } else {
        {
            await async function(){
                comps[0]=await (async function(){
                    let __array_op_rval__205=sanitizer_fn;
                     if (__array_op_rval__205 instanceof Function){
                        return await __array_op_rval__205((comps && comps["0"])) 
                    } else {
                        return [__array_op_rval__205,(comps && comps["0"])]
                    }
                })();
                return comps;
                
            }();
            await (async function(){
                 let __test_condition__206=async function() {
                    return ((comps && comps.length)>0)
                };
                let __body_ref__207=async function() {
                    (acc).push((comps).shift());
                    return (acc_full).push(await (async function(){
                         return await (await Environment.get_global("expand_dot_accessor"))((acc).join("."),ctx) 
                    })())
                };
                let __BREAK__FLAG__=false;
                while(await __test_condition__206()) {
                     await __body_ref__207();
                     if(__BREAK__FLAG__) {
                         break;
                        
                    }
                } ;
                
            })();
            rval=await (await Environment.get_global("flatten"))(["(",(acc_full).join(" && "),")"]);
            return rval
        }
    }
};__obj__1["compile_to_js"]=async function(quoted_form) {
    return ["=:->","=:Environment","compile",quoted_form]
};__obj__1["evaluate_compiled_source"]=async function(compiled_source) {
    return ["=:->","=:Environment","evaluate",compiled_source,"=:nil",{ "compiled_source":true
}]
};__obj__1["form_structure"]=async function(quoted_form,max_depth) {
    let idx;
    let acc;
    let structure;
    let follow_tree;
    idx=0;
    acc=[];
    max_depth=(max_depth|| (await Environment.get_global("MAX_SAFE_INTEGER")));
    structure=quoted_form;
    follow_tree=async function(elems,acc,_depth) {
        return await async function(){
            if (check_true ((((elems instanceof Array)|| (elems instanceof Object))&& (_depth>=max_depth)))) {
                if (check_true ((elems instanceof Array))){
                    return "array"
                } else {
                    return "object"
                }
            } else if (check_true ((elems instanceof Array))) {
                return await (await Environment.get_global("map"))(async function(elem,idx) {
                    return await follow_tree(elem,[],await (await Environment.get_global("add"))(_depth,1))
                },elems)
            } else if (check_true ((elems instanceof Object))) {
                {
                    return await (async function() {
                        let __for_body__210=async function(pset) {
                            return await follow_tree((pset && pset["1"]),[],await (await Environment.get_global("add"))(_depth,1))
                        };
                        let __array__211=[],__elements__209=await (await Environment.get_global("pairs"))(elems);
                        let __BREAK__FLAG__=false;
                        for(let __iter__208 in __elements__209) {
                            __array__211.push(await __for_body__210(__elements__209[__iter__208]));
                            if(__BREAK__FLAG__) {
                                 __array__211.pop();
                                break;
                                
                            }
                        }return __array__211;
                         
                    })()
                }
            } else {
                return await async function(){
                    if (check_true (((elems instanceof String || typeof elems==='string')&& await (await Environment.get_global("starts_with?"))("=:",elems)))) {
                        return "symbol"
                    } else if (check_true (await (await Environment.get_global("is_number?"))(elems))) {
                        return "number"
                    } else if (check_true ((elems instanceof String || typeof elems==='string'))) {
                        return "string"
                    } else if (check_true (((elems===true)|| (elems===false)))) {
                        return "boolean"
                    } else {
                        return elems
                    }
                } ()
            }
        } ()
    };
    return await follow_tree(structure,[],0)
};__obj__1["validate_form_structure"]=async function(validation_rules,quoted_form) {
    let results;
    let all_valid;
    let target;
    results={
        valid:[],invalid:[],rule_count:await (await Environment.get_global("length"))(validation_rules),all_passed:false
    };
    all_valid=null;
    target=null;
    await (async function() {
        let __for_body__214=async function(rule) {
            if (check_true (((rule instanceof Array)&& ((rule && rule.length)>1)&& ((rule && rule["0"]) instanceof Array)&& ((rule && rule["1"]) instanceof Array)))){
                {
                    all_valid=true;
                    target=await (await Environment.get_global("resolve_path"))((rule && rule["0"]),quoted_form);
                    await (async function() {
                        let __for_body__218=async function(validation) {
                            if (check_true (await (await Environment.get_global("not"))(await (async function(){
                                let __array_op_rval__220=validation;
                                 if (__array_op_rval__220 instanceof Function){
                                    return await __array_op_rval__220(target) 
                                } else {
                                    return [__array_op_rval__220,target]
                                }
                            })()))){
                                {
                                    all_valid=false;
                                    return __BREAK__FLAG__=true;
                                    return
                                }
                            }
                        };
                        let __array__219=[],__elements__217=(rule && rule["1"]);
                        let __BREAK__FLAG__=false;
                        for(let __iter__216 in __elements__217) {
                            __array__219.push(await __for_body__218(__elements__217[__iter__216]));
                            if(__BREAK__FLAG__) {
                                 __array__219.pop();
                                break;
                                
                            }
                        }return __array__219;
                         
                    })();
                    if (check_true (all_valid)){
                        return ((results && results["valid"])).push(((rule && rule["2"])|| (rule && rule["0"])))
                    } else {
                        return ((results && results["invalid"])).push(((rule && rule["2"])|| (rule && rule["0"])))
                    }
                }
            }
        };
        let __array__215=[],__elements__213=(validation_rules|| []);
        let __BREAK__FLAG__=false;
        for(let __iter__212 in __elements__213) {
            __array__215.push(await __for_body__214(__elements__213[__iter__212]));
            if(__BREAK__FLAG__) {
                 __array__215.pop();
                break;
                
            }
        }return __array__215;
         
    })();
    await async function(){
        results["all_passed"]=(await (await Environment.get_global("length"))((results && results["valid"]))===(results && results["rule_count"]));
        return results;
        
    }();
    return results
};__obj__1["*compiler_syntax_rules*"]={compile_let:await (async function(){ return [[[0,1,"val"],(function anonymous(x
) {
{ return x instanceof Array }
})(),"let allocation section"],await (async function(){ return [[0,2],await (async function(){ return (async function(v) {
                return await (await Environment.get_global("not"))((v===undefined))
            })() })(),"let missing block"] })()] })(),compile_cond:await (async function(){ return [[[0],await (async function(){ return (async function(v) {
            return ((await (await Environment.get_global("length"))(await (await Environment.get_global("rest"))(v))% 2)===0)
        })() })(),"cond: odd number of arguments"]] })(),compile_assignment:await (async function(){ return [[[0,1],await (async function(){ return (async function(v) {
            return await (await Environment.get_global("not"))((v===undefined))
        })() })(),"assignment is missing target and values"],await (async function(){ return [[0,2],await (async function(){ return (async function(v) {
                return await (await Environment.get_global("not"))((v===undefined))
            })() })(),"assignment is missing value"] })()] })()};__obj__1["tokenize_lisp"]=async function(quoted_source) {
    let current_env;
    current_env=await Environment["get_namespace_handle"].call(Environment,await (await Environment.get_global("current_namespace"))());
    return await (await Environment.get_global("compiler"))(quoted_source,{
        only_tokens:true,env:current_env
    })
};__obj__1["detokenize"]=async function(token) {
    let rval;
    rval=null;
    return await async function(){
        if (check_true ((token instanceof Array))) {
            return await (async function() {
                let __for_body__224=async function(t) {
                    return await (await Environment.get_global("detokenize"))(t)
                };
                let __array__225=[],__elements__223=token;
                let __BREAK__FLAG__=false;
                for(let __iter__222 in __elements__223) {
                    __array__225.push(await __for_body__224(__elements__223[__iter__222]));
                    if(__BREAK__FLAG__) {
                         __array__225.pop();
                        break;
                        
                    }
                }return __array__225;
                 
            })()
        } else if (check_true (((token instanceof Object)&& ((token && token["type"])==="objlit")&& ((token && token["val"] && token["val"]["name"])==="{}")))) {
            return new Object()
        } else if (check_true (((token instanceof Object)&& ((token && token["type"])==="objlit")))) {
            {
                rval=new Object();
                await (async function() {
                    let __for_body__228=async function(t) {
                        return await async function(){
                            rval[(t && t["val"] && t["val"]["0"] && t["val"]["0"]["name"])]=await (async function(){
                                 return await (await Environment.get_global("detokenize"))((t && t["val"] && t["val"]["1"])) 
                            })();
                            return rval;
                            
                        }()
                    };
                    let __array__229=[],__elements__227=(token && token["val"]);
                    let __BREAK__FLAG__=false;
                    for(let __iter__226 in __elements__227) {
                        __array__229.push(await __for_body__228(__elements__227[__iter__226]));
                        if(__BREAK__FLAG__) {
                             __array__229.pop();
                            break;
                            
                        }
                    }return __array__229;
                     
                })();
                return rval
            }
        } else if (check_true (((token instanceof Object)&& ((token && token["type"])==="literal")))) {
            return await (await Environment.get_global("detokenize"))((token && token["val"]))
        } else if (check_true (((token instanceof Object)&& ((token && token["type"])==="arr")&& (token && token["source"])&& ((token && token["val"] && token["val"]["0"] && token["val"]["0"]["type"])==="special")&& (token && token["val"] && token["val"]["0"] && token["val"]["0"]["ref"])))) {
            {
                return await (async function(){
                    let __array_op_rval__231=(token && token["val"] && token["val"]["0"] && token["val"]["0"]["val"]);
                     if (__array_op_rval__231 instanceof Function){
                        return await __array_op_rval__231((token && token["val"] && token["val"]["1"])) 
                    } else {
                        return [__array_op_rval__231,(token && token["val"] && token["val"]["1"])]
                    }
                })()
            }
        } else if (check_true (((token instanceof Object)&& (token && token["ref"])))) {
            return ("=:"+ (token && token.name))
        } else if (check_true (((token instanceof Object)&& ((token && token["type"])==="arr")))) {
            {
                return await (await Environment.get_global("detokenize"))((token && token["val"]))
            }
        } else if (check_true (((token instanceof Object)&& (token && token["ref"])))) {
            {
                return (token && token["val"])
            }
        } else if (check_true ((token instanceof Object))) {
            return await (await Environment.get_global("detokenize"))((token && token["val"]))
        } else {
            {
                return token
            }
        }
    } ()
};__obj__1["describe_all"]=async function() {
    return await (async function(){
        let __apply_args__232=await (async function(){
             return await (async function() {
                let __for_body__236=async function(s) {
                    return await (await Environment.get_global("to_object"))(await (async function(){
                         return [await (async function(){
                            let __array_op_rval__238=s;
                             if (__array_op_rval__238 instanceof Function){
                                return await __array_op_rval__238(await (async function(){
                                     return await (await Environment.get_global("describe"))(s) 
                                })()) 
                            } else {
                                return [__array_op_rval__238,await (async function(){
                                     return await (await Environment.get_global("describe"))(s) 
                                })()]
                            }
                        })()] 
                    })())
                };
                let __array__237=[],__elements__235=await (async function(){
                     return await (await Environment.get_global("symbols"))() 
                })();
                let __BREAK__FLAG__=false;
                for(let __iter__234 in __elements__235) {
                    __array__237.push(await __for_body__236(__elements__235[__iter__234]));
                    if(__BREAK__FLAG__) {
                         __array__237.pop();
                        break;
                        
                    }
                }return __array__237;
                 
            })() 
        })();
        return ( (await Environment.get_global("add"))).apply(this,__apply_args__232)
    })()
};__obj__1["is_value?"]=async function(val) {
    if (check_true ((val===""))){
        return true
    } else {
        if (check_true ((val===undefined))){
            return false
        } else {
            if (check_true (await isNaN(val))){
                return true
            } else {
                if (check_true (val)){
                    return true
                } else {
                    return false
                }
            }
        }
    }
};__obj__1["sort"]=async function(elems,options) {
    let opts;
    let sort_fn;
    let sort_fn_inner;
    let keyed;
    let reverser;
    let comparitor;
    let key_path_a;
    let key_path_b;
    opts=(((options instanceof Object)&& options)|| new Object());
    sort_fn=null;
    sort_fn_inner=null;
    keyed=false;
    reverser=await (async function(){
        if (check_true ((opts && opts["reversed"]))){
            return -1
        } else {
            return 1
        }
    })();
    comparitor=await (async function(){
         return await async function(){
            if (check_true ((opts && opts["comparitor"]) instanceof Function)) {
                return (opts && opts["comparitor"])
            } else {
                return function(a,b) {
                    return   (function(){
                        if (check_true ((a instanceof String || typeof a==='string'))) {
                            if (check_true ((b instanceof String || typeof b==='string'))){
                                return (reverser*  a["localeCompare"].call(a,b))
                            } else {
                                return (reverser*  a["localeCompare"].call(a,(""+ b)))
                            }
                        } else if (check_true ((b instanceof String || typeof b==='string'))) {
                            return (reverser*  ( function() {
                                {
                                     let __call_target__=(""+ a), __call_method__="localeCompare";
                                    return  __call_target__[__call_method__].call(__call_target__,b)
                                } 
                            })())
                        } else if (check_true ((opts && opts["reversed"]))) {
                            return (b- a)
                        } else {
                            return (a- b)
                        }
                    } )()
                }
            }
        } () 
    })();
    key_path_a="aval";
    key_path_b="bval";
    await (await Environment.get_global("assert"))((elems instanceof Array),"sort: elements must be an array");
    await (await Environment.get_global("assert"))((await subtype(comparitor)==="Function"),("sort: invalid comparitor provided : "+ await subtype(comparitor)+ " - must be a synchronous function, or evaluate to a synchronous function."));
    await (await Environment.get_global("assert"))((((opts && opts["comparitor"])&& await (await Environment.get_global("not"))((opts && opts["reversed"])))|| (await (await Environment.get_global("not"))((opts && opts["comparitor"]))&& (opts && opts["reversed"]))|| (await (await Environment.get_global("not"))((opts && opts["comparitor"]))&& await (await Environment.get_global("not"))((opts && opts["reversed"])))),"sort: comparitor option cannot be combined with reversed option");
    await async function(){
        if (check_true (((opts && opts["key"]) instanceof String || typeof (opts && opts["key"])==='string'))) {
            {
                keyed=true;
                key_path_a=await (async function(){
                     return await (await Environment.get_global("path_to_js_syntax"))(await (await Environment.get_global("get_object_path"))(("aval."+ (opts && opts["key"])))) 
                })();
                return key_path_b=await (async function(){
                     return await (await Environment.get_global("path_to_js_syntax"))(await (await Environment.get_global("get_object_path"))(("bval."+ (opts && opts["key"])))) 
                })()
            }
        } else if (check_true (((opts && opts["key"]) instanceof Array))) {
            {
                keyed=true;
                key_path_a=await (async function(){
                     return await (await Environment.get_global("path_to_js_syntax"))(await (await Environment.get_global("conj"))(["aval"],(opts && opts["key"]))) 
                })();
                key_path_b=await (async function(){
                     return await (await Environment.get_global("path_to_js_syntax"))(await (await Environment.get_global("conj"))(["bval"],(opts && opts["key"]))) 
                })()
            }
        }
    } ();
    sort_fn_inner=new Function("aval","bval","comparitor",("return comparitor( "+ key_path_a+ ","+ key_path_b+ ")"));
    sort_fn=function(aval,bval) {
        return  sort_fn_inner(aval,bval,comparitor)
    };
    return await elems["sort"].call(elems,sort_fn)
};__obj__1["and*"]=async function(...args) {
    let vals;
    vals=await (await Environment.get_global("slice"))(args,0);
    if (check_true (((vals && vals.length)>0))){
        {
            let rval=true;
            ;
            await (async function() {
                let __for_body__241=async function(v) {
                    if (check_true (await (await Environment.get_global("not"))(await (async function(){
                         return await (await Environment.get_global("is_value?"))(v) 
                    })()))){
                        {
                            rval=false;
                            return __BREAK__FLAG__=true;
                            return
                        }
                    }
                };
                let __array__242=[],__elements__240=vals;
                let __BREAK__FLAG__=false;
                for(let __iter__239 in __elements__240) {
                    __array__242.push(await __for_body__241(__elements__240[__iter__239]));
                    if(__BREAK__FLAG__) {
                         __array__242.pop();
                        break;
                        
                    }
                }return __array__242;
                 
            })();
            return rval
        }
    }
};__obj__1["or*"]=async function(...args) {
    let vals;
    vals=await (await Environment.get_global("slice"))(args,0);
    if (check_true (((vals && vals.length)>0))){
        {
            let rval=false;
            ;
            await (async function() {
                let __for_body__245=async function(v) {
                    if (check_true (await (await Environment.get_global("is_value?"))(v))){
                        {
                            rval=true;
                            return __BREAK__FLAG__=true;
                            return
                        }
                    }
                };
                let __array__246=[],__elements__244=vals;
                let __BREAK__FLAG__=false;
                for(let __iter__243 in __elements__244) {
                    __array__246.push(await __for_body__245(__elements__244[__iter__243]));
                    if(__BREAK__FLAG__) {
                         __array__246.pop();
                        break;
                        
                    }
                }return __array__246;
                 
            })();
            return rval
        }
    }
};__obj__1["either"]=async function(...args) {
    args=await (await Environment.get_global("slice"))(args,0);
    {
        let rval;
        rval=null;
        await (async function() {
            let __for_body__249=async function(arg) {
                rval=arg;
                if (check_true ((await (await Environment.get_global("not"))((undefined===arg))&& await (await Environment.get_global("not"))((null===arg))))){
                    {
                        return __BREAK__FLAG__=true;
                        return
                    }
                }
            };
            let __array__250=[],__elements__248=args;
            let __BREAK__FLAG__=false;
            for(let __iter__247 in __elements__248) {
                __array__250.push(await __for_body__249(__elements__248[__iter__247]));
                if(__BREAK__FLAG__) {
                     __array__250.pop();
                    break;
                    
                }
            }return __array__250;
             
        })();
        return rval
    }
};__obj__1["sanitize_js_ref_name"]=function(symname) {
        return   (function(){
            if (check_true ( ( Environment.get_global("not"))((symname instanceof String || typeof symname==='string')))) {
                return symname
            } else {
                {
                    let text_chars;
                    let acc;
                    text_chars=(symname).split("");
                    acc=[];
                     ( function() {
                        let __for_body__253=function(t) {
                            return   (function(){
                                if (check_true ((t==="+"))) {
                                    return (acc).push("_plus_")
                                } else if (check_true ((t==="?"))) {
                                    return (acc).push("_ques_")
                                } else if (check_true ((t==="-"))) {
                                    return (acc).push("_")
                                } else if (check_true ((t==="&"))) {
                                    return (acc).push("_amper_")
                                } else if (check_true ((t==="^"))) {
                                    return (acc).push("_carot_")
                                } else if (check_true ((t==="#"))) {
                                    return (acc).push("_hash_")
                                } else if (check_true ((t==="!"))) {
                                    return (acc).push("_exclaim_")
                                } else if (check_true ((t==="*"))) {
                                    return (acc).push("_star_")
                                } else if (check_true ((t==="~"))) {
                                    return (acc).push("_tilde_")
                                } else if (check_true ((t==="~"))) {
                                    return (acc).push("_percent_")
                                } else if (check_true ((t==="|"))) {
                                    return (acc).push("_pipe_")
                                } else if (check_true ( ( Environment.get_global("contains?"))(t,"(){}"))) {
                                    throw new LispSyntaxError(("Invalid character in symbol: "+ symname));
                                    
                                } else {
                                    return (acc).push(t)
                                }
                            } )()
                        };
                        let __array__254=[],__elements__252=text_chars;
                        let __BREAK__FLAG__=false;
                        for(let __iter__251 in __elements__252) {
                            __array__254.push( __for_body__253(__elements__252[__iter__251]));
                            if(__BREAK__FLAG__) {
                                 __array__254.pop();
                                break;
                                
                            }
                        }return __array__254;
                         
                    })();
                    return (acc).join("")
                }
            }
        } )()
    };__obj__1["is_symbol?"]=async function(symbol_to_find) {
    return ["=:not",["=:or",["=:==",["=:typeof",symbol_to_find],"undefined"],["=:==",["=:->","=:Environment","get_global",symbol_to_find,"=:ReferenceError"],"=:ReferenceError"]]]
};__obj__1["defvalue"]=async function(sym,value,meta) {
    let meta_data;
    meta_data=await (async function(){
        if (check_true ((meta instanceof Object))){
            return meta
        } else {
            return new Object()
        }
    })();
    return ["=:let",[["=:unquoted_sym",["=:desym",sym]],["=:details",["=:describe","=:unquoted_sym"]]],["=:if","=:details",["=:->","=:Environment","get_global",["=:+","=:details.namespace","/","=:unquoted_sym"]],["=:defglobal",sym,value,meta_data]]]
};__obj__1["defparameter"]=async function(sym,value,meta) {
    let meta_data;
    meta_data=await (async function(){
        if (check_true ((meta instanceof Object))){
            return meta
        } else {
            return new Object()
        }
    })();
    return ["=:first",["=:use_quoted_initializer",["=:defglobal",sym,value,meta_data]]]
};__obj__1["get_function_args"]=async function(f) {
    let r;
    let s;
    r=new RegExp("^[a-zA-Z_]+ [a-zA-Z ]*\\\\(([a-zA-Z 0-9_,\\\\.\\\\n]*)\\\\)","gm");
    s=await f["toString"]();
    r=await (await Environment.get_global("scan_str"))(r,s);
    if (check_true ((((r && r.length)>0)&& ((r && r["0"]) instanceof Object)))){
        {
            return await (await Environment.get_global("map"))(async function(v) {
                if (check_true (await (await Environment.get_global("ends_with?"))("\n",v))){
                    return await (await Environment.get_global("chop"))(v)
                } else {
                    return v
                }
            },((await (await Environment.get_global("second"))((r && r["0"]))|| "")).split(","))
        }
    }
};__obj__1["findpaths"]=async function(value,structure) {
    let acc;
    let search;
    acc=[];
    search=async function(struct,_cpath) {
        return await async function(){
            if (check_true ((struct instanceof Array))) {
                return await (await Environment.get_global("map"))(async function(elem,idx) {
                    return await async function(){
                        if (check_true ((elem instanceof Object))) {
                            return await search(elem,await (await Environment.get_global("conj"))(_cpath,await (async function(){
                                let __array_op_rval__255=idx;
                                 if (__array_op_rval__255 instanceof Function){
                                    return await __array_op_rval__255() 
                                } else {
                                    return [__array_op_rval__255]
                                }
                            })()))
                        } else if (check_true ((elem===value))) {
                            return (acc).push(await (await Environment.get_global("conj"))(_cpath,await (async function(){
                                let __array_op_rval__256=idx;
                                 if (__array_op_rval__256 instanceof Function){
                                    return await __array_op_rval__256() 
                                } else {
                                    return [__array_op_rval__256]
                                }
                            })()))
                        }
                    } ()
                },struct)
            } else if (check_true ((struct instanceof Object))) {
                return await (await Environment.get_global("map"))(async function(pset) {
                    return await async function(){
                        if (check_true (((pset && pset["1"]) instanceof Object))) {
                            return await search((pset && pset["1"]),await (await Environment.get_global("conj"))(_cpath,await (async function(){
                                let __array_op_rval__257=(pset && pset["0"]);
                                 if (__array_op_rval__257 instanceof Function){
                                    return await __array_op_rval__257() 
                                } else {
                                    return [__array_op_rval__257]
                                }
                            })()))
                        } else if (check_true (((pset && pset["1"])===value))) {
                            return (acc).push(await (await Environment.get_global("conj"))(_cpath,await (async function(){
                                let __array_op_rval__258=(pset && pset["1"]);
                                 if (__array_op_rval__258 instanceof Function){
                                    return await __array_op_rval__258() 
                                } else {
                                    return [__array_op_rval__258]
                                }
                            })()))
                        }
                    } ()
                },await (await Environment.get_global("pairs"))(struct))
            } else if (check_true ((struct===value))) {
                return (acc).push(_cpath)
            }
        } ()
    };
    await search(structure,[]);
    return acc
};__obj__1["warn"]=await (async function(){ return "placeholder" })();__obj__1["success"]=await (async function(){ return "placeholder" })();__obj__1["in_background"]=async function(...args) {
    let forms;
    forms=await (await Environment.get_global("slice"))(args,0);
    return ["=:new","=:Promise",["=:fn",["=:resolve","=:reject"],["=:progn",["=:resolve",true],].concat(forms)]]
};__obj__1["show"]=async function(thing) {
    return await async function(){
        if (check_true (thing instanceof Function)) {
            return await thing["toString"]()
        } else {
            return thing
        }
    } ()
};__obj__1["export_symbols"]=async function(...args) {
    args=await (await Environment.get_global("slice"))(args,0);
    {
        let acc;
        let numargs;
        let idx;
        acc=await (async function(){
             return ["=:javascript","export","{"] 
        })();
        numargs=await (await Environment.get_global("length"))(args);
        idx=0;
        await (async function() {
            let __for_body__261=async function(symname) {
                await async function(){
                    if (check_true (((symname instanceof Array)&& ((symname && symname.length)===2)))) {
                        {
                            (acc).push(await (async function(){
                                let mval;
                                mval=(symname && symname["0"]);
                                if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                                    return await mval["substr"].call(mval,2)
                                } else {
                                    return mval
                                }
                            })());
                            (acc).push(" as ");
                            return (acc).push(await (async function(){
                                let mval;
                                mval=(symname && symname["1"]);
                                if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                                    return await mval["substr"].call(mval,2)
                                } else {
                                    return mval
                                }
                            })())
                        }
                    } else if (check_true ((symname instanceof String || typeof symname==='string'))) {
                        (acc).push(await (async function(){
                            let mval;
                            mval=symname;
                            if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                                return await mval["substr"].call(mval,2)
                            } else {
                                return mval
                            }
                        })())
                    } else {
                        throw new SyntaxError("Invalid argument for export");
                        
                    }
                } ();
                idx+=1;
                if (check_true ((idx<numargs))){
                    return (acc).push(", ")
                }
            };
            let __array__262=[],__elements__260=args;
            let __BREAK__FLAG__=false;
            for(let __iter__259 in __elements__260) {
                __array__262.push(await __for_body__261(__elements__260[__iter__259]));
                if(__BREAK__FLAG__) {
                     __array__262.pop();
                    break;
                    
                }
            }return __array__262;
             
        })();
        (acc).push("}");
        return acc
    }
};__obj__1["register_feature"]=async function(feature) {
    if (check_true (await (await Environment.get_global("not"))(await (await Environment.get_global("contains?"))(feature,(await Environment.get_global("*env_config*.features")))))){
        {
            ((await Environment.get_global("*env_config*.features"))).push(feature);
            return true
        }
    } else {
        return false
    }
};__obj__1["uniq"]=async function(values) {
    let s;
    s=new Set();
    await (await Environment.get_global("map"))(async function(x) {
        return await s["add"].call(s,x)
    },(values|| []));
    return await (await Environment.get_global("to_array"))(s)
};__obj__1["time_in_millis"]=async function() {
    return ["=:Date.now"]
};__obj__1["defns"]=async function(name,options) {
    if (check_true ((options&& (options && options["ignore_if_exists"])&& (name instanceof String || typeof name==='string')&& await (await Environment.get_global("contains?"))(name,await (await Environment.get_global("namespaces"))())))){
        return name
    } else {
        return await (await Environment.get_global("create_namespace"))(name,options)
    }
};__obj__1["use_ns"]=async function(name) {
    return ["=:set_namespace",["=:desym",name]]
};__obj__1["bind_and_call"]=async function(...args) {
    let target_object;
    let this_object;
    let method;
    target_object=(args && args["0"]);
    this_object=(args && args["1"]);
    method=(args && args["2"]);
    args=await (await Environment.get_global("slice"))(args,3);
    {
        let boundf=await (await Environment.get_global("bind"))(target_object[method],this_object);
        ;
        if (check_true (boundf)){
            return await (async function(){
                return ( boundf).apply(this,args)
            })()
        } else {
            throw new Error("unable to bind target_object");
            
        }
    }
};__obj__1["clamp"]=function(value,min,max) {
        return  Math.min( Math.max(min,value),max)
    };__obj__1["save_locally"]=async function(fname,data,content_type) {
    if (check_true (window["document"])){
        {
            let blob;
            let elem;
            let dbody;
            blob=new Blob(await (async function(){
                let __array_op_rval__267=data;
                 if (__array_op_rval__267 instanceof Function){
                    return await __array_op_rval__267() 
                } else {
                    return [__array_op_rval__267]
                }
            })(),{
                type:content_type
            });
            elem=await (async function() {
                {
                     let __call_target__=window["document"], __call_method__="createElement";
                    return await __call_target__[__call_method__].call(__call_target__,"a")
                } 
            })();
            dbody=await (async function(){
                let __targ__268=(await Environment.get_global("document"));
                if (__targ__268){
                     return(__targ__268)["body"]
                } 
            })();
            ;
            await async function(){
                elem["href"]=await window.URL["createObjectURL"].call(window.URL,blob);
                elem["download"]=fname;
                return elem;
                
            }();
            await dbody["appendChild"].call(dbody,elem);
            await elem["click"]();
            await dbody["removeChild"].call(dbody,elem);
            return true
        }
    } else {
        return false
    }
};__obj__1["fetch_text"]=async function(url) {
    let resp;
    resp=await fetch(url);
    if (check_true ((resp && resp["ok"]))){
        return await resp["text"]()
    } else {
        throw new EvalError(("unable to fetch "+ url+ ": "+ (resp && resp["status"])+ ": "+ (resp && resp["statusText"])));
        
    }
};__obj__1["import"]=async function(...args) {
    args=await (await Environment.get_global("slice"))(args,0);
    {
        let filespec;
        let is_url_ques_;
        let js_mode;
        let url_comps;
        let js_mod;
        let load_fn;
        let target_symbols;
        let target_path;
        let acc;
        filespec=await (await Environment.get_global("last"))(args);
        is_url_ques_=await (await Environment.get_global("contains?"))("://",filespec);
        js_mode=null;
        url_comps=null;
        js_mod=null;
        load_fn=null;
        target_symbols=await (async function(){
            if (check_true (((args && args.length)>1))){
                return (args && args["0"])
            }
        })();
        target_path=null;
        acc=[];
        await async function(){
            if (check_true ((is_url_ques_|| await (await Environment.get_global("not"))((null==location))))) {
                {
                    load_fn="fetch_text";
                    url_comps=await (async function(){
                         return await async function(){
                            if (check_true (is_url_ques_)) {
                                return new URL(filespec)
                            } else if (check_true (await (await Environment.get_global("starts_with?"))("/",filespec))) {
                                return new URL((""+ location["origin"]+ filespec))
                            } else {
                                return new URL((""+ location["href"]+ "/"+ filespec))
                            }
                        } () 
                    })();
                    return target_path=(url_comps && url_comps["pathname"])
                }
            } else if (check_true (await (await Environment.get_global("not"))(((typeof "read_text_file"==="undefined")|| (await Environment["get_global"].call(Environment,"read_text_file",ReferenceError)===ReferenceError))))) {
                {
                    load_fn="read_text_file";
                    return target_path=filespec
                }
            } else {
                throw new EvalError(("unable to handle import of "+ filespec));
                
            }
        } ();
        return await async function(){
            if (check_true ((await (await Environment.get_global("ends_with?"))(".lisp",target_path)|| await (await Environment.get_global("ends_with?"))(".juno",target_path)))) {
                return ["=:evaluate",[await (async function(){
                     return ("=:"+ load_fn) 
                })(),filespec],"=:nil",["=:to_object",[["source_name",filespec],["throw_on_error",true]]]]
            } else if (check_true (await (await Environment.get_global("ends_with?"))(".json",target_path))) {
                return ["=:evaluate",["=:JSON.parse",[await (async function(){
                     return ("=:"+ load_fn) 
                })(),filespec]],"=:nil",["=:to_object",[["json_in",true],["source_name",filespec],["throw_on_error",true]]]]
            } else if (check_true ((await (await Environment.get_global("ends_with?"))(".js",target_path)|| (await (await Environment.get_global("not"))(((typeof "Deno"==="undefined")|| (await Environment["get_global"].call(Environment,"Deno",ReferenceError)===ReferenceError)))&& await (await Environment.get_global("ends_with?"))(".ts",target_path))))) {
                {
                    return await async function(){
                        if (check_true ((await (await Environment.get_global("length"))(target_symbols)===0))) {
                            throw new SyntaxError("imports of javascript sources require binding symbols as the first argument");
                            
                        } else if (check_true ((target_symbols instanceof Array))) {
                            {
                                (acc).push(await (async function(){
                                     return ["=:defglobal",(target_symbols && target_symbols["0"]),["=:dynamic_import",filespec],{ "is_import":true,"initializer":["=:quotem",["=:import",].concat(args)]
                                }] 
                            })());
                            (acc).push(await (async function(){
                                 return ["=:set_path",["imports",["=:+",await (await Environment.get_global("current_namespace"))(),"/",["=:desym",(target_symbols && target_symbols["0"])]]],"=:*env_config*",["=:to_object",[["symbol",["=:desym",(target_symbols && target_symbols["0"])]],["namespace",await (await Environment.get_global("current_namespace"))()],["location",filespec]]]] 
                            })());
                            (acc).push(await (async function(){
                                 return ["=:when",["=:prop",(target_symbols && target_symbols["0"]),"initializer"],["=:->",(target_symbols && target_symbols["0"]),"initializer","=:Environment"]] 
                            })());
                            (acc).push((target_symbols && target_symbols["0"]));
                            return ["=:iprogn",].concat(acc)
                        }
                    }
                } ()
            }
        } else {
            throw new EvalError("invalid extension: needs to be .lisp, .js, .json or .juno");
            
        }
    } ()
}
};__obj__1["system_date_format"]={weekday:"long",year:"numeric",month:"2-digit",day:"2-digit",hour:"numeric",minute:"numeric",second:"numeric",fractionalSecondDigits:3,hourCycle:"h24",hour12:false,timeZoneName:"short"};__obj__1["system_date_formatter"]=await (async function(){ return "placeholder" })();__obj__1["tzoffset"]=async function() {
    return (60* await (async function() {
        {
             let __call_target__=new Date(), __call_method__="getTimezoneOffset";
            return await __call_target__[__call_method__]()
        } 
    })())
};__obj__1["date_components"]=async function(date_value,date_formatter) {
    if (check_true (await (await Environment.get_global("is_date?"))(date_value))){
        return await (await Environment.get_global("to_object"))(await (async function(){
             return await (await Environment.get_global("map"))(async function(x) {
                return await (async function(){
                    let __array_op_rval__270=(x && x["type"]);
                     if (__array_op_rval__270 instanceof Function){
                        return await __array_op_rval__270((x && x["value"])) 
                    } else {
                        return [__array_op_rval__270,(x && x["value"])]
                    }
                })()
            },await (async function(){
                if (check_true (date_formatter)){
                    return await (await Environment.get_global("bind_and_call"))(date_formatter,date_formatter,"formatToParts",date_value)
                } else {
                    return await (await Environment.get_global("bind_and_call"))((await Environment.get_global("system_date_formatter")),(await Environment.get_global("system_date_formatter")),"formatToParts",date_value)
                }
            })()) 
        })())
    } else {
        return null
    }
};__obj__1["formatted_date"]=async function(dval,date_formatter) {
    let comps;
    comps=await (async function(){
         return await (await Environment.get_global("date_components"))(dval,date_formatter) 
    })();
    if (check_true (comps)){
        if (check_true (date_formatter)){
            return (await (await Environment.get_global("values"))(comps)).join("")
        } else {
            return (""+ (comps && comps["year"])+ "-"+ (comps && comps["month"])+ "-"+ (comps && comps["day"])+ " "+ (comps && comps["hour"])+ ":"+ (comps && comps["minute"])+ ":"+ (comps && comps["second"]))
        }
    } else {
        return null
    }
};__obj__1["*LANGUAGE*"]=new Object();__obj__1["dtext"]=function(default_text) {
        return ( ( function(){
            let __targ__271=( Environment.get_global("*LANGUAGE*"));
            if (__targ__271){
                 return(__targ__271)[default_text]
            } 
        })()|| default_text)
    };__obj__1["nth"]=async function(idx,collection) {
    return await async function(){
        if (check_true ((idx instanceof Array))) {
            return await (await Environment.get_global("map"))(async function(v) {
                return await (await Environment.get_global("nth"))(v,collection)
            },idx)
        } else if (check_true ((await (await Environment.get_global("is_number?"))(idx)&& (idx<0)&& (await (await Environment.get_global("length"))(collection)>=(-1* idx))))) {
            return collection[await (await Environment.get_global("add"))(await (await Environment.get_global("length"))(collection),idx)]
        } else if (check_true ((await (await Environment.get_global("is_number?"))(idx)&& (idx<0)&& (await (await Environment.get_global("length"))(collection)<(-1* idx))))) {
            return undefined
        } else {
            return collection[idx]
        }
    } ()
};__obj__1["max_index"]=function(container) {
        return  Math.max(0,( ( Environment.get_global("length"))(container)- 1))
    };__obj__1["decode_text"]=function(buffer) {
        return  ( function() {
            {
                 let __call_target__=new TextDecoder(), __call_method__="decode";
                return  __call_target__[__call_method__].call(__call_target__,buffer)
            } 
        })()
    };__obj__1["encode_text"]=function(text) {
        return  ( function() {
            {
                 let __call_target__=new TextEncoder(), __call_method__="encode";
                return  __call_target__[__call_method__].call(__call_target__,text)
            } 
        })()
    };__obj__1["hostname"]=async function() {
    return await Deno.hostname()
};__obj__1["use_symbols"]=async function(namespace,symbol_list,target_namespace) {
    let acc;
    let nspace;
    let nspace_handle;
    let decs;
    acc=await (async function(){
         return ["=:progn"] 
    })();
    nspace=await (async function(){
        if (check_true (namespace)){
            {
                let mval;
                mval=namespace;
                if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                    return await mval["substr"].call(mval,2)
                } else {
                    return mval
                }
            }
        }
    })();
    nspace_handle=null;
    decs=null;
    nspace_handle=await Environment["get_namespace_handle"].call(Environment,nspace);
    await (async function() {
        let __for_body__274=async function(sym) {
            decs=await (async function(){
                let __targ__276=(nspace_handle && nspace_handle["definitions"]);
                if (__targ__276){
                     return(__targ__276)[await (async function(){
                        let mval;
                        mval=sym;
                        if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                            return await mval["substr"].call(mval,2)
                        } else {
                            return mval
                        }
                    })()]
                } 
            })();
            return (acc).push(await (async function(){
                 return ["=:defglobal",await (async function(){
                    let mval;
                    mval=sym;
                    if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                        return await mval["substr"].call(mval,2)
                    } else {
                        return mval
                    }
                })(),await (async function(){
                     return ("=:"+ nspace+ "/"+ await (async function(){
                        let mval;
                        mval=sym;
                        if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                            return await mval["substr"].call(mval,2)
                        } else {
                            return mval
                        }
                    })()) 
                })(),["=:to_object",[["initializer",["=:quotem",["=:pend_load",nspace,await (async function(){
                     return (target_namespace|| await (await Environment.get_global("current_namespace"))()) 
                })(),await (async function(){
                    let mval;
                    mval=sym;
                    if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                        return await mval["substr"].call(mval,2)
                    } else {
                        return mval
                    }
                })(),await (async function(){
                     return ("=:"+ nspace+ "/"+ await (async function(){
                        let mval;
                        mval=sym;
                        if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                            return await mval["substr"].call(mval,2)
                        } else {
                            return mval
                        }
                    })()) 
                })()]]],["=:quotem",["require_ns",nspace]],["=:quotem",["requires",[await (async function(){
                     return (""+ nspace+ "/"+ await (async function(){
                        let mval;
                        mval=sym;
                        if (check_true (((mval instanceof String || typeof mval==='string')&& await (await Environment.get_global("starts_with?"))("=:",mval)))){
                            return await mval["substr"].call(mval,2)
                        } else {
                            return mval
                        }
                    })()) 
                })()]]],["eval_when",await (async function(){
                     return ((decs&& decs["eval_when"])|| new Object()) 
                })()]]]] 
            })())
        };
        let __array__275=[],__elements__273=symbol_list;
        let __BREAK__FLAG__=false;
        for(let __iter__272 in __elements__273) {
            __array__275.push(await __for_body__274(__elements__273[__iter__272]));
            if(__BREAK__FLAG__) {
                 __array__275.pop();
                break;
                
            }
        }return __array__275;
         
    })();
    return acc
};__obj__1["use_unique_symbols"]=async function(namespace) {
    if (check_true ((namespace instanceof String || typeof namespace==='string'))){
        {
            let symlist;
            symlist=await Environment["evaluate"].call(Environment,("("+ namespace+ "/symbols { `unique: true })"));
            (await Environment.eval(await async function(){
                return ["=:use_symbols",namespace,symlist]
            }(),null));
            return await (await Environment.get_global("length"))(symlist)
        }
    } else {
        throw new EvalError("provided namespace must be a string");
        
    }
};__obj__1["sort_dependencies"]=async function() {
    let ordered;
    let ns;
    let symname;
    let ns_marker;
    let symbol_marker;
    let splice_before;
    let current_pos;
    ordered=[];
    ns=null;
    symname=null;
    ns_marker=function(ns) {
        return ("*NS:"+ ns)
    };
    symbol_marker=function(ns,symbol_name) {
        return (""+ ns+ "/"+ symbol_name)
    };
    splice_before=async function(target_name,value_to_insert) {
        let idx;
        let value_idx;
        idx=await (await Environment.get_global("index_of"))(target_name,ordered);
        value_idx=await (await Environment.get_global("index_of"))(value_to_insert,ordered);
        return await async function(){
            if (check_true (((value_idx>-1)&& (value_idx===idx)))) {
                return true
            } else if (check_true (((value_idx>-1)&& (value_idx<idx)))) {
                return true
            } else if (check_true (((idx>-1)&& (value_idx===-1)))) {
                return await ordered["splice"].call(ordered,idx,0,value_to_insert)
            } else if (check_true (((idx===-1)&& (value_idx>-1)))) {
                return (ordered).push(target_name)
            } else if (check_true ((idx===-1))) {
                {
                    (ordered).push(value_to_insert);
                    return (ordered).push(target_name)
                }
            } else if (check_true (((idx>-1)&& (value_idx>-1)&& (idx<value_idx)))) {
                {
                    await ordered["splice"].call(ordered,value_idx,1);
                    return await ordered["splice"].call(ordered,idx,0,value_to_insert)
                }
            } else {
                return await console.log("fall through: target: ",target_name,"@",idx,"  ",value_to_insert,"@",value_idx)
            }
        } ()
    };
    current_pos=null;
    await (async function() {
        let __for_body__279=async function(name) {
            ns=await Environment["get_namespace_handle"].call(Environment,name);
            return await (async function() {
                let __for_body__283=async function(pset) {
                    {
                        let __symname__285= async function(){
                            return (pset && pset["0"])
                        };
                        let symdef;
                        {
                            let symname=await __symname__285();
                            ;
                            symdef=(pset && pset["1"]);
                            return await async function(){
                                if (check_true ((symdef && symdef["requires"]))) {
                                    return await (async function() {
                                        let __for_body__288=async function(req) {
                                            {
                                                let _expr_58599;
                                                let req_sym;
                                                let req_ns;
                                                let explicit;
                                                _expr_58599=await (async function(){
                                                     return await (await Environment.get_global("decomp_symbol"))(req) 
                                                })();
                                                req_sym=(_expr_58599 && _expr_58599["0"]);
                                                req_ns=(_expr_58599 && _expr_58599["1"]);
                                                explicit=(_expr_58599 && _expr_58599["2"]);
                                                if (check_true (req_ns)){
                                                    {
                                                        return await splice_before(await symbol_marker(name,symname),await symbol_marker(req_ns,req_sym))
                                                    }
                                                }
                                            }
                                        };
                                        let __array__289=[],__elements__287=(symdef && symdef["requires"]);
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__286 in __elements__287) {
                                            __array__289.push(await __for_body__288(__elements__287[__iter__286]));
                                            if(__BREAK__FLAG__) {
                                                 __array__289.pop();
                                                break;
                                                
                                            }
                                        }return __array__289;
                                         
                                    })()
                                } else {
                                    {
                                        if (check_true ((await (await Environment.get_global("index_of"))(await symbol_marker(name,symname),ordered)===-1))){
                                            {
                                                return (ordered).push(await symbol_marker(name,symname))
                                            }
                                        }
                                    }
                                }
                            } ()
                        }
                    }
                };
                let __array__284=[],__elements__282=await (await Environment.get_global("pairs"))((ns && ns["definitions"]));
                let __BREAK__FLAG__=false;
                for(let __iter__281 in __elements__282) {
                    __array__284.push(await __for_body__283(__elements__282[__iter__281]));
                    if(__BREAK__FLAG__) {
                         __array__284.pop();
                        break;
                        
                    }
                }return __array__284;
                 
            })()
        };
        let __array__280=[],__elements__278=await (await Environment.get_global("conj"))(["core"],await (async function(){
            let __collector;
            let __result;
            let __action;
            __collector=[];
            __result=null;
            __action=async function(name) {
                if (check_true (await (await Environment.get_global("not"))((name==="core")))){
                    {
                        return name
                    }
                }
            };
            ;
            await (async function() {
                let __for_body__292=async function(__item) {
                    __result=await __action(__item);
                    if (check_true (__result)){
                        return (__collector).push(__result)
                    }
                };
                let __array__293=[],__elements__291=await (await Environment.get_global("namespaces"))();
                let __BREAK__FLAG__=false;
                for(let __iter__290 in __elements__291) {
                    __array__293.push(await __for_body__292(__elements__291[__iter__290]));
                    if(__BREAK__FLAG__) {
                         __array__293.pop();
                        break;
                        
                    }
                }return __array__293;
                 
            })();
            return __collector
        })());
        let __BREAK__FLAG__=false;
        for(let __iter__277 in __elements__278) {
            __array__280.push(await __for_body__279(__elements__278[__iter__277]));
            if(__BREAK__FLAG__) {
                 __array__280.pop();
                break;
                
            }
        }return __array__280;
         
    })();
    return {
        namespaces:await (async function(){
            let acc;
            acc=[];
            {
                let __collector;
                let __result;
                let __action;
                __collector=[];
                __result=null;
                __action=async function(sym) {
                    let _expr_87788;
                    let nspace;
                    _expr_87788=await (async function(){
                         return await (await Environment.get_global("decomp_symbol"))(sym) 
                    })();
                    sym=(_expr_87788 && _expr_87788["0"]);
                    nspace=(_expr_87788 && _expr_87788["1"]);
                    if (check_true (await (await Environment.get_global("not"))(await (await Environment.get_global("contains?"))(nspace,acc)))){
                        {
                            (acc).push(nspace);
                            return nspace
                        }
                    }
                };
                ;
                await (async function() {
                    let __for_body__296=async function(__item) {
                        __result=await __action(__item);
                        if (check_true (__result)){
                            return (__collector).push(__result)
                        }
                    };
                    let __array__297=[],__elements__295=ordered;
                    let __BREAK__FLAG__=false;
                    for(let __iter__294 in __elements__295) {
                        __array__297.push(await __for_body__296(__elements__295[__iter__294]));
                        if(__BREAK__FLAG__) {
                             __array__297.pop();
                            break;
                            
                        }
                    }return __array__297;
                     
                })();
                return __collector
            }
        })(),symbols:ordered
    }
};__obj__1["symbols_by_namespace"]=async function(options) {
    let ns_handle;
    ns_handle=null;
    return await (await Environment.get_global("to_object"))(await (async function() {
        let __for_body__300=async function(ns) {
            ns_handle=await Environment["get_namespace_handle"].call(Environment,ns);
            if (check_true ((options && options["include_meta"]))){
                return await (async function(){
                    let __array_op_rval__313=ns;
                     if (__array_op_rval__313 instanceof Function){
                        return await __array_op_rval__313(await (await Environment.get_global("to_object"))(await (await Environment.get_global("conj"))(await (async function() {
                            let __for_body__304=async function(pset) {
                                {
                                    let sym_name;
                                    let val;
                                    sym_name=(pset && pset["0"]);
                                    val=(pset && pset["1"]);
                                    return await (async function(){
                                        let __array_op_rval__306=sym_name;
                                         if (__array_op_rval__306 instanceof Function){
                                            return await __array_op_rval__306(await (await Environment.get_global("add"))(new Object(),await (async function(){
                                                if (check_true ((null==(val && val["type"])))){
                                                    return {
                                                        type:"Unknown!"
                                                    }
                                                } else {
                                                    return new Object()
                                                }
                                            })(),val)) 
                                        } else {
                                            return [__array_op_rval__306,await (await Environment.get_global("add"))(new Object(),await (async function(){
                                                if (check_true ((null==(val && val["type"])))){
                                                    return {
                                                        type:"Unknown!"
                                                    }
                                                } else {
                                                    return new Object()
                                                }
                                            })(),val)]
                                        }
                                    })()
                                }
                            };
                            let __array__305=[],__elements__303=await (await Environment.get_global("pairs"))((ns_handle && ns_handle["definitions"]));
                            let __BREAK__FLAG__=false;
                            for(let __iter__302 in __elements__303) {
                                __array__305.push(await __for_body__304(__elements__303[__iter__302]));
                                if(__BREAK__FLAG__) {
                                     __array__305.pop();
                                    break;
                                    
                                }
                            }return __array__305;
                             
                        })(),await (async function() {
                            let __for_body__309=async function(pset) {
                                {
                                    let sym_name;
                                    let val;
                                    sym_name=(pset && pset["0"]);
                                    val=(pset && pset["1"]);
                                    return await (async function(){
                                        let __array_op_rval__312=sym_name;
                                         if (__array_op_rval__312 instanceof Function){
                                            return await __array_op_rval__312(await (await Environment.get_global("add"))({
                                                type:await (await Environment.get_global("sub_type"))(val)
                                            },await (async function(){
                                                let it;
                                                it=await (async function(){
                                                    let __targ__311=(ns_handle && ns_handle["definitions"]);
                                                    if (__targ__311){
                                                         return(__targ__311)[sym_name]
                                                    } 
                                                })();
                                                if (check_true (it)){
                                                    return it
                                                } else {
                                                    return new Object()
                                                }
                                            })())) 
                                        } else {
                                            return [__array_op_rval__312,await (await Environment.get_global("add"))({
                                                type:await (await Environment.get_global("sub_type"))(val)
                                            },await (async function(){
                                                let it;
                                                it=await (async function(){
                                                    let __targ__311=(ns_handle && ns_handle["definitions"]);
                                                    if (__targ__311){
                                                         return(__targ__311)[sym_name]
                                                    } 
                                                })();
                                                if (check_true (it)){
                                                    return it
                                                } else {
                                                    return new Object()
                                                }
                                            })())]
                                        }
                                    })()
                                }
                            };
                            let __array__310=[],__elements__308=await (await Environment.get_global("pairs"))((ns_handle && ns_handle["context"] && ns_handle["context"]["scope"]));
                            let __BREAK__FLAG__=false;
                            for(let __iter__307 in __elements__308) {
                                __array__310.push(await __for_body__309(__elements__308[__iter__307]));
                                if(__BREAK__FLAG__) {
                                     __array__310.pop();
                                    break;
                                    
                                }
                            }return __array__310;
                             
                        })()))) 
                    } else {
                        return [__array_op_rval__313,await (await Environment.get_global("to_object"))(await (await Environment.get_global("conj"))(await (async function() {
                            let __for_body__304=async function(pset) {
                                {
                                    let sym_name;
                                    let val;
                                    sym_name=(pset && pset["0"]);
                                    val=(pset && pset["1"]);
                                    return await (async function(){
                                        let __array_op_rval__306=sym_name;
                                         if (__array_op_rval__306 instanceof Function){
                                            return await __array_op_rval__306(await (await Environment.get_global("add"))(new Object(),await (async function(){
                                                if (check_true ((null==(val && val["type"])))){
                                                    return {
                                                        type:"Unknown!"
                                                    }
                                                } else {
                                                    return new Object()
                                                }
                                            })(),val)) 
                                        } else {
                                            return [__array_op_rval__306,await (await Environment.get_global("add"))(new Object(),await (async function(){
                                                if (check_true ((null==(val && val["type"])))){
                                                    return {
                                                        type:"Unknown!"
                                                    }
                                                } else {
                                                    return new Object()
                                                }
                                            })(),val)]
                                        }
                                    })()
                                }
                            };
                            let __array__305=[],__elements__303=await (await Environment.get_global("pairs"))((ns_handle && ns_handle["definitions"]));
                            let __BREAK__FLAG__=false;
                            for(let __iter__302 in __elements__303) {
                                __array__305.push(await __for_body__304(__elements__303[__iter__302]));
                                if(__BREAK__FLAG__) {
                                     __array__305.pop();
                                    break;
                                    
                                }
                            }return __array__305;
                             
                        })(),await (async function() {
                            let __for_body__309=async function(pset) {
                                {
                                    let sym_name;
                                    let val;
                                    sym_name=(pset && pset["0"]);
                                    val=(pset && pset["1"]);
                                    return await (async function(){
                                        let __array_op_rval__312=sym_name;
                                         if (__array_op_rval__312 instanceof Function){
                                            return await __array_op_rval__312(await (await Environment.get_global("add"))({
                                                type:await (await Environment.get_global("sub_type"))(val)
                                            },await (async function(){
                                                let it;
                                                it=await (async function(){
                                                    let __targ__311=(ns_handle && ns_handle["definitions"]);
                                                    if (__targ__311){
                                                         return(__targ__311)[sym_name]
                                                    } 
                                                })();
                                                if (check_true (it)){
                                                    return it
                                                } else {
                                                    return new Object()
                                                }
                                            })())) 
                                        } else {
                                            return [__array_op_rval__312,await (await Environment.get_global("add"))({
                                                type:await (await Environment.get_global("sub_type"))(val)
                                            },await (async function(){
                                                let it;
                                                it=await (async function(){
                                                    let __targ__311=(ns_handle && ns_handle["definitions"]);
                                                    if (__targ__311){
                                                         return(__targ__311)[sym_name]
                                                    } 
                                                })();
                                                if (check_true (it)){
                                                    return it
                                                } else {
                                                    return new Object()
                                                }
                                            })())]
                                        }
                                    })()
                                }
                            };
                            let __array__310=[],__elements__308=await (await Environment.get_global("pairs"))((ns_handle && ns_handle["context"] && ns_handle["context"]["scope"]));
                            let __BREAK__FLAG__=false;
                            for(let __iter__307 in __elements__308) {
                                __array__310.push(await __for_body__309(__elements__308[__iter__307]));
                                if(__BREAK__FLAG__) {
                                     __array__310.pop();
                                    break;
                                    
                                }
                            }return __array__310;
                             
                        })()))]
                    }
                })()
            } else {
                return await (async function(){
                    let __array_op_rval__319=ns;
                     if (__array_op_rval__319 instanceof Function){
                        return await __array_op_rval__319(await (async function(){
                             return await (await Environment.get_global("sort"))(await (async function(){
                                 return await async function(){
                                    if (check_true (false)) {
                                        {
                                            {
                                                let __collector;
                                                let __result;
                                                let __action;
                                                __collector=[];
                                                __result=null;
                                                __action=async function(pset) {
                                                    let name;
                                                    let val;
                                                    name=(pset && pset["0"]);
                                                    val=(pset && pset["1"]);
                                                    if (check_true (await (async function(){
                                                        let __array_op_rval__314=(options && options["filter_by"]);
                                                         if (__array_op_rval__314 instanceof Function){
                                                            return await __array_op_rval__314(name,{
                                                                type:await (await Environment.get_global("sub_type"))(val)
                                                            }) 
                                                        } else {
                                                            return [__array_op_rval__314,name,{
                                                                type:await (await Environment.get_global("sub_type"))(val)
                                                            }]
                                                        }
                                                    })())){
                                                        return name
                                                    }
                                                };
                                                ;
                                                await (async function() {
                                                    let __for_body__317=async function(__item) {
                                                        __result=await __action(__item);
                                                        if (check_true (__result)){
                                                            return (__collector).push(__result)
                                                        }
                                                    };
                                                    let __array__318=[],__elements__316=await (await Environment.get_global("pairs"))((ns_handle && ns_handle["context"] && ns_handle["context"]["scope"]));
                                                    let __BREAK__FLAG__=false;
                                                    for(let __iter__315 in __elements__316) {
                                                        __array__318.push(await __for_body__317(__elements__316[__iter__315]));
                                                        if(__BREAK__FLAG__) {
                                                             __array__318.pop();
                                                            break;
                                                            
                                                        }
                                                    }return __array__318;
                                                     
                                                })();
                                                return __collector
                                            }
                                        }
                                    } else {
                                        return await (await Environment.get_global("uniq"))(await (await Environment.get_global("conj"))(await (await Environment.get_global("keys"))((ns_handle && ns_handle["context"] && ns_handle["context"]["scope"])),await (await Environment.get_global("keys"))((ns_handle && ns_handle["definitions"]))))
                                    }
                                } () 
                            })()) 
                        })()) 
                    } else {
                        return [__array_op_rval__319,await (async function(){
                             return await (await Environment.get_global("sort"))(await (async function(){
                                 return await async function(){
                                    if (check_true (false)) {
                                        {
                                            {
                                                let __collector;
                                                let __result;
                                                let __action;
                                                __collector=[];
                                                __result=null;
                                                __action=async function(pset) {
                                                    let name;
                                                    let val;
                                                    name=(pset && pset["0"]);
                                                    val=(pset && pset["1"]);
                                                    if (check_true (await (async function(){
                                                        let __array_op_rval__314=(options && options["filter_by"]);
                                                         if (__array_op_rval__314 instanceof Function){
                                                            return await __array_op_rval__314(name,{
                                                                type:await (await Environment.get_global("sub_type"))(val)
                                                            }) 
                                                        } else {
                                                            return [__array_op_rval__314,name,{
                                                                type:await (await Environment.get_global("sub_type"))(val)
                                                            }]
                                                        }
                                                    })())){
                                                        return name
                                                    }
                                                };
                                                ;
                                                await (async function() {
                                                    let __for_body__317=async function(__item) {
                                                        __result=await __action(__item);
                                                        if (check_true (__result)){
                                                            return (__collector).push(__result)
                                                        }
                                                    };
                                                    let __array__318=[],__elements__316=await (await Environment.get_global("pairs"))((ns_handle && ns_handle["context"] && ns_handle["context"]["scope"]));
                                                    let __BREAK__FLAG__=false;
                                                    for(let __iter__315 in __elements__316) {
                                                        __array__318.push(await __for_body__317(__elements__316[__iter__315]));
                                                        if(__BREAK__FLAG__) {
                                                             __array__318.pop();
                                                            break;
                                                            
                                                        }
                                                    }return __array__318;
                                                     
                                                })();
                                                return __collector
                                            }
                                        }
                                    } else {
                                        return await (await Environment.get_global("uniq"))(await (await Environment.get_global("conj"))(await (await Environment.get_global("keys"))((ns_handle && ns_handle["context"] && ns_handle["context"]["scope"])),await (await Environment.get_global("keys"))((ns_handle && ns_handle["definitions"]))))
                                    }
                                } () 
                            })()) 
                        })()]
                    }
                })()
            }
        };
        let __array__301=[],__elements__299=await (await Environment.get_global("namespaces"))();
        let __BREAK__FLAG__=false;
        for(let __iter__298 in __elements__299) {
            __array__301.push(await __for_body__300(__elements__299[__iter__298]));
            if(__BREAK__FLAG__) {
                 __array__301.pop();
                break;
                
            }
        }return __array__301;
         
    })())
};__obj__1["*formatting_rules*"]={minor_indent:["defun","defun_sync","defmacro","define","when","let","destructuring_bind","while","for_each","fn","lambda","function","progn","do","reduce","cond","try","catch","macroexpand","compile","unless","for_with","no_await","reduce_sync"],keywords:["-","->","*","**","/","%","+","<","<<","<=","=","==","=>",">",">=",">>","and","apply","break","call","cond","debug","dec","declare","defconst","defglobal","defvar","do","dynamic_import","eq","eval","fn","for_each","for_with","function","function*","if","inc","instanceof","javascript","jslambda","lambda","let","list","new","or","progl","progn","prop","quote","quotel","quotem","return","set_prop","setq","static_import","throw","try","typeof","unquotem","while","yield"],functions:[],allocating_forms:new Object()};__obj__1["all_globals"]=async function() {
    let acc;
    acc=new Set();
    await (async function() {
        let __for_body__322=async function(ns) {
            return await (async function() {
                let __for_body__326=async function(k) {
                    return await acc["add"].call(acc,k)
                };
                let __array__327=[],__elements__325=await (await Environment.get_global("keys"))(await (await Environment.get_global("resolve_path"))(["global_ctx","scope"],await Environment["get_namespace_handle"].call(Environment,ns)));
                let __BREAK__FLAG__=false;
                for(let __iter__324 in __elements__325) {
                    __array__327.push(await __for_body__326(__elements__325[__iter__324]));
                    if(__BREAK__FLAG__) {
                         __array__327.pop();
                        break;
                        
                    }
                }return __array__327;
                 
            })()
        };
        let __array__323=[],__elements__321=await (await Environment.get_global("namespaces"))();
        let __BREAK__FLAG__=false;
        for(let __iter__320 in __elements__321) {
            __array__323.push(await __for_body__322(__elements__321[__iter__320]));
            if(__BREAK__FLAG__) {
                 __array__323.pop();
                break;
                
            }
        }return __array__323;
         
    })();
    return acc
};__obj__1["process_tree_symbols"]=async function(tree,prefix,_ctx) {
    let is_root;
    let rval;
    let symbol;
    let global_details;
    let allocator;
    let allocations;
    let sort_token;
    let format_token;
    is_root=(null==_ctx);
    rval=null;
    _ctx=(_ctx|| {
        acc:[],allocations:new Set(),symbols:new Set(),keywords:new Set(),literals:new Set(),globals:new Set(),global_detail:new Object()
    });
    symbol=null;
    global_details=null;
    allocator=null;
    allocations=null;
    sort_token=async function(t) {
        symbol=(""+ await (await Environment.get_global("as_lisp"))(t));
        if (check_true (await (await Environment.get_global("not"))((symbol===prefix)))){
            {
                return await async function(){
                    if (check_true ((t instanceof Array))) {
                        return await (await Environment.get_global("process_tree_symbols"))(t,prefix,_ctx)
                    } else if (check_true (await (await Environment.get_global("contains?"))(symbol,(await Environment.get_global("*formatting_rules*.keywords"))))) {
                        return await (_ctx && _ctx["keywords"])["add"].call((_ctx && _ctx["keywords"]),symbol)
                    } else if (check_true (await (async function(){
                        global_details=await (await Environment.get_global("meta_for_symbol"))(symbol,true);
                        return (await (await Environment.get_global("length"))(global_details)>0)
                    })())) {
                        {
                            return await (_ctx && _ctx["globals"])["add"].call((_ctx && _ctx["globals"]),symbol)
                        }
                    } else if (check_true (((t instanceof String || typeof t==='string')&& (await (await Environment.get_global("length"))(t)>2)&& await (await Environment.get_global("starts_with?"))(await (async function(){
                         return "=:" 
                    })(),t)))) {
                        return await (_ctx && _ctx["symbols"])["add"].call((_ctx && _ctx["symbols"]),(""+ await (await Environment.get_global("as_lisp"))(t)))
                    } else if (check_true ((await (await Environment.get_global("is_number?"))(t)|| (true===t)|| (false===t)|| ("nil"===(""+ await (await Environment.get_global("as_lisp"))(t)))))) {
                        return await (_ctx && _ctx["literals"])["add"].call((_ctx && _ctx["literals"]),(""+ t))
                    }
                } ()
            }
        }
    };
    format_token=async function(token) {
        return {
            value:(token && token.name),score:0,meta:await (async function(){
                if (check_true (((token && token["type"])==="arg"))){
                    return "local"
                } else {
                    return (token && token["type"])
                }
            })()
        }
    };
    await async function(){
        if (check_true (((tree instanceof Array)&& ((tree && tree.length)>0)))) {
            {
                allocator=await (async function(){
                    let __targ__328=(await Environment.get_global("*formatting_rules*.allocating_forms"));
                    if (__targ__328){
                         return(__targ__328)[(""+ await (await Environment.get_global("as_lisp"))(tree[0]))]
                    } 
                })();
                if (check_true (allocator instanceof Function)){
                    {
                        allocations=await (async function(){
                            let __array_op_rval__329=allocator;
                             if (__array_op_rval__329 instanceof Function){
                                return await __array_op_rval__329(tree) 
                            } else {
                                return [__array_op_rval__329,tree]
                            }
                        })();
                        await (async function() {
                            let __for_body__332=async function(allocation) {
                                symbol=(""+ await (await Environment.get_global("as_lisp"))(allocation));
                                if (check_true (await (await Environment.get_global("not"))(((symbol===prefix)|| (symbol==="\"&\""))))){
                                    {
                                        return await (_ctx && _ctx["allocations"])["add"].call((_ctx && _ctx["allocations"]),symbol)
                                    }
                                }
                            };
                            let __array__333=[],__elements__331=allocations;
                            let __BREAK__FLAG__=false;
                            for(let __iter__330 in __elements__331) {
                                __array__333.push(await __for_body__332(__elements__331[__iter__330]));
                                if(__BREAK__FLAG__) {
                                     __array__333.pop();
                                    break;
                                    
                                }
                            }return __array__333;
                             
                        })()
                    }
                };
                return await (async function() {
                    let __for_body__336=async function(t) {
                        return await sort_token(t)
                    };
                    let __array__337=[],__elements__335=tree;
                    let __BREAK__FLAG__=false;
                    for(let __iter__334 in __elements__335) {
                        __array__337.push(await __for_body__336(__elements__335[__iter__334]));
                        if(__BREAK__FLAG__) {
                             __array__337.pop();
                            break;
                            
                        }
                    }return __array__337;
                     
                })()
            }
        } else if (check_true ((tree instanceof Object))) {
            {
                await (async function() {
                    let __for_body__340=async function(pset) {
                        await (_ctx && _ctx["literals"])["add"].call((_ctx && _ctx["literals"]),(pset && pset["0"]));
                        return await sort_token((pset && pset["1"]))
                    };
                    let __array__341=[],__elements__339=await (await Environment.get_global("pairs"))(tree);
                    let __BREAK__FLAG__=false;
                    for(let __iter__338 in __elements__339) {
                        __array__341.push(await __for_body__340(__elements__339[__iter__338]));
                        if(__BREAK__FLAG__) {
                             __array__341.pop();
                            break;
                            
                        }
                    }return __array__341;
                     
                })()
            }
        } else {
            await sort_token(tree)
        }
    } ();
    if (check_true (is_root)){
        {
            rval={
                allocations:await (async function(){
                     return await (await Environment.get_global("to_array"))((_ctx && _ctx["allocations"])) 
                })(),symbols:await (async function(){
                     return await (await Environment.get_global("to_array"))((_ctx && _ctx["symbols"])) 
                })(),keywords:await (async function(){
                     return await (await Environment.get_global("to_array"))((_ctx && _ctx["keywords"])) 
                })(),literals:await (async function(){
                     return await (await Environment.get_global("to_array"))((_ctx && _ctx["literals"])) 
                })(),globals:await (async function(){
                     return await (await Environment.get_global("to_array"))((_ctx && _ctx["globals"])) 
                })()
            }
        }
    };
    return rval
};__obj__1["keys*"]=function(obj) {
        if (check_true ((obj instanceof Object))){
            {
                let current_obj;
                let prototypes;
                let properties;
                current_obj=obj;
                prototypes=[];
                properties= ( Environment.get_global("first"))(prototypes);
                 ( function(){
                     let __body_ref__343=function() {
                        properties=new Set();
                        (prototypes).push(properties);
                         ( function() {
                            let __for_body__346=function(item) {
                                return  properties["add"].call(properties,item)
                            };
                            let __array__347=[],__elements__345= Object.getOwnPropertyNames(current_obj);
                            let __BREAK__FLAG__=false;
                            for(let __iter__344 in __elements__345) {
                                __array__347.push( __for_body__346(__elements__345[__iter__344]));
                                if(__BREAK__FLAG__) {
                                     __array__347.pop();
                                    break;
                                    
                                }
                            }return __array__347;
                             
                        })();
                        return current_obj= Object.getPrototypeOf(current_obj)
                    };
                    let __BREAK__FLAG__=false;
                    while(current_obj) {  __body_ref__343();
                     if(__BREAK__FLAG__) {
                         break;
                        
                    }
                } ;
                
            })();
            return  ( Environment.get_global("flatten"))( ( function() {
                let __for_body__350=function(s) {
                    return  ( function() {
                        {
                             let __call_target__= Array.from(s), __call_method__="sort";
                            return  __call_target__[__call_method__]()
                        } 
                    })()
                };
                let __array__351=[],__elements__349=prototypes;
                let __BREAK__FLAG__=false;
                for(let __iter__348 in __elements__349) {
                    __array__351.push( __for_body__350(__elements__349[__iter__348]));
                    if(__BREAK__FLAG__) {
                         __array__351.pop();
                        break;
                        
                    }
                }return __array__351;
                 
            })())
        }
    } else {
        throw new TypeError("keys*: invalid object as argument");
        
    }
};__obj__1["pairs*"]=function(obj) {
        if (check_true ((obj instanceof Object))){
            return  ( function() {
                let __for_body__354=function(k) {
                    return  ( function(){
                        let __array_op_rval__356=k;
                         if (__array_op_rval__356 instanceof Function){
                            return  __array_op_rval__356(obj[k]) 
                        } else {
                            return [__array_op_rval__356,obj[k]]
                        }
                    })()
                };
                let __array__355=[],__elements__353= ( Environment.get_global("keys*"))(obj);
                let __BREAK__FLAG__=false;
                for(let __iter__352 in __elements__353) {
                    __array__355.push( __for_body__354(__elements__353[__iter__352]));
                    if(__BREAK__FLAG__) {
                         __array__355.pop();
                        break;
                        
                    }
                }return __array__355;
                 
            })()
        }
    };__obj__1["for"]=async function(...args) {
    let symbol_list;
    let array_ref;
    let body_forms;
    symbol_list=(args && args["0"] && args["0"]["0"]);
    array_ref=(args && args["0"] && args["0"]["1"]);
    body_forms=await (await Environment.get_global("slice"))(args,1);
    {
        let sym_list;
        sym_list=symbol_list;
        if (check_true ((sym_list instanceof Array))){
            return ["=:for_each",["=:_pset",array_ref],["=:destructuring_bind",sym_list,"=:_pset",].concat(body_forms)]
        } else {
            return ["=:for_each",[sym_list,array_ref],["=:progn",].concat(body_forms)]
        }
    }
};__obj__1["word_wrap"]=function(text,ncols) {
        let line_length;
        let words;
        let max_cols;
        let current_line;
        let lines;
        line_length=0;
        words=(text).split(" ");
        max_cols=(ncols|| 80);
        current_line=[];
        lines=[];
         ( function() {
            let __for_body__359=function(word) {
                return   (function(){
                    if (check_true (((line_length+  ( Environment.get_global("length"))(word))>=max_cols))) {
                        {
                            (lines).push((current_line).join(" "));
                            current_line= ( function(){
                                let __array_op_rval__361=word;
                                 if (__array_op_rval__361 instanceof Function){
                                    return  __array_op_rval__361() 
                                } else {
                                    return [__array_op_rval__361]
                                }
                            })();
                            return line_length= ( Environment.get_global("add"))( ( Environment.get_global("length"))(word),1)
                        }
                    } else {
                        {
                            (current_line).push(word);
                            return line_length+= ( Environment.get_global("add"))( ( Environment.get_global("length"))(word),1)
                        }
                    }
                } )()
            };
            let __array__360=[],__elements__358=(words|| []);
            let __BREAK__FLAG__=false;
            for(let __iter__357 in __elements__358) {
                __array__360.push( __for_body__359(__elements__358[__iter__357]));
                if(__BREAK__FLAG__) {
                     __array__360.pop();
                    break;
                    
                }
            }return __array__360;
             
        })();
        if (check_true (((current_line && current_line.length)>0))){
            (lines).push((current_line).join(" "))
        };
        return lines
    };__obj__1["progc"]=async function(...args) {
    let forms;
    forms=await (await Environment.get_global("slice"))(args,0);
    return ["=:try",["=:progn",].concat(forms),["=:catch","=:Error",["=:e"],["=:log","=:e.message"]]]
};__obj__1["reverse_string"]=function(text) {
        return ( ( function() {
            {
                 let __call_target__=(text).split(""), __call_method__="reverse";
                return  __call_target__[__call_method__]()
            } 
        })()).join("")
    };__obj__1["last_n_chars"]=function(n,text) {
        if (check_true ((text instanceof String || typeof text==='string'))){
            return  text["substr"].call(text,(-1* n))
        } else {
            return null
        }
    };__obj__1["last_n"]=function(n,arr) {
        if (check_true ((arr instanceof Array))){
            return  arr["slice"].call(arr,(-1* n))
        } else {
            return null
        }
    };__obj__1["analyze_text_line"]=function(line) {
        let delta;
        let indent_spaces;
        let base_indent;
        let idx;
        let openers;
        let closers;
        let code_mode;
        let cpos;
        let last_c;
        let last_delim;
        delta=0;
        indent_spaces=0;
        base_indent=null;
        idx=-1;
        openers=[];
        closers=[];
        code_mode=true;
        cpos=null;
        last_c=null;
        last_delim=null;
         ( function() {
            let __for_body__364=function(c) {
                idx+=1;
                  (function(){
                    if (check_true (((c==="\"")&& ((null==last_c)|| (last_c&&  ( Environment.get_global("not"))((92=== last_c["charCodeAt"]()))))))) {
                        return code_mode= ( Environment.get_global("not"))(code_mode)
                    } else if (check_true ((code_mode&& (c===";")))) {
                        {
                            __BREAK__FLAG__=true;
                            return
                        }
                    } else if (check_true ((code_mode&& ((c==="(")|| (c==="{")|| (c==="["))))) {
                        {
                            delta+=1;
                            (openers).push(idx);
                            base_indent=indent_spaces;
                            cpos=idx;
                            last_delim=c
                        }
                    } else if (check_true ((code_mode&& ((c===")")|| (c==="]")|| (c==="}"))))) {
                        {
                            delta-=1;
                            (closers).push(idx);
                            cpos=idx;
                            last_delim=c
                        }
                    } else if (check_true ((code_mode&& (c===" ")&&  ( Environment.get_global("not"))(base_indent)))) {
                        {
                            indent_spaces+=1
                        }
                    } else if (check_true ( ( Environment.get_global("not"))(base_indent))) {
                        base_indent=indent_spaces
                    }
                } )();
                return last_c=c
            };
            let __array__365=[],__elements__363=(line).split("");
            let __BREAK__FLAG__=false;
            for(let __iter__362 in __elements__363) {
                __array__365.push( __for_body__364(__elements__363[__iter__362]));
                if(__BREAK__FLAG__) {
                     __array__365.pop();
                    break;
                    
                }
            }return __array__365;
             
        })();
        if (check_true ((undefined==base_indent))){
            {
                base_indent=indent_spaces
            }
        };
        return {
            delta:delta,final_type:last_delim,final_pos:cpos,line:line,indent:base_indent,openers:openers,closers:closers
        }
    };__obj__1["calculate_indent_rule"]=function(delta,movement_needed) {
        let lisp_line;
        let remainder_pos;
        let remainder;
        let comps;
        let symbol_details;
        lisp_line= (delta && delta["line"])["substr"].call((delta && delta["line"]), ( Environment.get_global("first"))((delta && delta["openers"])));
        remainder_pos= ( function(){
            if (check_true (((delta && delta["openers"] && delta["openers"]["length"])>0))){
                return ( ( function(){
                    let __targ__366=(delta && delta["openers"]);
                    if (__targ__366){
                         return(__targ__366)[(movement_needed- 1)]
                    } 
                })()||  ( Environment.get_global("first"))((delta && delta["openers"]))|| (delta && delta["indent"]))
            } else {
                return 0
            }
        })();
        remainder= (delta && delta["line"])["substr"].call((delta && delta["line"]),(1+ remainder_pos));
        comps= ( function(){
            let __collector;
            let __result;
            let __action;
            __collector=[];
            __result=null;
            __action=function(c) {
                if (check_true ( ( Environment.get_global("not"))( ( Environment.get_global("blank?"))(c)))){
                    {
                        return c
                    }
                }
            };
            ;
             ( function() {
                let __for_body__369=function(__item) {
                    __result= __action(__item);
                    if (check_true (__result)){
                        return (__collector).push(__result)
                    }
                };
                let __array__370=[],__elements__368=(remainder).split(" ");
                let __BREAK__FLAG__=false;
                for(let __iter__367 in __elements__368) {
                    __array__370.push( __for_body__369(__elements__368[__iter__367]));
                    if(__BREAK__FLAG__) {
                         __array__370.pop();
                        break;
                        
                    }
                }return __array__370;
                 
            })();
            return __collector
        })();
        symbol_details= ( function(){
            if (check_true ((((comps && comps.length)>0)&&  ( Environment.get_global("not"))( ( Environment.get_global("contains?"))("(",(comps && comps["0"])))&&  ( Environment.get_global("not"))( ( Environment.get_global("contains?"))("{",(comps && comps["0"])))&&  ( Environment.get_global("not"))( ( Environment.get_global("contains?"))("[",(comps && comps["0"])))))){
                return ( ( Environment.get_global("first"))( ( Environment.get_global("meta_for_symbol"))((comps && comps["0"]),true))|| {
                    type:"-"
                })
            } else {
                return {
                    type:"-"
                }
            }
        })();
          (function(){
            if (check_true ((movement_needed===0))) {
                return true
            } else if (check_true ((((comps && comps.length)===0)&& ((delta && delta["openers"] && delta["openers"]["length"])===0)&& ((delta && delta["closers"] && delta["closers"]["length"])===0)))) {
                true
            } else if (check_true (( ( Environment.get_global("starts_with?"))("def",(comps && comps["0"]))||  ( Environment.get_global("contains?"))((comps && comps["0"]),( Environment.get_global("*formatting_rules*.minor_indent")))))) {
                {
                      (function(){
                        delta["indent"]=(remainder_pos+ 3);
                        return delta;
                        
                    })()
                }
            } else if (check_true (((((symbol_details && symbol_details["type"])&&  ( Environment.get_global("contains?"))("Function",(symbol_details && symbol_details["type"])))||  ( Environment.get_global("contains?"))((comps && comps["0"]),( Environment.get_global("*formatting_rules*.keywords"))))&&  ( Environment.get_global("contains?"))((delta && delta["final_type"]),["(","[",")","]"])))) {
                {
                    if (check_true ((( ( Environment.get_global("length"))((delta && delta["closers"]))===0)&& ( ( Environment.get_global("length"))((delta && delta["openers"]))===1)))){
                        {
                              (function(){
                                delta["indent"]=(remainder_pos+ 3);
                                return delta;
                                
                            })()
                        }
                    } else {
                        {
                              (function(){
                                delta["indent"]=(remainder_pos+ (comps && comps["0"] && comps["0"]["length"])+ 2);
                                return delta;
                                
                            })()
                        }
                    }
                }
            } else if (check_true ( ( Environment.get_global("contains?"))((comps && comps["0"]),( Environment.get_global("built_ins"))))) {
                {
                      (function(){
                        delta["indent"]=(remainder_pos+ (comps && comps["0"] && comps["0"]["length"])+ 2);
                        return delta;
                        
                    })()
                }
            } else if (check_true (((delta && delta["final_type"])==="["))) {
                {
                      (function(){
                        delta["indent"]=(remainder_pos+ 1);
                        return delta;
                        
                    })()
                }
            } else if (check_true (( ( Environment.get_global("starts_with?"))("[",(comps && comps["0"]))||  ( Environment.get_global("starts_with?"))("(",(comps && comps["0"]))))) {
                {
                      (function(){
                        delta["indent"]=(remainder_pos+ 1);
                        return delta;
                        
                    })()
                }
            } else if (check_true (((comps && comps.length)===1))) {
                {
                      (function(){
                        delta["indent"]=(remainder_pos+ 3);
                        return delta;
                        
                    })()
                }
            } else if (check_true ((((delta && delta["final_type"])==="{")&& (movement_needed>0)))) {
                {
                      (function(){
                        delta["indent"]=(remainder_pos+ 2);
                        return delta;
                        
                    })()
                }
            } else if (check_true (((comps && comps.length)===0))) {
                {
                      (function(){
                        delta["indent"]=(1+ remainder_pos);
                        return delta;
                        
                    })()
                }
            } else {
                {
                      (function(){
                        delta["indent"]=(remainder_pos+ (comps && comps["0"] && comps["0"]["length"])+ 2);
                        return delta;
                        
                    })()
                }
            }
        } )();
        return delta
    };__obj__1["format_lisp_line"]=function(line_number,get_line) {
        if (check_true (((line_number>0)&& get_line instanceof Function))){
            {
                let current_row;
                let prior_line;
                let delta;
                let movement_needed;
                let orig_movement_needed;
                let comps;
                let final;
                let in_seek;
                current_row=(line_number- 1);
                prior_line= ( function(){
                    let v= ( function(){
                        let __array_op_rval__381=get_line;
                         if (__array_op_rval__381 instanceof Function){
                            return  __array_op_rval__381(current_row) 
                        } else {
                            return [__array_op_rval__381,current_row]
                        }
                    })();
                    ;
                     ( function(){
                         let __test_condition__382=function() {
                            return (((v).trim()==="")&& (current_row>0))
                        };
                        let __body_ref__383=function() {
                            current_row-=1;
                            return v= ( function(){
                                let __array_op_rval__384=get_line;
                                 if (__array_op_rval__384 instanceof Function){
                                    return  __array_op_rval__384(current_row) 
                                } else {
                                    return [__array_op_rval__384,current_row]
                                }
                            })()
                        };
                        let __BREAK__FLAG__=false;
                        while( __test_condition__382()) {
                              __body_ref__383();
                             if(__BREAK__FLAG__) {
                                 break;
                                
                            }
                        } ;
                        
                    })();
                    return (v|| "")
                })();
                delta= ( Environment.get_global("analyze_text_line"))(prior_line);
                movement_needed=0;
                orig_movement_needed=0;
                comps=null;
                final=(delta && delta["final_type"]);
                in_seek=((delta && delta["openers"] && delta["openers"]["length"])<(delta && delta["closers"] && delta["closers"]["length"]));
                movement_needed=(delta && delta["delta"]);
                orig_movement_needed=movement_needed;
                  (function(){
                    if (check_true ((movement_needed<0))) {
                        {
                            let lisp_line;
                            let remainder_pos;
                            let remainder;
                            let symbol_details;
                            lisp_line=null;
                            remainder_pos=null;
                            remainder=null;
                            symbol_details=null;
                             ( function(){
                                 let __test_condition__385=function() {
                                    return ((movement_needed<0)&& (current_row>0))
                                };
                                let __body_ref__386=function() {
                                    current_row-=1;
                                    prior_line= ( function(){
                                        let __array_op_rval__387=get_line;
                                         if (__array_op_rval__387 instanceof Function){
                                            return  __array_op_rval__387(current_row) 
                                        } else {
                                            return [__array_op_rval__387,current_row]
                                        }
                                    })();
                                     ( function(){
                                         let __test_condition__388=function() {
                                            return ((current_row>0)&& ((prior_line).trim()===""))
                                        };
                                        let __body_ref__389=function() {
                                            current_row-=1;
                                            return prior_line= ( function(){
                                                let __array_op_rval__390=get_line;
                                                 if (__array_op_rval__390 instanceof Function){
                                                    return  __array_op_rval__390(current_row) 
                                                } else {
                                                    return [__array_op_rval__390,current_row]
                                                }
                                            })()
                                        };
                                        let __BREAK__FLAG__=false;
                                        while( __test_condition__388()) {
                                              __body_ref__389();
                                             if(__BREAK__FLAG__) {
                                                 break;
                                                
                                            }
                                        } ;
                                        
                                    })();
                                    delta= ( Environment.get_global("analyze_text_line"))(prior_line);
                                    return movement_needed=(movement_needed+ (delta && delta["delta"]))
                                };
                                let __BREAK__FLAG__=false;
                                while( __test_condition__385()) {
                                      __body_ref__386();
                                     if(__BREAK__FLAG__) {
                                         break;
                                        
                                    }
                                } ;
                                
                            })();
                            return delta= ( Environment.get_global("calculate_indent_rule"))(delta,movement_needed)
                        }
                    } else if (check_true ((movement_needed>0))) {
                        {
                            return delta= ( Environment.get_global("calculate_indent_rule"))(delta,movement_needed)
                        }
                    }
                } )();
                return ( ( function() {
                    let __for_body__393=function(c) {
                        return " "
                    };
                    let __array__394=[],__elements__392= ( Environment.get_global("range"))( Math.max(0,(delta && delta["indent"])));
                    let __BREAK__FLAG__=false;
                    for(let __iter__391 in __elements__392) {
                        __array__394.push( __for_body__393(__elements__392[__iter__391]));
                        if(__BREAK__FLAG__) {
                             __array__394.pop();
                            break;
                            
                        }
                    }return __array__394;
                     
                })()).join("")
            }
        }
    };__obj__1["set_default"]=async function(path,value) {
    let real_path;
    real_path=await (async function(){
         return await async function(){
            if (check_true (((path instanceof String || typeof path==='string')&& await (await Environment.get_global("starts_with?"))("=:",path)&& await (await Environment.get_global("contains?"))(".",path)))) {
                return ((""+ await (await Environment.get_global("as_lisp"))(path))).split(".")
            } else if (check_true (((path instanceof String || typeof path==='string')&& await (await Environment.get_global("contains?"))(".",path)))) {
                return (path).split(".")
            } else if (check_true (((path instanceof String || typeof path==='string')&& await (await Environment.get_global("contains?"))("~",path)))) {
                return (path).split("~")
            } else {
                return path
            }
        } () 
    })();
    return ["=:progn",["=:unless",["=:is_array?",real_path],["=:throw","=:ReferenceError","set_default: invalid path specification, needs to be an array, string or symbol."]],["=:defvar","=:__first_val",["=:first",real_path]],["=:if",["=:contains?","=:__first_val",["=:list","features","build","imports","included_libraries"]],["=:throw","=:ReferenceError",["=:+","set_default: the path value ","doesn't reference a default value setting"]]],["=:if",["=:resolve_path",real_path,"=:*env_config*"],["=:set_path",real_path,"=:*env_config*",value],["=:make_path",real_path,"=:*env_config*",value]],["=:resolve_path",real_path,"=:*env_config*"]]
};__obj__1["get_default"]=async function(key,alt_val) {
    if (check_true ((key instanceof Array))){
        return (await (await Environment.get_global("resolve_multi_path"))(key,(await Environment.get_global("*env_config*")))|| alt_val)
    } else {
        throw new TypeError("get_default: key must be an array");
        
    }
};__obj__1["traverse"]=async function(structure,operator_function,_path) {
    let __path__395= async function(){
        return (_path|| [])
    };
    {
        let path=await __path__395();
        ;
        if (check_true ((null==operator_function))){
            throw new Error("traverse: requires a function as a second argument");
            
        };
        await async function(){
            if (check_true ((structure instanceof Array))) {
                {
                    await (async function(){
                        let __array_op_rval__396=operator_function;
                         if (__array_op_rval__396 instanceof Function){
                            return await __array_op_rval__396(structure,path) 
                        } else {
                            return [__array_op_rval__396,structure,path]
                        }
                    })();
                    return await (await Environment.get_global("map"))(async function(elem,idx) {
                        return await (await Environment.get_global("traverse"))(elem,operator_function,await (await Environment.get_global("conj"))(path,idx))
                    },structure)
                }
            } else if (check_true ((structure instanceof Object))) {
                {
                    await (async function(){
                        let __array_op_rval__397=operator_function;
                         if (__array_op_rval__397 instanceof Function){
                            return await __array_op_rval__397(structure,path) 
                        } else {
                            return [__array_op_rval__397,structure,path]
                        }
                    })();
                    await (async function() {
                        let __for_body__400=async function(pset) {
                            {
                                let key;
                                let value;
                                key=(pset && pset["0"]);
                                value=(pset && pset["1"]);
                                return await (await Environment.get_global("traverse"))(value,operator_function,await (await Environment.get_global("conj"))(path,key))
                            }
                        };
                        let __array__401=[],__elements__399=await (await Environment.get_global("pairs"))(structure);
                        let __BREAK__FLAG__=false;
                        for(let __iter__398 in __elements__399) {
                            __array__401.push(await __for_body__400(__elements__399[__iter__398]));
                            if(__BREAK__FLAG__) {
                                 __array__401.pop();
                                break;
                                
                            }
                        }return __array__401;
                         
                    })()
                }
            } else {
                await (async function(){
                    let __array_op_rval__402=operator_function;
                     if (__array_op_rval__402 instanceof Function){
                        return await __array_op_rval__402(structure,path) 
                    } else {
                        return [__array_op_rval__402,structure,path]
                    }
                })()
            }
        } ();
        return structure
    }
};__obj__1["all_global_functions"]=function() {
        let acc;
        let env_a;
        acc=new Set();
        env_a=null;
         ( function() {
            let __for_body__405=function(ns) {
                env_a= Environment["get_namespace_handle"].call(Environment,ns);
                return  ( function() {
                    let __for_body__409=function(pset) {
                        if (check_true ((pset && pset["1"]) instanceof Function)){
                            return  acc["add"].call(acc,(pset && pset["0"]))
                        }
                    };
                    let __array__410=[],__elements__408= ( Environment.get_global("pairs"))((env_a && env_a["context"] && env_a["context"]["scope"]));
                    let __BREAK__FLAG__=false;
                    for(let __iter__407 in __elements__408) {
                        __array__410.push( __for_body__409(__elements__408[__iter__407]));
                        if(__BREAK__FLAG__) {
                             __array__410.pop();
                            break;
                            
                        }
                    }return __array__410;
                     
                })()
            };
            let __array__406=[],__elements__404= ( Environment.get_global("namespaces"))();
            let __BREAK__FLAG__=false;
            for(let __iter__403 in __elements__404) {
                __array__406.push( __for_body__405(__elements__404[__iter__403]));
                if(__BREAK__FLAG__) {
                     __array__406.pop();
                    break;
                    
                }
            }return __array__406;
             
        })();
        return acc
    };__obj__1["pretty_print"]=function(in_struct,report_callout) {
        let in_text;
        let chars;
        let key_words;
        let block_words;
        let conditionals;
        let char;
        let global_lookup;
        let last_opener;
        let operator;
        let next_char;
        let next_char_pos;
        let state;
        let lines;
        let formatted_lines;
        let line_acc;
        let rule;
        let cpos;
        let debug_mode;
        let closers;
        let openers;
        let code_mode;
        let string_mode;
        let escape_state;
        let mode;
        let nl_suppress;
        let skip_for;
        let depth_change;
        let long_string_mode;
        let report;
        let lpos;
        let lnum;
        let argnum;
        let text;
        let word;
        let word_acc;
        let add_char_to_line;
        let next_line;
        let is_whitespace_ques_;
        let indent_string;
        let get_line;
        let calc_next_char;
        in_text= ( function(){
             return   (function(){
                if (check_true ((in_struct instanceof Object))) {
                    return  ( Environment.get_global("as_lisp"))(in_struct)
                } else if (check_true ((in_struct instanceof String || typeof in_struct==='string'))) {
                    return in_struct
                } else {
                    return (""+ in_struct)
                }
            } )() 
        })();
        chars=(in_text).split("");
        key_words= ( function(){
            let __targ__411=( Environment.get_global("*formatting_rules*"));
            if (__targ__411){
                 return(__targ__411)["keywords"]
            } 
        })();
        block_words=["try","progn","progl","progc","do","let","cond"];
        conditionals=["if","when","unless"];
        char=null;
        global_lookup= ( function(){
            let tmp= ( Environment.get_global("all_global_functions"))();
            ;
             ( function() {
                let __for_body__414=function(op) {
                    return  tmp["add"].call(tmp,op)
                };
                let __array__415=[],__elements__413=(key_words|| []);
                let __BREAK__FLAG__=false;
                for(let __iter__412 in __elements__413) {
                    __array__415.push( __for_body__414(__elements__413[__iter__412]));
                    if(__BREAK__FLAG__) {
                         __array__415.pop();
                        break;
                        
                    }
                }return __array__415;
                 
            })();
            return tmp
        })();
        last_opener=null;
        operator=null;
        next_char=null;
        next_char_pos=0;
        state=new Object();
        lines=[];
        formatted_lines=[];
        line_acc=[];
        rule=null;
        cpos=-1;
        debug_mode= ( function(){
            if (check_true (report_callout)){
                return true
            } else {
                return false
            }
        })();
        closers=[")","]","}"];
        openers=["(","[","{"];
        code_mode=0;
        string_mode=1;
        escape_state=0;
        mode=code_mode;
        nl_suppress=false;
        skip_for=null;
        depth_change=0;
        long_string_mode=2;
        report=[];
        lpos=0;
        lnum=0;
        argnum=0;
        text=null;
        word="";
        word_acc=[];
        add_char_to_line=function(c) {
            (line_acc).push((c|| char));
            return lpos=(line_acc && line_acc.length)
        };
        next_line=function() {
            (lines).push((line_acc).join(""));
            lnum=(lines && lines.length);
            depth_change=0;
            return line_acc=[]
        };
        is_whitespace_ques_=function(c) {
            return  ( Environment.get_global("contains?"))(c,[" ","	"])
        };
        indent_string=null;
        get_line=function(rnum) {
            let it;
            it=lines[rnum];
            if (check_true (it)){
                if (check_true ( ( Environment.get_global("ends_with?"))("\n",it))){
                    return it
                } else {
                    return (it+ "\n")
                }
            } else {
                return null
            }
        };
        calc_next_char=function() {
            if (check_true (chars[(1+ cpos)])){
                {
                    next_char_pos=(cpos+ 1);
                     ( function(){
                         let __test_condition__416=function() {
                            return (chars[next_char_pos]&&  is_whitespace_ques_(chars[next_char_pos]))
                        };
                        let __body_ref__417=function() {
                            return next_char_pos+=1
                        };
                        let __BREAK__FLAG__=false;
                        while( __test_condition__416()) {
                              __body_ref__417();
                             if(__BREAK__FLAG__) {
                                 break;
                                
                            }
                        } ;
                        
                    })();
                    return next_char=chars[next_char_pos]
                }
            }
        };
         ( function(){
             let __test_condition__418=function() {
                return (cpos<(chars && chars.length))
            };
            let __body_ref__419=function() {
                cpos+=1;
                char=chars[cpos];
                rule=null;
                if (check_true (char)){
                    {
                        if (check_true ((skip_for&& (skip_for>0)))){
                            skip_for-=1
                        };
                        if (check_true (( char["charCodeAt"]()===92))){
                            escape_state=2
                        } else {
                            escape_state= Math.max(0,(escape_state- 1))
                        };
                        if (check_true (((mode===code_mode)&& (cpos>=next_char_pos)))){
                            {
                                if (check_true ((nl_suppress&& (skip_for===null)))){
                                    {
                                        skip_for=2
                                    }
                                };
                                 calc_next_char()
                            }
                        };
                        if (check_true (((mode===code_mode)&& ( is_whitespace_ques_(char)||  ( Environment.get_global("contains?"))(char,openers)||  ( Environment.get_global("contains?"))(char,closers)|| (char===":")|| (char==="\n"))))){
                            {
                                if (check_true (((word_acc && word_acc.length)>0))){
                                    {
                                        word=(word_acc).join("");
                                        if (check_true ((((last_opener==="(")|| (last_opener==="["))&&  ( Environment.get_global("not"))( ( Environment.get_global("starts_with?"))("\"",word))&&  ( Environment.get_global("not"))( ( Environment.get_global("starts_with?"))("`",word))))){
                                            operator=word
                                        }
                                    }
                                };
                                word_acc=[]
                            }
                        } else {
                            (word_acc).push(char)
                        };
                        if (check_true (((mode===code_mode)&& (char==="}")&&  ( Environment.get_global("not"))(( ( Environment.get_global("last"))(line_acc)==="{"))&&  ( Environment.get_global("not"))( ( Environment.get_global("contains?"))( ( Environment.get_global("last"))(line_acc),closers))&&  ( Environment.get_global("not"))(( ( Environment.get_global("last"))(line_acc)===" "))))){
                             add_char_to_line(" ")
                        };
                        if (check_true (((mode===code_mode)&&  ( Environment.get_global("contains?"))(char,openers)))){
                            last_opener=char
                        };
                        if (check_true (((mode===code_mode)&& ( ( Environment.get_global("contains?"))(char,closers)||  is_whitespace_ques_(char))))){
                            last_opener=null
                        };
                        if (check_true ((skip_for===0))){
                            {
                                nl_suppress=false;
                                skip_for=null
                            }
                        };
                          (function(){
                            if (check_true (((mode===code_mode)&& (char==="\"")))) {
                                {
                                    return mode=string_mode
                                }
                            } else if (check_true (((mode===code_mode)&& ("|"===char)))) {
                                {
                                    return mode=long_string_mode
                                }
                            } else if (check_true (((char==="\"")&& (mode===string_mode)&& (escape_state===0)))) {
                                {
                                    return mode=code_mode
                                }
                            } else if (check_true (((char==="|")&& (mode===long_string_mode)))) {
                                {
                                    return mode=code_mode
                                }
                            } else if (check_true (( ( Environment.get_global("contains?"))(char,openers)&& (mode===code_mode)))) {
                                {
                                    return argnum=0
                                }
                            } else if (check_true (((char===":")&& (mode===code_mode)))) {
                                {
                                    argnum+=1;
                                    return nl_suppress=true
                                }
                            }
                        } )();
                        if (check_true ((mode===code_mode))){
                            {
                                  (function(){
                                    if (check_true ( ( Environment.get_global("contains?"))(char,openers))) {
                                        return depth_change+=1
                                    } else if (check_true ( ( Environment.get_global("contains?"))(char,closers))) {
                                        depth_change-=1
                                    }
                                } )();
                                  (function(){
                                    if (check_true (( is_whitespace_ques_(char)&&  ( Environment.get_global("contains?"))(next_char,closers)&& (argnum>1)&&  ( Environment.get_global("not"))(nl_suppress)))) {
                                        {
                                            rule="r0!";
                                            return  next_line()
                                        }
                                    } else if (check_true (( is_whitespace_ques_(char)&& (word&&  ( Environment.get_global("contains?"))(word,block_words))))) {
                                        {
                                            rule="rb!";
                                             next_line()
                                        }
                                    } else if (check_true (( is_whitespace_ques_(char)&& (argnum>=1)&&  ( Environment.get_global("not"))( ( Environment.get_global("contains?"))( ( Environment.get_global("last"))(line_acc),closers))&& (depth_change>-1)&& (depth_change<2)&&  ( Environment.get_global("contains?"))(operator,conditionals)))) {
                                        {
                                            rule="rC";
                                             next_line()
                                        }
                                    } else if (check_true (( is_whitespace_ques_(char)&& (argnum<2)&& (depth_change<2)&& (lpos<30)&&  ( Environment.get_global("not"))( ( Environment.get_global("contains?"))( ( Environment.get_global("last"))(line_acc),closers))&& ( ( Environment.get_global("not"))( ( Environment.get_global("starts_with?"))("\"",(word|| "")))&&  ( Environment.get_global("not"))( ( Environment.get_global("starts_with?"))("`",(word|| "")))&& (depth_change>-1))&& ((next_char_pos- cpos)<=1)))) {
                                        {
                                             add_char_to_line();
                                            argnum+=1;
                                            rule="r1+"
                                        }
                                    } else if (check_true (( is_whitespace_ques_(char)&& (argnum===0)&& ( ( Environment.get_global("not"))( ( Environment.get_global("starts_with?"))("\"",(word|| "")))&&  ( Environment.get_global("not"))( ( Environment.get_global("starts_with?"))("`",(word|| "")))&& (word&&  global_lookup["has"].call(global_lookup,word))&&  ( Environment.get_global("not"))(("()"===( ( Environment.get_global("last_n"))(2,line_acc)).join("")))&& (depth_change>-1))))) {
                                        {
                                             add_char_to_line();
                                            argnum+=1;
                                            rule="rc"
                                        }
                                    } else if (check_true (( is_whitespace_ques_(char)&&  ( Environment.get_global("not"))(nl_suppress)&&  ( Environment.get_global("not"))((next_char==="{"))&& ((next_char_pos- cpos)<=1)))) {
                                        {
                                            rule="r2!";
                                             next_line();
                                            nl_suppress=true
                                        }
                                    } else if (check_true (( ( Environment.get_global("contains?"))(char,openers)&&  ( Environment.get_global("not"))(nl_suppress)&& (argnum>1)))) {
                                        {
                                            rule="r3!";
                                            nl_suppress=true;
                                             next_line();
                                             add_char_to_line();
                                            argnum=0
                                        }
                                    } else if (check_true (( ( Environment.get_global("contains?"))(char,openers)&& (argnum>1)))) {
                                        {
                                            rule="r3A";
                                             add_char_to_line();
                                            argnum=0
                                        }
                                    } else if (check_true (( is_whitespace_ques_(char)&&  ( Environment.get_global("not"))(nl_suppress)&& (depth_change<0)))) {
                                        {
                                            rule="r4!";
                                             next_line();
                                            argnum=0
                                        }
                                    } else if (check_true (( is_whitespace_ques_(char)&&  ( Environment.get_global("not"))(nl_suppress)&& (lpos>40)))) {
                                        {
                                            rule="r5!";
                                             next_line();
                                            argnum=0
                                        }
                                    } else if (check_true (((char==="{")&&  ( Environment.get_global("not"))( is_whitespace_ques_(chars[(1+ cpos)]))&&  ( Environment.get_global("not"))((chars[(1+ cpos)]==="}"))))) {
                                        {
                                            rule="r6";
                                             add_char_to_line();
                                             add_char_to_line(" ")
                                        }
                                    } else if (check_true (((char===":")&&  ( Environment.get_global("not"))((" "===chars[(1+ cpos)]))))) {
                                        {
                                            rule="r7";
                                             add_char_to_line();
                                             add_char_to_line(" ")
                                        }
                                    } else {
                                        {
                                            rule="r99";
                                             add_char_to_line()
                                        }
                                    }
                                } )()
                            }
                        } else {
                            {
                                rule="rD";
                                 add_char_to_line()
                            }
                        };
                        if (check_true (debug_mode)){
                            {
                                return (report).push( ( function(){
                                    let __array_op_rval__420=cpos;
                                     if (__array_op_rval__420 instanceof Function){
                                        return  __array_op_rval__420(char, ( function(){
                                            if (check_true ((cpos<=next_char_pos))){
                                                return next_char
                                            } else {
                                                return ""
                                            }
                                        })(),lpos,(next_char_pos- cpos),depth_change,mode,argnum, ( function(){
                                            if (check_true (((mode===code_mode)&&  is_whitespace_ques_(char)))){
                                                return "*"
                                            } else {
                                                return ""
                                            }
                                        })(), ( function(){
                                            if (check_true (nl_suppress)){
                                                return " NLS "
                                            } else {
                                                return ""
                                            }
                                        })(), ( function(){
                                            if (check_true (skip_for)){
                                                return skip_for
                                            } else {
                                                return ""
                                            }
                                        })(),rule,word,operator,(line_acc).join("")) 
                                    } else {
                                        return [__array_op_rval__420,char, ( function(){
                                            if (check_true ((cpos<=next_char_pos))){
                                                return next_char
                                            } else {
                                                return ""
                                            }
                                        })(),lpos,(next_char_pos- cpos),depth_change,mode,argnum, ( function(){
                                            if (check_true (((mode===code_mode)&&  is_whitespace_ques_(char)))){
                                                return "*"
                                            } else {
                                                return ""
                                            }
                                        })(), ( function(){
                                            if (check_true (nl_suppress)){
                                                return " NLS "
                                            } else {
                                                return ""
                                            }
                                        })(), ( function(){
                                            if (check_true (skip_for)){
                                                return skip_for
                                            } else {
                                                return ""
                                            }
                                        })(),rule,word,operator,(line_acc).join("")]
                                    }
                                })())
                            }
                        }
                    }
                }
            };
            let __BREAK__FLAG__=false;
            while( __test_condition__418()) {
                  __body_ref__419();
                 if(__BREAK__FLAG__) {
                     break;
                    
                }
            } ;
            
        })();
        if (check_true (debug_mode)){
            {
                 ( function(){
                    let __array_op_rval__421=report_callout;
                     if (__array_op_rval__421 instanceof Function){
                        return  __array_op_rval__421(report,{
                            columns:["CPOS","CHAR","NEXTC","LPOS","NCD","DEPTHC","MODE","ARGNUM","WS?","NLS?","SKIP_FOR","rule","word","op","Line_ACC"]
                        }) 
                    } else {
                        return [__array_op_rval__421,report,{
                            columns:["CPOS","CHAR","NEXTC","LPOS","NCD","DEPTHC","MODE","ARGNUM","WS?","NLS?","SKIP_FOR","rule","word","op","Line_ACC"]
                        }]
                    }
                })()
            }
        };
        if (check_true (((line_acc && line_acc.length)>0))){
            {
                (lines).push((line_acc).join(""))
            }
        };
         ( function() {
            let __for_body__424=function(line_num) {
                text=(""+ lines[line_num]+ "\n");
                if (check_true ((line_num>0))){
                    indent_string= ( Environment.get_global("format_lisp_line"))(line_num,get_line)
                } else {
                    indent_string=""
                };
                return   (function(){
                    lines[line_num]=(""+ indent_string+ text);
                    return lines;
                    
                })()
            };
            let __array__425=[],__elements__423= ( Environment.get_global("range"))((lines && lines.length));
            let __BREAK__FLAG__=false;
            for(let __iter__422 in __elements__423) {
                __array__425.push( __for_body__424(__elements__423[__iter__422]));
                if(__BREAK__FLAG__) {
                     __array__425.pop();
                    break;
                    
                }
            }return __array__425;
             
        })();
        return (lines).join("")
    };__obj__1["get_dependencies"]=async function(global_symbol,_deps,_req_ns,_externs) {
    let comps;
    let target_symbol;
    let namespace;
    let added;
    let externals;
    let required_namespaces;
    let dependencies;
    let ns_env;
    let sym_meta;
    comps=(global_symbol).split("/");
    target_symbol=await (async function(){
        if (check_true (((comps && comps.length)>1))){
            return await (await Environment.get_global("second"))(comps)
        } else {
            return await (await Environment.get_global("first"))(comps)
        }
    })();
    namespace=await (async function(){
        if (check_true (((comps && comps.length)>1))){
            return await (await Environment.get_global("first"))(comps)
        } else {
            return null
        }
    })();
    added=false;
    externals=(_externs|| new Set());
    required_namespaces=(_req_ns|| new Set());
    dependencies=(_deps|| new Set());
    ns_env=await Environment["get_namespace_handle"].call(Environment,await (await Environment.get_global("current_namespace"))());
    sym_meta=await ns_env["eval"].call(ns_env,await (async function(){
         return ["=:meta_for_symbol",target_symbol,true] 
    })());
    await async function(){
        if (check_true ((namespace&& sym_meta&& ((sym_meta && sym_meta.length)>0)))) {
            return await (async function() {
                let __for_body__429=async function(m) {
                    if (check_true (((m && m["namespace"])===namespace))){
                        {
                            sym_meta=m;
                            return __BREAK__FLAG__=true;
                            return
                        }
                    }
                };
                let __array__430=[],__elements__428=sym_meta;
                let __BREAK__FLAG__=false;
                for(let __iter__427 in __elements__428) {
                    __array__430.push(await __for_body__429(__elements__428[__iter__427]));
                    if(__BREAK__FLAG__) {
                         __array__430.pop();
                        break;
                        
                    }
                }return __array__430;
                 
            })()
        } else {
            {
                sym_meta=await (await Environment.get_global("first"))(sym_meta);
                namespace=(sym_meta && sym_meta["namespace"])
            }
        }
    } ();
    if (check_true ((namespace&& await (await Environment.get_global("not"))(await required_namespaces["has"].call(required_namespaces,namespace))))){
        await required_namespaces["add"].call(required_namespaces,namespace)
    };
    if (check_true ((sym_meta && sym_meta["externals"]))){
        {
            await (async function() {
                let __for_body__433=async function(external_ref) {
                    return await externals["add"].call(externals,external_ref)
                };
                let __array__434=[],__elements__432=(sym_meta && sym_meta["externals"]);
                let __BREAK__FLAG__=false;
                for(let __iter__431 in __elements__432) {
                    __array__434.push(await __for_body__433(__elements__432[__iter__431]));
                    if(__BREAK__FLAG__) {
                         __array__434.pop();
                        break;
                        
                    }
                }return __array__434;
                 
            })()
        }
    };
    if (check_true ((sym_meta&& namespace))){
        {
            await (async function() {
                let __for_body__437=async function(required_symbol) {
                    if (check_true (await (await Environment.get_global("not"))(await dependencies["has"].call(dependencies,required_symbol)))){
                        {
                            added=true;
                            return await dependencies["add"].call(dependencies,required_symbol)
                        }
                    }
                };
                let __array__438=[],__elements__436=(sym_meta && sym_meta["requires"]);
                let __BREAK__FLAG__=false;
                for(let __iter__435 in __elements__436) {
                    __array__438.push(await __for_body__437(__elements__436[__iter__435]));
                    if(__BREAK__FLAG__) {
                         __array__438.pop();
                        break;
                        
                    }
                }return __array__438;
                 
            })();
            if (check_true (added)){
                await (async function() {
                    let __for_body__441=async function(required_symbol) {
                        return await (await Environment.get_global("get_dependencies"))(required_symbol,dependencies,required_namespaces,externals)
                    };
                    let __array__442=[],__elements__440=(sym_meta && sym_meta["requires"]);
                    let __BREAK__FLAG__=false;
                    for(let __iter__439 in __elements__440) {
                        __array__442.push(await __for_body__441(__elements__440[__iter__439]));
                        if(__BREAK__FLAG__) {
                             __array__442.pop();
                            break;
                            
                        }
                    }return __array__442;
                     
                })()
            }
        }
    };
    if (check_true ((null==_deps))){
        {
            return {
                dependencies:await (async function(){
                     return await (await Environment.get_global("to_array"))(dependencies) 
                })(),namespaces:await (async function(){
                     return await (await Environment.get_global("to_array"))(required_namespaces) 
                })(),externals:await (async function(){
                     return await (await Environment.get_global("to_array"))(externals) 
                })()
            }
        }
    }
};__obj__1["pad_left"]=function(value,pad_amount,padchar) {
        return  ( function() {
            {
                 let __call_target__=(""+ value), __call_method__="padStart";
                return  __call_target__[__call_method__].call(__call_target__,pad_amount,padchar)
            } 
        })()
    };__obj__1["symbol_dependencies"]=async function(symbol_array) {
    if (check_true ((symbol_array instanceof Array))){
        {
            {
                let dependencies;
                let ns_deps;
                let externals;
                let deps;
                dependencies=new Set();
                ns_deps=new Set();
                externals=new Set();
                deps=null;
                await (async function() {
                    let __for_body__445=async function(sym) {
                        return await (await Environment.get_global("get_dependencies"))(sym,dependencies,ns_deps,externals)
                    };
                    let __array__446=[],__elements__444=symbol_array;
                    let __BREAK__FLAG__=false;
                    for(let __iter__443 in __elements__444) {
                        __array__446.push(await __for_body__445(__elements__444[__iter__443]));
                        if(__BREAK__FLAG__) {
                             __array__446.pop();
                            break;
                            
                        }
                    }return __array__446;
                     
                })();
                return {
                    dependencies:await (async function(){
                         return await (await Environment.get_global("to_array"))(dependencies) 
                    })(),namespaces:await (async function(){
                         return await (await Environment.get_global("to_array"))(ns_deps) 
                    })(),externals:await (async function(){
                         return await (await Environment.get_global("to_array"))(externals) 
                    })()
                }
            }
        }
    }
};__obj__1["keyword_mapper"]=function(token) {
        if (check_true ( ( Environment.get_global("contains?"))(token,( Environment.get_global("*formatting_rules*.keywords"))))){
            return "keyword"
        } else {
            return "identifier"
        }
    };__obj__1["with_each_entry"]=async function(...args) {
    let binding_sym;
    let iteration_form;
    let body_forms;
    binding_sym=(args && args["0"] && args["0"]["0"]);
    iteration_form=(args && args["1"]);
    body_forms=await (await Environment.get_global("slice"))(args,2);
    return ["=:let",[["=:__data_val__",iteration_form],[binding_sym,"=:nil"],["=:__next_val__","=:nil"]],["=:if",["=:is_function?","=:__data_val__.next"],["=:while",["=:=","=:__next_val__",["=:->","=:__data_val__","next"]],["=:progn",["=:=",binding_sym,"=:__next_val__.value"],].concat(body_forms,[["=:if","=:__next_val__.done",["=:break"]]])],["=:throw","=:TypeError","with_each_entry: iteration_form is not an iterator"]]]
};__obj__1["operating_system"]=function() {
            return  ( Environment.get_global("resolve_path"))(["build","os"],Deno)
        };__obj__1["platform_architecture"]=function() {
        return  ( Environment.get_global("resolve_path"))(["build","arch"],Deno)
    };__obj__1["platform"]=function() {
        return Deno["build"]
    };__obj__1["exit"]=function(return_code) {
        return  Deno.exit(return_code)
    };__obj__1["permissions"]=async function() {
    let perms;
    perms=["run","env","write","read","net","ffi","sys"];
    return await (await Environment.get_global("to_object"))(await (async function() {
        let __for_body__449=async function(p) {
            return await (async function(){
                let __array_op_rval__452=p;
                 if (__array_op_rval__452 instanceof Function){
                    return await __array_op_rval__452(await (async function(){
                        let __targ__451=await Deno.permissions.query({
                            name:p
                        });
                        if (__targ__451){
                             return(__targ__451)["state"]
                        } 
                    })()) 
                } else {
                    return [__array_op_rval__452,await (async function(){
                        let __targ__451=await Deno.permissions.query({
                            name:p
                        });
                        if (__targ__451){
                             return(__targ__451)["state"]
                        } 
                    })()]
                }
            })()
        };
        let __array__450=[],__elements__448=perms;
        let __BREAK__FLAG__=false;
        for(let __iter__447 in __elements__448) {
            __array__450.push(await __for_body__449(__elements__448[__iter__447]));
            if(__BREAK__FLAG__) {
                 __array__450.pop();
                break;
                
            }
        }return __array__450;
         
    })())
};__obj__1["compiler"]=async function(quoted_lisp,opts) {
    let Environment=(opts && opts["env"]);
    ;
    let get_global=(opts && opts["env"] && opts["env"]["get_global"]);
    ;
    {
        let length=function anonymous(obj) {
{
                         if(obj instanceof Array) {
                             return obj.length;
                             } else if (obj instanceof Set) {
                              return obj.size;
                              } else if ((obj === undefined)||(obj===null)) {
                               return 0;
                               } else if (typeof obj==='object') {
                                return Object.keys(obj).length;
                                } else if (typeof obj==='string') {
                                 return obj.length;
                                 }
                         return 0;
                         }
};
        let first=function anonymous(x) {
{ return x[0] }
};
        let second=function anonymous(x) {
{ return x[1] }
};
        let map=async function anonymous(lambda,array_values) {
{ try {
                      let rval = [],
                      tl = array_values.length;
                      for (let i = 0; i < array_values.length; i++) {
                             rval.push(await lambda.apply(this,[array_values[i], i, tl]));
                             }
                      return rval;
                      } catch (ex) {
                       if (lambda === undefined || lambda === null) {
                             throw new ReferenceError("map: lambda argument (position 0) is undefined or nil")
                             } else if (array_values === undefined || array_values === null) {
                              throw new ReferenceError("map: container argument (position 1) is undefined or nil")
                              } else if (!(lambda instanceof Function)) {
                               throw new ReferenceError("map: lambda argument must be a function: received: "+ typeof lambda)
                               } else if (!(array_values instanceof Array)) {
                                throw new ReferenceError("map: invalid array argument, received: " + typeof array_values)
                                } else {
                                 // something else just pass on the error
                                 throw ex;
                                 }
                       }
                 }
};
        let do_deferred_splice=async function(tree) {    let rval;
    let idx;
    let tval;
    let deferred_operator;
    rval=null;
    idx=0;
    tval=null;
    deferred_operator=(["=","$","&","!"]).join("");
    return await async function(){
        if (check_true ((tree instanceof Array))) {
            {
                rval=[];
                await (async function(){
                     let __test_condition__21=async function() {
                        return (idx<(tree && tree.length))
                    };
                    let __body_ref__22=async function() {
                        tval=tree[idx];
                        if (check_true ((tval===deferred_operator))){
                            {
                                idx+=1;
                                tval=tree[idx];
                                rval=await rval["concat"].call(rval,await (async function(){
                                     return await do_deferred_splice(tval) 
                                })())
                            }
                        } else {
                            (rval).push(await (async function(){
                                 return await do_deferred_splice(tval) 
                            })())
                        };
                        return idx+=1
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__21()) {
                         await __body_ref__22();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                return rval
            }
        } else if (check_true ((tree instanceof Object))) {
            {
                rval=new Object();
                await (async function() {
                    let __for_body__25=async function(pset) {
                        return await async function(){
                            rval[(pset && pset["0"])]=await (async function(){
                                 return await do_deferred_splice((pset && pset["1"])) 
                            })();
                            return rval;
                            
                        }()
                    };
                    let __array__26=[],__elements__24=await (await Environment.get_global("pairs"))(tree);
                    let __BREAK__FLAG__=false;
                    for(let __iter__23 in __elements__24) {
                        __array__26.push(await __for_body__25(__elements__24[__iter__23]));
                        if(__BREAK__FLAG__) {
                             __array__26.pop();
                            break;
                            
                        }
                    }return __array__26;
                     
                })();
                return rval
            }
        } else {
            return tree
        }
    } ()
};
        let not=function anonymous(x) {
{ if (check_true(x)) { return false } else { return true } }
};
        let sub_type=function subtype(value) {  if (value === null) return "null";  else if (value === undefined) return "undefined";
  else if (value instanceof Array) return "array";
  else if (value.constructor && value.constructor!=null && value.constructor.name!=='Object') {
    return value.constructor.name;
  }
  return typeof value;
};
        let last=function anonymous(x) {
{ return x[x.length - 1] }
};
        let flatten=function anonymous(x) {
{ return x.flat(999999999999) } 
};
        let add=function anonymous(...args) {
{
                   let acc;
                   if (typeof args[0]==="number") {
                        acc = 0;
                        } else if (args[0] instanceof Array) {
                         return args[0].concat(args.slice(1));
                         } else if (typeof args[0]==='object') {
                          let rval = {};
                          for (let i in args) {
                                 if (typeof args[i] === 'object') {
                                      for (let k in args[i]) {
                                             rval[k] = args[i][k];
                                             }
                                      }
                                 }
                          return rval;
                          } else {
                           acc = "";
                           }
                   for (let i in args) {
                          acc += args[i];
                          }
                   return acc;
                   }
};
        let subtype=function subtype(value) {  if (value === null) return "null";
  else if (value === undefined) return "undefined";
  else if (value instanceof Array) return "array";
  else if (value.constructor && value.constructor!=null && value.constructor.name!=='Object') {
    return value.constructor.name;
  }
  return typeof value;
};
        let is_nil_ques_=async function(value) {    return (null===value)
};
        let is_number_ques_=function(x) {                        return ( subtype(x)==="Number")
                    };
        let starts_with_ques_=function anonymous(val,text) {
{ if (text instanceof Array) { return text[0]===val } else if (subtype(text)=='String') { return text.startsWith(val) } else { return false }}
};
        let uniq=async function(values) {    let s;
    s=new Set();
    await (await Environment.get_global("map"))(async function(x) {
        return await s["add"].call(s,x)
    },(values|| []));
    return await (await Environment.get_global("to_array"))(s)
};
        let object_methods=async function(obj) {    let properties;
    let current_obj;
    properties=new Set();
    current_obj=obj;
    await (async function(){
         let __body_ref__264=async function() {
            await (await Environment.get_global("map"))(async function(item) {
                return await properties["add"].call(properties,item)
            },await Object.getOwnPropertyNames(current_obj));
            return current_obj=await Object.getPrototypeOf(current_obj)
        };
        let __BREAK__FLAG__=false;
        while(current_obj) { await __body_ref__264();
         if(__BREAK__FLAG__) {
             break;
            
        }
    } ;
    
})();
return await (async function() {
    {
         let __call_target__=await Array.from(await properties["keys"]()), __call_method__="filter";
        return await __call_target__[__call_method__].call(__call_target__,async function(item) {
            return item instanceof Function
        })
    } 
})()
};
        let conj=function anonymous(...args) {
{   let list = [];
                       if (args[0] instanceof Array) {
                            list = args[0];
                            } else {
                             list = [args[0]];
                             }
                       args.slice(1).map(function(x) {
                                          list = list.concat(x);
                                          });
                       return list;
                       }
};
        let cl_encode_string=async function(text) {    if (check_true ((text instanceof String || typeof text==='string'))){
        {
            let escaped;
            let nq;
            let step1;
            let snq;
            escaped=await (await Environment.get_global("replace"))(new RegExp("\n","g"),await (await Environment.get_global("add"))(await String.fromCharCode(92),"n"),text);
            escaped=await (await Environment.get_global("replace"))(new RegExp("\r","g"),await (await Environment.get_global("add"))(await String.fromCharCode(92),"r"),escaped);
            nq=(escaped).split(await String.fromCharCode(34));
            step1=(nq).join(await (await Environment.get_global("add"))(await String.fromCharCode(92),await String.fromCharCode(34)));
            snq=(step1).split(await String.fromCharCode(39));
            return step1
        }
    } else {
        return text
    }
};
        let contains_ques_=function anonymous(value,container) {
{ if (!value && !container) { return false }
                         else if (container === null) { throw new TypeError("contains?: passed nil/undefined container value"); }
                                            else if (container instanceof Array) return container.includes(value);
                                            else if (container instanceof Set) return container.has(value);
                                            else if ((container instanceof String) || typeof container === "string") {
                                                     if (subtype(value) === "Number") return container.indexOf(""+value)>-1;
                                                     else return container.indexOf(value)>-1;
                                                     }
                                            else throw new TypeError("contains?: passed invalid container type: "+subtype(container)) }
};
        let tree;
        let expanded_tree;
        let op;
        let default_safety_level;
        let source_name;
        let build_environment_mode;
        let env_ref;
        let operator;
        let break_out;
        let tokens;
        let tokenized;
        let target_namespace;
        let errors;
        let external_dependencies;
        let first_level_setup;
        let needs_first_level;
        let signal_error;
        let warnings;
        let blk_counter;
        let ctx;
        let output;
        let __log__1= async function(){
            return await Environment.get_global("log")
        };
        let __defclog__2= async function(){
            return async function(opts) {
                let style;
                style=("padding: 5px;"+ await (async function(){
                    if (check_true ((opts && opts["background"]))){
                        return ("background: "+ (opts && opts["background"])+ ";")
                    } else {
                        return ""
                    }
                })()+ await (async function(){
                    if (check_true ((opts && opts["color"]))){
                        return ("color: "+ (opts && opts["color"])+ ";")
                    }
                })()+ "");
                ;
                return async function(...args) {
                    return await (async function(){
                        let __target_arg__8=[].concat(await conj([style],args));
                        if(!__target_arg__8 instanceof Array){
                            throw new TypeError("Invalid final argument to apply - an array is required")
                        }let __pre_arg__9=("%c"+ await (async function(){
                            if (check_true ((opts && opts["prefix"]))){
                                return (opts && opts["prefix"])
                            } else {
                                return (args).shift()
                            }
                        })());
                        __target_arg__8.unshift(__pre_arg__9);
                        return (console.log).apply(this,__target_arg__8)
                    })()
                }
            }
        };
        let quiet_mode;
        let show_hints;
        let error_log;
        let dynamic_references_ques_;
        let assembly;
        let async_function_type_placeholder;
        let function_type_placeholder;
        let type_marker;
        let return_marker;
        let entry_signature;
        let temp_fn_asn_template;
        let anon_fn_template;
        let build_fn_with_assignment;
        let build_anon_fn;
        let completion_types;
        let referenced_global_symbols;
        let referenced_externals;
        let __new_ctx__3= async function(){
            return function(parent) {
                let ctx_obj;
                ctx_obj=new Object();
                  (function(){
                    ctx_obj["scope"]=new Object();
                    ctx_obj["source"]=source_name;
                    ctx_obj["parent"]=parent;
                    ctx_obj["ambiguous"]=new Object();
                    ctx_obj["declared_types"]=new Object();
                    ctx_obj["defs"]=[];
                    return ctx_obj;
                    
                })();
                if (check_true (parent)){
                    {
                          (function(){
                            let __target_obj__19=(ctx_obj && ctx_obj["scope"]);
                            __target_obj__19["namespace"]=(parent && parent["scope"] && parent["scope"]["namespace"]);
                            return __target_obj__19;
                            
                        })();
                        if (check_true ((parent && parent["defvar_eval"]))){
                            {
                                  (function(){
                                    ctx_obj["defvar_eval"]=true;
                                    return ctx_obj;
                                    
                                })()
                            }
                        };
                        if (check_true ((parent && parent["has_first_level"]))){
                            {
                                  (function(){
                                    ctx_obj["has_first_level"]=true;
                                    return ctx_obj;
                                    
                                })()
                            }
                        };
                        if (check_true ((parent && parent["block_step"]))){
                            {
                                  (function(){
                                    ctx_obj["block_step"]=(parent && parent["block_step"]);
                                    return ctx_obj;
                                    
                                })()
                            }
                        };
                        if (check_true ((parent && parent["block_id"]))){
                            {
                                  (function(){
                                    ctx_obj["block_id"]=(parent && parent["block_id"]);
                                    return ctx_obj;
                                    
                                })()
                            }
                        };
                        if (check_true ((parent && parent["sub_block_step"]))){
                            {
                                  (function(){
                                    ctx_obj["sub_block_step"]=(parent && parent["sub_block_step"]);
                                    return ctx_obj;
                                    
                                })()
                            }
                        };
                        if (check_true (false)){
                            {
                                  (function(){
                                    ctx_obj["return_point"]= add((parent && parent["return_point"]),1);
                                    return ctx_obj;
                                    
                                })()
                            }
                        }
                    }
                };
                return ctx_obj
            }
        };
        let set_ctx_log;
        let map_ctype_to_value;
        let map_value_to_ctype;
        let set_ctx;
        let get_ctx;
        let get_ctx_val;
        let get_declarations;
        let set_declaration;
        let is_ambiguous_ques_;
        let set_ambiguous;
        let unset_ambiguous;
        let invalid_js_ref_chars;
        let invalid_js_ref_chars_regex;
        let check_invalid_js_ref;
        let __sanitize_js_ref_name__4= async function(){
            return await Environment.get_global("sanitize_js_ref_name")
        };
        let find_in_context;
        let source_chain;
        let source_from_tokens;
        let source_comment;
        let NOT_FOUND;
        let THIS_REFERENCE;
        let NOT_FOUND_THING;
        let get_lisp_ctx_log;
        let get_lisp_ctx;
        let get_val;
        let has_lisp_globals;
        let root_ctx;
        let tokenize_object;
        let tokenize_quote;
        let tokenize;
        let comp_time_log;
        let compile_time_eval;
        let infix_ops;
        let compile_set_prop;
        let compile_prop;
        let compile_elem;
        let inline_log;
        let compile_inline;
        let compile_push;
        let compile_list;
        let compile_typeof;
        let compile_instanceof;
        let compile_compare;
        let compile_assignment;
        let top_level_log;
        let compile_toplevel;
        let check_statement_completion;
        let compile_block;
        let Expression;
        let Statement;
        let NumberType;
        let StringType;
        let NilType;
        let UnknownType;
        let ArgumentType;
        let compile_defvar;
        let get_declaration_details;
        let clean_quoted_reference;
        let compile_let;
        let in_sync_ques_;
        let await_ques_;
        let calling_preamble;
        let fn_log;
        let completion_scope_id;
        let set_new_completion_scope;
        let compile_fn;
        let compile_jslambda;
        let compile_yield;
        let var_counter;
        let gen_temp_name;
        let if_id;
        let compile_cond;
        let compile_cond_inner;
        let ensure_block;
        let compile_if;
        let compile_as_call;
        let compile_wrapper_fn;
        let compile_block_to_anon_fn;
        let make_do_block;
        let push_as_arg_list;
        let compile_new;
        let compile_val_mod;
        let compile_try;
        let compile_try_inner;
        let compile_throw;
        let compile_break;
        let compile_return;
        let apply_log;
        let compile_apply;
        let compile_call;
        let compile_call_inner;
        let check_needs_wrap;
        let compile_import;
        let compile_dynamic_import;
        let compile_javascript;
        let compile_set_global;
        let is_token_ques_;
        let compile_quote;
        let compile_quotel;
        let wrap_and_run;
        let quote_tree;
        let quotem_log;
        let compile_quotem;
        let compile_unquotem;
        let eval_log;
        let compile_eval;
        let compile_debug;
        let compile_for_each;
        let compile_for_each_inner;
        let compile_while;
        let compile_for_with;
        let compile_for_with_inner;
        let silence;
        let verbosity;
        let check_verbosity;
        let declare_log;
        let compile_declare;
        let safety_level;
        let get_scoped_type;
        let compile_scoped_reference;
        let compile_lisp_scoped_reference;
        let standard_types;
        let externals;
        let is_error;
        let is_block_ques_;
        let is_complex_ques_;
        let is_form_ques_;
        let op_lookup;
        let comp_log;
        let last_source;
        let output_validation;
        let compile_obj_literal;
        let is_literal_ques_;
        let comp_warn;
        let __compile__5= async function(){
            return async function(tokens,ctx,_cdepth) {
                if (check_true (is_error)){
                    return is_error
                } else {
                    {
                        let rval=await compile_inner(tokens,ctx,_cdepth);
                        ;
                        if (check_true (is_error)){
                            {
                                if (check_true ((opts && opts["throw_on_error"]))){
                                    {
                                        let error=new Error((is_error && is_error["error"]));
                                        ;
                                        await (async function() {
                                            let __for_body__555=async function(pset) {
                                                return await async function(){
                                                    error[(pset && pset["0"])]=(pset && pset["1"]);
                                                    return error;
                                                    
                                                }()
                                            };
                                            let __array__556=[],__elements__554=await (await Environment.get_global("pairs"))(is_error);
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__553 in __elements__554) {
                                                __array__556.push(await __for_body__555(__elements__554[__iter__553]));
                                                if(__BREAK__FLAG__) {
                                                     __array__556.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__556;
                                             
                                        })();
                                        throw error;
                                        
                                    }
                                }
                            }
                        };
                        return rval
                    }
                }
            }
        };
        let compile_inner;
        let final_token_assembly;
        let main_log;
        let assemble_output;
        {
            tree=quoted_lisp;
            expanded_tree=await (async function(){
                 return await clone(tree) 
            })();
            op=null;
            default_safety_level=((Environment && Environment["declarations"] && Environment["declarations"]["safety"] && Environment["declarations"]["safety"]["level"])|| 1);
            source_name=((opts && opts["source_name"])|| "anonymous");
            build_environment_mode=((opts && opts["build_environment"])|| false);
            env_ref=await (async function(){
                if (check_true (build_environment_mode)){
                    return ""
                } else {
                    return "Environment."
                }
            })();
            operator=null;
            break_out="__BREAK__FLAG__";
            tokens=[];
            tokenized=null;
            target_namespace=null;
            errors=[];
            external_dependencies=new Object();
            first_level_setup=[];
            needs_first_level=true;
            signal_error=async function(message) {
                return new LispSyntaxError(message)
            };
            warnings=[];
            blk_counter=0;
            ctx=null;
            output=null;
            let log=await __log__1();
            ;
            let defclog=await __defclog__2();
            ;
            quiet_mode=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    {
                        log=console.log;
                        return true
                    }
                } else {
                    return false
                }
            })();
            show_hints=null;
            error_log=await (async function(){
                 return await defclog({
                    prefix:"Compile Error",background:"#CA3040",color:"white"
                }) 
            })();
            dynamic_references_ques_=false;
            assembly=[];
            async_function_type_placeholder=async function() {
                return true
            };
            function_type_placeholder=function() {
                return true
            };
            type_marker=async function(type) {
                return await async function(){
                    let __target_obj__10=new Object();
                    __target_obj__10["ctype"]=type;
                    __target_obj__10["args"]=[];
                    return __target_obj__10;
                    
                }()
            };
            return_marker=async function() {
                return {
                    mark:"rval"
                }
            };
            entry_signature=null;
            temp_fn_asn_template=await (async function(){
                 return [{
                    type:"special",val:await (async function(){
                         return "=:defvar" 
                    })(),ref:true,name:"defvar"
                },{
                    type:"literal",val:"\"\"",ref:false,name:""
                },{
                    type:"arr",val:await (async function(){
                         return [{
                            type:"special",val:await (async function(){
                                 return "=:fn" 
                            })(),ref:true,name:"fn"
                        },{
                            type:"arr",val:[],ref:false,name:null
                        },{
                            type:"arr",val:[],ref:false,name:null
                        }] 
                    })(),ref:false,name:null
                }] 
            })();
            anon_fn_template=await temp_fn_asn_template["slice"].call(temp_fn_asn_template,2);
            build_fn_with_assignment=async function(tmp_var_name,body,args,ctx) {
                let tmp_template;
                tmp_template=await (async function(){
                     return await clone(temp_fn_asn_template) 
                })();
                if (check_true (await in_sync_ques_(ctx))){
                    {
                        await async function(){
                            let __target_obj__11=(tmp_template && tmp_template["2"] && tmp_template["2"]["val"] && tmp_template["2"]["val"]["0"]);
                            __target_obj__11["val"]=await (async function(){
                                 return "=:function" 
                            })();
                            return __target_obj__11;
                            
                        }();
                        await async function(){
                            let __target_obj__12=(tmp_template && tmp_template["2"] && tmp_template["2"]["val"] && tmp_template["2"]["val"]["0"]);
                            __target_obj__12["name"]="function";
                            return __target_obj__12;
                            
                        }()
                    }
                };
                await async function(){
                    let __target_obj__13=(tmp_template && tmp_template["1"]);
                    __target_obj__13["name"]=tmp_var_name;
                    __target_obj__13["val"]=tmp_var_name;
                    return __target_obj__13;
                    
                }();
                if (check_true ((args instanceof Array))){
                    {
                        await async function(){
                            let __target_obj__14=(tmp_template && tmp_template["2"] && tmp_template["2"]["val"] && tmp_template["2"]["val"]["1"]);
                            __target_obj__14["val"]=args;
                            return __target_obj__14;
                            
                        }()
                    }
                };
                await async function(){
                    let __target_obj__15=(tmp_template && tmp_template["2"] && tmp_template["2"]["val"] && tmp_template["2"]["val"]["2"]);
                    __target_obj__15["val"]=body;
                    return __target_obj__15;
                    
                }();
                return tmp_template
            };
            build_anon_fn=async function(body,args) {
                let tmp_template;
                tmp_template=await (async function(){
                     return await clone(anon_fn_template) 
                })();
                if (check_true (await verbosity(ctx))){
                    {
                        await console.log("build_anon_function: -> body: ",body);
                        await console.log("build_anon_function: -> args: ",args)
                    }
                };
                if (check_true ((args instanceof Array))){
                    {
                        await async function(){
                            let __target_obj__16=(tmp_template && tmp_template["0"] && tmp_template["0"]["val"] && tmp_template["0"]["val"]["1"]);
                            __target_obj__16["val"]=args;
                            return __target_obj__16;
                            
                        }()
                    }
                };
                await async function(){
                    let __target_obj__17=(tmp_template && tmp_template["0"] && tmp_template["0"]["val"] && tmp_template["0"]["val"]["2"]);
                    __target_obj__17["val"]=body;
                    return __target_obj__17;
                    
                }();
                return tmp_template
            };
            completion_types=["return","throw","yield"];
            referenced_global_symbols=new Set();
            referenced_externals=new Set();
            let new_ctx=await __new_ctx__3();
            ;
            set_ctx_log=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    return log
                } else {
                    return await defclog({
                        prefix:"set_ctx",background:"darkgreen",color:"white"
                    })
                }
            })();
            map_ctype_to_value=async function(ctype,value) {
                return await async function(){
                    if (check_true ((ctype==="Function"))) {
                        return Function
                    } else if (check_true ((ctype==="AsyncFunction"))) {
                        return AsyncFunction
                    } else if (check_true ((ctype==="expression"))) {
                        return Expression
                    } else if (check_true (((ctype instanceof String || typeof ctype==='string')&& await contains_ques_("block",ctype)))) {
                        return UnknownType
                    } else if (check_true ((ctype==="array"))) {
                        return Array
                    } else if (check_true ((ctype==="nil"))) {
                        return NilType
                    } else if (check_true (ctype instanceof Function)) {
                        return ctype
                    } else {
                        return value
                    }
                } ()
            };
            map_value_to_ctype=async function(value) {
                return await async function(){
                    if (check_true ((Function===value))) {
                        return "Function"
                    } else if (check_true ((AsyncFunction===value))) {
                        return "AsyncFunction"
                    } else if (check_true ((NumberType===value))) {
                        return "NumberType"
                    } else if (check_true ((Expression===value))) {
                        return "Expression"
                    } else if (check_true ((Array===value))) {
                        return "array"
                    } else if (check_true ((Boolean===value))) {
                        return "Boolean"
                    } else if (check_true ((NilType===value))) {
                        return "nil"
                    } else if (check_true ((Object===value))) {
                        return "Object"
                    } else {
                        return value
                    }
                } ()
            };
            set_ctx=async function(ctx,name,value) {
                let sanitized_name=await sanitize_js_ref_name(name);
                ;
                if (check_true (((value instanceof Array)&& (value && value["0"] && value["0"]["ctype"])))){
                    return await async function(){
                        let __target_obj__26=(ctx && ctx["scope"]);
                        __target_obj__26[sanitized_name]=await (async function(){
                             return await async function(){
                                if (check_true (((value && value["0"] && value["0"]["ctype"])==="Function"))) {
                                    return Function
                                } else if (check_true (((value && value["0"] && value["0"]["ctype"])==="AsyncFunction"))) {
                                    return AsyncFunction
                                } else if (check_true (((value && value["0"] && value["0"]["ctype"])==="expression"))) {
                                    return Expression
                                } else {
                                    return value
                                }
                            } () 
                        })();
                        return __target_obj__26;
                        
                    }()
                } else {
                    return await async function(){
                        let __target_obj__27=(ctx && ctx["scope"]);
                        __target_obj__27[sanitized_name]=value;
                        return __target_obj__27;
                        
                    }()
                }
            };
            get_ctx=async function(ctx,name) {
                let ref_name;
                ref_name=null;
                return await async function(){
                    if (check_true (await (async function(){
                         return await is_nil_ques_(name) 
                    })())) {
                        throw new SyntaxError(("get_ctx: nil identifier passed: "+ await sub_type(name)));
                        
                    } else if (check_true (await is_number_ques_(name))) {
                        return name
                    } else if (check_true (name instanceof Function)) {
                        throw new SyntaxError(("get_ctx: invalid identifier passed: "+ await sub_type(name)));
                        
                    } else {
                        {
                            ref_name=await first(await (await Environment.get_global("get_object_path"))(name));
                            return await async function(){
                                if (check_true (await not((undefined===await (async function(){
                                    let __targ__28=(ctx && ctx["scope"]);
                                    if (__targ__28){
                                         return(__targ__28)[ref_name]
                                    } 
                                })())))) {
                                    return await (async function(){
                                        let __targ__29=(ctx && ctx["scope"]);
                                        if (__targ__29){
                                             return(__targ__29)[ref_name]
                                        } 
                                    })()
                                } else if (check_true ((ctx && ctx["parent"]))) {
                                    return await get_ctx((ctx && ctx["parent"]),ref_name)
                                }
                            } ()
                        }
                    }
                } ()
            };
            get_ctx_val=async function(ctx,name) {
                let ref_name;
                let declared_type_value;
                ref_name=null;
                declared_type_value=null;
                if (check_true ((null==ctx))){
                    {
                        await console.error("get_ctx_val: undefined/nil ctx passed.")
                    }
                };
                return await async function(){
                    if (check_true (await (async function(){
                         return await is_nil_ques_(name) 
                    })())) {
                        throw new TypeError(("get_ctx_val: nil identifier passed: "+ await sub_type(name)));
                        
                    } else if (check_true (await is_number_ques_(name))) {
                        return name
                    } else if (check_true (name instanceof Function)) {
                        throw new Error(("get_ctx_val: invalid identifier passed: "+ await sub_type(name)));
                        
                    } else {
                        {
                            if (check_true (await starts_with_ques_(await (async function(){
                                 return "=:" 
                            })(),name))){
                                ref_name=await name["substr"].call(name,2)
                            } else {
                                ref_name=name
                            };
                            ref_name=await sanitize_js_ref_name(name);
                            declared_type_value=await get_declarations(ctx,ref_name);
                            return await async function(){
                                if (check_true ((declared_type_value && declared_type_value["declared_global"]))) {
                                    return undefined
                                } else if (check_true ((declared_type_value && declared_type_value["type"]))) {
                                    return (declared_type_value && declared_type_value["type"])
                                } else {
                                    {
                                        ref_name=await first(await (await Environment.get_global("get_object_path"))(ref_name));
                                        return await async function(){
                                            if (check_true (op_lookup[ref_name])) {
                                                return AsyncFunction
                                            } else if (check_true (await not((undefined===await (async function(){
                                                let __targ__30=(ctx && ctx["scope"]);
                                                if (__targ__30){
                                                     return(__targ__30)[ref_name]
                                                } 
                                            })())))) {
                                                return await (async function(){
                                                    let __targ__31=(ctx && ctx["scope"]);
                                                    if (__targ__31){
                                                         return(__targ__31)[ref_name]
                                                    } 
                                                })()
                                            } else if (check_true ((ctx && ctx["parent"]))) {
                                                return await get_ctx((ctx && ctx["parent"]),ref_name)
                                            }
                                        } ()
                                    }
                                }
                            } ()
                        }
                    }
                } ()
            };
            get_declarations=async function(ctx,name,_tagged) {
                let ref_name;
                let oname;
                let root_name;
                ref_name=null;
                oname=name;
                root_name=null;
                name=await (async function(){
                    if (check_true (_tagged)){
                        return name
                    } else {
                        return await sanitize_js_ref_name(name)
                    }
                })();
                return await async function(){
                    if (check_true (await not((ctx instanceof Object)))) {
                        throw new TypeError(("get_declarations: invalid ctx passed"));
                        
                    } else if (check_true (await (async function(){
                         return await is_nil_ques_(name) 
                    })())) {
                        throw new TypeError(("get_declarations: nil identifier passed: "+ await sub_type(oname)));
                        
                    } else if (check_true (await is_number_ques_(name))) {
                        return name
                    } else if (check_true (name instanceof Function)) {
                        throw new Error(("get_declarations: invalid identifier passed: "+ await sub_type(oname)));
                        
                    } else {
                        if (check_true ((name instanceof String || typeof name==='string'))){
                            {
                                if (check_true (await starts_with_ques_(await (async function(){
                                     return "=:" 
                                })(),name))){
                                    ref_name=await name["substr"].call(name,2)
                                } else {
                                    ref_name=name
                                };
                                return await async function(){
                                    if (check_true (op_lookup[ref_name])) {
                                        return null
                                    } else if (check_true (await not((undefined===await (async function(){
                                        let __targ__32=(ctx && ctx["declared_types"]);
                                        if (__targ__32){
                                             return(__targ__32)[ref_name]
                                        } 
                                    })())))) {
                                        return await (async function(){
                                            let __targ__33=(ctx && ctx["declared_types"]);
                                            if (__targ__33){
                                                 return(__targ__33)[ref_name]
                                            } 
                                        })()
                                    } else if (check_true ((ctx && ctx["parent"]))) {
                                        return await get_declarations((ctx && ctx["parent"]),ref_name,true)
                                    }
                                } ()
                            }
                        }
                    }
                } ()
            };
            set_declaration=async function(ctx,name,declaration_type,value) {
                let sname;
                let dec_struct;
                sname=await sanitize_js_ref_name(name);
                dec_struct=await get_declarations(ctx,sname);
                if (check_true (await (await Environment.get_global("blank?"))(dec_struct))){
                    {
                        dec_struct={
                            type:undefined,inlined:false
                        }
                    }
                };
                return await async function(){
                    if (check_true (((declaration_type==="location")&& (value==="global")))) {
                        {
                            has_lisp_globals=true;
                            if (check_true ((undefined===dec_struct["type"]))){
                                throw new SyntaxError("global declaration must be after declaration of type for symbol");
                                
                            };
                            await async function(){
                                dec_struct["declared_global"]=true;
                                return dec_struct;
                                
                            }();
                            return await async function(){
                                let __target_obj__35=(root_ctx && root_ctx["defined_lisp_globals"]);
                                __target_obj__35[name]=dec_struct["type"];
                                return __target_obj__35;
                                
                            }()
                        }
                    } else {
                        {
                            await async function(){
                                dec_struct[declaration_type]=value;
                                return dec_struct;
                                
                            }();
                            await async function(){
                                let __target_obj__37=(ctx && ctx["declared_types"]);
                                __target_obj__37[sname]=dec_struct;
                                return __target_obj__37;
                                
                            }();
                            return await (async function(){
                                let __targ__38=(ctx && ctx["declared_types"]);
                                if (__targ__38){
                                     return(__targ__38)[sname]
                                } 
                            })()
                        }
                    }
                } ()
            };
            is_ambiguous_ques_=async function(ctx,name) {
                let ref_name;
                ref_name=null;
                return await async function(){
                    if (check_true (await (async function(){
                         return await is_nil_ques_(ctx) 
                    })())) {
                        throw new TypeError(("is_ambiguous?: nil ctx passed"));
                        
                    } else if (check_true (await (async function(){
                         return await is_nil_ques_(name) 
                    })())) {
                        throw new TypeError(("is_ambiguous?: nil reference name passed"));
                        
                    } else if (check_true (await not((name instanceof String || typeof name==='string')))) {
                        throw new TypeError(("is_ambiguous?: reference name given is a "+ await sub_type(name)+ ", requires a string"));
                        
                    } else {
                        {
                            if (check_true (await starts_with_ques_(await (async function(){
                                 return "=:" 
                            })(),name))){
                                ref_name=await name["substr"].call(name,2)
                            } else {
                                ref_name=name
                            };
                            ref_name=await first(await (await Environment.get_global("get_object_path"))(ref_name));
                            return await async function(){
                                if (check_true (await (async function(){
                                    let __targ__39=(ctx && ctx["ambiguous"]);
                                    if (__targ__39){
                                         return(__targ__39)[ref_name]
                                    } 
                                })())) {
                                    return true
                                } else if (check_true ((ctx && ctx["parent"]))) {
                                    return await is_ambiguous_ques_((ctx && ctx["parent"]),ref_name)
                                }
                            } ()
                        }
                    }
                } ()
            };
            set_ambiguous=async function(ctx,name) {
                return await async function(){
                    let __target_obj__40=(ctx && ctx["ambiguous"]);
                    __target_obj__40[name]=true;
                    return __target_obj__40;
                    
                }()
            };
            unset_ambiguous=async function(ctx,name) {
                return await (await Environment.get_global("delete_prop"))((ctx && ctx["ambiguous"]),name)
            };
            invalid_js_ref_chars="+?-%&^#!*[]~{}/|";
            invalid_js_ref_chars_regex=new RegExp("[/\%\+\[\>\?\<\\}\{&\#\^\=\~\*\!\)\(\-]+","g");
            check_invalid_js_ref=async function(symname) {
                return await async function(){
                    if (check_true (await not((symname instanceof String || typeof symname==='string')))) {
                        return false
                    } else if (check_true (((symname instanceof String || typeof symname==='string')&& (await length(symname)>2)&& await starts_with_ques_(await (async function(){
                         return "=:" 
                    })(),symname)))) {
                        return (await length(await (await Environment.get_global("scan_str"))(invalid_js_ref_chars_regex,await symname["substr"].call(symname,2)))>0)
                    } else {
                        return (await length(await (await Environment.get_global("scan_str"))(invalid_js_ref_chars_regex,symname))>0)
                    }
                } ()
            };
            let sanitize_js_ref_name=await __sanitize_js_ref_name__4();
            ;
            find_in_context=async function(ctx,name) {
                let symname;
                let ref;
                let __is_literal_ques___41= async function(){
                    return (await is_number_ques_(name)|| (await not(ref)&& (name instanceof String || typeof name==='string'))|| ("nil"===symname)|| ("null"===symname)|| (ref&& ("undefined"===symname))|| (ref&& ("else"===symname))|| (ref&& ("catch"===symname))|| (true===name)|| (false===name))
                };
                let special;
                let local;
                let global;
                let val;
                {
                    symname=await (async function(){
                         return await async function(){
                            if (check_true (((name instanceof String || typeof name==='string')&& (await length(name)>2)&& await starts_with_ques_(await (async function(){
                                 return "=:" 
                            })(),name)))) {
                                return await name["substr"].call(name,2)
                            } else if (check_true ((name instanceof String || typeof name==='string'))) {
                                return name
                            } else {
                                {
                                    if (check_true ((name===null))){
                                        {
                                            name=await (async function(){
                                                 return "=:nil" 
                                            })()
                                        }
                                    };
                                    return "null"
                                }
                            }
                        } () 
                    })();
                    ref=(symname&& ((name instanceof String || typeof name==='string')&& (await length(name)>2)&& await starts_with_ques_(await (async function(){
                         return "=:" 
                    })(),name)));
                    let is_literal_ques_=await __is_literal_ques___41();
                    ;
                    special=(ref&& symname&& await contains_ques_(symname,await conj(["unquotem","quotem"],await (await Environment.get_global("keys"))(op_lookup))));
                    local=(await not(special)&& await not(is_literal_ques_)&& symname&& ref&& await get_ctx_val(ctx,symname));
                    global=(await not(special)&& await not(is_literal_ques_)&& ref&& symname&& await get_lisp_ctx(ctx,symname));
                    val=await (async function(){
                         return await async function(){
                            if (check_true (is_literal_ques_)) {
                                return name
                            } else if (check_true ((name instanceof Array))) {
                                return name
                            } else if (check_true ((name instanceof Object))) {
                                return name
                            } else if (check_true (special)) {
                                return name
                            } else if (check_true (local)) {
                                return local
                            } else if (check_true ((await not((global===undefined))&& await not((global===NOT_FOUND))))) {
                                return global
                            } else if (check_true ((symname===name))) {
                                return name
                            }
                        } () 
                    })();
                    return {
                        type:await (async function(){
                             return await async function(){
                                if (check_true ((name instanceof Array))) {
                                    return "arr"
                                } else if (check_true (name instanceof Element)) {
                                    return "dom"
                                } else if (check_true ((name instanceof Object))) {
                                    return await sub_type(name)
                                } else if (check_true (special)) {
                                    return "special"
                                } else if (check_true (is_literal_ques_)) {
                                    return "literal"
                                } else if (check_true (local)) {
                                    return await sub_type(local)
                                } else if (check_true (await not((undefined==global)))) {
                                    return await sub_type(global)
                                } else if (check_true ((ref&& symname))) {
                                    return "unbound"
                                } else if (check_true ((name===undefined))) {
                                    return "literal"
                                } else {
                                    {
                                        await error_log("find_in_context: unknown type: ",name);
                                        debugger;
                                        ;
                                        return "??"
                                    }
                                }
                            } () 
                        })(),name:await (async function(){
                             return await async function(){
                                if (check_true ((symname&& ref))) {
                                    return await sanitize_js_ref_name(symname)
                                } else if (check_true ((false&& is_literal_ques_&& (val instanceof String || typeof val==='string')))) {
                                    return await sanitize_js_ref_name(name)
                                } else if (check_true (is_literal_ques_)) {
                                    if (check_true (ref)){
                                        return await sanitize_js_ref_name(name)
                                    } else {
                                        return name
                                    }
                                } else {
                                    return null
                                }
                            } () 
                        })(),val:await (async function(){
                            if (check_true ((val===undefined))){
                                return undefined
                            } else {
                                return val
                            }
                        })(),ref:await (async function(){
                            if (check_true (ref)){
                                return true
                            } else {
                                return false
                            }
                        })(),local:(local|| null),global:((await not((undefined===global))&& await not((NOT_FOUND===global)))|| null)
                    }
                }
            };
            source_chain=async function(cpath,tree,sources) {
                if (check_true (((cpath instanceof Array)&& tree))){
                    {
                        let source;
                        sources=(sources|| []);
                        source=null;
                        cpath=await (await Environment.get_global("chop"))(cpath);
                        source=await (await Environment.get_global("as_lisp"))(await (await Environment.get_global("resolve_path"))(cpath,tree));
                        if (check_true (((source && source.length)>80))){
                            source=await add(await source["substr"].call(source,0,80),"...")
                        };
                        if (check_true (await not(await (await Environment.get_global("blank?"))(source)))){
                            {
                                (sources).push(source)
                            }
                        };
                        if (check_true ((((cpath && cpath.length)>0)&& ((sources && sources.length)<4)))){
                            await source_chain(cpath,tree,sources)
                        };
                        return sources
                    }
                }
            };
            source_from_tokens=async function(tokens,tree,collect_parents_ques_) {
                return await async function(){
                    if (check_true (((tokens && tokens["path"])&& collect_parents_ques_))) {
                        return await source_chain((tokens && tokens["path"]),tree)
                    } else if (check_true ((tree instanceof String || typeof tree==='string'))) {
                        return await (await Environment.get_global("as_lisp"))(tree)
                    } else if (check_true ((tokens && tokens["path"]))) {
                        return await (await Environment.get_global("as_lisp"))(await (await Environment.get_global("resolve_path"))((tokens && tokens["path"]),tree))
                    } else if (check_true (((tokens instanceof Array)&& (tokens && tokens["0"] && tokens["0"]["path"])&& collect_parents_ques_))) {
                        return await source_chain((tokens && tokens["0"] && tokens["0"]["path"]),tree)
                    } else if (check_true (((tokens instanceof Array)&& (tokens && tokens["0"] && tokens["0"]["path"])))) {
                        return await (await Environment.get_global("as_lisp"))(await (await Environment.get_global("resolve_path"))(await (await Environment.get_global("chop"))((tokens && tokens["0"] && tokens["0"]["path"])),tree))
                    } else if (check_true (((undefined===tokens)&& await not((undefined===tree))))) {
                        return await (await Environment.get_global("as_lisp"))(tree)
                    } else {
                        {
                            if (check_true (await verbosity(ctx))){
                                {
                                    await console.warn("source_from_tokens: unable to determine source path from: ",await (async function(){
                                         return await clone(tokens) 
                                    })())
                                }
                            };
                            return ""
                        }
                    }
                } ()
            };
            source_comment=async function(tokens) {
                return {
                    comment:await source_from_tokens(tokens,expanded_tree)
                }
            };
            NOT_FOUND="__!NOT_FOUND!__";
            THIS_REFERENCE=async function() {
                return "this"
            };
            NOT_FOUND_THING=async function() {
                return true
            };
            get_lisp_ctx_log=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    return log
                } else {
                    return await defclog({
                        prefix:"get_lisp_ctx",color:"darkgreen",background:"#A0A0A0"
                    })
                }
            })();
            get_lisp_ctx=async function(ctx,name) {
                if (check_true (await not((name instanceof String || typeof name==='string')))){
                    throw new Error("Compiler Error: get_lisp_ctx passed a non string identifier");
                    
                } else {
                    {
                        let comps;
                        let cannot_be_js_global;
                        let ref_name;
                        let ref_type;
                        comps=await (await Environment.get_global("get_object_path"))(name);
                        cannot_be_js_global=await check_invalid_js_ref((comps && comps["0"]));
                        ref_name=(comps).shift();
                        ref_type=await (async function(){
                            if (check_true ((ref_name==="this"))){
                                return THIS_REFERENCE
                            } else {
                                {
                                    let global_ref=await (async function(){
                                        let __targ__42=(root_ctx && root_ctx["defined_lisp_globals"]);
                                        if (__targ__42){
                                             return(__targ__42)[ref_name]
                                        } 
                                    })();
                                    ;
                                    if (check_true (((undefined==global_ref)|| (global_ref==="statement")))){
                                        return await Environment["get_global"].call(Environment,ref_name,NOT_FOUND_THING,cannot_be_js_global)
                                    } else {
                                        return global_ref
                                    }
                                }
                            }
                        })();
                        await async function(){
                            if (check_true ((await not((NOT_FOUND_THING===ref_type))&& await not(await contains_ques_(ref_name,standard_types))))) {
                                {
                                    await referenced_global_symbols["add"].call(referenced_global_symbols,ref_name);
                                    {
                                        let it;
                                        it=await get_ctx(ctx,"__GLOBALS__");
                                        if (check_true (it)){
                                            return await it["add"].call(it,ref_name)
                                        } else {
                                            return 
                                        }
                                    }
                                }
                            } else if (check_true ((await not((NOT_FOUND_THING===ref_type))&& await externals["has"].call(externals,ref_name)))) {
                                {
                                    await referenced_externals["add"].call(referenced_externals,ref_name);
                                    {
                                        let it;
                                        it=await get_ctx(ctx,"__EXTERNALS__");
                                        if (check_true (it)){
                                            {
                                                return await it["add"].call(it,ref_name)
                                            }
                                        } else {
                                            return 
                                        }
                                    }
                                }
                            }
                        } ();
                        if (check_true (await verbosity(root_ctx))){
                            {
                                await (async function(){
                                    let __array_op_rval__43=get_lisp_ctx_log;
                                     if (__array_op_rval__43 instanceof Function){
                                        return await __array_op_rval__43("name: ",name,"type: ",ref_type,"components: ",comps) 
                                    } else {
                                        return [__array_op_rval__43,"name: ",name,"type: ",ref_type,"components: ",comps]
                                    }
                                })()
                            }
                        };
                        return await async function(){
                            if (check_true ((NOT_FOUND_THING===ref_type))) {
                                return undefined
                            } else if (check_true ((ref_type===THIS_REFERENCE))) {
                                return ref_type
                            } else if (check_true (((comps && comps.length)===0))) {
                                return ref_type
                            } else if (check_true ((((comps && comps.length)===1)&& (ref_type instanceof Object)&& await contains_ques_((comps && comps["0"]),await (async function(){
                                 return await object_methods(ref_type) 
                            })())))) {
                                return ref_type[(comps && comps["0"])]
                            } else if (check_true ((ref_type instanceof Function&& await is_ambiguous_ques_(root_ctx,ref_name)))) {
                                return ref_type
                            } else if (check_true ((ref_type instanceof Array))) {
                                return ref_type
                            } else if (check_true ((ref_type==="array"))) {
                                return []
                            } else if (check_true ((((comps && comps.length)===1)&& (ref_type instanceof Object)))) {
                                {
                                    let v=ref_type[(comps && comps["0"])];
                                    ;
                                    if (check_true (v)){
                                        return v
                                    } else {
                                        return ref_type
                                    }
                                }
                            } else if (check_true ((ref_type instanceof Object))) {
                                return (await (await Environment.get_global("resolve_path"))(comps,ref_type)|| ref_type)
                            } else if (check_true (((typeof ref_type==="object")&& await contains_ques_((comps && comps["0"]),await Object["keys"].call(Object,ref_type))))) {
                                {
                                    await (async function(){
                                         let __test_condition__44=async function() {
                                            return ((ref_type==undefined)|| ((comps && comps.length)>0))
                                        };
                                        let __body_ref__45=async function() {
                                            return ref_type=ref_type[(comps).shift()]
                                        };
                                        let __BREAK__FLAG__=false;
                                        while(await __test_condition__44()) {
                                             await __body_ref__45();
                                             if(__BREAK__FLAG__) {
                                                 break;
                                                
                                            }
                                        } ;
                                        
                                    })();
                                    return ref_type
                                }
                            } else if (check_true ((ref_type==="objliteral"))) {
                                return ref_type
                            } else {
                                {
                                    debugger;
                                    ;
                                    await (async function(){
                                        let __array_op_rval__46=get_lisp_ctx_log;
                                         if (__array_op_rval__46 instanceof Function){
                                            return await __array_op_rval__46("symbol not found: ",name,ref_name,ref_type,cannot_be_js_global) 
                                        } else {
                                            return [__array_op_rval__46,"symbol not found: ",name,ref_name,ref_type,cannot_be_js_global]
                                        }
                                    })();
                                    return undefined
                                }
                            }
                        } ()
                    }
                }
            };
            get_val=async function(token,ctx) {
                return await async function(){
                    if (check_true ((token && token["ref"]))) {
                        {
                            let comps=((token && token.name)).split(".");
                            ;
                            let ref_name=await (async function(){
                                if (check_true (((await safety_level(ctx)>1)&& ((comps && comps.length)>1)))){
                                    return await (await Environment.get_global("safe_access"))(token,ctx,sanitize_js_ref_name)
                                } else {
                                    return await sanitize_js_ref_name(await (async function(){
                                         return await (await Environment.get_global("expand_dot_accessor"))((token && token.name),ctx) 
                                    })())
                                }
                            })();
                            ;
                            if (check_true (await verbosity(ctx))){
                                {
                                    console.log("get_val: reference: ",await (async function(){
                                         return await (await Environment.get_global("safe_access"))(token,ctx,sanitize_js_ref_name) 
                                    })(),ref_name,":",await get_ctx(ctx,ref_name))
                                }
                            };
                            return await async function(){
                                if (check_true ((await get_ctx(ctx,"__IN_QUOTEM__")&& await not(await get_ctx(ctx,"__IN_LAMBDA__"))))) {
                                    return await get_ctx(ctx,ref_name)
                                } else if (check_true ((false&& await get_ctx(ctx,"__IN_QUOTEM__")&& await get_ctx(ctx,"__IN_LAMBDA__")))) {
                                    return ("await ctx_access(\""+ ref_name+ "\")")
                                } else {
                                    return ref_name
                                }
                            } ()
                        }
                    } else {
                        return (token && token["val"])
                    }
                } ()
            };
            has_lisp_globals=false;
            root_ctx=await (async function(){
                 return await new_ctx(((opts && opts["ctx"]))) 
            })();
            tokenize_object=async function(obj,ctx,_path) {
                let ser=null;
                ;
                {
                    try {
                        ser=await JSON.stringify(obj)
                    } catch (__exception__47) {
                        if (__exception__47 instanceof TypeError) {
                            let e=__exception__47;
                            {
                                {
                                    await console.warn("compiler: cannot tokenize: ",obj,e);
                                    ser="{}"
                                }
                            }
                        } else throw __exception__47;
                        
                    };
                    _path=(_path|| []);
                    if (check_true ((ser==="{}"))){
                        {
                            return {
                                type:"object",ref:false,val:"{}",name:"{}",__token__:true,path:_path
                            }
                        }
                    } else {
                        return await (async function() {
                            let __for_body__50=async function(pset) {
                                return {
                                    type:"keyval",val:await tokenize(pset,ctx,"path:",await add(_path,(pset && pset["0"]))),ref:false,name:(""+ await (await Environment.get_global("as_lisp"))((pset && pset["0"]))),__token__:true
                                }
                            };
                            let __array__51=[],__elements__49=await (await Environment.get_global("pairs"))(obj);
                            let __BREAK__FLAG__=false;
                            for(let __iter__48 in __elements__49) {
                                __array__51.push(await __for_body__50(__elements__49[__iter__48]));
                                if(__BREAK__FLAG__) {
                                     __array__51.pop();
                                    break;
                                    
                                }
                            }return __array__51;
                             
                        })()
                    }
                }
            };
            tokenize_quote=async function(args,_path) {
                return await async function(){
                    if (check_true (((args && args["0"])==="=:quote"))) {
                        return {
                            type:"arr",__token__:true,source:await (await Environment.get_global("as_lisp"))(args),val:await conj(await (async function(){
                                 return [{
                                    type:"special",val:await (async function(){
                                         return "=:quote" 
                                    })(),ref:true,name:"quote",__token__:true
                                }] 
                            })(),await args["slice"].call(args,1)),ref:((args instanceof String || typeof args==='string')&& (await length(args)>2)&& await starts_with_ques_(await (async function(){
                                 return "=:" 
                            })(),args)),name:null,path:_path
                        }
                    } else if (check_true (((args && args["0"])==="=:quotem"))) {
                        return {
                            type:"arr",__token__:true,source:await (await Environment.get_global("as_lisp"))(args),val:await conj(await (async function(){
                                 return [{
                                    type:"special",path:await conj(_path,[0]),val:await (async function(){
                                         return "=:quotem" 
                                    })(),ref:true,name:"quotem",__token__:true
                                }] 
                            })(),await args["slice"].call(args,1)),ref:((args instanceof String || typeof args==='string')&& (await length(args)>2)&& await starts_with_ques_(await (async function(){
                                 return "=:" 
                            })(),args)),name:null,path:_path
                        }
                    } else {
                        return {
                            type:"arr",__token__:true,source:await (await Environment.get_global("as_lisp"))(args),val:await conj(await (async function(){
                                 return [{
                                    type:"special",val:await (async function(){
                                         return "=:quotel" 
                                    })(),ref:true,name:"quotel",__token__:true
                                }] 
                            })(),await args["slice"].call(args,1)),ref:((args instanceof String || typeof args==='string')&& (await length(args)>2)&& await starts_with_ques_(await (async function(){
                                 return "=:" 
                            })(),args)),name:null,path:_path
                        }
                    }
                } ()
            };
            tokenize=async function(args,ctx,_path,_suppress_comptime_eval) {
                let argtype;
                let rval;
                let qval;
                let idx;
                let tobject;
                let argdetails;
                let argvalue;
                let is_ref;
                argtype=null;
                rval=null;
                ctx=ctx;
                _path=(_path|| []);
                qval=null;
                idx=-1;
                tobject=null;
                argdetails=null;
                argvalue=null;
                is_ref=null;
                ;
                if (check_true ((null==ctx))){
                    {
                        await console.error("tokenize: nil ctx passed: ",await (async function(){
                             return await clone(args) 
                        })());
                        throw new ReferenceError("nil/undefined ctx passed to tokenize");
                        
                    }
                };
                if (check_true (((args instanceof Array)&& await not(_suppress_comptime_eval)))){
                    {
                        args=await compile_time_eval(ctx,args,_path);
                        await async function(){
                            if (check_true (((_path && _path.length)>1))) {
                                {
                                    tobject=await (await Environment.get_global("resolve_path"))(await (await Environment.get_global("chop"))(_path),expanded_tree);
                                    if (check_true (tobject)){
                                        {
                                            return await async function(){
                                                tobject[await last(_path)]=args;
                                                return tobject;
                                                
                                            }()
                                        }
                                    }
                                }
                            } else if (check_true (((_path && _path.length)===1))) {
                                {
                                    await async function(){
                                        expanded_tree[await first(_path)]=args;
                                        return expanded_tree;
                                        
                                    }()
                                }
                            } else {
                                expanded_tree=args
                            }
                        } ()
                    }
                };
                return await async function(){
                    if (check_true (((args instanceof String || typeof args==='string')|| await is_number_ques_(args)|| ((args===true)|| (args===false))))) {
                        return await first(await tokenize([args],ctx,_path,true))
                    } else if (check_true (((args instanceof Array)&& (((args && args["0"])==="=:quotem")|| ((args && args["0"])==="=:quote")|| ((args && args["0"])==="=:quotel"))))) {
                        {
                            rval=await tokenize_quote(args,_path);
                            return rval
                        }
                    } else if (check_true (((args instanceof Array)&& await not(await get_ctx_val(ctx,"__IN_LAMBDA__"))&& ((args && args["0"])==="=:iprogn")))) {
                        {
                            rval=await compile_toplevel(args,ctx);
                            return await tokenize(rval,ctx,_path)
                        }
                    } else if (check_true ((await not((args instanceof Array))&& (args instanceof Object)))) {
                        return await first(await tokenize([args],ctx,await add(_path,0)))
                    } else {
                        {
                            if (check_true ((((args && args["0"])==="=:fn")|| ((args && args["0"])==="=:function")|| ((args && args["0"])==="=:=>")))){
                                {
                                    ctx=await (async function(){
                                         return await new_ctx(ctx) 
                                    })();
                                    await set_ctx(ctx,"__IN_LAMBDA__",true)
                                }
                            };
                            return await (async function() {
                                let __for_body__56=async function(arg) {
                                    idx+=1;
                                    try {
                                        argdetails=await find_in_context(ctx,arg)
                                    } catch (__exception__58) {
                                        if (__exception__58 instanceof LispSyntaxError) {
                                            let e=__exception__58;
                                            {
                                                {
                                                    is_error={
                                                        error:(e && e["name"]),source_name:source_name,message:(e && e.message),form:await (await Environment.get_global("resolve_path"))(_path,expanded_tree),parent_forms:((await (await Environment.get_global("chop"))(_path)&& await (await Environment.get_global("resolve_path"))(await (await Environment.get_global("chop"))(_path),expanded_tree))|| []),invalid:true
                                                    };
                                                    await async function(){
                                                        e["details"]=is_error;
                                                        e["handled"]=true;
                                                        return e;
                                                        
                                                    }();
                                                    await console.error(is_error);
                                                    debugger;
                                                    ;
                                                    throw e;
                                                    
                                                }
                                            }
                                        } else throw __exception__58;
                                        
                                    };
                                    argvalue=(argdetails && argdetails["val"]);
                                    argtype=(argdetails && argdetails["type"]);
                                    is_ref=(argdetails && argdetails["ref"]);
                                    return await async function(){
                                        if (check_true ((await sub_type(arg)==="array"))) {
                                            return {
                                                type:"arr",__token__:true,val:await tokenize(arg,ctx,await add(_path,idx)),ref:is_ref,name:null,path:await add(_path,idx)
                                            }
                                        } else if (check_true ((argtype==="Function"))) {
                                            return {
                                                type:"fun",__token__:true,val:arg,ref:is_ref,name:(""+ await (await Environment.get_global("as_lisp"))(arg)),global:(argdetails && argdetails["global"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true ((argtype==="AsyncFunction"))) {
                                            return {
                                                type:"asf",__token__:true,val:arg,ref:is_ref,name:(""+ await (await Environment.get_global("as_lisp"))(arg)),global:(argdetails && argdetails["global"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true ((argtype==="array"))) {
                                            return {
                                                type:"array",__token__:true,val:arg,ref:is_ref,name:(""+ await (await Environment.get_global("as_lisp"))(arg)),global:(argdetails && argdetails["global"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true ((argtype==="Number"))) {
                                            return {
                                                type:"num",__token__:true,val:argvalue,ref:is_ref,name:(""+ await (await Environment.get_global("as_lisp"))(arg)),global:(argdetails && argdetails["global"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true (((argtype==="String")&& is_ref))) {
                                            return {
                                                type:"arg",__token__:true,val:argvalue,ref:is_ref,name:await clean_quoted_reference((""+ await (await Environment.get_global("as_lisp"))(arg))),global:(argdetails && argdetails["global"]),local:(argdetails && argdetails["local"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true ((argtype==="String"))) {
                                            return {
                                                type:"literal",__token__:true,val:argvalue,ref:is_ref,name:await clean_quoted_reference((""+ await (await Environment.get_global("as_lisp"))(arg))),global:(argdetails && argdetails["global"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true ((argtype==="dom"))) {
                                            return {
                                                type:"null",__token__:true,val:null,ref:is_ref,name:await clean_quoted_reference((""+ await (await Environment.get_global("as_lisp"))(arg))),global:(argdetails && argdetails["global"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true ((arg instanceof Object))) {
                                            {
                                                return {
                                                    type:"objlit",__token__:true,val:await tokenize_object(arg,ctx,await add(_path,idx)),ref:is_ref,name:null,path:await add(_path,idx)
                                                }
                                            }
                                        } else if (check_true (((argtype==="literal")&& is_ref&& ((""+ await (await Environment.get_global("as_lisp"))(arg))==="nil")))) {
                                            return {
                                                type:"null",__token__:true,val:null,ref:true,name:"null",path:await add(_path,idx)
                                            }
                                        } else if (check_true (((argtype==="unbound")&& is_ref&& (null==argvalue)))) {
                                            return {
                                                type:"arg",__token__:true,val:arg,ref:true,name:await clean_quoted_reference((""+ await (await Environment.get_global("as_lisp"))(arg))),global:(argdetails && argdetails["global"]),path:await add(_path,idx)
                                            }
                                        } else if (check_true (((argtype==="unbound")&& is_ref))) {
                                            return {
                                                type:await sub_type(argvalue),__token__:true,val:argvalue,ref:true,name:await clean_quoted_reference(await sanitize_js_ref_name((""+ await (await Environment.get_global("as_lisp"))(arg)))),path:await add(_path,idx)
                                            }
                                        } else {
                                            return {
                                                type:argtype,__token__:true,val:argvalue,ref:is_ref,name:await clean_quoted_reference((""+ await (await Environment.get_global("as_lisp"))(arg))),global:(argdetails && argdetails["global"]),local:(argdetails && argdetails["local"]),path:await add(_path,idx)
                                            }
                                        }
                                    } ()
                                };
                                let __array__57=[],__elements__55=args;
                                let __BREAK__FLAG__=false;
                                for(let __iter__54 in __elements__55) {
                                    __array__57.push(await __for_body__56(__elements__55[__iter__54]));
                                    if(__BREAK__FLAG__) {
                                         __array__57.pop();
                                        break;
                                        
                                    }
                                }return __array__57;
                                 
                            })()
                        }
                    }
                } ()
            };
            comp_time_log=await (async function(){
                 return await defclog({
                    prefix:"compile_time_eval",background:"#C0C0C0",color:"darkblue"
                }) 
            })();
            compile_time_eval=async function(ctx,lisp_tree,path) {
                if (check_true (((lisp_tree instanceof Array)&& (((lisp_tree && lisp_tree["0"]) instanceof String || typeof (lisp_tree && lisp_tree["0"])==='string')&& (await length((lisp_tree && lisp_tree["0"]))>2)&& await starts_with_ques_(await (async function(){
                     return "=:" 
                })(),(lisp_tree && lisp_tree["0"])))&& await (async function(){
                    let it;
                    it=await Environment["symbol_definition"].call(Environment,await (lisp_tree && lisp_tree["0"])["substr"].call((lisp_tree && lisp_tree["0"]),2));
                    if (check_true (it)){
                        return await (await Environment.get_global("resolve_path"))(["eval_when","compile_time"],it)
                    } else {
                        return 
                    }
                })()))){
                    {
                        let ntree;
                        let precompile_function;
                        ntree=null;
                        precompile_function=await Environment["get_global"].call(Environment,await (lisp_tree && lisp_tree["0"])["substr"].call((lisp_tree && lisp_tree["0"]),2));
                        if (check_true (await verbosity(ctx))){
                            {
                                await comp_time_log(path,"->",await (lisp_tree && lisp_tree["0"])["substr"].call((lisp_tree && lisp_tree["0"]),2),lisp_tree,"to function: ",await lisp_tree["slice"].call(lisp_tree,1))
                            }
                        };
                        try {
                            ntree=await (async function(){
                                let __apply_args__61=await (async function(){
                                     return await lisp_tree["slice"].call(lisp_tree,1) 
                                })();
                                return ( precompile_function).apply(this,__apply_args__61)
                            })()
                        } catch (__exception__60) {
                            if (__exception__60 instanceof Error) {
                                let e=__exception__60;
                                {
                                    {
                                        await async function(){
                                            e["handled"]=true;
                                            return e;
                                            
                                        }();
                                        (errors).push({
                                            error:(e && e.name),message:(e && e.message),source_name:source_name,precompilation:true,form:lisp_tree,parent_forms:[],invalid:true,stack:(e && e.stack)
                                        });
                                        throw e;
                                        
                                    }
                                }
                            }
                        };
                        if (check_true ((null==ntree))){
                            (warnings).push(("compile time function "+ await (lisp_tree && lisp_tree["0"])["substr"].call((lisp_tree && lisp_tree["0"]),2)+ " returned nil"))
                        } else {
                            {
                                ntree=await (async function(){
                                     return await do_deferred_splice(ntree) 
                                })();
                                if (check_true (await not((await JSON.stringify(ntree)===await JSON.stringify(lisp_tree))))){
                                    {
                                        ntree=await compile_time_eval(ctx,ntree,path)
                                    }
                                };
                                if (check_true (await verbosity(ctx))){
                                    {
                                        await comp_time_log(await (lisp_tree && lisp_tree["0"])["substr"].call((lisp_tree && lisp_tree["0"]),2),"<- lisp: ",await (await Environment.get_global("as_lisp"))(ntree))
                                    }
                                }
                            }
                        };
                        return ntree
                    }
                } else {
                    return lisp_tree
                }
            };
            infix_ops=async function(tokens,ctx,opts) {
                let op_translation;
                let math_op_a;
                let math_op;
                let idx;
                let stmts;
                let declaration;
                let symbol_ctx_val;
                let is_overloaded;
                let token;
                let add_operand;
                let acc;
                op_translation={
                    or:"||",and:"&&"
                };
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                math_op_a=await (async function(){
                    let __targ__64=await first(tokens);
                    if (__targ__64){
                         return(__targ__64)["name"]
                    } 
                })();
                math_op=(op_translation[math_op_a]|| math_op_a);
                idx=0;
                stmts=null;
                declaration=await (async function(){
                    if (check_true (((tokens && tokens["1"] && tokens["1"]["name"]) instanceof String || typeof (tokens && tokens["1"] && tokens["1"]["name"])==='string'))){
                        return await get_declarations(ctx,(tokens && tokens["1"] && tokens["1"]["name"]),await not((tokens && tokens["1"] && tokens["1"]["ref"])))
                    } else {
                        return null
                    }
                })();
                symbol_ctx_val=await (async function(){
                    if (check_true (((tokens && tokens["1"] && tokens["1"]["ref"])&& ((tokens && tokens["1"] && tokens["1"]["name"]) instanceof String || typeof (tokens && tokens["1"] && tokens["1"]["name"])==='string')))){
                        return await get_ctx_val(ctx,(tokens && tokens["1"] && tokens["1"]["name"]))
                    }
                })();
                is_overloaded=false;
                token=null;
                add_operand=async function() {
                    if (check_true (((idx>1)&& (idx<((tokens && tokens.length)- 0))))){
                        {
                            (acc).push(math_op);
                            return (acc).push(" ")
                        }
                    }
                };
                acc=await (async function(){
                     return [{
                        ctype:"expression"
                    }] 
                })();
                await set_ctx(ctx,"__COMP_INFIX_OPS__",true);
                if (check_true (((symbol_ctx_val instanceof Array)&& (symbol_ctx_val && symbol_ctx_val["0"] && symbol_ctx_val["0"]["ctype"])))){
                    {
                        symbol_ctx_val=(symbol_ctx_val && symbol_ctx_val["0"] && symbol_ctx_val["0"]["ctype"])
                    }
                };
                if (check_true (((((declaration && declaration["type"])===Array)|| ((declaration && declaration["type"])===Object)|| (symbol_ctx_val==="objliteral")|| (symbol_ctx_val===Expression)|| (symbol_ctx_val===ArgumentType)|| ((tokens && tokens["1"] && tokens["1"]["type"])==="objlit")|| ((tokens && tokens["1"] && tokens["1"]["type"])==="arr"))&& (math_op==="+")))){
                    {
                        is_overloaded=true
                    }
                };
                if (check_true (is_overloaded)){
                    {
                        await async function(){
                            tokens[0]={
                                type:"function",val:await add(await (async function(){
                                     return "=:" 
                                })(),"add"),name:"add",ref:true
                            };
                            return tokens;
                            
                        }();
                        await async function(){
                            ctx["block_step"]=0;
                            return ctx;
                            
                        }();
                        stmts=await compile_wrapper_fn(tokens,ctx);
                        return stmts
                    }
                } else {
                    {
                        (acc).push("(");
                        await (async function(){
                             let __test_condition__67=async function() {
                                return (idx<((tokens && tokens.length)- 1))
                            };
                            let __body_ref__68=async function() {
                                idx+=1;
                                token=tokens[idx];
                                await add_operand();
                                await async function(){
                                    ctx["block_step"]=0;
                                    return ctx;
                                    
                                }();
                                return (acc).push(await compile_wrapper_fn(token,ctx))
                            };
                            let __BREAK__FLAG__=false;
                            while(await __test_condition__67()) {
                                 await __body_ref__68();
                                 if(__BREAK__FLAG__) {
                                     break;
                                    
                                }
                            } ;
                            
                        })();
                        (acc).push(")");
                        return acc
                    }
                }
            };
            compile_set_prop=async function(tokens,ctx) {
                let acc;
                let wrapper;
                let stmt;
                let preamble;
                let token;
                let complicated;
                let target;
                let target_reference;
                let idx;
                acc=[];
                wrapper=[];
                stmt=null;
                preamble=await calling_preamble(ctx);
                token=await second(tokens);
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                complicated=await is_complex_ques_((token && token["val"]));
                target=await (async function(){
                    if (check_true (complicated)){
                        return await compile_wrapper_fn((token && token["val"]),ctx)
                    } else {
                        return await compile(token,ctx)
                    }
                })();
                target_reference=await gen_temp_name("target_obj");
                idx=1;
                ;
                if (check_true (((token && token["name"])==="this"))){
                    {
                        (acc).push("this.");
                        (acc).push((tokens && tokens["2"] && tokens["2"]["name"]));
                        (acc).push("=");
                        (acc).push(await compile_wrapper_fn((tokens && tokens["3"]),ctx));
                        return acc
                    }
                } else {
                    {
                        await set_new_completion_scope(ctx);
                        await (async function() {
                            let __for_body__72=async function(t) {
                                return (wrapper).push(t)
                            };
                            let __array__73=[],__elements__71=[(preamble && preamble["0"])," ",(preamble && preamble["1"])," ",(preamble && preamble["3"]),"function","()","{"];
                            let __BREAK__FLAG__=false;
                            for(let __iter__70 in __elements__71) {
                                __array__73.push(await __for_body__72(__elements__71[__iter__70]));
                                if(__BREAK__FLAG__) {
                                     __array__73.pop();
                                    break;
                                    
                                }
                            }return __array__73;
                             
                        })();
                        if (check_true (await not((target instanceof String || typeof target==='string')))){
                            await (async function() {
                                let __for_body__76=async function(t) {
                                    return (wrapper).push(t)
                                };
                                let __array__77=[],__elements__75=["let"," ",target_reference,"=",target,";"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__74 in __elements__75) {
                                    __array__77.push(await __for_body__76(__elements__75[__iter__74]));
                                    if(__BREAK__FLAG__) {
                                         __array__77.pop();
                                        break;
                                        
                                    }
                                }return __array__77;
                                 
                            })()
                        } else {
                            {
                                target_reference=target
                            }
                        };
                        await (async function(){
                             let __test_condition__78=async function() {
                                return (idx<((tokens && tokens.length)- 1))
                            };
                            let __body_ref__79=async function() {
                                idx+=1;
                                (acc).push(target_reference);
                                token=tokens[idx];
                                (acc).push("[");
                                stmt=await compile_as_call(token,ctx);
                                (acc).push(stmt);
                                (acc).push("]");
                                idx+=1;
                                (acc).push("=");
                                token=tokens[idx];
                                if (check_true ((null==token))){
                                    throw new SyntaxError("set_prop: odd number of arguments");
                                    
                                };
                                stmt=await compile_wrapper_fn(token,ctx);
                                (acc).push(stmt);
                                return (acc).push(";")
                            };
                            let __BREAK__FLAG__=false;
                            while(await __test_condition__78()) {
                                 await __body_ref__79();
                                 if(__BREAK__FLAG__) {
                                     break;
                                    
                                }
                            } ;
                            
                        })();
                        (wrapper).push(acc);
                        (wrapper).push("return");
                        (wrapper).push(" ");
                        (wrapper).push(target_reference);
                        (wrapper).push(";");
                        (wrapper).push("}");
                        (wrapper).push((preamble && preamble["4"]));
                        (wrapper).push("()");
                        return wrapper
                    }
                }
            };
            compile_prop=async function(tokens,ctx) {
                if (check_true (await not(((tokens && tokens.length)===3)))){
                    {
                        throw new SyntaxError("prop requires exactly 2 arguments");
                        
                    }
                } else {
                    {
                        let acc;
                        let target;
                        let target_val;
                        let preamble;
                        let idx_key;
                        acc=[];
                        target=await compile_wrapper_fn(await second(tokens),ctx);
                        target_val=null;
                        preamble=await calling_preamble(ctx);
                        idx_key=await compile_wrapper_fn(tokens[2],ctx);
                        ;
                        if (check_true ((await safety_level(ctx)>1))){
                            return await async function(){
                                if (check_true ((target instanceof String || typeof target==='string'))) {
                                    {
                                        return await (async function(){
                                            let __array_op_rval__80=target;
                                             if (__array_op_rval__80 instanceof Function){
                                                return await __array_op_rval__80("[",idx_key,"]") 
                                            } else {
                                                return [__array_op_rval__80,"[",idx_key,"]"]
                                            }
                                        })()
                                    }
                                } else {
                                    {
                                        target_val=await gen_temp_name("targ");
                                        return [(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()","{","let"," ",target_val,"=",target,";","if"," ","(",target_val,")","{"," ","return","(",target_val,")","[",idx_key,"]","}"," ","}",")","()"]
                                    }
                                }
                            } ()
                        } else {
                            return ["(",target,")","[",idx_key,"]"]
                        }
                    }
                }
            };
            compile_elem=async function(token,ctx) {
                let rval;
                rval=null;
                await console.warn("compile_elem - deprecated: check call: ",token);
                if (check_true ((await is_complex_ques_((token && token["val"]))|| (((token && token["val"]) instanceof Array)&& ((token && token["val"] && token["val"]["0"] && token["val"]["0"]["name"])==="if"))))){
                    rval=await compile_wrapper_fn(token,ctx)
                } else {
                    rval=await (async function(){
                         return await compile(token,ctx) 
                    })()
                };
                if (check_true (await not((rval instanceof Array)))){
                    {
                        rval=await (async function(){
                            let __array_op_rval__81=rval;
                             if (__array_op_rval__81 instanceof Function){
                                return await __array_op_rval__81() 
                            } else {
                                return [__array_op_rval__81]
                            }
                        })()
                    }
                };
                return rval
            };
            inline_log=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    return log
                } else {
                    return await defclog({
                        prefix:"compile_inline:",background:"#404880",color:"white"
                    })
                }
            })();
            compile_inline=async function(tokens,ctx) {
                let rval;
                let stmt;
                let inline_fn;
                let has_literal_ques_;
                let wrap_style;
                let args;
                rval=null;
                stmt=null;
                inline_fn=null;
                has_literal_ques_=false;
                wrap_style=0;
                args=[];
                await (async function() {
                    let __for_body__84=async function(token) {
                        stmt=await compile_wrapper_fn(token,ctx);
                        return (args).push(stmt)
                    };
                    let __array__85=[],__elements__83=await tokens["slice"].call(tokens,1);
                    let __BREAK__FLAG__=false;
                    for(let __iter__82 in __elements__83) {
                        __array__85.push(await __for_body__84(__elements__83[__iter__82]));
                        if(__BREAK__FLAG__) {
                             __array__85.pop();
                            break;
                            
                        }
                    }return __array__85;
                     
                })();
                if (check_true (await verbosity())){
                    {
                        await inline_log("args: ",args)
                    }
                };
                if (check_true (await (async function(){
                    let __targ__86=(Environment && Environment["inlines"]);
                    if (__targ__86){
                         return(__targ__86)[(tokens && tokens["0"] && tokens["0"]["name"])]
                    } 
                })())){
                    {
                        inline_fn=await (async function(){
                            let __targ__87=(Environment && Environment["inlines"]);
                            if (__targ__87){
                                 return(__targ__87)[(tokens && tokens["0"] && tokens["0"]["name"])]
                            } 
                        })();
                        rval=await (async function(){
                            let __array_op_rval__88=inline_fn;
                             if (__array_op_rval__88 instanceof Function){
                                return await __array_op_rval__88(args,ctx) 
                            } else {
                                return [__array_op_rval__88,args,ctx]
                            }
                        })()
                    }
                } else {
                    throw new ReferenceError(("no source for named lib function "+ (tokens && tokens["0"] && tokens["0"]["name"])));
                    
                };
                return rval
            };
            compile_push=async function(tokens,ctx) {
                let acc;
                let place;
                let thing;
                acc=[];
                place=await compile_wrapper_fn((tokens && tokens["1"]),ctx);
                thing=await compile_wrapper_fn((tokens && tokens["2"]),ctx);
                return await (async function(){
                    let __array_op_rval__89=place;
                     if (__array_op_rval__89 instanceof Function){
                        return await __array_op_rval__89(".push","(",thing,")") 
                    } else {
                        return [__array_op_rval__89,".push","(",thing,")"]
                    }
                })()
            };
            compile_list=async function(tokens,ctx) {
                let acc;
                let compiled_values;
                acc=["["];
                compiled_values=[];
                {
                    let it;
                    it=await get_ctx_val(ctx,"assignment_for");
                    if (check_true (it)){
                        await set_declaration(ctx,it,"type",Array)
                    } else {
                        
                    }
                };
                await (async function() {
                    let __for_body__92=async function(t) {
                        return (compiled_values).push(await compile_wrapper_fn(t,ctx))
                    };
                    let __array__93=[],__elements__91=await tokens["slice"].call(tokens,1);
                    let __BREAK__FLAG__=false;
                    for(let __iter__90 in __elements__91) {
                        __array__93.push(await __for_body__92(__elements__91[__iter__90]));
                        if(__BREAK__FLAG__) {
                             __array__93.pop();
                            break;
                            
                        }
                    }return __array__93;
                     
                })();
                await push_as_arg_list(acc,compiled_values);
                (acc).push("]");
                return acc
            };
            compile_typeof=async function(tokens,ctx) {
                let local_details=await (async function(){
                    if (check_true ((tokens && tokens["1"] && tokens["1"]["ref"]))){
                        return await get_ctx_val(ctx,(tokens && tokens["1"] && tokens["1"]["name"]))
                    } else {
                        return null
                    }
                })();
                ;
                let fully_qualified=await (async function(){
                    if (check_true (((tokens && tokens["1"] && tokens["1"]["name"])&& await contains_ques_("/",(tokens && tokens["1"] && tokens["1"]["name"]))))){
                        return true
                    } else {
                        return false
                    }
                })();
                ;
                if (check_true (await verbosity(ctx))){
                    {
                        await console.log("compile_typeof -> ",tokens)
                    }
                };
                if (check_true (((tokens && tokens.length)<2))){
                    {
                        throw new SyntaxError("typeof requires 1 argument");
                        
                    }
                };
                return await async function(){
                    if (check_true (((tokens && tokens["1"] && tokens["1"]["ref"])&& local_details))) {
                        return ["typeof"," ",await (async function(){
                             return await compile((tokens && tokens["1"]),ctx) 
                        })()]
                    } else if (check_true (((tokens && tokens["1"] && tokens["1"]["ref"])&& await get_lisp_ctx(ctx,(tokens && tokens["1"] && tokens["1"]["name"]))))) {
                        return ["typeof"," ",await (async function(){
                             return await compile((tokens && tokens["1"]),ctx) 
                        })()]
                    } else if (check_true ((tokens && tokens["1"] && tokens["1"]["ref"]))) {
                        return ["(","typeof"," ","(","function","() { let __tval=",await compile_lisp_scoped_reference((tokens && tokens["1"] && tokens["1"]["name"]),ctx,true),"; if (__tval === ReferenceError) return undefined; else return __tval; }",")()",")"]
                    } else {
                        return ["typeof"," ",await compile_wrapper_fn((tokens && tokens["1"]),ctx)]
                    }
                } ()
            };
            compile_instanceof=async function(tokens,ctx) {
                let acc;
                acc=[];
                if (check_true (((tokens instanceof Array)&& ((tokens && tokens.length)===3)))){
                    return ["(",await (async function(){
                        if (check_true (await is_complex_ques_((tokens && tokens["1"])))){
                            return await compile_wrapper_fn((tokens && tokens["1"]),ctx)
                        } else {
                            return await compile((tokens && tokens["1"]),ctx)
                        }
                    })()," ","instanceof"," ",await (async function(){
                        if (check_true (await is_complex_ques_((tokens && tokens["1"])))){
                            return await compile_wrapper_fn((tokens && tokens["2"]),ctx)
                        } else {
                            return await compile((tokens && tokens["2"]),ctx)
                        }
                    })(),")"]
                } else {
                    throw new SyntaxError("instanceof requires 2 arguments");
                    
                }
            };
            compile_compare=async function(tokens,ctx) {
                let acc;
                let ops;
                let __operator__94= async function(){
                    return ops[await (async function(){
                        let __targ__96=await first(tokens);
                        if (__targ__96){
                             return(__targ__96)["name"]
                        } 
                    })()]
                };
                let left;
                let right;
                {
                    acc=await (async function(){
                         return [{
                            ctype:"expression"
                        }] 
                    })();
                    ctx=await (async function(){
                         return await new_ctx(ctx) 
                    })();
                    ops=await ( async function(){
                        let __obj__95=new Object();
                        __obj__95["eq"]="==";
                        __obj__95["=="]="===";
                        __obj__95["<"]="<";
                        __obj__95[">"]=">";
                        __obj__95["gt"]=">";
                        __obj__95["lt"]="<";
                        __obj__95["<="]="<=";
                        __obj__95[">="]=">=";
                        return __obj__95;
                        
                    })();
                    let operator=await __operator__94();
                    ;
                    left=tokens[1];
                    right=tokens[2];
                    if (check_true (((tokens && tokens.length)<3))){
                        {
                            throw new SyntaxError("comparison operation requires 2 arguments");
                            
                        }
                    };
                    await set_ctx(ctx,"__COMP_INFIX_OPS__",true);
                    (acc).push("(");
                    (acc).push(await (async function(){
                         return await compile(left,ctx) 
                    })());
                    (acc).push(operator);
                    (acc).push(await (async function(){
                         return await compile(right,ctx) 
                    })());
                    (acc).push(")");
                    return acc
                }
            };
            compile_assignment=async function(tokens,ctx) {
                let acc;
                let token;
                let assignment_value;
                let assignment_type;
                let wrap_as_function_ques_;
                let preamble;
                let comps;
                let sanitized;
                let target_details;
                let target;
                acc=[];
                token=await second(tokens);
                assignment_value=await (async function(){
                    if (check_true (((tokens && tokens.length)<3))){
                        throw new SyntaxError("assignment is missing a value argument");
                        
                    } else {
                        return null
                    }
                })();
                assignment_type=null;
                wrap_as_function_ques_=null;
                preamble=await calling_preamble(ctx);
                comps=[];
                sanitized=await (async function(){
                    if (check_true (((token && token["ref"])&& (token && token["name"])))){
                        return await sanitize_js_ref_name((token && token["name"]))
                    } else {
                        throw new SyntaxError(("assignment: missing assignment symbol"));
                        
                    }
                })();
                target_details=await (async function(){
                     return await async function(){
                        if (check_true (await get_ctx(ctx,sanitized))) {
                            return "local"
                        } else if (check_true (await get_lisp_ctx(ctx,(token && token["name"])))) {
                            return "global"
                        } else {
                            {
                                {
                                    let it;
                                    it=await get_declaration_details(ctx,(token && token["name"]));
                                    if (check_true (it)){
                                        return await async function(){
                                            if (check_true ((it && it["is_argument"]))) {
                                                return "local"
                                            } else if (check_true ((it && it["declared_global"]))) {
                                                return "global"
                                            } else if (check_true (it)) {
                                                return "local"
                                            }
                                        } ()
                                    } else {
                                        return 
                                    }
                                }
                            }
                        }
                    } () 
                })();
                target=await (async function(){
                    if (check_true ((target_details==="local"))){
                        return sanitized
                    } else {
                        return (token && token["name"])
                    }
                })();
                ;
                comps=(target).split(".");
                if (check_true ((undefined===target_details))){
                    throw new ReferenceError(("assignment to undeclared symbol: "+ (token && token["name"])));
                    
                };
                if (check_true (((comps && comps.length)>1))){
                    throw new SyntaxError(("invalid assignment to an object property, use set_prop instead: "+ target));
                    
                };
                if (check_true ((((tokens && tokens["2"] && tokens["2"]["type"])==="arr")&& ((tokens && tokens["2"] && tokens["2"]["val"] && tokens["2"]["val"]["0"] && tokens["2"]["val"]["0"]["type"])==="special")&& ((tokens && tokens["2"] && tokens["2"]["val"] && tokens["2"]["val"]["0"] && tokens["2"]["val"]["0"]["name"])==="defvar")))){
                    {
                        throw new SyntaxError("cannot assign result of the allocation operator defvar");
                        
                    }
                };
                await unset_ambiguous(ctx,target);
                await async function(){
                    ctx["in_assignment"]=true;
                    return ctx;
                    
                }();
                assignment_value=await compile_wrapper_fn((tokens && tokens["2"]),ctx);
                if (check_true (((assignment_value instanceof Array)&& ((assignment_value && assignment_value["0"]) instanceof Object)&& (assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])))){
                    {
                        assignment_type=await map_ctype_to_value((assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"]),assignment_value)
                    }
                } else {
                    {
                        await set_ambiguous(ctx,target);
                        assignment_type=UnknownType
                    }
                };
                if (check_true ((target_details==="local"))){
                    {
                        await set_ctx(ctx,target,assignment_type);
                        (acc).push(target);
                        (acc).push("=");
                        (acc).push(assignment_value)
                    }
                } else {
                    {
                        await (async function() {
                            let __for_body__100=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__101=[],__elements__99=await (async function(){
                                 return [{
                                    ctype:"statement"
                                },(preamble && preamble["0"])," ","Environment",".","set_global","(","\"",target,"\"",",",assignment_value,")"] 
                            })();
                            let __BREAK__FLAG__=false;
                            for(let __iter__98 in __elements__99) {
                                __array__101.push(await __for_body__100(__elements__99[__iter__98]));
                                if(__BREAK__FLAG__) {
                                     __array__101.pop();
                                    break;
                                    
                                }
                            }return __array__101;
                             
                        })()
                    }
                };
                await async function(){
                    ctx["in_assignment"]=false;
                    return ctx;
                    
                }();
                if (check_true ((target_details==="local"))){
                    await set_ctx(ctx,target,assignment_type)
                };
                return acc
            };
            top_level_log=await (async function(){
                 return await defclog({
                    prefix:"top-level",color:"darkgreen",background:"#300010"
                }) 
            })();
            compile_toplevel=async function(lisp_tree,ctx,block_options) {
                if (check_true (await get_ctx_val(ctx,"__IN_LAMBDA__"))){
                    throw new EvalError("Compiler attempt to compile top-level in lambda (most likely a bug)");
                    
                } else {
                    {
                        {
                            let idx;
                            let rval;
                            let __tokens__103= async function(){
                                return null
                            };
                            let stmt;
                            let base_ctx;
                            let num_non_return_statements;
                            {
                                idx=0;
                                rval=null;
                                let tokens=await __tokens__103();
                                ;
                                stmt=null;
                                base_ctx=ctx;
                                num_non_return_statements=(await length(lisp_tree)- 2);
                                ctx=await (async function(){
                                    if (check_true ((block_options && block_options["no_scope_boundary"]))){
                                        return ctx
                                    } else {
                                        return await new_ctx(ctx)
                                    }
                                })();
                                await (async function(){
                                     let __test_condition__104=async function() {
                                        return (idx<num_non_return_statements)
                                    };
                                    let __body_ref__105=async function() {
                                        idx+=1;
                                        ctx=await (async function(){
                                             return await new_ctx(ctx) 
                                        })();
                                        await set_new_completion_scope(ctx);
                                        await set_ctx(ctx,"__TOP_LEVEL__",true);
                                        if (check_true (await verbosity(ctx))){
                                            {
                                                await console.log("");
                                                await top_level_log((""+ idx+ "/"+ num_non_return_statements),"->",await (await Environment.get_global("as_lisp"))(lisp_tree[idx]))
                                            }
                                        };
                                        tokens=await tokenize(lisp_tree[idx],ctx);
                                        stmt=await (async function(){
                                             return await compile(tokens,ctx) 
                                        })();
                                        rval=await wrap_and_run(stmt,ctx,{
                                            bind_mode:true
                                        });
                                        if (check_true (await verbosity(ctx))){
                                            {
                                                await top_level_log((""+ idx+ "/"+ num_non_return_statements),"compiled <- ",await (await Environment.get_global("as_lisp"))(stmt));
                                                return await top_level_log((""+ idx+ "/"+ num_non_return_statements),"<-",await (await Environment.get_global("as_lisp"))(rval))
                                            }
                                        }
                                    };
                                    let __BREAK__FLAG__=false;
                                    while(await __test_condition__104()) {
                                         await __body_ref__105();
                                         if(__BREAK__FLAG__) {
                                             break;
                                            
                                        }
                                    } ;
                                    
                                })();
                                return lisp_tree[(idx+ 1)]
                            }
                        }
                    }
                }
            };
            check_statement_completion=async function(ctx,stmts) {
                let stmt;
                let cmp_rec;
                stmt=await (async function(){
                    if (check_true ((null==stmts))){
                        throw new Error("compiler error: check_statement_completion: received undefined/nil statement array.");
                        
                    } else {
                        return await last(stmts)
                    }
                })();
                cmp_rec=await get_ctx(ctx,"__COMPLETION_SCOPE__");
                if (check_true ((((ctx && ctx["block_step"])===0)&& await not(await contains_ques_((stmt && stmt["0"] && stmt["0"]["ctype"]),["block","ifblock","tryblock","letblock"]))&& await not(await contains_ques_((stmt && stmt["0"] && stmt["0"]["completion"]),completion_types))&& await not(((cmp_rec && cmp_rec["scope_type"])==="arrow"))&& await not(((cmp_rec && cmp_rec["scope_type"])==="generator"))&& await not(((stmt && stmt["0"] && stmt["0"]["0"])==="yield"))))){
                    {
                        (stmts).pop();
                        await (await Environment.get_global("assert"))(cmp_rec,"compiler error: check_statement_completion unable to find completion_scope record in context");
                        if (check_true ((((stmt && stmt["0"]) instanceof Object)&& await not(((stmt && stmt["0"]) instanceof Array))))){
                            {
                                await async function(){
                                    let __target_obj__106=(stmt && stmt["0"]);
                                    __target_obj__106["completion"]="return";
                                    return __target_obj__106;
                                    
                                }();
                                if (check_true (((stmt && stmt["0"] && stmt["0"]["ctype"])==="__JS__"))){
                                    (stmts).push(await (async function(){
                                        let __array_op_rval__107=stmt;
                                         if (__array_op_rval__107 instanceof Function){
                                            return await __array_op_rval__107() 
                                        } else {
                                            return [__array_op_rval__107]
                                        }
                                    })())
                                } else {
                                    (stmts).push(await (async function(){
                                        let __array_op_rval__108=(stmt && stmt["0"]);
                                         if (__array_op_rval__108 instanceof Function){
                                            return await __array_op_rval__108("return ",await (await Environment.get_global("rest"))(stmt)) 
                                        } else {
                                            return [__array_op_rval__108,"return ",await (await Environment.get_global("rest"))(stmt)]
                                        }
                                    })())
                                };
                                ((cmp_rec && cmp_rec["completion_records"])).push({
                                    block_id:(ctx && ctx["block_id"]),block_step:(ctx && ctx["block_step"]),type:"return",stmt:await last(stmts)
                                })
                            }
                        } else {
                            {
                                if (check_true ((await not(((cmp_rec && cmp_rec["scope_type"])==="arrow"))&& await not(((cmp_rec && cmp_rec["scope_type"])==="generator"))))){
                                    (stmts).push(await (async function(){
                                         return [{
                                            completion:"return"
                                        },"return ",stmt] 
                                    })())
                                };
                                ((cmp_rec && cmp_rec["completion_records"])).push({
                                    block_id:(ctx && ctx["block_id"]),type:"return",block_step:(ctx && ctx["block_step"]),stmt:await last(stmts)
                                })
                            }
                        };
                        return stmts
                    }
                } else {
                    return stmts
                }
            };
            compile_block=async function(tokens,ctx,block_options) {
                let acc;
                let block_id;
                let clog;
                let token;
                let block_type;
                let last_stmt;
                let is_first_level;
                let return_last;
                let stmt;
                let subacc;
                let completion_scope;
                let stmt_ctype;
                let lambda_block;
                let stmts;
                let idx;
                acc=[];
                block_id=(((block_options && block_options.name)&& await add((block_options && block_options.name),(blk_counter=blk_counter+1)))|| (blk_counter=blk_counter+1));
                clog=await (async function(){
                    if (check_true (quiet_mode)){
                        return log
                    } else {
                        return await defclog({
                            prefix:("compile_block ("+ block_id+ "):"),background:"#404080",color:"white"
                        })
                    }
                })();
                ctx=await (async function(){
                    if (check_true ((block_options && block_options["force_no_new_ctx"]))){
                        return ctx
                    } else {
                        return await new_ctx(ctx)
                    }
                })();
                token=null;
                block_type="sub";
                last_stmt=null;
                is_first_level=false;
                return_last=(ctx && ctx["return_last_value"]);
                stmt=null;
                subacc=[];
                completion_scope=await get_ctx(ctx,"__COMPLETION_SCOPE__");
                stmt_ctype=null;
                lambda_block=false;
                stmts=[];
                idx=0;
                if (check_true ((null==ctx))){
                    {
                        throw new ReferenceError("undefined ctx passed to compile block");
                        
                    }
                };
                if (check_true (await verbosity(ctx))){
                    {
                        await clog("->",tokens,ctx,block_options)
                    }
                };
                if (check_true (needs_first_level)){
                    {
                        is_first_level=true;
                        needs_first_level=false
                    }
                };
                if (check_true ((opts && opts["include_source"]))){
                    {
                        if (check_true (((tokens && tokens["path"])&& ((tokens && tokens["path"] && tokens["path"]["length"])>0)))){
                            {
                                (acc).push(await source_comment(tokens))
                            }
                        }
                    }
                };
                await async function(){
                    ctx["block_id"]=block_id;
                    return ctx;
                    
                }();
                await (await Environment.get_global("assert"))(completion_scope,"block called with no completion scope");
                await (await Environment.get_global("assert"))((completion_scope instanceof Object),"block called with an invalid completion scope");
                if (check_true ((completion_scope && completion_scope["root_block_id"]))){
                    {
                        await set_ctx(ctx,"__IN_SUB_BLOCK__",true)
                    }
                } else {
                    {
                        await async function(){
                            completion_scope["root_block_id"]=block_id;
                            return completion_scope;
                            
                        }();
                        block_type="root";
                        await set_ctx(ctx,"__IN_SUB_BLOCK__",false)
                    }
                };
                if (check_true ((block_options && block_options["no_scope_boundary"]))){
                    {
                        await async function(){
                            ctx["no_scope_boundary"]=true;
                            return ctx;
                            
                        }()
                    }
                };
                if (check_true ((await get_ctx_val(ctx,"__LAMBDA_STEP__")===-1))){
                    {
                        lambda_block=true;
                        await (await Environment.get_global("setf_ctx"))(ctx,"__LAMBDA_STEP__",((tokens && tokens.length)- 1))
                    }
                };
                if (check_true (is_first_level)){
                    {
                        (acc).push(first_level_setup)
                    }
                };
                await async function(){
                    ctx["final_block_statement"]=false;
                    return ctx;
                    
                }();
                await (async function(){
                     let __test_condition__113=async function() {
                        return (idx<((tokens && tokens.length)- 1))
                    };
                    let __body_ref__114=async function() {
                        idx+=1;
                        subacc=[];
                        token=tokens[idx];
                        if (check_true ((idx===((tokens && tokens.length)- 1)))){
                            {
                                await async function(){
                                    ctx["final_block_statement"]=true;
                                    return ctx;
                                    
                                }()
                            }
                        };
                        if (check_true ((block_type==="root"))){
                            await async function(){
                                ctx["block_step"]=((tokens && tokens.length)- 1- idx);
                                return ctx;
                                
                            }()
                        };
                        await async function(){
                            ctx["sub_block_step"]=((tokens && tokens.length)- 1- idx);
                            return ctx;
                            
                        }();
                        if (check_true (lambda_block)){
                            {
                                await set_ctx(ctx,"__LAMBDA_STEP__",((tokens && tokens.length)- 1- idx))
                            }
                        };
                        await async function(){
                            if (check_true (((block_type==="root")&& ((token && token["type"])==="arr")&& ((token && token["val"] && token["val"]["0"] && token["val"]["0"]["name"])==="return")))) {
                                {
                                    return stmt=await compile_return((token && token["val"]),ctx)
                                }
                            } else if (check_true ((((token && token["val"] && token["val"]["0"] && token["val"]["0"]["name"])==="declare")&& (block_options && block_options["ignore_declarations"])))) {
                                stmt={
                                    ignored:"declare"
                                }
                            } else if (check_true (((((tokens && tokens.length)- 1- idx)>0)&& ((token && token["val"] && token["val"]["0"] && token["val"]["0"]["type"])==="special")&& (((token && token["val"] && token["val"]["0"] && token["val"]["0"]["name"])==="if")|| ((token && token["val"] && token["val"]["0"] && token["val"]["0"]["name"])==="try"))))) {
                                {
                                    let subctx;
                                    subctx=await (async function(){
                                         return await new_ctx(ctx) 
                                    })();
                                    await async function(){
                                        subctx["block_step"]=((tokens && tokens.length)- 1- idx);
                                        return subctx;
                                        
                                    }();
                                    if (check_true (((token && token["val"] && token["val"]["0"] && token["val"]["0"]["name"])==="if"))){
                                        stmt=await compile_if((token && token["val"]),subctx)
                                    } else {
                                        stmt=await compile_try((token && token["val"]),subctx)
                                    }
                                }
                            } else {
                                stmt=await (async function(){
                                     return await compile(token,ctx) 
                                })()
                            }
                        } ();
                        if (check_true ((stmt===undefined))){
                            {
                                if (check_true (is_error)){
                                    stmt=await (async function(){
                                         return [{
                                            ctype:Error
                                        },"ERROR_STATE"] 
                                    })()
                                } else {
                                    throw new EvalError("compile_block: returned stmt is undefined");
                                    
                                }
                            }
                        };
                        (stmts).push(stmt);
                        if (check_true ((idx<((tokens && tokens.length)- 1)))){
                            {
                                return (stmts).push(";")
                            }
                        }
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__113()) {
                         await __body_ref__114();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                await check_statement_completion(ctx,stmts);
                (acc).push(stmts);
                if (check_true (await not((block_options && block_options["no_scope_boundary"])))){
                    {
                        (acc).unshift("{");
                        (acc).push("}")
                    }
                };
                (acc).unshift({
                    ctype:"block",block_id:block_id,block_options:block_options
                });
                return acc
            };
            Expression=new Function("","{ return \"expression\" }");
            Statement=new Function("","{ return \"statement\" }");
            NumberType=new Function("","{ return \"number\" }");
            StringType=new Function("","{ return \"string\" }");
            NilType=new Function("","{ return \"nil\" }");
            UnknownType=new Function(""," { return \"unknown\"} ");
            ArgumentType=new Function(""," { return \"argument\" }");
            compile_defvar=async function(tokens,ctx,opts) {
                let target;
                let wrap_as_function_ques_;
                let ctx_details;
                let allocation_type;
                let assignment_type;
                let assignment_value;
                target=await clean_quoted_reference(await sanitize_js_ref_name((tokens && tokens["1"] && tokens["1"]["name"])));
                wrap_as_function_ques_=null;
                ctx_details=null;
                ctx=ctx;
                allocation_type=await (async function(){
                    if (check_true ((opts && opts["constant"]))){
                        return "const"
                    } else {
                        return "let"
                    }
                })();
                assignment_type=null;
                assignment_value=null;
                if (check_true (((tokens && tokens.length)<2))){
                    {
                        throw new SyntaxError(("defvar requires 2 arguments, received "+ ((tokens && tokens.length)- 1)));
                        
                    }
                };
                if (check_true (((ctx && ctx["final_block_statement"])&& await not((ctx && ctx["no_scope_boundary"]))))){
                    {
                        throw new SyntaxError("defvar has no effect at end of block scope");
                        
                    }
                };
                assignment_value=await (async function(){
                    return await compile_wrapper_fn((tokens && tokens["2"]),ctx)
                })();
                ctx_details=await get_declaration_details(ctx,target);
                assignment_type=await add(new Object(),ctx_details,await get_declarations(ctx,target));
                await async function(){
                    if (check_true (((assignment_value instanceof Array)&& ((assignment_value && assignment_value["0"]) instanceof Object)&& (assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])))) {
                        {
                            return await set_ctx(ctx,target,await map_ctype_to_value((assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"]),assignment_value))
                        }
                    } else if (check_true ((assignment_type && assignment_type["value"]) instanceof Function)) {
                        await set_ctx(ctx,target,(assignment_type && assignment_type["value"]))
                    } else {
                        await set_ctx(ctx,target,assignment_value)
                    }
                } ();
                if (check_true ((ctx && ctx["defvar_eval"]))){
                    {
                        await (await Environment.get_global("delete_prop"))(ctx,"defvar_eval");
                        return [{
                            ctype:"assignment"
                        },allocation_type," ",target,"=",assignment_value,"()",";"]
                    }
                } else {
                    return [{
                        ctype:"assignment"
                    },await (async function(){
                        if (check_true (((ctx_details && ctx_details["is_argument"])&& ((ctx_details && ctx_details["levels_up"])===1)))){
                            return ""
                        } else {
                            return (allocation_type+ " ")
                        }
                    })(),"",target,"=",[assignment_value],";"]
                }
            };
            get_declaration_details=async function(ctx,symname,_levels_up) {
                return await async function(){
                    if (check_true ((await (async function(){
                        let __targ__119=(ctx && ctx["scope"]);
                        if (__targ__119){
                             return(__targ__119)[symname]
                        } 
                    })()&& ctx["lambda_scope"]))) {
                        return {
                            name:symname,is_argument:true,levels_up:(_levels_up|| 0),value:await (async function(){
                                let __targ__120=(ctx && ctx["scope"]);
                                if (__targ__120){
                                     return(__targ__120)[symname]
                                } 
                            })(),declared_global:await (async function(){
                                if (check_true (await (async function(){
                                    let __targ__121=(root_ctx && root_ctx["defined_lisp_globals"]);
                                    if (__targ__121){
                                         return(__targ__121)[symname]
                                    } 
                                })())){
                                    return true
                                } else {
                                    return false
                                }
                            })()
                        }
                    } else if (check_true (await (async function(){
                        let __targ__122=(ctx && ctx["scope"]);
                        if (__targ__122){
                             return(__targ__122)[symname]
                        } 
                    })())) {
                        return {
                            name:symname,is_argument:false,levels_up:(_levels_up|| 0),value:await (async function(){
                                let __targ__123=(ctx && ctx["scope"]);
                                if (__targ__123){
                                     return(__targ__123)[symname]
                                } 
                            })(),declarations:await get_declarations(ctx,symname),declared_global:await (async function(){
                                if (check_true (await (async function(){
                                    let __targ__124=(root_ctx && root_ctx["defined_lisp_globals"]);
                                    if (__targ__124){
                                         return(__targ__124)[symname]
                                    } 
                                })())){
                                    return true
                                } else {
                                    return false
                                }
                            })()
                        }
                    } else if (check_true (((ctx["parent"]==null)&& await (async function(){
                        let __targ__125=(root_ctx && root_ctx["defined_lisp_globals"]);
                        if (__targ__125){
                             return(__targ__125)[symname]
                        } 
                    })()))) {
                        return {
                            name:symname,is_argument:false,levels_up:(_levels_up|| 0),value:await (async function(){
                                let __targ__126=(ctx && ctx["scope"]);
                                if (__targ__126){
                                     return(__targ__126)[symname]
                                } 
                            })(),declarations:await get_declarations(ctx,symname),declared_global:true
                        }
                    } else if (check_true ((ctx && ctx["parent"]))) {
                        return await get_declaration_details((ctx && ctx["parent"]),symname,((_levels_up&& await add(_levels_up,1))|| 1))
                    } else if (check_true (await not((NOT_FOUND_THING===await Environment["get_global"].call(Environment,symname,NOT_FOUND_THING))))) {
                        return {
                            name:symname,is_argument:false,levels_up:(_levels_up|| 0),value:await Environment["get_global"].call(Environment,symname),declared_global:true
                        }
                    }
                } ()
            };
            clean_quoted_reference=async function(name) {
                return await async function(){
                    if (check_true (((name instanceof String || typeof name==='string')&& await starts_with_ques_("\"",name)&& await (await Environment.get_global("ends_with?"))("\"",name)))) {
                        return await (async function() {
                            {
                                 let __call_target__=await name["substr"].call(name,1), __call_method__="substr";
                                return await __call_target__[__call_method__].call(__call_target__,0,(await length(name)- 2))
                            } 
                        })()
                    } else {
                        return name
                    }
                } ()
            };
            compile_let=async function(tokens,ctx) {
                let acc;
                let clog;
                let token;
                let declarations_handled;
                let assignment_value;
                let suppress_return;
                let block_declarations;
                let my_tokens;
                let assignment_type;
                let stmt;
                let def_idx;
                let redefinitions;
                let need_sub_block;
                let assignments;
                let reference_name;
                let shadowed_globals;
                let alloc_set;
                let is_first_level;
                let sub_block_count;
                let ctx_details;
                let preamble;
                let structure_validation_rules;
                let validation_results;
                let allocations;
                let block;
                let syntax_error;
                let idx;
                acc=[];
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                clog=await (async function(){
                    if (check_true (quiet_mode)){
                        return log
                    } else {
                        return await defclog({
                            prefix:("compile_let: "+ ((ctx && ctx["block_id"])|| "")),background:"#B0A0F0",color:"black"
                        })
                    }
                })();
                token=null;
                declarations_handled=false;
                assignment_value=null;
                suppress_return=null;
                block_declarations=new Object();
                my_tokens=tokens;
                assignment_type=null;
                stmt=null;
                def_idx=null;
                redefinitions=new Object();
                need_sub_block=false;
                assignments=new Object();
                reference_name=null;
                shadowed_globals=new Object();
                alloc_set=null;
                is_first_level=false;
                sub_block_count=0;
                ctx_details=null;
                preamble=await calling_preamble(ctx);
                structure_validation_rules=await (async function(){
                     return [[[1,"val"],[(await Environment.get_global("is_array?"))],"allocation section"],await (async function(){
                         return [[2],[async function(v) {
                            return await not((v===undefined))
                        }],"block"] 
                    })()] 
                })();
                validation_results=null;
                allocations=(tokens && tokens["1"] && tokens["1"]["val"]);
                block=await tokens["slice"].call(tokens,2);
                syntax_error=null;
                idx=-1;
                ;
                if (check_true (await not((allocations instanceof Array)))){
                    throw new SyntaxError("let: missing/malformed allocation section");
                    
                };
                if (check_true (((block && block.length)===0))){
                    throw new SyntaxError("let: missing block");
                    
                };
                await async function(){
                    ctx["return_last_value"]=true;
                    return ctx;
                    
                }();
                await set_ctx(ctx,"__LOCAL_SCOPE__",true);
                (acc).push("{");
                sub_block_count+=1;
                if (check_true (((block && block["0"] && block["0"]["val"] && block["0"]["val"]["0"] && block["0"]["val"]["0"]["name"])==="declare"))){
                    {
                        declarations_handled=true;
                        (acc).push(await compile_declare((block && block["0"] && block["0"]["val"]),ctx))
                    }
                };
                if (check_true (needs_first_level)){
                    {
                        is_first_level=true;
                        needs_first_level=false;
                        if (check_true (is_first_level)){
                            {
                                (acc).push(first_level_setup)
                            }
                        }
                    }
                };
                await (async function(){
                     let __test_condition__128=async function() {
                        return (idx<((allocations && allocations.length)- 1))
                    };
                    let __body_ref__129=async function() {
                        idx+=1;
                        alloc_set=await (async function(){
                            let __targ__130=allocations[idx];
                            if (__targ__130){
                                 return(__targ__130)["val"]
                            } 
                        })();
                        reference_name=await clean_quoted_reference(await sanitize_js_ref_name((alloc_set && alloc_set["0"] && alloc_set["0"]["name"])));
                        await (await Environment.get_global("assert"))(((reference_name instanceof String || typeof reference_name==='string')&& (await length(reference_name)>0)),("Invalid reference name: "+ (alloc_set && alloc_set["0"] && alloc_set["0"]["name"])));
                        ctx_details=await get_declaration_details(ctx,reference_name);
                        if (check_true (ctx_details)){
                            {
                                if (check_true ((await not((ctx_details && ctx_details["is_argument"]))&& ((ctx_details && ctx_details["levels_up"])>1)))){
                                    {
                                        need_sub_block=true;
                                        if (check_true (redefinitions[reference_name])){
                                            (redefinitions[reference_name]).push(await gen_temp_name(reference_name))
                                        } else {
                                            await async function(){
                                                redefinitions[reference_name]=[0,await gen_temp_name(reference_name)];
                                                return redefinitions;
                                                
                                            }()
                                        };
                                        if (check_true (((ctx_details && ctx_details["declared_global"])&& await not((ctx_details && ctx_details["is_argument"]))))){
                                            {
                                                await async function(){
                                                    shadowed_globals[(alloc_set && alloc_set["0"] && alloc_set["0"]["name"])]=true;
                                                    return shadowed_globals;
                                                    
                                                }()
                                            }
                                        }
                                    }
                                }
                            }
                        };
                        if (check_true (await not((ctx_details && ctx_details["is_argument"])))){
                            {
                                return await set_ctx(ctx,reference_name,AsyncFunction)
                            }
                        }
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__128()) {
                         await __body_ref__129();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                idx=-1;
                await (async function(){
                     let __test_condition__133=async function() {
                        return (idx<((allocations && allocations.length)- 1))
                    };
                    let __body_ref__134=async function() {
                        idx+=1;
                        stmt=[];
                        alloc_set=await (async function(){
                            let __targ__135=allocations[idx];
                            if (__targ__135){
                                 return(__targ__135)["val"]
                            } 
                        })();
                        reference_name=await clean_quoted_reference(await sanitize_js_ref_name((alloc_set && alloc_set["0"] && alloc_set["0"]["name"])));
                        ctx_details=await get_declaration_details(ctx,reference_name);
                        await async function(){
                            if (check_true (((alloc_set && alloc_set["1"] && alloc_set["1"]["val"]) instanceof Array))) {
                                {
                                    await async function(){
                                        ctx["in_assignment"]=true;
                                        return ctx;
                                        
                                    }();
                                    await set_ctx(ctx,"assignment_for",reference_name);
                                    assignment_value=await compile_wrapper_fn((alloc_set && alloc_set["1"]),ctx);
                                    await set_ctx(ctx,"assignment_for",null);
                                    return await async function(){
                                        ctx["in_assignment"]=false;
                                        return ctx;
                                        
                                    }()
                                }
                            } else if (check_true ((((alloc_set && alloc_set["1"] && alloc_set["1"]["name"]) instanceof String || typeof (alloc_set && alloc_set["1"] && alloc_set["1"]["name"])==='string')&& await not((ctx_details && ctx_details["is_argument"]))&& (alloc_set && alloc_set["1"] && alloc_set["1"]["ref"])&& await not((await Environment["get_global"].call(Environment,(alloc_set && alloc_set["1"] && alloc_set["1"]["name"]),NOT_FOUND_THING)===NOT_FOUND_THING))&& shadowed_globals[(alloc_set && alloc_set["0"] && alloc_set["0"]["name"])]))) {
                                {
                                    assignment_value=await (async function(){
                                         return [{
                                            ctype:(ctx_details && ctx_details["value"])
                                        },"await"," ",env_ref,"get_global","(","\"",(alloc_set && alloc_set["0"] && alloc_set["0"]["name"]),"\"",")"] 
                                    })()
                                }
                            } else {
                                {
                                    await set_ctx(ctx,"assignment_for",reference_name);
                                    assignment_value=await compile_wrapper_fn((alloc_set && alloc_set["1"]),ctx);
                                    await set_ctx(ctx,"assignment_for",null);
                                    if (check_true (await verbosity(ctx))){
                                        {
                                            await clog("setting simple assignment value for",reference_name,": <- ",await (async function(){
                                                 return await clone(assignment_value) 
                                            })())
                                        }
                                    }
                                }
                            }
                        } ();
                        await async function(){
                            if (check_true (((assignment_value instanceof Array)&& ((assignment_value && assignment_value["0"]) instanceof Object)&& (assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])))) {
                                {
                                    return await set_ctx(ctx,reference_name,await map_ctype_to_value((assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"]),assignment_value))
                                }
                            } else if (check_true (((assignment_value instanceof Array)&& ((assignment_value && assignment_value["0"]) instanceof Array)&& (assignment_value && assignment_value["0"] && assignment_value["0"]["0"] && assignment_value["0"]["0"]["ctype"])))) {
                                {
                                    await set_ctx(ctx,reference_name,await map_ctype_to_value((assignment_value && assignment_value["0"] && assignment_value["0"]["0"] && assignment_value["0"]["0"]["ctype"]),assignment_value))
                                }
                            } else {
                                {
                                    await set_ctx(ctx,reference_name,assignment_value)
                                }
                            }
                        } ();
                        if (check_true ((ctx_details && ctx_details["is_argument"]))){
                            {
                                await async function(){
                                    block_declarations[reference_name]=true;
                                    return block_declarations;
                                    
                                }()
                            }
                        };
                        def_idx=null;
                        await async function(){
                            if (check_true ((redefinitions[reference_name]&& await first(redefinitions[reference_name])))) {
                                {
                                    def_idx=await first(redefinitions[reference_name]);
                                    def_idx+=1;
                                    await async function(){
                                        let __target_obj__139=redefinitions[reference_name];
                                        __target_obj__139[0]=def_idx;
                                        return __target_obj__139;
                                        
                                    }();
                                    return await (async function() {
                                        let __for_body__142=async function(t) {
                                            return (acc).push(t)
                                        };
                                        let __array__143=[],__elements__141=["let"," ",await (async function(){
                                            let __targ__144=redefinitions[reference_name];
                                            if (__targ__144){
                                                 return(__targ__144)[def_idx]
                                            } 
                                        })(),"="," ",(preamble && preamble["1"])," ","function","()","{","return"," ",assignment_value,"}",";"];
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__140 in __elements__141) {
                                            __array__143.push(await __for_body__142(__elements__141[__iter__140]));
                                            if(__BREAK__FLAG__) {
                                                 __array__143.pop();
                                                break;
                                                
                                            }
                                        }return __array__143;
                                         
                                    })()
                                }
                            } else if (check_true (await not(block_declarations[reference_name]))) {
                                {
                                    await (async function() {
                                        let __for_body__147=async function(t) {
                                            return (acc).push(t)
                                        };
                                        let __array__148=[],__elements__146=["let"," ",reference_name,";"];
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__145 in __elements__146) {
                                            __array__148.push(await __for_body__147(__elements__146[__iter__145]));
                                            if(__BREAK__FLAG__) {
                                                 __array__148.pop();
                                                break;
                                                
                                            }
                                        }return __array__148;
                                         
                                    })();
                                    await async function(){
                                        block_declarations[reference_name]=true;
                                        return block_declarations;
                                        
                                    }()
                                }
                            }
                        } ();
                        if (check_true (await not(assignments[reference_name]))){
                            {
                                await async function(){
                                    assignments[reference_name]=[];
                                    return assignments;
                                    
                                }()
                            }
                        };
                        return (assignments[reference_name]).push(await (async function(){
                            if (check_true (def_idx)){
                                return [(preamble && preamble["0"])," ",await (async function(){
                                    let __targ__151=redefinitions[reference_name];
                                    if (__targ__151){
                                         return(__targ__151)[def_idx]
                                    } 
                                })(),"()",";"]
                            } else {
                                return assignment_value
                            }
                        })())
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__133()) {
                         await __body_ref__134();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                if (check_true (need_sub_block)){
                    {
                        await (async function() {
                            let __for_body__154=async function(pset) {
                                return await (async function() {
                                    let __for_body__158=async function(redef) {
                                        return (redefinitions[(pset && pset["0"])]).shift()
                                    };
                                    let __array__159=[],__elements__157=(pset && pset["1"]);
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__156 in __elements__157) {
                                        __array__159.push(await __for_body__158(__elements__157[__iter__156]));
                                        if(__BREAK__FLAG__) {
                                             __array__159.pop();
                                            break;
                                            
                                        }
                                    }return __array__159;
                                     
                                })()
                            };
                            let __array__155=[],__elements__153=await (await Environment.get_global("pairs"))(redefinitions);
                            let __BREAK__FLAG__=false;
                            for(let __iter__152 in __elements__153) {
                                __array__155.push(await __for_body__154(__elements__153[__iter__152]));
                                if(__BREAK__FLAG__) {
                                     __array__155.pop();
                                    break;
                                    
                                }
                            }return __array__155;
                             
                        })()
                    }
                };
                if (check_true (need_sub_block)){
                    {
                        (acc).push("{");
                        sub_block_count+=1
                    }
                };
                idx=-1;
                await (async function(){
                     let __test_condition__160=async function() {
                        return (idx<((allocations && allocations.length)- 1))
                    };
                    let __body_ref__161=async function() {
                        idx+=1;
                        def_idx=null;
                        stmt=[];
                        alloc_set=await (async function(){
                            let __targ__162=allocations[idx];
                            if (__targ__162){
                                 return(__targ__162)["val"]
                            } 
                        })();
                        reference_name=await clean_quoted_reference(await sanitize_js_ref_name((alloc_set && alloc_set["0"] && alloc_set["0"]["name"])));
                        ctx_details=await get_declaration_details(ctx,reference_name);
                        assignment_value=(assignments[reference_name]).shift();
                        await async function(){
                            if (check_true (block_declarations[reference_name])) {
                                return true
                            } else {
                                {
                                    (stmt).push("let");
                                    (stmt).push(" ")
                                }
                            }
                        } ();
                        (stmt).push(reference_name);
                        await async function(){
                            block_declarations[reference_name]=true;
                            return block_declarations;
                            
                        }();
                        (stmt).push("=");
                        (stmt).push(assignment_value);
                        (stmt).push(";");
                        return (acc).push(stmt)
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__160()) {
                         await __body_ref__161();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                (acc).push(await compile_block(await conj(["PLACEHOLDER"],block),ctx,{
                    no_scope_boundary:true,suppress_return:suppress_return,ignore_declarations:declarations_handled
                }));
                await (async function() {
                    let __for_body__166=async function(i) {
                        return (acc).push("}")
                    };
                    let __array__167=[],__elements__165=await (await Environment.get_global("range"))(sub_block_count);
                    let __BREAK__FLAG__=false;
                    for(let __iter__164 in __elements__165) {
                        __array__167.push(await __for_body__166(__elements__165[__iter__164]));
                        if(__BREAK__FLAG__) {
                             __array__167.pop();
                            break;
                            
                        }
                    }return __array__167;
                     
                })();
                if (check_true (false)){
                    return acc
                } else {
                    {
                        (acc).unshift({
                            ctype:"letblock",block_step:(ctx && ctx["parent"] && ctx["parent"]["block_step"])
                        });
                        return acc
                    }
                }
            };
            in_sync_ques_=async function(ctx) {
                return await get_ctx(ctx,"__SYNCF__")
            };
            await_ques_=async function(ctx) {
                if (check_true (await in_sync_ques_(ctx))){
                    return ""
                } else {
                    return "await"
                }
            };
            calling_preamble=async function(ctx) {
                if (check_true (await in_sync_ques_(ctx))){
                    return ["","",{
                        ctype:"Function",block_step:0
                    },"(",")"]
                } else {
                    return ["await","async",{
                        ctype:"AsyncFunction",block_step:0
                    },"",""]
                }
            };
            fn_log=await (async function(){
                 return await defclog({
                    prefix:"compile_fn",background:"black",color:"lightblue"
                }) 
            })();
            completion_scope_id=0;
            set_new_completion_scope=async function(ctx) {
                let completion_scope;
                completion_scope={
                    id:completion_scope_id+=1,root_block_id:null,completion_records:[],is_top:false
                };
                await set_ctx(ctx,"__COMPLETION_SCOPE__",completion_scope);
                await set_ctx(ctx,"__COMP_INFIX_OPS__",null);
                return completion_scope
            };
            compile_fn=async function(tokens,ctx,fn_opts) {
                let acc;
                let idx;
                let arg;
                let fn_args;
                let body;
                let external_declarations;
                let type_mark;
                let completion_scope;
                let nbody;
                acc=[];
                idx=-1;
                arg=null;
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                fn_args=(tokens && tokens["1"] && tokens["1"]["val"]);
                body=(tokens && tokens["2"]);
                external_declarations=(tokens && tokens["3"]);
                type_mark=null;
                completion_scope=await set_new_completion_scope(ctx);
                nbody=null;
                if (check_true ((undefined==body))){
                    {
                        throw new SyntaxError("Invalid function call syntax");
                        
                    }
                };
                await async function(){
                    ctx["return_point"]=0;
                    return ctx;
                    
                }();
                await set_ctx(ctx,"__IN_LAMBDA__",true);
                await set_ctx(ctx,"__LAMBDA_STEP__",-1);
                await async function(){
                    ctx["lambda_scope"]=true;
                    return ctx;
                    
                }();
                await async function(){
                    ctx["suppress_return"]=false;
                    return ctx;
                    
                }();
                await async function(){
                    if (check_true ((fn_opts && fn_opts["synchronous"]))) {
                        {
                            type_mark=await type_marker("Function");
                            await set_ctx(ctx,"__SYNCF__",true);
                            await async function(){
                                completion_scope["in_sync"]=true;
                                return completion_scope;
                                
                            }();
                            return (acc).push(type_mark)
                        }
                    } else if (check_true ((fn_opts && fn_opts["arrow"]))) {
                        {
                            type_mark=await type_marker("Function");
                            (acc).push(type_mark)
                        }
                    } else if (check_true ((fn_opts && fn_opts["generator"]))) {
                        {
                            await set_ctx(ctx,"__SYNCF__",true);
                            type_mark=await type_marker("GeneratorFunction");
                            (acc).push(type_mark);
                            (acc).push(" ")
                        }
                    } else {
                        {
                            type_mark=await type_marker("AsyncFunction");
                            (acc).push(type_mark);
                            (acc).push("async");
                            (acc).push(" ")
                        }
                    }
                } ();
                await async function(){
                    type_mark["args"]=[];
                    return type_mark;
                    
                }();
                await async function(){
                    if (check_true ((fn_opts && fn_opts["arrow"]))) {
                        return await async function(){
                            completion_scope["scope_type"]="arrow";
                            return completion_scope;
                            
                        }()
                    } else if (check_true ((fn_opts && fn_opts["generator"]))) {
                        {
                            (acc).push("function*");
                            await async function(){
                                completion_scope["scope_type"]="generator";
                                return completion_scope;
                                
                            }()
                        }
                    } else {
                        {
                            await async function(){
                                completion_scope["scope_type"]="function";
                                return completion_scope;
                                
                            }();
                            (acc).push("function")
                        }
                    }
                } ();
                (acc).push("(");
                await (async function(){
                     let __test_condition__176=async function() {
                        return (idx<((fn_args && fn_args.length)- 1))
                    };
                    let __body_ref__177=async function() {
                        idx+=1;
                        arg=fn_args[idx];
                        if (check_true (((arg && arg.name)==="&"))){
                            {
                                idx+=1;
                                arg=fn_args[idx];
                                if (check_true ((null==arg))){
                                    {
                                        throw new SyntaxError("Missing argument symbol after &");
                                        
                                    }
                                };
                                await set_ctx(ctx,(arg && arg.name),ArgumentType);
                                await async function(){
                                    arg["name"]=("..."+ (arg && arg.name));
                                    return arg;
                                    
                                }()
                            }
                        } else {
                            {
                                await set_ctx(ctx,(arg && arg.name),ArgumentType)
                            }
                        };
                        (acc).push(await sanitize_js_ref_name((arg && arg.name)));
                        ((type_mark && type_mark["args"])).push(await sanitize_js_ref_name((arg && arg.name)));
                        if (check_true ((idx<((fn_args && fn_args.length)- 1)))){
                            {
                                return (acc).push(",")
                            }
                        }
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__176()) {
                         await __body_ref__177();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                (acc).push(")");
                (acc).push(" ");
                if (check_true ((fn_opts && fn_opts["arrow"]))){
                    {
                        (acc).push("=>")
                    }
                };
                if (check_true (((fn_opts && fn_opts["generator"])|| (fn_opts && fn_opts["arrow"])))){
                    await async function(){
                        ctx["return_last_value"]=false;
                        return ctx;
                        
                    }()
                } else {
                    await async function(){
                        ctx["return_last_value"]=true;
                        return ctx;
                        
                    }()
                };
                await async function(){
                    if (check_true (((body && body["val"] && body["val"]["0"] && body["val"]["0"]["name"])==="let"))) {
                        {
                            return (acc).push(await (async function(){
                                 return await compile((body && body["val"]),ctx) 
                            })())
                        }
                    } else if (check_true (await contains_ques_((body && body["val"] && body["val"]["0"] && body["val"]["0"]["name"]),["do","progn","progl"]))) {
                        {
                            (acc).push(await compile_block((body && body["val"]),ctx))
                        }
                    } else {
                        {
                            nbody=await (async function(){
                                 return [{
                                    type:"special",val:await (async function(){
                                         return "=:do" 
                                    })(),ref:true,name:"do"
                                },body] 
                            })();
                            await async function(){
                                ctx["return_last_value"]=true;
                                return ctx;
                                
                            }();
                            (acc).push({
                                mark:"nbody"
                            });
                            (acc).push(await compile_block(nbody,ctx))
                        }
                    }
                } ();
                await async function(){
                    if (check_true ((await not((fn_opts && fn_opts["arrow"]))&& await not((fn_opts && fn_opts["generator"]))&& ((completion_scope && completion_scope["completion_records"] && completion_scope["completion_records"]["length"])===0)))) {
                        {
                            await console.error("internal compile error: no completion records for callable");
                            await console.log("error provoking source: ",await source_from_tokens(tokens,expanded_tree,true));
                            await console.log("output: ",acc);
                            let internal_syntax_error=new SyntaxError("internal compile error: no completion records for callable");
                            ;
                            throw internal_syntax_error;
                            
                        }
                    } else {
                        true
                    }
                } ();
                return acc
            };
            compile_jslambda=async function(tokens,ctx) {
                let acc;
                let fn_args;
                let body;
                let idx;
                let quoted_body;
                let arg;
                let type_mark;
                acc=[];
                fn_args=(tokens && tokens["1"] && tokens["1"]["val"]);
                body=await (async function(){
                     return await compile((tokens && tokens["2"] && tokens["2"]["val"]),ctx) 
                })();
                idx=-1;
                quoted_body=[];
                arg=null;
                type_mark=await type_marker("Function");
                (acc).push(type_mark);
                await (async function() {
                    let __for_body__184=async function(t) {
                        return (acc).push(t)
                    };
                    let __array__185=[],__elements__183=["new"," ","Function","("];
                    let __BREAK__FLAG__=false;
                    for(let __iter__182 in __elements__183) {
                        __array__185.push(await __for_body__184(__elements__183[__iter__182]));
                        if(__BREAK__FLAG__) {
                             __array__185.pop();
                            break;
                            
                        }
                    }return __array__185;
                     
                })();
                if (check_true (await not((body instanceof String || typeof body==='string')))){
                    {
                        throw new SyntaxError(("Invalid jslambda body, need string, got: "+ await subtype(body)));
                        
                    }
                };
                await (async function(){
                     let __test_condition__186=async function() {
                        return (idx<((fn_args && fn_args.length)- 1))
                    };
                    let __body_ref__187=async function() {
                        idx+=1;
                        arg=fn_args[idx];
                        await set_ctx(ctx,(arg && arg.name),ArgumentType);
                        (acc).push(("\""+ (arg && arg.name)+ "\""));
                        ((type_mark && type_mark["args"])).push((arg && arg.name));
                        return (acc).push(",")
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__186()) {
                         await __body_ref__187();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                (acc).push("\"");
                await (async function() {
                    let __for_body__190=async function(c) {
                        if (check_true (await not((c==="\n"),(c==="\r")))){
                            {
                                if (check_true ((c==="\""))){
                                    {
                                        (quoted_body).push(await String.fromCharCode(92))
                                    }
                                };
                                return (quoted_body).push(c)
                            }
                        }
                    };
                    let __array__191=[],__elements__189=(body).split("");
                    let __BREAK__FLAG__=false;
                    for(let __iter__188 in __elements__189) {
                        __array__191.push(await __for_body__190(__elements__189[__iter__188]));
                        if(__BREAK__FLAG__) {
                             __array__191.pop();
                            break;
                            
                        }
                    }return __array__191;
                     
                })();
                (acc).push((await flatten(quoted_body)).join(""));
                (acc).push("\"");
                (acc).push(")");
                return acc
            };
            compile_yield=async function(tokens,ctx) {
                let acc;
                let expr;
                let cmp_rec;
                acc=[];
                expr=null;
                cmp_rec=await get_ctx(ctx,"__COMPLETION_SCOPE__");
                (acc).push(["yield"," ",await compile_wrapper_fn((tokens && tokens["1"]),ctx),";"]);
                ((cmp_rec && cmp_rec["completion_records"])).push({
                    block_id:(ctx && ctx["block_id"]),block_step:(ctx && ctx["block_step"]),type:"yield",stmt:await last(acc)
                });
                return acc
            };
            var_counter=0;
            gen_temp_name=async function(arg) {
                return ("__"+ (arg|| "")+ "__"+ (var_counter=var_counter+1))
            };
            if_id=0;
            compile_cond=async function(tokens,ctx) {
                let preamble;
                preamble=await calling_preamble(ctx);
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                ;
                await set_new_completion_scope(ctx);
                return [(preamble && preamble["2"]),(preamble && preamble["0"])," ",(preamble && preamble["1"])," ",(preamble && preamble["3"]),"function","()","{",await compile_cond_inner(tokens,ctx),"} ",(preamble && preamble["4"]),"()"]
            };
            compile_cond_inner=async function(tokens,ctx) {
                let acc;
                let conditions;
                let block_step;
                let condition_tokens;
                let idx;
                let preamble;
                let compile_condition;
                acc=[];
                conditions=[];
                block_step=(ctx && ctx["block_step"]);
                condition_tokens=await tokens["slice"].call(tokens,1);
                idx=-2;
                preamble=await calling_preamble(ctx);
                compile_condition=async function(cond_test,cond_block) {
                    let stmts;
                    let compiled_test;
                    let stmt;
                    stmts=[];
                    compiled_test=null;
                    stmt=null;
                    if (check_true (((cond_test && cond_test.name)==="else"))){
                        if (check_true ((idx>=2))){
                            (stmts).push(" else ")
                        }
                    } else {
                        {
                            if (check_true ((idx>=2))){
                                (stmts).push(" else ")
                            };
                            compiled_test=await compile_wrapper_fn(cond_test,ctx);
                            if (check_true (((await first(compiled_test) instanceof Object)&& await (async function(){
                                let __targ__192=await first(compiled_test);
                                if (__targ__192){
                                     return(__targ__192)["ctype"]
                                } 
                            })()&& (await (async function(){
                                let __targ__193=await first(compiled_test);
                                if (__targ__193){
                                     return(__targ__193)["ctype"]
                                } 
                            })() instanceof String || typeof await (async function(){
                                let __targ__193=await first(compiled_test);
                                if (__targ__193){
                                     return(__targ__193)["ctype"]
                                } 
                            })()==='string')&& await contains_ques_("unction",await (async function(){
                                let __targ__194=await first(compiled_test);
                                if (__targ__194){
                                     return(__targ__194)["ctype"]
                                } 
                            })())))){
                                (stmts).push(["if"," ","(check_true (",(preamble && preamble["0"])," ",compiled_test,"()",")) "])
                            } else {
                                (stmts).push(["if"," ","(check_true (",compiled_test,")) "])
                            }
                        }
                    };
                    stmt=await compile_block(await ensure_block(cond_block),ctx);
                    (stmts).push(stmt);
                    return stmts
                };
                ;
                if (check_true ((null==block_step))){
                    acc=await compile_block(await ensure_block(tokens),ctx)
                } else {
                    {
                        await async function(){
                            if (check_true (await not((((condition_tokens && condition_tokens.length)% 2)===0)))) {
                                throw new LispSyntaxError("cond: Invalid syntax: missing condition block");
                                
                            } else if (check_true (((condition_tokens && condition_tokens.length)===0))) {
                                throw new LispSyntaxError("cond: Invalid syntax: no conditions provided");
                                
                            }
                        } ();
                        await (async function(){
                             let __test_condition__195=async function() {
                                return (idx<((condition_tokens && condition_tokens.length)- 2))
                            };
                            let __body_ref__196=async function() {
                                idx+=2;
                                return (acc).push(await compile_condition(condition_tokens[idx],condition_tokens[(idx+ 1)]))
                            };
                            let __BREAK__FLAG__=false;
                            while(await __test_condition__195()) {
                                 await __body_ref__196();
                                 if(__BREAK__FLAG__) {
                                     break;
                                    
                                }
                            } ;
                            
                        })()
                    }
                };
                return acc
            };
            ensure_block=async function(tokens) {
                if (check_true (((tokens instanceof Array)&& ("special"===(tokens && tokens["0"] && tokens["0"]["type"]))&& await contains_ques_((tokens && tokens["0"] && tokens["0"]["name"]),["do","progn"])))){
                    return tokens
                } else {
                    return ["PLACEHOLDER",tokens]
                }
            };
            compile_if=async function(tokens,ctx) {
                let acc;
                let subacc;
                let stmts;
                let test_form;
                let if_true;
                let if_false;
                let compiled_test;
                let compiled_true;
                let compiled_false;
                let block_step;
                let preamble;
                acc=[];
                subacc=[];
                stmts=null;
                test_form=(tokens && tokens["1"]);
                if_true=(tokens && tokens["2"]);
                if_false=(tokens && tokens["3"]);
                compiled_test=null;
                compiled_true=null;
                compiled_false=null;
                block_step=(ctx && ctx["block_step"]);
                preamble=await calling_preamble(ctx);
                ;
                if (check_true ((null==block_step))){
                    acc=await compile_block(await ensure_block(tokens),ctx)
                } else {
                    {
                        (acc).push({
                            ctype:"ifblock",block_step:(ctx && ctx["block_step"]),block_id:(ctx && ctx["block_id"])
                        });
                        compiled_test=await (async function(){
                             return await compile(test_form,ctx) 
                        })();
                        if (check_true (((await first(compiled_test) instanceof Object)&& await (async function(){
                            let __targ__197=await first(compiled_test);
                            if (__targ__197){
                                 return(__targ__197)["ctype"]
                            } 
                        })()&& (await (async function(){
                            let __targ__198=await first(compiled_test);
                            if (__targ__198){
                                 return(__targ__198)["ctype"]
                            } 
                        })() instanceof String || typeof await (async function(){
                            let __targ__198=await first(compiled_test);
                            if (__targ__198){
                                 return(__targ__198)["ctype"]
                            } 
                        })()==='string')&& await contains_ques_("unction",await (async function(){
                            let __targ__199=await first(compiled_test);
                            if (__targ__199){
                                 return(__targ__199)["ctype"]
                            } 
                        })())))){
                            await (async function() {
                                let __for_body__202=async function(t) {
                                    return (subacc).push(t)
                                };
                                let __array__203=[],__elements__201=["if"," ","(check_true (",(preamble && preamble["0"])," ",compiled_test,"()","))"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__200 in __elements__201) {
                                    __array__203.push(await __for_body__202(__elements__201[__iter__200]));
                                    if(__BREAK__FLAG__) {
                                         __array__203.pop();
                                        break;
                                        
                                    }
                                }return __array__203;
                                 
                            })()
                        } else {
                            await (async function() {
                                let __for_body__206=async function(t) {
                                    return (subacc).push(t)
                                };
                                let __array__207=[],__elements__205=["if"," ","(check_true (",compiled_test,"))"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__204 in __elements__205) {
                                    __array__207.push(await __for_body__206(__elements__205[__iter__204]));
                                    if(__BREAK__FLAG__) {
                                         __array__207.pop();
                                        break;
                                        
                                    }
                                }return __array__207;
                                 
                            })()
                        };
                        (acc).push(subacc);
                        subacc=[];
                        compiled_true=await compile_block(await ensure_block(if_true),ctx);
                        (acc).push(compiled_true);
                        if (check_true (if_false)){
                            {
                                (acc).push(" ");
                                (acc).push("else");
                                (acc).push(" ");
                                compiled_false=await compile_block(await ensure_block(if_false),ctx);
                                (acc).push(compiled_false)
                            }
                        }
                    }
                };
                return acc
            };
            compile_as_call=async function(tokens,ctx) {
                return await compile_wrapper_fn(tokens,ctx,{
                    force:true
                })
            };
            compile_wrapper_fn=async function(tokens,ctx,opts) {
                let acc;
                let preamble;
                let needs_await;
                acc=[];
                ctx=ctx;
                preamble=await calling_preamble(ctx);
                needs_await=true;
                ;
                await async function(){
                    if (check_true (((tokens instanceof Object)&& await not((tokens instanceof Array))&& await not(((tokens && tokens["type"])==="arr"))))) {
                        {
                            needs_await=false;
                            return acc=await (async function(){
                                 return await compile(tokens,ctx) 
                            })()
                        }
                    } else if (check_true (((tokens instanceof Object)&& ((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["type"])==="fun")))) {
                        {
                            needs_await=false;
                            acc=await (async function(){
                                 return await compile(tokens,ctx) 
                            })()
                        }
                    } else if (check_true ((opts && opts["force"]))) {
                        {
                            ctx=await (async function(){
                                 return await new_ctx(ctx) 
                            })();
                            await set_new_completion_scope(ctx);
                            acc=await compile_block_to_anon_fn(tokens,ctx,opts)
                        }
                    } else if (check_true (await is_block_ques_(tokens))) {
                        {
                            ctx=await (async function(){
                                 return await new_ctx(ctx) 
                            })();
                            await set_new_completion_scope(ctx);
                            await async function(){
                                ctx["block_step"]=0;
                                return ctx;
                                
                            }();
                            acc=await (async function(){
                                let __array_op_rval__209=(preamble && preamble["2"]);
                                 if (__array_op_rval__209 instanceof Function){
                                    return await __array_op_rval__209("(",(preamble && preamble["1"])," ","function","()","{",await (async function(){
                                         return await compile(tokens,ctx) 
                                    })(),"}",")","()") 
                                } else {
                                    return [__array_op_rval__209,"(",(preamble && preamble["1"])," ","function","()","{",await (async function(){
                                         return await compile(tokens,ctx) 
                                    })(),"}",")","()"]
                                }
                            })()
                        }
                    } else if (check_true (((tokens instanceof Object)&& ((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["type"])==="special")&& (((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["name"])==="if")|| (((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["name"])==="throw")&& await get_ctx(ctx,"__COMP_INFIX_OPS__")))))) {
                        {
                            ctx=await (async function(){
                                 return await new_ctx(ctx) 
                            })();
                            await set_new_completion_scope(ctx);
                            await async function(){
                                ctx["block_step"]=0;
                                return ctx;
                                
                            }();
                            await (async function() {
                                let __for_body__213=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__214=[],__elements__212=await (async function(){
                                    let __array_op_rval__215=(preamble && preamble["2"]);
                                     if (__array_op_rval__215 instanceof Function){
                                        return await __array_op_rval__215("(",(preamble && preamble["1"])," ","function","()","{",await compile_if((tokens && tokens["val"]),ctx),"}",")","()") 
                                    } else {
                                        return [__array_op_rval__215,"(",(preamble && preamble["1"])," ","function","()","{",await compile_if((tokens && tokens["val"]),ctx),"}",")","()"]
                                    }
                                })();
                                let __BREAK__FLAG__=false;
                                for(let __iter__211 in __elements__212) {
                                    __array__214.push(await __for_body__213(__elements__212[__iter__211]));
                                    if(__BREAK__FLAG__) {
                                         __array__214.pop();
                                        break;
                                        
                                    }
                                }return __array__214;
                                 
                            })()
                        }
                    } else if (check_true (((tokens instanceof Array)&& (((tokens && tokens["0"] && tokens["0"]["type"])==="fun")|| ((tokens && tokens["0"] && tokens["0"]["type"])==="asf")|| ((tokens && tokens["0"] && tokens["0"]["type"])==="function"))))) {
                        {
                            needs_await=false;
                            acc=await (async function(){
                                 return await compile(tokens,ctx) 
                            })()
                        }
                    } else if (check_true ((tokens instanceof Array))) {
                        {
                            ctx=await (async function(){
                                 return await new_ctx(ctx) 
                            })();
                            await set_new_completion_scope(ctx);
                            acc=await compile_block_to_anon_fn(tokens,ctx,opts)
                        }
                    } else if (check_true (((tokens instanceof Object)&& ((tokens && tokens["type"])==="arr")&& (((tokens && tokens["val"] && tokens["val"]["length"])===0)|| ((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["type"])==="literal")|| (((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["type"])==="arg")|| (((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["type"])==="special")&& await not(await contains_ques_((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["name"]),["if","try","do","progn","let","cond"])))))))) {
                        {
                            needs_await=false;
                            acc=await (async function(){
                                 return await compile(tokens,ctx) 
                            })()
                        }
                    } else if (check_true (((tokens instanceof Object)&& (tokens && tokens["val"])&& ((tokens && tokens["type"])==="arr")))) {
                        {
                            ctx=await (async function(){
                                 return await new_ctx(ctx) 
                            })();
                            await set_new_completion_scope(ctx);
                            acc=await compile_block_to_anon_fn((tokens && tokens["val"]),ctx,opts)
                        }
                    } else {
                        acc=await (async function(){
                             return await compile(tokens,ctx) 
                        })()
                    }
                } ();
                if (check_true (needs_await)){
                    return [(preamble && preamble["0"])," ",acc]
                } else {
                    return acc
                }
            };
            compile_block_to_anon_fn=async function(tokens,ctx,opts) {
                let acc;
                let preamble;
                acc=[];
                preamble=await calling_preamble(ctx);
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                await async function(){
                    ctx["return_point"]=0;
                    return ctx;
                    
                }();
                await async function(){
                    ctx["block_step"]=0;
                    return ctx;
                    
                }();
                await async function(){
                    if (check_true (await is_block_ques_(tokens))) {
                        {
                            await async function(){
                                ctx["return_last_value"]=true;
                                return ctx;
                                
                            }();
                            await async function(){
                                ctx["return_point"]=0;
                                return ctx;
                                
                            }();
                            return await (async function() {
                                let __for_body__222=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__223=[],__elements__221=["(",(preamble && preamble["1"])," ","function","()",await compile_block(tokens,ctx),")","()"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__220 in __elements__221) {
                                    __array__223.push(await __for_body__222(__elements__221[__iter__220]));
                                    if(__BREAK__FLAG__) {
                                         __array__223.pop();
                                        break;
                                        
                                    }
                                }return __array__223;
                                 
                            })()
                        }
                    } else if (check_true ((((tokens && tokens["0"] && tokens["0"]["name"])==="let")&& ((tokens && tokens["0"] && tokens["0"]["type"])==="special")))) {
                        {
                            await async function(){
                                ctx["return_last_value"]=true;
                                return ctx;
                                
                            }();
                            await async function(){
                                ctx["return_point"]=0;
                                return ctx;
                                
                            }();
                            await (async function() {
                                let __for_body__228=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__229=[],__elements__227=["(",(preamble && preamble["1"])," ","function","()",await (async function(){
                                     return await compile(tokens,ctx) 
                                })(),")","()"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__226 in __elements__227) {
                                    __array__229.push(await __for_body__228(__elements__227[__iter__226]));
                                    if(__BREAK__FLAG__) {
                                         __array__229.pop();
                                        break;
                                        
                                    }
                                }return __array__229;
                                 
                            })()
                        }
                    } else if (check_true ((((tokens && tokens["0"] && tokens["0"]["type"])==="special")&& (((tokens && tokens["0"] && tokens["0"]["name"])==="if")|| ((tokens && tokens["0"] && tokens["0"]["name"])==="try"))))) {
                        {
                            await (async function() {
                                let __for_body__232=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__233=[],__elements__231=["(",(preamble && preamble["1"])," ","function","() { ",await (async function(){
                                     return await compile(tokens,ctx) 
                                })(),"})","()"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__230 in __elements__231) {
                                    __array__233.push(await __for_body__232(__elements__231[__iter__230]));
                                    if(__BREAK__FLAG__) {
                                         __array__233.pop();
                                        break;
                                        
                                    }
                                }return __array__233;
                                 
                            })()
                        }
                    } else {
                        {
                            await async function(){
                                ctx["return_last_value"]=true;
                                return ctx;
                                
                            }();
                            await async function(){
                                ctx["return_point"]=0;
                                return ctx;
                                
                            }();
                            await (async function() {
                                let __for_body__238=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__239=[],__elements__237=["(",(preamble && preamble["1"])," ","function","()","{"," ","return"," ",await (async function(){
                                     return await compile(tokens,ctx) 
                                })()," ","}",")","()"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__236 in __elements__237) {
                                    __array__239.push(await __for_body__238(__elements__237[__iter__236]));
                                    if(__BREAK__FLAG__) {
                                         __array__239.pop();
                                        break;
                                        
                                    }
                                }return __array__239;
                                 
                            })()
                        }
                    }
                } ();
                return acc
            };
            make_do_block=async function(tokens) {
                let preamble;
                let place;
                preamble=await (async function(){
                     return await clone({
                        type:"arr",ref:false,name:null,val:[]
                    }) 
                })();
                place=(preamble && preamble["val"]);
                (place).push({
                    type:"special",val:await (async function(){
                         return "=:do" 
                    })(),ref:true,name:"do"
                });
                await async function(){
                    if (check_true ((tokens instanceof Array))) {
                        return await (async function() {
                            let __for_body__242=async function(token) {
                                return (place).push(token)
                            };
                            let __array__243=[],__elements__241=tokens;
                            let __BREAK__FLAG__=false;
                            for(let __iter__240 in __elements__241) {
                                __array__243.push(await __for_body__242(__elements__241[__iter__240]));
                                if(__BREAK__FLAG__) {
                                     __array__243.pop();
                                    break;
                                    
                                }
                            }return __array__243;
                             
                        })()
                    } else {
                        await (async function() {
                            let __for_body__246=async function(token) {
                                return (place).push(token)
                            };
                            let __array__247=[],__elements__245=await (async function(){
                                let __array_op_rval__248=tokens;
                                 if (__array_op_rval__248 instanceof Function){
                                    return await __array_op_rval__248() 
                                } else {
                                    return [__array_op_rval__248]
                                }
                            })();
                            let __BREAK__FLAG__=false;
                            for(let __iter__244 in __elements__245) {
                                __array__247.push(await __for_body__246(__elements__245[__iter__244]));
                                if(__BREAK__FLAG__) {
                                     __array__247.pop();
                                    break;
                                    
                                }
                            }return __array__247;
                             
                        })()
                    }
                } ();
                return preamble
            };
            push_as_arg_list=async function(place,args) {
                await map(async function(v,i,t) {
                    (place).push(v);
                    if (check_true ((i<=(t- 2)))){
                        {
                            return (place).push(",")
                        }
                    }
                },args);
                return place
            };
            compile_new=async function(tokens,ctx) {
                let acc;
                let prebuild;
                let target_type;
                let comps;
                let type_details;
                let root_type_details;
                let target_return_type;
                let new_arg_name;
                let args;
                let preamble;
                let new_opts;
                acc=[];
                prebuild=[];
                target_type=await clean_quoted_reference(await sanitize_js_ref_name((tokens && tokens["1"] && tokens["1"]["name"])));
                comps=await (await Environment.get_global("get_object_path"))(target_type);
                type_details=await get_declaration_details(ctx,target_type);
                root_type_details=await (async function(){
                    if (check_true (((comps && comps.length)>1))){
                        return await get_declaration_details(ctx,(comps && comps["0"]))
                    } else {
                        return null
                    }
                })();
                target_return_type=null;
                new_arg_name=null;
                args=[];
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                preamble=await calling_preamble(ctx);
                new_opts=await tokens["slice"].call(tokens,2);
                if (check_true (((comps && comps.length)>1))){
                    {
                        target_type=await (async function(){
                             return await (await Environment.get_global("path_to_js_syntax"))(comps) 
                        })()
                    }
                };
                await (async function() {
                    let __for_body__251=async function(opt_token) {
                        return (args).push(await compile_wrapper_fn(opt_token,ctx))
                    };
                    let __array__252=[],__elements__250=(new_opts|| []);
                    let __BREAK__FLAG__=false;
                    for(let __iter__249 in __elements__250) {
                        __array__252.push(await __for_body__251(__elements__250[__iter__249]));
                        if(__BREAK__FLAG__) {
                             __array__252.pop();
                            break;
                            
                        }
                    }return __array__252;
                     
                })();
                await async function(){
                    if (check_true ((await not((null==(type_details && type_details["value"])))&& (type_details && type_details["declared_global"])))) {
                        {
                            await (async function() {
                                let __for_body__255=async function(arg) {
                                    return (acc).push(arg)
                                };
                                let __array__256=[],__elements__254=["new"," ",await (async function(){
                                     return await compile((tokens && tokens["1"]),ctx) 
                                })(),"("];
                                let __BREAK__FLAG__=false;
                                for(let __iter__253 in __elements__254) {
                                    __array__256.push(await __for_body__255(__elements__254[__iter__253]));
                                    if(__BREAK__FLAG__) {
                                         __array__256.pop();
                                        break;
                                        
                                    }
                                }return __array__256;
                                 
                            })();
                            await push_as_arg_list(acc,args);
                            return (acc).push(")")
                        }
                    } else if (check_true ((await not((null==(type_details && type_details["value"])))&& (type_details && type_details["value"]) instanceof Function))) {
                        {
                            await (async function() {
                                let __for_body__259=async function(arg) {
                                    return (acc).push(arg)
                                };
                                let __array__260=[],__elements__258=["new"," ",target_type,"("];
                                let __BREAK__FLAG__=false;
                                for(let __iter__257 in __elements__258) {
                                    __array__260.push(await __for_body__259(__elements__258[__iter__257]));
                                    if(__BREAK__FLAG__) {
                                         __array__260.pop();
                                        break;
                                        
                                    }
                                }return __array__260;
                                 
                            })();
                            await push_as_arg_list(acc,args);
                            (acc).push(")")
                        }
                    } else if (check_true (((null==(type_details && type_details["value"]))&& await not((null==(root_type_details && root_type_details["value"])))))) {
                        {
                            await (async function() {
                                let __for_body__263=async function(arg) {
                                    return (acc).push(arg)
                                };
                                let __array__264=[],__elements__262=["(",(preamble && preamble["0"])," ",env_ref,"get_global","(","\"","indirect_new","\"",")",")","(",target_type];
                                let __BREAK__FLAG__=false;
                                for(let __iter__261 in __elements__262) {
                                    __array__264.push(await __for_body__263(__elements__262[__iter__261]));
                                    if(__BREAK__FLAG__) {
                                         __array__264.pop();
                                        break;
                                        
                                    }
                                }return __array__264;
                                 
                            })();
                            if (check_true (((args && args.length)>0))){
                                {
                                    (acc).push(",");
                                    await push_as_arg_list(acc,args)
                                }
                            };
                            (acc).push(")")
                        }
                    } else {
                        {
                            await (async function() {
                                let __for_body__267=async function(arg) {
                                    return (acc).push(arg)
                                };
                                let __array__268=[],__elements__266=["new"," ",(tokens && tokens["1"] && tokens["1"]["name"]),"("];
                                let __BREAK__FLAG__=false;
                                for(let __iter__265 in __elements__266) {
                                    __array__268.push(await __for_body__267(__elements__266[__iter__265]));
                                    if(__BREAK__FLAG__) {
                                         __array__268.pop();
                                        break;
                                        
                                    }
                                }return __array__268;
                                 
                            })();
                            await push_as_arg_list(acc,args);
                            (acc).push(")")
                        }
                    }
                } ();
                target_return_type=(await get_ctx_val(ctx,target_type)|| await (async function(){
                    let __targ__269=(await get_declarations(ctx,target_type)|| new Object());
                    if (__targ__269){
                         return(__targ__269)["type"]
                    } 
                })()|| await (await Environment.get_global("get_outside_global"))(target_type)|| UnknownType);
                await async function(){
                    if (check_true (await get_declarations(ctx,target_type))) {
                        return (acc).unshift({
                            ctype:await get_declarations(ctx,target_type)
                        })
                    } else if (check_true ((((tokens && tokens["1"] && tokens["1"]["name"])==="Function")|| ((tokens && tokens["1"] && tokens["1"]["name"])==="AsyncFunction")))) {
                        (acc).unshift({
                            ctype:target_return_type
                        })
                    } else if (check_true (false)) {
                        (acc).unshift({
                            ctype:UnknownType
                        })
                    }
                } ();
                return acc
            };
            compile_val_mod=async function(tokens,ctx) {
                let target;
                let sanitized;
                let target_details;
                let comps;
                let in_infix;
                let operation;
                let mod_source;
                let how_much;
                target=((tokens && tokens["1"] && tokens["1"]["name"])|| await (async function(){
                    throw new SyntaxError(await add((tokens && tokens["0"] && tokens["0"]["name"])," requires at least one argument indicating the symbol which value is to be modified"));
                    
                })());
                sanitized=await (async function(){
                    if (check_true (((tokens && tokens["1"] && tokens["1"]["ref"])&& (tokens && tokens["1"] && tokens["1"]["name"])))){
                        return await sanitize_js_ref_name((tokens && tokens["1"] && tokens["1"]["name"]))
                    } else {
                        return await add((tokens && tokens["0"] && tokens["0"]["name"])," requires at least one argument indicating the symbol which value is to be modified")
                    }
                })();
                target_details=await (async function(){
                     return await async function(){
                        if (check_true (await get_ctx(ctx,sanitized))) {
                            return "local"
                        } else if (check_true (await get_lisp_ctx(ctx,(tokens && tokens["1"] && tokens["1"]["name"])))) {
                            return "global"
                        } else {
                            {
                                {
                                    let it;
                                    it=await get_declaration_details(ctx,(tokens && tokens["1"] && tokens["1"]["name"]));
                                    if (check_true (it)){
                                        return await async function(){
                                            if (check_true ((it && it["is_argument"]))) {
                                                return "local"
                                            } else if (check_true ((it && it["declared_global"]))) {
                                                return "global"
                                            } else if (check_true (it)) {
                                                return "local"
                                            }
                                        } ()
                                    } else {
                                        return 
                                    }
                                }
                            }
                        }
                    } () 
                })();
                comps=(target).split(".");
                in_infix=await get_ctx_val(ctx,"__COMP_INFIX_OPS__");
                operation=await (async function(){
                    if (check_true (in_infix)){
                        return await async function(){
                            if (check_true (((tokens && tokens["0"] && tokens["0"]["name"])==="inc"))) {
                                return "+"
                            } else if (check_true (((tokens && tokens["0"] && tokens["0"]["name"])==="dec"))) {
                                return "-"
                            } else {
                                throw new SyntaxError(("Invalid value modification operator: "+ (tokens && tokens["0"] && tokens["0"]["name"])));
                                
                            }
                        } ()
                    } else {
                        return await async function(){
                            if (check_true (((target_details==="local")&& ((tokens && tokens["0"] && tokens["0"]["name"])==="inc")))) {
                                return "+="
                            } else if (check_true (((target_details==="local")&& ((tokens && tokens["0"] && tokens["0"]["name"])==="dec")))) {
                                return "-="
                            } else if (check_true (((tokens && tokens["0"] && tokens["0"]["name"])==="inc"))) {
                                return "+"
                            } else {
                                return "-"
                            }
                        } ()
                    }
                })();
                mod_source=null;
                how_much=(((tokens && tokens["2"])&& await compile_wrapper_fn((tokens && tokens["2"]),ctx))|| 1);
                if (check_true ((undefined===target_details))){
                    throw new ReferenceError(("unknown symbol: "+ (comps && comps["0"])));
                    
                };
                return await async function(){
                    if (check_true ((target_details==="global"))) {
                        {
                            has_lisp_globals=true;
                            return ["(","await"," ",env_ref,"set_global(\"",target,"\",","await"," ",env_ref,"get_global(\"",target,"\")"," ",operation," ",how_much,"))"]
                        }
                    } else if (check_true (in_infix)) {
                        {
                            return ["(",target,"=",target,operation,how_much,")"]
                        }
                    } else {
                        return await (async function(){
                            let __array_op_rval__270=sanitized;
                             if (__array_op_rval__270 instanceof Function){
                                return await __array_op_rval__270(operation,how_much) 
                            } else {
                                return [__array_op_rval__270,operation,how_much]
                            }
                        })()
                    }
                } ()
            };
            compile_try=async function(tokens,ctx) {
                if (check_true ((null==(ctx && ctx["block_step"])))){
                    return await compile_block(await ensure_block(tokens),ctx)
                } else {
                    return await compile_try_inner(tokens,ctx)
                }
            };
            compile_try_inner=async function(tokens,ctx) {
                let acc;
                let try_block;
                let compiled_try_block;
                let catch_block;
                let idx;
                let exception_ref;
                let base_error_caught;
                let catch_stmts;
                let catches;
                let compile_catch;
                acc=[];
                try_block=await (async function(){
                     return await async function(){
                        if (check_true (((tokens && tokens["1"])&& (null==(tokens && tokens["1"] && tokens["1"]["val"]))))) {
                            return (tokens && tokens["1"])
                        } else if (check_true (((tokens && tokens["1"] && tokens["1"]["type"])==="objlit"))) {
                            return (tokens && tokens["1"])
                        } else if (check_true ((tokens && tokens["1"]))) {
                            return (tokens && tokens["1"] && tokens["1"]["val"])
                        }
                    } () 
                })();
                compiled_try_block=null;
                catch_block=null;
                idx=-1;
                exception_ref=await gen_temp_name("exception");
                base_error_caught=false;
                catch_stmts=[];
                catches=await tokens["slice"].call(tokens,2);
                compile_catch=async function(catch_block) {
                    let throwable_type;
                    let throwable_ref;
                    let catch_statements;
                    let stmts;
                    let subacc;
                    throwable_type=(catch_block && catch_block["1"] && catch_block["1"]["name"]);
                    throwable_ref=(catch_block && catch_block["2"] && catch_block["2"]["val"] && catch_block["2"]["val"]["0"] && catch_block["2"]["val"]["0"]["name"]);
                    catch_statements=(catch_block && catch_block["3"]);
                    stmts=null;
                    subacc=[];
                    ctx=await (async function(){
                         return await new_ctx(ctx) 
                    })();
                    await set_ctx(ctx,throwable_ref,(await Environment.get_global("indirect_new"))(catch_block['1'].name));
                    if (check_true ((throwable_type==="Error"))){
                        {
                            base_error_caught=true
                        }
                    };
                    stmts=await compile_block(await ensure_block(catch_statements),ctx);
                    if (check_true ((idx>0))){
                        (subacc).push([" ","else"," "])
                    };
                    (subacc).push(["if (",exception_ref," instanceof ",throwable_type,") ","{","let ",throwable_ref,"=",exception_ref,";",stmts,"}"]);
                    if (check_true (((idx===((catches && catches.length)- 1))&& await not(base_error_caught)))){
                        {
                            (subacc).push([" ","else"," "]);
                            (subacc).push(await (async function(){
                                 return [{
                                    completion:"throw"
                                },"throw"," ",exception_ref,";"] 
                            })())
                        }
                    };
                    return subacc
                };
                await async function(){
                    if (check_true (((tokens && tokens.length)<2))) {
                        throw new SyntaxError("invalid try form: missing try block");
                        
                    } else if (check_true (((null==catches)|| ((catches && catches.length)<1)))) {
                        throw new SyntaxError("invalid catch block: missing catch");
                        
                    }
                } ();
                compiled_try_block=await compile_block(await ensure_block(try_block),ctx);
                (acc).push({
                    ctype:"tryblock"
                });
                (acc).push(["try"," ",compiled_try_block]);
                (catch_stmts).push([" ","catch"," ","(",exception_ref,")"," "]);
                (catch_stmts).push("{");
                await (async function(){
                     let __test_condition__271=async function() {
                        return (idx<((catches && catches.length)- 1))
                    };
                    let __body_ref__272=async function() {
                        idx+=1;
                        catch_block=await (async function(){
                            let __targ__273=catches[idx];
                            if (__targ__273){
                                 return(__targ__273)["val"]
                            } 
                        })();
                        if (check_true ((catch_block instanceof Array))){
                            return (catch_stmts).push(await compile_catch(catch_block))
                        } else {
                            throw new SyntaxError("invalid catch form");
                            
                        }
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__271()) {
                         await __body_ref__272();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                (catch_stmts).push("}");
                (acc).push(catch_stmts);
                return acc
            };
            compile_throw=async function(tokens,ctx) {
                let acc;
                let error_message;
                let mode;
                let cmp_rec;
                let error_instance;
                acc=[];
                error_message=null;
                mode=1;
                cmp_rec=await get_ctx(ctx,"__COMPLETION_SCOPE__");
                error_instance=null;
                await (await Environment.get_global("assert"))(cmp_rec,"compiler error: throw unable to find completion scope in context");
                await async function(){
                    if (check_true (((tokens instanceof Array)&& ((tokens && tokens.length)===2)&& (tokens && tokens["1"] && tokens["1"]["ref"])))) {
                        {
                            mode=0;
                            return error_instance=await (async function(){
                                 return await compile((tokens && tokens["1"]),ctx) 
                            })()
                        }
                    } else if (check_true (((tokens instanceof Array)&& ((tokens && tokens.length)===3)))) {
                        {
                            error_instance=await (async function(){
                                 return await compile((tokens && tokens["1"]),ctx) 
                            })();
                            error_message=await (async function(){
                                 return await compile((tokens && tokens["2"]),ctx) 
                            })()
                        }
                    } else if (check_true (((tokens instanceof Array)&& ((tokens && tokens.length)===2)))) {
                        {
                            error_message=await (async function(){
                                 return await compile((tokens && tokens["1"]),ctx) 
                            })();
                            error_instance="Error"
                        }
                    } else {
                        throw new SyntaxError("Invalid Throw Syntax");
                        
                    }
                } ();
                if (check_true ((mode===0))){
                    await (async function() {
                        let __for_body__276=async function(t) {
                            return (acc).push(t)
                        };
                        let __array__277=[],__elements__275=await (async function(){
                             return [{
                                completion:"throw"
                            },"throw"," ",error_instance,";"] 
                        })();
                        let __BREAK__FLAG__=false;
                        for(let __iter__274 in __elements__275) {
                            __array__277.push(await __for_body__276(__elements__275[__iter__274]));
                            if(__BREAK__FLAG__) {
                                 __array__277.pop();
                                break;
                                
                            }
                        }return __array__277;
                         
                    })()
                } else {
                    await (async function() {
                        let __for_body__280=async function(t) {
                            return (acc).push(t)
                        };
                        let __array__281=[],__elements__279=await (async function(){
                             return [{
                                completion:"throw"
                            },"throw"," ","new"," ",error_instance,"(",error_message,")",";"] 
                        })();
                        let __BREAK__FLAG__=false;
                        for(let __iter__278 in __elements__279) {
                            __array__281.push(await __for_body__280(__elements__279[__iter__278]));
                            if(__BREAK__FLAG__) {
                                 __array__281.pop();
                                break;
                                
                            }
                        }return __array__281;
                         
                    })()
                };
                ((cmp_rec && cmp_rec["completion_records"])).push({
                    block_id:(ctx && ctx["block_id"]),type:"throw",block_step:(ctx && ctx["block_step"]),stmt:acc
                });
                return acc
            };
            compile_break=async function(tokens,ctx) {
                return await (async function(){
                    let __array_op_rval__282=break_out;
                     if (__array_op_rval__282 instanceof Function){
                        return await __array_op_rval__282("=","true",";","return") 
                    } else {
                        return [__array_op_rval__282,"=","true",";","return"]
                    }
                })()
            };
            compile_return=async function(tokens,ctx) {
                let acc;
                let return_val_reference;
                let return_value;
                let cmp_rec;
                acc=[];
                return_val_reference=await gen_temp_name("return");
                return_value=null;
                cmp_rec=await get_ctx(ctx,"__COMPLETION_SCOPE__");
                await (await Environment.get_global("assert"))(cmp_rec,"compiler error: compile_return: no completion scope record found");
                if (check_true (await is_block_ques_((tokens && tokens["1"] && tokens["1"]["val"])))){
                    {
                        (acc).push(["let"," ",return_val_reference,"=",await (async function(){
                             return await compile((tokens && tokens["1"] && tokens["1"]["val"]),ctx) 
                        })(),";"]);
                        (acc).push(await (async function(){
                             return [{
                                completion:"return"
                            },"return"," ",return_val_reference,";"] 
                        })())
                    }
                } else {
                    {
                        await (async function() {
                            let __for_body__285=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__286=[],__elements__284=["return"," ",await (async function(){
                                 return await compile((tokens && tokens["1"]),ctx) 
                            })(),";"];
                            let __BREAK__FLAG__=false;
                            for(let __iter__283 in __elements__284) {
                                __array__286.push(await __for_body__285(__elements__284[__iter__283]));
                                if(__BREAK__FLAG__) {
                                     __array__286.pop();
                                    break;
                                    
                                }
                            }return __array__286;
                             
                        })()
                    }
                };
                ((cmp_rec && cmp_rec["completion_records"])).push({
                    block_id:(ctx && ctx["block_id"]),block_step:(ctx && ctx["block_step"]),type:"return",stmt:await last(acc)
                });
                return acc
            };
            apply_log=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    return log
                } else {
                    return await defclog({
                        prefix:"compile_apply",background:"sienna",color:"white"
                    })
                }
            })();
            compile_apply=async function(tokens,ctx) {
                let acc;
                let fn_ref;
                let complex_ques_;
                let args_ref;
                let function_ref;
                let target_argument_ref;
                let target_arg;
                let ctype;
                let preceding_arg_ref;
                let preamble;
                let requires_await;
                let compiled_fun_resolver;
                let args;
                acc=[];
                fn_ref=(tokens && tokens["1"]);
                complex_ques_=false;
                args_ref=await gen_temp_name("apply_args");
                function_ref=await gen_temp_name("apply_fn");
                target_argument_ref=null;
                target_arg=null;
                ctype=null;
                preceding_arg_ref=null;
                preamble=await calling_preamble(ctx);
                requires_await=false;
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                compiled_fun_resolver=null;
                args=await tokens["slice"].call(tokens,2);
                ;
                await set_new_completion_scope(ctx);
                if (check_true ((args&& ((args && args.length)===1)))){
                    {
                        args=await first(args)
                    }
                };
                function_ref=await compile_wrapper_fn(fn_ref,ctx);
                if (check_true ((fn_ref && fn_ref["ref"]))){
                    {
                        ctype=await get_declaration_details(ctx,(fn_ref && fn_ref["name"]))
                    }
                };
                if (check_true ((ctype && ctype["value"]) instanceof Function)){
                    {
                        requires_await=true
                    }
                };
                if (check_true ((args instanceof Array))){
                    {
                        target_argument_ref=await gen_temp_name("target_arg");
                        target_arg=(args).pop();
                        await (async function() {
                            let __for_body__289=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__290=[],__elements__288=["let"," ",target_argument_ref,"=","[]",".concat","(",await (async function(){
                                 return await compile(target_arg,ctx) 
                            })(),")",";"];
                            let __BREAK__FLAG__=false;
                            for(let __iter__287 in __elements__288) {
                                __array__290.push(await __for_body__289(__elements__288[__iter__287]));
                                if(__BREAK__FLAG__) {
                                     __array__290.pop();
                                    break;
                                    
                                }
                            }return __array__290;
                             
                        })();
                        await (async function() {
                            let __for_body__293=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__294=[],__elements__292=["if","(","!",target_argument_ref," ","instanceof"," ","Array",")","{","throw"," ","new"," ","TypeError","(","\"Invalid final argument to apply - an array is required\"",")","}"];
                            let __BREAK__FLAG__=false;
                            for(let __iter__291 in __elements__292) {
                                __array__294.push(await __for_body__293(__elements__292[__iter__291]));
                                if(__BREAK__FLAG__) {
                                     __array__294.pop();
                                    break;
                                    
                                }
                            }return __array__294;
                             
                        })();
                        await (async function() {
                            let __for_body__297=async function(token) {
                                preceding_arg_ref=await gen_temp_name("pre_arg");
                                if (check_true (await is_form_ques_(token))){
                                    {
                                        await (async function() {
                                            let __for_body__301=async function(t) {
                                                return (acc).push(t)
                                            };
                                            let __array__302=[],__elements__300=["let"," ",preceding_arg_ref,"=",await compile_wrapper_fn(token,ctx),";"];
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__299 in __elements__300) {
                                                __array__302.push(await __for_body__301(__elements__300[__iter__299]));
                                                if(__BREAK__FLAG__) {
                                                     __array__302.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__302;
                                             
                                        })()
                                    }
                                } else {
                                    preceding_arg_ref=await compile_wrapper_fn(token,ctx)
                                };
                                return (acc).push(await (async function(){
                                    let __array_op_rval__303=target_argument_ref;
                                     if (__array_op_rval__303 instanceof Function){
                                        return await __array_op_rval__303(".unshift","(",preceding_arg_ref,")",";") 
                                    } else {
                                        return [__array_op_rval__303,".unshift","(",preceding_arg_ref,")",";"]
                                    }
                                })())
                            };
                            let __array__298=[],__elements__296=args;
                            let __BREAK__FLAG__=false;
                            for(let __iter__295 in __elements__296) {
                                __array__298.push(await __for_body__297(__elements__296[__iter__295]));
                                if(__BREAK__FLAG__) {
                                     __array__298.pop();
                                    break;
                                    
                                }
                            }return __array__298;
                             
                        })();
                        await (async function() {
                            let __for_body__306=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__307=[],__elements__305=["return"," ","(",function_ref,")",".","apply","(","this",",",target_argument_ref,")"];
                            let __BREAK__FLAG__=false;
                            for(let __iter__304 in __elements__305) {
                                __array__307.push(await __for_body__306(__elements__305[__iter__304]));
                                if(__BREAK__FLAG__) {
                                     __array__307.pop();
                                    break;
                                    
                                }
                            }return __array__307;
                             
                        })()
                    }
                } else {
                    {
                        if (check_true (await is_form_ques_(args))){
                            {
                                await (async function() {
                                    let __for_body__310=async function(t) {
                                        return (acc).push(t)
                                    };
                                    let __array__311=[],__elements__309=["let"," ",args_ref,"=",await compile_wrapper_fn((args && args["val"]),ctx),";"];
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__308 in __elements__309) {
                                        __array__311.push(await __for_body__310(__elements__309[__iter__308]));
                                        if(__BREAK__FLAG__) {
                                             __array__311.pop();
                                            break;
                                            
                                        }
                                    }return __array__311;
                                     
                                })();
                                complex_ques_=true
                            }
                        };
                        await (async function() {
                            let __for_body__314=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__315=[],__elements__313=["return"," ","("," ",function_ref,")",".","apply","(","this"];
                            let __BREAK__FLAG__=false;
                            for(let __iter__312 in __elements__313) {
                                __array__315.push(await __for_body__314(__elements__313[__iter__312]));
                                if(__BREAK__FLAG__) {
                                     __array__315.pop();
                                    break;
                                    
                                }
                            }return __array__315;
                             
                        })();
                        if (check_true (args)){
                            {
                                (acc).push(",");
                                if (check_true (complex_ques_)){
                                    (acc).push(args_ref)
                                } else {
                                    (acc).push(await compile_wrapper_fn(args,ctx))
                                }
                            }
                        };
                        (acc).push(")")
                    }
                };
                return [(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()","{",acc,"}",")","()"]
            };
            compile_call=async function(tokens,ctx) {
                let preamble;
                let simple_target_ques_;
                let simple_method_ques_;
                preamble=await calling_preamble(ctx);
                simple_target_ques_=await (async function(){
                    if (check_true (((tokens && tokens["1"] && tokens["1"]["ref"])===true))){
                        return true
                    } else {
                        return false
                    }
                })();
                simple_method_ques_=await (async function(){
                    if (check_true (((tokens && tokens["2"] && tokens["2"]["type"])==="literal"))){
                        return true
                    } else {
                        return false
                    }
                })();
                ctx=ctx;
                ;
                return await async function(){
                    if (check_true ((simple_target_ques_&& simple_method_ques_))) {
                        return await compile_call_inner(tokens,ctx,{
                            type:0,preamble:preamble
                        })
                    } else if (check_true (simple_target_ques_)) {
                        return await compile_call_inner(tokens,ctx,{
                            type:0,preamble:preamble
                        })
                    } else {
                        {
                            ctx=await (async function(){
                                 return await new_ctx(ctx) 
                            })();
                            await set_new_completion_scope(ctx);
                            return [(preamble && preamble["2"]),(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()"," ","{",await compile_call_inner(tokens,ctx,{
                                type:2,preamble:preamble
                            })," ","}",")","()"]
                        }
                    }
                } ()
            };
            compile_call_inner=async function(tokens,ctx,opts) {
                let acc;
                let target;
                let idx;
                let preamble;
                let add_args;
                let method;
                acc=[];
                target=null;
                idx=-1;
                preamble=(opts && opts["preamble"]);
                add_args=async function() {
                    return await (async function() {
                        let __for_body__318=async function(token) {
                            (acc).push(",");
                            return (acc).push(await compile_wrapper_fn(token,ctx))
                        };
                        let __array__319=[],__elements__317=await tokens["slice"].call(tokens,3);
                        let __BREAK__FLAG__=false;
                        for(let __iter__316 in __elements__317) {
                            __array__319.push(await __for_body__318(__elements__317[__iter__316]));
                            if(__BREAK__FLAG__) {
                                 __array__319.pop();
                                break;
                                
                            }
                        }return __array__319;
                         
                    })()
                };
                method=null;
                if (check_true (((tokens && tokens.length)<3))){
                    {
                        throw new SyntaxError(("call: missing arguments, requires at least 2"));
                        
                    }
                };
                target=await compile_wrapper_fn((tokens && tokens["1"]),ctx);
                method=await compile_wrapper_fn((tokens && tokens["2"]),ctx);
                await async function(){
                    if (check_true ((((opts && opts["type"])===0)|| ((opts && opts["type"])===1)))) {
                        {
                            return await async function(){
                                if (check_true (((tokens && tokens.length)===3))) {
                                    return await (async function() {
                                        let __for_body__322=async function(t) {
                                            return (acc).push(t)
                                        };
                                        let __array__323=[],__elements__321=await (async function(){
                                            let __array_op_rval__324=(preamble && preamble["0"]);
                                             if (__array_op_rval__324 instanceof Function){
                                                return await __array_op_rval__324(" ",target,"[",method,"]","()") 
                                            } else {
                                                return [__array_op_rval__324," ",target,"[",method,"]","()"]
                                            }
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__320 in __elements__321) {
                                            __array__323.push(await __for_body__322(__elements__321[__iter__320]));
                                            if(__BREAK__FLAG__) {
                                                 __array__323.pop();
                                                break;
                                                
                                            }
                                        }return __array__323;
                                         
                                    })()
                                } else {
                                    {
                                        await (async function() {
                                            let __for_body__327=async function(t) {
                                                return (acc).push(t)
                                            };
                                            let __array__328=[],__elements__326=await (async function(){
                                                let __array_op_rval__329=(preamble && preamble["0"]);
                                                 if (__array_op_rval__329 instanceof Function){
                                                    return await __array_op_rval__329(" ",target,"[",method,"]",".call","(",target) 
                                                } else {
                                                    return [__array_op_rval__329," ",target,"[",method,"]",".call","(",target]
                                                }
                                            })();
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__325 in __elements__326) {
                                                __array__328.push(await __for_body__327(__elements__326[__iter__325]));
                                                if(__BREAK__FLAG__) {
                                                     __array__328.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__328;
                                             
                                        })();
                                        await add_args();
                                        return (acc).push(")")
                                    }
                                }
                            } ()
                        }
                    } else if (check_true (((opts && opts["type"])===2))) {
                        {
                            await (async function() {
                                let __for_body__332=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__333=[],__elements__331=["{"," ","let"," ","__call_target__","=",target,","," ","__call_method__","=",method,";"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__330 in __elements__331) {
                                    __array__333.push(await __for_body__332(__elements__331[__iter__330]));
                                    if(__BREAK__FLAG__) {
                                         __array__333.pop();
                                        break;
                                        
                                    }
                                }return __array__333;
                                 
                            })();
                            await async function(){
                                if (check_true (((tokens && tokens.length)===3))) {
                                    return await (async function() {
                                        let __for_body__336=async function(t) {
                                            return (acc).push(t)
                                        };
                                        let __array__337=[],__elements__335=["return"," ",(preamble && preamble["0"])," ","__call_target__","[","__call_method__","]","()"];
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__334 in __elements__335) {
                                            __array__337.push(await __for_body__336(__elements__335[__iter__334]));
                                            if(__BREAK__FLAG__) {
                                                 __array__337.pop();
                                                break;
                                                
                                            }
                                        }return __array__337;
                                         
                                    })()
                                } else {
                                    {
                                        await (async function() {
                                            let __for_body__340=async function(t) {
                                                return (acc).push(t)
                                            };
                                            let __array__341=[],__elements__339=["return"," ",(preamble && preamble["0"])," ","__call_target__","[","__call_method__","]",".","call","(","__call_target__"];
                                            let __BREAK__FLAG__=false;
                                            for(let __iter__338 in __elements__339) {
                                                __array__341.push(await __for_body__340(__elements__339[__iter__338]));
                                                if(__BREAK__FLAG__) {
                                                     __array__341.pop();
                                                    break;
                                                    
                                                }
                                            }return __array__341;
                                             
                                        })();
                                        await add_args();
                                        (acc).push(")")
                                    }
                                }
                            } ();
                            (acc).push("}")
                        }
                    }
                } ();
                return acc
            };
            check_needs_wrap=async function(stmts) {
                let fst;
                fst=(((stmts instanceof Array)&& await first(stmts)&& (await first(stmts) instanceof Object)&& await not(await (async function(){
                    let __targ__342=await first(stmts);
                    if (__targ__342){
                         return(__targ__342)["ctype"]
                    } 
                })() instanceof Function)&& await (async function(){
                    let __targ__343=await first(stmts);
                    if (__targ__343){
                         return(__targ__343)["ctype"]
                    } 
                })()&& await (async function(){
                     return await async function(){
                        if (check_true ((await (async function(){
                            let __targ__344=await first(stmts);
                            if (__targ__344){
                                 return(__targ__344)["ctype"]
                            } 
                        })() instanceof String || typeof await (async function(){
                            let __targ__344=await first(stmts);
                            if (__targ__344){
                                 return(__targ__344)["ctype"]
                            } 
                        })()==='string'))) {
                            return await (async function(){
                                let __targ__345=await first(stmts);
                                if (__targ__345){
                                     return(__targ__345)["ctype"]
                                } 
                            })()
                        } else {
                            return await sub_type(await (async function(){
                                let __targ__346=await first(stmts);
                                if (__targ__346){
                                     return(__targ__346)["ctype"]
                                } 
                            })())
                        }
                    } () 
                })())|| "");
                await console.warn("DEPRECATION: check_needs_wrap called: ",stmts);
                return await async function(){
                    if (check_true (await contains_ques_("block",fst))) {
                        return true
                    } else {
                        return false
                    }
                } ()
            };
            compile_import=async function(tokens,ctx) {
                let symbol_tokens;
                let __symbols__347= async function(){
                    return []
                };
                let from_tokens;
                let from_place;
                let acc;
                {
                    symbol_tokens=(tokens && tokens["1"]);
                    let symbols=await __symbols__347();
                    ;
                    from_tokens=null;
                    from_place=null;
                    acc=[];
                    if (check_true (((tokens && tokens.length)<3))){
                        throw new SyntaxError("import requires exactly two arguments");
                        
                    };
                    symbol_tokens=(tokens && tokens["1"]);
                    from_tokens=(tokens && tokens["2"]);
                    from_place=await (async function(){
                         return await compile(from_tokens,ctx) 
                    })();
                    (acc).push({
                        ctype:"statement",meta:{
                            imported_from:from_place
                        }
                    });
                    (acc).push("import");
                    (acc).push(" ");
                    await async function(){
                        if (check_true (((symbol_tokens && symbol_tokens["val"]) instanceof Array))) {
                            {
                                await (async function() {
                                    let __for_body__350=async function(s) {
                                        return (symbols).push((s && s.name))
                                    };
                                    let __array__351=[],__elements__349=(symbol_tokens && symbol_tokens["val"]);
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__348 in __elements__349) {
                                        __array__351.push(await __for_body__350(__elements__349[__iter__348]));
                                        if(__BREAK__FLAG__) {
                                             __array__351.pop();
                                            break;
                                            
                                        }
                                    }return __array__351;
                                     
                                })();
                                return await (async function() {
                                    let __for_body__354=async function(t) {
                                        return (acc).push(t)
                                    };
                                    let __array__355=[],__elements__353=await flatten(["{"," ",symbols," ","}"," ","from"," ",from_place]);
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__352 in __elements__353) {
                                        __array__355.push(await __for_body__354(__elements__353[__iter__352]));
                                        if(__BREAK__FLAG__) {
                                             __array__355.pop();
                                            break;
                                            
                                        }
                                    }return __array__355;
                                     
                                })()
                            }
                        } else {
                            throw new SyntaxError("import requires an array of imported symbols as a second argument");
                            
                        }
                    } ();
                    return acc
                }
            };
            compile_dynamic_import=async function(tokens,ctx) {
                let from_tokens;
                let preamble;
                let from_place;
                let can_be_static;
                let metaval;
                let imported_from;
                let acc;
                from_tokens=null;
                preamble=await calling_preamble(ctx);
                from_place=null;
                can_be_static=false;
                metaval=null;
                imported_from=null;
                acc=[];
                ;
                from_tokens=(tokens && tokens["1"]);
                from_place=await compile_wrapper_fn(from_tokens,ctx);
                imported_from=await (async function(){
                    if (check_true ((from_place instanceof Array))){
                        return (from_place && from_place["1"])
                    } else {
                        return from_place
                    }
                })();
                if (check_true (((imported_from instanceof String || typeof imported_from==='string')&& await starts_with_ques_("\"",imported_from)&& await (await Environment.get_global("ends_with?"))("\"",imported_from)))){
                    {
                        can_be_static=true;
                        imported_from=await imported_from["substr"].call(imported_from,1,((imported_from && imported_from.length)- 2))
                    }
                };
                await async function(){
                    external_dependencies[imported_from]=true;
                    return external_dependencies;
                    
                }();
                metaval=await (async function(){
                    if (check_true (can_be_static)){
                        return {
                            initializer:await (async function(){
                                 return ["=:javascript","undefined"] 
                            })()
                        }
                    } else {
                        return new Object()
                    }
                })();
                (acc).push({
                    ctype:"statement",meta:metaval
                });
                await (async function() {
                    let __for_body__359=async function(t) {
                        return (acc).push(t)
                    };
                    let __array__360=[],__elements__358=await flatten([(preamble && preamble["0"])," ","import"," ","(",from_place,")"]);
                    let __BREAK__FLAG__=false;
                    for(let __iter__357 in __elements__358) {
                        __array__360.push(await __for_body__359(__elements__358[__iter__357]));
                        if(__BREAK__FLAG__) {
                             __array__360.pop();
                            break;
                            
                        }
                    }return __array__360;
                     
                })();
                return acc
            };
            compile_javascript=async function(tokens,ctx) {
                let acc;
                let text;
                acc=await (async function(){
                     return [{
                        ctype:"__JS__"
                    }] 
                })();
                text=null;
                await (async function() {
                    let __for_body__363=async function(t) {
                        return await async function(){
                            if (check_true ((t && t["ref"]))) {
                                return (acc).push((t && t.name))
                            } else if (check_true (((t && t["val"]) instanceof Array))) {
                                return (acc).push(await (async function(){
                                     return await compile(t,ctx) 
                                })())
                            } else {
                                return (acc).push((t && t["val"]))
                            }
                        } ()
                    };
                    let __array__364=[],__elements__362=(await (await Environment.get_global("rest"))(tokens)|| []);
                    let __BREAK__FLAG__=false;
                    for(let __iter__361 in __elements__362) {
                        __array__364.push(await __for_body__363(__elements__362[__iter__361]));
                        if(__BREAK__FLAG__) {
                             __array__364.pop();
                            break;
                            
                        }
                    }return __array__364;
                     
                })();
                return acc
            };
            compile_set_global=async function(tokens,ctx,opts) {
                let target;
                let wrap_as_function_ques_;
                let global_dependencies;
                let __external_dependencies__365= async function(){
                    return null
                };
                let preamble;
                let source_meta;
                let acc;
                let clog;
                let metavalue;
                let assignment_value;
                {
                    target=(tokens && tokens["1"] && tokens["1"]["name"]);
                    wrap_as_function_ques_=null;
                    ctx=await (async function(){
                         return await new_ctx(ctx) 
                    })();
                    global_dependencies=null;
                    let external_dependencies=await __external_dependencies__365();
                    ;
                    preamble=await calling_preamble(ctx);
                    source_meta=null;
                    acc=null;
                    clog=await (async function(){
                        if (check_true ((opts && opts["quiet_mode"]))){
                            return log
                        } else {
                            return await defclog({
                                prefix:"compile_set_global",color:"blue",background:"#205020"
                            })
                        }
                    })();
                    metavalue=null;
                    assignment_value=null;
                    ;
                    await async function(){
                        if (check_true ((null==(tokens && tokens["1"])))) {
                            throw new SyntaxError("set global directive missing assignment target and assignment value");
                            
                        } else if (check_true ((null==(tokens && tokens["2"])))) {
                            throw new SyntaxError("set global directive missing assignment value");
                            
                        }
                    } ();
                    has_lisp_globals=true;
                    await set_ctx(ctx,"__GLOBALS__",new Set());
                    await async function(){
                        let __target_obj__366=(root_ctx && root_ctx["defined_lisp_globals"]);
                        __target_obj__366[target]=AsyncFunction;
                        return __target_obj__366;
                        
                    }();
                    assignment_value=await (async function(){
                        return await compile_wrapper_fn((tokens && tokens["2"]),ctx)
                    })();
                    global_dependencies=await (async function(){
                         return await (await Environment.get_global("to_array"))(await get_ctx(ctx,"__GLOBALS__")) 
                    })();
                    external_dependencies=await (async function(){
                         return await (await Environment.get_global("to_array"))(await get_ctx(ctx,"__EXTERNALS__")) 
                    })();
                    if (check_true (true)){
                        {
                            await async function(){
                                if (check_true ((null==(tokens && tokens["3"])))) {
                                    return (tokens).push(await tokenize({
                                        requires:global_dependencies,externals:external_dependencies,source_name:source_name
                                    },ctx))
                                } else if (check_true (((tokens && tokens["3"] && tokens["3"]["val"] && tokens["3"]["val"]["val"] && tokens["3"]["val"]["val"]["1"]) instanceof Object))) {
                                    {
                                        await async function(){
                                            let __target_obj__367=(tokens && tokens["3"] && tokens["3"]["val"] && tokens["3"]["val"]["val"] && tokens["3"]["val"]["val"]["1"]);
                                            __target_obj__367["requires"]=global_dependencies;
                                            return __target_obj__367;
                                            
                                        }();
                                        await async function(){
                                            let __target_obj__368=(tokens && tokens["3"] && tokens["3"]["val"] && tokens["3"]["val"]["val"] && tokens["3"]["val"]["val"]["1"]);
                                            __target_obj__368["externals"]=external_dependencies;
                                            return __target_obj__368;
                                            
                                        }();
                                        await async function(){
                                            let __target_obj__369=(tokens && tokens["3"] && tokens["3"]["val"] && tokens["3"]["val"]["val"] && tokens["3"]["val"]["val"]["1"]);
                                            __target_obj__369["source_name"]=source_name;
                                            return __target_obj__369;
                                            
                                        }()
                                    }
                                } else if (check_true ((((tokens && tokens["3"] && tokens["3"]["val"]) instanceof Array)&& ((tokens && tokens["3"] && tokens["3"]["type"])==="objlit")))) {
                                    {
                                        if (check_true (((global_dependencies && global_dependencies.length)>0))){
                                            {
                                                global_dependencies=await tokenize({
                                                    requires:global_dependencies
                                                },ctx);
                                                ((tokens && tokens["3"] && tokens["3"]["val"])).push((global_dependencies && global_dependencies["val"] && global_dependencies["val"]["0"]))
                                            }
                                        };
                                        if (check_true (((external_dependencies && external_dependencies.length)>0))){
                                            {
                                                external_dependencies=await tokenize({
                                                    requires:external_dependencies
                                                },ctx);
                                                ((tokens && tokens["3"] && tokens["3"]["val"])).push((external_dependencies && external_dependencies["val"] && external_dependencies["val"]["0"]))
                                            }
                                        };
                                        source_meta=await tokenize({
                                            source_name:source_name
                                        },ctx);
                                        ((tokens && tokens["3"] && tokens["3"]["val"])).push((source_meta && source_meta["val"] && source_meta["val"]["0"]))
                                    }
                                }
                            } ()
                        }
                    };
                    if (check_true ((tokens && tokens["3"]))){
                        {
                            metavalue=await (async function(){
                                if (check_true (await is_complex_ques_((tokens && tokens["3"])))){
                                    return await compile_wrapper_fn((tokens && tokens["3"]),ctx)
                                } else {
                                    return await compile((tokens && tokens["3"]),ctx)
                                }
                            })()
                        }
                    };
                    await async function(){
                        if (check_true ((((assignment_value && assignment_value["0"]) instanceof Object)&& (assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])))) {
                            {
                                if (check_true ((assignment_value && assignment_value["0"] && assignment_value["0"]["meta"]))){
                                    {
                                        if (check_true (await not(metavalue))){
                                            {
                                                metavalue=await quote_tree((assignment_value && assignment_value["0"] && assignment_value["0"]["meta"]),ctx)
                                            }
                                        }
                                    }
                                };
                                return await async function(){
                                    let __target_obj__370=(root_ctx && root_ctx["defined_lisp_globals"]);
                                    __target_obj__370[target]=await (async function(){
                                         return await async function(){
                                            if (check_true (((assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])==="Function"))) {
                                                return Function
                                            } else if (check_true (((assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])==="AsyncFunction"))) {
                                                return AsyncFunction
                                            } else if (check_true (((assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])==="Number"))) {
                                                return NumberType
                                            } else if (check_true (((assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])==="expression"))) {
                                                return Expression
                                            } else {
                                                return (assignment_value && assignment_value["0"] && assignment_value["0"]["ctype"])
                                            }
                                        } () 
                                    })();
                                    return __target_obj__370;
                                    
                                }()
                            }
                        } else {
                            {
                                if (check_true (((assignment_value instanceof Array)&& ((assignment_value && assignment_value["0"])==="await")))){
                                    {
                                        await async function(){
                                            let __target_obj__371=(root_ctx && root_ctx["defined_lisp_globals"]);
                                            __target_obj__371[target]=AsyncFunction;
                                            return __target_obj__371;
                                            
                                        }();
                                        await set_ambiguous(root_ctx,target)
                                    }
                                } else {
                                    await async function(){
                                        let __target_obj__372=(root_ctx && root_ctx["defined_lisp_globals"]);
                                        __target_obj__372[target]=assignment_value;
                                        return __target_obj__372;
                                        
                                    }()
                                }
                            }
                        }
                    } ();
                    if (check_true (await verbosity(ctx))){
                        {
                            await clog("target: ",await (await Environment.get_global("as_lisp"))(target));
                            await clog("assignment_value: ",await (await Environment.get_global("as_lisp"))(assignment_value))
                        }
                    };
                    acc=await (async function(){
                         return [{
                            ctype:"statement"
                        },await (async function(){
                            if (check_true (((Function===await (async function(){
                                let __targ__373=(root_ctx && root_ctx["defined_lisp_globals"]);
                                if (__targ__373){
                                     return(__targ__373)[target]
                                } 
                            })())|| await in_sync_ques_(ctx)))){
                                return ""
                            } else {
                                return "await"
                            }
                        })()," ","Environment",".","set_global","(","","\"",(tokens && tokens["1"] && tokens["1"]["name"]),"\"",",",assignment_value,await (async function(){
                            if (check_true ((metavalue|| (opts && opts["constant"])))){
                                return ","
                            } else {
                                return ""
                            }
                        })(),await (async function(){
                            if (check_true (metavalue)){
                                return metavalue
                            } else {
                                if (check_true ((opts && opts["constant"]))){
                                    return "null"
                                } else {
                                    return ""
                                }
                            }
                        })(),await (async function(){
                            if (check_true ((opts && opts["constant"]))){
                                return ","
                            } else {
                                return ""
                            }
                        })(),await (async function(){
                            if (check_true ((opts && opts["constant"]))){
                                return "true"
                            } else {
                                return ""
                            }
                        })(),")"] 
                    })();
                    return acc
                }
            };
            is_token_ques_=async function(t) {
                return (((t instanceof Object)&& (t && t["__token__"]))|| ((t instanceof Array)&& ((t && t["0"]) instanceof Object)&& (t && t["0"] && t["0"]["__token__"])))
            };
            compile_quote=async function(lisp_struct,ctx) {
                let acc;
                acc=[];
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                acc=await compile_quotem(lisp_struct,ctx);
                return acc
            };
            compile_quotel=async function(lisp_struct,ctx) {
                let acc;
                acc=[];
                acc=await JSON.stringify((lisp_struct && lisp_struct["1"]));
                return await (async function(){
                    let __array_op_rval__374=acc;
                     if (__array_op_rval__374 instanceof Function){
                        return await __array_op_rval__374() 
                    } else {
                        return [__array_op_rval__374]
                    }
                })()
            };
            wrap_and_run=async function(js_code,ctx,run_opts) {
                let __assembly__375= async function(){
                    return null
                };
                let result;
                let fst;
                let ctype;
                let comp_meta;
                let needs_braces_ques_;
                let in_quotem;
                let run_log;
                let needs_return_ques_;
                let assembled;
                {
                    let assembly=await __assembly__375();
                    ;
                    result=null;
                    fst=null;
                    ctype=null;
                    comp_meta=null;
                    needs_braces_ques_=false;
                    in_quotem=await get_ctx(ctx,"__IN_QUOTEM__");
                    run_log=await (async function(){
                        if (check_true ((opts && opts["quiet_mode"]))){
                            return log
                        } else {
                            return await defclog({
                                prefix:"wrap_and_run",background:"#703030",color:"white"
                            })
                        }
                    })();
                    needs_return_ques_=await (async function(){
                        ctype=await (async function(){
                            if (check_true (((js_code instanceof Array)&& await first(js_code)&& (await first(js_code) instanceof Object)&& await (async function(){
                                let __targ__376=await first(js_code);
                                if (__targ__376){
                                     return(__targ__376)["ctype"]
                                } 
                            })()))){
                                return await (async function(){
                                    let __targ__377=await first(js_code);
                                    if (__targ__377){
                                         return(__targ__377)["ctype"]
                                    } 
                                })()
                            }
                        })();
                        if (check_true (((typeof ctype==="object")&& await not((ctype instanceof Object))))){
                            fst=""
                        } else {
                            fst=(""+ (ctype|| ""))
                        };
                        if (check_true (fst instanceof Function)){
                            {
                                fst=await sub_type(fst)
                            }
                        };
                        return await async function(){
                            if (check_true (await contains_ques_("block",fst))) {
                                {
                                    if (check_true ((fst==="ifblock"))){
                                        needs_braces_ques_=true
                                    } else {
                                        needs_braces_ques_=false
                                    };
                                    return false
                                }
                            } else if (check_true ((await first(js_code)==="throw"))) {
                                {
                                    needs_braces_ques_=false;
                                    return false
                                }
                            } else {
                                {
                                    needs_braces_ques_=true;
                                    return true
                                }
                            }
                        } ()
                    })();
                    assembled=null;
                    ;
                    assembled=js_code;
                    try {
                        if (check_true ((target_namespace&& ((assembled && assembled["0"]) instanceof Object)&& await not((target_namespace===(Environment && Environment["namespace"])))))){
                            {
                                comp_meta=await first(assembled);
                                await async function(){
                                    comp_meta["namespace"]=target_namespace;
                                    return comp_meta;
                                    
                                }();
                                if (check_true ((await verbosity(ctx)&& (comp_meta && comp_meta["namespace"])))){
                                    {
                                        await run_log("specified namespace: ",(comp_meta && comp_meta["namespace"]))
                                    }
                                };
                                result=await Environment["evaluate_local"].call(Environment,await (async function(){
                                    let __array_op_rval__380=comp_meta;
                                     if (__array_op_rval__380 instanceof Function){
                                        return await __array_op_rval__380(await assemble_output(assembled)) 
                                    } else {
                                        return [__array_op_rval__380,await assemble_output(assembled)]
                                    }
                                })(),ctx,{
                                    compiled_source:true
                                });
                                if (check_true (await verbosity(ctx))){
                                    {
                                        await run_log("<- ",result)
                                    }
                                };
                                return result
                            }
                        } else {
                            {
                                assembled=await assemble_output(assembled);
                                assembled=await add(await (async function(){
                                    if (check_true (needs_braces_ques_)){
                                        return "{"
                                    } else {
                                        return ""
                                    }
                                })(),await (async function(){
                                    if (check_true (needs_return_ques_)){
                                        return " return "
                                    } else {
                                        return ""
                                    }
                                })(),assembled,await (async function(){
                                    if (check_true (needs_braces_ques_)){
                                        return "}"
                                    } else {
                                        return ""
                                    }
                                })());
                                if (check_true (await verbosity(ctx))){
                                    {
                                        await run_log("assembled: ",assembled)
                                    }
                                };
                                try {
                                    assembly=new AsyncFunction("Environment",assembled)
                                } catch (__exception__381) {
                                    if (__exception__381 instanceof Error) {
                                        let e=__exception__381;
                                        {
                                            {
                                                await console.error("compiler: wrap_and_run: caught error on constructing new async_function");
                                                await console.error("compiler: wrap_and_run: ",assembled);
                                                throw e;
                                                
                                            }
                                        }
                                    }
                                };
                                if (check_true ((run_opts && run_opts["bind_mode"]))){
                                    {
                                        assembly=await (await Environment.get_global("bind_function"))(assembly,Environment)
                                    }
                                };
                                result=await (async function(){
                                    let __array_op_rval__382=assembly;
                                     if (__array_op_rval__382 instanceof Function){
                                        return await __array_op_rval__382(Environment) 
                                    } else {
                                        return [__array_op_rval__382,Environment]
                                    }
                                })();
                                if (check_true (await verbosity(ctx))){
                                    {
                                        await run_log("<- ",result)
                                    }
                                };
                                return result
                            }
                        }
                    } catch (__exception__378) {
                        if (__exception__378 instanceof Error) {
                            let e=__exception__378;
                            {
                                {
                                    await console.log("compiler: wrap_and_run: caught error on evaluation: ",(e && e.message));
                                    if (check_true (await (await Environment.get_global("resolve_path"))(["context","scope","*on_compiler_eval_error*"],Environment) instanceof Function)){
                                        result=await (async function(){
                                             return [await (await Environment.get_global("resolve_path"))(["context","scope","*on_compiler_eval_error*"],Environment),e,assembled] 
                                        })()
                                    } else {
                                        throw e;
                                        
                                    };
                                    return result
                                }
                            }
                        }
                    }
                }
            };
            quote_tree=async function(lisp_tree,ctx,_acc) {
                let acc;
                let mode;
                let in_concat;
                let in_lambda_ques_;
                acc=(_acc|| []);
                mode=0;
                in_concat=false;
                in_lambda_ques_=false;
                await async function(){
                    if (check_true ((lisp_tree instanceof Array))) {
                        {
                            (acc).push("[");
                            await map(async function(elem,i,t) {
                                if (check_true ((mode===1))){
                                    {
                                        return mode=0
                                    }
                                } else {
                                    {
                                        await async function(){
                                            if (check_true ((("=:##"===elem)|| ("=:unquotem"===elem)))) {
                                                {
                                                    if (check_true (in_concat)){
                                                        (acc).push(await compile_wrapper_fn(await tokenize(await (async function(){
                                                             return [lisp_tree[await add(i,1)]] 
                                                        })(),ctx),ctx))
                                                    } else {
                                                        (acc).push(await compile_wrapper_fn(await tokenize(lisp_tree[await add(i,1)],ctx),ctx))
                                                    };
                                                    return mode=1
                                                }
                                            } else if (check_true (("=$,@"===elem))) {
                                                {
                                                    if (check_true (await not(in_concat))){
                                                        (acc).push("].concat(")
                                                    };
                                                    (acc).push(await compile_wrapper_fn(await tokenize(lisp_tree[await add(i,1)],ctx),ctx));
                                                    in_concat=true;
                                                    return mode=1
                                                }
                                            } else {
                                                {
                                                    if (check_true (in_concat)){
                                                        return await quote_tree(await (async function(){
                                                            let __array_op_rval__383=elem;
                                                             if (__array_op_rval__383 instanceof Function){
                                                                return await __array_op_rval__383() 
                                                            } else {
                                                                return [__array_op_rval__383]
                                                            }
                                                        })(),ctx,acc)
                                                    } else {
                                                        return await quote_tree(elem,ctx,acc)
                                                    }
                                                }
                                            }
                                        } ();
                                        if (check_true ((i<(t- 1)))){
                                            return (acc).push(",")
                                        }
                                    }
                                }
                            },lisp_tree);
                            if (check_true ((","===await last(acc)))){
                                (acc).pop()
                            };
                            if (check_true (in_concat)){
                                return (acc).push(")")
                            } else {
                                return (acc).push("]")
                            }
                        }
                    } else if (check_true ((lisp_tree instanceof Object))) {
                        {
                            (acc).push("{ ");
                            await map(async function(k,i,t) {
                                (acc).push(await JSON.stringify(k));
                                (acc).push(":");
                                await quote_tree(lisp_tree[k],ctx,acc);
                                if (check_true ((i<(t- 1)))){
                                    return (acc).push(",")
                                }
                            },await (await Environment.get_global("keys"))(lisp_tree));
                            (acc).push("}")
                        }
                    } else if (check_true ((lisp_tree instanceof String || typeof lisp_tree==='string'))) {
                        (acc).push(await JSON.stringify(lisp_tree))
                    } else if (check_true (await (async function(){
                         return await is_nil_ques_(lisp_tree) 
                    })())) {
                        (acc).push(await JSON.stringify(null))
                    } else if (check_true ((undefined===lisp_tree))) {
                        (acc).push(await JSON.stringify(undefined))
                    } else {
                        (acc).push(await JSON.stringify(lisp_tree))
                    }
                } ();
                return acc
            };
            quotem_log=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    return log
                } else {
                    return await defclog({
                        prefix:"compile_quotem",background:"#503090",color:"white"
                    })
                }
            })();
            compile_quotem=async function(lisp_struct,ctx) {
                let acc;
                let quoted_js;
                acc=[];
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                quoted_js=null;
                await set_ctx(ctx,"__IN_QUOTEM__",true);
                if (check_true (await verbosity(ctx))){
                    {
                        await quotem_log("->",await (async function(){
                            if (check_true (await get_ctx(ctx,"__IN_LAMBDA__"))){
                                return "[IN LAMBDA]"
                            } else {
                                return ""
                            }
                        })(),await JSON.stringify((lisp_struct && lisp_struct["1"])))
                    }
                };
                if (check_true (await get_ctx(ctx,"__IN_LAMBDA__"))){
                    {
                        quoted_js=await quote_tree((lisp_struct && lisp_struct["1"]),ctx)
                    }
                } else {
                    quoted_js=await quote_tree((lisp_struct && lisp_struct["1"]),ctx)
                };
                if (check_true (await verbosity(ctx))){
                    {
                        await quotem_log("<-",await (await Environment.get_global("as_lisp"))(quoted_js))
                    }
                };
                return quoted_js
            };
            compile_unquotem=async function(lisp_struct,ctx) {
                let acc;
                acc=[];
                (acc).push(await (async function(){
                     return await compile((lisp_struct && lisp_struct["1"]),ctx) 
                })());
                return acc
            };
            eval_log=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    return log
                } else {
                    return await defclog({
                        prefix:"compile_eval",background:"#705030",color:"white"
                    })
                }
            })();
            compile_eval=async function(tokens,ctx) {
                let __assembly__384= async function(){
                    return null
                };
                let type_mark;
                let acc;
                let preamble;
                let result;
                let eval_opts;
                {
                    let assembly=await __assembly__384();
                    ;
                    type_mark=null;
                    acc=[];
                    preamble=await calling_preamble(ctx);
                    result=null;
                    eval_opts=null;
                    ctx=await (async function(){
                         return await new_ctx(ctx) 
                    })();
                    await set_new_completion_scope(ctx);
                    if (check_true ((tokens && tokens["2"]))){
                        {
                            eval_opts=await (async function(){
                                 return await compile((tokens && tokens["2"]),ctx) 
                            })()
                        }
                    };
                    assembly=await (async function(){
                         return await compile((tokens && tokens["1"]),ctx) 
                    })();
                    if (check_true (await verbosity(ctx))){
                        {
                            await eval_log("assembly:",await (async function(){
                                 return await clone(assembly) 
                            })())
                        }
                    };
                    has_lisp_globals=true;
                    result=["(","await"," ","Environment",".","eval","(",(preamble && preamble["0"])," ",(preamble && preamble["1"])," ","function","()",["{","return"," ",assembly,"}","()",",null",await (async function(){
                        if (check_true (eval_opts)){
                            return [", ",eval_opts]
                        } else {
                            return ""
                        }
                    })(),")",")"]];
                    return result
                }
            };
            compile_debug=async function(tokens,ctx) {
                return [{
                    ctype:"statement"
                },"debugger",";"]
            };
            compile_for_each=async function(tokens,ctx) {
                let preamble;
                preamble=await calling_preamble(ctx);
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                ;
                await set_new_completion_scope(ctx);
                return await (async function(){
                    let __array_op_rval__385=(preamble && preamble["2"]);
                     if (__array_op_rval__385 instanceof Function){
                        return await __array_op_rval__385((preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()"," ","{",await compile_for_each_inner(tokens,ctx,preamble)," ","}",")","()") 
                    } else {
                        return [__array_op_rval__385,(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()"," ","{",await compile_for_each_inner(tokens,ctx,preamble)," ","}",")","()"]
                    }
                })()
            };
            compile_for_each_inner=async function(tokens,ctx,preamble) {
                let acc;
                let idx;
                let stmts;
                let idx_iter;
                let idx_iters;
                let element_list;
                let body_function_ref;
                let collector_ref;
                let prebuild;
                let for_args;
                let iterator_ref;
                let elements;
                let iter_count;
                let for_body;
                let body_is_block_ques_;
                acc=[];
                idx=0;
                stmts=[];
                idx_iter=await gen_temp_name("iter");
                idx_iters=[];
                element_list=await gen_temp_name("elements");
                body_function_ref=await gen_temp_name("for_body");
                collector_ref=await gen_temp_name("array");
                prebuild=[];
                for_args=(tokens && tokens["1"] && tokens["1"]["val"]);
                iterator_ref=(for_args && for_args["0"]);
                elements=await last(for_args);
                iter_count=await (async function(){
                    if (check_true (for_args)){
                        return ((for_args && for_args.length)- 1)
                    } else {
                        return 0
                    }
                })();
                for_body=(tokens && tokens["2"]);
                body_is_block_ques_=await is_block_ques_((for_body && for_body["val"]));
                if (check_true ((iter_count<1))){
                    {
                        throw new SyntaxError("Invalid for_each arguments");
                        
                    }
                };
                await (async function() {
                    let __for_body__388=async function(iter_idx) {
                        (idx_iters).push(for_args[iter_idx]);
                        return await set_ctx(ctx,await clean_quoted_reference(await (async function(){
                            let __targ__390=await last(idx_iters);
                            if (__targ__390){
                                 return(__targ__390)["name"]
                            } 
                        })()),ArgumentType)
                    };
                    let __array__389=[],__elements__387=await (await Environment.get_global("range"))(iter_count);
                    let __BREAK__FLAG__=false;
                    for(let __iter__386 in __elements__387) {
                        __array__389.push(await __for_body__388(__elements__387[__iter__386]));
                        if(__BREAK__FLAG__) {
                             __array__389.pop();
                            break;
                            
                        }
                    }return __array__389;
                     
                })();
                await set_ctx(ctx,collector_ref,ArgumentType);
                await set_ctx(ctx,"__LAMBDA_STEP__",-1);
                await set_ctx(ctx,element_list,"arg");
                if (check_true (await not(body_is_block_ques_))){
                    {
                        for_body=await make_do_block(for_body)
                    }
                };
                prebuild=await build_fn_with_assignment(body_function_ref,(for_body && for_body["val"]),idx_iters,ctx);
                await async function(){
                    ctx["return_last_value"]=true;
                    return ctx;
                    
                }();
                (acc).push(await (async function(){
                     return await compile(prebuild,ctx) 
                })());
                await (async function() {
                    let __for_body__394=async function(t) {
                        return (acc).push(t)
                    };
                    let __array__395=[],__elements__393=["let"," ",collector_ref,"=","[]",",",element_list,"=",await compile_wrapper_fn(elements,ctx),";"];
                    let __BREAK__FLAG__=false;
                    for(let __iter__392 in __elements__393) {
                        __array__395.push(await __for_body__394(__elements__393[__iter__392]));
                        if(__BREAK__FLAG__) {
                             __array__395.pop();
                            break;
                            
                        }
                    }return __array__395;
                     
                })();
                await (async function() {
                    let __for_body__398=async function(t) {
                        return (acc).push(t)
                    };
                    let __array__399=[],__elements__397=["let"," ",break_out,"=","false",";"];
                    let __BREAK__FLAG__=false;
                    for(let __iter__396 in __elements__397) {
                        __array__399.push(await __for_body__398(__elements__397[__iter__396]));
                        if(__BREAK__FLAG__) {
                             __array__399.pop();
                            break;
                            
                        }
                    }return __array__399;
                     
                })();
                if (check_true (await (await Environment.get_global("blank?"))((preamble && preamble["0"])))){
                    await set_ctx(ctx,body_function_ref,Function)
                } else {
                    await set_ctx(ctx,body_function_ref,AsyncFunction)
                };
                await async function(){
                    if (check_true ((((for_args && for_args.length)===2)&& await not(((for_args && for_args["1"]) instanceof Array))))) {
                        {
                            await set_ctx(ctx,idx_iter,NumberType);
                            await (async function() {
                                let __for_body__402=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__403=[],__elements__401=["for","(","let"," ",idx_iter," ","in"," ",element_list,")"," ","{"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__400 in __elements__401) {
                                    __array__403.push(await __for_body__402(__elements__401[__iter__400]));
                                    if(__BREAK__FLAG__) {
                                         __array__403.pop();
                                        break;
                                        
                                    }
                                }return __array__403;
                                 
                            })();
                            await (async function() {
                                let __for_body__406=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__407=[],__elements__405=await (async function(){
                                    let __array_op_rval__408=collector_ref;
                                     if (__array_op_rval__408 instanceof Function){
                                        return await __array_op_rval__408(".","push","(",(preamble && preamble["0"])," ",body_function_ref,"(",element_list,"[",idx_iter,"]",")",")",";") 
                                    } else {
                                        return [__array_op_rval__408,".","push","(",(preamble && preamble["0"])," ",body_function_ref,"(",element_list,"[",idx_iter,"]",")",")",";"]
                                    }
                                })();
                                let __BREAK__FLAG__=false;
                                for(let __iter__404 in __elements__405) {
                                    __array__407.push(await __for_body__406(__elements__405[__iter__404]));
                                    if(__BREAK__FLAG__) {
                                         __array__407.pop();
                                        break;
                                        
                                    }
                                }return __array__407;
                                 
                            })();
                            await (async function() {
                                let __for_body__411=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__412=[],__elements__410=["if","(",break_out,")"," ","{"," ",collector_ref,".","pop","()",";","break",";","}"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__409 in __elements__410) {
                                    __array__412.push(await __for_body__411(__elements__410[__iter__409]));
                                    if(__BREAK__FLAG__) {
                                         __array__412.pop();
                                        break;
                                        
                                    }
                                }return __array__412;
                                 
                            })();
                            return (acc).push("}")
                        }
                    }
                } ();
                (acc).push("return");
                (acc).push(" ");
                (acc).push(collector_ref);
                (acc).push(";");
                return acc
            };
            compile_while=async function(tokens,ctx) {
                let acc;
                let idx;
                let preamble;
                let test_condition;
                let complex_test_ques_;
                let test_condition_ref;
                let body;
                let body_ref;
                let prebuild;
                acc=[];
                idx=0;
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                preamble=await calling_preamble(ctx);
                test_condition=(tokens && tokens["1"]);
                complex_test_ques_=await not((test_condition && test_condition["ref"]));
                test_condition_ref=await gen_temp_name("test_condition");
                body=(tokens && tokens["2"]);
                body_ref=await gen_temp_name("body_ref");
                prebuild=[];
                ;
                await set_new_completion_scope(ctx);
                await set_ctx(ctx,break_out,true);
                if (check_true (complex_test_ques_)){
                    {
                        (prebuild).push(await (async function(){
                             return await compile(await build_fn_with_assignment(test_condition_ref,(test_condition && test_condition["val"]),null,ctx),ctx) 
                        })())
                    }
                };
                (prebuild).push(await (async function(){
                     return await compile(await build_fn_with_assignment(body_ref,(body && body["val"]),null,ctx),ctx) 
                })());
                await (async function() {
                    let __for_body__415=async function(t) {
                        return (prebuild).push(t)
                    };
                    let __array__416=[],__elements__414=["let"," ",break_out,"=","false",";"];
                    let __BREAK__FLAG__=false;
                    for(let __iter__413 in __elements__414) {
                        __array__416.push(await __for_body__415(__elements__414[__iter__413]));
                        if(__BREAK__FLAG__) {
                             __array__416.pop();
                            break;
                            
                        }
                    }return __array__416;
                     
                })();
                if (check_true (complex_test_ques_)){
                    await (async function() {
                        let __for_body__419=async function(t) {
                            return (prebuild).push(t)
                        };
                        let __array__420=[],__elements__418=["while","(",(preamble && preamble["0"])," ",test_condition_ref,"()",")"," ","{"," ",(preamble && preamble["0"])," ",body_ref,"()",";"," ","if","(",break_out,")"," ","{"," ","break",";","}","}"," ","",";"];
                        let __BREAK__FLAG__=false;
                        for(let __iter__417 in __elements__418) {
                            __array__420.push(await __for_body__419(__elements__418[__iter__417]));
                            if(__BREAK__FLAG__) {
                                 __array__420.pop();
                                break;
                                
                            }
                        }return __array__420;
                         
                    })()
                } else {
                    await (async function() {
                        let __for_body__423=async function(t) {
                            return (prebuild).push(t)
                        };
                        let __array__424=[],__elements__422=["while","(",await (async function(){
                             return await compile(test_condition,ctx) 
                        })(),")"," {"," ",(preamble && preamble["0"])," ",body_ref,"()",";"," ","if","(",break_out,")"," ","{"," ","break",";","}","}"," ","",";"];
                        let __BREAK__FLAG__=false;
                        for(let __iter__421 in __elements__422) {
                            __array__424.push(await __for_body__423(__elements__422[__iter__421]));
                            if(__BREAK__FLAG__) {
                                 __array__424.pop();
                                break;
                                
                            }
                        }return __array__424;
                         
                    })()
                };
                await (async function() {
                    let __for_body__427=async function(t) {
                        return (acc).push(t)
                    };
                    let __array__428=[],__elements__426=[(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()","{"," ",prebuild,"}",")","()"];
                    let __BREAK__FLAG__=false;
                    for(let __iter__425 in __elements__426) {
                        __array__428.push(await __for_body__427(__elements__426[__iter__425]));
                        if(__BREAK__FLAG__) {
                             __array__428.pop();
                            break;
                            
                        }
                    }return __array__428;
                     
                })();
                return acc
            };
            compile_for_with=async function(tokens,ctx,preamble) {
                preamble=await calling_preamble(ctx);
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                ;
                await set_new_completion_scope(ctx);
                return [(preamble && preamble["2"]),(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()"," ","{",await compile_for_with_inner(tokens,ctx,preamble)," ","}",")","()"]
            };
            compile_for_with_inner=async function(tokens,ctx,preamble) {
                let acc;
                let idx;
                let stmts;
                let iter_ref;
                let idx_iters;
                let generator_expression;
                let body_function_ref;
                let prebuild;
                let for_args;
                let iterator_ref;
                let elements;
                let iter_count;
                let for_body;
                let body_is_block_ques_;
                acc=[];
                idx=0;
                stmts=[];
                iter_ref=await gen_temp_name("iter");
                idx_iters=[];
                generator_expression=await gen_temp_name("elements");
                body_function_ref=await gen_temp_name("for_body");
                prebuild=[];
                for_args=(tokens && tokens["1"] && tokens["1"]["val"]);
                iterator_ref=(for_args && for_args["0"]);
                elements=await last(for_args);
                iter_count=await (async function(){
                    if (check_true (for_args)){
                        return ((for_args && for_args.length)- 1)
                    } else {
                        return 0
                    }
                })();
                for_body=(tokens && tokens["2"]);
                body_is_block_ques_=await is_block_ques_((for_body && for_body["val"]));
                if (check_true ((iter_count<1))){
                    {
                        throw new SyntaxError("Invalid for_each arguments");
                        
                    }
                };
                await (async function() {
                    let __for_body__431=async function(iter_ref) {
                        (idx_iters).push(for_args[iter_ref]);
                        return await set_ctx(ctx,await clean_quoted_reference(await (async function(){
                            let __targ__433=await last(idx_iters);
                            if (__targ__433){
                                 return(__targ__433)["name"]
                            } 
                        })()),ArgumentType)
                    };
                    let __array__432=[],__elements__430=await (await Environment.get_global("range"))(iter_count);
                    let __BREAK__FLAG__=false;
                    for(let __iter__429 in __elements__430) {
                        __array__432.push(await __for_body__431(__elements__430[__iter__429]));
                        if(__BREAK__FLAG__) {
                             __array__432.pop();
                            break;
                            
                        }
                    }return __array__432;
                     
                })();
                await set_ctx(ctx,generator_expression,"arg");
                if (check_true (await not(body_is_block_ques_))){
                    {
                        for_body=await make_do_block(for_body)
                    }
                };
                prebuild=await build_fn_with_assignment(body_function_ref,(for_body && for_body["val"]),idx_iters,ctx);
                await async function(){
                    ctx["block_step"]=0;
                    return ctx;
                    
                }();
                await async function(){
                    ctx["return_last_value"]=true;
                    return ctx;
                    
                }();
                (acc).push(await (async function(){
                     return await compile(prebuild,ctx) 
                })());
                await (async function() {
                    let __for_body__438=async function(t) {
                        return (acc).push(t)
                    };
                    let __array__439=[],__elements__437=["let"," ",break_out,"=","false",";"];
                    let __BREAK__FLAG__=false;
                    for(let __iter__436 in __elements__437) {
                        __array__439.push(await __for_body__438(__elements__437[__iter__436]));
                        if(__BREAK__FLAG__) {
                             __array__439.pop();
                            break;
                            
                        }
                    }return __array__439;
                     
                })();
                await set_ctx(ctx,body_function_ref,AsyncFunction);
                await async function(){
                    if (check_true ((((for_args && for_args.length)===2)&& await not(((for_args && for_args["1"]) instanceof Array))))) {
                        {
                            await (async function() {
                                let __for_body__442=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__443=[],__elements__441=["for"," ",(preamble && preamble["0"])," ","(","const"," ",iter_ref," ","of"," ",await compile_wrapper_fn(elements,ctx),")"," ","{"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__440 in __elements__441) {
                                    __array__443.push(await __for_body__442(__elements__441[__iter__440]));
                                    if(__BREAK__FLAG__) {
                                         __array__443.pop();
                                        break;
                                        
                                    }
                                }return __array__443;
                                 
                            })();
                            await (async function() {
                                let __for_body__446=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__447=[],__elements__445=await (async function(){
                                    let __array_op_rval__448=(preamble && preamble["0"]);
                                     if (__array_op_rval__448 instanceof Function){
                                        return await __array_op_rval__448(" ",body_function_ref,"(",iter_ref,")",";") 
                                    } else {
                                        return [__array_op_rval__448," ",body_function_ref,"(",iter_ref,")",";"]
                                    }
                                })();
                                let __BREAK__FLAG__=false;
                                for(let __iter__444 in __elements__445) {
                                    __array__447.push(await __for_body__446(__elements__445[__iter__444]));
                                    if(__BREAK__FLAG__) {
                                         __array__447.pop();
                                        break;
                                        
                                    }
                                }return __array__447;
                                 
                            })();
                            await (async function() {
                                let __for_body__451=async function(t) {
                                    return (acc).push(t)
                                };
                                let __array__452=[],__elements__450=["if","(",break_out,")"," ","break",";"];
                                let __BREAK__FLAG__=false;
                                for(let __iter__449 in __elements__450) {
                                    __array__452.push(await __for_body__451(__elements__450[__iter__449]));
                                    if(__BREAK__FLAG__) {
                                         __array__452.pop();
                                        break;
                                        
                                    }
                                }return __array__452;
                                 
                            })();
                            return (acc).push("}")
                        }
                    }
                } ();
                return acc
            };
            silence=async function() {
                return false
            };
            verbosity=silence;
            check_verbosity=async function(ctx) {
                return await Environment["get_global"].call(Environment,"__VERBOSITY__")
            };
            declare_log=await (async function(){
                if (check_true ((opts && opts["quiet_mode"]))){
                    return log
                } else {
                    return await defclog({
                        prefix:"DECLARE",color:"white",background:"black"
                    })
                }
            })();
            compile_declare=async function(tokens,ctx) {
                let expressions;
                let targeted;
                let acc;
                let source;
                let details;
                let sanitized_name;
                let declaration;
                let dec_struct;
                expressions=await (await Environment.get_global("rest"))(tokens);
                targeted=null;
                acc=[];
                source=null;
                details=null;
                sanitized_name=null;
                declaration=null;
                dec_struct=null;
                await (async function() {
                    let __for_body__455=async function(exp) {
                        declaration=(exp && exp["val"] && exp["val"]["0"] && exp["val"]["0"]["name"]);
                        targeted=await (await Environment.get_global("rest"))((exp && exp["val"]));
                        if (check_true (await (async function(){
                            let __array_op_rval__457=verbosity;
                             if (__array_op_rval__457 instanceof Function){
                                return await __array_op_rval__457(ctx) 
                            } else {
                                return [__array_op_rval__457,ctx]
                            }
                        })())){
                            {
                                await declare_log("declaration: ",declaration,"targeted: ",await (async function(){
                                     return await (await Environment.get_global("each"))(targeted,"name") 
                                })(),targeted)
                            }
                        };
                        return await async function(){
                            if (check_true ((declaration==="toplevel"))) {
                                {
                                    await async function(){
                                        opts["root_environment"]=(targeted && targeted["0"]);
                                        return opts;
                                        
                                    }();
                                    if (check_true ((opts && opts["root_environment"]))){
                                        return env_ref=""
                                    } else {
                                        return env_ref="Environment."
                                    }
                                }
                            } else if (check_true ((declaration==="include"))) {
                                {
                                    return await (async function() {
                                        let __for_body__461=async function(name) {
                                            sanitized_name=await sanitize_js_ref_name(name);
                                            dec_struct=await get_declaration_details(ctx,name);
                                            if (check_true (dec_struct)){
                                                {
                                                    await (async function() {
                                                        let __for_body__465=async function(t) {
                                                            return (acc).push(t)
                                                        };
                                                        let __array__466=[],__elements__464=["let"," ",sanitized_name,"="];
                                                        let __BREAK__FLAG__=false;
                                                        for(let __iter__463 in __elements__464) {
                                                            __array__466.push(await __for_body__465(__elements__464[__iter__463]));
                                                            if(__BREAK__FLAG__) {
                                                                 __array__466.pop();
                                                                break;
                                                                
                                                            }
                                                        }return __array__466;
                                                         
                                                    })();
                                                    await async function(){
                                                        if (check_true (((dec_struct && dec_struct["value"]) instanceof Function&& await (async function(){
                                                            let __targ__468=await (async function(){
                                                                let __targ__467=(Environment && Environment["definitions"]);
                                                                if (__targ__467){
                                                                     return(__targ__467)[name]
                                                                } 
                                                            })();
                                                            if (__targ__468){
                                                                 return(__targ__468)["fn_body"]
                                                            } 
                                                        })()))) {
                                                            {
                                                                details=await (async function(){
                                                                    let __targ__469=(Environment && Environment["definitions"]);
                                                                    if (__targ__469){
                                                                         return(__targ__469)[name]
                                                                    } 
                                                                })();
                                                                source=("(fn "+ (details && details["fn_args"])+ " "+ (details && details["fn_body"])+ ")");
                                                                source=await (async function(){
                                                                     return await compile(await tokenize(await (async function(){
                                                                         return await (await Environment.get_global("read_lisp"))(source) 
                                                                    })(),ctx),ctx,1000) 
                                                                })();
                                                                (acc).push(source);
                                                                return await set_ctx(ctx,name,AsyncFunction)
                                                            }
                                                        } else if (check_true ((dec_struct && dec_struct["value"]) instanceof Function)) {
                                                            {
                                                                (acc).push(await (async function() {
                                                                    {
                                                                         let __call_target__=await (dec_struct && dec_struct["value"])["toString"](), __call_method__="replace";
                                                                        return await __call_target__[__call_method__].call(__call_target__,"\n","")
                                                                    } 
                                                                })());
                                                                await set_ctx(ctx,name,AsyncFunction)
                                                            }
                                                        } else {
                                                            {
                                                                (acc).push(await (dec_struct && dec_struct["value"])["toString"]());
                                                                await set_ctx(ctx,name,ArgumentType)
                                                            }
                                                        }
                                                    } ();
                                                    (acc).push(";")
                                                }
                                            };
                                            await set_declaration(ctx,name,"inlined",true);
                                            if (check_true ((("undefined"===await (async function(){
                                                let __targ__470=await get_declarations(ctx,name);
                                                if (__targ__470){
                                                     return(__targ__470)["type"]
                                                } 
                                            })())&& (dec_struct && dec_struct["value"]) instanceof Function))){
                                                return await set_declaration(ctx,name,"type",Function)
                                            }
                                        };
                                        let __array__462=[],__elements__460=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__459 in __elements__460) {
                                            __array__462.push(await __for_body__461(__elements__460[__iter__459]));
                                            if(__BREAK__FLAG__) {
                                                 __array__462.pop();
                                                break;
                                                
                                            }
                                        }return __array__462;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="verbose"))) {
                                {
                                    let verbosity_level=await parseInt(await first(await (async function(){
                                         return await (await Environment.get_global("each"))(targeted,"name") 
                                    })()));
                                    ;
                                    if (check_true (await not(await isNaN(verbosity_level)))){
                                        {
                                            if (check_true ((verbosity_level>0))){
                                                await set_ctx(ctx,"__VERBOSITY__",verbosity_level)
                                            } else {
                                                {
                                                    await declare_log("verbosity: turned off");
                                                    verbosity=silence;
                                                    await set_ctx(ctx,"__VERBOSITY__",null)
                                                }
                                            };
                                            verbosity=check_verbosity;
                                            return await declare_log("compiler: verbosity set: ",await (async function(){
                                                let __array_op_rval__471=verbosity;
                                                 if (__array_op_rval__471 instanceof Function){
                                                    return await __array_op_rval__471(ctx) 
                                                } else {
                                                    return [__array_op_rval__471,ctx]
                                                }
                                            })())
                                        }
                                    } else {
                                        return (warnings).push("invalid verbosity declaration, expected number, received ")
                                    }
                                }
                            } else if (check_true ((declaration==="local"))) {
                                return await (async function() {
                                    let __for_body__474=async function(name) {
                                        dec_struct=await get_declaration_details(ctx,name);
                                        return await set_ctx(ctx,name,(dec_struct && dec_struct["value"]))
                                    };
                                    let __array__475=[],__elements__473=await (async function(){
                                         return await (await Environment.get_global("each"))(targeted,"name") 
                                    })();
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__472 in __elements__473) {
                                        __array__475.push(await __for_body__474(__elements__473[__iter__472]));
                                        if(__BREAK__FLAG__) {
                                             __array__475.pop();
                                            break;
                                            
                                        }
                                    }return __array__475;
                                     
                                })()
                            } else if (check_true ((declaration==="function"))) {
                                {
                                    return await (async function() {
                                        let __for_body__478=async function(name) {
                                            return await set_declaration(ctx,name,"type",Function)
                                        };
                                        let __array__479=[],__elements__477=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__476 in __elements__477) {
                                            __array__479.push(await __for_body__478(__elements__477[__iter__476]));
                                            if(__BREAK__FLAG__) {
                                                 __array__479.pop();
                                                break;
                                                
                                            }
                                        }return __array__479;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="fn"))) {
                                {
                                    return await (async function() {
                                        let __for_body__482=async function(name) {
                                            return await set_declaration(ctx,name,"type",AsyncFunction)
                                        };
                                        let __array__483=[],__elements__481=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__480 in __elements__481) {
                                            __array__483.push(await __for_body__482(__elements__481[__iter__480]));
                                            if(__BREAK__FLAG__) {
                                                 __array__483.pop();
                                                break;
                                                
                                            }
                                        }return __array__483;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="array"))) {
                                {
                                    return await (async function() {
                                        let __for_body__486=async function(name) {
                                            return await set_declaration(ctx,name,"type",Array)
                                        };
                                        let __array__487=[],__elements__485=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__484 in __elements__485) {
                                            __array__487.push(await __for_body__486(__elements__485[__iter__484]));
                                            if(__BREAK__FLAG__) {
                                                 __array__487.pop();
                                                break;
                                                
                                            }
                                        }return __array__487;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="number"))) {
                                {
                                    return await (async function() {
                                        let __for_body__490=async function(name) {
                                            return await set_declaration(ctx,name,"type",NumberType)
                                        };
                                        let __array__491=[],__elements__489=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__488 in __elements__489) {
                                            __array__491.push(await __for_body__490(__elements__489[__iter__488]));
                                            if(__BREAK__FLAG__) {
                                                 __array__491.pop();
                                                break;
                                                
                                            }
                                        }return __array__491;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="string"))) {
                                {
                                    return await (async function() {
                                        let __for_body__494=async function(name) {
                                            return await set_declaration(ctx,name,"type",StringType)
                                        };
                                        let __array__495=[],__elements__493=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__492 in __elements__493) {
                                            __array__495.push(await __for_body__494(__elements__493[__iter__492]));
                                            if(__BREAK__FLAG__) {
                                                 __array__495.pop();
                                                break;
                                                
                                            }
                                        }return __array__495;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="boolean"))) {
                                {
                                    return await (async function() {
                                        let __for_body__498=async function(name) {
                                            return await set_declaration(ctx,name,"type",Boolean)
                                        };
                                        let __array__499=[],__elements__497=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__496 in __elements__497) {
                                            __array__499.push(await __for_body__498(__elements__497[__iter__496]));
                                            if(__BREAK__FLAG__) {
                                                 __array__499.pop();
                                                break;
                                                
                                            }
                                        }return __array__499;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="regexp"))) {
                                {
                                    return await (async function() {
                                        let __for_body__502=async function(name) {
                                            return await set_declaration(ctx,name,"type",RegExp)
                                        };
                                        let __array__503=[],__elements__501=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__500 in __elements__501) {
                                            __array__503.push(await __for_body__502(__elements__501[__iter__500]));
                                            if(__BREAK__FLAG__) {
                                                 __array__503.pop();
                                                break;
                                                
                                            }
                                        }return __array__503;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="object"))) {
                                {
                                    return await (async function() {
                                        let __for_body__506=async function(name) {
                                            return await set_declaration(ctx,name,"type",Object)
                                        };
                                        let __array__507=[],__elements__505=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__504 in __elements__505) {
                                            __array__507.push(await __for_body__506(__elements__505[__iter__504]));
                                            if(__BREAK__FLAG__) {
                                                 __array__507.pop();
                                                break;
                                                
                                            }
                                        }return __array__507;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="global"))) {
                                {
                                    return await (async function() {
                                        let __for_body__510=async function(name) {
                                            return await set_declaration(ctx,name,"location","global")
                                        };
                                        let __array__511=[],__elements__509=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"name") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__508 in __elements__509) {
                                            __array__511.push(await __for_body__510(__elements__509[__iter__508]));
                                            if(__BREAK__FLAG__) {
                                                 __array__511.pop();
                                                break;
                                                
                                            }
                                        }return __array__511;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="optimize"))) {
                                {
                                    return await (async function() {
                                        let __for_body__514=async function(factor) {
                                            factor=await (async function(){
                                                 return await (await Environment.get_global("each"))(factor,"name") 
                                            })();
                                            return await async function(){
                                                if (check_true (((factor && factor["0"])==="safety"))) {
                                                    return await set_declaration(ctx,"__SAFETY__","level",(factor && factor["1"]))
                                                }
                                            } ()
                                        };
                                        let __array__515=[],__elements__513=await (async function(){
                                             return await (await Environment.get_global("each"))(targeted,"val") 
                                        })();
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__512 in __elements__513) {
                                            __array__515.push(await __for_body__514(__elements__513[__iter__512]));
                                            if(__BREAK__FLAG__) {
                                                 __array__515.pop();
                                                break;
                                                
                                            }
                                        }return __array__515;
                                         
                                    })()
                                }
                            } else if (check_true ((declaration==="namespace"))) {
                                {
                                    if (check_true (await not(((targeted && targeted.length)===1)))){
                                        {
                                            throw new SyntaxError("namespace declaration requires exactly 1 value");
                                            
                                        }
                                    };
                                    if (check_true (await get_ctx(ctx,"__IN_LAMBDA__"))){
                                        {
                                            throw new SyntaxError("namespace compiler declaration must be toplevel");
                                            
                                        }
                                    };
                                    target_namespace=(targeted && targeted["0"] && targeted["0"]["name"]);
                                    return Environment=await Environment["get_namespace_handle"].call(Environment,(targeted && targeted["0"] && targeted["0"]["name"]))
                                }
                            } else {
                                {
                                    (warnings).push(("unknown declaration directive: "+ declaration));
                                    return await (await Environment.get_global("warn"))(("compiler: unknown declaration directive: "+ declaration))
                                }
                            }
                        } ()
                    };
                    let __array__456=[],__elements__454=expressions;
                    let __BREAK__FLAG__=false;
                    for(let __iter__453 in __elements__454) {
                        __array__456.push(await __for_body__455(__elements__454[__iter__453]));
                        if(__BREAK__FLAG__) {
                             __array__456.pop();
                            break;
                            
                        }
                    }return __array__456;
                     
                })();
                return acc
            };
            safety_level=async function(ctx) {
                if (check_true (ctx)){
                    {
                        let safety=await get_declarations(ctx,"__SAFETY__");
                        ;
                        if (check_true (safety)){
                            return (safety && safety["level"])
                        } else {
                            return default_safety_level
                        }
                    }
                }
            };
            get_scoped_type=async function(name) {
                let rtype;
                rtype=await get_ctx(ctx,name);
                if (check_true ((undefined===rtype))){
                    return await sub_type(await get_lisp_ctx(ctx,name))
                } else {
                    return await sub_type(rtype)
                }
            };
            compile_scoped_reference=async function(tokens,ctx) {
                let acc;
                let idx;
                let ref_type;
                let rval;
                let stmt;
                let preamble;
                let sr_log;
                let val;
                let call_type;
                let token;
                acc=[];
                idx=0;
                ref_type=null;
                rval=null;
                stmt=null;
                preamble=await calling_preamble(ctx);
                sr_log=await (async function(){
                     return await defclog({
                        prefix:("compile_scoped_reference ("+ ((ctx && ctx["block_id"])|| "-")+ "):"),background:"steelblue",color:"white"
                    }) 
                })();
                val=null;
                call_type=await (async function(){
                     return await async function(){
                        if (check_true (await not((tokens && tokens["0"] && tokens["0"]["ref"])))) {
                            return "literal"
                        } else if (check_true (await get_ctx_val(ctx,(tokens && tokens["0"] && tokens["0"]["name"])))) {
                            return "local"
                        } else if (check_true (await get_lisp_ctx(ctx,(tokens && tokens["0"] && tokens["0"]["name"])))) {
                            return "lisp"
                        }
                    } () 
                })();
                token=null;
                ;
                await async function(){
                    if (check_true ((call_type==="lisp"))) {
                        return ref_type=await get_lisp_ctx(ctx,(tokens && tokens["0"] && tokens["0"]["name"]))
                    } else if (check_true ((call_type==="local"))) {
                        ref_type=await get_ctx_val(ctx,(tokens && tokens["0"] && tokens["0"]["name"]))
                    } else {
                        ref_type=ArgumentType
                    }
                } ();
                await async function(){
                    if (check_true ((ref_type===AsyncFunction))) {
                        return ref_type="AsyncFunction"
                    } else if (check_true ((ref_type===Expression))) {
                        ref_type=ArgumentType
                    } else if (check_true ((ref_type===Function))) {
                        ref_type="Function"
                    } else if (check_true ((ref_type===Array))) {
                        ref_type="Array"
                    } else if (check_true ((ref_type===NilType))) {
                        ref_type="nil"
                    } else if (check_true ((ref_type===NumberType))) {
                        ref_type=ArgumentType
                    } else if (check_true ((ref_type===StringType))) {
                        ref_type="StringType"
                    } else if (check_true ((ref_type===ArgumentType))) {
                        true
                    } else {
                        ref_type=await sub_type(ref_type)
                    }
                } ();
                if (check_true (await (async function(){
                    let __array_op_rval__516=verbosity;
                     if (__array_op_rval__516 instanceof Function){
                        return await __array_op_rval__516(ctx) 
                    } else {
                        return [__array_op_rval__516,ctx]
                    }
                })())){
                    {
                        await sr_log("SYMBOL: ",(tokens && tokens["0"] && tokens["0"]["name"]),"  found as:",call_type," of type:",ref_type,"sanitized as: ",await (async function(){
                            if (check_true (("local"===call_type))){
                                return (" local sanitized to: "+ await sanitize_js_ref_name((tokens && tokens["0"] && tokens["0"]["name"])))
                            }
                        })())
                    }
                };
                rval=await (async function(){
                     return await async function(){
                        if (check_true ((ref_type==="AsyncFunction"))) {
                            {
                                (acc).push((preamble && preamble["0"]));
                                (acc).push(" ");
                                (acc).push(await (async function(){
                                    if (check_true ((call_type==="lisp"))){
                                        return await compile_lisp_scoped_reference((tokens && tokens["0"] && tokens["0"]["name"]),ctx)
                                    } else {
                                        return await sanitize_js_ref_name((tokens && tokens["0"] && tokens["0"]["name"]))
                                    }
                                })());
                                (acc).push("(");
                                await (async function(){
                                     let __test_condition__517=async function() {
                                        return (idx<((tokens && tokens.length)- 1))
                                    };
                                    let __body_ref__518=async function() {
                                        idx+=1;
                                        token=tokens[idx];
                                        stmt=await compile_wrapper_fn(token,ctx,new Object());
                                        (acc).push(stmt);
                                        if (check_true ((idx<((tokens && tokens.length)- 1)))){
                                            {
                                                return (acc).push(",")
                                            }
                                        }
                                    };
                                    let __BREAK__FLAG__=false;
                                    while(await __test_condition__517()) {
                                         await __body_ref__518();
                                         if(__BREAK__FLAG__) {
                                             break;
                                            
                                        }
                                    } ;
                                    
                                })();
                                (acc).push(")");
                                return acc
                            }
                        } else if (check_true ((ref_type==="Function"))) {
                            {
                                (acc).push((preamble && preamble["0"]));
                                (acc).push(" ");
                                (acc).push(await (async function(){
                                    if (check_true ((call_type==="lisp"))){
                                        return await compile_lisp_scoped_reference((tokens && tokens["0"] && tokens["0"]["name"]),ctx)
                                    } else {
                                        return await sanitize_js_ref_name((tokens && tokens["0"] && tokens["0"]["name"]))
                                    }
                                })());
                                (acc).push("(");
                                await (async function(){
                                     let __test_condition__519=async function() {
                                        return (idx<((tokens && tokens.length)- 1))
                                    };
                                    let __body_ref__520=async function() {
                                        idx+=1;
                                        token=tokens[idx];
                                        stmt=await compile_wrapper_fn(token,ctx,new Object());
                                        (acc).push(stmt);
                                        if (check_true ((idx<((tokens && tokens.length)- 1)))){
                                            {
                                                return (acc).push(",")
                                            }
                                        }
                                    };
                                    let __BREAK__FLAG__=false;
                                    while(await __test_condition__519()) {
                                         await __body_ref__520();
                                         if(__BREAK__FLAG__) {
                                             break;
                                            
                                        }
                                    } ;
                                    
                                })();
                                (acc).push(")");
                                return acc
                            }
                        } else if (check_true (((call_type==="local")&& ((ref_type==="NumberType")|| (ref_type==="StringType")|| (ref_type==="Boolean"))))) {
                            {
                                (acc).push((tokens && tokens["0"] && tokens["0"]["name"]));
                                return acc
                            }
                        } else if (check_true (((call_type==="local")&& await not((ref_type===ArgumentType))&& (tokens instanceof Array)))) {
                            {
                                val=await get_ctx_val(ctx,(tokens && tokens["0"] && tokens["0"]["name"]));
                                (acc).push(val);
                                return acc
                            }
                        } else if (check_true (((ref_type===ArgumentType)&& (tokens instanceof Array)))) {
                            {
                                (acc).push("[");
                                await (async function(){
                                     let __test_condition__521=async function() {
                                        return (idx<(tokens && tokens.length))
                                    };
                                    let __body_ref__522=async function() {
                                        token=tokens[idx];
                                        (acc).push(await (async function(){
                                             return await compile(token,ctx) 
                                        })());
                                        if (check_true ((idx<((tokens && tokens.length)- 1)))){
                                            {
                                                (acc).push(",")
                                            }
                                        };
                                        return idx+=1
                                    };
                                    let __BREAK__FLAG__=false;
                                    while(await __test_condition__521()) {
                                         await __body_ref__522();
                                         if(__BREAK__FLAG__) {
                                             break;
                                            
                                        }
                                    } ;
                                    
                                })();
                                (acc).push("]");
                                return acc
                            }
                        } else if (check_true ((ref_type===ArgumentType))) {
                            {
                                (acc).push((tokens && tokens["0"] && tokens["0"]["name"]));
                                return acc
                            }
                        } else if (check_true ((ref_type==="undefined"))) {
                            {
                                throw new ReferenceError(("unknown reference: "+ (tokens && tokens["0"] && tokens["0"]["name"])));
                                
                            }
                        } else if (check_true ((call_type==="lisp"))) {
                            {
                                return await compile_lisp_scoped_reference((tokens && tokens["0"] && tokens["0"]["name"]),ctx)
                            }
                        } else {
                            {
                                (acc).push((tokens && tokens["0"] && tokens["0"]["name"]));
                                return acc
                            }
                        }
                    } () 
                })();
                if (check_true (false)){
                    {
                        await async function(){
                            if (check_true (((ref_type==="AsyncFunction")|| (ref_type==="Function")))) {
                                return (acc).unshift({
                                    ctype:ref_type
                                })
                            }
                        } ()
                    }
                };
                return acc
            };
            compile_lisp_scoped_reference=async function(refname,ctx,defer_not_found) {
                let refval;
                let reftype;
                let declarations;
                let preamble;
                let basename;
                refval=await get_lisp_ctx(ctx,refname);
                reftype=await sub_type(refval);
                declarations=null;
                preamble=await calling_preamble(ctx);
                basename=await (await Environment.get_global("get_object_path"))(refname);
                ;
                declarations=await add(new Object(),await get_declarations(ctx,refname),await get_declaration_details(ctx,refname));
                if (check_true ((declarations && declarations["inlined"]))){
                    {
                        refname=await sanitize_js_ref_name(refname)
                    }
                };
                if (check_true ((((reftype==="StringType")|| (reftype==="String"))&& await not((refval===undefined))))){
                    {
                        refval="text"
                    }
                };
                return await async function(){
                    if (check_true (await contains_ques_((basename && basename["0"]),standard_types))) {
                        return refname
                    } else if (check_true ((declarations && declarations["inlined"]))) {
                        return refname
                    } else if (check_true (await not((refval===undefined)))) {
                        {
                            has_lisp_globals=true;
                            return [{
                                ctype:await (async function(){
                                    if (check_true ((await not(refval instanceof Function)&& (refval instanceof Object)))){
                                        return "object"
                                    } else {
                                        return refval
                                    }
                                })()
                            },"(",(preamble && preamble["0"])," ",env_ref,"get_global","(\"",refname,"\")",")"]
                        }
                    } else if (check_true (defer_not_found)) {
                        return ["(",env_ref,"get_global","(\"",refname,"\", ReferenceError)",")"]
                    } else {
                        {
                            throw new ReferenceError(("unknown lisp reference: "+ refname));
                            
                        }
                    }
                } ()
            };
            standard_types=await (async function(){
                let all_vals;
                all_vals=await (await Environment.get_global("make_set"))(await (async function(){
                     return await uniq(await conj(["AsyncFunction","check_true","LispSyntaxError","dlisp_environment_count","clone","super","Class","Environment","Expression","get_next_environment_id","subtype","lisp_writer","do_deferred_splice"],await (async function(){
                         return await object_methods(globalThis) 
                    })())) 
                })());
                await all_vals["delete"].call(all_vals,"length");
                return all_vals
            })();
            externals=await (await Environment.get_global("make_set"))(await (async function(){
                 return await object_methods(globalThis) 
            })());
            is_error=null;
            is_block_ques_=async function(tokens) {
                return (((tokens && tokens["0"] && tokens["0"]["type"])==="special")&& await contains_ques_((tokens && tokens["0"] && tokens["0"]["name"]),["do","progn"]))
            };
            is_complex_ques_=async function(tokens) {
                let rval;
                rval=(await is_block_ques_(tokens)|| (((tokens && tokens["type"])==="arr")&& await is_block_ques_((tokens && tokens["val"])))|| (((tokens && tokens["0"] && tokens["0"]["type"])==="special")&& (((tokens && tokens["0"] && tokens["0"]["name"])==="let")|| ((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["name"])==="if")|| ((tokens && tokens["val"] && tokens["val"]["0"] && tokens["val"]["0"]["name"])==="let"))));
                return rval
            };
            is_form_ques_=async function(token) {
                return (((token && token["val"]) instanceof Array)|| await is_block_ques_((token && token["val"])))
            };
            op_lookup=await ( async function(){
                let __obj__523=new Object();
                __obj__523["+"]=infix_ops;
                __obj__523["*"]=infix_ops;
                __obj__523["/"]=infix_ops;
                __obj__523["-"]=infix_ops;
                __obj__523["**"]=infix_ops;
                __obj__523["%"]=infix_ops;
                __obj__523["<<"]=infix_ops;
                __obj__523[">>"]=infix_ops;
                __obj__523["and"]=infix_ops;
                __obj__523["or"]=infix_ops;
                __obj__523["apply"]=compile_apply;
                __obj__523["call"]=compile_call;
                __obj__523["->"]=compile_call;
                __obj__523["set_prop"]=compile_set_prop;
                __obj__523["prop"]=compile_prop;
                __obj__523["="]=compile_assignment;
                __obj__523["setq"]=compile_assignment;
                __obj__523["=="]=compile_compare;
                __obj__523["eq"]=compile_compare;
                __obj__523[">"]=compile_compare;
                __obj__523["<"]=compile_compare;
                __obj__523["<="]=compile_compare;
                __obj__523[">="]=compile_compare;
                __obj__523["return"]=compile_return;
                __obj__523["new"]=compile_new;
                __obj__523["do"]=compile_block;
                __obj__523["progn"]=compile_block;
                __obj__523["progl"]=async function(tokens,ctx) {
                    return await compile_block(tokens,ctx,{
                        no_scope_boundary:true,suppress_return:true,force_no_new_ctx:true
                    })
                };
                __obj__523["break"]=compile_break;
                __obj__523["inc"]=compile_val_mod;
                __obj__523["dec"]=compile_val_mod;
                __obj__523["try"]=compile_try;
                __obj__523["throw"]=compile_throw;
                __obj__523["let"]=compile_let;
                __obj__523["defvar"]=compile_defvar;
                __obj__523["defconst"]=async function(tokens,ctx) {
                    if (check_true (await get_ctx(ctx,"__LOCAL_SCOPE__"))){
                        return await compile_defvar(tokens,ctx,{
                            constant:true
                        })
                    } else {
                        return await compile_set_global(tokens,ctx,{
                            constant:true
                        })
                    }
                };
                __obj__523["while"]=compile_while;
                __obj__523["for_each"]=compile_for_each;
                __obj__523["if"]=compile_if;
                __obj__523["cond"]=compile_cond;
                __obj__523["fn"]=compile_fn;
                __obj__523["lambda"]=compile_fn;
                __obj__523["function*"]=async function(tokens,ctx) {
                    return await compile_fn(tokens,ctx,{
                        generator:true
                    })
                };
                __obj__523["defglobal"]=compile_set_global;
                __obj__523["list"]=compile_list;
                __obj__523["function"]=async function(tokens,ctx) {
                    return await compile_fn(tokens,ctx,{
                        synchronous:true
                    })
                };
                __obj__523["=>"]=async function(tokens,ctx) {
                    return await compile_fn(tokens,ctx,{
                        arrow:true
                    })
                };
                __obj__523["yield"]=compile_yield;
                __obj__523["for_with"]=compile_for_with;
                __obj__523["quotem"]=compile_quotem;
                __obj__523["quote"]=compile_quote;
                __obj__523["quotel"]=compile_quotel;
                __obj__523["eval"]=compile_eval;
                __obj__523["jslambda"]=compile_jslambda;
                __obj__523["javascript"]=compile_javascript;
                __obj__523["instanceof"]=compile_instanceof;
                __obj__523["typeof"]=compile_typeof;
                __obj__523["unquotem"]=compile_unquotem;
                __obj__523["debug"]=compile_debug;
                __obj__523["declare"]=compile_declare;
                __obj__523["static_import"]=compile_import;
                __obj__523["dynamic_import"]=compile_dynamic_import;
                return __obj__523;
                
            })();
            comp_log=await (async function(){
                if (check_true (quiet_mode)){
                    return log
                } else {
                    return await defclog({
                        background:"LightSkyblue",color:"#000000"
                    })
                }
            })();
            last_source=null;
            output_validation=async function(output_str) {
                let rgx1;
                let rval;
                let lines;
                rgx1=new RegExp(",,|,\\)|:,");
                rval=await (await Environment.get_global("scan_str"))(rgx1,output_str);
                lines=null;
                if (check_true (((rval && rval.length)===0))){
                    return output_str
                } else {
                    {
                        await (async function() {
                            let __for_body__526=async function(issue) {
                                if (check_true (await not(await contains_ques_("RegExp",await output_str["substr"].call(output_str,((issue && issue["index"])- 10),20))))){
                                    {
                                        return console.log("compiler: bad character: ",await output_str["substr"].call(output_str,((issue && issue["index"])- 10),20))
                                    }
                                }
                            };
                            let __array__527=[],__elements__525=rval;
                            let __BREAK__FLAG__=false;
                            for(let __iter__524 in __elements__525) {
                                __array__527.push(await __for_body__526(__elements__525[__iter__524]));
                                if(__BREAK__FLAG__) {
                                     __array__527.pop();
                                    break;
                                    
                                }
                            }return __array__527;
                             
                        })();
                        return output_str
                    }
                }
            };
            compile_obj_literal=async function(tokens,ctx) {
                let acc;
                let idx;
                let stmt;
                let has_valid_key_literals;
                let token;
                let preamble;
                let key;
                let output_val;
                let tmp_name;
                let kvpair;
                let total_length;
                acc=[];
                idx=-1;
                stmt=null;
                has_valid_key_literals=true;
                token=null;
                preamble=await calling_preamble(ctx);
                key=null;
                output_val=null;
                tmp_name=null;
                ctx=await (async function(){
                     return await new_ctx(ctx) 
                })();
                kvpair=null;
                total_length=((tokens && tokens["val"] && tokens["val"]["length"])- 1);
                ;
                await async function(){
                    ctx["in_obj_literal"]=true;
                    return ctx;
                    
                }();
                await (async function() {
                    let __for_body__531=async function(token) {
                        if (check_true ((((token && token["type"])==="keyval")&& await check_invalid_js_ref((token && token.name))))){
                            {
                                has_valid_key_literals=false;
                                return __BREAK__FLAG__=true;
                                return
                            }
                        }
                    };
                    let __array__532=[],__elements__530=((tokens && tokens["val"])|| []);
                    let __BREAK__FLAG__=false;
                    for(let __iter__529 in __elements__530) {
                        __array__532.push(await __for_body__531(__elements__530[__iter__529]));
                        if(__BREAK__FLAG__) {
                             __array__532.pop();
                            break;
                            
                        }
                    }return __array__532;
                     
                })();
                if (check_true (has_valid_key_literals)){
                    if (check_true (((tokens && tokens["val"] && tokens["val"]["name"])==="{}"))){
                        return [{
                            ctype:"objliteral"
                        },"new Object()"]
                    } else {
                        {
                            (acc).push("{");
                            await (async function(){
                                 let __test_condition__533=async function() {
                                    return (idx<total_length)
                                };
                                let __body_ref__534=async function() {
                                    idx+=1;
                                    kvpair=await (async function(){
                                        let __targ__535=(tokens && tokens["val"]);
                                        if (__targ__535){
                                             return(__targ__535)[idx]
                                        } 
                                    })();
                                    key=await get_val((kvpair && kvpair["val"] && kvpair["val"]["0"]),ctx);
                                    if (check_true ((((key && key.length)===1)&& (await key["charCodeAt"]()===34)))){
                                        {
                                            key="'\"'"
                                        }
                                    };
                                    (acc).push(key);
                                    (acc).push(":");
                                    await set_ctx(ctx,"__LAMBDA_STEP__",-1);
                                    stmt=await compile_wrapper_fn((kvpair && kvpair["val"] && kvpair["val"]["1"]),ctx);
                                    await (await Environment.get_global("assert"))(stmt,"compile: obj literal value returned invalid/undefined value.");
                                    (acc).push(stmt);
                                    if (check_true ((idx<total_length))){
                                        {
                                            return (acc).push(",")
                                        }
                                    }
                                };
                                let __BREAK__FLAG__=false;
                                while(await __test_condition__533()) {
                                     await __body_ref__534();
                                     if(__BREAK__FLAG__) {
                                         break;
                                        
                                    }
                                } ;
                                
                            })();
                            (acc).push("}");
                            return [{
                                ctype:"objliteral"
                            },acc]
                        }
                    }
                } else {
                    {
                        tmp_name=await gen_temp_name("obj");
                        await (async function() {
                            let __for_body__538=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__539=[],__elements__537=await (async function(){
                                 return [{
                                    ctype:"statement"
                                },(preamble && preamble["0"])," ","("," ",(preamble && preamble["1"])," ","function","()","{","let"," ",tmp_name,"=","new"," ","Object","()",";"] 
                            })();
                            let __BREAK__FLAG__=false;
                            for(let __iter__536 in __elements__537) {
                                __array__539.push(await __for_body__538(__elements__537[__iter__536]));
                                if(__BREAK__FLAG__) {
                                     __array__539.pop();
                                    break;
                                    
                                }
                            }return __array__539;
                             
                        })();
                        await (async function(){
                             let __test_condition__540=async function() {
                                return (idx<total_length)
                            };
                            let __body_ref__541=async function() {
                                idx+=1;
                                kvpair=await (async function(){
                                    let __targ__542=(tokens && tokens["val"]);
                                    if (__targ__542){
                                         return(__targ__542)[idx]
                                    } 
                                })();
                                output_val=(await compile_wrapper_fn((kvpair && kvpair["val"] && kvpair["val"]["1"]),ctx)|| "null");
                                try {
                                    (""+ output_val)
                                } catch (__exception__543) {
                                    if (__exception__543 instanceof Error) {
                                        let e=__exception__543;
                                        {
                                            {
                                                output_val="null"
                                            }
                                        }
                                    }
                                };
                                return await (async function() {
                                    let __for_body__546=async function(t) {
                                        return (acc).push(t)
                                    };
                                    let __array__547=[],__elements__545=await (async function(){
                                        let __array_op_rval__548=tmp_name;
                                         if (__array_op_rval__548 instanceof Function){
                                            return await __array_op_rval__548("[","\"",await (async function(){
                                                 return await cl_encode_string(await get_val((kvpair && kvpair["val"] && kvpair["val"]["0"]),ctx)) 
                                            })(),"\"","]","=",output_val,";") 
                                        } else {
                                            return [__array_op_rval__548,"[","\"",await (async function(){
                                                 return await cl_encode_string(await get_val((kvpair && kvpair["val"] && kvpair["val"]["0"]),ctx)) 
                                            })(),"\"","]","=",output_val,";"]
                                        }
                                    })();
                                    let __BREAK__FLAG__=false;
                                    for(let __iter__544 in __elements__545) {
                                        __array__547.push(await __for_body__546(__elements__545[__iter__544]));
                                        if(__BREAK__FLAG__) {
                                             __array__547.pop();
                                            break;
                                            
                                        }
                                    }return __array__547;
                                     
                                })()
                            };
                            let __BREAK__FLAG__=false;
                            while(await __test_condition__540()) {
                                 await __body_ref__541();
                                 if(__BREAK__FLAG__) {
                                     break;
                                    
                                }
                            } ;
                            
                        })();
                        await (async function() {
                            let __for_body__551=async function(t) {
                                return (acc).push(t)
                            };
                            let __array__552=[],__elements__550=["return"," ",tmp_name,";","}",")","()"];
                            let __BREAK__FLAG__=false;
                            for(let __iter__549 in __elements__550) {
                                __array__552.push(await __for_body__551(__elements__550[__iter__549]));
                                if(__BREAK__FLAG__) {
                                     __array__552.pop();
                                    break;
                                    
                                }
                            }return __array__552;
                             
                        })();
                        return acc
                    }
                }
            };
            is_literal_ques_=async function(val) {
                return (await is_number_ques_(val)|| (val instanceof String || typeof val==='string')|| (false===val)|| (true===val))
            };
            comp_warn=await (async function(){
                 return await defclog({
                    prefix:"compile: [warn]:",background:"#fcffc8",color:"brown"
                }) 
            })();
            let compile=await __compile__5();
            ;
            compile_inner=async function(tokens,ctx,_cdepth) {
                let operator_type;
                let op_token;
                let rcv;
                let __op__558= async function(){
                    return null
                };
                let acc;
                let preamble;
                let tmp_name;
                let refval;
                let ref;
                {
                    operator_type=null;
                    op_token=null;
                    rcv=null;
                    let op=await __op__558();
                    ;
                    _cdepth=(_cdepth|| 100);
                    acc=[];
                    preamble=await calling_preamble(ctx);
                    tmp_name=null;
                    refval=null;
                    ref=null;
                    ;
                    try {
                        if (check_true ((null==ctx))){
                            {
                                await error_log("compile: nil ctx: ",tokens);
                                throw new Error("compile: nil ctx");
                                
                            }
                        } else {
                            return await async function(){
                                if (check_true ((await is_number_ques_(tokens)|| (tokens instanceof String || typeof tokens==='string')|| (await sub_type(tokens)==="Boolean")))) {
                                    return tokens
                                } else if (check_true (((tokens instanceof Array)&& (tokens && tokens["0"] && tokens["0"]["ref"])&& await not((await get_ctx(ctx,(tokens && tokens["0"] && tokens["0"]["name"]))===UnknownType))&& (op_lookup[(tokens && tokens["0"] && tokens["0"]["name"])]|| (Function===await get_ctx_val(ctx,(tokens && tokens["0"] && tokens["0"]["name"])))|| (AsyncFunction===await get_ctx_val(ctx,(tokens && tokens["0"] && tokens["0"]["name"])))|| ("function"===typeof await (async function(){
                                    let __targ__560=(root_ctx && root_ctx["defined_lisp_globals"]);
                                    if (__targ__560){
                                         return(__targ__560)[(tokens && tokens["0"] && tokens["0"]["name"])]
                                    } 
                                })())|| await get_lisp_ctx(ctx,(tokens && tokens["0"] && tokens["0"]["name"])) instanceof Function)))) {
                                    {
                                        op_token=await first(tokens);
                                        operator=op_token["name"];
                                        operator_type=op_token["val"];
                                        ref=op_token["ref"];
                                        op=op_lookup[operator];
                                        return await async function(){
                                            if (check_true (op)) {
                                                return (op)(tokens,ctx)
                                            } else if (check_true (await (async function(){
                                                let __targ__561=(Environment && Environment["inlines"]);
                                                if (__targ__561){
                                                     return(__targ__561)[operator]
                                                } 
                                            })())) {
                                                return await compile_inline(tokens,ctx)
                                            } else {
                                                return await compile_scoped_reference(tokens,ctx)
                                            }
                                        } ()
                                    }
                                } else if (check_true (((tokens instanceof Object)&& ((tokens && tokens["type"])==="objlit")))) {
                                    {
                                        return await compile_obj_literal(tokens,ctx)
                                    }
                                } else if (check_true ((tokens instanceof Array))) {
                                    {
                                        return await async function(){
                                            if (check_true (((tokens && tokens.length)===0))) {
                                                return [{
                                                    ctype:"array",is_literal:true
                                                },"[]"]
                                            } else {
                                                {
                                                    let is_operation;
                                                    let declared_type;
                                                    let prefix;
                                                    let symbolic_replacements;
                                                    let compiled_values;
                                                    is_operation=false;
                                                    declared_type=null;
                                                    prefix="";
                                                    ctx=await (async function(){
                                                         return await new_ctx(ctx) 
                                                    })();
                                                    symbolic_replacements=[];
                                                    compiled_values=[];
                                                    await set_new_completion_scope(ctx);
                                                    if (check_true (((tokens && tokens["0"] && tokens["0"]["ref"])&& ((tokens && tokens["0"] && tokens["0"]["val"]) instanceof String || typeof (tokens && tokens["0"] && tokens["0"]["val"])==='string')))){
                                                        {
                                                            declared_type=await get_declarations(ctx,(tokens && tokens["0"] && tokens["0"]["name"]))
                                                        }
                                                    };
                                                    rcv=await (async function(){
                                                         return await compile((tokens && tokens["0"]),ctx,await add(_cdepth,1)) 
                                                    })();
                                                    if (check_true (await (async function(){
                                                        let __array_op_rval__562=verbosity;
                                                         if (__array_op_rval__562 instanceof Function){
                                                            return await __array_op_rval__562(ctx) 
                                                        } else {
                                                            return [__array_op_rval__562,ctx]
                                                        }
                                                    })())){
                                                        {
                                                            await comp_log(("compile: "+ _cdepth+ " array: "),"potential operator: ",(tokens && tokens["0"] && tokens["0"]["name"]),"declarations: ",declared_type)
                                                        }
                                                    };
                                                    await (async function() {
                                                        let __for_body__565=async function(t) {
                                                            if (check_true (await not(await get_ctx_val(ctx,"__IN_LAMBDA__")))){
                                                                await set_ctx(ctx,"__LAMBDA_STEP__",0)
                                                            };
                                                            return (compiled_values).push(await compile_wrapper_fn(t,ctx))
                                                        };
                                                        let __array__566=[],__elements__564=await (await Environment.get_global("rest"))(tokens);
                                                        let __BREAK__FLAG__=false;
                                                        for(let __iter__563 in __elements__564) {
                                                            __array__566.push(await __for_body__565(__elements__564[__iter__563]));
                                                            if(__BREAK__FLAG__) {
                                                                 __array__566.pop();
                                                                break;
                                                                
                                                            }
                                                        }return __array__566;
                                                         
                                                    })();
                                                    await map(async function(compiled_element,idx) {
                                                        let inst;
                                                        inst=await (async function(){
                                                             return await async function(){
                                                                if (check_true ((((compiled_element && compiled_element["0"]) instanceof Object)&& await (async function(){
                                                                    let __targ__567=(compiled_element && compiled_element["0"]);
                                                                    if (__targ__567){
                                                                         return(__targ__567)["ctype"]
                                                                    } 
                                                                })()))) {
                                                                    return await (async function(){
                                                                        let __targ__568=(compiled_element && compiled_element["0"]);
                                                                        if (__targ__568){
                                                                             return(__targ__568)["ctype"]
                                                                        } 
                                                                    })()
                                                                } else if (check_true (((compiled_element && compiled_element["0"])==="{"))) {
                                                                    return "block"
                                                                } else {
                                                                    return null
                                                                }
                                                            } () 
                                                        })();
                                                        return await async function(){
                                                            if (check_true (((inst==="block")|| (inst==="letblock")))) {
                                                                {
                                                                    return (symbolic_replacements).push(await (async function(){
                                                                        let __array_op_rval__569=idx;
                                                                         if (__array_op_rval__569 instanceof Function){
                                                                            return await __array_op_rval__569(await gen_temp_name("array_arg"),[(preamble && preamble["2"]),"(",(preamble && preamble["1"])," ","function","()"," ",compiled_element," ",")"]) 
                                                                        } else {
                                                                            return [__array_op_rval__569,await gen_temp_name("array_arg"),[(preamble && preamble["2"]),"(",(preamble && preamble["1"])," ","function","()"," ",compiled_element," ",")"]]
                                                                        }
                                                                    })())
                                                                }
                                                            } else if (check_true ((inst==="ifblock"))) {
                                                                {
                                                                    return (symbolic_replacements).push(await (async function(){
                                                                        let __array_op_rval__570=idx;
                                                                         if (__array_op_rval__570 instanceof Function){
                                                                            return await __array_op_rval__570(await gen_temp_name("array_arg"),[(preamble && preamble["2"]),"(",(preamble && preamble["1"])," ","function","()"," ","{",compiled_element,"}"," ",")"]) 
                                                                        } else {
                                                                            return [__array_op_rval__570,await gen_temp_name("array_arg"),[(preamble && preamble["2"]),"(",(preamble && preamble["1"])," ","function","()"," ","{",compiled_element,"}"," ",")"]]
                                                                        }
                                                                    })())
                                                                }
                                                            }
                                                        } ()
                                                    },compiled_values);
                                                    await (async function() {
                                                        let __for_body__573=async function(elem) {
                                                            await (async function() {
                                                                let __for_body__577=async function(t) {
                                                                    return (acc).push(t)
                                                                };
                                                                let __array__578=[],__elements__576=["let"," ",(elem && elem["1"]),"=",(elem && elem["2"]),";"];
                                                                let __BREAK__FLAG__=false;
                                                                for(let __iter__575 in __elements__576) {
                                                                    __array__578.push(await __for_body__577(__elements__576[__iter__575]));
                                                                    if(__BREAK__FLAG__) {
                                                                         __array__578.pop();
                                                                        break;
                                                                        
                                                                    }
                                                                }return __array__578;
                                                                 
                                                            })();
                                                            return await compiled_values["splice"].call(compiled_values,(elem && elem["0"]),1,[(preamble && preamble["0"])," ",(elem && elem["1"]),"()"])
                                                        };
                                                        let __array__574=[],__elements__572=symbolic_replacements;
                                                        let __BREAK__FLAG__=false;
                                                        for(let __iter__571 in __elements__572) {
                                                            __array__574.push(await __for_body__573(__elements__572[__iter__571]));
                                                            if(__BREAK__FLAG__) {
                                                                 __array__574.pop();
                                                                break;
                                                                
                                                            }
                                                        }return __array__574;
                                                         
                                                    })();
                                                    if (check_true (((symbolic_replacements && symbolic_replacements.length)>0))){
                                                        {
                                                            (acc).unshift("{");
                                                            (acc).unshift({
                                                                ctype:"block"
                                                            })
                                                        }
                                                    };
                                                    await async function(){
                                                        if (check_true ((((declared_type && declared_type["type"])===Function)|| ((declared_type && declared_type["type"])===AsyncFunction)|| (((rcv && rcv["0"]) instanceof Object)&& (rcv && rcv["0"] && rcv["0"]["ctype"]) instanceof Function)|| (((rcv && rcv["0"]) instanceof Object)&& await not(((rcv && rcv["0"]) instanceof Array))&& ((rcv && rcv["0"] && rcv["0"]["ctype"]) instanceof String || typeof (rcv && rcv["0"] && rcv["0"]["ctype"])==='string')&& await contains_ques_("unction",(rcv && rcv["0"] && rcv["0"]["ctype"])))))) {
                                                            {
                                                                if (check_true (((declared_type && declared_type["type"])===AsyncFunction))){
                                                                    prefix="await "
                                                                } else {
                                                                    prefix=""
                                                                };
                                                                is_operation=true;
                                                                await (async function() {
                                                                    let __for_body__581=async function(t) {
                                                                        return (acc).push(t)
                                                                    };
                                                                    let __array__582=[],__elements__580=await (async function(){
                                                                        let __array_op_rval__583=prefix;
                                                                         if (__array_op_rval__583 instanceof Function){
                                                                            return await __array_op_rval__583("(",rcv,")","(") 
                                                                        } else {
                                                                            return [__array_op_rval__583,"(",rcv,")","("]
                                                                        }
                                                                    })();
                                                                    let __BREAK__FLAG__=false;
                                                                    for(let __iter__579 in __elements__580) {
                                                                        __array__582.push(await __for_body__581(__elements__580[__iter__579]));
                                                                        if(__BREAK__FLAG__) {
                                                                             __array__582.pop();
                                                                            break;
                                                                            
                                                                        }
                                                                    }return __array__582;
                                                                     
                                                                })();
                                                                await push_as_arg_list(acc,compiled_values);
                                                                return (acc).push(")")
                                                            }
                                                        } else if (check_true (((null==(declared_type && declared_type["type"]))&& (((tokens && tokens["0"] && tokens["0"]["type"])==="arg")|| ((rcv instanceof String || typeof rcv==='string')&& await get_declaration_details(ctx,rcv))|| ((rcv instanceof Array)&& ((rcv && rcv["0"]) instanceof Object)&& ((rcv && rcv["0"] && rcv["0"]["ctype"]) instanceof String || typeof (rcv && rcv["0"] && rcv["0"]["ctype"])==='string')&& ((rcv && rcv["0"] && rcv["0"]["ctype"])&& (await not(await contains_ques_("unction",(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(await contains_ques_("block",(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("string"===(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("StringType"===(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("nil"===(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("NumberType"===(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("undefined"===(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("objliteral"===(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("Boolean"===(rcv && rcv["0"] && rcv["0"]["ctype"])))&& await not(("array"===(rcv && rcv["0"] && rcv["0"]["ctype"])))))))))) {
                                                            {
                                                                if (check_true (show_hints)){
                                                                    {
                                                                        await comp_warn("value ambiguity - use declare to clarify: ",await source_from_tokens(tokens,expanded_tree,true)," ",await (await Environment.get_global("as_lisp"))(rcv))
                                                                    }
                                                                };
                                                                tmp_name=await gen_temp_name("array_op_rval");
                                                                if (check_true (((symbolic_replacements && symbolic_replacements.length)>0))){
                                                                    {
                                                                        (acc).push({
                                                                            ctype:"block"
                                                                        });
                                                                        (acc).push("return");
                                                                        (acc).push(" ")
                                                                    }
                                                                };
                                                                await (async function() {
                                                                    let __for_body__586=async function(t) {
                                                                        return (acc).push(t)
                                                                    };
                                                                    let __array__587=[],__elements__585=[(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","()","{","let"," ",tmp_name,"=",rcv,";"," ","if"," ","(",tmp_name," ","instanceof"," ","Function",")","{","return"," ",(preamble && preamble["0"])," ",tmp_name,"("];
                                                                    let __BREAK__FLAG__=false;
                                                                    for(let __iter__584 in __elements__585) {
                                                                        __array__587.push(await __for_body__586(__elements__585[__iter__584]));
                                                                        if(__BREAK__FLAG__) {
                                                                             __array__587.pop();
                                                                            break;
                                                                            
                                                                        }
                                                                    }return __array__587;
                                                                     
                                                                })();
                                                                await push_as_arg_list(acc,compiled_values);
                                                                await (async function() {
                                                                    let __for_body__590=async function(t) {
                                                                        return (acc).push(t)
                                                                    };
                                                                    let __array__591=[],__elements__589=[")"," ","}"," ","else"," ","{","return"," ","[",tmp_name];
                                                                    let __BREAK__FLAG__=false;
                                                                    for(let __iter__588 in __elements__589) {
                                                                        __array__591.push(await __for_body__590(__elements__589[__iter__588]));
                                                                        if(__BREAK__FLAG__) {
                                                                             __array__591.pop();
                                                                            break;
                                                                            
                                                                        }
                                                                    }return __array__591;
                                                                     
                                                                })();
                                                                if (check_true ((await length(await (await Environment.get_global("rest"))(tokens))>0))){
                                                                    {
                                                                        (acc).push(",");
                                                                        await push_as_arg_list(acc,compiled_values)
                                                                    }
                                                                };
                                                                return await (async function() {
                                                                    let __for_body__594=async function(t) {
                                                                        return (acc).push(t)
                                                                    };
                                                                    let __array__595=[],__elements__593=["]","}","}",")","()"];
                                                                    let __BREAK__FLAG__=false;
                                                                    for(let __iter__592 in __elements__593) {
                                                                        __array__595.push(await __for_body__594(__elements__593[__iter__592]));
                                                                        if(__BREAK__FLAG__) {
                                                                             __array__595.pop();
                                                                            break;
                                                                            
                                                                        }
                                                                    }return __array__595;
                                                                     
                                                                })()
                                                            }
                                                        } else if (check_true (((null==(declared_type && declared_type["type"]))&& (((rcv instanceof Array)&& ((rcv && rcv["0"]) instanceof Object)&& ((rcv && rcv["0"] && rcv["0"]["ctype"]) instanceof String || typeof (rcv && rcv["0"] && rcv["0"]["ctype"])==='string')&& await contains_ques_("block",(rcv && rcv["0"] && rcv["0"]["ctype"]))))))) {
                                                            {
                                                                if (check_true (((symbolic_replacements && symbolic_replacements.length)>0))){
                                                                    {
                                                                        (acc).push("return");
                                                                        (acc).push(" ")
                                                                    }
                                                                };
                                                                (acc).push("[");
                                                                (acc).push(["(",(preamble && preamble["0"])," ","(",(preamble && preamble["1"])," ","function","() {",rcv,"})","()",")"]);
                                                                if (check_true ((await length(await (await Environment.get_global("rest"))(tokens))>0))){
                                                                    {
                                                                        (acc).push(",");
                                                                        await push_as_arg_list(acc,compiled_values)
                                                                    }
                                                                };
                                                                return (acc).push("]")
                                                            }
                                                        } else {
                                                            return [(await (async function() {if (check_true (((symbolic_replacements && symbolic_replacements.length)>0))){
                                                                {
                                                                    (acc).push("return");
                                                                    return (acc).push(" ")
                                                                }
                                                            }
                                                        })()),(acc).push("["),(acc).push(rcv),await (async function(){
                                                            if (check_true ((await length(await (await Environment.get_global("rest"))(tokens))>0))){
                                                                {
                                                                    (acc).push(",");
                                                                    return await push_as_arg_list(acc,compiled_values)
                                                                }
                                                            }
                                                        })(),(acc).push("]")]
                                                    }
                                                } ();
                                                if (check_true (((symbolic_replacements && symbolic_replacements.length)>0))){
                                                    {
                                                        (acc).push("}")
                                                    }
                                                };
                                                return acc
                                            }
                                        }
                                    } ()
                                }
                            } else if (check_true (((tokens instanceof Object)&& ((tokens && tokens["val"]) instanceof Array)&& (tokens && tokens["type"])))) {
                                {
                                    await async function(){
                                        ctx["source"]=(tokens && tokens["source"]);
                                        return ctx;
                                        
                                    }();
                                    rcv=await (async function(){
                                         return await compile((tokens && tokens["val"]),ctx,await add(_cdepth,1)) 
                                    })();
                                    return rcv
                                }
                            } else if (check_true ((((tokens instanceof Object)&& await not((undefined===(tokens && tokens["val"])))&& (tokens && tokens["type"]))|| ((tokens && tokens["type"])==="literal")|| ((tokens && tokens["type"])==="arg")|| ((tokens && tokens["type"])==="null")))) {
                                {
                                    let snt_name=null;
                                    ;
                                    let snt_value=null;
                                    ;
                                    return await async function(){
                                        if (check_true ((await not((tokens && tokens["ref"]))&& ((tokens && tokens["type"])==="arr")))) {
                                            return await compile((tokens && tokens["val"]),ctx,await add(_cdepth,1))
                                        } else if (check_true ((((tokens && tokens["type"])==="null")|| (((tokens && tokens["type"])==="literal")&& ((tokens && tokens.name)==="null")&& (tokens && tokens["ref"]))))) {
                                            return [{
                                                ctype:"nil"
                                            },"null"]
                                        } else if (check_true ((((tokens && tokens["type"])==="literal")&& ((tokens && tokens.name)==="undefined")&& (tokens && tokens["ref"])))) {
                                            return [{
                                                ctype:"undefined"
                                            },"undefined"]
                                        } else if (check_true (await not((tokens && tokens["ref"])))) {
                                            if (check_true ((((tokens && tokens["type"])==="literal")&& ((tokens && tokens["val"]) instanceof String || typeof (tokens && tokens["val"])==='string')))){
                                                return [{
                                                    ctype:"string"
                                                },("\""+ await (async function(){
                                                     return await cl_encode_string((tokens && tokens["val"])) 
                                                })()+ "\"")]
                                            } else {
                                                if (check_true (await is_number_ques_((tokens && tokens["val"])))){
                                                    return [{
                                                        ctype:"NumberType"
                                                    },(tokens && tokens["val"])]
                                                } else {
                                                    return [{
                                                        ctype:await sub_type((tokens && tokens["val"]))
                                                    },(tokens && tokens["val"])]
                                                }
                                            }
                                        } else if (check_true (((tokens && tokens["ref"])&& (opts && opts["root_environment"])))) {
                                            {
                                                return await (await Environment.get_global("path_to_js_syntax"))((await sanitize_js_ref_name((tokens && tokens.name))).split("."))
                                            }
                                        } else if (check_true (((tokens && tokens["ref"])&& op_lookup[(tokens && tokens.name)]))) {
                                            return (tokens && tokens.name)
                                        } else if (check_true (((tokens && tokens["ref"])&& await (async function(){
                                            snt_name=await sanitize_js_ref_name((tokens && tokens.name));
                                            snt_value=await get_ctx_val(ctx,snt_name);
                                            if (check_true (await (async function(){
                                                let __array_op_rval__597=verbosity;
                                                 if (__array_op_rval__597 instanceof Function){
                                                    return await __array_op_rval__597(ctx) 
                                                } else {
                                                    return [__array_op_rval__597,ctx]
                                                }
                                            })())){
                                                {
                                                    await comp_log("compile: singleton: ","name: ",(tokens && tokens.name)," sanitized: ",snt_name,"found locally as:",snt_value)
                                                }
                                            };
                                            return await not((snt_value===undefined))
                                        })()))) {
                                            {
                                                refval=snt_value;
                                                if (check_true ((refval===ArgumentType))){
                                                    {
                                                        refval=snt_name
                                                    }
                                                };
                                                return await async function(){
                                                    if (check_true (((tokens && tokens["type"])==="literal"))) {
                                                        return refval
                                                    } else {
                                                        return await get_val(tokens,ctx)
                                                    }
                                                } ()
                                            }
                                        } else if (check_true (await contains_ques_((tokens && tokens.name),standard_types))) {
                                            return (tokens && tokens.name)
                                        } else if (check_true (await not((undefined===await get_lisp_ctx(ctx,(tokens && tokens.name)))))) {
                                            {
                                                if (check_true (await (async function(){
                                                    let __array_op_rval__598=verbosity;
                                                     if (__array_op_rval__598 instanceof Function){
                                                        return await __array_op_rval__598(ctx) 
                                                    } else {
                                                        return [__array_op_rval__598,ctx]
                                                    }
                                                })())){
                                                    {
                                                        await comp_log("compile: singleton: found global: ",(tokens && tokens.name))
                                                    }
                                                };
                                                return await compile_lisp_scoped_reference((tokens && tokens.name),ctx)
                                            }
                                        } else {
                                            {
                                                if (check_true (await (async function(){
                                                    let __array_op_rval__599=verbosity;
                                                     if (__array_op_rval__599 instanceof Function){
                                                        return await __array_op_rval__599() 
                                                    } else {
                                                        return [__array_op_rval__599]
                                                    }
                                                })())){
                                                    {
                                                        await comp_log("compile: resolver fall through:",(tokens && tokens.name),"-  not found globally or in local context")
                                                    }
                                                };
                                                throw new ReferenceError(("compile: unknown/not found reference: "+ (tokens && tokens.name)));
                                                
                                            }
                                        }
                                    } ()
                                }
                            } else {
                                {
                                    throw new SyntaxError("compile passed invalid compilation structure");
                                    
                                }
                            }
                        } ()
                    }
                } catch (__exception__559) {
                    if (__exception__559 instanceof Error) {
                        let e=__exception__559;
                        {
                            {
                                if (check_true ((is_error&& (e && e["handled"])))){
                                    {
                                        throw e;
                                        
                                    }
                                };
                                is_error={
                                    error:(e && e.name),source_name:source_name,message:(e && e.message),form:await source_from_tokens(tokens,expanded_tree),parent_forms:await source_from_tokens(tokens,expanded_tree,true),invalid:true
                                };
                                if (check_true (await not((e && e["handled"])))){
                                    {
                                        (errors).push(is_error);
                                        await async function(){
                                            e["handled"]=true;
                                            return e;
                                            
                                        }()
                                    }
                                };
                                await async function(){
                                    e["details"]=is_error;
                                    return e;
                                    
                                }();
                                if (check_true ((opts && opts["throw_on_error"]))){
                                    throw e;
                                    
                                }
                            }
                        }
                    }
                }
            }
        };
        final_token_assembly=null;
        main_log=await (async function(){
            if (check_true ((opts && opts["quiet_mode"]))){
                return log
            } else {
                return await defclog({
                    prefix:"compiler:",background:"green",color:"black"
                })
            }
        })();
        assemble_output=async function(js_tree,suppress_join) {
            let text;
            let in_quotes;
            let escaped;
            let escape_char;
            let format_depth;
            let last_t;
            let insert_indent;
            let process_output_token;
            let assemble;
            text=[];
            in_quotes=false;
            escaped=0;
            escape_char=await String.fromCharCode(92);
            format_depth=[];
            last_t=null;
            insert_indent=async function() {
                (text).push("\n");
                return await (async function() {
                    let __for_body__604=async function(spacer) {
                        return (text).push(spacer)
                    };
                    let __array__605=[],__elements__603=format_depth;
                    let __BREAK__FLAG__=false;
                    for(let __iter__602 in __elements__603) {
                        __array__605.push(await __for_body__604(__elements__603[__iter__602]));
                        if(__BREAK__FLAG__) {
                             __array__605.pop();
                            break;
                            
                        }
                    }return __array__605;
                     
                })()
            };
            process_output_token=async function(t) {
                escaped=await Math.max(0,(escaped- 1));
                return await async function(){
                    if (check_true (((t==="\"")&& (escaped===0)&& in_quotes))) {
                        {
                            in_quotes=false;
                            return (text).push(t)
                        }
                    } else if (check_true (((t==="\"")&& (escaped===0)))) {
                        {
                            in_quotes=true;
                            return (text).push(t)
                        }
                    } else if (check_true ((t===escape_char))) {
                        {
                            (escaped===2);
                            return (text).push(t)
                        }
                    } else if (check_true ((await not(in_quotes)&& (t==="{")))) {
                        {
                            (text).push(t);
                            (format_depth).push("    ");
                            return await insert_indent()
                        }
                    } else if (check_true ((await not(in_quotes)&& await starts_with_ques_("}",t)))) {
                        {
                            (format_depth).pop();
                            await insert_indent();
                            return (text).push(t)
                        }
                    } else if (check_true ((await not(in_quotes)&& (t===";")))) {
                        {
                            (text).push(t);
                            return await insert_indent()
                        }
                    } else if (check_true ((false&& await not(in_quotes)&& await starts_with_ques_("/*",t)))) {
                        {
                            (text).push(t);
                            return await insert_indent()
                        }
                    } else {
                        {
                            return (text).push(t)
                        }
                    }
                } ()
            };
            assemble=async function(js_tokens) {
                return await (async function() {
                    let __for_body__608=async function(t) {
                        return await async function(){
                            if (check_true ((t instanceof Array))) {
                                {
                                    return await assemble(t)
                                }
                            } else if (check_true (("object"===typeof t))) {
                                {
                                    if (check_true (((t && t["comment"])&& (opts && opts["include_source"])))){
                                        {
                                            (text).push(("/* "+ (t && t["comment"])+ " */"));
                                            return await insert_indent()
                                        }
                                    } else {
                                        if (check_true (false)){
                                            {
                                                return await console.log("assemble: discarding: ",t,"->",await (await Environment.get_global("last_n"))(5,text))
                                            }
                                        }
                                    }
                                }
                            } else if (check_true (t instanceof Function)) {
                                {
                                    return await async function(){
                                        if (check_true (((t && t.name)&& await contains_ques_((t && t.name),standard_types)))) {
                                            return (text).push((t && t.name))
                                        } else if (check_true (await (await Environment.get_global("ends_with?"))("{ [native code] }",await t["toString"]()))) {
                                            {
                                                throw new ReferenceError(("cannot capture source of: "+ (t && t.name)));
                                                
                                            }
                                        } else {
                                            return (text).push(t)
                                        }
                                    } ()
                                }
                            } else {
                                {
                                    if (check_true ((opts && opts["formatted_output"]))){
                                        return await process_output_token(t)
                                    } else {
                                        return (text).push(t)
                                    }
                                }
                            }
                        } ()
                    };
                    let __array__609=[],__elements__607=js_tokens;
                    let __BREAK__FLAG__=false;
                    for(let __iter__606 in __elements__607) {
                        __array__609.push(await __for_body__608(__elements__607[__iter__606]));
                        if(__BREAK__FLAG__) {
                             __array__609.pop();
                            break;
                            
                        }
                    }return __array__609;
                     
                })()
            };
            {
                await assemble(await flatten(await (async function(){
                    let __array_op_rval__610=js_tree;
                     if (__array_op_rval__610 instanceof Function){
                        return await __array_op_rval__610() 
                    } else {
                        return [__array_op_rval__610]
                    }
                })()));
                if (check_true (suppress_join)){
                    return text
                } else {
                    {
                        return await output_validation((text).join(""))
                    }
                }
            }
        };
        ;
        if (check_true ((null==Environment))){
            throw new EvalError("Compiler: No environment passed in options.");
            
        };
        if (check_true ((opts && opts["show_hints"]))){
            {
                show_hints=true
            }
        };
        if (check_true (await Environment["get_global"].call(Environment,"__VERBOSITY__"))){
            {
                {
                    let verbosity_level;
                    verbosity_level=await Environment["get_global"].call(Environment,"__VERBOSITY__");
                    await async function(){
                        if (check_true ((verbosity_level>4))) {
                            {
                                verbosity=check_verbosity;
                                return show_hints=true
                            }
                        } else if (check_true ((verbosity_level>3))) {
                            show_hints=true
                        }
                    } ()
                }
            }
        };
        if (check_true (await (async function(){
            let __array_op_rval__611=verbosity;
             if (__array_op_rval__611 instanceof Function){
                return await __array_op_rval__611(ctx) 
            } else {
                return [__array_op_rval__611,ctx]
            }
        })())){
            {
                await (async function(){
                    let __array_op_rval__612=main_log;
                     if (__array_op_rval__612 instanceof Function){
                        return await __array_op_rval__612("namespace set to: ",(Environment && Environment["namespace"])) 
                    } else {
                        return [__array_op_rval__612,"namespace set to: ",(Environment && Environment["namespace"])]
                    }
                })();
                if (check_true ((opts && opts["fully_qualified_globals"]))){
                    {
                        await (async function(){
                            let __array_op_rval__613=main_log;
                             if (__array_op_rval__613 instanceof Function){
                                return await __array_op_rval__613("fully qualified globals") 
                            } else {
                                return [__array_op_rval__613,"fully qualified globals"]
                            }
                        })()
                    }
                }
            }
        };
        await set_ctx(root_ctx,break_out,false);
        await async function(){
            root_ctx["defined_lisp_globals"]=new Object();
            return root_ctx;
            
        }();
        await set_ctx(root_ctx,"__COMPLETION_SCOPE__",{
            id:completion_scope_id,root_block_id:null,completion_records:[],is_top:true
        });
        await set_ctx(root_ctx,"__GLOBALS__",new Set());
        await set_ctx(root_ctx,"__EXTERNALS__",new Set());
        await set_ctx(root_ctx,"__SOURCE_NAME__",source_name);
        await set_ctx(root_ctx,"__LAMBDA_STEP__",-1);
        if (check_true (await (async function(){
            let __array_op_rval__615=verbosity;
             if (__array_op_rval__615 instanceof Function){
                return await __array_op_rval__615(ctx) 
            } else {
                return [__array_op_rval__615,ctx]
            }
        })())){
            {
                await (async function(){
                    let __array_op_rval__616=main_log;
                     if (__array_op_rval__616 instanceof Function){
                        return await __array_op_rval__616("root_ctx: ",root_ctx) 
                    } else {
                        return [__array_op_rval__616,"root_ctx: ",root_ctx]
                    }
                })()
            }
        };
        output=await (async function(){
             return await async function(){
                if (check_true ((opts && opts["special_operators"]))) {
                    {
                        return await (await Environment.get_global("make_set"))(await (await Environment.get_global("keys"))(op_lookup))
                    }
                } else if (check_true ((opts && opts["only_tokens"]))) {
                    return await tokenize(tree,root_ctx)
                } else if (check_true (is_error)) {
                    return [{
                        ctype:"CompileError"
                    },is_error]
                } else {
                    {
                        try {
                            if (check_true ((await not((opts && opts["root_environment"]))&& ((first_level_setup && first_level_setup.length)===0)&& ((opts && opts["ctx"] && opts["ctx"]["scope"]) instanceof Object)))){
                                {
                                    dynamic_references_ques_=false;
                                    await (async function() {
                                        let __for_body__620=async function(pset) {
                                            {
                                                let name;
                                                let value;
                                                name=(pset && pset["0"]);
                                                value=(pset && pset["1"]);
                                                await set_ctx(root_ctx,name,value);
                                                return (first_level_setup).push(["let ",await sanitize_js_ref_name(name),"=",await (async function(){
                                                     return await compile(await tokenize(value,root_ctx),root_ctx,101) 
                                                })(),";"])
                                            }
                                        };
                                        let __array__621=[],__elements__619=await (await Environment.get_global("pairs"))((opts && opts["ctx"] && opts["ctx"]["scope"]));
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__618 in __elements__619) {
                                            __array__621.push(await __for_body__620(__elements__619[__iter__618]));
                                            if(__BREAK__FLAG__) {
                                                 __array__621.pop();
                                                break;
                                                
                                            }
                                        }return __array__621;
                                         
                                    })()
                                }
                            };
                            final_token_assembly=await tokenize(tree,root_ctx)
                        } catch (__exception__617) {
                            if (__exception__617 instanceof Error) {
                                let e=__exception__617;
                                {
                                    is_error=e
                                }
                            }
                        };
                        await async function(){
                            if (check_true ((is_error&& (opts && opts["throw_on_error"])))) {
                                throw is_error;
                                
                            } else if (check_true ((is_error instanceof SyntaxError))) {
                                {
                                    (errors).push(is_error);
                                    return is_error
                                }
                            } else if (check_true (is_error)) {
                                {
                                    (errors).push(is_error);
                                    return is_error
                                }
                            } else if (check_true ((null==final_token_assembly))) {
                                {
                                    is_error=new EvalError("Pre-Compilation Error");
                                    return (errors).push(is_error)
                                }
                            } else {
                                {
                                    if (check_true ((opts && opts["on_final_token_assembly"]))){
                                        await opts["on_final_token_assembly"].call(opts,final_token_assembly)
                                    };
                                    assembly=await (async function(){
                                         return await compile(final_token_assembly,root_ctx,0) 
                                    })();
                                    if (check_true ((is_error&& (opts && opts["throw_on_error"])))){
                                        {
                                            throw is_error;
                                            
                                        }
                                    };
                                    if (check_true (await not(is_error))){
                                        {
                                            if (check_true ((assembly instanceof Array))){
                                                {
                                                    await check_statement_completion(root_ctx,assembly)
                                                }
                                            }
                                        }
                                    };
                                    return assembly
                                }
                            }
                        } ();
                        if (check_true ((opts && opts["root_environment"]))){
                            {
                                has_lisp_globals=false
                            }
                        };
                        if (check_true (((assembly && assembly["0"] && assembly["0"]["ctype"])&& (assembly && assembly["0"] && assembly["0"]["ctype"]) instanceof Function))){
                            {
                                await async function(){
                                    let __target_obj__622=(assembly && assembly["0"]);
                                    __target_obj__622["ctype"]=await map_value_to_ctype((assembly && assembly["0"] && assembly["0"]["ctype"]));
                                    return __target_obj__622;
                                    
                                }()
                            }
                        };
                        await async function(){
                            if (check_true ((await not(is_error)&& assembly&& (await first(assembly) instanceof Object)&& await (async function(){
                                let __targ__623=await first(assembly);
                                if (__targ__623){
                                     return(__targ__623)["ctype"]
                                } 
                            })()&& (await not((await (async function(){
                                let __targ__624=await first(assembly);
                                if (__targ__624){
                                     return(__targ__624)["ctype"]
                                } 
                            })() instanceof String || typeof await (async function(){
                                let __targ__624=await first(assembly);
                                if (__targ__624){
                                     return(__targ__624)["ctype"]
                                } 
                            })()==='string'))|| await (async function(){
                                let val;
                                val=await (async function(){
                                    let __targ__625=await first(assembly);
                                    if (__targ__625){
                                         return(__targ__625)["ctype"]
                                    } 
                                })();
                                return (await not((val==="assignment"))&& await not(await contains_ques_("block",val))&& await not(await contains_ques_("unction",val)))
                            })())))) {
                                {
                                    return await async function(){
                                        let __target_obj__626=(assembly && assembly["0"]);
                                        __target_obj__626["ctype"]="statement";
                                        return __target_obj__626;
                                        
                                    }()
                                }
                            } else if (check_true ((assembly&& (await first(assembly) instanceof String || typeof await first(assembly)==='string')&& (await first(assembly)==="throw")))) {
                                return assembly=await (async function(){
                                     return [{
                                        ctype:"block"
                                    },assembly] 
                                })()
                            } else if (check_true ((await not(is_error)&& assembly&& (await not((await first(assembly) instanceof Object))|| await not(await (async function(){
                                let __targ__627=await first(assembly);
                                if (__targ__627){
                                     return(__targ__627)["ctype"]
                                } 
                            })()))))) {
                                {
                                    if (check_true (dynamic_references_ques_)){
                                        return assembly=await (async function(){
                                             return [{
                                                ctype:"block"
                                            },["{",first_level_setup,";","return ",assembly,"};"]] 
                                        })()
                                    } else {
                                        return assembly=await (async function(){
                                             return [{
                                                ctype:"statement"
                                            },assembly] 
                                        })()
                                    }
                                }
                            } else if (check_true (is_error)) {
                                return is_error
                            } else if (check_true ((null==assembly))) {
                                return assembly=[]
                            }
                        } ();
                        if (check_true (is_error)){
                            {
                                return [{
                                    ctype:"FAIL"
                                },errors]
                            }
                        } else {
                            if (check_true ((await first(assembly) instanceof Object))){
                                return [await add({
                                    has_lisp_globals:has_lisp_globals,requires:await (async function(){
                                         return await (await Environment.get_global("to_array"))(referenced_global_symbols) 
                                    })(),externals:await (async function(){
                                         return await (await Environment.get_global("to_array"))(referenced_externals) 
                                    })()
                                },(assembly).shift()),await assemble_output(assembly)]
                            } else {
                                return [{
                                    has_lisp_globals:has_lisp_globals,requires:await (async function(){
                                         return await (await Environment.get_global("to_array"))(referenced_global_symbols) 
                                    })(),externals:await (async function(){
                                         return await (await Environment.get_global("to_array"))(referenced_externals) 
                                    })()
                                },await assemble_output(assembly)]
                            }
                        }
                    }
                }
            } () 
        })();
        if (check_true (((await first(output) instanceof Object)&& target_namespace))){
            {
                await async function(){
                    let __target_obj__628=await first(output);
                    __target_obj__628["namespace"]=target_namespace;
                    return __target_obj__628;
                    
                }()
            }
        };
        if (check_true ((opts && opts["error_report"]))){
            {
                await opts.error_report({
                    errors:errors,warnings:warnings
                })
            }
        };
        return output
    }
}
};__obj__1["set_repl"]=async function(key,value) {
    return await (await Environment.get_global("set_path"))(["repl",key],(await Environment.get_global("*env_config*")),value)
};__obj__1["repl_config"]=async function() {
    return await (await Environment.get_global("add"))({
        backtrace:false,raw_mode:false,output_processor:false
    },(await (await Environment.get_global("resolve_path"))(["repl"],(await Environment.get_global("*env_config*")))|| new Object()))
};__obj__1["if_undefined"]=async function(value,replacer) {
        return ["=:if",["=:==","=:undefined",value],replacer,value]
    };__obj__1["str"]=async function(...args) {
    args=await (await Environment.get_global("slice"))(args,0);
    return (args).join(" ")
};__obj__1["COPY_DATA"]=null;__obj__1["on_nil"]=async function(nil_form,value) {
    return ["=:let",[["=:v",value]],["=:if",["=:eq","=:v","=:nil"],nil_form,"=:v"]]
};__obj__1["on_empty"]=async function(on_empty_form,value) {
    return ["=:let",[["=:v",value]],["=:if",["=:or",["=:eq","=:v","=:nil"],["=:and",["=:is_array?","=:v"],["=:==",0,["=:length","=:v"]]],["=:and",["=:is_object?","=:v"],["=:==",["=:length","=:v"],0]]],on_empty_form,"=:v"]]
};__obj__1["sum"]=async function(vals) {
    return ["=:apply","=:add",vals]
};__obj__1["options_and_args"]=async function(arg_array) {
    return await async function(){
        if (check_true ((arg_array&& (arg_array instanceof Array)))) {
            {
                if (check_true ((await (await Environment.get_global("type"))((arg_array && arg_array["0"]))==="object"))){
                    return await (async function(){
                        let __array_op_rval__1=(arg_array && arg_array["0"]);
                         if (__array_op_rval__1 instanceof Function){
                            return await __array_op_rval__1(await (await Environment.get_global("slice"))(arg_array,1)) 
                        } else {
                            return [__array_op_rval__1,await (await Environment.get_global("slice"))(arg_array,1)]
                        }
                    })()
                } else {
                    return [null,arg_array]
                }
            }
        } else {
            return [null,arg_array]
        }
    } ()
};__obj__1["enum"]=async function(value_list) {
    let e=new Object();
    ;
    let i=-1;
    ;
    await (await Environment.get_global("assert"))((value_list instanceof Array),"Value_list must be an array");
    await (async function() {
        let __for_body__4=async function(v) {
            return await async function(){
                e[v]=i+=1;
                return e;
                
            }()
        };
        let __array__5=[],__elements__3=value_list;
        let __BREAK__FLAG__=false;
        for(let __iter__2 in __elements__3) {
            __array__5.push(await __for_body__4(__elements__3[__iter__2]));
            if(__BREAK__FLAG__) {
                 __array__5.pop();
                break;
                
            }
        }return __array__5;
         
    })();
    return e
};__obj__1["gen_id"]=async function(prefix) {
    return (""+ prefix+ "_"+ await Date.now())
};__obj__1["macros"]=async function() {
    let __collector;
    let __result;
    let __action;
    __collector=[];
    __result=null;
    __action=async function(v) {
        if (check_true ((v && v["1"] && v["1"]["macro"]))){
            return (v && v["0"])
        }
    };
    ;
    await (async function() {
        let __for_body__9=async function(__item) {
            __result=await __action(__item);
            if (check_true (__result)){
                return (__collector).push(__result)
            }
        };
        let __array__10=[],__elements__8=await (await Environment.get_global("pairs"))(Environment.definitions);
        let __BREAK__FLAG__=false;
        for(let __iter__7 in __elements__8) {
            __array__10.push(await __for_body__9(__elements__8[__iter__7]));
            if(__BREAK__FLAG__) {
                 __array__10.pop();
                break;
                
            }
        }return __array__10;
         
    })();
    return __collector
};__obj__1["pluck"]=async function(fields,data) {
    return ["=:each",data,fields]
};__obj__1["objects_from_list"]=async function(key_path,objects) {
    let obj;
    let path;
    obj=new Object();
    path=await (async function(){
        if (check_true ((key_path instanceof Array))){
            return key_path
        } else {
            return await (async function(){
                let __array_op_rval__11=key_path;
                 if (__array_op_rval__11 instanceof Function){
                    return await __array_op_rval__11() 
                } else {
                    return [__array_op_rval__11]
                }
            })()
        }
    })();
    await (async function() {
        let __for_body__14=async function(o) {
            return await async function(){
                obj[await (await Environment.get_global("resolve_path"))(path,o)]=o;
                return obj;
                
            }()
        };
        let __array__15=[],__elements__13=objects;
        let __BREAK__FLAG__=false;
        for(let __iter__12 in __elements__13) {
            __array__15.push(await __for_body__14(__elements__13[__iter__12]));
            if(__BREAK__FLAG__) {
                 __array__15.pop();
                break;
                
            }
        }return __array__15;
         
    })();
    return obj
};__obj__1["pairs_from_list"]=async function(value_list,size) {
    let container;
    let mod_size;
    let pset;
    let count;
    container=[];
    size=(size|| 2);
    mod_size=(size- 1);
    pset=[];
    count=0;
    await (async function() {
        let __for_body__19=async function(item) {
            (pset).push(item);
            if (check_true ((mod_size===(count% size)))){
                {
                    (container).push(pset);
                    pset=[]
                }
            };
            return count+=1
        };
        let __array__20=[],__elements__18=value_list;
        let __BREAK__FLAG__=false;
        for(let __iter__17 in __elements__18) {
            __array__20.push(await __for_body__19(__elements__18[__iter__17]));
            if(__BREAK__FLAG__) {
                 __array__20.pop();
                break;
                
            }
        }return __array__20;
         
    })();
    if (check_true ((await (await Environment.get_global("length"))(pset)>0))){
        (container).push(pset)
    };
    return container
};__obj__1["reorder_keys"]=async function(key_list,obj) {
    let objkeys;
    let rval;
    let __values__21= async function(){
        return await (async function(){
             return await (await Environment.get_global("nth"))(key_list,obj) 
        })()
    };
    {
        objkeys=await (await Environment.get_global("keys"))(obj);
        rval=new Object();
        let values=await __values__21();
        ;
        return await (await Environment.get_global("to_object"))(await (await Environment.get_global("pairs_from_list"))(await (async function(){
             return await (await Environment.get_global("interlace"))(key_list,values) 
        })()))
    }
};__obj__1["only"]=async function(fields,data) {
    return await async function(){
        if (check_true ((data instanceof Array))) {
            return await (await Environment.get_global("map"))(async function(v) {
                return await (await Environment.get_global("reorder_keys"))(fields,v)
            },data)
        } else if (check_true ((data instanceof Object))) {
            return await (await Environment.get_global("reorder_keys"))(fields,data)
        } else {
            return data
        }
    } ()
};__obj__1["sleep"]=async function(seconds) {
    return new Promise(async function(resolve) {
        return await setTimeout(async function() {
            return await (async function(){
                let __array_op_rval__22=resolve;
                 if (__array_op_rval__22 instanceof Function){
                    return await __array_op_rval__22(true) 
                } else {
                    return [__array_op_rval__22,true]
                }
            })()
        },(seconds* 1000))
    })
};__obj__1["from_universal_time"]=function(seconds) {
        let d;
        let ue;
        d=new Date(0);
        ue=(seconds- 2208988800);
         d["setUTCSeconds"].call(d,ue);
        return d
    };__obj__1["+="]=async function(...args) {
    let symbol;
    symbol=(args && args["0"]);
    args=await (await Environment.get_global("slice"))(args,1);
    return ["=:=",].concat(symbol,[["=:+",symbol,].concat(args)])
};__obj__1["minmax_index"]=async function(container) {
    let value_found=false;
    ;
    let idx_small=null;
    ;
    let idx_largest=null;
    ;
    let idx=0;
    ;
    let smallest=(await Environment.get_global("MAX_SAFE_INTEGER"));
    ;
    let biggest=(-1* (await Environment.get_global("MAX_SAFE_INTEGER")));
    ;
    if (check_true ((container&& (container instanceof Array)&& (await (await Environment.get_global("length"))(container)>0)))){
        {
            await (async function() {
                let __for_body__30=async function(value) {
                    return (await (await Environment.get_global("is_number?"))(value)&& await (async function(){
                        value_found=true;
                        if (check_true ((value<smallest))){
                            {
                                smallest=value;
                                idx_small=idx
                            }
                        };
                        if (check_true ((value>biggest))){
                            {
                                biggest=value;
                                idx_largest=idx
                            }
                        };
                        return idx+=1
                    })())
                };
                let __array__31=[],__elements__29=container;
                let __BREAK__FLAG__=false;
                for(let __iter__28 in __elements__29) {
                    __array__31.push(await __for_body__30(__elements__29[__iter__28]));
                    if(__BREAK__FLAG__) {
                         __array__31.pop();
                        break;
                        
                    }
                }return __array__31;
                 
            })();
            if (check_true (value_found)){
                return await (async function(){
                    let __array_op_rval__32=idx_small;
                     if (__array_op_rval__32 instanceof Function){
                        return await __array_op_rval__32(idx_largest) 
                    } else {
                        return [__array_op_rval__32,idx_largest]
                    }
                })()
            } else {
                return null
            }
        }
    } else {
        return null
    }
};__obj__1["invert_pairs"]=async function(value) {
    if (check_true ((value instanceof Array))){
        return await (await Environment.get_global("map"))(async function(v) {
            return await (async function(){
                let __array_op_rval__33=(v && v["1"]);
                 if (__array_op_rval__33 instanceof Function){
                    return await __array_op_rval__33((v && v["0"])) 
                } else {
                    return [__array_op_rval__33,(v && v["0"])]
                }
            })()
        },value)
    } else {
        throw new Error("invert_pairs passed a non-array value");
        
    }
};__obj__1["noop"]=async function(val) {
    return val
};__obj__1["apply_list_to_list"]=async function(operator,list1,list2) {
    return await (await Environment.get_global("map"))(async function(val,idx) {
        return await (async function(){
            let __array_op_rval__34=operator;
             if (__array_op_rval__34 instanceof Function){
                return await __array_op_rval__34(val,list1[(idx% await (await Environment.get_global("length"))(list1))]) 
            } else {
                return [__array_op_rval__34,val,list1[(idx% await (await Environment.get_global("length"))(list1))]]
            }
        })()
    },list2)
};__obj__1["apply_operator_list"]=async function(modifier_list,target_list) {
    return await (await Environment.get_global("map"))(async function(val,idx) {
        let op=await Environment["eval"].call(Environment,("=:"+ modifier_list[(idx% await (await Environment.get_global("length"))(modifier_list))]));
        ;
        return await (async function(){
            let __array_op_rval__35=op;
             if (__array_op_rval__35 instanceof Function){
                return await __array_op_rval__35(val) 
            } else {
                return [__array_op_rval__35,val]
            }
        })()
    },target_list)
};__obj__1["range_overlap?"]=async function(range_a,range_b) {
    return (((range_a && range_a["0"])<=(range_a && range_a["1"]))&& ((range_b && range_b["0"])<=(range_b && range_b["1"]))&& await (async function(){
        if (check_true (((((range_a && range_a["0"])<=(range_b && range_b["0"]))&& ((range_b && range_b["0"])<=(range_a && range_a["1"])))|| (((range_a && range_a["0"])>=(range_b && range_b["0"]))&& ((range_a && range_a["0"])<=(range_b && range_b["1"])))))){
            return true
        } else {
            return false
        }
    })())
};__obj__1["remaining_in_range"]=async function(value,check_range) {
    return await async function(){
        if (check_true (((value<=(check_range && check_range["1"]))&& (value>=(check_range && check_range["0"]))))) {
            return ((check_range && check_range["1"])- value)
        } else {
            return null
        }
    } ()
};__obj__1["form_id"]=async function(name) {
    return await (await Environment.get_global("replace"))(new RegExp("W","g"),"_",await (await Environment.get_global("replace"))(new RegExp("[+?':]","g"),"sssymss1",await (await Environment.get_global("replace"))("!","sexcs1",await (await Environment.get_global("replace"))("<","slts1",await (await Environment.get_global("replace"))(">","sgts1",(await (await Environment.get_global("split"))((name).toLowerCase()," ")).join("_"))))))
};__obj__1["from_key"]=function(value,sep_ques_,ignore_ques_) {
        if (check_true ((value instanceof String || typeof value==='string'))){
            {
                if (check_true (ignore_ques_)){
                    return value;
                    
                };
                sep_ques_=(sep_ques_|| "_");
                return  ( Environment.get_global("dtext"))(( ( function() {
                    let __for_body__39=function(v) {
                        return (""+  ( function() {
                            {
                                 let __call_target__= v["charAt"].call(v,0), __call_method__="toUpperCase";
                                return  __call_target__[__call_method__]()
                            } 
                        })()+  v["slice"].call(v,1))
                    };
                    let __array__40=[],__elements__38=(value).split(sep_ques_);
                    let __BREAK__FLAG__=false;
                    for(let __iter__37 in __elements__38) {
                        __array__40.push( __for_body__39(__elements__38[__iter__37]));
                        if(__BREAK__FLAG__) {
                             __array__40.pop();
                            break;
                            
                        }
                    }return __array__40;
                     
                })()).join(" "))
            }
        } else {
            return value
        }
    };__obj__1["from_key1"]=function(v) {
        return  ( Environment.get_global("from_key"))(v)
    };__obj__1["to_key"]=function(value,sep_ques_,ignore_ques_) {
        if (check_true ((value instanceof String || typeof value==='string'))){
            {
                if (check_true (ignore_ques_)){
                    return value;
                    
                };
                sep_ques_="_";
                let tokens= ( function() {
                    let __for_body__44=function(v) {
                        return (""+ (v).toLowerCase())
                    };
                    let __array__45=[],__elements__43=(value).split(" ");
                    let __BREAK__FLAG__=false;
                    for(let __iter__42 in __elements__43) {
                        __array__45.push( __for_body__44(__elements__43[__iter__42]));
                        if(__BREAK__FLAG__) {
                             __array__45.pop();
                            break;
                            
                        }
                    }return __array__45;
                     
                })();
                ;
                let rv=(tokens).join(sep_ques_);
                ;
                return rv
            }
        } else {
            {
                return value
            }
        }
    };__obj__1["is_object_or_function?"]=function anonymous(obj
) {
var type = typeof obj; return type === 'function' || type === 'object' && !!obj;
};__obj__1["extend"]=async function(target_object,source_object) {
    if (check_true (((target_object instanceof Object)&& (source_object instanceof Object)))){
        {
            await (async function() {
                let __for_body__48=async function(pset) {
                    return await async function(){
                        target_object[(pset && pset["0"])]=(pset && pset["1"]);
                        return target_object;
                        
                    }()
                };
                let __array__49=[],__elements__47=await (await Environment.get_global("pairs"))(source_object);
                let __BREAK__FLAG__=false;
                for(let __iter__46 in __elements__47) {
                    __array__49.push(await __for_body__48(__elements__47[__iter__46]));
                    if(__BREAK__FLAG__) {
                         __array__49.pop();
                        break;
                        
                    }
                }return __array__49;
                 
            })();
            return target_object
        }
    } else {
        return target_object
    }
};__obj__1["no_empties"]=async function(items) {
    let item_type=await (await Environment.get_global("sub_type"))(items);
    ;
    if (check_true (await (await Environment.get_global("not"))((item_type=="array")))){
        items=[items]
    };
    {
        let __collector;
        let __result;
        let __action;
        __collector=[];
        __result=null;
        __action=async function(value) {
            return await async function(){
                if (check_true ((null==value))) {
                    return false
                } else if (check_true ((""==value))) {
                    return false
                } else {
                    return value
                }
            } ()
        };
        ;
        await (async function() {
            let __for_body__53=async function(__item) {
                __result=await __action(__item);
                if (check_true (__result)){
                    return (__collector).push(__result)
                }
            };
            let __array__54=[],__elements__52=items;
            let __BREAK__FLAG__=false;
            for(let __iter__51 in __elements__52) {
                __array__54.push(await __for_body__53(__elements__52[__iter__51]));
                if(__BREAK__FLAG__) {
                     __array__54.pop();
                    break;
                    
                }
            }return __array__54;
             
        })();
        return __collector
    }
};__obj__1["first_with"]=async function(prop_list,data_value) {
    let rval;
    let found;
    rval=null;
    found=false;
    await (async function() {
        let __for_body__57=async function(p) {
            rval=data_value[p];
            if (check_true (await (await Environment.get_global("not"))((null==rval)))){
                {
                    found=true;
                    return __BREAK__FLAG__=true;
                    return
                }
            }
        };
        let __array__58=[],__elements__56=prop_list;
        let __BREAK__FLAG__=false;
        for(let __iter__55 in __elements__56) {
            __array__58.push(await __for_body__57(__elements__56[__iter__55]));
            if(__BREAK__FLAG__) {
                 __array__58.pop();
                break;
                
            }
        }return __array__58;
         
    })();
    if (check_true (found)){
        return rval
    } else {
        return null
    }
};__obj__1["fixed"]=async function(v,p) {
    if (check_true (p)){
        return await (async function() {
            {
                 let __call_target__=await parseFloat(v), __call_method__="toFixed";
                return await __call_target__[__call_method__].call(__call_target__,p)
            } 
        })()
    } else {
        return await (async function() {
            {
                 let __call_target__=await parseFloat(v), __call_method__="toFixed";
                return await __call_target__[__call_method__].call(__call_target__,3)
            } 
        })()
    }
};__obj__1["hide"]=async function(value) {
    return undefined
};__obj__1["array_to_object"]=async function(input_array) {
    let count;
    let output;
    let working_array;
    count=0;
    output=await (async function(){
         return await clone(new Object()) 
    })();
    working_array=await (async function(){
         return await clone(input_array) 
    })();
    await (async function(){
         let __test_condition__63=async function() {
            return (await (await Environment.get_global("length"))(working_array)>0)
        };
        let __body_ref__64=async function() {
            let v1=(working_array).shift();
            ;
            let v1t=await (async function(){
                 return await (await Environment.get_global("type"))(v1) 
            })();
            ;
            return await async function(){
                if (check_true ((v1t==="object"))) {
                    return output=await (await Environment.get_global("add"))(await (async function(){
                        let __array_op_rval__65=output;
                         if (__array_op_rval__65 instanceof Function){
                            return await __array_op_rval__65(v1) 
                        } else {
                            return [__array_op_rval__65,v1]
                        }
                    })())
                } else {
                    return await async function(){
                        output[v1]=(working_array).shift();
                        return output;
                        
                    }()
                }
            } ()
        };
        let __BREAK__FLAG__=false;
        while(await __test_condition__63()) {
             await __body_ref__64();
             if(__BREAK__FLAG__) {
                 break;
                
            }
        } ;
        
    })();
    return output
};__obj__1["split_text_in_array"]=async function(split_element,input_array) {
    let output=[];
    ;
    await (async function() {
        let __for_body__69=async function(item) {
            return await async function(){
                if (check_true ((item instanceof String || typeof item==='string'))) {
                    return (output).push(await (await Environment.get_global("split"))(item,split_element))
                } else {
                    return (output).push(await (async function(){
                         return [null,item] 
                    })())
                }
            } ()
        };
        let __array__70=[],__elements__68=input_array;
        let __BREAK__FLAG__=false;
        for(let __iter__67 in __elements__68) {
            __array__70.push(await __for_body__69(__elements__68[__iter__67]));
            if(__BREAK__FLAG__) {
                 __array__70.pop();
                break;
                
            }
        }return __array__70;
         
    })();
    return output
};__obj__1["words_and_quotes"]=async function(text) {
    if (check_true (await (await Environment.get_global("not"))((text==null)))){
        return await (await Environment.get_global("map"))(async function(x,i) {
            if (check_true ((0===(i% 2)))){
                return (await (await Environment.get_global("no_empties"))(((x).trim()).split(" "))).join(" ")
            } else {
                return x
            }
        },(text).split("\""))
    } else {
        return []
    }
};__obj__1["split_words"]=async function(text_string) {
    return await (await Environment.get_global("no_empties"))(await (async function(){
         return await (await Environment.get_global("map"))(async function(x,i) {
            if (check_true ((0===(i% 2)))){
                return await (await Environment.get_global("no_empties"))(((x).trim()).split(" "))
            } else {
                return await (async function(){
                    let __array_op_rval__71=x;
                     if (__array_op_rval__71 instanceof Function){
                        return await __array_op_rval__71() 
                    } else {
                        return [__array_op_rval__71]
                    }
                })()
            }
        },await (await Environment.get_global("words_and_quotes"))(text_string)) 
    })())
};__obj__1["from_style_text"]=async function(text) {
    let semi_reg;
    let colon_reg;
    semi_reg=await RegExp(";\n ","g");
    colon_reg=await RegExp(": ","g");
    return await (await Environment.get_global("no_empties"))(await (async function(){
         return await (await Environment.get_global("map"))(async function(x) {
            return [((x && x["0"])).trim(),(x && x["1"])]
        },await (async function(){
             return await (await Environment.get_global("map"))(async function(v) {
                return (await (await Environment.get_global("replace"))(colon_reg,":",v)).split(":")
            },await (await Environment.get_global("flatten"))(await (async function(){
                 return await (await Environment.get_global("map"))(async function(v) {
                    return (await (await Environment.get_global("replace"))(semi_reg,";",v)).split(";")
                },await (await Environment.get_global("words_and_quotes"))(text)) 
            })())) 
        })()) 
    })())
};__obj__1["sha1"]=async function(text) {
    if (check_true ((text instanceof String || typeof text==='string'))){
        {
            let buffer;
            let hash;
            let hexcodes;
            let view;
            buffer=await (async function() {
                {
                     let __call_target__=new TextEncoder("utf-8"), __call_method__="encode";
                    return await __call_target__[__call_method__].call(__call_target__,text)
                } 
            })();
            hash=await crypto.subtle["digest"].call(crypto.subtle,"SHA-1",buffer);
            hexcodes=[];
            view=new DataView(hash);
            await (async function() {
                let __for_body__74=async function(i) {
                    return (hexcodes).push(await (async function() {
                        {
                             let __call_target__=await (async function() {
                                {
                                     let __call_target__=await view["getUint8"].call(view,i), __call_method__="toString";
                                    return await __call_target__[__call_method__].call(__call_target__,16)
                                } 
                            })(), __call_method__="padStart";
                            return await __call_target__[__call_method__].call(__call_target__,2,0)
                        } 
                    })())
                };
                let __array__75=[],__elements__73=await (await Environment.get_global("range"))((view && view["byteLength"]));
                let __BREAK__FLAG__=false;
                for(let __iter__72 in __elements__73) {
                    __array__75.push(await __for_body__74(__elements__73[__iter__72]));
                    if(__BREAK__FLAG__) {
                         __array__75.pop();
                        break;
                        
                    }
                }return __array__75;
                 
            })();
            return (hexcodes).join("")
        }
    } else {
        throw new TypeError(("sha1: requires a single string as an argument - got "+ await subtype(text)));
        
    }
};__obj__1["remove_if"]=async function(f,container) {
    let __collector;
    let __result;
    let __action;
    __collector=[];
    __result=null;
    __action=async function(v) {
        if (check_true (await (await Environment.get_global("not"))(await (async function(){
            let __array_op_rval__76=f;
             if (__array_op_rval__76 instanceof Function){
                return await __array_op_rval__76(v) 
            } else {
                return [__array_op_rval__76,v]
            }
        })()))){
            return v
        }
    };
    ;
    await (async function() {
        let __for_body__79=async function(__item) {
            __result=await __action(__item);
            if (check_true (__result)){
                return (__collector).push(__result)
            }
        };
        let __array__80=[],__elements__78=container;
        let __BREAK__FLAG__=false;
        for(let __iter__77 in __elements__78) {
            __array__80.push(await __for_body__79(__elements__78[__iter__77]));
            if(__BREAK__FLAG__) {
                 __array__80.pop();
                break;
                
            }
        }return __array__80;
         
    })();
    return __collector
};__obj__1["filter"]=async function(f,container) {
    let __collector;
    let __result;
    let __action;
    __collector=[];
    __result=null;
    __action=async function(v) {
        if (check_true (await (async function(){
            let __array_op_rval__81=f;
             if (__array_op_rval__81 instanceof Function){
                return await __array_op_rval__81(v) 
            } else {
                return [__array_op_rval__81,v]
            }
        })())){
            return v
        }
    };
    ;
    await (async function() {
        let __for_body__84=async function(__item) {
            __result=await __action(__item);
            if (check_true (__result)){
                return (__collector).push(__result)
            }
        };
        let __array__85=[],__elements__83=container;
        let __BREAK__FLAG__=false;
        for(let __iter__82 in __elements__83) {
            __array__85.push(await __for_body__84(__elements__83[__iter__82]));
            if(__BREAK__FLAG__) {
                 __array__85.pop();
                break;
                
            }
        }return __array__85;
         
    })();
    return __collector
};__obj__1["add_days"]=async function(date_obj,num_days) {
    await date_obj["setDate"].call(date_obj,await (await Environment.get_global("add"))(await date_obj["getDate"](),num_days));
    return date_obj
};__obj__1["day_of_week"]=async function(dval) {
    return await dval["getDay"]()
};__obj__1["add_hours"]=async function(date_obj,hours) {
    await date_obj["setHours"].call(date_obj,hours);
    return date_obj
};__obj__1["clear_time"]=async function(date_obj) {
    await date_obj["setHours"].call(date_obj,0,0,0,0);
    return date_obj
};__obj__1["yesterday"]=async function() {
    let d1;
    let d2;
    d1=new Date();
    d2=new Date();
    return [await (await Environment.get_global("clear_time"))(await (await Environment.get_global("add_days"))(d1,-1)),await (await Environment.get_global("add_hours"))(await (await Environment.get_global("clear_time"))(await (await Environment.get_global("add_days"))(d2,-1)),24)]
};__obj__1["next_sunday"]=async function(dval) {
    let dv=(dval|| new Date());
    ;
    return await (await Environment.get_global("clear_time"))(await (await Environment.get_global("add_days"))(dv,(7- await (await Environment.get_global("day_of_week"))(dv))))
};__obj__1["last_sunday"]=async function(dval) {
    let dv=(dval|| new Date());
    ;
    return await (await Environment.get_global("clear_time"))(await (await Environment.get_global("add_days"))(dv,(-1* await (await Environment.get_global("day_of_week"))(dv))))
};__obj__1["day_before_yesterday"]=async function() {
    let d1;
    let d2;
    d1=await (await Environment.get_global("clear_time"))(await (await Environment.get_global("add_days"))(new Date(),-2));
    d2=await (await Environment.get_global("clear_time"))(await (await Environment.get_global("add_days"))(new Date(),-1));
    return await (async function(){
        let __array_op_rval__94=d1;
         if (__array_op_rval__94 instanceof Function){
            return await __array_op_rval__94(d2) 
        } else {
            return [__array_op_rval__94,d2]
        }
    })()
};__obj__1["last_week"]=async function() {
    let d1;
    let d2;
    d1=new Date();
    d2=new Date();
    return [await (await Environment.get_global("clear_time"))(await (await Environment.get_global("add_days"))(await (await Environment.get_global("next_sunday"))(),-14)),await (await Environment.get_global("last_sunday"))()]
};__obj__1["midnight-to-midnight"]=async function(dval) {
    let d1;
    let d2;
    d1=await (await Environment.get_global("clear_time"))(new Date(dval));
    d2=await (await Environment.get_global("clear_time"))(new Date(dval));
    return await (async function(){
        let __array_op_rval__95=d1;
         if (__array_op_rval__95 instanceof Function){
            return await __array_op_rval__95(await (await Environment.get_global("add_hours"))(d2,24)) 
        } else {
            return [__array_op_rval__95,await (await Environment.get_global("add_hours"))(d2,24)]
        }
    })()
};__obj__1["date_to_string"]=async function(date_val,str_layout) {
    let split_regex;
    let comps;
    let t_flag;
    let construction;
    let t_sep;
    let acc;
    let date_comps;
    let formatter;
    let add_formatter;
    let format_desc;
    split_regex=new RegExp("([\.:\ T/, \-]+)","g");
    comps=(((str_layout instanceof String || typeof str_layout==='string')&& (str_layout).split(split_regex))|| []);
    t_flag=null;
    construction=[];
    t_sep=null;
    acc=[];
    date_comps=null;
    formatter=null;
    add_formatter=async function(key,value) {
        await async function(){
            if (check_true ((key==="fractionalSecondDigits"))) {
                return (construction).push("fractionalSecond")
            } else if (check_true ((key==="hour24"))) {
                {
                    (construction).push("hour");
                    await async function(){
                        format_desc["hourCycle"]="h24";
                        return format_desc;
                        
                    }();
                    key="hour"
                }
            } else {
                (construction).push(key)
            }
        } ();
        return await async function(){
            format_desc[key]=value;
            return format_desc;
            
        }()
    };
    format_desc=new Object();
    await (async function() {
        let __for_body__100=async function(c) {
            return await async function(){
                if (check_true ((c==="yyyy"))) {
                    return await add_formatter("year","numeric")
                } else if (check_true ((c==="yy"))) {
                    return await add_formatter("year","2-digit")
                } else if (check_true ((c==="dd"))) {
                    return await add_formatter("day","2-digit")
                } else if (check_true ((c==="d"))) {
                    return await add_formatter("day","numeric")
                } else if (check_true ((c==="MM"))) {
                    return await add_formatter("month","2-digit")
                } else if (check_true ((c==="M"))) {
                    return await add_formatter("month","numeric")
                } else if (check_true ((c==="HH"))) {
                    return await add_formatter("hour24","2-digit")
                } else if (check_true ((c==="H"))) {
                    return await add_formatter("hour24","numeric")
                } else if (check_true ((c==="h"))) {
                    return await add_formatter("hour","2-digit")
                } else if (check_true ((c==="h"))) {
                    return await add_formatter("hour","numeric")
                } else if (check_true ((c==="mm"))) {
                    return await add_formatter("minute","2-digit")
                } else if (check_true ((c==="m"))) {
                    return await add_formatter("minute","numeric")
                } else if (check_true ((c==="s"))) {
                    return await add_formatter("second","numeric")
                } else if (check_true ((c==="ss"))) {
                    return await add_formatter("second","2-digit")
                } else if (check_true ((c==="sss"))) {
                    return await add_formatter("fractionalSecondDigits",3)
                } else if (check_true ((c==="TZ"))) {
                    return await add_formatter("timeZoneName","short")
                } else if (check_true ((c==="D"))) {
                    return await add_formatter("weekday","narrow")
                } else if (check_true ((c==="DD"))) {
                    return await add_formatter("weekday","short")
                } else if (check_true ((c==="DDD"))) {
                    return await add_formatter("weekday","long")
                } else {
                    return (construction).push(c)
                }
            } ()
        };
        let __array__101=[],__elements__99=comps;
        let __BREAK__FLAG__=false;
        for(let __iter__98 in __elements__99) {
            __array__101.push(await __for_body__100(__elements__99[__iter__98]));
            if(__BREAK__FLAG__) {
                 __array__101.pop();
                break;
                
            }
        }return __array__101;
         
    })();
    formatter=new Intl.DateTimeFormat([],format_desc);
    date_comps=await (async function(){
         return await (await Environment.get_global("date_components"))(date_val,formatter) 
    })();
    return (await (async function() {
        let __for_body__104=async function(key) {
            return (date_comps[key]|| key)
        };
        let __array__105=[],__elements__103=construction;
        let __BREAK__FLAG__=false;
        for(let __iter__102 in __elements__103) {
            __array__105.push(await __for_body__104(__elements__103[__iter__102]));
            if(__BREAK__FLAG__) {
                 __array__105.pop();
                break;
                
            }
        }return __array__105;
         
    })()).join("")
};__obj__1["is_even?"]=async function(x) {
    return (0===(x% 2))
};__obj__1["is_odd?"]=async function(x) {
    return (1===(x% 2))
};__obj__1["set_path_value"]=async function(root,path,value) {
    if (check_true ((path instanceof Array))){
        {
            let idx;
            let parent;
            idx=await (await Environment.get_global("last"))(path);
            parent=await (await Environment.get_global("resolve_path"))(await (await Environment.get_global("chop"))(path),root);
            if (check_true (parent)){
                await async function(){
                    parent[idx]=value;
                    return parent;
                    
                }()
            };
            return parent
        }
    } else {
        {
            return root
        }
    }
};__obj__1["has_items?"]=async function(value) {
    if (check_true ((await (await Environment.get_global("not"))((null===value))&& (await (await Environment.get_global("length"))(value)>0)))){
        return true
    } else {
        return false
    }
};__obj__1["match_all_js"]=function anonymous(regex_str,search_string
) {
let rval=[];let regex=new RegExp(regex_str,'g'); while ((m = regex.exec(search_string)) !== null) {rval.push(m);  if (m.index === regex.lastIndex) {  regex.lastIndex++; }  } return rval;
};__obj__1["match_all"]=async function(regex_str,search_string) {
    return await (await Environment.get_global("match_all_js"))(regex_str,search_string)
};__obj__1["chop_front"]=function(container,amount) {
        amount=(amount|| 1);
        return   (function(){
            if (check_true ((container instanceof String || typeof container==='string'))) {
                return  container["substr"].call(container,amount)
            } else if (check_true ((container instanceof Array))) {
                return  container["slice"].call(container,amount)
            } else {
                throw new Error("chop: container must be a string or array");
                
            }
        } )()
    };__obj__1["compile_lisp"]=async function(text) {
    if (check_true (text)){
        return await (await Environment.get_global("reader"))(text)
    } else {
        return text
    }
};__obj__1["has_the_keys?"]=async function(key_list,obj) {
    let is_fit;
    is_fit=true;
    {
        await (async function() {
            let __for_body__109=async function(item) {
                return is_fit=((await (await Environment.get_global("resolve_path"))(item,obj)|| false)&& is_fit)
            };
            let __array__110=[],__elements__108=key_list;
            let __BREAK__FLAG__=false;
            for(let __iter__107 in __elements__108) {
                __array__110.push(await __for_body__109(__elements__108[__iter__107]));
                if(__BREAK__FLAG__) {
                     __array__110.pop();
                    break;
                    
                }
            }return __array__110;
             
        })();
        return is_fit
    }
};__obj__1["demarked_number"]=async function(value,separator,precision,no_show_sign) {
    let abs_value;
    let vf;
    let comps;
    let l;
    let sep;
    let prec;
    let sign;
    abs_value=await Math.abs(value);
    vf=await Math.floor(abs_value);
    comps=(await (await Environment.get_global("split"))((""+ vf),"")).slice(0).reverse();
    l=await (await Environment.get_global("length"))(comps);
    sep=(separator|| ",");
    prec=(await (async function(){
        if (check_true ((null==precision))){
            return 2
        }
    })()|| precision);
    sign=await (async function(){
        if (check_true (((value<0)&& await (await Environment.get_global("not"))(no_show_sign)))){
            return "-"
        } else {
            return ""
        }
    })();
    if (check_true ((l>3))){
        await (async function() {
            let __for_body__113=async function(p) {
                return await comps["splice"].call(comps,p,0,sep)
            };
            let __array__114=[],__elements__112=(await (await Environment.get_global("range"))(3,l,3)).slice(0).reverse();
            let __BREAK__FLAG__=false;
            for(let __iter__111 in __elements__112) {
                __array__114.push(await __for_body__113(__elements__112[__iter__111]));
                if(__BREAK__FLAG__) {
                     __array__114.pop();
                    break;
                    
                }
            }return __array__114;
             
        })()
    };
    return (sign+ ((comps).slice(0).reverse()).join("")+ await (await Environment.get_global("chop_front"))(await (async function() {
        {
             let __call_target__=(abs_value% vf), __call_method__="toFixed";
            return await __call_target__[__call_method__].call(__call_target__,prec)
        } 
    })()))
};__obj__1["measure_time"]=async function(...args) {
    let forms;
    forms=await (await Environment.get_global("slice"))(args,0);
    return ["=:let",[["=:end","=:nil"],["=:rval","=:nil"],["=:start",["=:time_in_millis"]]],["=:=","=:rval",["=:do",].concat(forms)],{ "time":["=:-",["=:time_in_millis"],"=:start"],"result":"=:rval"
}]
};__obj__1["compare_list_ends"]=async function(l1,l2) {
    let long_short;
    let long;
    let short;
    let match_count;
    let idx;
    let matcher;
    long_short=await (async function(){
        if (check_true ((await (await Environment.get_global("length"))(l1)>await (await Environment.get_global("length"))(l2)))){
            return [l1,l2]
        } else {
            return [l2,l1]
        }
    })();
    long=((long_short && long_short["0"])).slice(0).reverse();
    short=((long_short && long_short["1"])).slice(0).reverse();
    match_count=0;
    idx=0;
    matcher=async function(val) {
        if (check_true ((val===long[idx]))){
            match_count+=1
        };
        return idx=(idx+ 1)
    };
    await (await Environment.get_global("map"))(matcher,short);
    if (check_true ((match_count===await (await Environment.get_global("length"))(short)))){
        return true
    } else {
        return false
    }
};__obj__1["hsv_to_rgb"]=function anonymous(h,s,v
) {
{
        var r, g, b, i, f, p, q, t;
        if (arguments.length === 1) {
            s = h.s, v = h.v, h = h.h;
        }
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }
        return {
            r: r,
            g: g,
            b: b
        }
    }
};__obj__1["rgb_to_text"]=async function(rgb) {
    return (await (async function() {
        let __for_body__117=async function(v) {
            let vs=await (async function() {
                {
                     let __call_target__=await Math.round((v* 255)), __call_method__="toString";
                    return await __call_target__[__call_method__].call(__call_target__,16)
                } 
            })();
            ;
            if (check_true ((await (await Environment.get_global("length"))(vs)===1))){
                return ("0"+ vs)
            } else {
                return vs
            }
        };
        let __array__118=[],__elements__116=rgb;
        let __BREAK__FLAG__=false;
        for(let __iter__115 in __elements__116) {
            __array__118.push(await __for_body__117(__elements__116[__iter__115]));
            if(__BREAK__FLAG__) {
                 __array__118.pop();
                break;
                
            }
        }return __array__118;
         
    })()).join("")
};__obj__1["text_to_rgb"]=async function(rgb_string) {
    if (check_true (rgb_string)){
        return await (async function(){
            let __array_op_rval__119=(await parseInt((await (async function(){
                 return await (await Environment.get_global("nth"))([0,1],rgb_string) 
            })()).join(''),16)/ 255);
             if (__array_op_rval__119 instanceof Function){
                return await __array_op_rval__119((await parseInt((await (async function(){
                     return await (await Environment.get_global("nth"))([2,3],rgb_string) 
                })()).join(''),16)/ 255),(await parseInt((await (async function(){
                     return await (await Environment.get_global("nth"))([4,5],rgb_string) 
                })()).join(''),16)/ 255)) 
            } else {
                return [__array_op_rval__119,(await parseInt((await (async function(){
                     return await (await Environment.get_global("nth"))([2,3],rgb_string) 
                })()).join(''),16)/ 255),(await parseInt((await (async function(){
                     return await (await Environment.get_global("nth"))([4,5],rgb_string) 
                })()).join(''),16)/ 255)]
            }
        })()
    } else {
        return null
    }
};__obj__1["rgb_to_hsv"]=async function(rgb) {
    if (check_true (rgb)){
        {
            let computedH;
            let computedS;
            let computedV;
            let r;
            let g;
            let b;
            let minRGB;
            let maxRGB;
            let d;
            let h;
            computedH=0;
            computedS=0;
            computedV=0;
            r=(rgb && rgb["0"]);
            g=(rgb && rgb["1"]);
            b=(rgb && rgb["2"]);
            minRGB=await Math.min(r,await Math.min(g,b));
            maxRGB=await Math.max(r,await Math.max(g,b));
            d=null;
            h=null;
            if (check_true ((minRGB===maxRGB))){
                return [0,0,minRGB];
                
            };
            d=await (async function(){
                 return await async function(){
                    if (check_true ((r===minRGB))) {
                        return (g- b)
                    } else if (check_true ((b===minRGB))) {
                        return (r- g)
                    } else {
                        return (b- r)
                    }
                } () 
            })();
            h=await (async function(){
                 return await async function(){
                    if (check_true ((r===minRGB))) {
                        return 3
                    } else if (check_true ((b===minRGB))) {
                        return 1
                    } else {
                        return 5
                    }
                } () 
            })();
            await console.log("");
            computedH=((60* (h- (d/ (maxRGB- minRGB))))/ 360);
            computedS=((maxRGB- minRGB)/ maxRGB);
            computedV=maxRGB;
            return await (async function(){
                let __array_op_rval__121=computedH;
                 if (__array_op_rval__121 instanceof Function){
                    return await __array_op_rval__121(computedS,computedV) 
                } else {
                    return [__array_op_rval__121,computedS,computedV]
                }
            })()
        }
    }
};__obj__1["tint_rgb"]=async function(rgb,tint_factor) {
    if (check_true ((rgb&& tint_factor))){
        return await (async function() {
            let __for_body__124=async function(c) {
                c=(255* c);
                return (await (await Environment.get_global("add"))(c,((255- c)* tint_factor))/ 255)
            };
            let __array__125=[],__elements__123=rgb;
            let __BREAK__FLAG__=false;
            for(let __iter__122 in __elements__123) {
                __array__125.push(await __for_body__124(__elements__123[__iter__122]));
                if(__BREAK__FLAG__) {
                     __array__125.pop();
                    break;
                    
                }
            }return __array__125;
             
        })()
    } else {
        return rgb
    }
};__obj__1["shade_rgb"]=async function(rgb,shade_factor) {
    if (check_true ((rgb&& shade_factor))){
        return await (async function() {
            let __for_body__128=async function(c) {
                c=(255* c);
                return ((c* (1- shade_factor))/ 255)
            };
            let __array__129=[],__elements__127=rgb;
            let __BREAK__FLAG__=false;
            for(let __iter__126 in __elements__127) {
                __array__129.push(await __for_body__128(__elements__127[__iter__126]));
                if(__BREAK__FLAG__) {
                     __array__129.pop();
                    break;
                    
                }
            }return __array__129;
             
        })()
    } else {
        return rgb
    }
};__obj__1["modify_color_ts"]=async function(rgb,factor) {
    if (check_true ((0<=factor))){
        return await (await Environment.get_global("tint_rgb"))(rgb,await Math.abs(factor))
    } else {
        return await (await Environment.get_global("shade_rgb"))(rgb,await Math.abs(factor))
    }
};__obj__1["is_lower?"]=async function(v) {
    let c=await v["charCodeAt"].call(v,0);
    ;
    return ((c>96)&& (c<123))
};__obj__1["is_upper?"]=async function(v) {
    let c=await v["charCodeAt"].call(v,0);
    ;
    return ((c>64)&& (c<91))
};__obj__1["camel_case_to_lower"]=async function(val) {
    let last_upper=0;
    ;
    return (await (async function(){
         return await (await Environment.get_global("map"))(async function(v,i) {
            return await async function(){
                if (check_true (((i>0)&& await (await Environment.get_global("is_upper?"))(v)&& (0===last_upper)))) {
                    {
                        last_upper=1;
                        return ("_"+ (v).toLowerCase())
                    }
                } else if (check_true (((i>0)&& await (await Environment.get_global("is_upper?"))(v)&& (last_upper>0)))) {
                    {
                        last_upper=2;
                        return (v).toLowerCase()
                    }
                } else if (check_true (((i===0)&& await (await Environment.get_global("is_upper?"))(v)))) {
                    return (v).toLowerCase()
                } else if (check_true (await (await Environment.get_global("is_lower?"))(v))) {
                    {
                        return await async function(){
                            if (check_true ((last_upper===2))) {
                                {
                                    last_upper=0;
                                    return ("_"+ (v).toLowerCase())
                                }
                            } else {
                                {
                                    last_upper=0;
                                    return (v).toLowerCase()
                                }
                            }
                        } ()
                    }
                } else {
                    {
                        last_upper=0;
                        return v
                    }
                }
            } ()
        },await (await Environment.get_global("split"))(val,"")) 
    })()).join("")
};__obj__1["scan_list"]=async function(regex,container) {
    let expr=regex;
    ;
    if (check_true (await (await Environment.get_global("not"))((await (await Environment.get_global("sub_type"))(regex)==="RegExp")))){
        {
            expr=new RegExp(regex)
        }
    };
    let cnt=0;
    ;
    let results=[];
    ;
    let r=null;
    ;
    await (async function() {
        let __for_body__132=async function(item) {
            r=await (async function(){
                if (check_true ((item instanceof String || typeof item==='string'))){
                    return await item["match"].call(item,expr)
                } else {
                    return await (async function() {
                        {
                             let __call_target__=(""+ item), __call_method__="match";
                            return await __call_target__[__call_method__].call(__call_target__,expr)
                        } 
                    })()
                }
            })();
            if (check_true (r)){
                (results).push(cnt)
            };
            return cnt+=1
        };
        let __array__133=[],__elements__131=(container|| []);
        let __BREAK__FLAG__=false;
        for(let __iter__130 in __elements__131) {
            __array__133.push(await __for_body__132(__elements__131[__iter__130]));
            if(__BREAK__FLAG__) {
                 __array__133.pop();
                break;
                
            }
        }return __array__133;
         
    })();
    return results
};__obj__1["gather_up_prop"]=async function(key,values) {
    return await async function(){
        if (check_true ((values instanceof Array))) {
            return await (await Environment.get_global("no_empties"))(await (async function(){
                 return await (await Environment.get_global("map"))(async function(v) {
                    return await async function(){
                        if (check_true ((v instanceof Array))) {
                            return await (await Environment.get_global("gather_up_prop"))(key,v)
                        } else if (check_true ((v instanceof Object))) {
                            return v[key]
                        }
                    } ()
                },values) 
            })())
        } else if (check_true ((values instanceof Object))) {
            return values[key]
        }
    } ()
};__obj__1["sum_up_prop"]=async function(key,values) {
    return await (await Environment.get_global("sum"))(await (await Environment.get_global("flatten"))(await (await Environment.get_global("gather_up_prop"))(key,values)))
};__obj__1["scan_for"]=async function(non_nil_prop,list_of_objects) {
    let rval=null;
    ;
    await (async function() {
        let __for_body__136=async function(val) {
            if (check_true ((val&& val[non_nil_prop]))){
                {
                    rval=val[non_nil_prop];
                    return __BREAK__FLAG__=true;
                    return
                }
            }
        };
        let __array__137=[],__elements__135=(list_of_objects|| []);
        let __BREAK__FLAG__=false;
        for(let __iter__134 in __elements__135) {
            __array__137.push(await __for_body__136(__elements__135[__iter__134]));
            if(__BREAK__FLAG__) {
                 __array__137.pop();
                break;
                
            }
        }return __array__137;
         
    })();
    return rval
};__obj__1["make_sort_buckets"]=async function() {
    let buckets;
    let push_to;
    buckets=new Object();
    push_to=async function(category,thing) {
        let place;
        place=null;
        if (check_true ((null==category))){
            return buckets
        } else {
            {
                place=buckets[category];
                if (check_true (place)){
                    (place).push(thing)
                } else {
                    await async function(){
                        buckets[category]=await (async function(){
                            let __array_op_rval__139=thing;
                             if (__array_op_rval__139 instanceof Function){
                                return await __array_op_rval__139() 
                            } else {
                                return [__array_op_rval__139]
                            }
                        })();
                        return buckets;
                        
                    }()
                };
                return thing
            }
        }
    };
    return push_to
};__obj__1["bytes_from_int_16"]=function anonymous(x
) {
{ let bytes = []; let i = 2; do { bytes[(1 - --i)] = x & (255); x = x>>8; } while ( i ) return bytes;}
};__obj__1["int_16_from_bytes"]=function anonymous(x,y
) {
 { let val = 0;  val +=y; val = val << 8; val +=x; return val; }
};__obj__1["truncate"]=async function(len,value,trailer) {
    trailer=(trailer|| "");
    return await async function(){
        if (check_true ((value instanceof String || typeof value==='string'))) {
            if (check_true (((value && value.length)>len))){
                return await (await Environment.get_global("add"))(await value["substr"].call(value,0,len),trailer)
            } else {
                return value
            }
        } else if (check_true ((value instanceof Array))) {
            return await value["slice"].call(value,0,len)
        } else {
            return value
        }
    } ()
};__obj__1["parse_csv"]=async function(csv_data,options) {
    let lbuffer;
    let sepval;
    let sepval_r;
    let fixer_r;
    let interruptions;
    let line;
    let count;
    let tmp;
    let rval;
    let match_list;
    let lines;
    let total_lines;
    lbuffer=null;
    sepval=((options && options["separator"])|| ",");
    sepval_r=new RegExp(sepval,"g");
    fixer_r=new RegExp("!SEPVAL!","g");
    interruptions=((options && options["interruptions"])|| false);
    line=null;
    count=0;
    tmp=null;
    rval=null;
    match_list=null;
    lines=await (async function(){
         return await async function(){
            if (check_true ((csv_data instanceof Array))) {
                return csv_data
            } else if (check_true ((csv_data instanceof String || typeof csv_data==='string'))) {
                return (await (await Environment.get_global("replace"))(new RegExp("[\r]+","g"),"",csv_data)).split("\n")
            }
        } () 
    })();
    total_lines=(lines && lines.length);
    if (check_true (interruptions)){
        await (await Environment.get_global("sleep"))(0.1)
    };
    return await (async function() {
        let __for_body__142=async function(v) {
            if (check_true (interruptions)){
                {
                    count+=1;
                    if (check_true (((count% 1000)===0))){
                        {
                            await (await Environment.get_global("sleep"))(0.1);
                            if (check_true ((options && options["notifier"]))){
                                await (async function(){
                                    let __array_op_rval__144=(options && options["notifier"]);
                                     if (__array_op_rval__144 instanceof Function){
                                        return await __array_op_rval__144((count/ total_lines),count,total_lines) 
                                    } else {
                                        return [__array_op_rval__144,(count/ total_lines),count,total_lines]
                                    }
                                })()
                            }
                        }
                    }
                }
            };
            match_list=(await (await Environment.get_global("scan_str"))(new RegExp("\"([A-Za-z0-9, .  :;]+)\"","g"),v)).slice(0).reverse();
            line=await (async function(){
                if (check_true (((match_list && match_list.length)>0))){
                    {
                        rval=[];
                        await (async function() {
                            let __for_body__147=async function(m) {
                                return (rval).push(await (async function(){
                                    let __array_op_rval__149=(m && m["index"]);
                                     if (__array_op_rval__149 instanceof Function){
                                        return await __array_op_rval__149(await (await Environment.get_global("replace"))(sepval_r,"!SEPVAL!",m["1"]),m["1"]) 
                                    } else {
                                        return [__array_op_rval__149,await (await Environment.get_global("replace"))(sepval_r,"!SEPVAL!",m["1"]),m["1"]]
                                    }
                                })())
                            };
                            let __array__148=[],__elements__146=match_list;
                            let __BREAK__FLAG__=false;
                            for(let __iter__145 in __elements__146) {
                                __array__148.push(await __for_body__147(__elements__146[__iter__145]));
                                if(__BREAK__FLAG__) {
                                     __array__148.pop();
                                    break;
                                    
                                }
                            }return __array__148;
                             
                        })();
                        tmp=v;
                        await (async function() {
                            let __for_body__152=async function(r) {
                                return tmp=(""+ await tmp["substr"].call(tmp,0,(r && r["0"]))+ (r && r["1"])+ await tmp["substr"].call(tmp,(2+ (r && r["0"])+ await (await Environment.get_global("length"))((r && r["2"])))))
                            };
                            let __array__153=[],__elements__151=rval;
                            let __BREAK__FLAG__=false;
                            for(let __iter__150 in __elements__151) {
                                __array__153.push(await __for_body__152(__elements__151[__iter__150]));
                                if(__BREAK__FLAG__) {
                                     __array__153.pop();
                                    break;
                                    
                                }
                            }return __array__153;
                             
                        })();
                        return tmp
                    }
                } else {
                    return v
                }
            })();
            return await (async function() {
                let __for_body__156=async function(segment) {
                    return await (await Environment.get_global("replace"))(fixer_r,sepval,segment)
                };
                let __array__157=[],__elements__155=(line).split(sepval);
                let __BREAK__FLAG__=false;
                for(let __iter__154 in __elements__155) {
                    __array__157.push(await __for_body__156(__elements__155[__iter__154]));
                    if(__BREAK__FLAG__) {
                         __array__157.pop();
                        break;
                        
                    }
                }return __array__157;
                 
            })()
        };
        let __array__143=[],__elements__141=lines;
        let __BREAK__FLAG__=false;
        for(let __iter__140 in __elements__141) {
            __array__143.push(await __for_body__142(__elements__141[__iter__140]));
            if(__BREAK__FLAG__) {
                 __array__143.pop();
                break;
                
            }
        }return __array__143;
         
    })()
};__obj__1["to_csv"]=async function(rows,delimiter) {
    let quote_quoter=new RegExp("\"","g");
    ;
    return (await (async function() {
        let __for_body__160=async function(row) {
            return (await (async function(){
                 return await (await Environment.get_global("map"))(async function(v) {
                    if (check_true (((v instanceof String || typeof v==='string')&& (await (await Environment.get_global("contains?"))(" ",(""+ v+ ""))|| await (await Environment.get_global("contains?"))(delimiter,v)|| await (await Environment.get_global("contains?"))("\"",v))))){
                        return ("\""+ await (await Environment.get_global("replace"))(quote_quoter,"\"\"",v)+ "\"")
                    } else {
                        return (""+ v+ "")
                    }
                },row) 
            })()).join(await (async function(){
                if (check_true (delimiter)){
                    return delimiter
                } else {
                    return ","
                }
            })())
        };
        let __array__161=[],__elements__159=rows;
        let __BREAK__FLAG__=false;
        for(let __iter__158 in __elements__159) {
            __array__161.push(await __for_body__160(__elements__159[__iter__158]));
            if(__BREAK__FLAG__) {
                 __array__161.pop();
                break;
                
            }
        }return __array__161;
         
    })()).join("\n")
};__obj__1["squeeze"]=async function(s) {
    return await (await Environment.get_global("replace"))(new RegExp(" ","g"),"",s)
};__obj__1["ensure_keys"]=async function(keylist,obj,default_value) {
    default_value=await (async function(){
        if (check_true ((undefined===default_value))){
            return null
        } else {
            return default_value
        }
    })();
    if (check_true ((null==obj))){
        {
            obj=new Object()
        }
    };
    await (async function() {
        let __for_body__164=async function(key) {
            if (check_true ((undefined===obj[key]))){
                {
                    return await async function(){
                        obj[key]=default_value;
                        return obj;
                        
                    }()
                }
            }
        };
        let __array__165=[],__elements__163=keylist;
        let __BREAK__FLAG__=false;
        for(let __iter__162 in __elements__163) {
            __array__165.push(await __for_body__164(__elements__163[__iter__162]));
            if(__BREAK__FLAG__) {
                 __array__165.pop();
                break;
                
            }
        }return __array__165;
         
    })();
    return obj
};__obj__1["show_time_in_words"]=function anonymous(seconds,options
) {
options=options||{}
        if (options['longForm']==null) {
            if (seconds<2) return "now";
            if (seconds<61) return parseInt(seconds)+" secs";
            if ((seconds>61)&&(seconds<120)) return "1 min";
            if (seconds<3601) {
                // less than an hour
                return parseInt(seconds/60)+" mins";
            }
        } else if (options['longForm']==true) {
            if (seconds<61) return parseInt(seconds)+" seconds";
            if ((seconds>61)&&(seconds<120)) return "1 minute";
            if (seconds<3601) {
                // less than an hour
                return parseInt(seconds / 60) + " minutes";
            }
        }

        if (seconds<86400) {
            return parseInt(seconds/3600)+" hours";
        }
        if (seconds<172801) {
            return parseInt(seconds/86400)+" day";
        }
        if (seconds < 31536000) {
            return parseInt(seconds/86400)+" days";
        }
        if (seconds < (2 * 31536000)) {
            return "1 year";
        }
        return parseInt(seconds/31536000)+" years";
 
};__obj__1["ago"]=async function(dval) {
    return await (await Environment.get_global("show_time_in_words"))(((await (async function() {
        {
             let __call_target__=new Date(), __call_method__="getTime";
            return await __call_target__[__call_method__]()
        } 
    })()- await dval["getTime"]())/ 1000))
};__obj__1["lifespan"]=async function(dval) {
    return await (await Environment.get_global("show_time_in_words"))(((await dval["getTime"]()- await (async function() {
        {
             let __call_target__=new Date(), __call_method__="getTime";
            return await __call_target__[__call_method__]()
        } 
    })())/ 1000))
};__obj__1["rotate_right"]=function(array_obj) {
        (array_obj).unshift((array_obj).pop());
        return array_obj
    };__obj__1["rotate_left"]=function(array_obj) {
        (array_obj).push((array_obj).shift());
        return array_obj
    };__obj__1["interpolate"]=function(from,to,steps) {
        let cur;
        let step_size;
        let tmp;
        let acc;
        cur=from;
        step_size=1;
        tmp=0;
        acc=[];
         ( Environment.get_global("assert"))(( ( Environment.get_global("is_number?"))(from)&&  ( Environment.get_global("is_number?"))(to)&&  ( Environment.get_global("is_number?"))(steps)),"interpolate: all arguments must be numbers");
         ( Environment.get_global("assert"))(( Math.abs((from- to))>0),"interpolate: from and to numbers cannot be the same");
         ( Environment.get_global("assert"))((steps>1),"interpolate: steps must be greater than 1");
        step_size=((to- from)/ (steps- 1));
        if (check_true ((to>from))){
            {
                 ( function(){
                     let __test_condition__167=function() {
                        return (cur<=to)
                    };
                    let __body_ref__168=function() {
                        (acc).push(cur);
                        return cur=(cur+ step_size)
                    };
                    let __BREAK__FLAG__=false;
                    while( __test_condition__167()) {
                          __body_ref__168();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                if (check_true (((acc && acc.length)<steps))){
                    (acc).push(to)
                }
            }
        } else {
            {
                 ( function(){
                     let __test_condition__169=function() {
                        return (cur>=to)
                    };
                    let __body_ref__170=function() {
                        (acc).push(cur);
                        return cur=(cur+ step_size)
                    };
                    let __BREAK__FLAG__=false;
                    while( __test_condition__169()) {
                          __body_ref__170();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                if (check_true (((acc && acc.length)<steps))){
                    (acc).push(to)
                }
            }
        };
        return acc
    };__obj__1["unload_core_ext"]=async function() {
    let count;
    let core_handle;
    count=0;
    core_handle=await Environment["get_namespace_handle"].call(Environment,"core");
    await (async function() {
        let __for_body__173=async function(def) {
            if (check_true (((def && def["source_name"])==="src/core-ext.lisp"))){
                {
                    console.log(("(undefine `"+ (def && def.name)+ ")"));
                    if (check_true (await core_handle["evaluate_local"].call(core_handle,("(undefine `"+ (def && def.name)+ ")")))){
                        return count+=1
                    }
                }
            }
        };
        let __array__174=[],__elements__172=(core_handle && core_handle["definitions"]);
        let __BREAK__FLAG__=false;
        for(let __iter__171 in __elements__172) {
            __array__174.push(await __for_body__173(__elements__172[__iter__171]));
            if(__BREAK__FLAG__) {
                 __array__174.pop();
                break;
                
            }
        }return __array__174;
         
    })();
    console.log(("removed "+ count+ " definitions."));
    return count
};__obj__1["documentation_coverage"]=async function(ns) {
    let env;
    let good;
    let missing;
    let total;
    env=await (async function(){
        if (check_true (ns)){
            return await Environment["get_namespace_handle"].call(Environment,ns)
        } else {
            return Environment
        }
    })();
    good=[];
    missing=[];
    total=0;
    await (async function() {
        let __for_body__177=async function(_pset) {
            {
                let sym;
                let meta;
                sym=(_pset && _pset["0"]);
                meta=(_pset && _pset["1"]);
                if (check_true ((meta && meta["description"]))){
                    return (good).push(sym)
                } else {
                    return (missing).push(sym)
                }
            }
        };
        let __array__178=[],__elements__176=await (await Environment.get_global("pairs"))((env && env["definitions"]));
        let __BREAK__FLAG__=false;
        for(let __iter__175 in __elements__176) {
            __array__178.push(await __for_body__177(__elements__176[__iter__175]));
            if(__BREAK__FLAG__) {
                 __array__178.pop();
                break;
                
            }
        }return __array__178;
         
    })();
    total=((good && good.length)+ (missing && missing.length));
    return {
        total:total,ratio:((good && good.length)/ total),num_good:(good && good.length),num_missing:(missing && missing.length),good:good,missing:missing
    }
};__obj__1["*lz_string_contents*"]="// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.4\n\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nconst LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\nreturn LZString;\n\n\n\n\n";__obj__1["LZString"]=await (async function(){ return "placeholder" })();__obj__1["html_package"]=await (async function(){ return ";; Juno HTML Pakage\n\n;; For browser based DOM utilization and manipulation\n\n;; Initializes and loads the html namespace \n;; (c) 2022 Kina\n;; Author: Alex Nygren\n\n(console.log \"HTML Package: \" (namespaces) (contains? \"html\" (namespaces)))\n\n(when (contains? \"html\" (namespaces))\n  (delete_namespace `html))\n\n(create_namespace `html { `serialize_with_image: false })\n\n\n(declare (namespace `html))\n\n\n;; Tag component names sourced from\n;; https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\n\n(defglobal *DOM_TAGS* [`html `base `head `link `meta `style `title\n                       `body `address `article `aside `footer `header\n                       `h1 `h2 `h3 `h4 `h5 `h6\n                       `main `nav `section\n                       `blockquote `dd `div `dl `dt `figcaption `figure\n                       `hr `li `menu `ol `p `pre `ul\n                       `a `abbr `b `bdi `bdo `br `cite `code `data `dfn `em\n                       `i `kbd `mark `q `rp `rt `ruby `s `samp `small `span\n                       `strong `sub `time `u `var `wbr\n                       `area `audio `img  `track `video\n                       `embed `iframe `object `picture `portal `source\n                       `svg `math `canvas `noscript `script\n                       `del `ins\n                       `caption `col `colgroup `table `tbody `td `tfoot\n                       `th `thead `tr\n                       `button `datalist `fieldset `form `input `label `legend\n                       `meter `optgroup `option `output `progress `select `textarea\n                       `details `dialog `summary\n                       `slot `template ])\n\n\n(defmacro get_by_id (id)\n  `(-> document `getElementById ,#id)\n  {\n   `description: \"Given an id, this macro is shorthand for calling document.getElementById with the passed id\"\n   `usage: [\"id:string\"]\n   `tags: [\"html\" \"DOM\" \"id\" \"find\" ]\n   })\n\n(defun get_by_tag (tagname)\n  (if tagname\n    (-> document `querySelectorAll tagname)\n    (throw \"get_by_tag: invalid tagname provided\"))\n  {\n   `description: \"Deprecated: use query_all: Returns all tags in the document matching the provided tagname\"\n   `usage: [\"tagname:string\"]\n   `tags: [\"html\" \"DOM\" \"id\" \"find\" ]\n   })\n\n(defun query_all (query)\n  (if (is_string? query)\n    (-> document `querySelectorAll query)\n    (throw ReferenceError \"query_all: argument must be a string\"))\n  {\n   `description: \"Returns all tags in the document matching the provided tagname\"\n   `usage: [\"tagname:string\"]\n   `tags: [\"html\" \"DOM\" \"id\" \"find\" ]\n   })\n\n(defun append_children (parent children)\n  (when (and (is_element? parent)\n             (is_array? children))\n    (for_each (child children)\n              (-> parent `appendChild child)))\n  parent)\n\n\n(defun generate_id (prefix)\n  (if (is_string? prefix)\n    (+ \"\" prefix \"-\" (time_in_millis) \"-\" (random_int 9999999))\n    (+ \"control-\" (time_in_millis) \"-\" (random_int 9999999))))\n\n\n(defmacro getAttribute (elem attrib)  ;; legacy\n  `(-> ,#elem `getAttribute ,#attrib)\n   {\n     description: (+ \"Use get_attribute<br>.Given a DOM Element and attribute text, \"\n                     \"returns the value of the attrbute or nil \"\n                     \"if not set. \")\n     usage: [\"element:Element\" \"attrib:string\" \"value:string\"]\n     tags: [\"DOM\" \"attribute\" \"element\" \"set\" \"property\"]\n     deprecated: \"get_attribute\"\n   })\n\n(defmacro get_attribute (elem attrib)\n  `(-> ,#elem `getAttribute ,#attrib)\n  {\n     description: (+ \"Given a DOM Element and attribute text, \"\n                     \"returns the value of the attrbute or nil \"\n                     \"if not set.\")\n     usage: [\"element:Element\" \"attrib:string\" \"value:string\"]\n     tags: [\"DOM\" \"attribute\" \"element\" \"set\" \"property\"]\n   })\n\n(defmacro set_attribute (elem attrib value)\n   `(-> ,#elem `getAttribute ,#attrib ,#value)\n   {\n     description: (+ \"Given a DOM Element, attribute text and value, sets \"\n                     \"the provided attribute to the value on the element. \"\n                     \"There is no return value.\")\n     usage: [\"element:Element\" \"attrib:string\" \"value:string\"]\n     tags: [\"DOM\" \"attribute\" \"element\" \"set\" \"property\"]\n   })\n;(defbinding (html/create_element (document.createElement document.createElement)))\n\n;(defglobal html/create_element (-> document.createElement `bind document)\n ;  {\n  ;  `description: \"Binding for document.createElement\"\n   ; `initializer: (quote  (-> document.createElement `bind document))\n    ;})\n\n(defun_sync create_element (element_name)\n  (-> document `createElement element_name))\n\n;; first create the base constructor function which will be called\n;; with the tag to create\n\n(defun_sync append_children (parent children)\n  (do\n    (for_each (child (or children []))\n              (cond\n                (is_array? child)\n                (append_children parent child)\n                (is_element? child)\n                (-> parent `appendChild child)                               \n                child.view\n                (-> parent `appendChild child.view)\n                else\n                (-> parent `appendChild (-> document `createTextNode (+ \"\" child)))))\n    parent))\n\n(defun_sync create_dom_element (element_name `& args)\n  (let\n      ((opts (if (and (is_object? args.0)\n                      (not (is_array? args.0))\n                      (not (is_element? args.0)))\n               args.0\n               nil))\n       (content (if opts\n                  (if (> args.length 0)\n                    (rest args)\n                    [])\n                  (or args\n                      [])))       \n       (elem (-> document `createElement element_name)))\n    \n    (when opts\n      (for_each (pset (pairs opts))\n                (do\n                  (cond\n                    (is_function? pset.1)\n                    (set_prop elem\n                              pset.0\n                              pset.1)\n                    else\n                    (-> elem `setAttribute pset.0 pset.1)))))\n    (when (> content.length 0)\n      (for_each (child content)\n                (cond\n                  (is_element? child)\n                  (-> elem `appendChild child)\n                  (is_array? child)\n                  (append_children elem child)\n                  (is_string? child)\n                  (-> elem `appendChild (-> document `createTextNode child))\n                  else\n                  (try\n                    (-> elem `appendChild (-> document `createTextNode (+ \"\" child)))\n                    (catch TypeError (e)\n                      (-> elem `appendChild (-> document `createTextNode (+ \"ERROR: \" (subtype child)))))))))\n    elem))\n\n\n\n;; next create the individual pointers to the create_dom_element function\n;; for every tag name in the *DOM_TAG* list create the construction function\n\n(for_each (tagname *DOM_TAGS*)\n          (let\n              ((bound_fn (-> create_dom_element `bind create_dom_element tagname)))\n            ;; use the set_global function directly since we are dynamically creating the symbol names\n            (-> Environment `set_global\n                tagname\n                bound_fn\n                {\n                 `initializer: `((quote quote) (-> create_element `bind create_dom_element ,#tagname))\n                 `description: (+ \"The function \" tagname \" creates a DOM element of type \" tagname \" and returns the constructed object.\")\n                 `usage: [ \"options:?object\" \"elem:*\" \"elemN:*\" ]\n                 `tags: [\"html\" \"ui\" \"DOM\" \"tags\" \"element\" \"node\"]\n                 })))\n\n\n;; various helper functions \n\n(defun set_style (style_attributes elem)\n  (when (is_element? elem)\n    (let ((`current_style (-> elem `getAttribute \"style\"))\n          (`attribs       (or (no_empties (from_style_text current_style)) []))\n          (`combined      (pairs\n                           (to_object\n                            (conj attribs style_attributes))))\n          (`newtext\n           (join \";\"\n                 (for_each (`atr combined)\n                           (join \": \" atr)))))\n\n      (-> elem `setAttribute \"style\" newtext)\n      elem))\n  {\n   `tags:[\"ui\" \"html\" \"css\" \"element\" \"style\"]\n   `description:\"Given a set of style attributes in the [[attribute value]] form, and an element, sets the element style attribute to contain the specified values. Returns the element.\"\n   `usage:[\"style_attributes:list\" \"element:Element\"]\n   })\n\n(defun_sync has_class? (classname elem)\n  (if (and elem\n           (is_element? elem))\n    (-> elem.classList `contains classname)\n    false)\n  {\n   `usage: [\"classname:string\" \"element:Element\"]\n   `description: \"If the provided element has the specified CSS class, returns true, otherwise the function returns false\"\n   `tags: [\"css\" \"DOM\" \"class\" \"ui\" \"element\" \"html\"]\n   })\n\n(defun add_class (class_name `& elems)\n  (progn\n    (defvar effected [])\n    (= elems (flatten elems))\n    (when (and (not (eq nil elems))\n               (> elems.length 0))\n      (= elems (if (or (instanceof elems.0 NodeList)\n                       (instanceof elems.0 HTMLCollection)\n                       (and (is_array? elems.0)\n                            (> elems.0.length 0)))\n                 elems.0\n                 elems))\n      (when (> (length elems) 0)\n         (for_each (`e elems)\n            (do\n               (when e.classList\n                  (push effected e)\n                  (-> e.classList `add class_name))))))\n    effected)\n  {\n   `usage: [\"class_name:string\" \"element:Element\" \"element?:Element\"]\n   `description: \"Removes the designated CSS class from the provided element or elements. Returns the list of nodes.\"\n   `tags: [\"ui\" \"html\" \"css\" \"class\"]\n   })\n\n(defun remove_class (class_name `& elems)\n  (do\n    (defvar `effected [])\n    (= elems (flatten elems))\n    (when (and (not (eq nil elems))\n               (> elems.length 0))\n      (= elems (if (or (instanceof elems.0 NodeList)\n                       (instanceof elems.0 HTMLCollection)\n                       (is_array? elems.0))\n                 elems.0\n                 elems))\n      (for_each (`e elems)\n                (do\n                  (when e.classList\n                    (push effected e)\n                    (-> e.classList `remove class_name)))))\n    effected)\n  {\n   `usage: [\"class_name:string\" \"element:Element\" \"element?:Element\"]\n   `description: \"Removes the designated CSS class from the provided element or elements. Returns the list of nodes.\"\n   `tags: [\"ui\" \"html\" \"css\" \"class\"]\n   })\n\n(defun element_to_lisp (element options)\n   (if (is_element? element)\n       (let\n          ((tag_name (if (is_function? options.tagname_for_element)\n                         (-> options `tagname_for_element element)\n                         element.tagName))\n           (elem_as_lisp (list (+ \"=:\" (lowercase tag_name))))\n           (acc [])\n           (nodes nil)\n           (ptype nil)\n           (val nil)\n           (attrib_list (prop element `attributes))\n           (attribs {}))\n          (for_each (attrib_num (range (length attrib_list)))\n             (progn\n                (set_prop attribs\n                   (resolve_path [ `attributes attrib_num `name ] element)\n                   (resolve_path [ `attributes attrib_num `value ] element))))\n          (push elem_as_lisp\n             attribs)\n          (= nodes element.childNodes)\n          (for_each (cnum (range (length nodes)))\n             (cond \n                (== 3 (resolve_path [ cnum `nodeType ] nodes))\n                (push elem_as_lisp\n                   (resolve_path [ cnum `nodeValue] nodes))\n                (== 1 (resolve_path [ cnum `nodeType ] nodes))\n                (push elem_as_lisp\n                   (element_to_lisp (resolve_path [ cnum ] nodes) options))))\n          (if (is_function? options.on_element_complete)\n              (-> options `on_element_complete elem_as_lisp)\n              elem_as_lisp))\n       [ \"UNKNOWN:\" element ])\n   {\n     `description: (+ \"Given a DOM element, returns the lisp represenation of the DOM element.<br>\"\n                      \"If provided with an options object, the following keys are applicable:<br>\"\n                      \"tagname_for_element:(fn element) - For every new element encountered in the \"\n                      \"provided tree, will be called with the new element.  The function should \"\n                      \"return a string value to be used for the tagname as opposed to the original \"\n                      \"element tagName value.<br>\"\n                      \"on_element_complete:(fn array) - Will be called with the quoted lisp form \"\n                      \"that was constructed.  The function can then manipulate the completed form \"\n                      \"prior to it being placed in the returned lisp form.  Note that this function \"\n                      \"is called for every completed element, not just the final return value.\")\n     `usage: [\"element:element\"]\n     `tags: [\"DOM\" \"ui\" \"serialize\" \"serialization\" \"view\" \"element\" ]\n   })\n\n\n\n(defun set_disabled (`& args)\n  (when (and args (> (length args) 0))\n    (for_each (`elem (flatten args))\n              (if elem (-> elem `setAttribute `disabled \"true\"))))\n  { `description: \"Given an arbitrary list of Elements, set them to disabled.\"\n   `tags: [\"ui\" \"html\" \"css\"]\n   `usage: [\"element:Element\" \"element?:Element\"]\n   } )\n\n(defun set_enabled (`& args)\n  (when (and args (> (length args) 0))\n    (for_each (`elem (flatten args))\n              (if elem (-> elem `removeAttribute `disabled))))\n  { `description: \"Given an arbitrary list of Elements, set them to enabled (removes the disabled property from the Element).\"\n   `tags: [\"ui\" \"html\" \"css\"]\n   `usage: [\"element:Element\" \"element?:Element\"]\n   } )\n\n(defun remove_attribute (elem `& attribs)\n  (when (and elem\n             (is_element? elem)\n             attribs\n             (> attribs.length 0))\n    (for_each (attrib (flatten attribs))\n              (-> elem `removeAttribute attrib)))\n  {\n   `description: \"Provided a target DOM element and 1 or more attributes, removes each attribute from the targeted DOM element.\"\n   `usage: [\"element:Element\" \"attrib0:string\" \"attribN:string\"]\n   `tags: [ `ui `html `attribute `delete ]\n   })\n\n(defun attach_event_listener (elem event_type handler_function)\n  (when elem\n    ((jslambda (`elem `event `f) \"return elem.addEventListener(event,f);\")  elem event_type handler_function))\n  {\n   `usage:[\"element:Element\" \"event_type:string\" \"handler:function\"]\n   `description:\"Given an element, an event type such as `click, and a function, attaches the provided function as an event handler to the HTML Element.\"\n   `tags:[\"ui\" \"events\" \"HTML\" \"events\" \"\"]\n   })\n\n(defun remove_css_entry (entry_name)\n  (do\n    (aif (get_by_id (to_key (+ \"juno-css-\" entry_name)))\n      (-> it `remove)))\n  {\n   `usage:[\"entry_name:string\"]\n   `description:\"If a class has been created by create_css_entry, use this function to remove the class from the document.\"\n   `tags: [\"html\" \"css\" \"ui\"]\n   })\n\n(defun create_css_entry (entry_name css_attribute_list)\n  (let\n      ((css_attributes (reduce (attrib_set (or css_attribute_list []))\n                               (destructuring_bind (attrib val)\n                                                   attrib_set\n                                                   (when (and (not (blank? attrib))\n                                                              (not (blank? val)))\n                                                     (+ \"\" attrib \": \" val)))))\n       \n       (head_elem (-> document `querySelector \"head\"))\n       (new_style nil))\n      ;(log \"create_css_entry: \" entry_name \"css_attributes: \"  css_attributes )\n    (when head_elem\n      (remove_css_entry entry_name)\n      (-> head_elem `appendChild\n          (= new_style\n             (style { `id: (to_key (+ \"juno-css-\" entry_name )) `type: \"text/css\" }\n                    (+ \"\" entry_name \"{ \" (join \";\" css_attributes) \" }\")))))\n    new_style)\n  { `usage: [\"entry_name:string\" \"css_attribute_list:array\"]\n   `description: (+ \" Given a name for the class and a list of formatted css attributes \"\n                    \"create and load the CSS object into the DOM.<br> Example: <br><code> \"\n                    \"(create_css_entry 'FilteredSelect:focus-within' \"\n                    \"                  [[`box-shadow '0px 0px 10px 0px rgba(0,0,0,0.75)']])<br>\"\n                    \" </code>\")\n   `tags: [\"html\" \"css\" \"ui\"]\n   } )\n\n(defun css_entry_to_css_format (entry_name css_attribute_list)\n  (let\n      ((`style (create_element \"style\"))\n       (`css_attributes (map (fn (v)\n                               (+ v.0 \": \" v.1))\n                             css_attribute_list)))\n    (+ \"\" entry_name \" {\\\\\\\\n   \" (join \";\\\\\\\\n   \" css_attributes) \";\\\\\\\\n}\")\n    )\n\n  { `usage: [\"entry_name:string\" \"css_attribute_list:array\"]\n   `description: (+ \"Given a name for the class and a list of formatted css attributes returns a formatted string in CSS syntax.<br> Example: <br><code>\"\n                    \"(create_css_entry 'FilteredSelect:focus-within'\n                                    [['box-shadow' '0px 0px 10px 0px rgba(0,0,0,0.75)']])<br>\"\n                    \"</code>\")\n   `tags: [\"html\" \"css\" \"ui\" \"convert\"]\n   } )\n\n(defun_sync handle_event (e)\n  (progn\n   (-> e `preventDefault)\n   (-> e `stopPropagation)))\n\n(defun_sync focus_to (elem)\n    (aif elem (-> it `focus)))\n\n(defmacro blur_to (elem)\n    `(aif ,#elem (-> it `blur)))\n\n(defun file_picker_button (button_text on_selection)\n  (let\n      ((elem (html/input { type: \"file\" \n                          value: (or button_text \"Open\")\n                          onchange: (fn (e)\n                                      (let\n                                          ((items e.srcElement.files)\n                                           (status nil))\n                                        (when on_selection\n                                          (on_selection items)))) })))\n    (declare (fn on_selection html/input)\n             (global html/input))\n    (when (eq nil on_selection)\n      (throw \"on_selection is required for file_picker_button\"))\n    elem))\n\n(defun notify (text type on_click)\n        (let\n            ((type (or type \"info\"))\n             (timer nil)\n             (view (div { `class: \"juno-notification\" \n                          `style: (cond\n                                     (== type \"error\")\n                                     \"border-left: 10px solid var(--type-error-color);\"\n                                     (== type \"success\")\n                                     \"border-left: 10px solid var(--success-color);\"\n                                     else\n                                     \"border-left: 10px solid var(--primary-action-bg-color);\") }\n                         (or text \"-\"))))\n            (when (eq nil (get_by_id \"lower_right_corner\"))\n                  (-> (get_by_id \"body\")\n                      `appendChild (div { `id: \"lower_right_corner\" `style: \"position: absolute; right: 50px; bottom: 5px; width: 255px;\" } )))\n            \n            (-> (get_by_id \"lower_right_corner\") `appendChild view)\n            (-> view `animate [{ `easing: `ease-in }\n                               { `opacity: 1    `easing: `ease-out  `offset: 0.1 }\n                               { `opacity: 1 `easing: `ease-out } ] \n                           { `duration: 3000 })\n            \n            (= timer (setTimeout (fn ()\n                                   (do \n                                     (-> view `animate [{ `opacity: 0  `easing: `ease-in } ] { `duration: 260 })\n                                     (setTimeout (fn () (do\n                                                          (-> view `remove)\n                                                          (= timer nil)\n                                                          (= view nil)))\n                                                 250)))                                                   \n                            10000))\n            (setTimeout (fn ()\n                            (set_style [[\"opacity\" 1]] view))\n                        200)\n            (attach_event_listener view\n                 `click\n                 (fn (e)\n                     (do\n                         (when timer (clearTimeout timer))\n                         (when view (-> view `remove))\n                         (= view nil)\n                         (= timer nil)\n                         (when on_click\n                               (on_click type text)))))\n            true)\n        {\n         `usage: [\"text:string\" \"type?:string\" \"on_click?:function\"]\n         `description: (+ \"Given a obligatory text string, and an optional type, and on_click function, \" \n                          \"show an alert for 10 seconds in the lower right hand corner.\"\n                          \"<br><br>\"\n                          \"Types are as follows: <br>\"\n                          \"error<br>\"\n                          \"success<br>\"\n                          \"info (default)<br>\"\n                          \"<br>Returns true, but is of no significance.\")\n         `tags: [\"ui\" \"alerts\" \"alerting\" \"message\" \"notify\"]\n         })\n\n\n\n(defun editable_element (`& args)\n   (let\n      ((options (if (and (is_object? args.0)\n                         (not (is_element? args.0)))\n                    (take args)\n                    {}))\n       (elem (div { `tabindex: 0 `contenteditable: true `style: (+ \"min-width: 20px; display: inline-block;\" (or options.style \"\")) \n                    `class: options.class  } \n                  args))\n       (handler (fn (e)\n                   (cond\n                      (and (not options.multiline) \n                           (== e.key \"Enter\"))\n                      (handle_event e)\n                      else\n                      (setTimeout (fn ()\n                                     (progn\n                                        (set_prop elem\n                                           `value\n                                           (trim elem.innerText))\n                                        (when options.on_change\n                                           (options.on_change e))))\n                            10)))))\n      (attach_event_listener elem\n                             `keydown\n                             handler)\n      (log \"OPTIONS: \" options)\n      (set_prop elem `value elem.innerText)\n       elem)\n   {\n       description:(+ \"Returns a contenteditable div with an additional value \" \n                      \"property for the innerText value.  Single line by default, \"\n                      \"setting options.multiline to true will allow for multiple \"\n                      \"line input values. If ptions.on_change is set as a function \"\n                      \"it will be called with the keydown event.\")\n       usage: [\"options:object\" \"argsN:*\"]\n       tags: [`DOM `UI `input `edit `element]\n    })\n\n\n\n(defun read_file (file options)\n    (new Promise\n         (fn (resolve reject)\n           (let\n               ((reader (new FileReader))                \n                (options (+ {}                          \n                            {\n                             `read_as: \"binary\"\n                             `details: false\n                             }\n                            options))\n                (read_as options.read_as))\n             (set_prop reader\n                       `onload\n                       (function (e)\n                                 (progn\n                                  (resolve\n                                   (cond\n                                     options.details\n                                     {\n                                      `name: file.name\n                                      `type: file.type\n                                      `size: file.size\n                                      `data: reader.result                                     \n                                      }\n                                     else\n                                     reader.result))))\n                       `error\n                       (function (e)\n                                 (reject e)))\n             \n             (cond\n               (or (== read_as \"binary\")\n                   (== read_as \"ArrayBuffer\"))\n               (-> reader `readAsArrayBuffer file)\n               (== read_as \"text\")\n               (-> reader `readAsText file)\n               (== read_as \"binaryString\")\n               (-> reader `readAsBinaryString file)\n               (== read_as \"dataURL\")\n               (-> reader `readAsDataURL file))))))\n\n\n\n(defun control_tree (content_list control_lambda _parent)\n  (cond\n    (is_array? content_list)    \n    (reduce (c content_list)\n            (control_tree c control_lambda _parent))               \n    content_list.view\n    (progn\n     (when control_lambda\n       (control_lambda content_list _parent))\n     (= _parent content_list)\n     (if content_list.controls\n       [ content_list (control_tree (-> content_list `controls) control_lambda _parent) ]\n       content_list))\n     \n    (is_element? content_list)\n    { view: content_list })) \n\n                    \n(defvalue *frame_count* -1)\n(defvalue *view_count* -1)\n\n(defun control_container (content options)\n  (let\n      ((contained_content content)\n       (resize_observer nil)\n       (options (or options {}))\n       (name (or options.name\n                 (and options.root_frame (+ \"Frame \" (inc *frame_count*)))\n                 (+ \"view-\" (inc *view_count*))))\n       (id (or options.id (generate_id \"container\")))       \n       (init_timer nil)\n       (view (div { `control_id: id `class: \"juno-view-container\" } ))\n       (initialized false)\n       (init_count 0)\n       (parent_view nil)\n       (check_observer (fn ()\n                         (when (not (== view.parentElement parent_view))\n                            (log \"control_container: changing observation: parent view changed: parent now: \" (get_attribute view.parentElement `id))\n                            \n                            (-> resize_observer `disconnect)\n                            (-> resize_observer `observe view.parentElement)\n                            (= parent_view view.parentElement))))\n       (perform_resize (fn ()\n                         (when view.parentElement\n                            (log \"control_container: performing resize: parent view is: \"  (get_attribute view.parentElement `id))\n                            (check_observer)\n                            (let\n                               ((new_height (- (prop view.parentElement `offsetHeight) 0))\n                                (new_width  (- (prop view.parentElement `offsetWidth) 0)))\n                               \n                               (set_style [[ \"width\" (+ \"\" new_width \"px\") ]\n                                           [ \"height\" (+ \"\" new_height \"px\") ]]\n                                          view)))))\n       (set_content (fn (position new_content) ;; position is discarded but it is essentially 0 since this is a single unit container\n                      (let\n                          ((new_view nil))\n                        (= new_view\n                           (cond\n                             new_content.view\n                             new_content.view\n\n                             (is_element? new_content)\n                             new_content\n                             \n                             else\n                             (progn\n                              (if new_content \n                                (div { } (as_lisp new_content))\n                                (div { `class: \"juno-empty-content\" } \"Set Content\")))))\n                        (-> view `replaceChildren new_view)\n                        (if (not new_content.view)\n                          (= contained_content\n                             {\n                              `view: view\n                              })\n                          (= contained_content new_content))\n                        (perform_resize)\n                        (when new_content.initialize\n                          (-> new_content `initialize))  ;; initialize if not already\n                        view)))\n       (initialize (fn ()\n                     (when (not initialized)\n                      (when init_timer\n                        (clearInterval init_timer)\n                        (= init_timer nil))\n                      (when (not initialized)\n                        (= initialized true))\n                      (when view.parentElement\n                        (= parent_view view.parentElement)\n                        (-> resize_observer `observe view.parentElement)\n                        (perform_resize)\n                        (console.log \"control_container: \" name \": initializing with: \" contained_content)\n                        (when contained_content\n                          (set_content 0 contained_content))\n                        (when (is_function? contained_content.initialize)\n                          (-> contained_content `initialize))))))\n       (destroy (fn ()\n                  (progn\n                   (when (is_function? contained_content.destroy)\n                     (-> contained_content `destroy)))))\n                        \n       (intf (new Object)))\n    \n    (set_prop options\n              `name\n              name\n              `id\n              id)\n    \n    (= resize_observer (new ResizeObserver (fn ()\n                                              (progn\n                                                 (console.log \"control_container: \" name \": resize observer fired\")\n                                                 (perform_resize)))))\n    \n    (= init_timer (setInterval (fn (e)\n                                   (progn\n                                      (console.log \"control_container: resize interval running: timer handle:\" init_timer \": count: \" init_count)\n                                    (when view.parentElement\n                                      (clearInterval init_timer)\n                                      (initialize))))\n                               250))\n    \n    \n    (set_prop intf\n              `view view              \n              `initialize initialize              \n              `set_content set_content\n              `name options.name\n              `resize_observer resize_observer\n              `resize perform_resize\n              `menu_items options.menu_item\n              `initialized? (fn () initialized)\n              `controls (fn () [contained_content])\n              `toJSON (function ()\n                                 `(control_container ,#contained_content ,#options))\n              `type `control_container\n              `options options)))\n\n(defun split_view_vertical (content_a content_b options)\n  (let\n      ((center_width 7)\n       (right_margin 5)\n       (options (or options { }))\n       (id (or options.id (generate_id \"split_view_vertical\")))\n       (center_divider (div { `class: \"juno-vertical-dragger\"\n                              `style: (+ \" top: 0px; left: 50%; cursor: col-resize; height: 100%; width: \" center_width \"px\") }))\n       (left_container (div { `class: \"juno-view-container\" }\n                            (if content_a.view\n                              content_a.view\n                              content_a)))\n       (right_container (div { `class: \"juno-view-container\" }\n                            (if content_b.view\n                              content_b.view\n                              content_b)))\n       (view_overlay (div { `style: \"width: 0%; height: 0%; position: absolute; top: 0px; left; 0px; background: transparent; cursor: col-resize\" }))\n       (view (div { `control_id: id  `class: \"juno-vertical-split-container\" `style: \"height: calc(100% - 5px); width: 100%;\" }\n                  left_container\n                  center_divider\n                  right_container\n                  view_overlay\n                  ))\n       (parent_view nil)\n       (drag_status nil)       \n       (resize_observer nil)\n       (center_pos nil)\n       (initialized false)\n       (min_size (or options.min_size 20))\n       (init_timer nil)       \n       (lock_ratio (function (state)\n                             (when (not drag_status)\n                              (if state\n                                (progn\n                                 (set_prop options\n                                          `ratio_locked\n                                          true)\n                                 (= lock_ratio options.ratio))\n                                (set_prop options\n                                          `ratio_locked\n                                          false)))))\n       (check_observer (fn ()\n                         (when (not (== view.parentElement parent_view))\n                           (-> resize_observer `disconnect)\n                           (-> resize_observer `observe view.parentElement)\n                           (= parent_view view.parentElement))))\n       (perform_resize (fn ()\n                         (when view.parentElement\n                           (check_observer)\n                           (if (isNaN (- (prop view.parentElement `offsetHeight) 5))\n                             (progn\n                              (console.log \"split_view_vertical: cannot get parent height is NAN: \" view.parentElement)\n                              (setTimeout perform_resize 1000))\n                             (let\n                                 ((new_height (- (prop view.parentElement `offsetHeight) 5))\n                                  (new_width  (- (prop view.parentElement `offsetWidth) 0)))\n                               \n                               (set_style [[ \"width\" (+ \"\" new_width \"px\") ]\n                                           [ \"height\" (+ \"\" new_height \"px\") ]]\n                                          view)\n                               ;; get the center position - set it to the midpoint if we are just initializing\n                               (when (== center_pos nil)\n                                 (cond\n                                   (and options.ratio\n                                        (is_number? options.ratio))\n                                   (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth))\n                                   options.ratio\n                                   (throw TypeError \"Invalid ratio option: must be a number between 0 and 1\")\n                                   else\n                                   (= center_pos (/ view.offsetWidth 2))))\n                               \n                               (when (and (== drag_status nil)\n                                          (or (isNaN options.ratio)\n                                              (isNaN center_pos)))\n                                 (console.log \"split_view_vertical: options.ratio is NaN: \" options.ratio \"center_pos: \" center_pos)\n                                 (set_prop options\n                                           `ratio\n                                           0.5)\n                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth))\n                                 (console.log \"split_view_horizontal: center_pos now:\" center_pos))\n                                                                                             \n                               (when (and (== drag_status nil)  ;; not doing a drag so we need to preserve the ratio\n                                          (is_number? options.ratio))\n                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetWidth)))\n\n                               \n                               (if (> options.right_panel_max_size 10)\n                                 (= center_pos (- new_width 20 options.right_panel_max_size))\n                                 (= center_pos (Math.max (+ 20 min_size) (Math.min center_pos (- new_width 20 min_size)))))\n                               \n                               (set_style [[\"width\" (+ (- center_pos center_width) \"px\") ]]                                         \n                                          left_container)\n                               (set_style [[\"width\" (+ \"\" center_width \"px\") ]] center_divider)\n                               (set_style [[\"width\" (+ (- view.offsetWidth center_pos center_width right_margin) \"px\") ]]\n                                          right_container)\n                               (when (not options.ratio_locked)\n                                 (set_prop options\n                                           `ratio\n                                           (/ center_pos view.offsetWidth)))\n                                        ;(console.log \"[\" left_container.offsetWidth \"<->\" right_container.offsetWidth \"]\")\n                               )))))\n       (init_drag (fn (e)\n                    (when (and (not options.ratio_locked)\n                               (== drag_status nil))\n                      (= drag_status 1)\n                      (set_style [[\"width\" \"100%\"]\n                                  [\"height\" \"100%\"]] view_overlay)\n                      ;; since our overlay covers the center_divider add a class to indicate activity\n                      ;; on the center divider\n                      (add_class \"juno-active-hover\" center_divider))))\n       \n       (complete_drag (fn (e)\n                        (progn\n                         (set_style [[\"width\" \"0%\"]\n                                     [\"height\" \"0%\"]] view_overlay)\n                         (remove_class \"juno-active-hover\" center_divider)\n                         (= drag_status nil)                         \n                         (perform_resize))))\n       (perform_drag (fn (e)\n                       (progn\n                        (-> e `preventDefault)\n                        (when drag_status                          \n                          (if (== e.buttons 0)\n                            (complete_drag)\n                            (progn\n                             (= center_pos (Math.max 20 (Math.min e.offsetX (- view.offsetWidth 20))))))\n                          (perform_resize)))))\n       (intf {})                                                                    \n       (initialize (fn ()\n                     (progn\n                      (when init_timer\n                        (clearInterval init_timer)\n                        (= init_timer nil))\n                      (console.log \"split_view_vertical: initialize called: \" initialized)\n                      (when (not initialized)                       \n                        (= initialized true)\n                        (= parent_view view.parentElement)\n                        (-> resize_observer `observe view.parentElement)\n                        (perform_resize)\n                        (console.log \"split_view_vertical initialized:\" initialized)\n                        (when content_a.initialize\n                          (-> content_a `initialize))\n                        (when content_b.initialize\n                          (-> content_b `initialize))))))\n       (destroy (fn ()\n                  (progn\n                   (when (is_function? content_a.destroy)\n                     (-> content_a `destroy))\n                   (when (is_function? content_b.destroy)\n                     (-> content_b `destroy)))))\n       (set_content (fn (position new_content)\n                      (if (and position new_content\n                               (or (== position 0) (== position 1)))\n                        (let\n                            ((target_container (if (== position 0)\n                                                 left_container\n                                                 right_container)))\n                          (console.log \"split_view_vertical: adding new content: \" new_content)\n                          (if (== position 0)\n                            (= content_a new_content)\n                            (= content_b new_content))\n                          (cond\n                            new_content.view ;; we have been given a control\n                            (progn                             \n                             (-> target_container `replaceChildren new_content.view)\n                             (when new_content.initialize\n                               (-> new_content `initialize)))\n                            (is_element? new_content)                                                         \n                            (-> target_container `replaceChildren new_content)\n                            else\n                            (-> target_container `replaceChildren (pre\n                                                                   (JSON.stringify new_content nil 4))))\n                          (perform_resize)\n                          (console.log \"split_view_vertical: added new content: \" new_content)\n                          true)\n                        (throw \"set_content: invalid or missing arguments\")))))\n\n    ;; set up the events\n    (attach_event_listener view_overlay\n                           `mousemove\n                           (fn (e)\n                             (progn\n                              (handle_event e)\n                              (when drag_status\n                                (perform_drag e)))))\n                             \n    (attach_event_listener view_overlay\n                           `mouseup\n                           (fn (e)\n                             (progn\n                              (handle_event e)                              \n                              (complete_drag))))\n\n    (attach_event_listener center_divider\n                           `mouseup\n                           (fn (e)\n                             (progn\n                              (handle_event e)                              \n                              (complete_drag))))\n    (attach_event_listener center_divider\n                           `mousedown\n                           (fn (e)\n                             (progn                              \n                              (handle_event e)                              \n                              (init_drag e))))\n\n   \n\n    (= resize_observer (new ResizeObserver perform_resize))\n    (console.log \"split_view_vertical: ready: initialized: \" initialized)\n    (when true ;options.auto_initialize\n      (= init_timer (setInterval (fn (e)\n                                   (progn\n                                    (when view.parentElement\n                                      (clearInterval init_timer)\n                                      \n                                      (= init_timer nil)\n                                      (initialize))))\n                                 250)))\n    (set_prop options\n              `ratio_locked (or options.ratio_locked false)\n              `id id\n              `name (or options.name\n                        (+ \"vertical-split-\" (inc *view_count*))))\n    (set_prop intf\n     `view view\n     `initialize initialize\n     `set_content set_content\n     `lock_ratio lock_ratio\n     `set_min_panel_size (fn (val)\n                             (when (is_number? val)\n                               (set_prop options `min_size val)\n                               (= min_size val)\n                               (perform_resize)))\n     `set_right_panel_max_size (fn (val)\n                                 (when (is_number? val)                                   \n                                   (set_prop options `right_panel_max_size val)                                  \n                                   (perform_resize)))\n     `options options\n     `destroy destroy\n     `name options.name\n     `resize perform_resize\n     `type `split_view_vertical\n     `controls (fn () [ content_a content_b ])\n     `toJSON (function ()\n                       `(split_view_vertical ,#content_a ,#content_b ,#options)))\n    intf))\n                             \n\n(defun split_view_horizontal (content_a content_b options)\n  (let\n      ((center_height 7)\n       (bottom_margin 5)\n       (options (or options {}))\n       (id (or options.id (generate_id \"split_view_horizontal\")))\n       (center_divider (div { `class: \"juno-horizontal-dragger\"\n                              `style: (+ \"cursor: row-resize; width: 100%; height: \" center_height \"px\") }))\n       (top_container (div { `class: \"juno-view-container\" }\n                            (if content_a.view\n                              content_a.view\n                              content_a)))\n       (bottom_container (div { `class: \"juno-view-container\" }\n                            (if content_b.view\n                              content_b.view\n                              content_b)))\n       (view_overlay (div { `style: \"width: 0%; height: 0%; position: absolute; top: 0px; left; 0px; background: transparent; cursor: row-resize\" }))\n       (view (div { `control_id: id `class: \"juno-horizontal-split-container\" `style: \"height: calc(100% - 0px); width: 100%;margin: 0px; padding: 0px;\" }\n                  top_container\n                  center_divider\n                  bottom_container\n                  view_overlay\n                 ))\n       (drag_status nil)\n       (initialized false)\n       (resize_observer nil)\n       (center_pos nil)\n       (last_center_pos nil)\n       (initialized false)\n       (init_timer nil)\n       (locked_ratio nil)\n       (last_set_ratio nil)\n       (min_size (or options.min_panel_size 20))\n       (lock_ratio (function (state)\n                             (when (not drag_status)\n                              (if state\n                                (progn\n                                 (set_prop options\n                                          `ratio_locked\n                                          true)\n                                 (= lock_ratio options.ratio))\n                                (set_prop options\n                                          `ratio_locked\n                                          false)))))           \n       (parent_view nil)\n       (check_observer (fn ()\n                         (when (not (== view.parentElement parent_view))\n                           (-> resize_observer `disconnect)\n                           (-> resize_observer `observe view.parentElement)\n                           (= parent_view view.parentElement))))\n       (perform_resize (fn ()\n                         (when view.parentElement\n                           (check_observer)\n                           (if (isNaN (- (prop view.parentElement `offsetHeight) 5))\n                             (progn\n                              (console.log \"split_view_horizontal: cannot get parent height is NAN: \" view.parentElement)\n                              (setTimeout perform_resize 1000))\n                             (let\n                                 ((new_height (- (prop view.parentElement `offsetHeight) 0))\n                                  (new_width  (- (prop view.parentElement `offsetWidth) 0)))\n                                 \n                                 (if (and center_pos\n                                          (> center_pos 0)\n                                          (> new_height 0))\n                                     (= last_center_pos center_pos))\n                                \n                                 \n                               (set_style [[ \"width\" (+ \"\" new_width \"px\") ]\n                                           [ \"height\" (+ \"\" new_height \"px\") ]]\n                                          view)\n                               ;; get the center position - set it to the midpoint if we are just initializing\n                               (when (== center_pos nil)\n                                 (cond\n                                   (and options.ratio\n                                        (is_number? options.ratio))\n                                   (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight))\n                                   options.ratio\n                                   (throw TypeError \"Invalid ratio option: must be a number between 0 and 1\")\n                                   else\n                                   (= center_pos (/ view.offsetHeight 2))))  ;; default is 50% 0.5\n                               (when (and (== drag_status nil)\n                                          (or (isNaN options.ratio)\n                                              (isNaN center_pos)))\n                                 (log \"split_view_horizontal: options.ratio is NaN: \" options.ratio \"center_pos: \" center_pos)\n                                 (set_prop options\n                                           `ratio\n                                           0.5)\n                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight)))\n                                 \n                               \n                             \n                               (when (and (== drag_status nil)  ;; not doing a drag so we need to preserve the ratio \n                                          (is_number? options.ratio))\n                                 (= center_pos (* (Math.min 1 (Math.max 0.01 options.ratio)) view.offsetHeight)))\n                               \n                               (when (== new_height 0)\n                                  (= last_set_ratio\n                                     options.ratio))\n                               \n                               (cond \n                                 last_set_ratio\n                                 (= center_pos (* new_height last_set_ratio))\n                                 (> options.lower_panel_max_size 10)\n                                 (= center_pos (- new_height 20 options.lower_panel_max_size))\n                                 else\n                                 (= center_pos (Math.max (+ 20 min_size) (Math.min center_pos (- new_height 20 min_size)))))\n                               \n                               (set_style [[\"height\" (+ \"\" center_pos  \"px\") ]]\n                                          top_container)\n                               (set_style [[\"height\" (+ \"\" center_height \"px\") ]] center_divider)\n                               (set_style [[\"height\" (+ (- view.offsetHeight center_height center_pos 0) \"px\") ]]\n                                          bottom_container)\n                               (cond \n                                  (and (not options.ratio_locked)\n                                       last_set_ratio)\n                                  (progn\n                                     (set_prop options\n                                        `ratio\n                                        last_set_ratio)\n                                     (= last_set_ratio nil))\n                                  (not options.ratio_locked)\n                                  (set_prop options\n                                     `ratio\n                                     (/ center_pos view.offsetHeight)))\n                                        ;(console.log \"[\" top_container.offsetHeight \"<|>\" bottom_container.offsetHeight \"]\")\n                               )))))\n       (init_drag (fn (e)\n                    (when (and (not options.ratio_locked)\n                               (== drag_status nil))\n                      (= drag_status 1)\n                      (set_style [[\"width\" \"100%\"]\n                                  [\"height\" \"100%\"]] view_overlay)\n                      ;; since our overlay covers the center_divider add a class to indicate activity\n                      ;; on the center divider\n                      (add_class \"juno-active-hover\" center_divider))))\n       \n       (complete_drag (fn (e)\n                        (progn\n                         (set_style [[\"width\" \"0%\"]\n                                     [\"height\" \"0%\"]] view_overlay)\n                         (remove_class \"juno-active-hover\" center_divider)\n                         (= drag_status nil)                         \n                         (perform_resize))))\n       (perform_drag (fn (e)\n                       (progn\n                        (-> e `preventDefault)\n                        (when drag_status\n                          ;(console.log \"view_overlay: center_pos: \" center_pos \"offsetY: \" e.offsetY \"movementX: \" e.movementY)\n                          (if (== e.buttons 0)\n                            (complete_drag)\n                            (progn\n                             (= center_pos (Math.max 20 (Math.min (- e.offsetY center_height 3) (- view.offsetHeight 40))))))\n                          (perform_resize)))))\n       (intf {})\n       (initialize (fn ()\n                     (progn\n                      (when init_timer\n                        (clearInterval init_timer)\n                        (= init_timer nil))\n                      (when (not initialized)\n                        (= initialized true)\n                        (= parent_view view.parentElement)\n                        (-> resize_observer `observe view.parentElement)\n                        (perform_resize)\n                        (console.log \"split_view_horizontal initialized: \" initialized)\n                        (when content_a.initialize\n                          (-> content_a `initialize))\n                        (when content_b.initialize\n                          (-> content_b `initialize))))))\n       (destroy (fn ()\n                  (progn\n                   (when (is_function? content_a.destroy)\n                     (-> content_a `destroy))\n                   (when (is_function? content_b.destroy)\n                     (-> content_b `destroy)))))\n       (set_content (fn (position new_content)\n                      (if (and position new_content\n                               (or (== position 0) (== position 1)))\n                        (let\n                            ((target_container (if (== position 0)\n                                                 top_container\n                                                 bottom_container)))\n                          (if (== position 0)\n                            (= content_a new_content)\n                            (= content_b new_content))\n                          (cond\n                            new_content.view ;; we have been given a control\n                            (progn                             \n                             (-> target_container `replaceChildren new_content.view)\n                             (when new_content.initialize\n                               (-> new_content `initialize)))\n                            (is_element? new_content)                                                         \n                            (-> target_container `replaceChildren new_content)\n                            else\n                            (-> target_container `replaceChildren (pre\n                                                                   (JSON.stringify new_content nil 4))))\n                          (perform_resize)\n                          true)\n                        (throw \"set_content: invalid or missing arguments\")))))\n                          \n                                                        \n    ;; set up the events\n    (attach_event_listener view_overlay\n                           `mousemove\n                           (fn (e)\n                             (progn\n                              (handle_event e)\n                              (when drag_status\n                                (perform_drag e)))))\n                             \n    (attach_event_listener view_overlay\n                           `mouseup\n                           (fn (e)\n                             (progn\n                              (handle_event e)                              \n                              (complete_drag))))\n\n    (attach_event_listener center_divider\n                           `mouseup\n                           (fn (e)\n                             (progn\n                              (handle_event e)                              \n                              (complete_drag))))\n    (attach_event_listener center_divider\n                           `mousedown\n                           (fn (e)\n                             (progn                              \n                              (handle_event e)                              \n                              (init_drag e))))\n  \n    (= resize_observer (new ResizeObserver perform_resize))\n    (console.log \"split_view_horizontal: ready: initialized: \" initialized)\n    (when true ;options.auto_initialize\n      (= init_timer (setInterval (fn (e)\n                                   (progn\n                                    (when view.parentElement\n                                      (clearInterval init_timer)\n                                      (= init_timer nil)\n                                      (initialize))))\n                                 250)))\n    (set_prop options\n              `ratio_locked (or options.ratio_locked false)\n              `id id\n              `name (or options.name\n                        (+ \"horizontal-split-\" (inc *view_count*))))\n    \n    (set_prop intf\n     `view view\n     `initialize initialize\n     `options options\n     `name options.name\n     `resize perform_resize\n     `set_min_panel_size (fn (val)\n                             (when (is_number? val)\n                               (set_prop options `min_size val)\n                               (= min_size val)\n                               (perform_resize)))\n     `set_lower_panel_max_size (fn (val)\n                                 (when (is_number? val)                                   \n                                   (set_prop options `lower_panel_max_size val)                                  \n                                   (perform_resize)))\n     `destroy destroy\n     `type `split_view_horizontal\n     `controls (fn () [ content_a content_b ])\n     `toJSON (function ()\n                       `(split_view_horizontal  ,#content_a ,#content_b ,#options))\n     `lock_ratio lock_ratio\n     `set_content (fn (position new_content)\n                        (set_content position new_content)))\n     \n    intf))\n\n(defun checkbox (`& args)\n   (let\n      ((options (if (and (is_object? args.0)\n                      (not (is_element? args.0)))\n                 args.0\n                 {}))\n       (args (if (> (length options) 0)\n                 (rest args)\n                 args))\n       (state options.value)\n       (check_input (input (+ { `type: \"checkbox\" }\n                              (if options.value\n                                 { `checked: true }\n                                 {})\n                              { `style: \"padding: 5px; margin-right: 5px;\" }\n                              (if (is_object? options.checkbox)\n                                  options.checkbox\n                                  {}))))\n       (view (label (+ {}\n                       (if (is_object? options.label)\n                           options.label\n                        {}))\n                    check_input\n                    args)))\n      (attach_event_listener view\n         `click\n         (fn (e)\n            (progn\n               (= state (prop check_input `checked))\n               (set_prop view\n                  `value\n                  state))))\n      (set_prop view\n         `value\n         state)\n      view)\n   {\n       `description: (+ \"Creates a checkbox with a label element and \"\n                        \"returns the label element.  The state of the \"\n                        \"check box input is set to the value property \"\n                        \"of the label, such that when the check box input \"\n                        \"is checked, the value will be true, otherwise \"\n                        \"it will be false.  Event listeners can be \"\n                        \"attached as needed.<br>Example:```\"\n                        \"(defconst my_checkbox (checkbox { `value: true } \\\\\\\\\"Completed\\\\\\\\\"))\\\\\\\\n\"\n                        \"(attach_event_listener my_checkbox\\\\\\\\n\"\n                        \"   `click\\\\\\\\n\"\n                        \"   (fn (e)\\\\\\\\n\"\n                        \"      (log \\\\\\\\\"State: \\\\\\\\\" e.srcElement.value)))\\\\\\\\n```\"\n                        \"<br>\"\n                        \"Options for the checkbox:<br>\"\n                        \"value:boolean - If true the checkbox is checked when first \"\n                        \"presented.<br>\"\n                        \"label:object - If provided, will be used for the attributes of the label element.<br>\"\n                        \"checkbox:object - If provided, will be used for the attributes of the checkbox input \"\n                        \"element.<br>\")\n       `usage: [\"options:?object\" \"label_contents:string|Element\" ]\n       `tags: [ \"html\" \"ui\" \"DOM\" \"element\" \"node\"]\n   })\n\n(defun_sync doc_exec (command_name value show_default_ui )\n   (-> document `execCommand command_name \n                             (if (== show_default_ui true) true false) \n                             value)\n   {\n       `description: (+ \"Executes document.execCommand with the arguments provided \"\n                        \"on the DOM element currently in focus.<br>\"\n                        \"Returns false if the command is unsupported.  The \" \n                        \"show_default_ui argument defaults to false.<br>\" \n                        \"<br>Note that browser support is officially deprecated for the \"\n                        \"execCommand method of document.\")\n       `tags: [\"DOM\" \"ui\" \"command\" \"formatting\" \"editing\" ]\n       `resources: [\"https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand\"]\n       `usage:[\"command_name:string\" \"value:*\" \"show_default_ui:?boolean\"]\n   })\n   \n(defun pair_editor (pair options)\n   (let\n      ((pair [ pair.0 pair.1 ])\n       (key_elem (input (+ { `tabindex: 0 `class: \"juno-editable\" }\n                           (if options.placeholder_0 \n                              { `placeholder: options.placeholder_0 }\n                              {})\n                           (if options.list_0\n                              { `list: options.list_0 }\n                              {})\n                           (if (is_array? options.path)\n                              { `path: (join \"~\" (conj options.path [ 0 ])) }\n                              { path: \"0\" })\n                           { value: (or pair.0 \"\") \n                             style: \"padding: 5px; flex-grow: 1; flex-basis: 100px;\" } )))\n       (value_elem (input (+ { `tabindex: 0 `class: \"juno-editable\" }\n                             (if options.placeholder_1 \n                              { `placeholder: options.placeholder_1 }\n                              {})\n                             (if options.list_1\n                                { `list: options.list_1 }\n                                {})\n                           (if (is_array? options.path)\n                              { `path:  (join \"~\"  (conj options.path [ 1 ])) }\n                              { path: \"1\" })\n                           { value: (or pair.1 \"\") style: \"padding: 5px; flex-grow: 2; flex-basis: 150px;\" } )))\n       (view (div { `class: \"juno-editable\" style: (+ \"display:flex; align-items: flex-end; flex-wrap: wrap; gap: 16px;\"\n                                                      (if (is_string? options.style)\n                                                          options.style\n                                                          \"\"))\n                           }\n                  key_elem\n                  value_elem\n                  (if options.additional_elements\n                     options.additional_elements\n                     [])))\n       (handler (fn (e)\n                   (progn\n                      (defvar edited_path (get_attribute e.srcElement \"path\"))\n                      (if (and edited_path\n                               (is_function? options.on_change))\n                         (-> options `on_change (split_by \"~\" edited_path) e.srcElement.value))))))\n      (log \"pair editor: \" pair)\n      (attach_event_listener view\n         `keyup\n         handler)\n      (attach_event_listener view\n         `click\n         handler)\n      view))\n\n(defun dtable (row_data options)\n   (table { `style: \"width: 100%\" }\n          (if (is_array? options.columns)\n              (thead\n                 (for_each (colheader options.columns)\n                    (cond \n                       (is_string? colheader)\n                       (th { `style: \"padding: 5px;\" }  colheader)\n                       (and (is_object? colheader)\n                            colheader.name)\n                       (th { `style: \"padding: 5px;\" }  colheader.name))))\n              [])\n         (tbody\n            (for_each (row (or row_data []))\n               (tr\n                  (for_each (cell row)\n                     (td { `style: \"padding: 3px;\" } \n                         cell)))))))\n\n\n\n\n          \n ;; (defglobal tabview (tabs [[\"Tab 1\" (div \"Hi this is tab 1\") true ] [\"Tab 2\" (div \"This is tab 2\") ]]))                \n\n\n\n\n\n(set_prop (get_by_id \"juno-css\")\n          `textContent\n          style_css)\n    \n(console.log \"html is loaded\");\n(register_feature \"html\")\n(load_pends \"html\")\ntrue\n" })();__obj__1["style_css"]=await (async function(){ return "\n/* Seedling Default CSS */\n\n/* Variables */\n\n:root {\n  --main-bg-color: #FBFAF8;\n  --main-color: #000000;\n  --header-color: inherit;\n  --header-bg-color: inherit;\n  --highlight-bg-color: #DADADA;\n  --highlight-color: #000000;\n  --selected-bg-color: #0278e7;\n  --selected-color: #FFFFFF;\n  --control-bg-color: inherit;\n  --control-color: inherit;\n  --control-text-input-color-bg: #FFFFFF50;\n  --control-text-input-color: #000000;\n  --control-focused: #efe5e540;\n  --control-unfocused-color: darkgray;\n  --control-disabled-bg-color: #eaeded;\n  --control-disabled-color: #cad2d3;\n  --control-readonly-color: #777;\n  --log-message-bg-color: inherit;\n  --log-result-bg-color: inherit;\n  --button-hover-bg-color: #00000030;\n  --identification-bg-color: #01678338;\n  --app-header-color: #546478;\n  --namespace-color: #976464;\n  --main-accent-color: #0000000A;\n  --main-accent-line: #00000010;\n  --main-accent-line-hover: #00000020;\n  --main-control-surface-accent-color: #efe5e540;\n  --main-control-button-color: #00000020;\n  --value-modified-color: #016783;\n  --matching-paren-color: #ffeb00;\n  --matching-paren-outline-color: #b6a800;\n  --scrollbar-thumb-color: inherit;\n  --scrollbar-track-color: inherit;\n  --link-color: inherit;\n  --link-visited-color: inherit;\n  --link-bg-color: inherit;\n  --link-visited-bg-color: inherit;\n  --type-number-color: green;\n  --type-boolean-color: orange;\n  --type-string-color: darkblue;\n  --type-function-color: #2e3eb4;\n  --type-asyncfunction-color: #3f5b71;\n  --type-null-color: #a35e5e;\n  --type-undefined-color: #9d9d9d;\n  --type-symbol-color: #ff4f4f;\n  --type-error-color: darkred;\n  --type-array-color: #535173;\n  --type-path-color: #88127D;\n  --type-key-color:  #88127D;\n  --type-regexp-color: #fe2f53;\n  --type-code-color: darkblue;\n  --value-focus-color: #0168ff;\n  --mode-color: #0278e7;\n  --primary-action-bg-color: #0278e7;\n  --primary-action-color: #FFFFFF;\n  --success-color: #19A019;\n  --main-app-font:  -apple-system,BlinkMacSystemFont,'Segoe UI','Helvetica Neue', Helvetica, FreeSans, Arimo, \"Droid Sans\", Arial, sans-serif;\n  --main-app-font-size: 14px;\n  --main-mono-space: \"Roboto Mono\", ui-monospace,\t\t     \n    \"Cascadia Mono\", \"Segoe UI Mono\",    \n    \"Ubuntu Mono\",\n    Menlo, Monaco, Consolas,\n    monospace;\n  --editor-bg-color: #f6f3f1;\n  --editor-text-color: #363636;\n  --editor-gutter-bg-color: #e0e0e0;\n  --editor-gutter-color: #333;\n  --editor-cursor-color: #202020;\n  --editor-selected-bg-color: #4ab1ff3d;  \n  --editor-selected-word-bg-color: #fff4a36e;\n  --editor-step-bg-color: rgb(198,219,174);\n  --editor-active-line-bg: rgb(255 255 255 / 53%);\n  --editor-active-line-gutter-bg-color: rgb(166 166 166 / 46%);\n  --editor-invisible-color: #BFBFBF;\n  --editor-keyword-color: #670171;\n  --editor-identifier-color: #191919;\n  --editor-constant-color: #CD6839;\n  --editor-numeric-color: #9A5925;\n  --editor-support-color: #104e8b;\n  --editor-function-color: #0274a1;\n  --editor-asyncfunction-color: #3f5b71;\n  --editor-string-color: #006b1e;\n  --editor-constant-color: #CF6A4C;\n  --editor-variable-color: #009ACD;\n  --editor-comment-color: rgba(148,148,148, 0.91);\n  --editor-storage-color: #A52A2A;\n  --editor-illegal-color: #FD1224;\n  --editor-illegal-bg-color: rgba(255, 6, 0, 0.15);\n  --editor-deprecated-color: #FD1732;\n  --editor-deprecated-bg-color: #EEEAE8;\n  --editor-regex-color: #fe2f53;\n  --editor-regex-bg-color: #FE40AA10;\n  --editor-heading-color: #B8012D;\n  --editor-heading-bg-color: rgba(191,97,51,0.051);\n  --editor-list-color: #8F5B26;\n}\n\n\n\n\n/*!\nPure v2.1.0\nCopyright 2013 Yahoo!\nLicensed under the BSD License.\nhttps://github.com/pure-css/pure/blob/master/LICENSE\n*/\n/*!\nnormalize.css v | MIT License | git.io/normalize\nCopyright (c) Nicolas Gallagher and Jonathan Neal\n*/\n/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */  \n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers.\n */\n\nbody {\n  margin: 0;\n  background: var(--main-bg-color, #FCFAFA);\n  color: var(--main-color, #000000);\n  font-size: var(--main-app-font-size);\n  scrollbar-color: var(--scrollbar-thumb-color) var(--scrollbar-track-color);\n}\n\n\n/**\n * Render the `main` element consistently in IE.\n */\n\nmain {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  -webkit-box-sizing: content-box;\n          box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: var(--main-mono-space, monospace, monospace); /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * Remove the gray background on active links in IE 10.\n */\n\na {\n  background-color: transparent;\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: var(--main-mono-space, monospace, monospace); /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Remove the border on images inside links in IE 10.\n */\n\nimg {\n  border-style: none;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button;\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\n\ndetails {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Misc\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10+.\n */\n\ntemplate {\n  display: none;\n}\n\n/**\n * Add the correct display in IE 10.\n */\n\n[hidden] {\n  display: none;\n}\n\n/*csslint important:false*/\n\n/* ==========================================================================\n   Pure Base Extras\n   ========================================================================== */\n\n/**\n * Extra rules that Pure adds on top of Normalize.css\n */\n\nhtml {\n  font-family: var(--main-app-font);\n}\n\n/**\n * Always hide an element when it has the `hidden` HTML attribute.\n */\n\n.hidden,\n[hidden] {\n    display: none !important;\n}\n\n/**\n * Add this class to an image to make it fit within it's fluid parent wrapper while maintaining\n * aspect ratio.\n */\n.pure-img {\n    max-width: 100%;\n    height: auto;\n    display: block;\n}\n\n/*csslint regex-selectors:false, known-properties:false, duplicate-properties:false*/\n\n.pure-g {\n    letter-spacing: -0.31em; /* Webkit: collapse white-space between units */\n    text-rendering: optimizespeed; /* Webkit: fixes text-rendering: optimizeLegibility */\n\n    /*\n    Sets the font stack to fonts known to work properly with the above letter\n    and word spacings. See: https://github.com/pure-css/pure/issues/41/\n\n    The following font stack makes Pure Grids work on all known environments.\n\n    * FreeSans: Ships with many Linux distros, including Ubuntu\n\n    * Arimo: Ships with Chrome OS. Arimo has to be defined before Helvetica and\n      Arial to get picked up by the browser, even though neither is available\n      in Chrome OS.\n\n    * Droid Sans: Ships with all versions of Android.\n\n    * Helvetica, Arial, sans-serif: Common font stack on OS X and Windows.\n    */\n    font-family: FreeSans, Arimo, \"Droid Sans\", Helvetica, Arial, sans-serif;\n\n    /* Use flexbox when possible to avoid `letter-spacing` side-effects. */\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n        -ms-flex-flow: row wrap;\n            flex-flow: row wrap;\n\n    /* Prevents distributing space between rows */\n    -ms-flex-line-pack: start;\n        align-content: flex-start;\n}\n\n/* IE10 display: -ms-flexbox (and display: flex in IE 11) does not work inside a table; fall back to block and rely on font hack */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n\ttable .pure-g {\n\t\tdisplay: block;\n\t}\n}\n\n/* Opera as of 12 on Windows needs word-spacing.\n   The \".opera-only\" selector is used to prevent actual prefocus styling\n   and is not required in markup.\n*/\n.opera-only :-o-prefocus,\n.pure-g {\n    word-spacing: -0.43em;\n}\n\n.pure-u {\n    display: inline-block;\n    letter-spacing: normal;\n    word-spacing: normal;\n    vertical-align: top;\n    text-rendering: auto;\n}\n\n/*\nResets the font family back to the OS/browser's default sans-serif font,\nthis the same font stack that Normalize.css sets for the `body`.\n*/\n.pure-g [class *= \"pure-u\"] {\n    font-family: sans-serif;\n}\n\n.pure-u-1,\n.pure-u-1-1,\n.pure-u-1-2,\n.pure-u-1-3,\n.pure-u-2-3,\n.pure-u-1-4,\n.pure-u-3-4,\n.pure-u-1-5,\n.pure-u-2-5,\n.pure-u-3-5,\n.pure-u-4-5,\n.pure-u-5-5,\n.pure-u-1-6,\n.pure-u-5-6,\n.pure-u-1-8,\n.pure-u-3-8,\n.pure-u-5-8,\n.pure-u-7-8,\n.pure-u-1-12,\n.pure-u-5-12,\n.pure-u-7-12,\n.pure-u-11-12,\n.pure-u-1-24,\n.pure-u-2-24,\n.pure-u-3-24,\n.pure-u-4-24,\n.pure-u-5-24,\n.pure-u-6-24,\n.pure-u-7-24,\n.pure-u-8-24,\n.pure-u-9-24,\n.pure-u-10-24,\n.pure-u-11-24,\n.pure-u-12-24,\n.pure-u-13-24,\n.pure-u-14-24,\n.pure-u-15-24,\n.pure-u-16-24,\n.pure-u-17-24,\n.pure-u-18-24,\n.pure-u-19-24,\n.pure-u-20-24,\n.pure-u-21-24,\n.pure-u-22-24,\n.pure-u-23-24,\n.pure-u-24-24 {\n    display: inline-block;\n    letter-spacing: normal;\n    word-spacing: normal;\n    vertical-align: top;\n    text-rendering: auto;\n}\n\n.pure-u-1-24 {\n    width: 4.1667%;\n}\n\n.pure-u-1-12,\n.pure-u-2-24 {\n    width: 8.3333%;\n}\n\n.pure-u-1-8,\n.pure-u-3-24 {\n    width: 12.5000%;\n}\n\n.pure-u-1-6,\n.pure-u-4-24 {\n    width: 16.6667%;\n}\n\n.pure-u-1-5 {\n    width: 20%;\n}\n\n.pure-u-5-24 {\n    width: 20.8333%;\n}\n\n.pure-u-1-4,\n.pure-u-6-24 {\n    width: 25%;\n}\n\n.pure-u-7-24 {\n    width: 29.1667%;\n}\n\n.pure-u-1-3,\n.pure-u-8-24 {\n    width: 33.3333%;\n}\n\n.pure-u-3-8,\n.pure-u-9-24 {\n    width: 37.5000%;\n}\n\n.pure-u-2-5 {\n    width: 40%;\n}\n\n.pure-u-5-12,\n.pure-u-10-24 {\n    width: 41.6667%;\n}\n\n.pure-u-11-24 {\n    width: 45.8333%;\n}\n\n.pure-u-1-2,\n.pure-u-12-24 {\n    width: 50%;\n}\n\n.pure-u-13-24 {\n    width: 54.1667%;\n}\n\n.pure-u-7-12,\n.pure-u-14-24 {\n    width: 58.3333%;\n}\n\n.pure-u-3-5 {\n    width: 60%;\n}\n\n.pure-u-5-8,\n.pure-u-15-24 {\n    width: 62.5000%;\n}\n\n.pure-u-2-3,\n.pure-u-16-24 {\n    width: 66.6667%;\n}\n\n.pure-u-17-24 {\n    width: 70.8333%;\n}\n\n.pure-u-3-4,\n.pure-u-18-24 {\n    width: 75%;\n}\n\n.pure-u-19-24 {\n    width: 79.1667%;\n}\n\n.pure-u-4-5 {\n    width: 80%;\n}\n\n.pure-u-5-6,\n.pure-u-20-24 {\n    width: 83.3333%;\n}\n\n.pure-u-7-8,\n.pure-u-21-24 {\n    width: 87.5000%;\n}\n\n.pure-u-11-12,\n.pure-u-22-24 {\n    width: 91.6667%;\n}\n\n.pure-u-23-24 {\n    width: 95.8333%;\n}\n\n.pure-u-1,\n.pure-u-1-1,\n.pure-u-5-5,\n.pure-u-24-24 {\n    width: 100%;\n}\n.pure-button {\n    /* Structure */\n    display: inline-block;\n    line-height: normal;\n    white-space: nowrap;\n    vertical-align: middle;\n    text-align: center;\n    cursor: pointer;\n    -webkit-user-drag: none;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n/* Firefox: Get rid of the inner focus border */\n.pure-button::-moz-focus-inner {\n    padding: 0;\n    border: 0;\n}\n\n/* Inherit .pure-g styles */\n.pure-button-group {\n    letter-spacing: -0.31em; /* Webkit: collapse white-space between units */\n    text-rendering: optimizespeed; /* Webkit: fixes text-rendering: optimizeLegibility */\n}\n\n.opera-only :-o-prefocus,\n.pure-button-group {\n    word-spacing: -0.43em;\n}\n\n.pure-button-group .pure-button {\n    letter-spacing: normal;\n    word-spacing: normal;\n    vertical-align: top;\n    text-rendering: auto;\n}\n\n/*csslint outline-none:false*/\n\n.pure-button {\n    font-family: inherit;\n    font-size: 100%;\n    padding: 0.5em 1em;\n    color: var(--main-color);\n    border: none rgba(0, 0, 0, 0);\n    background-color: var(--main-control-button-color);\n    text-decoration: none;\n    border-radius: 2px;\n}\n\n.pure-button-hover,\n.pure-button:hover,\n.pure-button:focus,\nbutton:hover {\n    background-image: -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(40%, rgba(0,0,0, 0.05)), to(rgba(0,0,0, 0.10)));\n    background-image: linear-gradient(transparent, rgba(0,0,0, 0.05) 40%, rgba(0,0,0, 0.10));\n}\n.pure-button:focus {\n    outline: 0;\n}\n.pure-button-active,\n.pure-button:active {\n    -webkit-box-shadow: 0 0 0 1px rgba(0,0,0, 0.15) inset, 0 0 6px rgba(0,0,0, 0.20) inset;\n            box-shadow: 0 0 0 1px rgba(0,0,0, 0.15) inset, 0 0 6px rgba(0,0,0, 0.20) inset;\n    border-color: var(--main-accent-line);\n}\n\n.pure-button[disabled],\n.pure-button-disabled,\n.pure-button-disabled:hover,\n.pure-button-disabled:focus,\n.pure-button-disabled:active,\nbutton:disabled {\n    border: none;\n    background-image: none;\n    opacity: 0.40;\n    cursor: not-allowed;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    pointer-events: none;\n}\n\n.pure-button-hidden {\n    display: none;\n}\n\n.pure-button-primary,\n.pure-button-selected,\na.pure-button-primary,\na.pure-button-selected {\n    background: var(--primary-action-bg-color)\n    color: var(--primary-action-color);\n}\n\n/* Button Groups */\n.pure-button-group .pure-button {\n    margin: 0;\n    border-radius: 0;\n    border-right: 1px solid rgba(0, 0, 0, 0.2);\n\n}\n\n.pure-button-group .pure-button:first-child {\n    border-top-left-radius: 2px;\n    border-bottom-left-radius: 2px;\n}\n.pure-button-group .pure-button:last-child {\n    border-top-right-radius: 2px;\n    border-bottom-right-radius: 2px;\n    border-right: none;\n}\n\n/*csslint box-model:false*/\n/*\nBox-model set to false because we're setting a height on select elements, which\nalso have border and padding. This is done because some browsers don't render\nthe padding. We explicitly set the box-model for select elements to border-box,\nso we can ignore the csslint warning.\n*/\n\n.pure-form input[type=\"text\"],\n.pure-form input[type=\"password\"],\n.pure-form input[type=\"email\"],\n.pure-form input[type=\"url\"],\n.pure-form input[type=\"date\"],\n.pure-form input[type=\"month\"],\n.pure-form input[type=\"time\"],\n.pure-form input[type=\"datetime\"],\n.pure-form input[type=\"datetime-local\"],\n.pure-form input[type=\"week\"],\n.pure-form input[type=\"number\"],\n.pure-form input[type=\"search\"],\n.pure-form input[type=\"tel\"],\n.pure-form input[type=\"color\"],\n.pure-form select,\n.pure-form textarea {\n    padding: 0.5em 0.6em;\n    display: inline-block;\n    border: 1px solid #ccc;\n    -webkit-box-shadow: inset 0 1px 3px #ddd;\n            box-shadow: inset 0 1px 3px #ddd;\n    border-radius: 4px;\n    vertical-align: middle;\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n/*\nNeed to separate out the :not() selector from the rest of the CSS 2.1 selectors\nsince IE8 won't execute CSS that contains a CSS3 selector.\n*/\n.pure-form input:not([type]) {\n    padding: 0.5em 0.6em;\n    display: inline-block;\n    border: 1px solid #ccc;\n    -webkit-box-shadow: inset 0 1px 3px #ddd;\n            box-shadow: inset 0 1px 3px #ddd;\n    border-radius: 4px;\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n\n/* Chrome (as of v.32/34 on OS X) needs additional room for color to display. */\n/* May be able to remove this tweak as color inputs become more standardized across browsers. */\n.pure-form input[type=\"color\"] {\n    padding: 0.2em 0.5em;\n}\n\n\n.pure-form input[type=\"text\"]:focus,\n.pure-form input[type=\"password\"]:focus,\n.pure-form input[type=\"email\"]:focus,\n.pure-form input[type=\"url\"]:focus,\n.pure-form input[type=\"date\"]:focus,\n.pure-form input[type=\"month\"]:focus,\n.pure-form input[type=\"time\"]:focus,\n.pure-form input[type=\"datetime\"]:focus,\n.pure-form input[type=\"datetime-local\"]:focus,\n.pure-form input[type=\"week\"]:focus,\n.pure-form input[type=\"number\"]:focus,\n.pure-form input[type=\"search\"]:focus,\n.pure-form input[type=\"tel\"]:focus,\n.pure-form input[type=\"color\"]:focus,\n.pure-form select:focus,\n.pure-form textarea:focus {\n    outline: 0;\n    border-color: var(--value-focus-color);\n}\n\n/*\nNeed to separate out the :not() selector from the rest of the CSS 2.1 selectors\nsince IE8 won't execute CSS that contains a CSS3 selector.\n*/\n.pure-form input:not([type]):focus {\n    outline: 0;\n    border-color: var(--value-focus-color);\n}\n\n.pure-form input[type=\"file\"]:focus,\n.pure-form input[type=\"radio\"]:focus,\n.pure-form input[type=\"checkbox\"]:focus {\n  outline: thin solid var(--value-focus-color);\n  outline: 1px auto var(--value-focus-color);\n}\n.pure-form .pure-checkbox,\n.pure-form .pure-radio {\n    margin: 0.5em 0;\n    display: block;\n}\n\n.pure-form input[type=\"text\"][disabled],\n.pure-form input[type=\"password\"][disabled],\n.pure-form input[type=\"email\"][disabled],\n.pure-form input[type=\"url\"][disabled],\n.pure-form input[type=\"date\"][disabled],\n.pure-form input[type=\"month\"][disabled],\n.pure-form input[type=\"time\"][disabled],\n.pure-form input[type=\"datetime\"][disabled],\n.pure-form input[type=\"datetime-local\"][disabled],\n.pure-form input[type=\"week\"][disabled],\n.pure-form input[type=\"number\"][disabled],\n.pure-form input[type=\"search\"][disabled],\n.pure-form input[type=\"tel\"][disabled],\n.pure-form input[type=\"color\"][disabled],\n.pure-form select[disabled],\n.pure-form textarea[disabled] {\n    cursor: not-allowed;\n    background-color: var(--control-disabled-color);\n    color: var(--control-disabled-color);\n}\n\n/*\nNeed to separate out the :not() selector from the rest of the CSS 2.1 selectors\nsince IE8 won't execute CSS that contains a CSS3 selector.\n*/\n.pure-form input:not([type])[disabled] {\n    cursor: not-allowed;\n    background-color: var(--control-disabled-bg-color);\n    color: var(--control-disabled-color);\n}\n.pure-form input[readonly],\n.pure-form select[readonly],\n.pure-form textarea[readonly] {\n  background-color: var(--control-disabled-bg-color); /* menu hover bg color */\n  color: var(--control-disabled-color); /* menu text color */\n  border-color: #ccc;\n}\n\n.pure-form input:focus:invalid,\n.pure-form textarea:focus:invalid,\n.pure-form select:focus:invalid {\n    color: #b94a48;\n    border-color: #e9322d;\n}\n.pure-form input[type=\"file\"]:focus:invalid:focus,\n.pure-form input[type=\"radio\"]:focus:invalid:focus,\n.pure-form input[type=\"checkbox\"]:focus:invalid:focus {\n    outline-color: #e9322d;\n}\n.pure-form select {\n    /* Normalizes the height; padding is not sufficient. */\n    height: 2.25em;\n    border: 1px solid #ccc;\n    background-color: var(--main-bg-color);\n}\n.pure-form select[multiple] {\n    height: auto;\n}\n.pure-form label {\n    margin: 0.5em 0 0.2em;\n}\n.pure-form fieldset {\n    margin: 0;\n    padding: 0.35em 0 0.75em;\n    border: 0;\n}\n.pure-form legend {\n    display: block;\n    width: 100%;\n    padding: 0.3em 0;\n    margin-bottom: 0.3em;\n    color: var(--main-color);\n    border-bottom: 1px solid #e5e5e5;\n}\n\n.pure-form-stacked input[type=\"text\"],\n.pure-form-stacked input[type=\"password\"],\n.pure-form-stacked input[type=\"email\"],\n.pure-form-stacked input[type=\"url\"],\n.pure-form-stacked input[type=\"date\"],\n.pure-form-stacked input[type=\"month\"],\n.pure-form-stacked input[type=\"time\"],\n.pure-form-stacked input[type=\"datetime\"],\n.pure-form-stacked input[type=\"datetime-local\"],\n.pure-form-stacked input[type=\"week\"],\n.pure-form-stacked input[type=\"number\"],\n.pure-form-stacked input[type=\"search\"],\n.pure-form-stacked input[type=\"tel\"],\n.pure-form-stacked input[type=\"color\"],\n.pure-form-stacked input[type=\"file\"],\n.pure-form-stacked select,\n.pure-form-stacked label,\n.pure-form-stacked textarea {\n    display: block;\n    margin: 0.25em 0;\n}\n\n/*\nNeed to separate out the :not() selector from the rest of the CSS 2.1 selectors\nsince IE8 won't execute CSS that contains a CSS3 selector.\n*/\n.pure-form-stacked input:not([type]) {\n    display: block;\n    margin: 0.25em 0;\n}\n.pure-form-aligned input,\n.pure-form-aligned textarea,\n.pure-form-aligned select,\n.pure-form-message-inline {\n    display: inline-block;\n    vertical-align: middle;\n}\n.pure-form-aligned textarea {\n    vertical-align: top;\n}\n\n/* Aligned Forms */\n.pure-form-aligned .pure-control-group {\n    margin-bottom: 0.5em;\n}\n.pure-form-aligned .pure-control-group label {\n    text-align: right;\n    display: inline-block;\n    vertical-align: middle;\n    width: 10em;\n    margin: 0 1em 0 0;\n}\n.pure-form-aligned .pure-controls {\n    margin: 1.5em 0 0 11em;\n}\n\n/* Rounded Inputs */\n.pure-form input.pure-input-rounded,\n.pure-form .pure-input-rounded {\n    border-radius: 2em;\n    padding: 0.5em 1em;\n}\n\n/* Grouped Inputs */\n.pure-form .pure-group fieldset {\n    margin-bottom: 10px;\n}\n.pure-form .pure-group input,\n.pure-form .pure-group textarea {\n    display: block;\n    padding: 10px;\n    margin: 0 0 -1px;\n    border-radius: 0;\n    position: relative;\n    top: -1px;\n}\n.pure-form .pure-group input:focus,\n.pure-form .pure-group textarea:focus {\n    z-index: 3;\n}\n.pure-form .pure-group input:first-child,\n.pure-form .pure-group textarea:first-child {\n    top: 1px;\n    border-radius: 4px 4px 0 0;\n    margin: 0;\n}\n.pure-form .pure-group input:first-child:last-child,\n.pure-form .pure-group textarea:first-child:last-child {\n    top: 1px;\n    border-radius: 4px;\n    margin: 0;\n}\n.pure-form .pure-group input:last-child,\n.pure-form .pure-group textarea:last-child {\n    top: -2px;\n    border-radius: 0 0 4px 4px;\n    margin: 0;\n}\n.pure-form .pure-group button {\n    margin: 0.35em 0;\n}\n\n.pure-form .pure-input-1 {\n    width: 100%;\n}\n.pure-form .pure-input-3-4 {\n    width: 75%;\n}\n.pure-form .pure-input-2-3 {\n    width: 66%;\n}\n.pure-form .pure-input-1-2 {\n    width: 50%;\n}\n.pure-form .pure-input-1-3 {\n    width: 33%;\n}\n.pure-form .pure-input-1-4 {\n    width: 25%;\n}\n\n/* Inline help for forms */\n.pure-form-message-inline {\n    display: inline-block;\n    padding-left: 0.3em;\n    color: #666;\n    vertical-align: middle;\n    font-size: 0.875em;\n}\n\n/* Block help for forms */\n.pure-form-message {\n    display: block;\n    color: #666;\n    font-size: 0.875em;\n}\n\n@media only screen and (max-width : 480px) {\n    .pure-form button[type=\"submit\"] {\n        margin: 0.7em 0 0;\n    }\n\n    .pure-form input:not([type]),\n    .pure-form input[type=\"text\"],\n    .pure-form input[type=\"password\"],\n    .pure-form input[type=\"email\"],\n    .pure-form input[type=\"url\"],\n    .pure-form input[type=\"date\"],\n    .pure-form input[type=\"month\"],\n    .pure-form input[type=\"time\"],\n    .pure-form input[type=\"datetime\"],\n    .pure-form input[type=\"datetime-local\"],\n    .pure-form input[type=\"week\"],\n    .pure-form input[type=\"number\"],\n    .pure-form input[type=\"search\"],\n    .pure-form input[type=\"tel\"],\n    .pure-form input[type=\"color\"],\n    .pure-form label {\n        margin-bottom: 0.3em;\n        display: block;\n    }\n\n    .pure-group input:not([type]),\n    .pure-group input[type=\"text\"],\n    .pure-group input[type=\"password\"],\n    .pure-group input[type=\"email\"],\n    .pure-group input[type=\"url\"],\n    .pure-group input[type=\"date\"],\n    .pure-group input[type=\"month\"],\n    .pure-group input[type=\"time\"],\n    .pure-group input[type=\"datetime\"],\n    .pure-group input[type=\"datetime-local\"],\n    .pure-group input[type=\"week\"],\n    .pure-group input[type=\"number\"],\n    .pure-group input[type=\"search\"],\n    .pure-group input[type=\"tel\"],\n    .pure-group input[type=\"color\"] {\n        margin-bottom: 0;\n    }\n\n    .pure-form-aligned .pure-control-group label {\n        margin-bottom: 0.3em;\n        text-align: left;\n        display: block;\n        width: 100%;\n    }\n\n    .pure-form-aligned .pure-controls {\n        margin: 1.5em 0 0 0;\n    }\n\n    .pure-form-message-inline,\n    .pure-form-message {\n        display: block;\n        font-size: 0.75em;\n        /* Increased bottom padding to make it group with its related input element. */\n        padding: 0.2em 0 0.8em;\n    }\n}\n\n/*csslint adjoining-classes: false, box-model:false*/\n.pure-menu {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n.pure-menu-fixed {\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 3;\n}\n\n.pure-menu-list,\n.pure-menu-item {\n    position: relative;\n}\n\n.pure-menu-list {\n    list-style: none;\n    margin: 0;\n    line-height: 1.4;\n    padding: 0;    \n}\n\n.pure-menu-item {\n    padding: 0;\n    margin: 0;\n    height: 100%;\n}\n\n.pure-menu-link,\n.pure-menu-heading {\n    display: block;\n    text-decoration: none;\n    white-space: nowrap;\n}\n\n/* HORIZONTAL MENU */\n.pure-menu-horizontal {\n    width: 100%;\n    white-space: nowrap;\n}\n\n.pure-menu-horizontal .pure-menu-list {\n    display: inline-block;\n}\n\n/* Initial menus should be inline-block so that they are horizontal */\n.pure-menu-horizontal .pure-menu-item,\n.pure-menu-horizontal .pure-menu-heading,\n.pure-menu-horizontal .pure-menu-separator {\n    display: inline-block;\n    vertical-align: middle;\n}\n\n/* Submenus should still be display: block; */\n.pure-menu-item .pure-menu-item {\n    display: block;\n}\n\n.pure-menu-children {\n    display: none;\n    position: absolute;\n    left: 100%;\n    top: 0;\n    margin: 0;\n    padding: 0;\n    z-index: 3;\n}\n\n.pure-menu-horizontal .pure-menu-children {\n    left: 0;\n    top: auto;\n    width: inherit;\n}\n\n.pure-menu-allow-hover:hover > .pure-menu-children,\n.pure-menu-active > .pure-menu-children {\n    display: block;\n    position: absolute;\n}\n\n/* Vertical Menus - show the dropdown arrow */\n.pure-menu-has-children > .pure-menu-link:after {\n    padding-left: 0.5em;\n    content: \"\";\n    font-size: small;\n}\n\n/* Horizontal Menus - show the dropdown arrow */\n.pure-menu-horizontal .pure-menu-has-children > .pure-menu-link:after {\n    content: \"\";\n}\n\n/* scrollable menus */\n.pure-menu-scrollable {\n    overflow-y: scroll;\n    overflow-x: hidden;\n}\n\n.pure-menu-scrollable .pure-menu-list {\n    display: block;\n}\n\n.pure-menu-horizontal.pure-menu-scrollable .pure-menu-list {\n  display: inline-block;    \n}\n\n.pure-menu-horizontal.pure-menu-scrollable {\n    white-space: nowrap;\n    overflow-y: hidden;\n    overflow-x: auto;\n    /* a little extra padding for this style to allow for scrollbars */\n    padding: .5em 0;\n}\n\n/* misc default styling */\n\n.pure-menu-separator,\n.pure-menu-horizontal .pure-menu-children .pure-menu-separator {\n    background-color: #ccc;\n    height: 1px;\n    margin: .3em 0;\n}\n\n.pure-menu-horizontal .pure-menu-separator {\n    width: 1px;\n    height: 1.3em;\n    margin: 0 .3em ;\n}\n\n/* Need to reset the separator since submenu is vertical */\n.pure-menu-horizontal .pure-menu-children .pure-menu-separator {\n    display: block;\n    width: auto;\n}\n\n.pure-menu-heading {\n    /* text-transform: uppercase; */\n    color: #565d64;\n}\n\n.pure-menu-link {\n  color: var(--main-color);\n}\n\n.pure-menu-children {\n  background-color: var(--main-bg-color);\n}\n\n.pure-menu-link,\n.pure-menu-heading {\n    padding: 0.3em 1em;\n}\n\n.pure-menu-disabled {\n    opacity: .5;\n}\n\n.pure-menu-disabled .pure-menu-link:hover {\n    background-color: transparent;\n    cursor: default;\n}\n\n.pure-menu-active > .pure-menu-link,\n.pure-menu-link:hover,\n.pure-menu-link:focus {\n  background-color: var(--highlight-bg-color);\n  color: var(--highlight-color);\n}\n\n.pure-menu-selected > .pure-menu-link,\n.pure-menu-selected > .pure-menu-link:visited {\n    color:  #000;\n}\n\n.pure-table {\n    /* Remove spacing between table cells (from Normalize.css) */\n    border-collapse: collapse;\n    border-spacing: 0;\n    empty-cells: show;\n    border: 1px solid #cbcbcb;\n}\n\n.pure-table caption {\n    color: #000;\n    font: italic 85%/1 arial, sans-serif;\n    padding: 1em 0;\n    text-align: center;\n}\n\n.pure-table td,\n.pure-table th {\n    border-left: 1px solid #cbcbcb;/*  inner column border */\n    border-width: 0 0 0 1px;\n    font-size: inherit;\n    margin: 0;\n    overflow: visible; /*to make ths where the title is really long work*/\n    padding: 0.5em 1em; /* cell padding */\n}\n\n.pure-table thead {\n    background-color: var(--main-accent-color);\n    color: var(--main-color);\n    text-align: left;\n    vertical-align: bottom;\n}\n\n/*\nstriping:\n   even - #fff (white)\n   odd  - #f2f2f2 (light gray)\n*/\n.pure-table td {\n    background-color: transparent;\n}\n.pure-table-odd td {\n    background-color: #f2f2f2;\n}\n\n/* nth-child selector for modern browsers */\n.pure-table-striped tr:nth-child(2n-1) td {\n    background-color: #f2f2f2;\n}\n\n/* BORDERED TABLES */\n.pure-table-bordered td {\n    border-bottom: 1px solid #cbcbcb;\n}\n.pure-table-bordered tbody > tr:last-child > td {\n    border-bottom-width: 0;\n}\n\n\n/* HORIZONTAL BORDERED TABLES */\n\n.pure-table-horizontal td,\n.pure-table-horizontal th {\n    border-width: 0 0 1px 0;\n    border-bottom: 1px solid #cbcbcb;\n}\n.pure-table-horizontal tbody > tr:last-child > td {\n    border-bottom-width: 0;\n}\n\n\n/* ----- Specific Juno Styles ----- */\n\nsummary {\n  display: list-item;\n  padding: 1px;\n}\n\nbutton {\n  margin-left: 5px;\n  margin-right: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border: 1px solid transparent;\n  border-radius: 0px;  \n  background: var(--main-control-button-color);\n  color: var(--main-color);\n}\n\nbutton.juno-primary {\n  background: var(--primary-action-bg-color);\n  color: var(--primary-action-color);\n  min-width: 60px;\n}\n\nbutton.juno-secondary {  \n  min-width: 60px;\n}\n\nbutton.juno-button-on {\n  background: orange;\n  color: white;\n}\n\nbutton.juno-command-button {\n  \n}\n\njuno-dialog { \n  min-width: 300px;\n}\n\nbutton:hover {\n  background: var(--button-hover-bg-color);  \n  border: 1px inset #ffffff;\n}\n\nselect,input {\n  border: 1px solid var(--main-accent-line);\n  background: var(--control-text-input-color-bg);\n  color: var(--main-color);\n  padding: 3px;\n}\n\nselect:focus,input:focus {\n  color: var(--control-text-input-color);\n  border-top: 1px solid var(--main-accent-line);\n  border-left: 1px solid var(--main-accent-line);\n  border-right: 1px solid var(--main-accent-line);\n  border-top: 1px solid var(--value-focus-color);  \t      \t      \n}\n\na {\n    color: var(--link-color);\n    background: var(--link-bg-color);\n}\n\na:visited {\n    color: var(--link-visited-color);\n    background: var(--link-visted-bg-color);\n}\n\ndialog:modal {\n  height: 40%;\n  width: 60%;\n  overflow: hidden;\n  position: fixed;\n  top: 0px;\n  bottom: 0px;\n  max-width: calc((100% - 6px) - 2em);\n  max-height: calc((100% - 6px) - 2em);\n  min-width: 300px;\n  user-select: text;\n  visibility: visible;  \n  border: 1px solid var(--main-accent-color);\n  color: var(--main-color);\n  background: var(--main-bg-color);\n  box-shadow: 1px 2px 11px 2px #00000033;\n}\n\n\n\n.filtered-hidden {\n  display: none;\n}\n\n.filtered-lower-opacity {\n  opacity: 50%;\n}\n\n::-webkit-scrollbar {\n    width: 10px;\n    height: 10px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--scrollbar-track-color);\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--scrollbar-thumb-color);\n}\n\n::-webkit-scrollbar-corner {\n    background: var(--scrollbar-track-color);\n}\n\n.juno-scrollbar {\n    width: 10px;\n    height: 10px;\n}\n\n.juno-scrollbar::-webkit-scrollbar-track {\n    background: var(--scrollbar-track-color);\n}\n\n.juno-scrollbar::-webkit-scrollbar-thumb {\n    background: var(--scrollbar-thumb-color)\n}\n\n\n.juno-view-container {\n  display: inline-block;\n  color: var(--main-color);\n  width: inherit;\n  height: inherit;\n  overflow: hidden;  /* Views need to manage how they present their content */\n}\n\n.juno-view-content {\n  height: calc(100% - 5px);\n  width: 100%;\n}\n\nhr {\n    border: 0;\n    height: 0;\n    border-top: 1px solid rgba(0,0,0,.1);\n    border-bottom: 1px solid rgba(255,255,255,.3);\n}\n\n.juno-monospace {\n  font-family: var(--main-mono-space);\n}\n\n.juno-page-header {\n  color: var(--header-color);\n  background: var(--header-bg-color);\n  height: 28px;\n  display: flex;\n}\n\n.juno-view-container thead {\n  text-align: left;\n  padding: 3px;  \n  background: var(--main-accent-color);\n}\n\n.juno-view-container thead {\n  text-align: left;\n  padding: 3px;  \n  background: var(--main-accent-color);\n}\n\n.juno-view-container td {\n   \n}\n\ndiv.juno-notification {\n   z-index: 5; \n   box-shadow: 1px 2px 11px 2px #00000050; \n   padding: 5px; \n   position: relative; \n   opacity: 0; cursor: pointer; \n   color: var(--main-bg-color); \n   background: var(--main-color); \n   display: inline-block; \n   width: 250px; \n   overflow: auto; \n   height: 70px; \n   text-overflow: ellipses;\n   border-radius: 5px; \n}\n\n.juno-empty-content {\n  width: 100%;\n  height: 100%;    \n  text-align: middle;\n}\n\n.juno-vertical-split-container {\n  overflow: hidden;\n  margin: 0px;\n  padding: 0px;\n  position: relative;\n  display: inline-block;  \n  height: calc(100% - 5px);\n}\n\n.juno-horizontal-split-container {\n  overflow: hidden;\n  margin: 0px;\n  padding: 0px;\n  position: relative;\n  display: block;  \n  height: calc(100% - 5px);\n}\n\nli.juno-main-menu-header {\n  display: inline-block;\n  color: var(--header-color);\n}\n\n.juno-vertical-dragger { \n  width: 7px;\n  height: 100%;\n  cursor: col-resize;\n  display: inline-block;\n  border-left: 1px solid var(--main-accent-line);\n}\n\n.juno-vertical-dragger:hover { \n  background: var(--main-accent-line-hover);\n}\n\n.juno-horizontal-dragger {\n  height: 7px;\n  width: 100%;\n  cursor: row-resize;\n  display: inline-block;\n  border-top: 1px solid #00000020;\n}\n\n.juno-horizontal-dragger:hover {  \n  background: var(--main-accent-line-hover);\n}\n\n.juno-active-hover {\n  background: #00000010;\n}\n\n.juno-buffer-bar {    \n  background: var(--main-accent-color);\n  width: 100%;\n  cursor: default;\n  white-space: nowrap;\n  overflow: hidden;\n  padding-top: 2px;\n  padding-bottom: 2px;\n  color: var(--control-unfocused-color);\n  border-bottom: 1px solid var(--main-accent-line);\n}\n\n.juno-instructions {\n  padding-bottom: 5px;  \n}\n\n.juno-control-group {\n  padding: 5px;\n}\n\n.juno-title {\n  padding-left: 10px;\n  padding-right: 10px;\n  font-weight: bold;\n  \n}\n\n.juno-path {\n  color: var(--type-path-color);\n  padding-left: 10px;\n  padding-right: 10px;\n  font-family: var(--main-mono-space);\n}\n\n.juno-path:hover {\n  background: #FFFFFF40;\n  box-shadow: 0 0 4px 1px #a0a0a042;\n \n}\n\ndiv.juno-result,\ndetails.juno-result {\n  border-left: 3px solid #0167835e;\n  border-top: 1px solid #00000020;\n  padding: 5px;\n  margin-top: 7px;\n  width: calc(100% - 13px);\n  display: inline-block; \n}\n\n.juno-log-output {\n  background: var(--log-result-bg-color);\n  height: calc(100% - 20px);\n  overflow: scroll;\n  width: 100%;\n  vertical-align:bottom;\n}\n\n.juno-log-message {\n  background: var(--log-message-bg-color);\n}\n\nspan.juno-evaluator {\n  padding-left: 10px;\n  padding-right: 10px;\n  font-family: var(--main-mono-space);\n  margin-left: 10px;\n  margin-right: 10px;\n  color: var(--main-color);\n}\n\nspan.juno-namespace {\n  font-family: var(--main-mono-space);\n  color: var(--namespace-color);\n}\n\nli.juno-namespace {\n  color: var(--namespace-color);\n  font-weight: bold;  \n}\n\ndiv.juno-symbol-browser {\n  display: flex;\n  align-content: flex-start;\n  height: 100%;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n\n.juno-symbol-browser ol {\n  height: calc(100% - 10px);\n  overflow-y: scroll;\n  overflow-x: hidden; \n  padding-inline-start: 2px;\n  border-right: 2px inset var(--main-accent-line);\n  max-width: 295px;\n  min-width: 200px;\n  background: var(--main-control-surface-accent-color);\n}\n\n.juno-list-item {\n  list-style: none;\n  padding: 4px;\n  cursor: default;\n  min-width: 200px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  \n}\n\n.juno-list-item:hover {\n  background-color: var(--highlight-bg-color) !important;\n  color: var(--highlight-color) !important;\n}\n\n.juno-highlighted {\n  background-color: var(--highlight-bg-color) !important;\n  color: var(--highlight-color) !important;\n}\n\n\ndiv.juno-focused {\n  background: var(--control-focused);\n  color: var(--main-color);\n  border-bottom: 1px solid var(--main-control-button-color);\n}\n\nspan.juno-needs-save {\n  color: var(--value-modified-color)\n}\n\n.juno-menu {\n  position: absolute;\n  z-index: 20;\n  /* animation: slide-in 0.2s ease-out; */\n  box-shadow: 2px 3px 8px 0px #00000069;\n  background: var(--main-bg-color);\n  border: 1px solid var(--main-control-surface-accent-color);\n}\n\n\nli.juno-menu-header {\n  cursor: default;\n  line-height: 1.8em;\n  padding-left: 10px;\n  padding-right: 10px;\n  border-radius: 4px;\n  user-select: none;\n}\n\nli.juno-main-menu-header {\n  \n}\n\nspan.juno-menu-text {\n \n}\n\nspan.juno-menu-submenu {\n  float: right;\n  opacity: 0.7;\n}\n\nli.juno-menu-header:hover {\n  background: var(--highlight-bg-color);\n  color: var(--highlight-color);\n}\n\nli.juno-menu-header:active {\n  background: var(--highlight-bg-color);\n  color: var(--highlight-color);\n}\n\n\nli.juno-menu-selected {\n  background: var(--highlight-bg-color) !important;\n  color: var(--highlight-color) !important;\n}\n\n.juno-menu-selected > .pure-menu-link {\n  background: var(--highlight-bg-color) !important;\n  color: var(--highlight-color) !important;\n}\n\n.juno-selected {\n  background: var(--selected-bg-color);\n  color: var(--selected-color);\n  font-weight: bold;\t      \n}\n\n.juno-header {  \n  padding-top: 5px;\n  padding-bottom: 4px;\n  margin-right: 10px;\n  font-weight: bold;\n  display: inline-block;\n  cursor: default;\n  color: var(--app-header-color);\n  padding-left: 10px;\n  padding-right: 10px;\n}\n\n.juno-display-none {\n    display: none !important;\n}\n\ndiv.juno-floating-container {\n    cursor: default;\n    user-select: none;\n    box-shadow: 1px 1px 12px 0px #00000080;\n    background: var(--main-bg-color); \n    color: var(--main-color);\n    position: absolute;\n    z-index: 10;\n    min-width: 300px;\n}\n\ntd.juno-obj-to-dom-key {\n    vertical-align: top;\n    color: var(--type-key-color);\n    text-align: right;\n    font-weight: bold;\n    padding-right: 5px;\n}\n\nsummary.juno-type-view {\n  padding: 1px;\n}\n\nspan.juno-code-value {  \n  color: var(--type-code-color);\n  text-overflow: ellipsis;\n}\n\nsummary.juno-code-value {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  font-family: var(--main-mono-space);\n}\n\n.juno-code-value {\n  color: var(--type-code-color);\n  font-style: italic;\n}\n\n.juno-code-value:focus {\n  outline: var(--value-focus-color) auto 1px;\n}\n\nspan.juno-value {\n  display: inline-block;\n}\n\n.juno-type-array {\n  color: var(--type-array-color);\n}\n\n.juno-value:focus {\n  outline: var(--value-focus-color) auto 1px;\n}\n\n.juno-type-array summary:focus {\n  outline: var(--value-focus-color) auto 1px;\n}\n\n.juno-obj-to-dom summary:focus {\n  outline: var(--value-focus-color) auto 1px;\n}\n\n.juno-type-number {\n  color: var(--type-number-color)\n}\n\n.juno-type-boolean {\n  color: var(--type-boolean-color)\n}\n\n.juno-type-string {\n  color: var(--type-string-color)\n}\n\n.juno-type-regexp {\n  color: var(--type-regexp-color);\n  font-style: italic;\n}\n\n.juno-timestamp {\n    padding-right: 10px; \n    min-width: 150px; \n    display: inline-block;\n}\n\n.juno-mode {\n  color: var(--mode-color);\n  margin-left: 10px;\n  margin-right: 10px; \n}\n\nsummary.juno-type-function {\n  color: var(--type-function-color);\n  \n}\n\n.juno-type-function {\n  color: var(--type-function-color);\n}\n\n.juno-type-asyncfunction {\n  color: var(--type-asyncfunction-color);\n}\n\n\n.juno-type-error {\n  color: var(--type-error-color);\n}\n\n.juno-type-symbol {\n  color: var(--type-symbol-color);  \n  box-shadow: 0 0 4px 1px #a0a0a042;\n}\n\n.juno-type-null {\n  color: var(--type-null-color);\n  font-style: italic;\n}\n\n.juno-type-undefined {\n  color: var(--type-undefined-color);\n}\n\nli.juno-array-item {\n    list-style: decimal;\n}\n\nli.juno-array-item::marker {\n    color: var(--type-path-color);\n    content: counter(list-item) \":  \";    \n    font-family: var(--main-mono-space);\n}\n\nol.juno-type-array {\n  border: 2px dashed transparent;\n  border-radius: 2px;\n}\n\nol.juno-type-array:hover {\n  background: #ffffff03;\n  box-shadow: 0 0 4px 1px #a0a0a042;\n  border-color: #ffffff08;\n}\n\n.identification {\n  background: var(--identification-bg-color) !important;\n}\n\ndiv.juno-help-context {\n  white-space: nowrap;\n  font-size: 1.1em;\n  text-overflow: ellipsis;\n  display: inline-block;\n  width: calc(100% - 30px);\n  padding-left: 10px;\n  padding-right: 10px;\n  font-family: var(--main-mono-space);\n}\n\ndiv.juno-control {\n    overflow: scroll;\n    height: calc(100% - 10px);\n    width: calc(100% - 10px);\n    background: var(--control-bg-color);\n    color: var(--control-color);\n}\n\ndiv.juno-editable {\n    padding: 5px;\n    caret-color: red;\n}\n\ndiv.juno-editable:focus {\n    outline: none;\n    transition: all .1s ease-in-out;\n}\n\ninput.juno-editable {\n   transition:all .1s ease-in-out;\n}\n\ninput.juno-editable:focus {\n   outline: none;\n   box-shadow: 1px 1px 6px 2px #00000040;\n   transition all .1s ease-in-out;\n}\n\nspan.juno-editable:focus {\n   outline: none;\n   background: #FFFFFF10;\n   padding-left: 5px;\n   padding-right: 5px;\n   box-shadow: 1px 1px 6px 2px #00000040;\n   transition: all .1s ease-in-out;\n}\n\n.juno-editable  pre {\n    font-family: var(--main-mono-space);\n    box-shadow: 1px 1px 6px 2px #00000010; \n    border: 1px solid var(--main-accent-line); \n    background: #FFFFFF20;\n    overflow: auto;\n    padding: 5px;\n}\n\n.juno-editable code {\n    background: #FFFFFF20;\n    padding: 3px;\n}\n\n.juno-editable div {\n  margin-top: 5px;\n  margin-bottom: 10px;\n}\n\n.juno-editable div:focus {\n  outline: none;\n}\n\n.juno-context-bar {\n  padding: 3px;\n  min-height: 26px;\n  background: var(--main-control-surface-accent-color);\n}\n\n.juno-operator-name {\n  padding-left: 4px;\n  padding-right: 4px;\n  \n}\n\n.juno-arg-name {\n  padding-left: 5px;\n  padding-right: 5px;\n  margin-left: 2px;  \n}\n\n\nspan.juno-tag {\n    cursor: pointer; \n    margin-right: 5px; \n    padding: 5px;\n    border: 1px solid var(--main-accent-line-hover);\n    transition: all .1s ease-in-out;\n}\n\nspan.juno-tag:hover {\n    transition: all .1s ease-in-out;\n    box-shadow: 0 0 5px 1px #a0a0a052;\n    background: #FFFFFF10;\n}\n\nspan.juno-requires {\n    padding: 5px;\n    cursor: pointer;\n}\n\nspan.juno-requires:hover {\n    text-decoration: underline;\n}\n\n.opacity-0 {\n  opacity: 0;\n}\n\n.juno-selected-menu-item {\n    margin-left: -5px; \n    padding-left: 5px; \n    padding-right: 5px; \n    border-radius: 3px; \n    font-weight: bold; \n    background: var(--selected-bg-color); \n    color: var(--selected-color);\n}\n\ninput.juno-input-error {\n   color: darkred; \n   text-decoration: line-through;\n}\n\n.juno-shadow-on-hover {\n    border: 1px solid transparent;\n}\n\n.juno-shadow-on-hover:hover {\n    box-shadow: 2px 3px 8px 0px #00000040;\n    border-color: var(--main-accent-line-hover);\n}\n\n@keyframes slide-in {\n    0% {\n        margin-top:-6px;\n        opacity: 0\n    }\n    100% {\n        margin-top:-0px;\n        opacity: 1\n    }\n}\n\nspan.juno-hint {\n    padding-left: 4px;\n    padding-right: 4px;\n    margin-left: 10px;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n.juno-non-value {\n    opacity: 60%;\n}\n\n.juno-source-location {\n    padding: 5px;\n    background: var(--main-accent-line);\n    cursor: pointer;\n}\n\n.juno-bottom-bar {\n    padding: 5px;\n    margin-top: 5px;\n}\n\n.juno-form {\n    padding: 10px;\n    flex-direction: column;\n    display: flex;\n    height: calc(100% - 50px);\n    justify-content: stretch;\n}\n\n.juno-form h4 {\n    margin-top: 0px;\n    margin-bottom: 5px;\n}\n\n.juno-form-data {\n    line-height: 1.5em;\n    display: flex;\n    justify-content: stretch;\n    flex-direction: column;\n}\n\n/* Overrides - may be dealt with in a better way but for now\n * placing in the same as the main style set for easier\n * managament */\n\n.ace-tm .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid var(--matching-paren-outline-color);\n    background: var(--matching-paren-color);\n}\n\n\n" })();__obj__1["*global_themes*"]={juno_light:"\n\n:root {\n    --main-bg-color: hsl(40deg 13% 90%);\n    --main-color: #000000;\n    --header-bg-color: hsl(43deg 14% 93%);;\n    --highlight-bg-color: #404040;\n    --highlight-color: white;\n    --selected-bg-color: #0278e7;\n    --selected-color: #FFFFFF;\n    --control-bg-color: hsl(40deg 13% 90%);\n    --control-color: #000000;\n    --control-focused: hsl(45 11% 95% / 1);\n    --control-text-input-color-bg: #FFFFFF50;\n    --control-unfocused-color: darkgray;\n    --control-disabled-bg-color: #eaeded;\n    --control-disabled-color: #cad2d3;\n    --control-readonly-color: #777;\n    --button-hover-bg-color: #00000030;\n    --app-header-color: black;\n    --namespace-color: #976464;\n    --log-message-bg-color: inherit;\n    --log-result-bg-color: inherit;\n    --main-accent-color: #0000000A;\n    --main-accent-line: #00000015;\n    --main-accent-line-hover: #00000025;\n    --main-control-surface-accent-color: #efe5e540;\n    --main-control-button-color: #00000020;\n    --scrollbar-thumb-color: #00000040;\n    --scrollbar-track-color: #00000010;\n    --link-color: #002fdc;\n    --link-visited-color: #9a00dc;\n    --link-bg-color: inherit;\n    --link-visited-bg-color: inherit;\n    --value-modified-color: #016783;\n    --matching-paren-color: #ffeb00;\n    --matching-paren-outline-color: #b6a800;\n    --type-number-color: green;\n    --type-boolean-color: orange;\n    --type-string-color: darkblue;\n    --type-function-color: #2e3eb4;\n    --type-asyncfunction-color: #3f5b71;\n    --type-null-color: #a35e5e;\n    --type-undefined-color: #9d9d9d;\n    --type-symbol-color: #ff4f4f;\n    --type-error-color: darkred;\n    --type-array-color: #535173;\n    --type-path-color: #88127D;\n    --type-regexp-color: #fe2f53;\n    --type-code-color: darkblue;\n    --value-focus-color: #0168ff;\n    --mode-color: #0278e7;\n    --primary-action-bg-color: #0278e7;\n    --primary-action-color: #FFFFFF;\n    --main-app-font: -apple-system,BlinkMacSystemFont,'Segoe UI','Helvetica Neue', Helvetica, FreeSans, Arimo, \"Droid Sans\", Arial, sans-serif;\n    --main-app-font-size: 14px;\n    --main-mono-space: ui-monospace,\n  \"Cascadia Mono\", \"Segoe UI Mono\",    \n    \"Roboto Mono\",\n    \"Ubuntu Mono\",\n    Menlo, Monaco, Consolas,\n    monospace;\n    --editor-bg-color: hsl(43deg 14% 93%);\n    --editor-text-color: #363636;\n    --editor-gutter-bg-color: #e0e0e0;\n    --editor-gutter-color: #333;\n    --editor-cursor-color: #202020;\n    --editor-selected-bg-color: #4ab1ff3d;\n    --editor-selected-word-bg-color: #fff05c40;\n    --editor-step-bg-color: rgb(198,219,174);\n    --editor-active-line-bg: rgb(255 255 255 / 53%);\n    --editor-active-line-gutter-bg-color: rgb(166 166 166 / 46%);\n    --editor-invisible-color: #BFBFBF;\n    --editor-keyword-color: #670171;\n    --editor-identifier-color: #191919;\n    --editor-constant-color: #CD6839;\n    --editor-numeric-color: #9A5925;\n    --editor-support-color: #104e8b;\n    --editor-function-color: #0274a1;\n    --editor-string-color: #006b1e;\n    --editor-constant-color: #CF6A4C;\n    --editor-variable-color: #009ACD;\n    --editor-comment-color: rgba(148,148,148, 0.91);\n    --editor-storage-color: #A52A2A;\n    --editor-illegal-color: #FD1224;\n    --editor-illegal-bg-color: rgba(255, 6, 0, 0.15);\n    --editor-deprecated-color: #FD1732;\n    --editor-deprecated-bg-color: #EEEAE8;\n    --editor-regex-color: #fe2f53;\n    --editor-regex-bg-color: #FE40AA10;\n    --editor-heading-color: #B8012D;\n    --editor-heading-bg-color: rgba(191,97,51,0.051);\n    --editor-list-color: #8F5B26;\n}",earth_tones:":root {\n  --main-bg-color: #849a8f; /* #85988b; */\n  --main-color: #000000;\n  --header-color: white;\n  --header-bg-color: #000000BF;\n  --app-header-color: #E6E6E6;\n  --highlight-bg-color: #FBF7ED;\n  --highlight-color: #000000;\n  --control-bg-color: hsl(44deg 26% 83%);\n  --control-color: inherit;\n  --control-focused: #efe5e540;\n  --control-text-input-color-bg: #FFFFFF50;\n  --control-unfocused-color: #0000009e;\n  --control-unfocused-bg-color: #FFFFFF10;\n  --control-disabled-bg-color: #eaeded;\n  --control-disabled-color: #cad2d3;\n  --control-readonly-color: #777;\n  --button-hover-bg-color: #00000030;\n  --namespace-color: #9d0e0e;\n  --main-accent-color: #0000000A;\n  --main-accent-line: #00000015;\n  --main-accent-line-hover: #00000025;\n  --main-control-surface-accent-color: #efe5e540;\n  --main-control-button-color: #00000020;\n  --scrollbar-thumb-color: #00000040;\n  --scrollbar-track-color: #00000010;\n  --link-color: #002fdc;\n  --link-visited-color: #9a00dc;\n  --link-bg-color: inherit;\n  --link-visited-bg-color: inherit;\n  --value-modified-color: #004e64;\n  --matching-paren-color: #ffeb00;\n  --matching-paren-outline-color: #b6a800;\n  --log-message-bg-color: hsl(44deg 26% 83%); /* hsl(44deg 38% 89%); */\n  --log-result-bg-color: hsl(44deg 26% 83%);  /* hsl(44deg 26% 83%); */\n  --type-number-color: #015415;\n  --type-boolean-color: #d35600;\n  --type-string-color: darkblue;\n  --type-function-color: #2e3eb4;\n  --type-asyncfunction-color: #3f5b71;\n  --type-null-color: #a35e5e;\n  --type-undefined-color: #9d9d9d;\n  --type-key-color: #74006c;\n  --type-symbol-color: #ff4f4f;\n  --type-error-color: darkred;\n  --type-array-color: #535173;\n  --type-path-color: #88127D;\n  --type-regexp-color: #fe2f53;\n  --type-code-color: darkblue;\n  --value-focus-color: #0168ff;\n  --mode-color: #0c20ff;\n  --primary-action-bg-color: #0278e7;\n  --primary-action-color: #FFFFFF;\n  --main-app-font:  -apple-system,BlinkMacSystemFont,'Segoe UI','Helvetica Neue', Helvetica, FreeSans, Arimo, \"Droid Sans\", Arial, sans-serif;\n  --main-app-font-size: 14px;\n  --main-mono-space: ui-monospace,		     \n    \"Cascadia Mono\", \"Segoe UI Mono\",    \n    \"Roboto Mono\",\n    \"Ubuntu Mono\",\n    Menlo, Monaco, Consolas,\n    monospace;\n  --editor-bg-color: hsl(44deg 38% 89%);\n  --editor-text-color: #4d6268;\n  --editor-gutter-bg-color: hsl(44deg 25% 84%);\n  --editor-gutter-color: #333;\n  --editor-cursor-color: #000000;\n  --editor-selected-bg-color: rgb(255 60 0 / 35%);\n  --editor-selected-word-bg-color: #FFFFFF;\n  --editor-step-bg-color: rgb(255, 255, 0);\n  --editor-active-line-bg: hsl(44deg 38% 84%);\n  --editor-active-line-gutter-bg-color: rgb(166 166 166 / 46%);\n  --editor-invisible-color: rgba(147, 161, 161, 0.50);\n  --editor-keyword-color: #00770c;\n  --editor-identifier-color: #191919;\n  --editor-constant-color: #859900;\n  --editor-numeric-color: #D33682;\n  --editor-support-color: #104e8b;\n  --editor-function-color: #268BD2;\n  --editor-string-color: #2AA198;\n  --editor-constant-color: #CB4B16;\n  --editor-variable-color: #268BD2;\n  --editor-comment-color: #8d7070;\n  --editor-storage-color: #073642;\n  --editor-illegal-color: #FD1224;\n  --editor-illegal-bg-color: rgba(255, 6, 0, 0.15);\n  --editor-deprecated-color: #FD1732;\n  --editor-deprecated-bg-color: #EEEAE8;\n  --editor-regex-color: #D30102;\n  --editor-regex-bg-color: inherit;\n  --editor-heading-color: #B8012D;\n  --editor-heading-bg-color: rgba(191,97,51,0.051);\n  --editor-list-color: #8F5B26;\n}\n",cobalt:":root {\n    --main-bg-color: #001d36;\n    --main-color: #d0d0d0;\n    --highlight-bg-color: #ffffff59;\n    --highlight-color: #fff4e8;\n    --control-bg-color: #002240;\n    --control-color: #FFFFFF;\n    --control-text-input-color-bg: #FFFFFF50;\n    --control-focused: #efe5e540;\n    --control-unfocused-color: darkgray;\n    --control-disabled-bg-color: #eaeded;\n    --control-disabled-color: #cad2d3;\n    --control-readonly-color: #777;\n    --button-hover-bg-color: #00000030;\n    --app-header-color: #b7bbbf;\n    --namespace-color: #e9a5a5;\n    --main-accent-color: #ff927221;\n    --main-accent-line: #c77a0b20;\n    --main-accent-line-hover: #FFFFFF40;\n    --main-control-surface-accent-color: #efe5e51c;\n    --main-control-button-color: #FFFFFF40;\n    --scrollbar-thumb-color: #FFFFFF40;\n    --scrollbar-track-color: #00000010;\n    --link-color: orange;\n    --link-visited-color: #e9a5a5;\n    --link-bg-color: inherit;\n    --link-visited-bg-color: inherit;\n    --value-modified-color: #4ac0e0;\n    --matching-paren-color: #ffeb0042;\n    --matching-paren-outline-color: #b6a80052;;\n    --type-number-color: #ff618c;\n    --type-boolean-color: orange;\n    --type-string-color: #3bd901;\n    --type-function-color: #b1baff;\n    --type-asyncfunction-color: #b2b7ba;\n    --type-null-color: #a35e5e;\n    --type-undefined-color: #9d9d9d;\n    --type-key-color: #e456da;\n    --type-symbol-color: #ff4f4f;\n    --type-error-color: #f82e2e;\n    --type-array-color: #cac8e7;\n    --type-path-color: #b18bae;\n    --type-regexp-color: #fe2f81;\n    --type-code-color: #ffe2b7;\n    --value-focus-color: #0168ff;\n    --mode-color: #70baff;\n    --primary-action-bg-color: #0278e7;\n    --primary-action-color: #FFFFFF;\n    --main-app-font: -apple-system,BlinkMacSystemFont,'Segoe UI','Helvetica Neue', Helvetica, FreeSans, Arimo, \"Droid Sans\", Arial, sans-serif;\n    --main-app-font-size: 14px;\n    --main-mono-space: ui-monospace,\n  \"Cascadia Mono\", \"Segoe UI Mono\",    \n    \"Roboto Mono\",\n    \"Ubuntu Mono\",\n    Menlo, Monaco, Consolas,\n    monospace;\n    --editor-bg-color: #002240;\n    --editor-text-color: #FFFFFF;\n    --editor-gutter-bg-color: #e0e0e0;\n    --editor-gutter-color: #333;\n    --editor-cursor-color: #202020;\n    --editor-selected-bg-color: #4ab1ff3d;\n    --editor-selected-word-bg-color: #fff4a36e;\n    --editor-step-bg-color: rgb(198,219,174);\n    --editor-active-line-bg: rgb(255 255 255 / 53%);\n    --editor-active-line-gutter-bg-color: rgb(166 166 166 / 46%);\n    --editor-invisible-color: #BFBFBF;\n    --editor-keyword-color: #670171;\n    --editor-identifier-color: #191919;\n    --editor-constant-color: #CD6839;\n    --editor-numeric-color: #9A5925;\n    --editor-support-color: #104e8b;\n    --editor-function-color: #0274a1;\n    --editor-string-color: #006b1e;\n    --editor-constant-color: #CF6A4C;\n    --editor-variable-color: #009ACD;\n    --editor-comment-color: rgba(148,148,148, 0.91);\n    --editor-storage-color: #A52A2A;\n    --editor-illegal-color: #FD1224;\n    --editor-illegal-bg-color: rgba(255, 6, 0, 0.15);\n    --editor-deprecated-color: #FD1732;\n    --editor-deprecated-bg-color: #EEEAE8;\n    --editor-regex-color: #fe2f53;\n    --editor-regex-bg-color: #FE40AA10;\n    --editor-heading-color: #B8012D;\n    --editor-heading-bg-color: rgba(191,97,51,0.051);\n    --editor-list-color: #8F5B26;\n}\n",idle_fingers:":root {\n    --main-bg-color: #2d2d2d;\n    --main-color: #d0d0d0;\n    --highlight-bg-color: #ffffff59;\n    --highlight-color: #fff4e8;\n    --selected-bg-color: #0278e7;\n    --selected-color: #FFFFFF;\n    --control-bg-color: #323232;\n    --control-color: #f0f0f0;\n    --control-text-input-color-bg: #FFFFFF50;\n    --control-focused: #efe5e540;\n    --control-unfocused-color: darkgray;\n    --control-disabled-bg-color: #eaeded;\n    --control-disabled-color: #cad2d3;\n    --control-readonly-color: #777;\n    --button-hover-bg-color: #00000030;\n    --app-header-color: #b7bbbf;\n    --namespace-color: #e9a5a5;\n    --main-accent-color: #fffdfc21;\n    --main-accent-line: #c77a0b20;\n    --main-accent-line-hover: #FFFFFF40;\n    --main-control-surface-accent-color: #efe5e51c;\n    --main-control-button-color: #FFFFFF40;\n    --scrollbar-thumb-color: #FFFFFF40;\n    --scrollbar-track-color: #00000010;\n    --link-color: #68d9ff;\n    --link-visited-color: #e9a5a5;\n    --link-bg-color: inherit;\n    --link-visited-bg-color: inherit;\n    --value-modified-color: #4ac0e0;\n    --matching-paren-color: #ffeb0042;\n    --matching-paren-outline-color: #b6a800;\n    --type-number-color: #ff618c;\n    --type-boolean-color: orange;\n    --type-string-color: #a6c260;\n    --type-function-color: #b1baff;\n    --type-key-color: #e456da;\n    --type-asyncfunction-color: #b2b7ba;\n    --type-null-color: #a35e5e;\n    --type-undefined-color: #9d9d9d;\n    --type-symbol-color: #ff4f4f;\n    --type-error-color: #f82e2e;\n    --type-array-color: #cac8e7;\n    --type-path-color: #b18bae;\n    --type-regexp-color: #fe2f81;\n    --type-code-color: #ffe2b7;\n    --value-focus-color: #0168ff;\n    --mode-color: #a9d5ff;\n    --primary-action-bg-color: #0278e7;\n    --primary-action-color: #FFFFFF;\n    --main-app-font: -apple-system,BlinkMacSystemFont,'Segoe UI','Helvetica Neue', Helvetica, FreeSans, Arimo, \"Droid Sans\", Arial, sans-serif;\n    --main-app-font-size: 14px;\n    --main-mono-space: ui-monospace,\n  \"Cascadia Mono\", \"Segoe UI Mono\",    \n    \"Roboto Mono\",\n    \"Ubuntu Mono\",\n    Menlo, Monaco, Consolas,\n    monospace;\n    --editor-bg-color: #323232;\n    --editor-text-color: #FFFFFF;\n    --editor-gutter-bg-color: #e0e0e0;\n    --editor-gutter-color: #333;\n    --editor-cursor-color: #202020;\n    --editor-selected-bg-color: #ffd39985;\n    --editor-selected-word-bg-color: #fff05c40;\n    --editor-step-bg-color: rgb(198,219,174);\n    --editor-active-line-bg: rgb(255 255 255 / 53%);\n    --editor-active-line-gutter-bg-color: rgb(166 166 166 / 46%);\n    --editor-invisible-color: #BFBFBF;\n    --editor-keyword-color: #670171;\n    --editor-identifier-color: #191919;\n    --editor-constant-color: #CD6839;\n    --editor-numeric-color: #9A5925;\n    --editor-support-color: #104e8b;\n    --editor-function-color: #0274a1;\n    --editor-string-color: #006b1e;\n    --editor-constant-color: #CF6A4C;\n    --editor-variable-color: #009ACD;\n    --editor-comment-color: rgba(148,148,148, 0.91);\n    --editor-storage-color: #A52A2A;\n    --editor-illegal-color: #FD1224;\n    --editor-illegal-bg-color: rgba(255, 6, 0, 0.15);\n    --editor-deprecated-color: #FD1732;\n    --editor-deprecated-bg-color: #EEEAE8;\n    --editor-regex-color: #fe2f53;\n    --editor-regex-bg-color: #FE40AA10;\n    --editor-heading-color: #B8012D;\n    --editor-heading-bg-color: rgba(191,97,51,0.051);\n    --editor-list-color: #8F5B26;\n}\n"};__obj__1["browser_initializer"]=await (async function(){ return "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" })();__obj__1["browser_repl_package"]=await (async function(){ return ";; Browser Based Workspace\n;; Sets up the basic environment in Browser \n;; Initialize a simple REPL from which to start working\n\n\n\n(declare (namespace core))\n(console.log \"browser_workspace: running\")\n\n(defparameter core/is_served? (and (not (blank? (resolve_path [ `location `hostname ] window)))\n                                   (== (prop (fetch \"/files\") `status) 200)))\n(console.log \"browser_workspace: online? is_served: \" is_served?)\n\n;; not needed in the client\n(delete_namespace `sys)\n\n(defun core/*initializer* ()\n  (let\n      ((scripts (-> (page_header) `querySelectorAll \"script[id]\")))\n    (console.log \"core/*initializer* running: \" *namespace*)\n    (if (> scripts.length 0)\n      (map (fn (idx)\n             (when (not (== (-> (prop scripts idx) `getAttribute `id) \"juno-core\"))\n               (eval `(defglobal ,#(+ \"$\" (-> (prop scripts idx) `getAttribute `id)) ,#(prop scripts idx)))))\n           (range scripts.length)))))\n\n\n(defun $set_global_theme (theme_name options)\n   (if (prop *global_themes* theme_name)\n       (let\n          ((head_elem (-> document `querySelector \"head\"))\n           (existing (html/get_by_id \"juno-css-theme\")))\n          (if existing\n               (-> existing `remove))\n          (-> head_elem `append\n              (html/style { `id: \"juno-css-theme\" `type: \"text/css\" }\n               (prop *global_themes* theme_name)) )          \n          true)\n       (throw ReferenceError \"Invalid theme name provided\")))\n\n(defun browser_repl ()\n  (let\n      ((body_element (-> document `querySelector \"body\"))\n       (output_container (html/div { `id: \"output-container\"  } ))\n       (resize_observer nil)                                                      \n                                        ;(result nil)\n       (current_env Environment)\n       (error_state nil)\n       (initialized false)\n       (evaluator (fn (lisp_text no_eval options)\n                    (let\n                        ((result nil))\n                      (setq error_state nil)\n                      (setq current_env (-> Environment `get_namespace_handle (current_namespace)))\n                      (log \"evaluator: options: \" options)\n                      (try\n                        (= result (if no_eval\n                                    lisp_text\n                                    (-> current_env `evaluate lisp_text nil options)))\n                        (catch Error (ex)\n                          (do\n                            (= error_state true)\n                            (console.error ex)\n                            (= result ex))))\n                      (console.log \"<-\" result)\n                      (when (not no_eval)                        \n                        (-> output_container\n                            `append\n                            (html/div { style:\"border-top: 1px solid #C0C0C0; padding: 5px; margin-top: 1px; width: calc(100% - 10px); display: inline-block; \" }\n                                      (html/code { `style: \"font-style: italic;\" }\n                                                 lisp_text))))\n                      (-> output_container\n                          `append\n                          (html/div { `style: \"padding: 5px; margin-top: 0px; width: calc(100% - 10px); display: inline-block; \" }\n                                    (cond\n                                      (is_element? result)\n                                      result\n                                      (is_number? result)\n                                      (html/code { `style: \" color: green;\" }\n                                                 result)\n                                      (or (== true result)\n                                          (== false result))\n                                      (html/code { `style: \" color: orange;\" }\n                                                 result)\n                                      (is_function? result)\n                                      (html/code { `style: \" color: var(--type-function-color);\" } \"Function: \"\n                                                 (if result.name result.name \"anonymous\"))\n                                      (and (is_array? result)\n                                           (instanceof result.0 Error))\n                                      (html/pre { `style: \" color: var(--type-array-color);\" } \"ERROR: \"\n                                                (subtype result.0)\n                                                \"\\n\"\n                                                result.0.message)\n                                      (or error_state\n                                          (instanceof result Error))\n                                      (html/pre { `style: \" color: var(--type-error-color);\" } \"ERROR: \"\n                                                (subtype result)\n                                                \"\\n\"\n                                                result.message)\n                                      (and (is_array? result)\n                                           result.0.error)\n                                      (html/pre { `style: \" color: var(--type-error-color);\" }                                                 \n                                                (JSON.stringify result nil 3 ))\n                                      else\n                                      (html/pre { `style: \"\" } (JSON.stringify result nil 3 )))))\n                      (set_prop output_container\n                                `scrollTop\n                                output_container.offsetHeight)\n                      result)))\n       \n       (input_container (html/div {  `style: \"height: calc(20% - 15px); overflow: hidden; \" }\n                                  \"\"))\n       (juno_container (html/div { `id: \"discard_container\" `style: \"height: inherit; max-height: 100%; overflow: scroll;\" }\n                                 output_container\n                                 input_container))\n       (perform_resize (fn ()\n                         (progn\n                          ;(console.log \"repl: resize: \" (prop juno_container.parentElement `offsetWidth))\n                          (html/set_style [[\"width\" (+ \"\" (- (prop juno_container.parentElement `offsetWidth) 2) \"px\")]] \n                                          juno_container)\n                          )))\n       (initialize (fn ()\n                     (progn\n                      (if initialized\n                        (evaluator (html/div { `style: \"display: flex padding: 5px\" } \"WARNING: REPL already initialized\") true)\n                        (progn\n                         (= initialized true)\n                         (= resize_observer (new ResizeObserver perform_resize))\n                         (-> resize_observer `observe juno_container.parentElement)\n                         (evaluator (html/div { `style: \"display: flex padding: 5px\" }                \n                                              (html/span { `style: \"font-weight: bold; display: inline-block;\" } \"Juno Environment Builder\")\n                                              (html/span { `style: \"display: inline-block; margin-left: 10px;\" }\n                                                         \"Environment Version: \" Environment.build_version   )) true)                         \n                         (evaluator (html/div \"Namespace: \" (current_namespace)) true)))))))\n    {\n     `view: juno_container\n     `input_container: input_container\n     `initialize: initialize\n     `output_container: output_container\n     `log: (fn (val)\n             (evaluator val true))\n     `evaluate: (fn (lisp_text options)\n                  (evaluator lisp_text nil options))\n     }))\n     \n;; easy page header access\n\n(defun core/page_header ()\n  (first (html/query_all \"head\")))\n\n\n\n(defglobal core/*env_skeleton* (reader (LZString.decompressFromBase64 (clone *env_template*))))\n\n(defun core/read_text_file (file)\n  (console.log \"reading text file stub called\"))\n\n(defun core/save_image (options)\n   (let\n       ((js_resource (save_env { `want_buffer: true\n                                `do_not_include: (conj  [ `browser_repl `line_reader  ] (if (is_array? options.do_not_include) options.do_not_include []) )}))\n        (scripts (-> (page_header) `querySelectorAll \"script[id]\"))\n        (styles (-> (page_header) `querySelectorAll \"style[id]\"))\n        (do_not_include_scripts (if (is_array? options.do_not_include_scripts)\n                                    options.do_not_include_scripts\n                                    []))\n        (do_not_include_styles (if (is_array? options.do_not_include_styles)\n                                    options.do_not_include_styles\n                                    []))\n        (log (if (is_function? options.log)\n               options.log\n               console.log))\n        (save_method nil)\n        (additional_embeds (let\n                               ((acc [])\n                                (deduper (new Set)))\n                             (map (fn (idx)\n                                     (let\n                                        ((script_id (-> (prop scripts idx) `getAttribute `id)))\n                                        (when (and (not (== (-> (prop scripts idx) `getAttribute `id) \"juno-core\"))\n                                                   (not (-> deduper `has (-> (prop scripts idx) `getAttribute `id)))\n                                                   (not (contains? script_id do_not_include_scripts)))\n                                           (-> deduper `add (-> (prop scripts idx) `getAttribute `id))\n                                           (push acc (prop scripts idx)))))\n                                  (range scripts.length))\n                             acc))\n        (additional_styles (let\n                               ((acc [])\n                                (deduper (new Set)))\n                             (map (fn (idx)\n                                     (let\n                                        ((style_id (-> (prop styles idx) `getAttribute `id)))\n                                        (when (and (not (== style_id \"juno-css\"))\n                                                   (not (-> deduper `has style_id))\n                                                   (not (contains? style_id do_not_include_styles)))\n                                           (-> deduper `add style_id)\n                                           (push acc (prop styles idx)))))\n                                     (range styles.length))\n                             acc))\n        (total_export_script_count (+ (length additional_embeds) 1)) ;; add one for juno-core\n        (script_ids (for_each (embedded additional_embeds)\n                        (-> embedded `getAttribute `id)))\n        (dcomps (date_components (new Date)))\n        (file_version_tag (if (not (blank? options.version_tag))\n                              options.version_tag\n                              (join \".\" [ dcomps.year dcomps.month dcomps.day dcomps.hour dcomps.minute ])))\n        (scaffold_1 (prop\n                     (html/head { `title: \"Seedling\" }\n                                (html/meta { `charset: \"utf-8\" })\n                                (html/style { `id: \"juno-css\" } \"\")\n                                (html/script { `id: \"juno-core\" `type: \"module\" }\n                                             js_resource\n                                             \"\\n\\n\"                               \n                                             ;; boot_up\n                                             \"\\n\\n\")\n                                (for_each (stl (or additional_styles []))\n                                          (html/style { `id: (-> stl `getAttribute `id) } \n                                                      (prop stl `innerHTML)))\n                                                                           \n                                (for_each (scr (or additional_embeds []))\n                                          (html/script { `id: (-> scr `getAttribute `id) `type: (-> scr `getAttribute `type) `charset: (-> scr `getAttribute `charset) }\n                                                       (prop scr `innerHTML))))\n                                     ;scr))\n                                        \n                          `outerHTML))\n        (scaffold_2 (prop\n                          \n                          (html/body { style: (+ \"\" (if options.no_header \n                                                        \"height: 100vh; \"\n                                                        \"height: 98vh; \")\n                                                 \" overflow: hidden;\")\n                                             `id: \"body\" }\n                                     (if options.no_header\n                                        (html/header {  `id: \"page-header\" })\n                                        (html/header {  `id: \"page-header\" class: \"juno-page-header\" } ))\n                                     (html/div { `id: \"lower_right_corner\" style: \"position: absolute; right: 50px; bottom: 5px; width: 255px;\" } )\n                                     )\n                          `outerHTML)))\n\n     (declare (function http/send_files http/data_to_file)\n              (global http/send_files http/data_to_file))\n     \n     (log \"save_image exporting: \" script_ids)\n     (log \"namespaces: \" (namespaces) (sort (http/symbols)))\n     ;(try\n      ; (log \"http: \" http/send_files)\n       ;(catch Error (e)\n        ; (console.error \"Issue on accessing http: \" e)))\n     \n     (if (and is_served? \n              (not options.save_locally)\n              (contains? \"http_client\" *env_config*.features))\n       (progn\n        (console.log \"we are online and we have http client software\")\n        (= save_method (fn (fname content content_type)\n                             (http/send_files \"/save_file\" (http/data_to_file (+ \"environments/\" (or options.save_as (prop *env_config*.export `save_prefix) \"a1\") \".html\") content content_type)))))\n       (= save_method save_locally))\n     (new Promise (fn (resolve reject)\n                    (setTimeout (fn ()\n                                  (try\n                                    (resolve (save_method (or options.save_as                                       \n                                                          (+ (or (prop *env_config*.export `save_prefix) \"juno_image\")\n                                                             \"-\" file_version_tag \".html\"))\n                                                      (+ \"<!DOCTYPE html>\\n<html>\\n\"\n                                                         scaffold_1\n                                                         scaffold_2\n                                                         \"</html>\")\n                                                      \"text/html\" ))\n                                    (catch Error (e)\n                                      (reject e))))\n                                100)))))\n     \n\n(defun core/*system_initializer* ()\n  (let\n      ((pkg (-> Environment `evaluate \"core/html_package\")))\n    (console.log \"system initializer: initializing packaged html_package\")\n    (-> Environment `evaluate pkg nil { `source_name: \"pkg/html.juno\" })\n\n    ;(eval (reader (clone browser_repl_package)))\n    (undefine `browser_repl_package)\n    (undefine `rlog)\n    (set_prop globalThis `env Environment) ;; establish a global handle (not necessary but handy for development)\n    (console.log \"system initializer Complete\")))\n\n(defglobal `repl (core/browser_repl))\n(defun rlog (val)\n  (progn\n   (console.log \"rlog:\" val)\n   (-> repl `log val)))\n\n(-> (-> document `querySelector \"body\")\n    `appendChild (prop repl\n                       `view))\n\n(defglobal $current_theme (-> (prop (new URL window.location) `searchParams) `get \"theme\"))\n(console.log \"$current_theme: \" $current_theme)\n\n(when (not (blank? $current_theme))\n  ($set_global_theme $current_theme))\n\n(setTimeout (fn ()\n              (rlog (if (prop globalThis `in_starter)\n                      (progn\n                       (-> repl `initialize)\n                       (html/div \"In starter mode..building new image..\"))\n                      (html/div \"Ready\"))))\n            10)\n      \n\n\n\n(setTimeout (fn ()\n              (progn\n               (when (prop globalThis `in_starter)\n                 (rlog (html/div \"Bootstrapping new image..\"))                 \n                 (-> repl `evaluate |\n                     (use_unique_symbols \"html\")\n                     (evaluate (LZString.decompressFromBase64 browser_initializer) nil { `source_name: \"pkg/browser_initializer.juno\" })\n                     | { `source_name: \"pkg/browser_initializer.juno\" })\n                 (undefine `browser_initializer) ;; no longer needed in text form, remove to save space\n                 (-> repl `evaluate | (save_image) | )\n                 (rlog (html/div \"Complete..Open the newly created html file to use.\")))))\n            100)\n            \n\n\n                                    \n                                    \n           \n                                    \n" })();__obj__1["load"]=async function(filename) {
        let fname;
        let js_mod;
        let comps;
        fname=filename;
        js_mod=null;
        comps=await (await Environment.get_global("path.parse"))(fname);
        return await async function(){
            if (check_true (((comps && comps["ext"])===".lisp"))) {
                return await (await Environment.get_global("evaluate"))(await (async function(){
                     return await (await Environment.get_global("read_text_file"))(fname) 
                })(),null,{
                    source_name:fname
                })
            } else if (check_true (((comps && comps["ext"])===".js"))) {
                {
                    js_mod=await import (fname);
                    if (check_true ((js_mod && js_mod["initializer"]))){
                        return await (async function(){
                            let __array_op_rval__2=(js_mod && js_mod["initializer"]);
                             if (__array_op_rval__2 instanceof Function){
                                return await __array_op_rval__2(Environment) 
                            } else {
                                return [__array_op_rval__2,Environment]
                            }
                        })()
                    } else {
                        throw new EvalError("load: unable to find function named initializer in export, use dynamic_import for this.");
                        
                    }
                }
            } else if (check_true (((comps && comps["ext"])===".json"))) {
                return await (await Environment.get_global("evaluate"))(await JSON.parse(await (async function(){
                     return await (await Environment.get_global("read_text_file"))(fname) 
                })()),null,{
                    json_in:true,source_name:fname
                })
            }
        } ()
    };__obj__1["with_fs_events"]=async function(...args) {
    let event_binding;
    let location;
    let body;
    event_binding=(args && args["0"] && args["0"]["0"]);
    location=(args && args["0"] && args["0"]["1"]);
    body=(args && args["1"]);
    return ["=:let",[["=:watcher",["=:->","=:Deno","watchFs",location]]],["=:declare",["=:object","=:watcher"]],["=:for_with",[event_binding,"=:watcher"],["=:progn",body]]]
};__obj__1["compile_buffer"]=async function(input_buffer,export_function_name,options) {
    let output_filename;
    let opts;
    let segments;
    let export_segment;
    let include_boilerplate;
    let start_time;
    let compile_time;
    let write_file;
    let import_headers;
    let include_source;
    let compiled;
    let invalid_js_ref_chars;
    let invalid_js_ref_chars_regex;
    let boilerplate;
    let compiled_js;
    output_filename=(options && options["output_file"]);
    opts=await (await Environment.get_global("add"))(new Object(),(options|| new Object()),{
        want_buffer:await (async function(){
            if (check_true (((options && options["want_buffer"])|| (null==output_filename)))){
                return true
            } else {
                return false
            }
        })()
    });
    export_function_name=(export_function_name|| "initializer");
    segments=[];
    export_segment=[];
    include_boilerplate=await (async function(){
        if (check_true ((false===(opts && opts["include_boilerplate"])))){
            return false
        } else {
            return true
        }
    })();
    start_time=await Date.now();
    compile_time=null;
    write_file=true;
    import_headers=await (async function(){
        if (check_true (((options && options["imports"]) instanceof Object))){
            return await (await Environment.get_global("map"))(async function(import_set,idx) {
                let target;
                let imp_details;
                target=(import_set && import_set["1"] && import_set["1"]["symbol"]);
                imp_details=(import_set && import_set["1"] && import_set["1"]["location"]);
                return await (async function(){
                    let __array_op_rval__1=("import * as "+ (target+ "_module")+ " from '"+ imp_details+ "'\n"+ "export const "+ target+ "="+ (target+ "_module")+ ";");
                     if (__array_op_rval__1 instanceof Function){
                        return await __array_op_rval__1() 
                    } else {
                        return [__array_op_rval__1]
                    }
                })()
            },await (await Environment.get_global("pairs"))((options && options["imports"])))
        } else {
            return []
        }
    })();
    include_source=await (async function(){
        if (check_true ((opts && opts["include_source"]))){
            return true
        } else {
            return false
        }
    })();
    compiled=null;
    invalid_js_ref_chars="+?-%&^#!*[]~{}|";
    invalid_js_ref_chars_regex=new RegExp("[\%\+\[\>\?\<\\}\{&\#\^\=\~\*\!\)\(\-]+");
    boilerplate="const { get_next_environment_id, check_true, get_outside_global, subtype, lisp_writer, clone, LispSyntaxError } = await import(\"./lisp_writer.js\");";
    compiled_js=null;
    if (check_true ((await (await Environment.get_global("length"))(await (await Environment.get_global("scan_str"))(invalid_js_ref_chars_regex,export_function_name))>0))){
        {
            throw new SyntaxError(("export function name contains an invalid JS character: "+ export_function_name+ ", cannot contain: "+ invalid_js_ref_chars));
            
        }
    };
    (segments).push(("// Source: "+ (options && options["input_filename"])+ "  "));
    if (check_true (((import_headers && import_headers.length)>0))){
        {
            await (async function() {
                let __for_body__4=async function(static_import) {
                    return (segments).push(static_import)
                };
                let __array__5=[],__elements__3=import_headers;
                let __BREAK__FLAG__=false;
                for(let __iter__2 in __elements__3) {
                    __array__5.push(await __for_body__4(__elements__3[__iter__2]));
                    if(__BREAK__FLAG__) {
                         __array__5.pop();
                        break;
                        
                    }
                }return __array__5;
                 
            })();
            (segments).push("\n")
        }
    };
    if (check_true (((opts && opts["build_headers"]) instanceof Array))){
        {
            await (async function() {
                let __for_body__8=async function(header) {
                    return (segments).push(header)
                };
                let __array__9=[],__elements__7=(opts && opts["build_headers"]);
                let __BREAK__FLAG__=false;
                for(let __iter__6 in __elements__7) {
                    __array__9.push(await __for_body__8(__elements__7[__iter__6]));
                    if(__BREAK__FLAG__) {
                         __array__9.pop();
                        break;
                        
                    }
                }return __array__9;
                 
            })();
            (segments).push("\n")
        }
    };
    (segments).push("\n");
    if (check_true (include_boilerplate)){
        (segments).push(boilerplate)
    };
    if (check_true (((opts && opts["js_headers"]) instanceof Array))){
        {
            await (async function() {
                let __for_body__12=async function(header) {
                    return (segments).push(header)
                };
                let __array__13=[],__elements__11=(opts && opts["js_headers"]);
                let __BREAK__FLAG__=false;
                for(let __iter__10 in __elements__11) {
                    __array__13.push(await __for_body__12(__elements__11[__iter__10]));
                    if(__BREAK__FLAG__) {
                         __array__13.pop();
                        break;
                        
                    }
                }return __array__13;
                 
            })();
            (segments).push("\n")
        }
    };
    if (check_true (((export_function_name==="init_dlisp")|| (opts && opts["toplevel"])))){
        {
            (segments).push("if (typeof AsyncFunction === \"undefined\") {\n  globalThis.AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n}")
        }
    };
    if (check_true (((input_buffer instanceof Array)&& ((input_buffer && input_buffer["0"])==="=:iprogn")))){
        await async function(){
            input_buffer[0]=await (async function(){
                 return "=:progn" 
            })();
            return input_buffer;
            
        }()
    };
    if (check_true ((opts && opts["verbose"]))){
        {
            await console.log("input_buffer: ",input_buffer)
        }
    };
    compiled=await (async function(){
         return await (await Environment.get_global("compiler"))(input_buffer,await (await Environment.get_global("add"))({
            env:Environment,formatted_output:true,include_source:include_source,source_name:((opts && opts["input_filename"])|| "anonymous")
        },opts)) 
    })();
    compile_time=await (await Environment.get_global("add"))(await (async function() {
        {
             let __call_target__=((await Date.now()- start_time)/ 1000), __call_method__="toFixed";
            return await __call_target__[__call_method__].call(__call_target__,3)
        } 
    })(),"s");
    await async function(){
        if (check_true ((compiled && compiled["error"]))) {
            throw new Error((await Environment.get_global("indirect_new"))(compiled.error,(compiled && compiled["message"])));
            
        } else if (check_true (((compiled && compiled["0"] && compiled["0"]["ctype"])&& ((compiled && compiled["0"] && compiled["0"]["ctype"])==="FAIL")))) {
            {
                write_file=false;
                await (await Environment.get_global("warn"))((compiled && compiled["1"]))
            }
        } else if (check_true (((compiled && compiled["0"] && compiled["0"]["ctype"])&& (await (await Environment.get_global("contains?"))("block",(compiled && compiled["0"] && compiled["0"]["ctype"]))|| ((compiled && compiled["0"] && compiled["0"]["ctype"])==="assignment")|| ((compiled && compiled["0"] && compiled["0"]["ctype"])==="__!NOT_FOUND!__"))))) {
            if (check_true (await (async function(){
                let __array_op_rval__15=(compiled && compiled["0"] && compiled["0"]["has_lisp_globals"]);
                 if (__array_op_rval__15 instanceof Function){
                    return await __array_op_rval__15() 
                } else {
                    return [__array_op_rval__15]
                }
            })())){
                {
                    (segments).push(("export async function "+ export_function_name+ "(Environment)  {"));
                    (segments).push((compiled && compiled["1"]));
                    (segments).push("}")
                }
            } else {
                {
                    (segments).push(("export async function "+ export_function_name+ "() {"));
                    (segments).push((compiled && compiled["1"]));
                    (segments).push("}")
                }
            }
        } else if (check_true (((compiled && compiled["0"] && compiled["0"]["ctype"])&& (("AsyncFunction"===(compiled && compiled["0"] && compiled["0"]["ctype"]))|| ("statement"===(compiled && compiled["0"] && compiled["0"]["ctype"]))|| ("objliteral"===(compiled && compiled["0"] && compiled["0"]["ctype"])))))) {
            {
                if (check_true (await (async function(){
                    let __array_op_rval__16=(compiled && compiled["0"] && compiled["0"]["has_lisp_globals"]);
                     if (__array_op_rval__16 instanceof Function){
                        return await __array_op_rval__16() 
                    } else {
                        return [__array_op_rval__16]
                    }
                })())){
                    {
                        (segments).push(("export async function "+ export_function_name+ "(Environment) {"));
                        (segments).push(("  return "+ (compiled && compiled["1"])+ "} "))
                    }
                } else {
                    {
                        (segments).push(("export async function "+ export_function_name+ "() {"));
                        (segments).push(("  return "+ (compiled && compiled["1"])+ "} "))
                    }
                }
            }
        } else if (check_true (((compiled && compiled["0"] && compiled["0"]["ctype"])&& ("Function"===(compiled && compiled["0"] && compiled["0"]["ctype"]))))) {
            {
                if (check_true (await (async function(){
                    let __array_op_rval__17=(compiled && compiled["0"] && compiled["0"]["has_lisp_globals"]);
                     if (__array_op_rval__17 instanceof Function){
                        return await __array_op_rval__17() 
                    } else {
                        return [__array_op_rval__17]
                    }
                })())){
                    {
                        (segments).push(("export function "+ export_function_name+ "(Environment) {"));
                        (segments).push(("  return "+ (compiled && compiled["1"])+ "}"))
                    }
                } else {
                    {
                        (segments).push(("export function "+ export_function_name+ "() {"));
                        (segments).push(("  return "+ (compiled && compiled["1"])+ " } "))
                    }
                }
            }
        } else {
            {
                await console.log("warning: unhandled return: ",compiled);
                write_file=false
            }
        }
    } ();
    if (check_true ((opts && opts["bundle"]))){
        {
            (segments).push(("await init_dlisp();"));
            (segments).push(("let env = await dlisp_env("+ await (async function(){
                if (check_true ((opts && opts["bundle_options"]))){
                    return await JSON.stringify((opts && opts["bundle_options"]))
                } else {
                    return ""
                }
            })()+ ");"))
        }
    };
    if (check_true (((opts && opts["exports"]) instanceof Array))){
        {
            (export_segment).push("export { ");
            await (await Environment.get_global("map"))(async function(exp,i,len) {
                await async function(){
                    if (check_true (((exp instanceof Array)&& ((exp && exp.length)===2)))) {
                        {
                            (export_segment).push((exp && exp["0"]));
                            (export_segment).push(" as ");
                            return (export_segment).push((exp && exp["1"]))
                        }
                    } else if (check_true ((exp instanceof String || typeof exp==='string'))) {
                        (export_segment).push(exp)
                    } else {
                        throw new SyntaxError(("Invalid export format: "+ exp));
                        
                    }
                } ();
                if (check_true ((i<(len- 1)))){
                    {
                        return (export_segment).push(",")
                    }
                }
            },(opts && opts["exports"]));
            (segments).push((export_segment).join(""))
        }
    };
    return await async function(){
        if (check_true ((write_file&& await (await Environment.get_global("not"))((opts && opts["want_buffer"]))))) {
            {
                await (await Environment.get_global("write_text_file"))(output_filename,(segments).join("\n"));
                await (await Environment.get_global("success"))(("["+ compile_time+ "] compiled: "),((opts && opts["input_filename"])|| (opts && opts["namespace"])|| "anonymous"),"->",output_filename);
                return output_filename
            }
        } else if (check_true ((write_file&& (opts && opts["want_buffer"])))) {
            return (segments).join("\n")
        } else {
            {
                await (await Environment.get_global("warn"))("cannot compile: ",((opts && opts["input_filename"])|| (opts && opts["namespace"])|| "anonymous"));
                return null
            }
        }
    } ()
};__obj__1["compile_file"]=async function(lisp_file,export_function_name,options) {
    let input_components;
    let input_filename;
    let input_buffer;
    input_components=await (await Environment.get_global("path.parse"))(lisp_file);
    input_filename=await (await Environment.get_global("path.basename"))(lisp_file);
    input_buffer=null;
    input_buffer=await (async function(){
         return await (await Environment.get_global("read_text_file"))(lisp_file) 
    })();
    if (check_true (((input_components && input_components["ext"])===".lisp"))){
        input_buffer=await (async function(){
             return await (await Environment.get_global("read_lisp"))(input_buffer,{
                implicit_progn:false,source_name:input_filename
            }) 
        })()
    };
    return await (await Environment.get_global("compile_buffer"))(input_buffer,export_function_name,await (await Environment.get_global("add"))(new Object(),{
        input_filename:input_filename,source_name:input_filename
    },await (async function(){
        if (check_true (options)){
            return options
        } else {
            return new Object()
        }
    })()))
};__obj__1["rebuild_env"]=async function(opts) {
    let issues;
    let source_dir;
    let output_dir;
    let dcomps;
    let version_tag;
    let build_time;
    let build_headers;
    let include_source;
    let source_path;
    let output_path;
    issues=[];
    source_dir=((opts && opts["source_dir"])|| "./src");
    output_dir=((opts && opts["output_dir"])|| "./js");
    dcomps=await (async function(){
         return await (await Environment.get_global("date_components"))(new Date()) 
    })();
    version_tag=await (async function(){
        if (check_true (await (await Environment.get_global("not"))(await (await Environment.get_global("blank?"))((opts && opts["version_tag"]))))){
            return (opts && opts["version_tag"])
        } else {
            return (await (async function(){
                let __array_op_rval__18=(dcomps && dcomps["year"]);
                 if (__array_op_rval__18 instanceof Function){
                    return await __array_op_rval__18((dcomps && dcomps["month"]),(dcomps && dcomps["day"]),(dcomps && dcomps["hour"]),(dcomps && dcomps["minute"])) 
                } else {
                    return [__array_op_rval__18,(dcomps && dcomps["month"]),(dcomps && dcomps["day"]),(dcomps && dcomps["hour"]),(dcomps && dcomps["minute"])]
                }
            })()).join(".")
        }
    })();
    build_time=await (async function(){
         return await (await Environment.get_global("formatted_date"))(new Date()) 
    })();
    build_headers=[];
    include_source=((opts && opts["include_source"])|| false);
    source_path=async function(filename) {
        return (await (async function(){
            let __array_op_rval__19=source_dir;
             if (__array_op_rval__19 instanceof Function){
                return await __array_op_rval__19(filename) 
            } else {
                return [__array_op_rval__19,filename]
            }
        })()).join((await Environment.get_global("path.sep")))
    };
    output_path=async function(filename) {
        return (await (async function(){
            let __array_op_rval__20=output_dir;
             if (__array_op_rval__20 instanceof Function){
                return await __array_op_rval__20(filename) 
            } else {
                return [__array_op_rval__20,filename]
            }
        })()).join((await Environment.get_global("path.sep")))
    };
    await console.log("Environment Build Time: ",build_time,"In Namespace: ",(await Environment.get_global("*namespace*")));
    await console.log("Version Tag: ",version_tag);
    await console.log("Source Directory: ",source_dir);
    await console.log("Output Directory: ",output_dir);
    (build_headers).push(("// Build Time: "+ build_time));
    (build_headers).push(("// Version: "+ version_tag));
    (build_headers).push(("export const DLISP_ENV_VERSION='"+ version_tag+ "';"));
    await Environment.set_global("reader",await (async function(){
         return await (await Environment.get_global("load"))(await source_path("reader.lisp")) 
    })(),{
        requires:["load"],externals:["Date","RegExp","SyntaxError","console","JSON"],source_name:"src/build-tools.lisp"
    });
    await (await Environment.get_global("success"))("reloaded reader");
    await (await Environment.get_global("compile_file"))(await source_path("compiler.lisp"),"init_compiler",{
        output_file:await output_path("compiler.js"),include_source:include_source,build_headers:build_headers
    });
    await (await Environment.get_global("compile_file"))(await source_path("reader.lisp"),null,{
        output_file:await output_path("reader.js"),include_source:include_source,build_headers:build_headers
    });
    await (await Environment.get_global("compile_file"))(await source_path("environment.lisp"),"init_dlisp",{
        output_file:await output_path("environment.js"),include_source:include_source,toplevel:true,build_headers:build_headers
    });
    await (await Environment.get_global("compile_file"))(await source_path("core.lisp"),"environment_boot",{
        output_file:await output_path("core.js"),include_source:include_source,build_headers:build_headers
    });
    await (await Environment.get_global("compile_file"))(await source_path("core-ext.lisp"),"load_core",{
        output_file:await output_path("core-ext.js"),include_source:include_source,build_headers:build_headers
    });
    await (await Environment.get_global("compile_file"))(await source_path("base-io.lisp"),null,{
        output_file:await output_path("base-io.js"),include_source:include_source,build_headers:build_headers
    });
    await (await Environment.get_global("success"))("complete");
    return true
};__obj__1["*system_initializer*"]=async function() {
    let pkg;
    pkg=await Environment["evaluate"].call(Environment,"core/html_package");
    await console.log("system initializer: namespaces:",await (await Environment.get_global("namespaces"))());
    await console.log("system initializer: ",(await Environment.get_global("*namespace*")),"initializing packaged html_package");
    await Environment["evaluate"].call(Environment,pkg);
    await console.log("initializing browser_repl_package");
    (await Environment.eval(await async function(){
        return await (await Environment.get_global("reader"))(await (async function(){
             return await clone((await Environment.get_global("browser_repl_package"))) 
        })())
    }(),null));
    await async function(){
        globalThis["env"]=Environment;
        return globalThis;
        
    }();
    return await console.log("system initializer Complete")
};__obj__1["*env_template*"]="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";__obj__1["included_libs"]=["lz-string.js"];__obj__1["included_editor_assets_old"]=["ext-searchbox.js","ext-split.js","ext-language_tools.js","mode-juno.js","mode-json.js","mode-javascript.js","mode-css.js","mode-sh.js","mode-plain_text.js","theme-juno_light.js","theme-earth_tones.js","theme-chrome.js","theme-crimson_editor.js","theme-cobalt.js","theme-idle_fingers.js","theme-gruvbox.js","theme-dracula.js","theme-katzenmilch.js","theme-solarized_dark.js","theme-solarized_light.js"];__obj__1["included_editor_assets"]=["ext-language_tools.js","ext-searchbox.js","ext-split.js","mode-css.js","mode-javascript.js","mode-json.js","mode-juno.js","mode-markdown.js","mode-plain_text.js","mode-sh.js","theme-chrome.js","theme-cobalt.js","theme-crimson_editor.js","theme-dracula.js","theme-earth_tones.js","theme-gruvbox.js","theme-idle_fingers.js","theme-juno_light.js","theme-katzenmilch.js","theme-kuroir.js","theme-solarized_dark.js","theme-solarized_light.js"];return __obj__1;})(),children_declarations:async function() {
    return {
        user:{
            serialize_with_image:true
        },sys:{
            serialize_with_image:true
        },http:{
            serialize_with_image:true
        },html:{
            serialize_with_image:false
        }
    }
},child_load_order:["EXTERNAL","user","sys","http","html"],children:{
    user:await (async function(){
         return [{"meta_for_symbol":{"core_lang":true,"description":"Given a quoted symbol and a boolean indicating whether or not all namespaces should be searched, returns the meta data associated with the symbol for each environment.  If search mode is requested, the value returned is an array, since there can be symbols with the same name in different environments. If no values are found an empty array is returned.  If not in search mode, meta_for_symbol searches the current namespace only, and if a matching symbol is found, returns an object with all found metadata, otherwise nil is returned.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["describe","meta","help","definition","symbol","metadata"]},"describe":{"core_lang":true,"description":"Given a quoted symbol returns the relevant metadata pertinent to the current namespace context.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["meta","help","definition","symbol","metadata","info","meta_for_symbol"]},"undefine":{"core_lang":true,"description":"Given a quoted symbol removes the symbol and any definition information from the namespace. If the namespace is fully-qualified, then the symbol will be removed from the specified namespace instead of the currently active namespace. If the symbol is successfully removed, the function will return true, otherwise if it is not found, false will be returned.  Note that if the specified symbol is non-qualified, but exists in a different, accessible namespace, but the symbol isn't present in the current namespace, the symbol will not be deleted.  The environment is not searched and therefore symbols have to be explicitly fully-qualified for any effect of this function outside the current namespace.","usage":["quoted_symbol:string"],"tags":["symbol","delete","remove","unintern","reference","value"]},"*namespace*":{"core_lang":true},"pend_load":{"core_lang":true,"description":"When used as an initializer wrapper via the use_symbols macro, the wrapped initializer will not be loaded until the from_namespace is loaded to ensure that the wrapped initializer won't fail due to not yet loaded dependencies.","usage":["from_namespace:string","target_namespace:string","symbol:string","initializer:array"],"tags":["symbol","definitions","namespace","scope","dependency","dependencies","require"]},"symbols":{"core_lang":true,"description":"Returns an array of the defined global symbols for the local environment.  If opts.unique is true, only symbols that are not part of the built ins are included.","usage":["opts:object"],"tags":["symbol","names","definitions","values","scope"]},"set_global":{"core_lang":true},"get_global":{"core_lang":true},"symbol_definition":{"core_lang":true,"description":"Given a symbol name and an optional namespace, either as a fully qualified path or via the target_namespace argument, returns definition information about the retquested symbol.  Used primarily by the compiler to find metadata for a specific symbol during compilation.","usage":["symname:string","namespace:string"],"tags":["compiler","symbols","namespace","search","context","environment"]},"compile":{"core_lang":true,"description":"Compiles the given JSON or quoted lisp and returns a string containing the lisp form or expression as javascript.<br>If passed the option { meta: true } , an array is returned containing compilation metadata in element 0 and the compiled code in element 1.","usage":["json_expression:*","opts:object"],"tags":["macro","quote","quotes","desym","compiler"]},"env_log":{"core_lang":true,"description":"The environment logging function used by the environment.","usage":["arg0:*","argN:*"]},"evaluate_local":{"core_lang":true},"evaluate":{"core_lang":true},"eval_struct":{"core_lang":true}},await (async function(){
             return ["=:javascript","[[\"meta_for_symbol\",function(quoted_symbol,search_mode) {\n                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){\n                            {\n                                let local_data=(Environment.global_ctx.scope[quoted_symbol]|| Environment.definitions[quoted_symbol]);\n                                ;\n                                let acc=[];\n                                ;\n                                if (check_true (search_mode)){\n                                    {\n                                        if (check_true (local_data)){\n                                            {\n                                                (acc).push( ( get_global(\"add\"))({\n                                                    namespace:namespace,name:quoted_symbol,type: subtype(local_data)\n                                                }, ( function(){\n                                                    let it;\n                                                    it=Environment.definitions[quoted_symbol];\n                                                    if (check_true (it)){\n                                                        return it\n                                                    } else {\n                                                        return new Object()\n                                                    }\n                                                })()))\n                                            }\n                                        };\n                                        if (check_true (parent_environment)){\n                                            {\n                                                {\n                                                    let __collector;\n                                                    let __result;\n                                                    let __action;\n                                                    __collector=[];\n                                                    __result=null;\n                                                    __action=function(info) {\n                                                        return (acc).push(info)\n                                                    };\n                                                    ;\n                                                     ( function() {\n                                                        let __for_body__121=function(__item) {\n                                                            __result= __action(__item);\n                                                            if (check_true (__result)){\n                                                                return (__collector).push(__result)\n                                                            }\n                                                        };\n                                                        let __array__122=[],__elements__120= ( function() {\n                                                            {\n                                                                 let __call_target__= parent_environment[\"meta_for_symbol\"].call(parent_environment,quoted_symbol,true), __call_method__=\"flat\";\n                                                                return  __call_target__[__call_method__].call(__call_target__,1)\n                                                            } \n                                                        })();\n                                                        let __BREAK__FLAG__=false;\n                                                        for(let __iter__119 in __elements__120) {\n                                                            __array__122.push( __for_body__121(__elements__120[__iter__119]));\n                                                            if(__BREAK__FLAG__) {\n                                                                 __array__122.pop();\n                                                                break;\n                                                                \n                                                            }\n                                                        }return __array__122;\n                                                         \n                                                    })();\n                                                    __collector\n                                                }\n                                            }\n                                        };\n                                        if (check_true (( length( keys(children))>0))){\n                                            {\n                                                {\n                                                    let __collector;\n                                                    let __result;\n                                                    let __action;\n                                                    __collector=[];\n                                                    __result=null;\n                                                    __action=function(details) {\n                                                        return (acc).push(details)\n                                                    };\n                                                    ;\n                                                     ( function() {\n                                                        let __for_body__125=function(__item) {\n                                                            __result= __action(__item);\n                                                            if (check_true (__result)){\n                                                                return (__collector).push(__result)\n                                                            }\n                                                        };\n                                                        let __array__126=[],__elements__124= ( function(){\n                                                            let ____collector__127=  function(){\n                                                                return []\n                                                            };\n                                                            let ____result__128=  function(){\n                                                                return null\n                                                            };\n                                                            let ____action__129=  function(){\n                                                                return function(child_data) {\n                                                                    if (check_true ( not((child_data['0']=== ( get_global(\"current_namespace\"))())))){\n                                                                        {\n                                                                            return  child_data['1'][\"meta_for_symbol\"].call(child_data['1'],quoted_symbol)\n                                                                        }\n                                                                    }\n                                                                }\n                                                            };\n                                                            {\n                                                                let __collector= ____collector__127();\n                                                                ;\n                                                                let __result= ____result__128();\n                                                                ;\n                                                                let __action= ____action__129();\n                                                                ;\n                                                                ;\n                                                                 ( function() {\n                                                                    let __for_body__132=function(__item) {\n                                                                        __result= __action(__item);\n                                                                        if (check_true (__result)){\n                                                                            return (__collector).push(__result)\n                                                                        }\n                                                                    };\n                                                                    let __array__133=[],__elements__131= pairs(children);\n                                                                    let __BREAK__FLAG__=false;\n                                                                    for(let __iter__130 in __elements__131) {\n                                                                        __array__133.push( __for_body__132(__elements__131[__iter__130]));\n                                                                        if(__BREAK__FLAG__) {\n                                                                             __array__133.pop();\n                                                                            break;\n                                                                            \n                                                                        }\n                                                                    }return __array__133;\n                                                                     \n                                                                })();\n                                                                return __collector\n                                                            }\n                                                        })();\n                                                        let __BREAK__FLAG__=false;\n                                                        for(let __iter__123 in __elements__124) {\n                                                            __array__126.push( __for_body__125(__elements__124[__iter__123]));\n                                                            if(__BREAK__FLAG__) {\n                                                                 __array__126.pop();\n                                                                break;\n                                                                \n                                                            }\n                                                        }return __array__126;\n                                                         \n                                                    })();\n                                                    __collector\n                                                }\n                                            }\n                                        };\n                                        return acc\n                                    }\n                                } else {\n                                    {\n                                        quoted_symbol= ( function(){\n                                            if (check_true ( starts_with_ques_( ( function(){\n                                                 return \"=:\" \n                                            })(),quoted_symbol))){\n                                                return  quoted_symbol[\"substr\"].call(quoted_symbol,2)\n                                            } else {\n                                                return quoted_symbol\n                                            }\n                                        })();\n                                        {\n                                            let it;\n                                            it=Environment.definitions[quoted_symbol];\n                                            if (check_true (it)){\n                                                return  ( get_global(\"add\"))({\n                                                    namespace:namespace,type: sub_type(local_data),name:quoted_symbol\n                                                },it)\n                                            } else {\n                                                return null\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }],[\"describe\",async function(quoted_symbol,search_mode) {\n                        let internal_results=await meta_for_symbol(quoted_symbol,true);\n                        ;\n                        if (check_true (((internal_results instanceof Array)&& internal_results['0']))){\n                            if (check_true (search_mode)){\n                                return internal_results\n                            } else {\n                                return await first(internal_results)\n                            }\n                        } else {\n                            {\n                                let external_results=await get_outside_global(quoted_symbol);\n                                ;\n                                if (check_true (external_results)){\n                                    {\n                                        let detail={\n                                            location:\"external\",type:await subtype(external_results),name:quoted_symbol,namespace:\"EXTERNAL\",description:(\"This is not a bound symbol within the Juno Environment.  \"+ \"If it is to be used, it is recommended to create a reference to it with \"+ \"`(defglobal \"+ quoted_symbol+ \" \"+ quoted_symbol+ \" { `description: \\\"...\\\" })`\")\n                                        };\n                                        ;\n                                        if (check_true (search_mode)){\n                                            return await (async function(){\n                                                let __array_op_rval__136=detail;\n                                                 if (__array_op_rval__136 instanceof Function){\n                                                    return await __array_op_rval__136() \n                                                } else {\n                                                    return [__array_op_rval__136]\n                                                }\n                                            })()\n                                        } else {\n                                            return detail\n                                        }\n                                    }\n                                } else {\n                                    return null\n                                }\n                            }\n                        }\n                    }],[\"undefine\",function(quoted_symbol) {\n                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){\n                            {\n                                let namespace_identity;\n                                let parent_call;\n                                let child_call;\n                                let target_symbol;\n                                namespace_identity=(quoted_symbol).split(\"/\");\n                                parent_call=null;\n                                child_call=null;\n                                target_symbol=null;\n                                ;\n                                return   (function(){\n                                    if (check_true ((((namespace_identity.length===1)&& Environment.global_ctx.scope[namespace_identity['0']])|| ((namespace_identity.length>1)&& (namespace_identity['0']===namespace))))) {\n                                        {\n                                            target_symbol= ( function(){\n                                                if (check_true ((namespace_identity.length>1))){\n                                                    return namespace_identity['1']\n                                                } else {\n                                                    return namespace_identity['0']\n                                                }\n                                            })();\n                                             delete_prop(Environment.definitions,target_symbol);\n                                            if (check_true (Environment.global_ctx.scope[target_symbol])){\n                                                return  delete_prop(Environment.global_ctx.scope,target_symbol)\n                                            } else {\n                                                return false\n                                            }\n                                        }\n                                    } else if (check_true (((namespace_identity.length>1)&& parent_environment))) {\n                                        {\n                                            parent_call= parent_environment[\"get_global\"].call(parent_environment,\"undefine\");\n                                            return (parent_call)(quoted_symbol)\n                                        }\n                                    } else if (check_true (((namespace_identity.length>1)&& children[namespace_identity['0']]))) {\n                                        {\n                                            child_call= ( function() {\n                                                {\n                                                     let __call_target__=children[namespace_identity['0']], __call_method__=\"get_global\";\n                                                    return  __call_target__[__call_method__].call(__call_target__,\"undefine\")\n                                                } \n                                            })();\n                                            return  child_call(quoted_symbol)\n                                        }\n                                    } else {\n                                        return false\n                                    }\n                                } )()\n                            }\n                        } else {\n                            throw new SyntaxError(\"undefine requires a quoted symbol\");\n                            \n                        }\n                    }],[\"*namespace*\",\"user\"],[\"pend_load\",async function(from_namespace,target_namespace,symbol,initializer) {\n                        if (check_true ((null==pending_ns_loads[from_namespace]))){\n                            {\n                                await async function(){\n                                    pending_ns_loads[from_namespace]=[];\n                                    return pending_ns_loads;\n                                    \n                                }()\n                            }\n                        };\n                        (pending_ns_loads[from_namespace]).push({\n                            symbol:symbol,source_ns:from_namespace,target_ns:target_namespace,initializer:await (async function(){\n                                 return [\"=:quote\",initializer] \n                            })()\n                        });\n                        return initializer\n                    }],[\"symbols\",async function(opts) {\n                        return await async function(){\n                            if (check_true ((null==opts))) {\n                                return await keys(Environment.global_ctx.scope)\n                            } else if (check_true (opts.unique)) {\n                                {\n                                    let no_includes=await make_set(await conj([\"meta_for_symbol\",\"describe\",\"undefine\",\"*namespace*\",\"pend_load\",\"symbols\",\"set_global\",\"get_global\",\"symbol_definition\",\"compile\",\"env_log\",\"evaluate_local\",\"evaluate\",\"eval_struct\",\"set_compiler\",\"clone\",\"eval\",\"add_escape_encoding\",\"get_outside_global\",\"as_lisp\",\"lisp_writer\",\"clone_to_new\",\"save_env\",\"null\",\"compiler\"],built_ins));\n                                    ;\n                                    {\n                                        let __collector;\n                                        let __result;\n                                        let __action;\n                                        __collector=[];\n                                        __result=null;\n                                        __action=async function(sym) {\n                                            if (check_true (await no_includes[\"has\"].call(no_includes,sym))){\n                                                return null\n                                            } else {\n                                                return sym\n                                            }\n                                        };\n                                        ;\n                                        await (async function() {\n                                            let __for_body__213=async function(__item) {\n                                                __result=await __action(__item);\n                                                if (check_true (__result)){\n                                                    return (__collector).push(__result)\n                                                }\n                                            };\n                                            let __array__214=[],__elements__212=await keys(Environment.global_ctx.scope);\n                                            let __BREAK__FLAG__=false;\n                                            for(let __iter__211 in __elements__212) {\n                                                __array__214.push(await __for_body__213(__elements__212[__iter__211]));\n                                                if(__BREAK__FLAG__) {\n                                                     __array__214.pop();\n                                                    break;\n                                                    \n                                                }\n                                            }return __array__214;\n                                             \n                                        })();\n                                        return __collector\n                                    }\n                                }\n                            }\n                        } ()\n                    }],[\"set_global\",function(refname,value,meta,is_constant,target_namespace,contained_req) {\n                          (function(){\n                            if (check_true ( not((typeof refname===\"string\")))) {\n                                throw new TypeError(\"reference name must be a string type\");\n                                \n                            } else if (check_true (((Environment===value)|| (Environment.global_ctx===value)|| (Environment.global_ctx.scope===value)))) {\n                                {\n                                    throw new EvalError(\"cannot set the environment scope as a global value\");\n                                    \n                                }\n                            }\n                        } )();\n                        if (check_true ( resolve_path( ( function(){\n                            let __array_op_rval__217=refname;\n                             if (__array_op_rval__217 instanceof Function){\n                                return  __array_op_rval__217(\"constant\") \n                            } else {\n                                return [__array_op_rval__217,\"constant\"]\n                            }\n                        })(),Environment.definitions))){\n                            {\n                                throw new TypeError((\"Assignment to constant variable \"+ refname));\n                                \n                            }\n                        };\n                        let namespace_identity= ( function(){\n                            if (check_true (target_namespace)){\n                                return  ( function(){\n                                    let __array_op_rval__218=target_namespace;\n                                     if (__array_op_rval__218 instanceof Function){\n                                        return  __array_op_rval__218(refname) \n                                    } else {\n                                        return [__array_op_rval__218,refname]\n                                    }\n                                })()\n                            } else {\n                                return (refname).split(\"/\")\n                            }\n                        })();\n                        ;\n                        return   (function(){\n                            if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace===namespace_identity['0']))))) {\n                                return  parent_environment[\"set_global\"].call(parent_environment,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'],(contained|| contained_req))\n                            } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                {\n                                    if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){\n                                        return  ( function() {\n                                            {\n                                                 let __call_target__=children[namespace_identity['0']], __call_method__=\"set_global\";\n                                                return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'])\n                                            } \n                                        })()\n                                    } else {\n                                        throw new EvalError((\"namespace \"+ namespace_identity['0']+ \" doesn't exist\"));\n                                        \n                                    }\n                                }\n                            } else {\n                                try {\n                                    let comps= get_object_path( ( function(){\n                                        if (check_true ((1===namespace_identity.length))){\n                                            return namespace_identity['0']\n                                        } else {\n                                            return namespace_identity['1']\n                                        }\n                                    })());\n                                    ;\n                                      (function(){\n                                        Environment.global_ctx.scope[comps['0']]=value;\n                                        return Environment.global_ctx.scope;\n                                        \n                                    })();\n                                    if (check_true (((meta instanceof Object)&&  not((meta instanceof Array))))){\n                                        {\n                                            if (check_true (is_constant)){\n                                                {\n                                                      (function(){\n                                                        meta[\"constant\"]=true;\n                                                        return meta;\n                                                        \n                                                    })()\n                                                }\n                                            };\n                                              (function(){\n                                                Environment.definitions[comps['0']]=meta;\n                                                return Environment.definitions;\n                                                \n                                            })()\n                                        }\n                                    } else {\n                                        if (check_true (is_constant)){\n                                            {\n                                                  (function(){\n                                                    Environment.definitions[comps['0']]={\n                                                        constant:true\n                                                    };\n                                                    return Environment.definitions;\n                                                    \n                                                })()\n                                            }\n                                        }\n                                    };\n                                    return Environment.global_ctx.scope[comps['0']]\n                                } catch (__exception__219) {\n                                    if (__exception__219 instanceof Error) {\n                                        let e=__exception__219;\n                                        {\n                                            {\n                                                let message=(\"Error: set_global: \"+ _star_namespace_star_+ \"symbol name: \"+ refname+ \": \"+ e.message);\n                                                ;\n                                                 console.error(message,[]);\n                                                  (function(){\n                                                    e[\"message\"]=message;\n                                                    return e;\n                                                    \n                                                })();\n                                                throw e;\n                                                \n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } )()\n                    }],[\"get_global\",function(refname,value_if_not_found,suppress_check_external_env,target_namespace,path_comps,contained_req) {\n                        return   (function(){\n                            if (check_true ( not((typeof refname===\"string\")))) {\n                                throw new TypeError(\"reference name must be a string type\");\n                                \n                            } else if (check_true ((refname===\"Environment\"))) {\n                                return Environment\n                            } else if (check_true ( compiler_operators[\"has\"].call(compiler_operators,refname))) {\n                                return special_identity\n                            } else {\n                                {\n                                    let namespace_identity;\n                                    let comps;\n                                    let refval;\n                                    let symbol_name;\n                                    let check_external_env;\n                                    namespace_identity= ( function(){\n                                        if (check_true (target_namespace)){\n                                            return  ( function(){\n                                                let __array_op_rval__227=target_namespace;\n                                                 if (__array_op_rval__227 instanceof Function){\n                                                    return  __array_op_rval__227(refname) \n                                                } else {\n                                                    return [__array_op_rval__227,refname]\n                                                }\n                                            })()\n                                        } else {\n                                            return (refname).split(\"/\")\n                                        }\n                                    })();\n                                    comps=(path_comps||  get_object_path( ( function(){\n                                        if (check_true ((1===namespace_identity.length))){\n                                            return namespace_identity['0']\n                                        } else {\n                                            return namespace_identity['1']\n                                        }\n                                    })()));\n                                    refval=null;\n                                    symbol_name=null;\n                                    check_external_env= ( function(){\n                                        if (check_true (suppress_check_external_env)){\n                                            return false\n                                        } else {\n                                            return check_external_env_default\n                                        }\n                                    })();\n                                    return   (function(){\n                                        if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                            return  parent_environment[\"get_global\"].call(parent_environment,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps,(contained|| contained_req))\n                                        } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                            {\n                                                if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){\n                                                    return  ( function() {\n                                                        {\n                                                             let __call_target__=children[namespace_identity['0']], __call_method__=\"get_global\";\n                                                            return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps)\n                                                        } \n                                                    })()\n                                                } else {\n                                                    {\n                                                        throw new EvalError((\"namespace \"+ namespace_identity['0']+ \" doesn't exist\"));\n                                                        \n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            {\n                                                refval=Environment.global_ctx.scope[comps['0']];\n                                                if (check_true (((undefined===refval)&& (namespace_identity.length===1)&& parent_environment))){\n                                                    {\n                                                        let rval= parent_environment[\"get_global\"].call(parent_environment,refname,value_if_not_found,suppress_check_external_env,null,comps,(contained|| contained_req));\n                                                        ;\n                                                        return rval\n                                                    }\n                                                } else {\n                                                    {\n                                                        if (check_true (((undefined===refval)&& check_external_env))){\n                                                            refval= ( function(){\n                                                                if (check_true (check_external_env)){\n                                                                    return ( get_outside_global(comps['0'])|| NOT_FOUND)\n                                                                } else {\n                                                                    return NOT_FOUND\n                                                                }\n                                                            })()\n                                                        };\n                                                        return   (function(){\n                                                            if (check_true (((NOT_FOUND===refval)&&  not((undefined===value_if_not_found))))) {\n                                                                return value_if_not_found\n                                                            } else if (check_true ((NOT_FOUND===refval))) {\n                                                                {\n                                                                    throw new ReferenceError((\"symbol not found: \"+  ( function(){\n                                                                        if (check_true ((namespace_identity.length>1))){\n                                                                            return  add(namespace,\"/\",namespace_identity['1'])\n                                                                        } else {\n                                                                            return  add(namespace,\"/\",namespace_identity['0'])\n                                                                        }\n                                                                    })()));\n                                                                    \n                                                                }\n                                                            } else if (check_true ((comps.length===1))) {\n                                                                return refval\n                                                            } else if (check_true ((comps.length>1))) {\n                                                                {\n                                                                    return  resolve_path( rest(comps),refval)\n                                                                }\n                                                            } else {\n                                                                {\n                                                                     console.warn(\"get_global: condition fall through: \",comps);\n                                                                    return NOT_FOUND\n                                                                }\n                                                            }\n                                                        } )()\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } )()\n                                }\n                            }\n                        } )()\n                    }],[\"symbol_definition\",async function(symname,target_namespace) {\n                        let namespace_identity;\n                        namespace_identity=await (async function(){\n                            if (check_true (target_namespace)){\n                                return await (async function(){\n                                    let __array_op_rval__230=target_namespace;\n                                     if (__array_op_rval__230 instanceof Function){\n                                        return await __array_op_rval__230(symname) \n                                    } else {\n                                        return [__array_op_rval__230,symname]\n                                    }\n                                })()\n                            } else {\n                                if (check_true ((await length(symname)>2))){\n                                    return (symname).split(\"/\")\n                                } else {\n                                    return await (async function(){\n                                        let __array_op_rval__231=symname;\n                                         if (__array_op_rval__231 instanceof Function){\n                                            return await __array_op_rval__231() \n                                        } else {\n                                            return [__array_op_rval__231]\n                                        }\n                                    })()\n                                }\n                            }\n                        })();\n                        return await async function(){\n                            if (check_true ((namespace_identity.length===1))) {\n                                {\n                                    let it;\n                                    it=Environment.definitions[symname];\n                                    if (check_true (it)){\n                                        return it\n                                    } else {\n                                        if (check_true (parent_environment)){\n                                            return await parent_environment[\"symbol_definition\"].call(parent_environment,symname)\n                                        }\n                                    }\n                                }\n                            } else if (check_true ((namespace_identity['0']===namespace))) {\n                                return Environment.definitions[symname]\n                            } else if (check_true (parent_environment)) {\n                                return await parent_environment[\"symbol_definition\"].call(parent_environment,namespace_identity['1'],namespace_identity['0'])\n                            } else if (check_true ((namespace_identity.length===2))) {\n                                return await (async function() {\n                                    {\n                                         let __call_target__=children[namespace_identity['0']], __call_method__=\"symbol_definition\";\n                                        return await __call_target__[__call_method__].call(__call_target__,namespace_identity['1'])\n                                    } \n                                })()\n                            } else {\n                                return undefined\n                            }\n                        } ()\n                    }],[\"compile\",async function(json_expression,opts) {\n                        let out;\n                        opts=await add({\n                            env:Environment\n                        },opts,{\n                            meta:await (async function(){\n                                if (check_true ((opts&& opts.meta))){\n                                    return true\n                                } else {\n                                    return false\n                                }\n                            })()\n                        });\n                        out=null;\n                        out=await (async function(){\n                             return await compiler(json_expression,opts) \n                        })();\n                        return await async function(){\n                            if (check_true (((out instanceof Array)&& out['0'].ctype&& (out['0'].ctype===\"FAIL\")))) {\n                                return out\n                            } else if (check_true (opts.meta)) {\n                                return out\n                            } else {\n                                return out['1']\n                            }\n                        } ()\n                    }],[\"env_log\",async function(...args) {\n                            return await (async function(){\n                                let __target_arg__189=[].concat(await conj(await (async function(){\n                                    let __array_op_rval__190=style;\n                                     if (__array_op_rval__190 instanceof Function){\n                                        return await __array_op_rval__190() \n                                    } else {\n                                        return [__array_op_rval__190]\n                                    }\n                                })(),args));\n                                if(!__target_arg__189 instanceof Array){\n                                    throw new TypeError(\"Invalid final argument to apply - an array is required\")\n                                }let __pre_arg__191=(\"%c\"+ await (async function(){\n                                    if (check_true (opts.prefix)){\n                                        return opts.prefix\n                                    } else {\n                                        return (args).shift()\n                                    }\n                                })());\n                                __target_arg__189.unshift(__pre_arg__191);\n                                return (console.log).apply(this,__target_arg__189)\n                            })()\n                        }],[\"evaluate_local\",async function(expression,ctx,opts) {\n                        let compiled;\n                        let error_data;\n                        let requires;\n                        let precompiled_assembly;\n                        let result;\n                        opts=(opts|| new Object());\n                        compiled=null;\n                        error_data=null;\n                        requires=null;\n                        precompiled_assembly=null;\n                        result=null;\n                        if (check_true (opts.compiled_source)){\n                            compiled=expression\n                        } else {\n                            try {\n                                compiled=await (async function(){\n                                     return await compiler(await (async function(){\n                                        if (check_true (opts.json_in)){\n                                            return expression\n                                        } else {\n                                            return await Environment[\"read_lisp\"].call(Environment,expression,{\n                                                source_name:opts.source_name\n                                            })\n                                        }\n                                    })(),{\n                                        env:Environment,ctx:ctx,formatted_output:true,source_name:opts.source_name,throw_on_error:opts.throw_on_error,on_final_token_assembly:async function(val) {\n                                            return precompiled_assembly=val\n                                        },error_report:(opts.error_report|| null),quiet_mode:(opts.quiet_mode|| false)\n                                    }) \n                                })()\n                            } catch (__exception__238) {\n                                if (__exception__238 instanceof Error) {\n                                    let e=__exception__238;\n                                    {\n                                        {\n                                            if (check_true (opts.throw_on_error)){\n                                                {\n                                                    throw e;\n                                                    \n                                                }\n                                            };\n                                            if (check_true ((e instanceof LispSyntaxError))){\n                                                {\n                                                    await async function(){\n                                                        e[\"message\"]=await JSON.parse(e.message);\n                                                        return e;\n                                                        \n                                                    }()\n                                                }\n                                            };\n                                            await async function(){\n                                                if (check_true ((e instanceof LispSyntaxError))) {\n                                                    return error_data=await add({\n                                                        error:\"LispSyntaxError\"\n                                                    },e.message)\n                                                } else {\n                                                    error_data={\n                                                        error:await sub_type(e),message:e.message,stack:e.stack,form:await (async function(){\n                                                             return await async function(){\n                                                                if (check_true (((expression instanceof String || typeof expression==='string')&& (expression.length>100)))) {\n                                                                    return await add(await expression[\"substr\"].call(expression,0,100),\"...\")\n                                                                } else {\n                                                                    return await (await get_global(\"as_lisp\"))(expression)\n                                                                }\n                                                            } () \n                                                        })(),parent_forms:[],source_name:opts.source_name,invalid:true\n                                                    }\n                                                }\n                                            } ();\n                                            if (check_true (opts.error_report)){\n                                                await (async function(){\n                                                    let __array_op_rval__240=opts.error_report;\n                                                     if (__array_op_rval__240 instanceof Function){\n                                                        return await __array_op_rval__240(error_data) \n                                                    } else {\n                                                        return [__array_op_rval__240,error_data]\n                                                    }\n                                                })()\n                                            } else {\n                                                await console.error(\"Compilation Error: \",error_data)\n                                            };\n                                            compiled=await (async function(){\n                                                 return [{\n                                                    error:true\n                                                },null] \n                                            })()\n                                        }\n                                    }\n                                }\n                            }\n                        };\n                        return await async function(){\n                            if (check_true ((null==compiled))) {\n                                return null\n                            } else if (check_true ((compiled['0'].ctype===\"FAIL\"))) {\n                                {\n                                    if (check_true (opts.error_report)){\n                                        {\n                                            await (async function(){\n                                                let __array_op_rval__241=opts.error_report;\n                                                 if (__array_op_rval__241 instanceof Function){\n                                                    return await __array_op_rval__241(compiled['1']) \n                                                } else {\n                                                    return [__array_op_rval__241,compiled['1']]\n                                                }\n                                            })()\n                                        }\n                                    };\n                                    return await async function(){\n                                        if (check_true ((compiled['1'] instanceof Error))) {\n                                            throw compiled['1'];\n                                            \n                                        } else if (check_true ((compiled['1']['0'] instanceof Error))) {\n                                            throw compiled['1']['0'];\n                                            \n                                        } else if (check_true (((compiled['1']['0'] instanceof Object)&& (compiled['1']['0'].error===\"SyntaxError\")))) {\n                                            {\n                                                let new_error=new SyntaxError(compiled['1']['0'].message);\n                                                ;\n                                                await async function(){\n                                                    new_error[\"from\"]=compiled['1']['0'];\n                                                    return new_error;\n                                                    \n                                                }();\n                                                throw new_error;\n                                                \n                                            }\n                                        } else {\n                                            return compiled['1']\n                                        }\n                                    } ()\n                                }\n                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))&& parent_environment))) {\n                                return await parent_environment[\"evaluate_local\"].call(parent_environment,compiled,ctx,await add(new Object(),opts,{\n                                    compiled_source:true\n                                }))\n                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))))) {\n                                if (check_true (children[compiled['0'].namespace])){\n                                    return await (async function() {\n                                        {\n                                             let __call_target__=children[compiled['0'].namespace], __call_method__=\"evaluate_local\";\n                                            return await __call_target__[__call_method__].call(__call_target__,compiled,ctx,await add(new Object(),opts,{\n                                                compiled_source:true\n                                            }))\n                                        } \n                                    })()\n                                } else {\n                                    throw new EvalError((\"unknown namespace \"+ compiled['0'].namespace+ \" assignment\"));\n                                    \n                                }\n                            } else {\n                                {\n                                    if (check_true (opts.on_compilation_complete)){\n                                        await (async function(){\n                                            let __array_op_rval__243=opts.on_compilation_complete;\n                                             if (__array_op_rval__243 instanceof Function){\n                                                return await __array_op_rval__243(compiled) \n                                            } else {\n                                                return [__array_op_rval__243,compiled]\n                                            }\n                                        })()\n                                    };\n                                    try {\n                                        if (check_true (((compiled instanceof Array)&& (compiled['0'] instanceof Object)&& compiled['0'].ctype&& await not((compiled['0'].ctype instanceof String || typeof compiled['0'].ctype==='string'))))){\n                                            {\n                                                await async function(){\n                                                    compiled['0'][\"ctype\"]=await subtype(compiled['0'].ctype);\n                                                    return compiled['0'];\n                                                    \n                                                }()\n                                            }\n                                        };\n                                        result=await (async function(){\n                                             return await async function(){\n                                                if (check_true (compiled.error)) {\n                                                    throw new Error((await get_global(\"indirect_new\"))(compiled.error,compiled.message));\n                                                    \n                                                } else if (check_true ((compiled['0'].ctype&& (await contains_ques_(\"block\",compiled['0'].ctype)|| (compiled['0'].ctype===\"assignment\")|| (compiled['0'].ctype===\"__!NOT_FOUND!__\"))))) {\n                                                    if (check_true (await (async function(){\n                                                        let __array_op_rval__246=compiled['0'].has_lisp_globals;\n                                                         if (__array_op_rval__246 instanceof Function){\n                                                            return await __array_op_rval__246() \n                                                        } else {\n                                                            return [__array_op_rval__246]\n                                                        }\n                                                    })())){\n                                                        {\n                                                            await async function(){\n                                                                compiled[1]=new AsyncFunction(\"Environment\",(\"{ \"+ compiled['1']+ \"}\"));\n                                                                return compiled;\n                                                                \n                                                            }();\n                                                            return await (async function(){\n                                                                let __array_op_rval__248=compiled['1'];\n                                                                 if (__array_op_rval__248 instanceof Function){\n                                                                    return await __array_op_rval__248(Environment) \n                                                                } else {\n                                                                    return [__array_op_rval__248,Environment]\n                                                                }\n                                                            })()\n                                                        }\n                                                    } else {\n                                                        {\n                                                            await async function(){\n                                                                compiled[1]=new AsyncFunction((\"{\"+ compiled['1']+ \"}\"));\n                                                                return compiled;\n                                                                \n                                                            }();\n                                                            return await (async function(){\n                                                                let __array_op_rval__250=compiled['1'];\n                                                                 if (__array_op_rval__250 instanceof Function){\n                                                                    return await __array_op_rval__250() \n                                                                } else {\n                                                                    return [__array_op_rval__250]\n                                                                }\n                                                            })()\n                                                        }\n                                                    }\n                                                } else if (check_true ((compiled['0'].ctype&& ((\"AsyncFunction\"===compiled['0'].ctype)|| (\"statement\"===compiled['0'].ctype)|| (\"objliteral\"===compiled['0'].ctype))))) {\n                                                    {\n                                                        if (check_true (await (async function(){\n                                                            let __array_op_rval__251=compiled['0'].has_lisp_globals;\n                                                             if (__array_op_rval__251 instanceof Function){\n                                                                return await __array_op_rval__251() \n                                                            } else {\n                                                                return [__array_op_rval__251]\n                                                            }\n                                                        })())){\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new AsyncFunction(\"Environment\",(\"{ return \"+ compiled['1']+ \"} \"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__253=compiled['1'];\n                                                                     if (__array_op_rval__253 instanceof Function){\n                                                                        return await __array_op_rval__253(Environment) \n                                                                    } else {\n                                                                        return [__array_op_rval__253,Environment]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        } else {\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new AsyncFunction((\"{ return \"+ compiled['1']+ \"}\"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__255=compiled['1'];\n                                                                     if (__array_op_rval__255 instanceof Function){\n                                                                        return await __array_op_rval__255() \n                                                                    } else {\n                                                                        return [__array_op_rval__255]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        }\n                                                    }\n                                                } else if (check_true ((compiled['0'].ctype&& (\"Function\"===compiled['0'].ctype)))) {\n                                                    {\n                                                        if (check_true (await (async function(){\n                                                            let __array_op_rval__256=compiled['0'].has_lisp_globals;\n                                                             if (__array_op_rval__256 instanceof Function){\n                                                                return await __array_op_rval__256() \n                                                            } else {\n                                                                return [__array_op_rval__256]\n                                                            }\n                                                        })())){\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new Function(\"Environment\",(\"{ return \"+ compiled['1']+ \"} \"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__258=compiled['1'];\n                                                                     if (__array_op_rval__258 instanceof Function){\n                                                                        return await __array_op_rval__258(Environment) \n                                                                    } else {\n                                                                        return [__array_op_rval__258,Environment]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        } else {\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new Function((\"{ return \"+ compiled['1']+ \"}\"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__260=compiled['1'];\n                                                                     if (__array_op_rval__260 instanceof Function){\n                                                                        return await __array_op_rval__260() \n                                                                    } else {\n                                                                        return [__array_op_rval__260]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        }\n                                                    }\n                                                } else {\n                                                    return compiled['1']\n                                                }\n                                            } () \n                                        })()\n                                    } catch (__exception__244) {\n                                        if (__exception__244 instanceof Error) {\n                                            let e=__exception__244;\n                                            {\n                                                {\n                                                    if (check_true (true)){\n                                                        {\n                                                            let details={\n                                                                error:e.name,message:e.message,expanded_source:await (await get_global(\"pretty_print\"))(await (async function(){\n                                                                     return await (await get_global(\"detokenize\"))(precompiled_assembly) \n                                                                })()),compiled:compiled['1']\n                                                            };\n                                                            ;\n                                                            console.log(\"Syntax Error: \",details);\n                                                            await async function(){\n                                                                e[\"details\"]=details;\n                                                                return e;\n                                                                \n                                                            }()\n                                                        }\n                                                    };\n                                                    if (check_true ((opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4)))){\n                                                        {\n                                                            if (check_true (e.details)){\n                                                                await env_log(\"caught error: \",e.details)\n                                                            } else {\n                                                                await env_log(\"caught error: \",e.name,e.message,e)\n                                                            }\n                                                        }\n                                                    };\n                                                    if (check_true ((false&& (await sub_type(e)===\"SyntaxError\")&& (opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4))))){\n                                                        await console.log(compiled['1'])\n                                                    };\n                                                    if (check_true (opts.error_report)){\n                                                        {\n                                                            await (async function(){\n                                                                let __array_op_rval__262=opts.error_report;\n                                                                 if (__array_op_rval__262 instanceof Function){\n                                                                    return await __array_op_rval__262(await (async function(){\n                                                                        if (check_true (e.details)){\n                                                                            return e.details\n                                                                        } else {\n                                                                            return {\n                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack\n                                                                            }\n                                                                        }\n                                                                    })()) \n                                                                } else {\n                                                                    return [__array_op_rval__262,await (async function(){\n                                                                        if (check_true (e.details)){\n                                                                            return e.details\n                                                                        } else {\n                                                                            return {\n                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack\n                                                                            }\n                                                                        }\n                                                                    })()]\n                                                                }\n                                                            })()\n                                                        }\n                                                    };\n                                                    result=e;\n                                                    if (check_true ((await not(opts.catch_errors)|| (ctx&& ctx.in_try)))){\n                                                        {\n                                                            throw result;\n                                                            \n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    };\n                                    return result\n                                }\n                            }\n                        } ()\n                    }],[\"evaluate\",async function(expression,ctx,opts) {\n                        return await async function(){\n                            if (check_true ((namespace===active_namespace))) {\n                                return await evaluate_local(expression,ctx,opts)\n                            } else if (check_true ((namespace===\"core\"))) {\n                                return await (async function() {\n                                    {\n                                         let __call_target__=children[active_namespace], __call_method__=\"evaluate\";\n                                        return await __call_target__[__call_method__].call(__call_target__,expression,ctx,opts)\n                                    } \n                                })()\n                            }\n                        } ()\n                    }],[\"eval_struct\",async function(lisp_struct,ctx,opts) {\n                        let rval;\n                        rval=null;\n                        if (check_true (lisp_struct instanceof Function)){\n                            rval=await (async function(){\n                                let __array_op_rval__267=lisp_struct;\n                                 if (__array_op_rval__267 instanceof Function){\n                                    return await __array_op_rval__267() \n                                } else {\n                                    return [__array_op_rval__267]\n                                }\n                            })()\n                        } else {\n                            rval=await (async function(){\n                                 return await evaluate(lisp_struct,ctx,await add({\n                                    json_in:true\n                                },(opts|| new Object()))) \n                            })()\n                        };\n                        return rval\n                    }],[\"set_compiler\",async function(compiler_function) {\n                        let new_ops;\n                        new_ops=await (async function(){\n                            let __array_op_rval__271=compiler_function;\n                             if (__array_op_rval__271 instanceof Function){\n                                return await __array_op_rval__271([],{\n                                    special_operators:true,env:Environment\n                                }) \n                            } else {\n                                return [__array_op_rval__271,[],{\n                                    special_operators:true,env:Environment\n                                }]\n                            }\n                        })();\n                        if (check_true (await is_set_ques_(new_ops))){\n                            {\n                                compiler_operators=new_ops;\n                                compiler=compiler_function;\n                                await async function(){\n                                    Environment.global_ctx.scope[\"compiler\"]=compiler;\n                                    return Environment.global_ctx.scope;\n                                    \n                                }();\n                                await (await get_global(\"register_feature\"))(\"compiler\")\n                            }\n                        } else {\n                            {\n                                await console.error(\"Invalid compiler function: invalid operators returned. Not installing.\");\n                                throw new EvalError(\"Invalid compiler function\");\n                                \n                            }\n                        };\n                        return compiler\n                    }],[\"clone\",async function(val) {\n                            if (check_true ((val===Environment))){\n                                return Environment\n                            } else {\n                                return await clone(val,0,Environment)\n                            }\n                        }],[\"eval\",async function(expression) {\n                        return await (async function(){\n                            let __array_op_rval__141=expression;\n                             if (__array_op_rval__141 instanceof Function){\n                                return await __array_op_rval__141() \n                            } else {\n                                return [__array_op_rval__141]\n                            }\n                        })()\n                    }],[\"add_escape_encoding\",async function(text) {        if (check_true ((text instanceof String || typeof text==='string'))){            let chars;            let acc;            chars=(text).split(\"\");            acc=[];            await (async function() {                let __for_body__3=async function(c) {                     return  await async function(){                        if (check_true( ((await c[\"charCodeAt\"].call(c,0)===34)))) {                            (acc).push(await String.fromCharCode(92));                             return  (acc).push(c)                        } else  {                             return (acc).push(c)                        }                    } ()                };                let __array__4=[],__elements__2=chars;                let __BREAK__FLAG__=false;                for(let __iter__1 in __elements__2) {                    __array__4.push(await __for_body__3(__elements__2[__iter__1]));                    if(__BREAK__FLAG__) {                         __array__4.pop();                        break;                                            }                }return __array__4;                             })();             return  (acc).join(\"\")        } else {              return text        }    }],[\"get_outside_global\",function get_outside_global(refname) {  try {    let tfn = new Function(\"{ if (typeof \" + refname + \" === 'undefined') { return undefined } else { return \"+refname+\" } }\");    return tfn();  } catch (ex) {    return undefined;  }}],[\"as_lisp\",lisp_writer],[\"lisp_writer\",lisp_writer],[\"clone_to_new\",async function(options) {\n                        let new_env;\n                        let my_children;\n                        let my_children_declarations;\n                        new_env=null;\n                        my_children=null;\n                        my_children_declarations=null;\n                        await env_log(namespace,\"cloning: # children: \",await length(children));\n                        new_env=await (async function(){\n                             return await dlisp_env({\n                                env:await (async function(){\n                                     return await clone(Environment) \n                                })(),children:await (async function(){\n                                     return await clone(children) \n                                })(),children_declarations:await (async function(){\n                                     return await clone(children_declarations) \n                                })()\n                            }) \n                        })();\n                        await env_log(namespace,\"constructed: \",await new_env[\"id\"]());\n                        return new_env\n                    }],[\"save_env\",async function(options) {\n                        let new_env;\n                        let my_children;\n                        let env_constructor;\n                        let dcomps;\n                        let version_tag;\n                        let build_time;\n                        let build_headers;\n                        let child_env;\n                        let want_buffer;\n                        let comp_buffer;\n                        let sorted_dependencies;\n                        let child_export_order;\n                        let preserve_imports;\n                        let include_source;\n                        let exports;\n                        let src;\n                        let target_insertion_path;\n                        let output_path;\n                        new_env=null;\n                        my_children=null;\n                        env_constructor=null;\n                        dcomps=await (async function(){\n                             return await (await get_global(\"date_components\"))(new Date()) \n                        })();\n                        options=(options|| new Object());\n                        version_tag=await (async function(){\n                            if (check_true (await not(await blank_ques_(opts.version_tag)))){\n                                return opts.version_tag\n                            } else {\n                                return (await (async function(){\n                                    let __array_op_rval__328=dcomps.year;\n                                     if (__array_op_rval__328 instanceof Function){\n                                        return await __array_op_rval__328(dcomps.month,dcomps.day,dcomps.hour,dcomps.minute) \n                                    } else {\n                                        return [__array_op_rval__328,dcomps.month,dcomps.day,dcomps.hour,dcomps.minute]\n                                    }\n                                })()).join(\".\")\n                            }\n                        })();\n                        build_time=await (async function(){\n                             return await (await get_global(\"formatted_date\"))(new Date()) \n                        })();\n                        build_headers=[];\n                        child_env=null;\n                        want_buffer=(options.want_buffer|| false);\n                        comp_buffer=null;\n                        sorted_dependencies=await (async function(){\n                             return await (await get_global(\"sort_dependencies\"))() \n                        })();\n                        child_export_order=null;\n                        preserve_imports=await (async function(){\n                            if (check_true ((options&& (options.preserve_imports===false)))){\n                                return false\n                            } else {\n                                return true\n                            }\n                        })();\n                        include_source=false;\n                        exports=[];\n                        src=await (async function(){\n                            if (check_true (await Environment[\"get_global\"].call(Environment,\"*env_skeleton*\",null))){\n                                return await clone(await Environment[\"get_global\"].call(Environment,\"*env_skeleton*\"))\n                            } else {\n                                return await (await get_global(\"reader\"))(await (async function(){\n                                     return await (await get_global(\"read_text_file\"))(\"./src/environment.lisp\") \n                                })())\n                            }\n                        })();\n                        target_insertion_path=null;\n                        output_path=null;\n                        if (check_true (Environment.global_ctx.scope[\"*env_skeleton*\"])){\n                            {\n                                await (await get_global(\"register_feature\"))(\"*env_skeleton*\")\n                            }\n                        };\n                        target_insertion_path=await first(await (async function(){\n                             return await (await get_global(\"findpaths\"))(await (async function(){\n                                 return \"=:included_globals\" \n                            })(),src) \n                        })());\n                        if (check_true (await not((target_insertion_path instanceof Array)))){\n                            throw new EvalError(\"Unable to find the first included_globals symbol\");\n                            \n                        };\n                        target_insertion_path=await conj(await chop(target_insertion_path),[2]);\n                        if (check_true (options.include_source)){\n                            {\n                                include_source=true\n                            }\n                        };\n                        await env_log(namespace,\"cloning: # children: \",await length(children));\n                        await env_log(namespace,\"preserve_imports: \",preserve_imports);\n                        exports=await export_symbol_set(await (async function(){\n                            if (check_true (options.do_not_include)){\n                                return {\n                                    do_not_include:options.do_not_include\n                                }\n                            }\n                        })());\n                        child_export_order=await (async function(){\n                            let __collector;\n                            let __result;\n                            let __action;\n                            __collector=[];\n                            __result=null;\n                            __action=async function(cname) {\n                                if (check_true (await not((cname===\"core\")))){\n                                    {\n                                        return await (async function(){\n                                            let __array_op_rval__329=cname;\n                                             if (__array_op_rval__329 instanceof Function){\n                                                return await __array_op_rval__329(children[cname]) \n                                            } else {\n                                                return [__array_op_rval__329,children[cname]]\n                                            }\n                                        })()\n                                    }\n                                }\n                            };\n                            ;\n                            await (async function() {\n                                let __for_body__332=async function(__item) {\n                                    __result=await __action(__item);\n                                    if (check_true (__result)){\n                                        return (__collector).push(__result)\n                                    }\n                                };\n                                let __array__333=[],__elements__331=sorted_dependencies.namespaces;\n                                let __BREAK__FLAG__=false;\n                                for(let __iter__330 in __elements__331) {\n                                    __array__333.push(await __for_body__332(__elements__331[__iter__330]));\n                                    if(__BREAK__FLAG__) {\n                                         __array__333.pop();\n                                        break;\n                                        \n                                    }\n                                }return __array__333;\n                                 \n                            })();\n                            return __collector\n                        })();\n                        await console.log(\"save_env: child_export_order: \",await (async function(){\n                             return await (await get_global(\"each\"))(child_export_order,0) \n                        })());\n                        my_children=await to_object(await (async function(){\n                            let __collector;\n                            let __result;\n                            let __action;\n                            __collector=[];\n                            __result=null;\n                            __action=async function(child) {\n                                if (check_true (await resolve_path(await (async function(){\n                                    let __array_op_rval__334=child['0'];\n                                     if (__array_op_rval__334 instanceof Function){\n                                        return await __array_op_rval__334(\"serialize_with_image\") \n                                    } else {\n                                        return [__array_op_rval__334,\"serialize_with_image\"]\n                                    }\n                                })(),children_declarations))){\n                                    {\n                                        await env_log(\"checking \",namespace,\"checking for: \",await add(child['0'],\"/*on_serialization*\"));\n                                        if (check_true (await not(((typeof await add(child['0'],\"/*on_serialization*\")===\"undefined\")|| (await Environment[\"get_global\"].call(Environment,await add(child['0'],\"/*on_serialization*\"),ReferenceError)===ReferenceError))))){\n                                            {\n                                                await child['1'][\"evaluate\"].call(child['1'],(\"(\"+ child['0']+ \"/*on_serialization*)\"))\n                                            }\n                                        };\n                                        child_env=await child['1'][\"compile\"].call(child['1'],await child['1'][\"export_symbol_set\"].call(child['1'],await add(new Object(),await (async function(){\n                                            if (check_true (options.do_not_include)){\n                                                return {\n                                                    do_not_include:await (async function(){\n                                                        let comps;\n                                                        comps=null;\n                                                        {\n                                                            let ____collector__335= async function(){\n                                                                return []\n                                                            };\n                                                            let ____result__336= async function(){\n                                                                return null\n                                                            };\n                                                            let ____action__337= async function(){\n                                                                return async function(symbol) {\n                                                                    return await async function(){\n                                                                        if (check_true (await contains_ques_(\"/\",symbol))) {\n                                                                            {\n                                                                                comps=(symbol).split(\"/\");\n                                                                                if (check_true ((comps['0']===child['0']))){\n                                                                                    return comps['1']\n                                                                                }\n                                                                            }\n                                                                        } else {\n                                                                            return symbol\n                                                                        }\n                                                                    } ()\n                                                                }\n                                                            };\n                                                            {\n                                                                let __collector=await ____collector__335();\n                                                                ;\n                                                                let __result=await ____result__336();\n                                                                ;\n                                                                let __action=await ____action__337();\n                                                                ;\n                                                                ;\n                                                                await (async function() {\n                                                                    let __for_body__340=async function(__item) {\n                                                                        __result=await __action(__item);\n                                                                        if (check_true (__result)){\n                                                                            return (__collector).push(__result)\n                                                                        }\n                                                                    };\n                                                                    let __array__341=[],__elements__339=options.do_not_include;\n                                                                    let __BREAK__FLAG__=false;\n                                                                    for(let __iter__338 in __elements__339) {\n                                                                        __array__341.push(await __for_body__340(__elements__339[__iter__338]));\n                                                                        if(__BREAK__FLAG__) {\n                                                                             __array__341.pop();\n                                                                            break;\n                                                                            \n                                                                        }\n                                                                    }return __array__341;\n                                                                     \n                                                                })();\n                                                                return __collector\n                                                            }\n                                                        }\n                                                    })()\n                                                }\n                                            } else {\n                                                return new Object()\n                                            }\n                                        })(),{\n                                            no_compiler:true\n                                        })),{\n                                            throw_on_error:true\n                                        });\n                                        return await (async function(){\n                                            let __array_op_rval__342=child['0'];\n                                             if (__array_op_rval__342 instanceof Function){\n                                                return await __array_op_rval__342(await (async function(){\n                                                     return [[\"=:quotel\",child['1'].definitions],await (async function(){\n                                                         return [\"=:quotel\",await (async function(){\n                                                             return [\"=:javascript\",child_env] \n                                                        })()] \n                                                    })()] \n                                                })()) \n                                            } else {\n                                                return [__array_op_rval__342,await (async function(){\n                                                     return [[\"=:quotel\",child['1'].definitions],await (async function(){\n                                                         return [\"=:quotel\",await (async function(){\n                                                             return [\"=:javascript\",child_env] \n                                                        })()] \n                                                    })()] \n                                                })()]\n                                            }\n                                        })()\n                                    }\n                                }\n                            };\n                            ;\n                            await (async function() {\n                                let __for_body__345=async function(__item) {\n                                    __result=await __action(__item);\n                                    if (check_true (__result)){\n                                        return (__collector).push(__result)\n                                    }\n                                };\n                                let __array__346=[],__elements__344=child_export_order;\n                                let __BREAK__FLAG__=false;\n                                for(let __iter__343 in __elements__344) {\n                                    __array__346.push(await __for_body__345(__elements__344[__iter__343]));\n                                    if(__BREAK__FLAG__) {\n                                         __array__346.pop();\n                                        break;\n                                        \n                                    }\n                                }return __array__346;\n                                 \n                            })();\n                            return __collector\n                        })());\n                        await (await get_global(\"set_path\"))(target_insertion_path,src,await (async function(){\n                             return [\"=:fn\",[],await to_object(await (async function(){\n                                 return [[\"definitions\",await (async function(){\n                                     return [\"=:quote\",await (async function(){\n                                        if (check_true (options.do_not_include)){\n                                            return await to_object(await (async function(){\n                                                let __collector;\n                                                let __result;\n                                                let __action;\n                                                __collector=[];\n                                                __result=null;\n                                                __action=async function(defset) {\n                                                    if (check_true (await not(await contains_ques_(defset['0'],options.do_not_include)))){\n                                                        return await (async function(){\n                                                            let __array_op_rval__347=defset['0'];\n                                                             if (__array_op_rval__347 instanceof Function){\n                                                                return await __array_op_rval__347(defset['1']) \n                                                            } else {\n                                                                return [__array_op_rval__347,defset['1']]\n                                                            }\n                                                        })()\n                                                    }\n                                                };\n                                                ;\n                                                await (async function() {\n                                                    let __for_body__350=async function(__item) {\n                                                        __result=await __action(__item);\n                                                        if (check_true (__result)){\n                                                            return (__collector).push(__result)\n                                                        }\n                                                    };\n                                                    let __array__351=[],__elements__349=await pairs(Environment.definitions);\n                                                    let __BREAK__FLAG__=false;\n                                                    for(let __iter__348 in __elements__349) {\n                                                        __array__351.push(await __for_body__350(__elements__349[__iter__348]));\n                                                        if(__BREAK__FLAG__) {\n                                                             __array__351.pop();\n                                                            break;\n                                                            \n                                                        }\n                                                    }return __array__351;\n                                                     \n                                                })();\n                                                return __collector\n                                            })())\n                                        } else {\n                                            return await clone(Environment.definitions)\n                                        }\n                                    })()] \n                                })()],[\"declarations\",await (async function(){\n                                     return await clone(Environment.declarations) \n                                })()],[\"config\",await (async function(){\n                                    let exp_conf;\n                                    exp_conf=await (async function(){\n                                         return await clone(Environment.global_ctx.scope[\"*env_config*\"]) \n                                    })();\n                                    if (check_true (await not(preserve_imports))){\n                                        {\n                                            await async function(){\n                                                exp_conf[\"imports\"]=new Object();\n                                                return exp_conf;\n                                                \n                                            }()\n                                        }\n                                    };\n                                    if (check_true (options.features)){\n                                        {\n                                            await async function(){\n                                                exp_conf[\"features\"]=options.features;\n                                                return exp_conf;\n                                                \n                                            }()\n                                        }\n                                    };\n                                    return exp_conf\n                                })()],[\"imports\",await (async function(){\n                                    if (check_true (preserve_imports)){\n                                        return await to_object(await (async function() {\n                                            let __for_body__356=async function(imp_source) {\n                                                return await (async function(){\n                                                    let __array_op_rval__358=imp_source.symbol;\n                                                     if (__array_op_rval__358 instanceof Function){\n                                                        return await __array_op_rval__358({\n                                                            initializer:await (async function(){\n                                                                 return [\"=:javascript\",\"new function () { return \",imp_source.symbol,\" }\"] \n                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace\n                                                        }) \n                                                    } else {\n                                                        return [__array_op_rval__358,{\n                                                            initializer:await (async function(){\n                                                                 return [\"=:javascript\",\"new function () { return \",imp_source.symbol,\" }\"] \n                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace\n                                                        }]\n                                                    }\n                                                })()\n                                            };\n                                            let __array__357=[],__elements__355=await values((await resolve_path([\"*env_config*\",\"imports\"],Environment.global_ctx.scope)|| new Object()));\n                                            let __BREAK__FLAG__=false;\n                                            for(let __iter__354 in __elements__355) {\n                                                __array__357.push(await __for_body__356(__elements__355[__iter__354]));\n                                                if(__BREAK__FLAG__) {\n                                                     __array__357.pop();\n                                                    break;\n                                                    \n                                                }\n                                            }return __array__357;\n                                             \n                                        })())\n                                    } else {\n                                        return new Object()\n                                    }\n                                })()],[\"symbols\",await (async function(){\n                                     return [\"=:javascript\",await compile(await to_object(exports),{\n                                        throw_on_error:true\n                                    })] \n                                })()],[\"children_declarations\",await (async function(){\n                                     return [\"=:fn\",[],await clone(children_declarations)] \n                                })()],[\"child_load_order\",await (async function(){\n                                     return await (await get_global(\"each\"))(child_export_order,0) \n                                })()],[\"children\",my_children]] \n                            })())] \n                        })());\n                        output_path=await (async function(){\n                            if (check_true (options.want_buffer)){\n                                return null\n                            } else {\n                                return (options.save_as|| await resolve_path([\"*env_config*\",\"export\",\"save_path\"],Environment.global_ctx.scope))\n                            }\n                        })();\n                        if (check_true (output_path instanceof Function)){\n                            output_path=await (async function(){\n                                let __array_op_rval__359=output_path;\n                                 if (__array_op_rval__359 instanceof Function){\n                                    return await __array_op_rval__359() \n                                } else {\n                                    return [__array_op_rval__359]\n                                }\n                            })()\n                        };\n                        if (check_true ((await not((output_path instanceof String || typeof output_path==='string'))&& output_path))){\n                            throw new EvalError(\"invalid name for target for saving the environment.  Must be a string or function\");\n                            \n                        };\n                        return await async function(){\n                            if (check_true ((want_buffer|| (output_path&& await ends_with_ques_(\".js\",output_path))))) {\n                                {\n                                    (build_headers).push((\"// Build Time: \"+ build_time));\n                                    (build_headers).push((\"// Version: \"+ version_tag));\n                                    (build_headers).push((\"export const DLISP_ENV_VERSION='\"+ version_tag+ \"';\"));\n                                    await env_log(\"saving to: \",output_path);\n                                    return await (await get_global(\"compile_buffer\"))(src,\"init_dlisp\",{\n                                        namespace:namespace,toplevel:true,include_boilerplate:false,verbose:false,bundle:true,want_buffer:want_buffer,imports:await (async function(){\n                                            if (check_true (preserve_imports)){\n                                                return await resolve_path([\"*env_config*\",\"imports\"],Environment.global_ctx.scope)\n                                            }\n                                        })(),js_headers:await (async function(){\n                                             return [await (await get_global(\"show\"))(check_true),await (async function(){\n                                                 return await (await get_global(\"show\"))(get_next_environment_id) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(get_outside_global) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(subtype) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(lisp_writer) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(clone) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(LispSyntaxError) \n                                            })()] \n                                        })(),bundle_options:{\n                                            default_namespace:await resolve_path([\"*env_config*\",\"export\",\"default_namespace\"],Environment.global_ctx.scope)\n                                        },output_file:output_path,include_source:(options.include_source|| await resolve_path([\"*env_config*\",\"export\",\"include_source\"],Environment.global_ctx.scope)),build_headers:build_headers\n                                    })\n                                }\n                            } else if (check_true ((output_path&& await ends_with_ques_(\".lisp\",output_path)))) {\n                                return await (await get_global(\"write_text_file\"))(output_path,await JSON.stringify(src,null,4))\n                            } else {\n                                return src\n                            }\n                        } ()\n                    }],[\"null\",null]]"] 
        })()] 
    })(),sys:await (async function(){
         return [{"meta_for_symbol":{"core_lang":true,"description":"Given a quoted symbol and a boolean indicating whether or not all namespaces should be searched, returns the meta data associated with the symbol for each environment.  If search mode is requested, the value returned is an array, since there can be symbols with the same name in different environments. If no values are found an empty array is returned.  If not in search mode, meta_for_symbol searches the current namespace only, and if a matching symbol is found, returns an object with all found metadata, otherwise nil is returned.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["describe","meta","help","definition","symbol","metadata"]},"describe":{"core_lang":true,"description":"Given a quoted symbol returns the relevant metadata pertinent to the current namespace context.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["meta","help","definition","symbol","metadata","info","meta_for_symbol"]},"undefine":{"core_lang":true,"description":"Given a quoted symbol removes the symbol and any definition information from the namespace. If the namespace is fully-qualified, then the symbol will be removed from the specified namespace instead of the currently active namespace. If the symbol is successfully removed, the function will return true, otherwise if it is not found, false will be returned.  Note that if the specified symbol is non-qualified, but exists in a different, accessible namespace, but the symbol isn't present in the current namespace, the symbol will not be deleted.  The environment is not searched and therefore symbols have to be explicitly fully-qualified for any effect of this function outside the current namespace.","usage":["quoted_symbol:string"],"tags":["symbol","delete","remove","unintern","reference","value"]},"*namespace*":{"core_lang":true},"pend_load":{"core_lang":true,"description":"When used as an initializer wrapper via the use_symbols macro, the wrapped initializer will not be loaded until the from_namespace is loaded to ensure that the wrapped initializer won't fail due to not yet loaded dependencies.","usage":["from_namespace:string","target_namespace:string","symbol:string","initializer:array"],"tags":["symbol","definitions","namespace","scope","dependency","dependencies","require"]},"symbols":{"core_lang":true,"description":"Returns an array of the defined global symbols for the local environment.  If opts.unique is true, only symbols that are not part of the built ins are included.","usage":["opts:object"],"tags":["symbol","names","definitions","values","scope"]},"set_global":{"core_lang":true},"get_global":{"core_lang":true},"symbol_definition":{"core_lang":true,"description":"Given a symbol name and an optional namespace, either as a fully qualified path or via the target_namespace argument, returns definition information about the retquested symbol.  Used primarily by the compiler to find metadata for a specific symbol during compilation.","usage":["symname:string","namespace:string"],"tags":["compiler","symbols","namespace","search","context","environment"]},"compile":{"core_lang":true,"description":"Compiles the given JSON or quoted lisp and returns a string containing the lisp form or expression as javascript.<br>If passed the option { meta: true } , an array is returned containing compilation metadata in element 0 and the compiled code in element 1.","usage":["json_expression:*","opts:object"],"tags":["macro","quote","quotes","desym","compiler"]},"env_log":{"core_lang":true,"description":"The environment logging function used by the environment.","usage":["arg0:*","argN:*"]},"evaluate_local":{"core_lang":true},"evaluate":{"core_lang":true},"eval_struct":{"core_lang":true},"exec":{"name":"exec","fn_args":"(command options)","description":["=:+","The exec function spawns a subprocess using the `Deno.run` facility. ","The command and the arguments to execute is provided as a string or an array of ","strings (which form the command), and returns a `Process` object which contains ","details about the spawned process, including process id, resource id, `stdout`, ","`stderr` and `stdin` streams.<br>For more details on this command see the ","documentation for Deno.run and Deno.Process.<br>Example:```(text_decode (-> ","(sys/exec \"uptime\") `output))```<br><br> "],"usage":["command:string|array","options:object"],"tags":["exec","run","process","subprocess","command"],"requires":["is_string?","split_by","is_array?","is_object?","add"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"system":{"name":"system","fn_args":"(command)","description":["=:+","Given a command string or an array with the command and arguments, the ","system function calls the sys/exec function with the command, collects the ","results and returns a serializable object. This facility provides a simple ","mechanism for running external commands and collecting the return values prior ","to further operations. The returned simple object contains:<br>stdout:string - ","The standard output that the evaluated command returned.<br>stderr:string - ","Any error output that was produced by the executed command.<br>success:boolean ","- If the command returned 0, then success will be 0.<br>code:integer - The ","return code of the process.<br>"],"usage":["command:string|array"],"tags":["exec","run","process","subprocess","command"],"requires":["exec","add","decode_text"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"request":{"name":"request","fn_args":"[]","description":"Requests 'run' permissions from the virtual machine.","usage":[],"tags":["permissions","run","process","subproces"],"requires":[],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"compile_executable":{"name":"compile_executable","fn_args":"(options)","description":["=:+","The compile_executable function generates a stand-alone executable from ","a source javascript file. This can be useful for bundling and distributing ","into a single runtime the application logic and all dependencies. The output ","varies on the options object provided. If no options are provided, the ","`*env_config*` object is referenced for default locations and names, and the ","current permission set is used for the emitted binary. If successful, an ","object is returned with `sucess` set to `true` and an `emitted` key indicating ","where the binary was written.<br><br>#### Options <br><br>emit_as:string - A ","path name to the location to which to write the binary executable file. By ","default this value is sourced from `*env_config*.exports.save_executable`. If ","that is not present, then the file is emitted in the current directory with the ","form `juno.{*env_config*.build}`.<br>permissions:array - A list of ","permissions to be allowed in the emitted executable file. The current ","permissions can be accessed with the `(permissions)` function. Include only ","the key names, such as `read` or `net` that you wish to retain in the emitted ","binary.<br>additional_args:array - A list of command line arguments to be ","passed to the Deno compile command.<br>source:string - The source file to be ","used as the bundled image. By default this value is taken from ","`*env_config*.exports.save_path`<br>target:string - The target architecture to ","emit as. See `deno compile --help` to see the full list of values ","available.<br> "],"usage":["options:object"],"tags":["compile","build","image","save","executable","export"],"requires":["permissions","is_array?","push","pairs","resolve_path","*env_config*","join","flatten","is_string?","not","blank?","system"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"stat":{"name":"stat","fn_args":"(filepath)","description":["=:+","<br><br>Given a path to a file as a string, returns a FileInfo object, which ","will contain the results of the `stat()` system ","call:```isFile:Boolean\nisDirectory:Boolean\nisSymlink:Boolean","\nsize:Number\nmtime:Date\natime:Date\nbirthtime:Date\ndev:Number\n","ino:Number\nmode:Number\nnlink:Number\nuid:Number\ngid:Number\nrdev:Number\n","blksize:Number\nblocks:Number```<br> "],"usage":["filepath:string"],"tags":["file","status","information","io","filesystem"],"requires":[],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"is_file?":{"name":"is_file?","fn_args":"(filepath)","description":"Returns true if the provided file path is a file object, otherwise false.","usage":["filepath:string"],"tags":["file","status","information","filesystem"],"requires":["stat"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"is_dir?":{"name":"is_dir?","fn_args":"(filepath)","description":"Returns true if the provided file path is a file object, otherwise false.","usage":["filepath:string"],"tags":["file","directory","status","information","filesystem"],"requires":["stat"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"is_symlink?":{"name":"is_symlink?","fn_args":"(filepath)","description":"Returns true if the provided file path is a symbolic link, otherwise false.","usage":["filepath:string"],"tags":["file","directory","status","information","filesystem"],"requires":["stat"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"filesize":{"name":"filesize","fn_args":"(filepath)","description":["=:+","If the provided path is a file, returns the size of the file. ","Otherwise if the path cannot be found, or the object pointed to by the path ","isn't a file, `nil` will be returned. "],"usage":["filepath:string"],"tags":["file","directory","status","information","filesystem"],"requires":["stat"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"rename":{"name":"rename","fn_args":"(source_path remote_path)","description":["=:+","Given a source path and a target path, renames the source path to the ","target path. If the operation is successful returns true. True is returned ","when the rename operation is validated by a check to ensure that the target ","entry is present in the filesystem (either a file, a directory or a symbolic ","link).<br>If the source file isn't present, or the target file cannot be ","written, an error will be thrown. "],"usage":["source_path:string","remote_path:string"],"tags":["file","directory","status","information","filesystem","move","mv","filename"],"requires":["is_file?","is_dir?","is_symlink?"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"delete_file":{"name":"delete_file","fn_args":"(filepath)","description":["=:+","<br><br>Given a path to a file or symbolic link, the function will remove the entry ","and return true if no errors are encountered. Otherwise, if the target of the ","path isn't a file or link, or the file doesn't exist, returns false.<br> "],"usage":["filepath:string"],"tags":["remove","file","status","information","filesystem"],"requires":["stat"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"delete_dir":{"name":"delete_dir","fn_args":"(dirpath)","description":["=:+","<br><br>Given a path to a directory, the function will remove the directory and any ","content and return true if no errors are encountered. Otherwise, if the target of ","the path isn't a file or the file doesn't exist, returns false.<br> "],"usage":["dirpath:string"],"tags":["remove","directory","status","information","filesystem"],"requires":["is_dir?"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"list_files":{"name":"list_files","fn_args":"(dirpath details?)","description":["=:+","The list files returns a list of DirEntry objects for the provided ","directory. Otherwise if the path isn't a directory or the path doesn't exist, ","it will return an empty array. <br>If `details?` is true, the full `stat` data ","for each entry in the directory is provided in the response. "],"usage":["dirpath:string","details?:?boolean"],"tags":["directory","status","information","filesystem"],"requires":["is_dir?","push","stat"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"mkdir":{"name":"mkdir","fn_args":"(dirpath options)","description":["=:+","Given a string as a path, synchronously creates a new directory, or ","directory tree. If the directory already exists, the function will throw an ","error.<br><br>#### Options <br><br>recursive:boolean - If true, the parent ","directory structure will be created. All parent directories are set to the ","same permissions. Will not throw an error if a directory already ","exists.<br>mode:number - The permissions for the created directory ","structure.<br> "],"usage":["dirpath:string","options:?object"],"tags":["directory","tree","make","create","folder","filesystem"],"requires":["is_dir?"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"ensure_path_exists":{"name":"ensure_path_exists","fn_args":"(fspath options)","description":["=:+","Given a path to a file or a directory, `ensure_path_exists` will return ","true if the file or directory exists, or if it doesn't exist, it will create ","the specified path. By default, the function assumes that the provided path is ","a path to a file and so will treat the last segment of the path as a file to be ","created. However, if the `dir` flag is `true` in options, the final path ","component will be created as a directory. The function returns true if the ","file already exists or was created, or will throw an error if the file or ","directory path cannot be made.<br><br>#### Options <br><br>dir:boolean - If ","true, the final segment of the path will be created as a ","directory.<br>mode:number - If provided, the specified path will be constructed ","with the permissions set to the provided mode, which is usually specified in ","octal, such as `0o700`.<br> "],"usage":["fspath:string","options:?object"],"tags":["filesystem","path","create","folder","directory","create"],"requires":["is_file?","is_dir?","is_object?","mkdir","add","split_by","join","but_last","not","blank?"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"copy_file":{"name":"copy_file","fn_args":"(from_path to_path)","description":["=:+","Given a `from_path` and a `to_path`, copy_file will synchronously copy ","the file located a `from_path` to the `to_path` location. If the operations ","fails, the function will throw an error, otherwise it will return true if ","successful. "],"usage":["from_path:string","to_path:string"],"tags":["filesystem","path","copy","clone","directory"],"requires":["is_string?","is_file?"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"watch_fs":{"name":"watch_fs","fn_args":"(paths options)","description":["=:+","Given a path, or an array of paths, creates and returns an ","`FSWatcher`. The provided paths can be files or directories and they must ","already exist. When file system events occur in the watched paths (or ","potentially subpaths), events are then created and returned via the `FSWatcher` ","object.<br>Event firing orders are not guaranteed to be returned in ","chronological order.<br>Once the path or paths are no longer required to be ","watched, the `FSWatcher` object should be closed by calling the `close` method ","of the watcher.<br><br>#### Options  <br><br>recursive:boolean -If true, the ","subpaths of provided watch directories will also be watched.<br><br>#### ","Example <br>```(let\n   ((watcher (watch_fs \"/tmp\")))\n   (setTimeout (fn ()\n    ","             (progn\n                     (-> watcher `close)\n                  ","  (log \"closed watcher\")))\n               10000)\n   (for_with (event watcher)\n ","    (log \"FS EVENT: \" event)))\n```<br><br>If a file is then created in the ","`/tmp` directory while the block is running, an event will be produced on the ","console:```FS EVENT:  { kind: \"create\", paths: [ \"/private/tmp/abc.txt\" ], ","flag: null }```<br><br>"],"usage":["paths:string|array"],"tags":["filesystem","path","watch","events","file","directory"],"requires":[],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"dir_tree":{"name":"dir_tree","fn_args":"(dirpath options)","description":["=:+","The `dir_tree` function recursively follows a directory hierarchy and ","returns a non-nested structure with the contents of the directory and the ","contained sub-directories. The returned value is an array containing ","`DirEntry` objects with the keys`name`, `isFile`, `isDirectory` and ","`isSymlink`.<br>Each `DirEntry` name value will be the full path to the found ","entity: the provided base path to the dir_tree function plus the position of ","the entity in the sub directory structure.<br>An optional `reducer` function ","can be provided to the dir_tree function in options, which will be called with ","the signature `(entry)`. If the reducer function returns a true value for the ","entry when called, the entry will be included in the returned results. If the ","reducer returns false, nil or undefined, the entry will be excluded from the ","final results.<br><br>#### Example <br><br>Find all files that have the ","\".pdf\" extension in a subfolder:```(dir_tree \"/tmp\"\n          {\n             ","`reduce: (function (entry)\n                              (and entry.isFile\n    ","                            (ends_with? \".pdf\" entry.name)))\n         ","})```<br><br><br> "],"usage":["base_path:string","options:?object"],"tags":["directory","folder","recursive","subdirectory","reduce"],"requires":["add","push","list_files","is_dir?"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"make_temp_dir":{"name":"make_temp_dir","fn_args":"(opts)","description":["=:+","<br><br>Makes a temporary directory in the default directory and returns the ","path as a string. See also `with_temp_dir`. <br><br>#### Options ","<br><br>prefix:string - The prefix given to the start of the final temp ","directory name in the constructed path.<br>suffix:string - The suffix given to ","the end of the final temp directory name.<br>dir:string - The explicit path in ","which to construct the temp directory.<br> "],"usage":["opts:options"],"tags":["temp","directory","tmp","filesystem"],"requires":[],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"},"with_temp_dir":{"eval_when":{"compile_time":true},"name":"with_temp_dir","macro":true,"fn_args":"[(tmp_path) \"&\" body_forms]","description":["=:+","The `with_temp_dir` macro creates a temporary named handle which is ","bound to the `tmp_path` argument as a first argument to the macro. The ","remaining forms (macro arguments) are evaluated in a `progn` with the symbol ","name provided to `tmp_path` bound to the path to the temp directory, which is a ","string. As with a `progn` form, the final form's return value is returned from ","the evaluated macro code. Once the provided forms to the macro are completed, ","the temp directory is removed prior to the return value being returned. If an ","exception is encountered during the processing of the provided forms, the ","exception is caught, the temp directory cleaned up and the exception is then ","re-thrown.```(with_temp_dir (tt)\n         (write_text_file (+ tt \"/text.txt\") \n ","                         (+ \"TT was: \" (is_dir? tt) \": \" tt))\n        ","(read_text_file (+ tt \"/text.txt\")))```<br><br><br><br><br> "],"usage":["tmp_path:symbol","body_forms:*"],"tags":["temp","directory","filesystem","tmp"],"requires":["slice"],"externals":["Deno","TypeError","Error","ReferenceError","console"],"source_name":"pkg/sys.juno"}},await (async function(){
             return ["=:javascript","[[\"meta_for_symbol\",function(quoted_symbol,search_mode) {\n                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){\n                            {\n                                let local_data=(Environment.global_ctx.scope[quoted_symbol]|| Environment.definitions[quoted_symbol]);\n                                ;\n                                let acc=[];\n                                ;\n                                if (check_true (search_mode)){\n                                    {\n                                        if (check_true (local_data)){\n                                            {\n                                                (acc).push( ( get_global(\"add\"))({\n                                                    namespace:namespace,name:quoted_symbol,type: subtype(local_data)\n                                                }, ( function(){\n                                                    let it;\n                                                    it=Environment.definitions[quoted_symbol];\n                                                    if (check_true (it)){\n                                                        return it\n                                                    } else {\n                                                        return new Object()\n                                                    }\n                                                })()))\n                                            }\n                                        };\n                                        if (check_true (parent_environment)){\n                                            {\n                                                {\n                                                    let __collector;\n                                                    let __result;\n                                                    let __action;\n                                                    __collector=[];\n                                                    __result=null;\n                                                    __action=function(info) {\n                                                        return (acc).push(info)\n                                                    };\n                                                    ;\n                                                     ( function() {\n                                                        let __for_body__121=function(__item) {\n                                                            __result= __action(__item);\n                                                            if (check_true (__result)){\n                                                                return (__collector).push(__result)\n                                                            }\n                                                        };\n                                                        let __array__122=[],__elements__120= ( function() {\n                                                            {\n                                                                 let __call_target__= parent_environment[\"meta_for_symbol\"].call(parent_environment,quoted_symbol,true), __call_method__=\"flat\";\n                                                                return  __call_target__[__call_method__].call(__call_target__,1)\n                                                            } \n                                                        })();\n                                                        let __BREAK__FLAG__=false;\n                                                        for(let __iter__119 in __elements__120) {\n                                                            __array__122.push( __for_body__121(__elements__120[__iter__119]));\n                                                            if(__BREAK__FLAG__) {\n                                                                 __array__122.pop();\n                                                                break;\n                                                                \n                                                            }\n                                                        }return __array__122;\n                                                         \n                                                    })();\n                                                    __collector\n                                                }\n                                            }\n                                        };\n                                        if (check_true (( length( keys(children))>0))){\n                                            {\n                                                {\n                                                    let __collector;\n                                                    let __result;\n                                                    let __action;\n                                                    __collector=[];\n                                                    __result=null;\n                                                    __action=function(details) {\n                                                        return (acc).push(details)\n                                                    };\n                                                    ;\n                                                     ( function() {\n                                                        let __for_body__125=function(__item) {\n                                                            __result= __action(__item);\n                                                            if (check_true (__result)){\n                                                                return (__collector).push(__result)\n                                                            }\n                                                        };\n                                                        let __array__126=[],__elements__124= ( function(){\n                                                            let ____collector__127=  function(){\n                                                                return []\n                                                            };\n                                                            let ____result__128=  function(){\n                                                                return null\n                                                            };\n                                                            let ____action__129=  function(){\n                                                                return function(child_data) {\n                                                                    if (check_true ( not((child_data['0']=== ( get_global(\"current_namespace\"))())))){\n                                                                        {\n                                                                            return  child_data['1'][\"meta_for_symbol\"].call(child_data['1'],quoted_symbol)\n                                                                        }\n                                                                    }\n                                                                }\n                                                            };\n                                                            {\n                                                                let __collector= ____collector__127();\n                                                                ;\n                                                                let __result= ____result__128();\n                                                                ;\n                                                                let __action= ____action__129();\n                                                                ;\n                                                                ;\n                                                                 ( function() {\n                                                                    let __for_body__132=function(__item) {\n                                                                        __result= __action(__item);\n                                                                        if (check_true (__result)){\n                                                                            return (__collector).push(__result)\n                                                                        }\n                                                                    };\n                                                                    let __array__133=[],__elements__131= pairs(children);\n                                                                    let __BREAK__FLAG__=false;\n                                                                    for(let __iter__130 in __elements__131) {\n                                                                        __array__133.push( __for_body__132(__elements__131[__iter__130]));\n                                                                        if(__BREAK__FLAG__) {\n                                                                             __array__133.pop();\n                                                                            break;\n                                                                            \n                                                                        }\n                                                                    }return __array__133;\n                                                                     \n                                                                })();\n                                                                return __collector\n                                                            }\n                                                        })();\n                                                        let __BREAK__FLAG__=false;\n                                                        for(let __iter__123 in __elements__124) {\n                                                            __array__126.push( __for_body__125(__elements__124[__iter__123]));\n                                                            if(__BREAK__FLAG__) {\n                                                                 __array__126.pop();\n                                                                break;\n                                                                \n                                                            }\n                                                        }return __array__126;\n                                                         \n                                                    })();\n                                                    __collector\n                                                }\n                                            }\n                                        };\n                                        return acc\n                                    }\n                                } else {\n                                    {\n                                        quoted_symbol= ( function(){\n                                            if (check_true ( starts_with_ques_( ( function(){\n                                                 return \"=:\" \n                                            })(),quoted_symbol))){\n                                                return  quoted_symbol[\"substr\"].call(quoted_symbol,2)\n                                            } else {\n                                                return quoted_symbol\n                                            }\n                                        })();\n                                        {\n                                            let it;\n                                            it=Environment.definitions[quoted_symbol];\n                                            if (check_true (it)){\n                                                return  ( get_global(\"add\"))({\n                                                    namespace:namespace,type: sub_type(local_data),name:quoted_symbol\n                                                },it)\n                                            } else {\n                                                return null\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }],[\"describe\",async function(quoted_symbol,search_mode) {\n                        let internal_results=await meta_for_symbol(quoted_symbol,true);\n                        ;\n                        if (check_true (((internal_results instanceof Array)&& internal_results['0']))){\n                            if (check_true (search_mode)){\n                                return internal_results\n                            } else {\n                                return await first(internal_results)\n                            }\n                        } else {\n                            {\n                                let external_results=await get_outside_global(quoted_symbol);\n                                ;\n                                if (check_true (external_results)){\n                                    {\n                                        let detail={\n                                            location:\"external\",type:await subtype(external_results),name:quoted_symbol,namespace:\"EXTERNAL\",description:(\"This is not a bound symbol within the Juno Environment.  \"+ \"If it is to be used, it is recommended to create a reference to it with \"+ \"`(defglobal \"+ quoted_symbol+ \" \"+ quoted_symbol+ \" { `description: \\\"...\\\" })`\")\n                                        };\n                                        ;\n                                        if (check_true (search_mode)){\n                                            return await (async function(){\n                                                let __array_op_rval__136=detail;\n                                                 if (__array_op_rval__136 instanceof Function){\n                                                    return await __array_op_rval__136() \n                                                } else {\n                                                    return [__array_op_rval__136]\n                                                }\n                                            })()\n                                        } else {\n                                            return detail\n                                        }\n                                    }\n                                } else {\n                                    return null\n                                }\n                            }\n                        }\n                    }],[\"undefine\",function(quoted_symbol) {\n                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){\n                            {\n                                let namespace_identity;\n                                let parent_call;\n                                let child_call;\n                                let target_symbol;\n                                namespace_identity=(quoted_symbol).split(\"/\");\n                                parent_call=null;\n                                child_call=null;\n                                target_symbol=null;\n                                ;\n                                return   (function(){\n                                    if (check_true ((((namespace_identity.length===1)&& Environment.global_ctx.scope[namespace_identity['0']])|| ((namespace_identity.length>1)&& (namespace_identity['0']===namespace))))) {\n                                        {\n                                            target_symbol= ( function(){\n                                                if (check_true ((namespace_identity.length>1))){\n                                                    return namespace_identity['1']\n                                                } else {\n                                                    return namespace_identity['0']\n                                                }\n                                            })();\n                                             delete_prop(Environment.definitions,target_symbol);\n                                            if (check_true (Environment.global_ctx.scope[target_symbol])){\n                                                return  delete_prop(Environment.global_ctx.scope,target_symbol)\n                                            } else {\n                                                return false\n                                            }\n                                        }\n                                    } else if (check_true (((namespace_identity.length>1)&& parent_environment))) {\n                                        {\n                                            parent_call= parent_environment[\"get_global\"].call(parent_environment,\"undefine\");\n                                            return (parent_call)(quoted_symbol)\n                                        }\n                                    } else if (check_true (((namespace_identity.length>1)&& children[namespace_identity['0']]))) {\n                                        {\n                                            child_call= ( function() {\n                                                {\n                                                     let __call_target__=children[namespace_identity['0']], __call_method__=\"get_global\";\n                                                    return  __call_target__[__call_method__].call(__call_target__,\"undefine\")\n                                                } \n                                            })();\n                                            return  child_call(quoted_symbol)\n                                        }\n                                    } else {\n                                        return false\n                                    }\n                                } )()\n                            }\n                        } else {\n                            throw new SyntaxError(\"undefine requires a quoted symbol\");\n                            \n                        }\n                    }],[\"*namespace*\",\"sys\"],[\"pend_load\",async function(from_namespace,target_namespace,symbol,initializer) {\n                        if (check_true ((null==pending_ns_loads[from_namespace]))){\n                            {\n                                await async function(){\n                                    pending_ns_loads[from_namespace]=[];\n                                    return pending_ns_loads;\n                                    \n                                }()\n                            }\n                        };\n                        (pending_ns_loads[from_namespace]).push({\n                            symbol:symbol,source_ns:from_namespace,target_ns:target_namespace,initializer:await (async function(){\n                                 return [\"=:quote\",initializer] \n                            })()\n                        });\n                        return initializer\n                    }],[\"symbols\",async function(opts) {\n                        return await async function(){\n                            if (check_true ((null==opts))) {\n                                return await keys(Environment.global_ctx.scope)\n                            } else if (check_true (opts.unique)) {\n                                {\n                                    let no_includes=await make_set(await conj([\"meta_for_symbol\",\"describe\",\"undefine\",\"*namespace*\",\"pend_load\",\"symbols\",\"set_global\",\"get_global\",\"symbol_definition\",\"compile\",\"env_log\",\"evaluate_local\",\"evaluate\",\"eval_struct\",\"set_compiler\",\"clone\",\"eval\",\"add_escape_encoding\",\"get_outside_global\",\"as_lisp\",\"lisp_writer\",\"clone_to_new\",\"save_env\",\"null\",\"compiler\"],built_ins));\n                                    ;\n                                    {\n                                        let __collector;\n                                        let __result;\n                                        let __action;\n                                        __collector=[];\n                                        __result=null;\n                                        __action=async function(sym) {\n                                            if (check_true (await no_includes[\"has\"].call(no_includes,sym))){\n                                                return null\n                                            } else {\n                                                return sym\n                                            }\n                                        };\n                                        ;\n                                        await (async function() {\n                                            let __for_body__213=async function(__item) {\n                                                __result=await __action(__item);\n                                                if (check_true (__result)){\n                                                    return (__collector).push(__result)\n                                                }\n                                            };\n                                            let __array__214=[],__elements__212=await keys(Environment.global_ctx.scope);\n                                            let __BREAK__FLAG__=false;\n                                            for(let __iter__211 in __elements__212) {\n                                                __array__214.push(await __for_body__213(__elements__212[__iter__211]));\n                                                if(__BREAK__FLAG__) {\n                                                     __array__214.pop();\n                                                    break;\n                                                    \n                                                }\n                                            }return __array__214;\n                                             \n                                        })();\n                                        return __collector\n                                    }\n                                }\n                            }\n                        } ()\n                    }],[\"set_global\",function(refname,value,meta,is_constant,target_namespace,contained_req) {\n                          (function(){\n                            if (check_true ( not((typeof refname===\"string\")))) {\n                                throw new TypeError(\"reference name must be a string type\");\n                                \n                            } else if (check_true (((Environment===value)|| (Environment.global_ctx===value)|| (Environment.global_ctx.scope===value)))) {\n                                {\n                                    throw new EvalError(\"cannot set the environment scope as a global value\");\n                                    \n                                }\n                            }\n                        } )();\n                        if (check_true ( resolve_path( ( function(){\n                            let __array_op_rval__217=refname;\n                             if (__array_op_rval__217 instanceof Function){\n                                return  __array_op_rval__217(\"constant\") \n                            } else {\n                                return [__array_op_rval__217,\"constant\"]\n                            }\n                        })(),Environment.definitions))){\n                            {\n                                throw new TypeError((\"Assignment to constant variable \"+ refname));\n                                \n                            }\n                        };\n                        let namespace_identity= ( function(){\n                            if (check_true (target_namespace)){\n                                return  ( function(){\n                                    let __array_op_rval__218=target_namespace;\n                                     if (__array_op_rval__218 instanceof Function){\n                                        return  __array_op_rval__218(refname) \n                                    } else {\n                                        return [__array_op_rval__218,refname]\n                                    }\n                                })()\n                            } else {\n                                return (refname).split(\"/\")\n                            }\n                        })();\n                        ;\n                        return   (function(){\n                            if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace===namespace_identity['0']))))) {\n                                return  parent_environment[\"set_global\"].call(parent_environment,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'],(contained|| contained_req))\n                            } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                {\n                                    if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){\n                                        return  ( function() {\n                                            {\n                                                 let __call_target__=children[namespace_identity['0']], __call_method__=\"set_global\";\n                                                return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'])\n                                            } \n                                        })()\n                                    } else {\n                                        throw new EvalError((\"namespace \"+ namespace_identity['0']+ \" doesn't exist\"));\n                                        \n                                    }\n                                }\n                            } else {\n                                try {\n                                    let comps= get_object_path( ( function(){\n                                        if (check_true ((1===namespace_identity.length))){\n                                            return namespace_identity['0']\n                                        } else {\n                                            return namespace_identity['1']\n                                        }\n                                    })());\n                                    ;\n                                      (function(){\n                                        Environment.global_ctx.scope[comps['0']]=value;\n                                        return Environment.global_ctx.scope;\n                                        \n                                    })();\n                                    if (check_true (((meta instanceof Object)&&  not((meta instanceof Array))))){\n                                        {\n                                            if (check_true (is_constant)){\n                                                {\n                                                      (function(){\n                                                        meta[\"constant\"]=true;\n                                                        return meta;\n                                                        \n                                                    })()\n                                                }\n                                            };\n                                              (function(){\n                                                Environment.definitions[comps['0']]=meta;\n                                                return Environment.definitions;\n                                                \n                                            })()\n                                        }\n                                    } else {\n                                        if (check_true (is_constant)){\n                                            {\n                                                  (function(){\n                                                    Environment.definitions[comps['0']]={\n                                                        constant:true\n                                                    };\n                                                    return Environment.definitions;\n                                                    \n                                                })()\n                                            }\n                                        }\n                                    };\n                                    return Environment.global_ctx.scope[comps['0']]\n                                } catch (__exception__219) {\n                                    if (__exception__219 instanceof Error) {\n                                        let e=__exception__219;\n                                        {\n                                            {\n                                                let message=(\"Error: set_global: \"+ _star_namespace_star_+ \"symbol name: \"+ refname+ \": \"+ e.message);\n                                                ;\n                                                 console.error(message,[]);\n                                                  (function(){\n                                                    e[\"message\"]=message;\n                                                    return e;\n                                                    \n                                                })();\n                                                throw e;\n                                                \n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } )()\n                    }],[\"get_global\",function(refname,value_if_not_found,suppress_check_external_env,target_namespace,path_comps,contained_req) {\n                        return   (function(){\n                            if (check_true ( not((typeof refname===\"string\")))) {\n                                throw new TypeError(\"reference name must be a string type\");\n                                \n                            } else if (check_true ((refname===\"Environment\"))) {\n                                return Environment\n                            } else if (check_true ( compiler_operators[\"has\"].call(compiler_operators,refname))) {\n                                return special_identity\n                            } else {\n                                {\n                                    let namespace_identity;\n                                    let comps;\n                                    let refval;\n                                    let symbol_name;\n                                    let check_external_env;\n                                    namespace_identity= ( function(){\n                                        if (check_true (target_namespace)){\n                                            return  ( function(){\n                                                let __array_op_rval__227=target_namespace;\n                                                 if (__array_op_rval__227 instanceof Function){\n                                                    return  __array_op_rval__227(refname) \n                                                } else {\n                                                    return [__array_op_rval__227,refname]\n                                                }\n                                            })()\n                                        } else {\n                                            return (refname).split(\"/\")\n                                        }\n                                    })();\n                                    comps=(path_comps||  get_object_path( ( function(){\n                                        if (check_true ((1===namespace_identity.length))){\n                                            return namespace_identity['0']\n                                        } else {\n                                            return namespace_identity['1']\n                                        }\n                                    })()));\n                                    refval=null;\n                                    symbol_name=null;\n                                    check_external_env= ( function(){\n                                        if (check_true (suppress_check_external_env)){\n                                            return false\n                                        } else {\n                                            return check_external_env_default\n                                        }\n                                    })();\n                                    return   (function(){\n                                        if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                            return  parent_environment[\"get_global\"].call(parent_environment,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps,(contained|| contained_req))\n                                        } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                            {\n                                                if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){\n                                                    return  ( function() {\n                                                        {\n                                                             let __call_target__=children[namespace_identity['0']], __call_method__=\"get_global\";\n                                                            return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps)\n                                                        } \n                                                    })()\n                                                } else {\n                                                    {\n                                                        throw new EvalError((\"namespace \"+ namespace_identity['0']+ \" doesn't exist\"));\n                                                        \n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            {\n                                                refval=Environment.global_ctx.scope[comps['0']];\n                                                if (check_true (((undefined===refval)&& (namespace_identity.length===1)&& parent_environment))){\n                                                    {\n                                                        let rval= parent_environment[\"get_global\"].call(parent_environment,refname,value_if_not_found,suppress_check_external_env,null,comps,(contained|| contained_req));\n                                                        ;\n                                                        return rval\n                                                    }\n                                                } else {\n                                                    {\n                                                        if (check_true (((undefined===refval)&& check_external_env))){\n                                                            refval= ( function(){\n                                                                if (check_true (check_external_env)){\n                                                                    return ( get_outside_global(comps['0'])|| NOT_FOUND)\n                                                                } else {\n                                                                    return NOT_FOUND\n                                                                }\n                                                            })()\n                                                        };\n                                                        return   (function(){\n                                                            if (check_true (((NOT_FOUND===refval)&&  not((undefined===value_if_not_found))))) {\n                                                                return value_if_not_found\n                                                            } else if (check_true ((NOT_FOUND===refval))) {\n                                                                {\n                                                                    throw new ReferenceError((\"symbol not found: \"+  ( function(){\n                                                                        if (check_true ((namespace_identity.length>1))){\n                                                                            return  add(namespace,\"/\",namespace_identity['1'])\n                                                                        } else {\n                                                                            return  add(namespace,\"/\",namespace_identity['0'])\n                                                                        }\n                                                                    })()));\n                                                                    \n                                                                }\n                                                            } else if (check_true ((comps.length===1))) {\n                                                                return refval\n                                                            } else if (check_true ((comps.length>1))) {\n                                                                {\n                                                                    return  resolve_path( rest(comps),refval)\n                                                                }\n                                                            } else {\n                                                                {\n                                                                     console.warn(\"get_global: condition fall through: \",comps);\n                                                                    return NOT_FOUND\n                                                                }\n                                                            }\n                                                        } )()\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } )()\n                                }\n                            }\n                        } )()\n                    }],[\"symbol_definition\",async function(symname,target_namespace) {\n                        let namespace_identity;\n                        namespace_identity=await (async function(){\n                            if (check_true (target_namespace)){\n                                return await (async function(){\n                                    let __array_op_rval__230=target_namespace;\n                                     if (__array_op_rval__230 instanceof Function){\n                                        return await __array_op_rval__230(symname) \n                                    } else {\n                                        return [__array_op_rval__230,symname]\n                                    }\n                                })()\n                            } else {\n                                if (check_true ((await length(symname)>2))){\n                                    return (symname).split(\"/\")\n                                } else {\n                                    return await (async function(){\n                                        let __array_op_rval__231=symname;\n                                         if (__array_op_rval__231 instanceof Function){\n                                            return await __array_op_rval__231() \n                                        } else {\n                                            return [__array_op_rval__231]\n                                        }\n                                    })()\n                                }\n                            }\n                        })();\n                        return await async function(){\n                            if (check_true ((namespace_identity.length===1))) {\n                                {\n                                    let it;\n                                    it=Environment.definitions[symname];\n                                    if (check_true (it)){\n                                        return it\n                                    } else {\n                                        if (check_true (parent_environment)){\n                                            return await parent_environment[\"symbol_definition\"].call(parent_environment,symname)\n                                        }\n                                    }\n                                }\n                            } else if (check_true ((namespace_identity['0']===namespace))) {\n                                return Environment.definitions[symname]\n                            } else if (check_true (parent_environment)) {\n                                return await parent_environment[\"symbol_definition\"].call(parent_environment,namespace_identity['1'],namespace_identity['0'])\n                            } else if (check_true ((namespace_identity.length===2))) {\n                                return await (async function() {\n                                    {\n                                         let __call_target__=children[namespace_identity['0']], __call_method__=\"symbol_definition\";\n                                        return await __call_target__[__call_method__].call(__call_target__,namespace_identity['1'])\n                                    } \n                                })()\n                            } else {\n                                return undefined\n                            }\n                        } ()\n                    }],[\"compile\",async function(json_expression,opts) {\n                        let out;\n                        opts=await add({\n                            env:Environment\n                        },opts,{\n                            meta:await (async function(){\n                                if (check_true ((opts&& opts.meta))){\n                                    return true\n                                } else {\n                                    return false\n                                }\n                            })()\n                        });\n                        out=null;\n                        out=await (async function(){\n                             return await compiler(json_expression,opts) \n                        })();\n                        return await async function(){\n                            if (check_true (((out instanceof Array)&& out['0'].ctype&& (out['0'].ctype===\"FAIL\")))) {\n                                return out\n                            } else if (check_true (opts.meta)) {\n                                return out\n                            } else {\n                                return out['1']\n                            }\n                        } ()\n                    }],[\"env_log\",async function(...args) {\n                            return await (async function(){\n                                let __target_arg__189=[].concat(await conj(await (async function(){\n                                    let __array_op_rval__190=style;\n                                     if (__array_op_rval__190 instanceof Function){\n                                        return await __array_op_rval__190() \n                                    } else {\n                                        return [__array_op_rval__190]\n                                    }\n                                })(),args));\n                                if(!__target_arg__189 instanceof Array){\n                                    throw new TypeError(\"Invalid final argument to apply - an array is required\")\n                                }let __pre_arg__191=(\"%c\"+ await (async function(){\n                                    if (check_true (opts.prefix)){\n                                        return opts.prefix\n                                    } else {\n                                        return (args).shift()\n                                    }\n                                })());\n                                __target_arg__189.unshift(__pre_arg__191);\n                                return (console.log).apply(this,__target_arg__189)\n                            })()\n                        }],[\"evaluate_local\",async function(expression,ctx,opts) {\n                        let compiled;\n                        let error_data;\n                        let requires;\n                        let precompiled_assembly;\n                        let result;\n                        opts=(opts|| new Object());\n                        compiled=null;\n                        error_data=null;\n                        requires=null;\n                        precompiled_assembly=null;\n                        result=null;\n                        if (check_true (opts.compiled_source)){\n                            compiled=expression\n                        } else {\n                            try {\n                                compiled=await (async function(){\n                                     return await compiler(await (async function(){\n                                        if (check_true (opts.json_in)){\n                                            return expression\n                                        } else {\n                                            return await Environment[\"read_lisp\"].call(Environment,expression,{\n                                                source_name:opts.source_name\n                                            })\n                                        }\n                                    })(),{\n                                        env:Environment,ctx:ctx,formatted_output:true,source_name:opts.source_name,throw_on_error:opts.throw_on_error,on_final_token_assembly:async function(val) {\n                                            return precompiled_assembly=val\n                                        },error_report:(opts.error_report|| null),quiet_mode:(opts.quiet_mode|| false)\n                                    }) \n                                })()\n                            } catch (__exception__238) {\n                                if (__exception__238 instanceof Error) {\n                                    let e=__exception__238;\n                                    {\n                                        {\n                                            if (check_true (opts.throw_on_error)){\n                                                {\n                                                    throw e;\n                                                    \n                                                }\n                                            };\n                                            if (check_true ((e instanceof LispSyntaxError))){\n                                                {\n                                                    await async function(){\n                                                        e[\"message\"]=await JSON.parse(e.message);\n                                                        return e;\n                                                        \n                                                    }()\n                                                }\n                                            };\n                                            await async function(){\n                                                if (check_true ((e instanceof LispSyntaxError))) {\n                                                    return error_data=await add({\n                                                        error:\"LispSyntaxError\"\n                                                    },e.message)\n                                                } else {\n                                                    error_data={\n                                                        error:await sub_type(e),message:e.message,stack:e.stack,form:await (async function(){\n                                                             return await async function(){\n                                                                if (check_true (((expression instanceof String || typeof expression==='string')&& (expression.length>100)))) {\n                                                                    return await add(await expression[\"substr\"].call(expression,0,100),\"...\")\n                                                                } else {\n                                                                    return await (await get_global(\"as_lisp\"))(expression)\n                                                                }\n                                                            } () \n                                                        })(),parent_forms:[],source_name:opts.source_name,invalid:true\n                                                    }\n                                                }\n                                            } ();\n                                            if (check_true (opts.error_report)){\n                                                await (async function(){\n                                                    let __array_op_rval__240=opts.error_report;\n                                                     if (__array_op_rval__240 instanceof Function){\n                                                        return await __array_op_rval__240(error_data) \n                                                    } else {\n                                                        return [__array_op_rval__240,error_data]\n                                                    }\n                                                })()\n                                            } else {\n                                                await console.error(\"Compilation Error: \",error_data)\n                                            };\n                                            compiled=await (async function(){\n                                                 return [{\n                                                    error:true\n                                                },null] \n                                            })()\n                                        }\n                                    }\n                                }\n                            }\n                        };\n                        return await async function(){\n                            if (check_true ((null==compiled))) {\n                                return null\n                            } else if (check_true ((compiled['0'].ctype===\"FAIL\"))) {\n                                {\n                                    if (check_true (opts.error_report)){\n                                        {\n                                            await (async function(){\n                                                let __array_op_rval__241=opts.error_report;\n                                                 if (__array_op_rval__241 instanceof Function){\n                                                    return await __array_op_rval__241(compiled['1']) \n                                                } else {\n                                                    return [__array_op_rval__241,compiled['1']]\n                                                }\n                                            })()\n                                        }\n                                    };\n                                    return await async function(){\n                                        if (check_true ((compiled['1'] instanceof Error))) {\n                                            throw compiled['1'];\n                                            \n                                        } else if (check_true ((compiled['1']['0'] instanceof Error))) {\n                                            throw compiled['1']['0'];\n                                            \n                                        } else if (check_true (((compiled['1']['0'] instanceof Object)&& (compiled['1']['0'].error===\"SyntaxError\")))) {\n                                            {\n                                                let new_error=new SyntaxError(compiled['1']['0'].message);\n                                                ;\n                                                await async function(){\n                                                    new_error[\"from\"]=compiled['1']['0'];\n                                                    return new_error;\n                                                    \n                                                }();\n                                                throw new_error;\n                                                \n                                            }\n                                        } else {\n                                            return compiled['1']\n                                        }\n                                    } ()\n                                }\n                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))&& parent_environment))) {\n                                return await parent_environment[\"evaluate_local\"].call(parent_environment,compiled,ctx,await add(new Object(),opts,{\n                                    compiled_source:true\n                                }))\n                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))))) {\n                                if (check_true (children[compiled['0'].namespace])){\n                                    return await (async function() {\n                                        {\n                                             let __call_target__=children[compiled['0'].namespace], __call_method__=\"evaluate_local\";\n                                            return await __call_target__[__call_method__].call(__call_target__,compiled,ctx,await add(new Object(),opts,{\n                                                compiled_source:true\n                                            }))\n                                        } \n                                    })()\n                                } else {\n                                    throw new EvalError((\"unknown namespace \"+ compiled['0'].namespace+ \" assignment\"));\n                                    \n                                }\n                            } else {\n                                {\n                                    if (check_true (opts.on_compilation_complete)){\n                                        await (async function(){\n                                            let __array_op_rval__243=opts.on_compilation_complete;\n                                             if (__array_op_rval__243 instanceof Function){\n                                                return await __array_op_rval__243(compiled) \n                                            } else {\n                                                return [__array_op_rval__243,compiled]\n                                            }\n                                        })()\n                                    };\n                                    try {\n                                        if (check_true (((compiled instanceof Array)&& (compiled['0'] instanceof Object)&& compiled['0'].ctype&& await not((compiled['0'].ctype instanceof String || typeof compiled['0'].ctype==='string'))))){\n                                            {\n                                                await async function(){\n                                                    compiled['0'][\"ctype\"]=await subtype(compiled['0'].ctype);\n                                                    return compiled['0'];\n                                                    \n                                                }()\n                                            }\n                                        };\n                                        result=await (async function(){\n                                             return await async function(){\n                                                if (check_true (compiled.error)) {\n                                                    throw new Error((await get_global(\"indirect_new\"))(compiled.error,compiled.message));\n                                                    \n                                                } else if (check_true ((compiled['0'].ctype&& (await contains_ques_(\"block\",compiled['0'].ctype)|| (compiled['0'].ctype===\"assignment\")|| (compiled['0'].ctype===\"__!NOT_FOUND!__\"))))) {\n                                                    if (check_true (await (async function(){\n                                                        let __array_op_rval__246=compiled['0'].has_lisp_globals;\n                                                         if (__array_op_rval__246 instanceof Function){\n                                                            return await __array_op_rval__246() \n                                                        } else {\n                                                            return [__array_op_rval__246]\n                                                        }\n                                                    })())){\n                                                        {\n                                                            await async function(){\n                                                                compiled[1]=new AsyncFunction(\"Environment\",(\"{ \"+ compiled['1']+ \"}\"));\n                                                                return compiled;\n                                                                \n                                                            }();\n                                                            return await (async function(){\n                                                                let __array_op_rval__248=compiled['1'];\n                                                                 if (__array_op_rval__248 instanceof Function){\n                                                                    return await __array_op_rval__248(Environment) \n                                                                } else {\n                                                                    return [__array_op_rval__248,Environment]\n                                                                }\n                                                            })()\n                                                        }\n                                                    } else {\n                                                        {\n                                                            await async function(){\n                                                                compiled[1]=new AsyncFunction((\"{\"+ compiled['1']+ \"}\"));\n                                                                return compiled;\n                                                                \n                                                            }();\n                                                            return await (async function(){\n                                                                let __array_op_rval__250=compiled['1'];\n                                                                 if (__array_op_rval__250 instanceof Function){\n                                                                    return await __array_op_rval__250() \n                                                                } else {\n                                                                    return [__array_op_rval__250]\n                                                                }\n                                                            })()\n                                                        }\n                                                    }\n                                                } else if (check_true ((compiled['0'].ctype&& ((\"AsyncFunction\"===compiled['0'].ctype)|| (\"statement\"===compiled['0'].ctype)|| (\"objliteral\"===compiled['0'].ctype))))) {\n                                                    {\n                                                        if (check_true (await (async function(){\n                                                            let __array_op_rval__251=compiled['0'].has_lisp_globals;\n                                                             if (__array_op_rval__251 instanceof Function){\n                                                                return await __array_op_rval__251() \n                                                            } else {\n                                                                return [__array_op_rval__251]\n                                                            }\n                                                        })())){\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new AsyncFunction(\"Environment\",(\"{ return \"+ compiled['1']+ \"} \"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__253=compiled['1'];\n                                                                     if (__array_op_rval__253 instanceof Function){\n                                                                        return await __array_op_rval__253(Environment) \n                                                                    } else {\n                                                                        return [__array_op_rval__253,Environment]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        } else {\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new AsyncFunction((\"{ return \"+ compiled['1']+ \"}\"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__255=compiled['1'];\n                                                                     if (__array_op_rval__255 instanceof Function){\n                                                                        return await __array_op_rval__255() \n                                                                    } else {\n                                                                        return [__array_op_rval__255]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        }\n                                                    }\n                                                } else if (check_true ((compiled['0'].ctype&& (\"Function\"===compiled['0'].ctype)))) {\n                                                    {\n                                                        if (check_true (await (async function(){\n                                                            let __array_op_rval__256=compiled['0'].has_lisp_globals;\n                                                             if (__array_op_rval__256 instanceof Function){\n                                                                return await __array_op_rval__256() \n                                                            } else {\n                                                                return [__array_op_rval__256]\n                                                            }\n                                                        })())){\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new Function(\"Environment\",(\"{ return \"+ compiled['1']+ \"} \"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__258=compiled['1'];\n                                                                     if (__array_op_rval__258 instanceof Function){\n                                                                        return await __array_op_rval__258(Environment) \n                                                                    } else {\n                                                                        return [__array_op_rval__258,Environment]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        } else {\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new Function((\"{ return \"+ compiled['1']+ \"}\"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__260=compiled['1'];\n                                                                     if (__array_op_rval__260 instanceof Function){\n                                                                        return await __array_op_rval__260() \n                                                                    } else {\n                                                                        return [__array_op_rval__260]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        }\n                                                    }\n                                                } else {\n                                                    return compiled['1']\n                                                }\n                                            } () \n                                        })()\n                                    } catch (__exception__244) {\n                                        if (__exception__244 instanceof Error) {\n                                            let e=__exception__244;\n                                            {\n                                                {\n                                                    if (check_true (true)){\n                                                        {\n                                                            let details={\n                                                                error:e.name,message:e.message,expanded_source:await (await get_global(\"pretty_print\"))(await (async function(){\n                                                                     return await (await get_global(\"detokenize\"))(precompiled_assembly) \n                                                                })()),compiled:compiled['1']\n                                                            };\n                                                            ;\n                                                            console.log(\"Syntax Error: \",details);\n                                                            await async function(){\n                                                                e[\"details\"]=details;\n                                                                return e;\n                                                                \n                                                            }()\n                                                        }\n                                                    };\n                                                    if (check_true ((opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4)))){\n                                                        {\n                                                            if (check_true (e.details)){\n                                                                await env_log(\"caught error: \",e.details)\n                                                            } else {\n                                                                await env_log(\"caught error: \",e.name,e.message,e)\n                                                            }\n                                                        }\n                                                    };\n                                                    if (check_true ((false&& (await sub_type(e)===\"SyntaxError\")&& (opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4))))){\n                                                        await console.log(compiled['1'])\n                                                    };\n                                                    if (check_true (opts.error_report)){\n                                                        {\n                                                            await (async function(){\n                                                                let __array_op_rval__262=opts.error_report;\n                                                                 if (__array_op_rval__262 instanceof Function){\n                                                                    return await __array_op_rval__262(await (async function(){\n                                                                        if (check_true (e.details)){\n                                                                            return e.details\n                                                                        } else {\n                                                                            return {\n                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack\n                                                                            }\n                                                                        }\n                                                                    })()) \n                                                                } else {\n                                                                    return [__array_op_rval__262,await (async function(){\n                                                                        if (check_true (e.details)){\n                                                                            return e.details\n                                                                        } else {\n                                                                            return {\n                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack\n                                                                            }\n                                                                        }\n                                                                    })()]\n                                                                }\n                                                            })()\n                                                        }\n                                                    };\n                                                    result=e;\n                                                    if (check_true ((await not(opts.catch_errors)|| (ctx&& ctx.in_try)))){\n                                                        {\n                                                            throw result;\n                                                            \n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    };\n                                    return result\n                                }\n                            }\n                        } ()\n                    }],[\"evaluate\",async function(expression,ctx,opts) {\n                        return await async function(){\n                            if (check_true ((namespace===active_namespace))) {\n                                return await evaluate_local(expression,ctx,opts)\n                            } else if (check_true ((namespace===\"core\"))) {\n                                return await (async function() {\n                                    {\n                                         let __call_target__=children[active_namespace], __call_method__=\"evaluate\";\n                                        return await __call_target__[__call_method__].call(__call_target__,expression,ctx,opts)\n                                    } \n                                })()\n                            }\n                        } ()\n                    }],[\"eval_struct\",async function(lisp_struct,ctx,opts) {\n                        let rval;\n                        rval=null;\n                        if (check_true (lisp_struct instanceof Function)){\n                            rval=await (async function(){\n                                let __array_op_rval__267=lisp_struct;\n                                 if (__array_op_rval__267 instanceof Function){\n                                    return await __array_op_rval__267() \n                                } else {\n                                    return [__array_op_rval__267]\n                                }\n                            })()\n                        } else {\n                            rval=await (async function(){\n                                 return await evaluate(lisp_struct,ctx,await add({\n                                    json_in:true\n                                },(opts|| new Object()))) \n                            })()\n                        };\n                        return rval\n                    }],[\"set_compiler\",async function(compiler_function) {\n                        let new_ops;\n                        new_ops=await (async function(){\n                            let __array_op_rval__271=compiler_function;\n                             if (__array_op_rval__271 instanceof Function){\n                                return await __array_op_rval__271([],{\n                                    special_operators:true,env:Environment\n                                }) \n                            } else {\n                                return [__array_op_rval__271,[],{\n                                    special_operators:true,env:Environment\n                                }]\n                            }\n                        })();\n                        if (check_true (await is_set_ques_(new_ops))){\n                            {\n                                compiler_operators=new_ops;\n                                compiler=compiler_function;\n                                await async function(){\n                                    Environment.global_ctx.scope[\"compiler\"]=compiler;\n                                    return Environment.global_ctx.scope;\n                                    \n                                }();\n                                await (await get_global(\"register_feature\"))(\"compiler\")\n                            }\n                        } else {\n                            {\n                                await console.error(\"Invalid compiler function: invalid operators returned. Not installing.\");\n                                throw new EvalError(\"Invalid compiler function\");\n                                \n                            }\n                        };\n                        return compiler\n                    }],[\"clone\",async function(val) {\n                            if (check_true ((val===Environment))){\n                                return Environment\n                            } else {\n                                return await clone(val,0,Environment)\n                            }\n                        }],[\"eval\",async function(expression) {\n                        return await (async function(){\n                            let __array_op_rval__141=expression;\n                             if (__array_op_rval__141 instanceof Function){\n                                return await __array_op_rval__141() \n                            } else {\n                                return [__array_op_rval__141]\n                            }\n                        })()\n                    }],[\"add_escape_encoding\",async function(text) {        if (check_true ((text instanceof String || typeof text==='string'))){            let chars;            let acc;            chars=(text).split(\"\");            acc=[];            await (async function() {                let __for_body__3=async function(c) {                     return  await async function(){                        if (check_true( ((await c[\"charCodeAt\"].call(c,0)===34)))) {                            (acc).push(await String.fromCharCode(92));                             return  (acc).push(c)                        } else  {                             return (acc).push(c)                        }                    } ()                };                let __array__4=[],__elements__2=chars;                let __BREAK__FLAG__=false;                for(let __iter__1 in __elements__2) {                    __array__4.push(await __for_body__3(__elements__2[__iter__1]));                    if(__BREAK__FLAG__) {                         __array__4.pop();                        break;                                            }                }return __array__4;                             })();             return  (acc).join(\"\")        } else {              return text        }    }],[\"get_outside_global\",function get_outside_global(refname) {  try {    let tfn = new Function(\"{ if (typeof \" + refname + \" === 'undefined') { return undefined } else { return \"+refname+\" } }\");    return tfn();  } catch (ex) {    return undefined;  }}],[\"as_lisp\",lisp_writer],[\"lisp_writer\",lisp_writer],[\"clone_to_new\",async function(options) {\n                        let new_env;\n                        let my_children;\n                        let my_children_declarations;\n                        new_env=null;\n                        my_children=null;\n                        my_children_declarations=null;\n                        await env_log(namespace,\"cloning: # children: \",await length(children));\n                        new_env=await (async function(){\n                             return await dlisp_env({\n                                env:await (async function(){\n                                     return await clone(Environment) \n                                })(),children:await (async function(){\n                                     return await clone(children) \n                                })(),children_declarations:await (async function(){\n                                     return await clone(children_declarations) \n                                })()\n                            }) \n                        })();\n                        await env_log(namespace,\"constructed: \",await new_env[\"id\"]());\n                        return new_env\n                    }],[\"save_env\",async function(options) {\n                        let new_env;\n                        let my_children;\n                        let env_constructor;\n                        let dcomps;\n                        let version_tag;\n                        let build_time;\n                        let build_headers;\n                        let child_env;\n                        let want_buffer;\n                        let comp_buffer;\n                        let sorted_dependencies;\n                        let child_export_order;\n                        let preserve_imports;\n                        let include_source;\n                        let exports;\n                        let src;\n                        let target_insertion_path;\n                        let output_path;\n                        new_env=null;\n                        my_children=null;\n                        env_constructor=null;\n                        dcomps=await (async function(){\n                             return await (await get_global(\"date_components\"))(new Date()) \n                        })();\n                        options=(options|| new Object());\n                        version_tag=await (async function(){\n                            if (check_true (await not(await blank_ques_(opts.version_tag)))){\n                                return opts.version_tag\n                            } else {\n                                return (await (async function(){\n                                    let __array_op_rval__328=dcomps.year;\n                                     if (__array_op_rval__328 instanceof Function){\n                                        return await __array_op_rval__328(dcomps.month,dcomps.day,dcomps.hour,dcomps.minute) \n                                    } else {\n                                        return [__array_op_rval__328,dcomps.month,dcomps.day,dcomps.hour,dcomps.minute]\n                                    }\n                                })()).join(\".\")\n                            }\n                        })();\n                        build_time=await (async function(){\n                             return await (await get_global(\"formatted_date\"))(new Date()) \n                        })();\n                        build_headers=[];\n                        child_env=null;\n                        want_buffer=(options.want_buffer|| false);\n                        comp_buffer=null;\n                        sorted_dependencies=await (async function(){\n                             return await (await get_global(\"sort_dependencies\"))() \n                        })();\n                        child_export_order=null;\n                        preserve_imports=await (async function(){\n                            if (check_true ((options&& (options.preserve_imports===false)))){\n                                return false\n                            } else {\n                                return true\n                            }\n                        })();\n                        include_source=false;\n                        exports=[];\n                        src=await (async function(){\n                            if (check_true (await Environment[\"get_global\"].call(Environment,\"*env_skeleton*\",null))){\n                                return await clone(await Environment[\"get_global\"].call(Environment,\"*env_skeleton*\"))\n                            } else {\n                                return await (await get_global(\"reader\"))(await (async function(){\n                                     return await (await get_global(\"read_text_file\"))(\"./src/environment.lisp\") \n                                })())\n                            }\n                        })();\n                        target_insertion_path=null;\n                        output_path=null;\n                        if (check_true (Environment.global_ctx.scope[\"*env_skeleton*\"])){\n                            {\n                                await (await get_global(\"register_feature\"))(\"*env_skeleton*\")\n                            }\n                        };\n                        target_insertion_path=await first(await (async function(){\n                             return await (await get_global(\"findpaths\"))(await (async function(){\n                                 return \"=:included_globals\" \n                            })(),src) \n                        })());\n                        if (check_true (await not((target_insertion_path instanceof Array)))){\n                            throw new EvalError(\"Unable to find the first included_globals symbol\");\n                            \n                        };\n                        target_insertion_path=await conj(await chop(target_insertion_path),[2]);\n                        if (check_true (options.include_source)){\n                            {\n                                include_source=true\n                            }\n                        };\n                        await env_log(namespace,\"cloning: # children: \",await length(children));\n                        await env_log(namespace,\"preserve_imports: \",preserve_imports);\n                        exports=await export_symbol_set(await (async function(){\n                            if (check_true (options.do_not_include)){\n                                return {\n                                    do_not_include:options.do_not_include\n                                }\n                            }\n                        })());\n                        child_export_order=await (async function(){\n                            let __collector;\n                            let __result;\n                            let __action;\n                            __collector=[];\n                            __result=null;\n                            __action=async function(cname) {\n                                if (check_true (await not((cname===\"core\")))){\n                                    {\n                                        return await (async function(){\n                                            let __array_op_rval__329=cname;\n                                             if (__array_op_rval__329 instanceof Function){\n                                                return await __array_op_rval__329(children[cname]) \n                                            } else {\n                                                return [__array_op_rval__329,children[cname]]\n                                            }\n                                        })()\n                                    }\n                                }\n                            };\n                            ;\n                            await (async function() {\n                                let __for_body__332=async function(__item) {\n                                    __result=await __action(__item);\n                                    if (check_true (__result)){\n                                        return (__collector).push(__result)\n                                    }\n                                };\n                                let __array__333=[],__elements__331=sorted_dependencies.namespaces;\n                                let __BREAK__FLAG__=false;\n                                for(let __iter__330 in __elements__331) {\n                                    __array__333.push(await __for_body__332(__elements__331[__iter__330]));\n                                    if(__BREAK__FLAG__) {\n                                         __array__333.pop();\n                                        break;\n                                        \n                                    }\n                                }return __array__333;\n                                 \n                            })();\n                            return __collector\n                        })();\n                        await console.log(\"save_env: child_export_order: \",await (async function(){\n                             return await (await get_global(\"each\"))(child_export_order,0) \n                        })());\n                        my_children=await to_object(await (async function(){\n                            let __collector;\n                            let __result;\n                            let __action;\n                            __collector=[];\n                            __result=null;\n                            __action=async function(child) {\n                                if (check_true (await resolve_path(await (async function(){\n                                    let __array_op_rval__334=child['0'];\n                                     if (__array_op_rval__334 instanceof Function){\n                                        return await __array_op_rval__334(\"serialize_with_image\") \n                                    } else {\n                                        return [__array_op_rval__334,\"serialize_with_image\"]\n                                    }\n                                })(),children_declarations))){\n                                    {\n                                        await env_log(\"checking \",namespace,\"checking for: \",await add(child['0'],\"/*on_serialization*\"));\n                                        if (check_true (await not(((typeof await add(child['0'],\"/*on_serialization*\")===\"undefined\")|| (await Environment[\"get_global\"].call(Environment,await add(child['0'],\"/*on_serialization*\"),ReferenceError)===ReferenceError))))){\n                                            {\n                                                await child['1'][\"evaluate\"].call(child['1'],(\"(\"+ child['0']+ \"/*on_serialization*)\"))\n                                            }\n                                        };\n                                        child_env=await child['1'][\"compile\"].call(child['1'],await child['1'][\"export_symbol_set\"].call(child['1'],await add(new Object(),await (async function(){\n                                            if (check_true (options.do_not_include)){\n                                                return {\n                                                    do_not_include:await (async function(){\n                                                        let comps;\n                                                        comps=null;\n                                                        {\n                                                            let ____collector__335= async function(){\n                                                                return []\n                                                            };\n                                                            let ____result__336= async function(){\n                                                                return null\n                                                            };\n                                                            let ____action__337= async function(){\n                                                                return async function(symbol) {\n                                                                    return await async function(){\n                                                                        if (check_true (await contains_ques_(\"/\",symbol))) {\n                                                                            {\n                                                                                comps=(symbol).split(\"/\");\n                                                                                if (check_true ((comps['0']===child['0']))){\n                                                                                    return comps['1']\n                                                                                }\n                                                                            }\n                                                                        } else {\n                                                                            return symbol\n                                                                        }\n                                                                    } ()\n                                                                }\n                                                            };\n                                                            {\n                                                                let __collector=await ____collector__335();\n                                                                ;\n                                                                let __result=await ____result__336();\n                                                                ;\n                                                                let __action=await ____action__337();\n                                                                ;\n                                                                ;\n                                                                await (async function() {\n                                                                    let __for_body__340=async function(__item) {\n                                                                        __result=await __action(__item);\n                                                                        if (check_true (__result)){\n                                                                            return (__collector).push(__result)\n                                                                        }\n                                                                    };\n                                                                    let __array__341=[],__elements__339=options.do_not_include;\n                                                                    let __BREAK__FLAG__=false;\n                                                                    for(let __iter__338 in __elements__339) {\n                                                                        __array__341.push(await __for_body__340(__elements__339[__iter__338]));\n                                                                        if(__BREAK__FLAG__) {\n                                                                             __array__341.pop();\n                                                                            break;\n                                                                            \n                                                                        }\n                                                                    }return __array__341;\n                                                                     \n                                                                })();\n                                                                return __collector\n                                                            }\n                                                        }\n                                                    })()\n                                                }\n                                            } else {\n                                                return new Object()\n                                            }\n                                        })(),{\n                                            no_compiler:true\n                                        })),{\n                                            throw_on_error:true\n                                        });\n                                        return await (async function(){\n                                            let __array_op_rval__342=child['0'];\n                                             if (__array_op_rval__342 instanceof Function){\n                                                return await __array_op_rval__342(await (async function(){\n                                                     return [[\"=:quotel\",child['1'].definitions],await (async function(){\n                                                         return [\"=:quotel\",await (async function(){\n                                                             return [\"=:javascript\",child_env] \n                                                        })()] \n                                                    })()] \n                                                })()) \n                                            } else {\n                                                return [__array_op_rval__342,await (async function(){\n                                                     return [[\"=:quotel\",child['1'].definitions],await (async function(){\n                                                         return [\"=:quotel\",await (async function(){\n                                                             return [\"=:javascript\",child_env] \n                                                        })()] \n                                                    })()] \n                                                })()]\n                                            }\n                                        })()\n                                    }\n                                }\n                            };\n                            ;\n                            await (async function() {\n                                let __for_body__345=async function(__item) {\n                                    __result=await __action(__item);\n                                    if (check_true (__result)){\n                                        return (__collector).push(__result)\n                                    }\n                                };\n                                let __array__346=[],__elements__344=child_export_order;\n                                let __BREAK__FLAG__=false;\n                                for(let __iter__343 in __elements__344) {\n                                    __array__346.push(await __for_body__345(__elements__344[__iter__343]));\n                                    if(__BREAK__FLAG__) {\n                                         __array__346.pop();\n                                        break;\n                                        \n                                    }\n                                }return __array__346;\n                                 \n                            })();\n                            return __collector\n                        })());\n                        await (await get_global(\"set_path\"))(target_insertion_path,src,await (async function(){\n                             return [\"=:fn\",[],await to_object(await (async function(){\n                                 return [[\"definitions\",await (async function(){\n                                     return [\"=:quote\",await (async function(){\n                                        if (check_true (options.do_not_include)){\n                                            return await to_object(await (async function(){\n                                                let __collector;\n                                                let __result;\n                                                let __action;\n                                                __collector=[];\n                                                __result=null;\n                                                __action=async function(defset) {\n                                                    if (check_true (await not(await contains_ques_(defset['0'],options.do_not_include)))){\n                                                        return await (async function(){\n                                                            let __array_op_rval__347=defset['0'];\n                                                             if (__array_op_rval__347 instanceof Function){\n                                                                return await __array_op_rval__347(defset['1']) \n                                                            } else {\n                                                                return [__array_op_rval__347,defset['1']]\n                                                            }\n                                                        })()\n                                                    }\n                                                };\n                                                ;\n                                                await (async function() {\n                                                    let __for_body__350=async function(__item) {\n                                                        __result=await __action(__item);\n                                                        if (check_true (__result)){\n                                                            return (__collector).push(__result)\n                                                        }\n                                                    };\n                                                    let __array__351=[],__elements__349=await pairs(Environment.definitions);\n                                                    let __BREAK__FLAG__=false;\n                                                    for(let __iter__348 in __elements__349) {\n                                                        __array__351.push(await __for_body__350(__elements__349[__iter__348]));\n                                                        if(__BREAK__FLAG__) {\n                                                             __array__351.pop();\n                                                            break;\n                                                            \n                                                        }\n                                                    }return __array__351;\n                                                     \n                                                })();\n                                                return __collector\n                                            })())\n                                        } else {\n                                            return await clone(Environment.definitions)\n                                        }\n                                    })()] \n                                })()],[\"declarations\",await (async function(){\n                                     return await clone(Environment.declarations) \n                                })()],[\"config\",await (async function(){\n                                    let exp_conf;\n                                    exp_conf=await (async function(){\n                                         return await clone(Environment.global_ctx.scope[\"*env_config*\"]) \n                                    })();\n                                    if (check_true (await not(preserve_imports))){\n                                        {\n                                            await async function(){\n                                                exp_conf[\"imports\"]=new Object();\n                                                return exp_conf;\n                                                \n                                            }()\n                                        }\n                                    };\n                                    if (check_true (options.features)){\n                                        {\n                                            await async function(){\n                                                exp_conf[\"features\"]=options.features;\n                                                return exp_conf;\n                                                \n                                            }()\n                                        }\n                                    };\n                                    return exp_conf\n                                })()],[\"imports\",await (async function(){\n                                    if (check_true (preserve_imports)){\n                                        return await to_object(await (async function() {\n                                            let __for_body__356=async function(imp_source) {\n                                                return await (async function(){\n                                                    let __array_op_rval__358=imp_source.symbol;\n                                                     if (__array_op_rval__358 instanceof Function){\n                                                        return await __array_op_rval__358({\n                                                            initializer:await (async function(){\n                                                                 return [\"=:javascript\",\"new function () { return \",imp_source.symbol,\" }\"] \n                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace\n                                                        }) \n                                                    } else {\n                                                        return [__array_op_rval__358,{\n                                                            initializer:await (async function(){\n                                                                 return [\"=:javascript\",\"new function () { return \",imp_source.symbol,\" }\"] \n                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace\n                                                        }]\n                                                    }\n                                                })()\n                                            };\n                                            let __array__357=[],__elements__355=await values((await resolve_path([\"*env_config*\",\"imports\"],Environment.global_ctx.scope)|| new Object()));\n                                            let __BREAK__FLAG__=false;\n                                            for(let __iter__354 in __elements__355) {\n                                                __array__357.push(await __for_body__356(__elements__355[__iter__354]));\n                                                if(__BREAK__FLAG__) {\n                                                     __array__357.pop();\n                                                    break;\n                                                    \n                                                }\n                                            }return __array__357;\n                                             \n                                        })())\n                                    } else {\n                                        return new Object()\n                                    }\n                                })()],[\"symbols\",await (async function(){\n                                     return [\"=:javascript\",await compile(await to_object(exports),{\n                                        throw_on_error:true\n                                    })] \n                                })()],[\"children_declarations\",await (async function(){\n                                     return [\"=:fn\",[],await clone(children_declarations)] \n                                })()],[\"child_load_order\",await (async function(){\n                                     return await (await get_global(\"each\"))(child_export_order,0) \n                                })()],[\"children\",my_children]] \n                            })())] \n                        })());\n                        output_path=await (async function(){\n                            if (check_true (options.want_buffer)){\n                                return null\n                            } else {\n                                return (options.save_as|| await resolve_path([\"*env_config*\",\"export\",\"save_path\"],Environment.global_ctx.scope))\n                            }\n                        })();\n                        if (check_true (output_path instanceof Function)){\n                            output_path=await (async function(){\n                                let __array_op_rval__359=output_path;\n                                 if (__array_op_rval__359 instanceof Function){\n                                    return await __array_op_rval__359() \n                                } else {\n                                    return [__array_op_rval__359]\n                                }\n                            })()\n                        };\n                        if (check_true ((await not((output_path instanceof String || typeof output_path==='string'))&& output_path))){\n                            throw new EvalError(\"invalid name for target for saving the environment.  Must be a string or function\");\n                            \n                        };\n                        return await async function(){\n                            if (check_true ((want_buffer|| (output_path&& await ends_with_ques_(\".js\",output_path))))) {\n                                {\n                                    (build_headers).push((\"// Build Time: \"+ build_time));\n                                    (build_headers).push((\"// Version: \"+ version_tag));\n                                    (build_headers).push((\"export const DLISP_ENV_VERSION='\"+ version_tag+ \"';\"));\n                                    await env_log(\"saving to: \",output_path);\n                                    return await (await get_global(\"compile_buffer\"))(src,\"init_dlisp\",{\n                                        namespace:namespace,toplevel:true,include_boilerplate:false,verbose:false,bundle:true,want_buffer:want_buffer,imports:await (async function(){\n                                            if (check_true (preserve_imports)){\n                                                return await resolve_path([\"*env_config*\",\"imports\"],Environment.global_ctx.scope)\n                                            }\n                                        })(),js_headers:await (async function(){\n                                             return [await (await get_global(\"show\"))(check_true),await (async function(){\n                                                 return await (await get_global(\"show\"))(get_next_environment_id) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(get_outside_global) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(subtype) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(lisp_writer) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(clone) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(LispSyntaxError) \n                                            })()] \n                                        })(),bundle_options:{\n                                            default_namespace:await resolve_path([\"*env_config*\",\"export\",\"default_namespace\"],Environment.global_ctx.scope)\n                                        },output_file:output_path,include_source:(options.include_source|| await resolve_path([\"*env_config*\",\"export\",\"include_source\"],Environment.global_ctx.scope)),build_headers:build_headers\n                                    })\n                                }\n                            } else if (check_true ((output_path&& await ends_with_ques_(\".lisp\",output_path)))) {\n                                return await (await get_global(\"write_text_file\"))(output_path,await JSON.stringify(src,null,4))\n                            } else {\n                                return src\n                            }\n                        } ()\n                    }],[\"null\",null],[\"exec\",async function(command,options) {\n        let arg_set;\n        let process_info;\n        arg_set=await (async function(){\n             return await async function(){\n                if (check_true ((command instanceof String || typeof command==='string'))) {\n                    return (command).split(\" \")\n                } else if (check_true ((command instanceof Array))) {\n                    return command\n                } else {\n                    throw new TypeError(\"system: invalid command format: must be string or array\");\n                    \n                }\n            } () \n        })();\n        options=await (async function(){\n             return await async function(){\n                if (check_true ((options instanceof Object))) {\n                    return options\n                } else if (check_true ((null==options))) {\n                    return new Object()\n                } else {\n                    throw new TypeError(\"system: options must be an object if provided\");\n                    \n                }\n            } () \n        })();\n        process_info=null;\n        process_info=await Deno.run(await (await Environment.get_global(\"add\"))({\n            cmd:arg_set,stdout:\"piped\",stderr:\"piped\"\n        },options));\n        return process_info\n    }],[\"system\",async function(command) {\n    let result;\n    let status;\n    let rval;\n    result=await (await Environment.get_global(\"exec\"))(command);\n    status=await result[\"status\"]();\n    rval=null;\n    rval=await (await Environment.get_global(\"add\"))({\n        stdout:await (async function(){\n            let it;\n            it=await result[\"output\"]();\n            if (check_true (it)){\n                return await (await Environment.get_global(\"decode_text\"))(it)\n            } else {\n                return null\n            }\n        })(),stderr:await (async function(){\n            let it;\n            it=await result[\"stderrOutput\"]();\n            if (check_true (it)){\n                return await (await Environment.get_global(\"decode_text\"))(it)\n            } else {\n                return \n            }\n        })()\n    },status);\n    await result[\"close\"]();\n    return rval\n}],[\"request\",async function() {\n    return await Deno.permissions.request({\n        name:\"run\"\n    })\n}],[\"compile_executable\",async function(options) {\n    let perms;\n    let perm_flags;\n    let emit_file;\n    let command;\n    let result;\n    perms=await (async function(){\n         return await (await Environment.get_global(\"permissions\"))() \n    })();\n    options=(options|| new Object());\n    perm_flags=await (async function(){\n         return await async function(){\n            if (check_true (((options && options[\"permissions\"]) instanceof Array))) {\n                return await (async function() {\n                    let __for_body__3=async function(p) {\n                        return (\"--allow-\"+ p)\n                    };\n                    let __array__4=[],__elements__2=(options && options[\"permissions\"]);\n                    let __BREAK__FLAG__=false;\n                    for(let __iter__1 in __elements__2) {\n                        __array__4.push(await __for_body__3(__elements__2[__iter__1]));\n                        if(__BREAK__FLAG__) {\n                             __array__4.pop();\n                            break;\n                            \n                        }\n                    }return __array__4;\n                     \n                })()\n            } else {\n                {\n                    let __collector;\n                    let __result;\n                    let __action;\n                    __collector=[];\n                    __result=null;\n                    __action=async function(p) {\n                        let name;\n                        let status;\n                        name=(p && p[\"0\"]);\n                        status=(p && p[\"1\"]);\n                        if (check_true ((status===\"granted\"))){\n                            {\n                                return (\"--allow-\"+ name)\n                            }\n                        }\n                    };\n                    ;\n                    await (async function() {\n                        let __for_body__7=async function(__item) {\n                            __result=await __action(__item);\n                            if (check_true (__result)){\n                                return (__collector).push(__result)\n                            }\n                        };\n                        let __array__8=[],__elements__6=await (await Environment.get_global(\"pairs\"))(await (async function(){\n                             return await (await Environment.get_global(\"permissions\"))() \n                        })());\n                        let __BREAK__FLAG__=false;\n                        for(let __iter__5 in __elements__6) {\n                            __array__8.push(await __for_body__7(__elements__6[__iter__5]));\n                            if(__BREAK__FLAG__) {\n                                 __array__8.pop();\n                                break;\n                                \n                            }\n                        }return __array__8;\n                         \n                    })();\n                    return __collector\n                }\n            }\n        } () \n    })();\n    emit_file=await (async function(){\n         return await async function(){\n            if (check_true ((options && options[\"emit_as\"]))) {\n                return (options && options[\"emit_as\"])\n            } else if (check_true (await (await Environment.get_global(\"resolve_path\"))([\"export\",\"save_executable\"],(await Environment.get_global(\"*env_config*\"))))) {\n                return await (await Environment.get_global(\"resolve_path\"))([\"export\",\"save_executable\"],(await Environment.get_global(\"*env_config*\")))\n            } else {\n                return (\"juno.\"+ (await Environment.get_global(\"*env_config*.build\")))\n            }\n        } () \n    })();\n    command=(await (await Environment.get_global(\"flatten\"))([\"deno compile\",perm_flags,await (async function(){\n        if (check_true (((options && options[\"additional_args\"]) instanceof Array))){\n            return (options && options[\"additional_args\"])\n        } else {\n            return []\n        }\n    })(),\"-o\",emit_file,await (async function(){\n        if (check_true ((((options && options[\"target\"]) instanceof String || typeof (options && options[\"target\"])==='string')&& await (await Environment.get_global(\"not\"))(await (await Environment.get_global(\"blank?\"))((options && options[\"target\"])))))){\n            return [\"-t\",(options && options[\"target\"])]\n        } else {\n            return []\n        }\n    })(),await (async function(){\n         return await async function(){\n            if (check_true (((options && options[\"source\"]) instanceof String || typeof (options && options[\"source\"])==='string'))) {\n                return (options && options[\"source\"])\n            } else if (check_true (await (await Environment.get_global(\"resolve_path\"))([\"export\",\"save_path\"],(await Environment.get_global(\"*env_config*\"))))) {\n                return await (await Environment.get_global(\"resolve_path\"))([\"export\",\"save_path\"],(await Environment.get_global(\"*env_config*\")))\n            } else {\n                throw new TypeError(\"compile_executable: cannot resolve the source option: check env_config or provide source in options\");\n                \n            }\n        } () \n    })()])).join(\" \");\n    result=null;\n    if (check_true (((perms && perms[\"run\"])===\"granted\"))){\n        {\n            result=await (await Environment.get_global(\"system\"))(command);\n            if (check_true ((result && result[\"success\"]))){\n                return {\n                    success:true,emitted:emit_file\n                }\n            } else {\n                return result\n            }\n        }\n    } else {\n        {\n            return {\n                success:false,stderr:\"Invalid permissions: require run permissions, evaluate (sys/request) to request access at the console.\",stdout:\"\"\n            }\n        }\n    }\n}],[\"stat\",function(filepath) {\n        return  Deno.lstatSync(filepath)\n    }],[\"is_file?\",function(filepath) {\n        try {\n            return  ( function(){\n                let __targ__10= ( Environment.get_global(\"stat\"))(filepath);\n                if (__targ__10){\n                     return(__targ__10)[\"isFile\"]\n                } \n            })()\n        } catch (__exception__9) {\n            if (__exception__9 instanceof Error) {\n                let e=__exception__9;\n                {\n                    return false\n                }\n            }\n        }\n    }],[\"is_dir?\",function(filepath) {\n        try {\n            return  ( function(){\n                let __targ__12= ( Environment.get_global(\"stat\"))(filepath);\n                if (__targ__12){\n                     return(__targ__12)[\"isDirectory\"]\n                } \n            })()\n        } catch (__exception__11) {\n            if (__exception__11 instanceof Error) {\n                let e=__exception__11;\n                {\n                    return false\n                }\n            }\n        }\n    }],[\"is_symlink?\",function(filepath) {\n        try {\n            return  ( function(){\n                let __targ__14= ( Environment.get_global(\"stat\"))(filepath);\n                if (__targ__14){\n                     return(__targ__14)[\"isSymlink\"]\n                } \n            })()\n        } catch (__exception__13) {\n            if (__exception__13 instanceof Error) {\n                let e=__exception__13;\n                {\n                    return false\n                }\n            }\n        }\n    }],[\"filesize\",function(filepath) {\n        try {\n            {\n                let it;\n                it= ( Environment.get_global(\"stat\"))(filepath);\n                if (check_true (it)){\n                    if (check_true ((it && it[\"isFile\"]))){\n                        return it[\"size\"]\n                    } else {\n                        return null\n                    }\n                } else {\n                    return \n                }\n            }\n        } catch (__exception__15) {\n            if (__exception__15 instanceof Error) {\n                let e=__exception__15;\n                {\n                    return null\n                }\n            }\n        }\n    }],[\"rename\",function(source_path,remote_path) {\n         Deno.renameSync(source_path,remote_path);\n        return ( ( Environment.get_global(\"is_file?\"))(remote_path)||  ( Environment.get_global(\"is_dir?\"))(remote_path)||  ( Environment.get_global(\"is_symlink?\"))(remote_path)|| false)\n    }],[\"delete_file\",function(filepath) {\n        try {\n            {\n                let fd;\n                fd= ( Environment.get_global(\"stat\"))(filepath);\n                if (check_true (((fd && fd[\"isFile\"])|| (fd && fd[\"isSymlink\"])))){\n                    {\n                         Deno.removeSync(filepath);\n                        return true\n                    }\n                } else {\n                    return false\n                }\n            }\n        } catch (__exception__16) {\n            if (__exception__16 instanceof Error) {\n                let e=__exception__16;\n                {\n                    return false\n                }\n            }\n        }\n    }],[\"delete_dir\",function(dirpath) {\n        if (check_true ( ( Environment.get_global(\"is_dir?\"))(dirpath))){\n            try {\n                 Deno.removeSync(dirpath,{\n                    recursive:true\n                });\n                return true\n            } catch (__exception__17) {\n                if (__exception__17 instanceof Error) {\n                    let e=__exception__17;\n                    {\n                        return false\n                    }\n                }\n            }\n        } else {\n            return false\n        }\n    }],[\"list_files\",async function(dirpath,details_ques_) {\n    if (check_true (await (await Environment.get_global(\"is_dir?\"))(dirpath))){\n        try {\n            {\n                let entries;\n                entries=[];\n                await (async function() {\n                    let __for_body__21=async function(entry) {\n                        if (check_true (details_ques_)){\n                            return (entries).push(await (await Environment.get_global(\"stat\"))(dirpath))\n                        } else {\n                            return (entries).push(entry)\n                        }\n                    };\n                    let __BREAK__FLAG__=false;\n                    for await (const __iter__19 of await Deno.readDir(dirpath)) {\n                        await __for_body__21(__iter__19);\n                        if(__BREAK__FLAG__) break;\n                        \n                    } \n                })();\n                return entries\n            }\n        } catch (__exception__18) {\n            if (__exception__18 instanceof Error) {\n                let e=__exception__18;\n                {\n                    return []\n                }\n            }\n        }\n    } else {\n        return []\n    }\n}],[\"mkdir\",function(dirpath,options) {\n         Deno.mkdirSync(dirpath,options);\n        return  ( Environment.get_global(\"is_dir?\"))(dirpath)\n    }],[\"ensure_path_exists\",function(fspath,options) {\n        return   (function(){\n            if (check_true ((null==fspath))) {\n                throw new ReferenceError(\"ensure_path_exists: nil path argument\");\n                \n            } else if (check_true ( ( Environment.get_global(\"is_file?\"))(fspath))) {\n                return true\n            } else if (check_true ( ( Environment.get_global(\"is_dir?\"))(fspath))) {\n                return true\n            } else if (check_true (((options instanceof Object)&& (options && options[\"dir\"])))) {\n                {\n                     ( Environment.get_global(\"mkdir\"))(fspath, ( Environment.get_global(\"add\"))({\n                        recursive:true\n                    },options));\n                    return  ( Environment.get_global(\"is_dir?\"))(fspath)\n                }\n            } else {\n                {\n                    let fsresult;\n                    let comps;\n                    let dir_name;\n                    let an_error;\n                    fsresult=null;\n                    comps=(fspath).split(\"/\");\n                    dir_name=( ( Environment.get_global(\"but_last\"))(comps)).join(\"/\");\n                    an_error=null;\n                    if (check_true ( ( Environment.get_global(\"not\"))( ( Environment.get_global(\"blank?\"))(dir_name)))){\n                        {\n                             ( Environment.get_global(\"mkdir\"))(dir_name, ( Environment.get_global(\"add\"))({\n                                recursive:true\n                            }, ( function(){\n                                if (check_true ((options instanceof Object))){\n                                    return options\n                                } else {\n                                    return new Object()\n                                }\n                            })()));\n                            if (check_true ( ( Environment.get_global(\"not\"))( ( Environment.get_global(\"is_dir?\"))(dir_name)))){\n                                {\n                                    throw new Error((\"ensure_path_exists: cannot make parent directories: \"+ dir_name));\n                                    \n                                }\n                            }\n                        }\n                    };\n                    fsresult= Deno.createSync(fspath);\n                    if (check_true (fsresult)){\n                         fsresult[\"close\"]()\n                    };\n                    if (check_true ((fsresult&& (options && options[\"mode\"])))){\n                        {\n                            try {\n                                 Deno.chmodSync(fspath,(options && options[\"mode\"]))\n                            } catch (__exception__22) {\n                                if (__exception__22 instanceof Error) {\n                                    let e=__exception__22;\n                                    {\n                                        {\n                                            an_error=e\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    };\n                    if (check_true (an_error)){\n                        throw an_error;\n                        \n                    } else {\n                        return true\n                    }\n                }\n            }\n        } )()\n    }],[\"copy_file\",function(from_path,to_path) {\n        if (check_true (((from_path instanceof String || typeof from_path==='string')&& (to_path instanceof String || typeof to_path==='string')))){\n            {\n                 Deno.copyFileSync(from_path,to_path);\n                return  ( Environment.get_global(\"is_file?\"))(to_path)\n            }\n        } else {\n            throw new TypeError(\"copy_file: bad argument(s): requires two string arguments\");\n            \n        }\n    }],[\"watch_fs\",async function(paths,options) {\n    return await Deno.watchFs(paths,options)\n}],[\"dir_tree\",async function(dirpath,options) {\n    let base_dir;\n    let results;\n    let reducer;\n    let __traverse__23= async function(){\n        return async function(path) {\n            return await (async function() {\n                let __for_body__26=async function(entry) {\n                    await async function(){\n                        entry[\"name\"]=await (await Environment.get_global(\"add\"))(path,\"/\",(entry && entry.name));\n                        return entry;\n                        \n                    }();\n                    if (check_true (reducer)){\n                        if (check_true (await (async function(){\n                            let __array_op_rval__29=reducer;\n                             if (__array_op_rval__29 instanceof Function){\n                                return await __array_op_rval__29(entry) \n                            } else {\n                                return [__array_op_rval__29,entry]\n                            }\n                        })())){\n                            (results).push(entry)\n                        }\n                    } else {\n                        (results).push(entry)\n                    };\n                    if (check_true ((entry && entry[\"isDirectory\"]))){\n                        return await traverse((entry && entry.name))\n                    }\n                };\n                let __array__27=[],__elements__25=await (await Environment.get_global(\"list_files\"))(path);\n                let __BREAK__FLAG__=false;\n                for(let __iter__24 in __elements__25) {\n                    __array__27.push(await __for_body__26(__elements__25[__iter__24]));\n                    if(__BREAK__FLAG__) {\n                         __array__27.pop();\n                        break;\n                        \n                    }\n                }return __array__27;\n                 \n            })()\n        }\n    };\n    {\n        base_dir=dirpath;\n        results=[];\n        options=(options|| new Object());\n        reducer=(options && options[\"reducer\"]);\n        let traverse=await __traverse__23();\n        ;\n        if (check_true (await (await Environment.get_global(\"is_dir?\"))(dirpath))){\n            {\n                await traverse(dirpath)\n            }\n        };\n        return results\n    }\n}],[\"make_temp_dir\",async function(opts) {\n    return await Deno[\"makeTempDir\"].call(Deno,opts)\n}],[\"with_temp_dir\",async function(...args) {\n    let tmp_path;\n    let body_forms;\n    tmp_path=(args && args[\"0\"] && args[\"0\"][\"0\"]);\n    body_forms=await (await Environment.get_global(\"slice\"))(args,1);\n    {\n        await console.log(\"with_tmp_dir: \",body_forms);\n        return [\"=:let\",[[tmp_path,[\"=:sys/make_temp_dir\"]],[\"=:caught_error\",\"=:nil\"],[\"=:rval\",\"=:nil\"]],[\"=:try\",[\"=:=\",\"=:rval\",[\"=:progn\",].concat(body_forms)],[\"=:catch\",\"=:Error\",[\"=:e\"],[\"=:progn\",[\"=:=\",\"=:caught_error\",\"=:e\"]]]],[\"=:when\",[\"=:is_dir?\",tmp_path],[\"=:sys/delete_dir\",tmp_path]],[\"=:if\",\"=:caught_error\",[\"=:throw\",\"=:caught_error\"],\"=:rval\"]]\n    }\n}]]"] 
        })()] 
    })(),http:await (async function(){
         return [{"meta_for_symbol":{"core_lang":true,"description":"Given a quoted symbol and a boolean indicating whether or not all namespaces should be searched, returns the meta data associated with the symbol for each environment.  If search mode is requested, the value returned is an array, since there can be symbols with the same name in different environments. If no values are found an empty array is returned.  If not in search mode, meta_for_symbol searches the current namespace only, and if a matching symbol is found, returns an object with all found metadata, otherwise nil is returned.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["describe","meta","help","definition","symbol","metadata"]},"describe":{"core_lang":true,"description":"Given a quoted symbol returns the relevant metadata pertinent to the current namespace context.","usage":["quoted_symbol:string","search_mode:boolean"],"tags":["meta","help","definition","symbol","metadata","info","meta_for_symbol"]},"undefine":{"core_lang":true,"description":"Given a quoted symbol removes the symbol and any definition information from the namespace. If the namespace is fully-qualified, then the symbol will be removed from the specified namespace instead of the currently active namespace. If the symbol is successfully removed, the function will return true, otherwise if it is not found, false will be returned.  Note that if the specified symbol is non-qualified, but exists in a different, accessible namespace, but the symbol isn't present in the current namespace, the symbol will not be deleted.  The environment is not searched and therefore symbols have to be explicitly fully-qualified for any effect of this function outside the current namespace.","usage":["quoted_symbol:string"],"tags":["symbol","delete","remove","unintern","reference","value"]},"*namespace*":{"core_lang":true},"pend_load":{"core_lang":true,"description":"When used as an initializer wrapper via the use_symbols macro, the wrapped initializer will not be loaded until the from_namespace is loaded to ensure that the wrapped initializer won't fail due to not yet loaded dependencies.","usage":["from_namespace:string","target_namespace:string","symbol:string","initializer:array"],"tags":["symbol","definitions","namespace","scope","dependency","dependencies","require"]},"symbols":{"core_lang":true,"description":"Returns an array of the defined global symbols for the local environment.  If opts.unique is true, only symbols that are not part of the built ins are included.","usage":["opts:object"],"tags":["symbol","names","definitions","values","scope"]},"set_global":{"core_lang":true},"get_global":{"core_lang":true},"symbol_definition":{"core_lang":true,"description":"Given a symbol name and an optional namespace, either as a fully qualified path or via the target_namespace argument, returns definition information about the retquested symbol.  Used primarily by the compiler to find metadata for a specific symbol during compilation.","usage":["symname:string","namespace:string"],"tags":["compiler","symbols","namespace","search","context","environment"]},"compile":{"core_lang":true,"description":"Compiles the given JSON or quoted lisp and returns a string containing the lisp form or expression as javascript.<br>If passed the option { meta: true } , an array is returned containing compilation metadata in element 0 and the compiled code in element 1.","usage":["json_expression:*","opts:object"],"tags":["macro","quote","quotes","desym","compiler"]},"env_log":{"core_lang":true,"description":"The environment logging function used by the environment.","usage":["arg0:*","argN:*"]},"evaluate_local":{"core_lang":true},"evaluate":{"core_lang":true},"eval_struct":{"core_lang":true},"is_Response?":{"name":"is_Response?","fn_args":"(value)","description":"Returns true if the value provided is a Response object, otherwise false.","usage":["value:object"],"tags":["request","response","fetch","http"],"requires":[],"externals":["Response"],"source_name":"pkg/http_client.juno"},"get_content_type":{"name":"get_content_type","fn_args":"(obj)","description":"For the given response object attempts to return the content-type value","usage":["response:Response"],"tags":["response","content","mime","fetch","http"],"requires":[],"externals":["Response"],"source_name":"pkg/http_client.juno"},"send_http":{"name":"send_http","fn_args":"(method url data headers)","description":["=:+","Given a method, a url and optional headers, the send_http ","function invokes the underlying fetch function and returns ","the response object.  Optional headers can be provided as ","an object which will be included in the request.  The ","data argument will be stringified using JSON.stringify."],"usage":["method:string","url:string","data:*","headers:object"],"tags":["fetch","http","request","response","io","send","post","get"],"requires":["is_string?","add","is_object?"],"externals":["Response","fetch","JSON","SyntaxError"],"source_name":"pkg/http_client.juno"},"response_handler":{"name":"response_handler","fn_args":"(response options)","description":["=:+","This function takes a response object and based on the provided options ","will either return the body of the response if the HTTP response is 200 OK ","or if either options.raw_response is set to true or a non 200 response ","is returned, will directly return the response.  Used by the functions ","post and get."],"usage":["response:Response","options:object"],"tags":["response","mime","http"],"requires":["get_content_type","starts_with?"],"externals":["Response","fetch","JSON","SyntaxError"],"source_name":"pkg/http_client.juno"},"post":{"name":"post","fn_args":"(url data options)","description":["=:+","Given a url string, a data object and an optional options ","object, performs a POST to the provided URL, and returns ","the value of the response body if a 200 OK is received. ","The response body is parsed as JSON if the content-type ","returned is application/json, text if the content-type ","returned starts with text.  Otherwise a blob representing ","the body is returned.  If the option for raw_response is ","true, the received Response is returned directly with ","no prior processing.  Other options are passed on to ","send_http for use in that function."],"usage":["url:string","data:*","options:object"],"tags":["fetch","post","http","response","request","io","send"],"requires":["send_http","response_handler"],"externals":["Response","fetch","JSON","SyntaxError"],"source_name":"pkg/http_client.juno"},"put":{"name":"put","fn_args":"(url data options)","description":["=:+","Given a url string, a data object and an optional options ","object, performs a PUT to the provided URL, and returns ","the value of the response body if a 200 OK is received. ","The response body is parsed as JSON if the content-type ","returned is application/json, text if the content-type ","returned starts with text.  Otherwise a blob representing ","the body is returned.  If the option for raw_response is ","true, the received Response is returned directly with ","no prior processing.  Other options are passed on to ","send_http for use in that function."],"usage":["url:string","data:*","options:object"],"tags":["fetch","post","http","response","request","io","send"],"requires":["send_http","response_handler"],"externals":["Response","fetch","JSON","SyntaxError"],"source_name":"pkg/http_client.juno"},"get":{"name":"get","fn_args":"(url options)","description":["=:+","Given a url string, and an optional options object ","performs a GET to the provided URL, and returns ","the value of the response body if a 200 OK is received. ","The response body is parsed as JSON if the content-type ","returned is application/json, text if the content-type ","returned starts with text.  Otherwise a blob representing ","the body is returned.  If the option for raw_response is ","true, the received Response is returned directly with ","no prior processing.  Other options are passed on to ","the fetch function as the options argument."],"usage":["url:string","data:*","options:object"],"tags":["fetch","post","http","response","request","io","send"],"requires":["add","is_object?","response_handler"],"externals":["Response","fetch","JSON","SyntaxError"],"source_name":"pkg/http_client.juno"},"send_files":{"name":"send_files","fn_args":"(url file_object options)","usage":["url:string","file_object:object|array","options:?object"],"description":["=:+","Posts a file or files to the location specified by the url and returns ","either the results of the posting operation if all a 200 OK is received ","or will return an unprocessed response object if a non 200 status ","code is returned, or if raw_response is set to true in the options."],"tags":["http","fetch","file","files","io","send","post"],"requires":["is_object?","is_array?","response_handler"],"externals":["Response","fetch","JSON","SyntaxError","FormData"],"source_name":"pkg/http_client.juno"},"data_to_file":{"name":"data_to_file","fn_args":"(name data content_type last_modified)","usage":["name:string","data:*","content_type:?string","last_modified:?number"],"description":"For the given arguments returns a File object representing the provided data.","tags":["file","convert","text","io"],"requires":["is_string?","not","is_object?","starts_with?","add","is_number?"],"externals":["Response","fetch","JSON","SyntaxError","FormData","TypeError","Blob","File"],"source_name":"pkg/http_client.juno"},"list_files":{"name":"list_files","fn_args":"(path)","description":"Given a path to a directory, returns an array of elements if the path is found, otherwise will throw an Error.","usage":["path:string"],"tags":["files","io","path","directory","folder"],"requires":["http/get"],"externals":["Response","fetch","JSON","SyntaxError","FormData","TypeError","Blob","File","Error"],"source_name":"pkg/http_client.juno"},"create_websocket":{"name":"create_websocket","fn_args":"(uri options)","usage":"[uri:string] [options:object]","description":["=:+","Creates a websocket client with the given uri format: ws://hostname:port/path and returns a WebSocket object.","Options are as follows with each function receiving the event object as a single argument:<br>","on_open:function - Called when the socket is opened<br>","on_close:function - Called when the socket is closed<br>","on_message:function - Called when the socket receives a message event<br>","on_error:function - Called when an error event occurs on the socket.<br>"],"tags":["socket","websocket","connection","uri","url","events","messages","message","open","create"],"requires":[],"externals":["Response","fetch","JSON","SyntaxError","FormData","TypeError","Blob","File","Error","WebSocket","console"],"source_name":"pkg/http_client.juno"},"send_to_ws":{"name":"send_to_ws","fn_args":"(ws data)","description":["=:+","Given an active websocket and a data value such as a string or object, sends that data value over ","the websocket. If the websocket is an object, it will call JSON.stringify on the object prior to ","sending."],"usage":["ws:WebSocket","data:*"],"tags":["socket","websocket","connection","uri","url","events","messages","message"],"requires":["is_object?"],"externals":["Response","fetch","JSON","SyntaxError","FormData","TypeError","Blob","File","Error","WebSocket","console"],"source_name":"pkg/http_client.juno"},"close_ws":{"name":"close_ws","fn_args":"(ws)","description":["=:+","Closes the provided websocket and returns the result of the operation."],"usage":["ws:WebSocket"],"tags":["socket","websocket","connection","uri","url","events","messages","message","close"],"requires":[],"externals":["Response","fetch","JSON","SyntaxError","FormData","TypeError","Blob","File","Error","WebSocket","console"],"source_name":"pkg/http_client.juno"},"load":{"name":"load","fn_args":"(filename)","description":["=:+","Compile and load the contents of the specified lisp ","filename (including path) into the Lisp environment. ","Non-qualified symbols will be loaded by default into ","the current namespace.  Otherwise, if qualified they ","will be loaded to the specified namespace.<br>","The file contents are expected to be Lisp source code ","in text format."],"tags":["compile","read","io","file","input"],"usage":["filename:string"],"requires":["is_string?","not","blank?","current_namespace","assert","fetch_text"],"externals":["Response","fetch","JSON","SyntaxError","FormData","TypeError","Blob","File","Error","WebSocket","console"],"source_name":"pkg/http_client.juno"}},await (async function(){
             return ["=:javascript","[[\"meta_for_symbol\",function(quoted_symbol,search_mode) {\n                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){\n                            {\n                                let local_data=(Environment.global_ctx.scope[quoted_symbol]|| Environment.definitions[quoted_symbol]);\n                                ;\n                                let acc=[];\n                                ;\n                                if (check_true (search_mode)){\n                                    {\n                                        if (check_true (local_data)){\n                                            {\n                                                (acc).push( ( get_global(\"add\"))({\n                                                    namespace:namespace,name:quoted_symbol,type: subtype(local_data)\n                                                }, ( function(){\n                                                    let it;\n                                                    it=Environment.definitions[quoted_symbol];\n                                                    if (check_true (it)){\n                                                        return it\n                                                    } else {\n                                                        return new Object()\n                                                    }\n                                                })()))\n                                            }\n                                        };\n                                        if (check_true (parent_environment)){\n                                            {\n                                                {\n                                                    let __collector;\n                                                    let __result;\n                                                    let __action;\n                                                    __collector=[];\n                                                    __result=null;\n                                                    __action=function(info) {\n                                                        return (acc).push(info)\n                                                    };\n                                                    ;\n                                                     ( function() {\n                                                        let __for_body__121=function(__item) {\n                                                            __result= __action(__item);\n                                                            if (check_true (__result)){\n                                                                return (__collector).push(__result)\n                                                            }\n                                                        };\n                                                        let __array__122=[],__elements__120= ( function() {\n                                                            {\n                                                                 let __call_target__= parent_environment[\"meta_for_symbol\"].call(parent_environment,quoted_symbol,true), __call_method__=\"flat\";\n                                                                return  __call_target__[__call_method__].call(__call_target__,1)\n                                                            } \n                                                        })();\n                                                        let __BREAK__FLAG__=false;\n                                                        for(let __iter__119 in __elements__120) {\n                                                            __array__122.push( __for_body__121(__elements__120[__iter__119]));\n                                                            if(__BREAK__FLAG__) {\n                                                                 __array__122.pop();\n                                                                break;\n                                                                \n                                                            }\n                                                        }return __array__122;\n                                                         \n                                                    })();\n                                                    __collector\n                                                }\n                                            }\n                                        };\n                                        if (check_true (( length( keys(children))>0))){\n                                            {\n                                                {\n                                                    let __collector;\n                                                    let __result;\n                                                    let __action;\n                                                    __collector=[];\n                                                    __result=null;\n                                                    __action=function(details) {\n                                                        return (acc).push(details)\n                                                    };\n                                                    ;\n                                                     ( function() {\n                                                        let __for_body__125=function(__item) {\n                                                            __result= __action(__item);\n                                                            if (check_true (__result)){\n                                                                return (__collector).push(__result)\n                                                            }\n                                                        };\n                                                        let __array__126=[],__elements__124= ( function(){\n                                                            let ____collector__127=  function(){\n                                                                return []\n                                                            };\n                                                            let ____result__128=  function(){\n                                                                return null\n                                                            };\n                                                            let ____action__129=  function(){\n                                                                return function(child_data) {\n                                                                    if (check_true ( not((child_data['0']=== ( get_global(\"current_namespace\"))())))){\n                                                                        {\n                                                                            return  child_data['1'][\"meta_for_symbol\"].call(child_data['1'],quoted_symbol)\n                                                                        }\n                                                                    }\n                                                                }\n                                                            };\n                                                            {\n                                                                let __collector= ____collector__127();\n                                                                ;\n                                                                let __result= ____result__128();\n                                                                ;\n                                                                let __action= ____action__129();\n                                                                ;\n                                                                ;\n                                                                 ( function() {\n                                                                    let __for_body__132=function(__item) {\n                                                                        __result= __action(__item);\n                                                                        if (check_true (__result)){\n                                                                            return (__collector).push(__result)\n                                                                        }\n                                                                    };\n                                                                    let __array__133=[],__elements__131= pairs(children);\n                                                                    let __BREAK__FLAG__=false;\n                                                                    for(let __iter__130 in __elements__131) {\n                                                                        __array__133.push( __for_body__132(__elements__131[__iter__130]));\n                                                                        if(__BREAK__FLAG__) {\n                                                                             __array__133.pop();\n                                                                            break;\n                                                                            \n                                                                        }\n                                                                    }return __array__133;\n                                                                     \n                                                                })();\n                                                                return __collector\n                                                            }\n                                                        })();\n                                                        let __BREAK__FLAG__=false;\n                                                        for(let __iter__123 in __elements__124) {\n                                                            __array__126.push( __for_body__125(__elements__124[__iter__123]));\n                                                            if(__BREAK__FLAG__) {\n                                                                 __array__126.pop();\n                                                                break;\n                                                                \n                                                            }\n                                                        }return __array__126;\n                                                         \n                                                    })();\n                                                    __collector\n                                                }\n                                            }\n                                        };\n                                        return acc\n                                    }\n                                } else {\n                                    {\n                                        quoted_symbol= ( function(){\n                                            if (check_true ( starts_with_ques_( ( function(){\n                                                 return \"=:\" \n                                            })(),quoted_symbol))){\n                                                return  quoted_symbol[\"substr\"].call(quoted_symbol,2)\n                                            } else {\n                                                return quoted_symbol\n                                            }\n                                        })();\n                                        {\n                                            let it;\n                                            it=Environment.definitions[quoted_symbol];\n                                            if (check_true (it)){\n                                                return  ( get_global(\"add\"))({\n                                                    namespace:namespace,type: sub_type(local_data),name:quoted_symbol\n                                                },it)\n                                            } else {\n                                                return null\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }],[\"describe\",async function(quoted_symbol,search_mode) {\n                        let internal_results=await meta_for_symbol(quoted_symbol,true);\n                        ;\n                        if (check_true (((internal_results instanceof Array)&& internal_results['0']))){\n                            if (check_true (search_mode)){\n                                return internal_results\n                            } else {\n                                return await first(internal_results)\n                            }\n                        } else {\n                            {\n                                let external_results=await get_outside_global(quoted_symbol);\n                                ;\n                                if (check_true (external_results)){\n                                    {\n                                        let detail={\n                                            location:\"external\",type:await subtype(external_results),name:quoted_symbol,namespace:\"EXTERNAL\",description:(\"This is not a bound symbol within the Juno Environment.  \"+ \"If it is to be used, it is recommended to create a reference to it with \"+ \"`(defglobal \"+ quoted_symbol+ \" \"+ quoted_symbol+ \" { `description: \\\"...\\\" })`\")\n                                        };\n                                        ;\n                                        if (check_true (search_mode)){\n                                            return await (async function(){\n                                                let __array_op_rval__136=detail;\n                                                 if (__array_op_rval__136 instanceof Function){\n                                                    return await __array_op_rval__136() \n                                                } else {\n                                                    return [__array_op_rval__136]\n                                                }\n                                            })()\n                                        } else {\n                                            return detail\n                                        }\n                                    }\n                                } else {\n                                    return null\n                                }\n                            }\n                        }\n                    }],[\"undefine\",function(quoted_symbol) {\n                        if (check_true ((quoted_symbol instanceof String || typeof quoted_symbol==='string'))){\n                            {\n                                let namespace_identity;\n                                let parent_call;\n                                let child_call;\n                                let target_symbol;\n                                namespace_identity=(quoted_symbol).split(\"/\");\n                                parent_call=null;\n                                child_call=null;\n                                target_symbol=null;\n                                ;\n                                return   (function(){\n                                    if (check_true ((((namespace_identity.length===1)&& Environment.global_ctx.scope[namespace_identity['0']])|| ((namespace_identity.length>1)&& (namespace_identity['0']===namespace))))) {\n                                        {\n                                            target_symbol= ( function(){\n                                                if (check_true ((namespace_identity.length>1))){\n                                                    return namespace_identity['1']\n                                                } else {\n                                                    return namespace_identity['0']\n                                                }\n                                            })();\n                                             delete_prop(Environment.definitions,target_symbol);\n                                            if (check_true (Environment.global_ctx.scope[target_symbol])){\n                                                return  delete_prop(Environment.global_ctx.scope,target_symbol)\n                                            } else {\n                                                return false\n                                            }\n                                        }\n                                    } else if (check_true (((namespace_identity.length>1)&& parent_environment))) {\n                                        {\n                                            parent_call= parent_environment[\"get_global\"].call(parent_environment,\"undefine\");\n                                            return (parent_call)(quoted_symbol)\n                                        }\n                                    } else if (check_true (((namespace_identity.length>1)&& children[namespace_identity['0']]))) {\n                                        {\n                                            child_call= ( function() {\n                                                {\n                                                     let __call_target__=children[namespace_identity['0']], __call_method__=\"get_global\";\n                                                    return  __call_target__[__call_method__].call(__call_target__,\"undefine\")\n                                                } \n                                            })();\n                                            return  child_call(quoted_symbol)\n                                        }\n                                    } else {\n                                        return false\n                                    }\n                                } )()\n                            }\n                        } else {\n                            throw new SyntaxError(\"undefine requires a quoted symbol\");\n                            \n                        }\n                    }],[\"*namespace*\",\"http\"],[\"pend_load\",async function(from_namespace,target_namespace,symbol,initializer) {\n                        if (check_true ((null==pending_ns_loads[from_namespace]))){\n                            {\n                                await async function(){\n                                    pending_ns_loads[from_namespace]=[];\n                                    return pending_ns_loads;\n                                    \n                                }()\n                            }\n                        };\n                        (pending_ns_loads[from_namespace]).push({\n                            symbol:symbol,source_ns:from_namespace,target_ns:target_namespace,initializer:await (async function(){\n                                 return [\"=:quote\",initializer] \n                            })()\n                        });\n                        return initializer\n                    }],[\"symbols\",async function(opts) {\n                        return await async function(){\n                            if (check_true ((null==opts))) {\n                                return await keys(Environment.global_ctx.scope)\n                            } else if (check_true (opts.unique)) {\n                                {\n                                    let no_includes=await make_set(await conj([\"meta_for_symbol\",\"describe\",\"undefine\",\"*namespace*\",\"pend_load\",\"symbols\",\"set_global\",\"get_global\",\"symbol_definition\",\"compile\",\"env_log\",\"evaluate_local\",\"evaluate\",\"eval_struct\",\"set_compiler\",\"clone\",\"eval\",\"add_escape_encoding\",\"get_outside_global\",\"as_lisp\",\"lisp_writer\",\"clone_to_new\",\"save_env\",\"null\",\"compiler\"],built_ins));\n                                    ;\n                                    {\n                                        let __collector;\n                                        let __result;\n                                        let __action;\n                                        __collector=[];\n                                        __result=null;\n                                        __action=async function(sym) {\n                                            if (check_true (await no_includes[\"has\"].call(no_includes,sym))){\n                                                return null\n                                            } else {\n                                                return sym\n                                            }\n                                        };\n                                        ;\n                                        await (async function() {\n                                            let __for_body__213=async function(__item) {\n                                                __result=await __action(__item);\n                                                if (check_true (__result)){\n                                                    return (__collector).push(__result)\n                                                }\n                                            };\n                                            let __array__214=[],__elements__212=await keys(Environment.global_ctx.scope);\n                                            let __BREAK__FLAG__=false;\n                                            for(let __iter__211 in __elements__212) {\n                                                __array__214.push(await __for_body__213(__elements__212[__iter__211]));\n                                                if(__BREAK__FLAG__) {\n                                                     __array__214.pop();\n                                                    break;\n                                                    \n                                                }\n                                            }return __array__214;\n                                             \n                                        })();\n                                        return __collector\n                                    }\n                                }\n                            }\n                        } ()\n                    }],[\"set_global\",function(refname,value,meta,is_constant,target_namespace,contained_req) {\n                          (function(){\n                            if (check_true ( not((typeof refname===\"string\")))) {\n                                throw new TypeError(\"reference name must be a string type\");\n                                \n                            } else if (check_true (((Environment===value)|| (Environment.global_ctx===value)|| (Environment.global_ctx.scope===value)))) {\n                                {\n                                    throw new EvalError(\"cannot set the environment scope as a global value\");\n                                    \n                                }\n                            }\n                        } )();\n                        if (check_true ( resolve_path( ( function(){\n                            let __array_op_rval__217=refname;\n                             if (__array_op_rval__217 instanceof Function){\n                                return  __array_op_rval__217(\"constant\") \n                            } else {\n                                return [__array_op_rval__217,\"constant\"]\n                            }\n                        })(),Environment.definitions))){\n                            {\n                                throw new TypeError((\"Assignment to constant variable \"+ refname));\n                                \n                            }\n                        };\n                        let namespace_identity= ( function(){\n                            if (check_true (target_namespace)){\n                                return  ( function(){\n                                    let __array_op_rval__218=target_namespace;\n                                     if (__array_op_rval__218 instanceof Function){\n                                        return  __array_op_rval__218(refname) \n                                    } else {\n                                        return [__array_op_rval__218,refname]\n                                    }\n                                })()\n                            } else {\n                                return (refname).split(\"/\")\n                            }\n                        })();\n                        ;\n                        return   (function(){\n                            if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace===namespace_identity['0']))))) {\n                                return  parent_environment[\"set_global\"].call(parent_environment,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'],(contained|| contained_req))\n                            } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                {\n                                    if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){\n                                        return  ( function() {\n                                            {\n                                                 let __call_target__=children[namespace_identity['0']], __call_method__=\"set_global\";\n                                                return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value,meta,is_constant,namespace_identity['0'])\n                                            } \n                                        })()\n                                    } else {\n                                        throw new EvalError((\"namespace \"+ namespace_identity['0']+ \" doesn't exist\"));\n                                        \n                                    }\n                                }\n                            } else {\n                                try {\n                                    let comps= get_object_path( ( function(){\n                                        if (check_true ((1===namespace_identity.length))){\n                                            return namespace_identity['0']\n                                        } else {\n                                            return namespace_identity['1']\n                                        }\n                                    })());\n                                    ;\n                                      (function(){\n                                        Environment.global_ctx.scope[comps['0']]=value;\n                                        return Environment.global_ctx.scope;\n                                        \n                                    })();\n                                    if (check_true (((meta instanceof Object)&&  not((meta instanceof Array))))){\n                                        {\n                                            if (check_true (is_constant)){\n                                                {\n                                                      (function(){\n                                                        meta[\"constant\"]=true;\n                                                        return meta;\n                                                        \n                                                    })()\n                                                }\n                                            };\n                                              (function(){\n                                                Environment.definitions[comps['0']]=meta;\n                                                return Environment.definitions;\n                                                \n                                            })()\n                                        }\n                                    } else {\n                                        if (check_true (is_constant)){\n                                            {\n                                                  (function(){\n                                                    Environment.definitions[comps['0']]={\n                                                        constant:true\n                                                    };\n                                                    return Environment.definitions;\n                                                    \n                                                })()\n                                            }\n                                        }\n                                    };\n                                    return Environment.global_ctx.scope[comps['0']]\n                                } catch (__exception__219) {\n                                    if (__exception__219 instanceof Error) {\n                                        let e=__exception__219;\n                                        {\n                                            {\n                                                let message=(\"Error: set_global: \"+ _star_namespace_star_+ \"symbol name: \"+ refname+ \": \"+ e.message);\n                                                ;\n                                                 console.error(message,[]);\n                                                  (function(){\n                                                    e[\"message\"]=message;\n                                                    return e;\n                                                    \n                                                })();\n                                                throw e;\n                                                \n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } )()\n                    }],[\"get_global\",function(refname,value_if_not_found,suppress_check_external_env,target_namespace,path_comps,contained_req) {\n                        return   (function(){\n                            if (check_true ( not((typeof refname===\"string\")))) {\n                                throw new TypeError(\"reference name must be a string type\");\n                                \n                            } else if (check_true ((refname===\"Environment\"))) {\n                                return Environment\n                            } else if (check_true ( compiler_operators[\"has\"].call(compiler_operators,refname))) {\n                                return special_identity\n                            } else {\n                                {\n                                    let namespace_identity;\n                                    let comps;\n                                    let refval;\n                                    let symbol_name;\n                                    let check_external_env;\n                                    namespace_identity= ( function(){\n                                        if (check_true (target_namespace)){\n                                            return  ( function(){\n                                                let __array_op_rval__227=target_namespace;\n                                                 if (__array_op_rval__227 instanceof Function){\n                                                    return  __array_op_rval__227(refname) \n                                                } else {\n                                                    return [__array_op_rval__227,refname]\n                                                }\n                                            })()\n                                        } else {\n                                            return (refname).split(\"/\")\n                                        }\n                                    })();\n                                    comps=(path_comps||  get_object_path( ( function(){\n                                        if (check_true ((1===namespace_identity.length))){\n                                            return namespace_identity['0']\n                                        } else {\n                                            return namespace_identity['1']\n                                        }\n                                    })()));\n                                    refval=null;\n                                    symbol_name=null;\n                                    check_external_env= ( function(){\n                                        if (check_true (suppress_check_external_env)){\n                                            return false\n                                        } else {\n                                            return check_external_env_default\n                                        }\n                                    })();\n                                    return   (function(){\n                                        if (check_true ((parent_environment&& (namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                            return  parent_environment[\"get_global\"].call(parent_environment,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps,(contained|| contained_req))\n                                        } else if (check_true (((namespace_identity.length>1)&&  not((namespace_identity['0']===namespace))))) {\n                                            {\n                                                if (check_true ((children[namespace_identity['0']]&&  not(contained_req)))){\n                                                    return  ( function() {\n                                                        {\n                                                             let __call_target__=children[namespace_identity['0']], __call_method__=\"get_global\";\n                                                            return  __call_target__[__call_method__].call(__call_target__,namespace_identity['1'],value_if_not_found,suppress_check_external_env,namespace_identity['0'],comps)\n                                                        } \n                                                    })()\n                                                } else {\n                                                    {\n                                                        throw new EvalError((\"namespace \"+ namespace_identity['0']+ \" doesn't exist\"));\n                                                        \n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            {\n                                                refval=Environment.global_ctx.scope[comps['0']];\n                                                if (check_true (((undefined===refval)&& (namespace_identity.length===1)&& parent_environment))){\n                                                    {\n                                                        let rval= parent_environment[\"get_global\"].call(parent_environment,refname,value_if_not_found,suppress_check_external_env,null,comps,(contained|| contained_req));\n                                                        ;\n                                                        return rval\n                                                    }\n                                                } else {\n                                                    {\n                                                        if (check_true (((undefined===refval)&& check_external_env))){\n                                                            refval= ( function(){\n                                                                if (check_true (check_external_env)){\n                                                                    return ( get_outside_global(comps['0'])|| NOT_FOUND)\n                                                                } else {\n                                                                    return NOT_FOUND\n                                                                }\n                                                            })()\n                                                        };\n                                                        return   (function(){\n                                                            if (check_true (((NOT_FOUND===refval)&&  not((undefined===value_if_not_found))))) {\n                                                                return value_if_not_found\n                                                            } else if (check_true ((NOT_FOUND===refval))) {\n                                                                {\n                                                                    throw new ReferenceError((\"symbol not found: \"+  ( function(){\n                                                                        if (check_true ((namespace_identity.length>1))){\n                                                                            return  add(namespace,\"/\",namespace_identity['1'])\n                                                                        } else {\n                                                                            return  add(namespace,\"/\",namespace_identity['0'])\n                                                                        }\n                                                                    })()));\n                                                                    \n                                                                }\n                                                            } else if (check_true ((comps.length===1))) {\n                                                                return refval\n                                                            } else if (check_true ((comps.length>1))) {\n                                                                {\n                                                                    return  resolve_path( rest(comps),refval)\n                                                                }\n                                                            } else {\n                                                                {\n                                                                     console.warn(\"get_global: condition fall through: \",comps);\n                                                                    return NOT_FOUND\n                                                                }\n                                                            }\n                                                        } )()\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } )()\n                                }\n                            }\n                        } )()\n                    }],[\"symbol_definition\",async function(symname,target_namespace) {\n                        let namespace_identity;\n                        namespace_identity=await (async function(){\n                            if (check_true (target_namespace)){\n                                return await (async function(){\n                                    let __array_op_rval__230=target_namespace;\n                                     if (__array_op_rval__230 instanceof Function){\n                                        return await __array_op_rval__230(symname) \n                                    } else {\n                                        return [__array_op_rval__230,symname]\n                                    }\n                                })()\n                            } else {\n                                if (check_true ((await length(symname)>2))){\n                                    return (symname).split(\"/\")\n                                } else {\n                                    return await (async function(){\n                                        let __array_op_rval__231=symname;\n                                         if (__array_op_rval__231 instanceof Function){\n                                            return await __array_op_rval__231() \n                                        } else {\n                                            return [__array_op_rval__231]\n                                        }\n                                    })()\n                                }\n                            }\n                        })();\n                        return await async function(){\n                            if (check_true ((namespace_identity.length===1))) {\n                                {\n                                    let it;\n                                    it=Environment.definitions[symname];\n                                    if (check_true (it)){\n                                        return it\n                                    } else {\n                                        if (check_true (parent_environment)){\n                                            return await parent_environment[\"symbol_definition\"].call(parent_environment,symname)\n                                        }\n                                    }\n                                }\n                            } else if (check_true ((namespace_identity['0']===namespace))) {\n                                return Environment.definitions[symname]\n                            } else if (check_true (parent_environment)) {\n                                return await parent_environment[\"symbol_definition\"].call(parent_environment,namespace_identity['1'],namespace_identity['0'])\n                            } else if (check_true ((namespace_identity.length===2))) {\n                                return await (async function() {\n                                    {\n                                         let __call_target__=children[namespace_identity['0']], __call_method__=\"symbol_definition\";\n                                        return await __call_target__[__call_method__].call(__call_target__,namespace_identity['1'])\n                                    } \n                                })()\n                            } else {\n                                return undefined\n                            }\n                        } ()\n                    }],[\"compile\",async function(json_expression,opts) {\n                        let out;\n                        opts=await add({\n                            env:Environment\n                        },opts,{\n                            meta:await (async function(){\n                                if (check_true ((opts&& opts.meta))){\n                                    return true\n                                } else {\n                                    return false\n                                }\n                            })()\n                        });\n                        out=null;\n                        out=await (async function(){\n                             return await compiler(json_expression,opts) \n                        })();\n                        return await async function(){\n                            if (check_true (((out instanceof Array)&& out['0'].ctype&& (out['0'].ctype===\"FAIL\")))) {\n                                return out\n                            } else if (check_true (opts.meta)) {\n                                return out\n                            } else {\n                                return out['1']\n                            }\n                        } ()\n                    }],[\"env_log\",async function(...args) {\n                            return await (async function(){\n                                let __target_arg__189=[].concat(await conj(await (async function(){\n                                    let __array_op_rval__190=style;\n                                     if (__array_op_rval__190 instanceof Function){\n                                        return await __array_op_rval__190() \n                                    } else {\n                                        return [__array_op_rval__190]\n                                    }\n                                })(),args));\n                                if(!__target_arg__189 instanceof Array){\n                                    throw new TypeError(\"Invalid final argument to apply - an array is required\")\n                                }let __pre_arg__191=(\"%c\"+ await (async function(){\n                                    if (check_true (opts.prefix)){\n                                        return opts.prefix\n                                    } else {\n                                        return (args).shift()\n                                    }\n                                })());\n                                __target_arg__189.unshift(__pre_arg__191);\n                                return (console.log).apply(this,__target_arg__189)\n                            })()\n                        }],[\"evaluate_local\",async function(expression,ctx,opts) {\n                        let compiled;\n                        let error_data;\n                        let requires;\n                        let precompiled_assembly;\n                        let result;\n                        opts=(opts|| new Object());\n                        compiled=null;\n                        error_data=null;\n                        requires=null;\n                        precompiled_assembly=null;\n                        result=null;\n                        if (check_true (opts.compiled_source)){\n                            compiled=expression\n                        } else {\n                            try {\n                                compiled=await (async function(){\n                                     return await compiler(await (async function(){\n                                        if (check_true (opts.json_in)){\n                                            return expression\n                                        } else {\n                                            return await Environment[\"read_lisp\"].call(Environment,expression,{\n                                                source_name:opts.source_name\n                                            })\n                                        }\n                                    })(),{\n                                        env:Environment,ctx:ctx,formatted_output:true,source_name:opts.source_name,throw_on_error:opts.throw_on_error,on_final_token_assembly:async function(val) {\n                                            return precompiled_assembly=val\n                                        },error_report:(opts.error_report|| null),quiet_mode:(opts.quiet_mode|| false)\n                                    }) \n                                })()\n                            } catch (__exception__238) {\n                                if (__exception__238 instanceof Error) {\n                                    let e=__exception__238;\n                                    {\n                                        {\n                                            if (check_true (opts.throw_on_error)){\n                                                {\n                                                    throw e;\n                                                    \n                                                }\n                                            };\n                                            if (check_true ((e instanceof LispSyntaxError))){\n                                                {\n                                                    await async function(){\n                                                        e[\"message\"]=await JSON.parse(e.message);\n                                                        return e;\n                                                        \n                                                    }()\n                                                }\n                                            };\n                                            await async function(){\n                                                if (check_true ((e instanceof LispSyntaxError))) {\n                                                    return error_data=await add({\n                                                        error:\"LispSyntaxError\"\n                                                    },e.message)\n                                                } else {\n                                                    error_data={\n                                                        error:await sub_type(e),message:e.message,stack:e.stack,form:await (async function(){\n                                                             return await async function(){\n                                                                if (check_true (((expression instanceof String || typeof expression==='string')&& (expression.length>100)))) {\n                                                                    return await add(await expression[\"substr\"].call(expression,0,100),\"...\")\n                                                                } else {\n                                                                    return await (await get_global(\"as_lisp\"))(expression)\n                                                                }\n                                                            } () \n                                                        })(),parent_forms:[],source_name:opts.source_name,invalid:true\n                                                    }\n                                                }\n                                            } ();\n                                            if (check_true (opts.error_report)){\n                                                await (async function(){\n                                                    let __array_op_rval__240=opts.error_report;\n                                                     if (__array_op_rval__240 instanceof Function){\n                                                        return await __array_op_rval__240(error_data) \n                                                    } else {\n                                                        return [__array_op_rval__240,error_data]\n                                                    }\n                                                })()\n                                            } else {\n                                                await console.error(\"Compilation Error: \",error_data)\n                                            };\n                                            compiled=await (async function(){\n                                                 return [{\n                                                    error:true\n                                                },null] \n                                            })()\n                                        }\n                                    }\n                                }\n                            }\n                        };\n                        return await async function(){\n                            if (check_true ((null==compiled))) {\n                                return null\n                            } else if (check_true ((compiled['0'].ctype===\"FAIL\"))) {\n                                {\n                                    if (check_true (opts.error_report)){\n                                        {\n                                            await (async function(){\n                                                let __array_op_rval__241=opts.error_report;\n                                                 if (__array_op_rval__241 instanceof Function){\n                                                    return await __array_op_rval__241(compiled['1']) \n                                                } else {\n                                                    return [__array_op_rval__241,compiled['1']]\n                                                }\n                                            })()\n                                        }\n                                    };\n                                    return await async function(){\n                                        if (check_true ((compiled['1'] instanceof Error))) {\n                                            throw compiled['1'];\n                                            \n                                        } else if (check_true ((compiled['1']['0'] instanceof Error))) {\n                                            throw compiled['1']['0'];\n                                            \n                                        } else if (check_true (((compiled['1']['0'] instanceof Object)&& (compiled['1']['0'].error===\"SyntaxError\")))) {\n                                            {\n                                                let new_error=new SyntaxError(compiled['1']['0'].message);\n                                                ;\n                                                await async function(){\n                                                    new_error[\"from\"]=compiled['1']['0'];\n                                                    return new_error;\n                                                    \n                                                }();\n                                                throw new_error;\n                                                \n                                            }\n                                        } else {\n                                            return compiled['1']\n                                        }\n                                    } ()\n                                }\n                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))&& parent_environment))) {\n                                return await parent_environment[\"evaluate_local\"].call(parent_environment,compiled,ctx,await add(new Object(),opts,{\n                                    compiled_source:true\n                                }))\n                            } else if (check_true ((compiled['0'].namespace&& await not((compiled['0'].namespace===namespace))))) {\n                                if (check_true (children[compiled['0'].namespace])){\n                                    return await (async function() {\n                                        {\n                                             let __call_target__=children[compiled['0'].namespace], __call_method__=\"evaluate_local\";\n                                            return await __call_target__[__call_method__].call(__call_target__,compiled,ctx,await add(new Object(),opts,{\n                                                compiled_source:true\n                                            }))\n                                        } \n                                    })()\n                                } else {\n                                    throw new EvalError((\"unknown namespace \"+ compiled['0'].namespace+ \" assignment\"));\n                                    \n                                }\n                            } else {\n                                {\n                                    if (check_true (opts.on_compilation_complete)){\n                                        await (async function(){\n                                            let __array_op_rval__243=opts.on_compilation_complete;\n                                             if (__array_op_rval__243 instanceof Function){\n                                                return await __array_op_rval__243(compiled) \n                                            } else {\n                                                return [__array_op_rval__243,compiled]\n                                            }\n                                        })()\n                                    };\n                                    try {\n                                        if (check_true (((compiled instanceof Array)&& (compiled['0'] instanceof Object)&& compiled['0'].ctype&& await not((compiled['0'].ctype instanceof String || typeof compiled['0'].ctype==='string'))))){\n                                            {\n                                                await async function(){\n                                                    compiled['0'][\"ctype\"]=await subtype(compiled['0'].ctype);\n                                                    return compiled['0'];\n                                                    \n                                                }()\n                                            }\n                                        };\n                                        result=await (async function(){\n                                             return await async function(){\n                                                if (check_true (compiled.error)) {\n                                                    throw new Error((await get_global(\"indirect_new\"))(compiled.error,compiled.message));\n                                                    \n                                                } else if (check_true ((compiled['0'].ctype&& (await contains_ques_(\"block\",compiled['0'].ctype)|| (compiled['0'].ctype===\"assignment\")|| (compiled['0'].ctype===\"__!NOT_FOUND!__\"))))) {\n                                                    if (check_true (await (async function(){\n                                                        let __array_op_rval__246=compiled['0'].has_lisp_globals;\n                                                         if (__array_op_rval__246 instanceof Function){\n                                                            return await __array_op_rval__246() \n                                                        } else {\n                                                            return [__array_op_rval__246]\n                                                        }\n                                                    })())){\n                                                        {\n                                                            await async function(){\n                                                                compiled[1]=new AsyncFunction(\"Environment\",(\"{ \"+ compiled['1']+ \"}\"));\n                                                                return compiled;\n                                                                \n                                                            }();\n                                                            return await (async function(){\n                                                                let __array_op_rval__248=compiled['1'];\n                                                                 if (__array_op_rval__248 instanceof Function){\n                                                                    return await __array_op_rval__248(Environment) \n                                                                } else {\n                                                                    return [__array_op_rval__248,Environment]\n                                                                }\n                                                            })()\n                                                        }\n                                                    } else {\n                                                        {\n                                                            await async function(){\n                                                                compiled[1]=new AsyncFunction((\"{\"+ compiled['1']+ \"}\"));\n                                                                return compiled;\n                                                                \n                                                            }();\n                                                            return await (async function(){\n                                                                let __array_op_rval__250=compiled['1'];\n                                                                 if (__array_op_rval__250 instanceof Function){\n                                                                    return await __array_op_rval__250() \n                                                                } else {\n                                                                    return [__array_op_rval__250]\n                                                                }\n                                                            })()\n                                                        }\n                                                    }\n                                                } else if (check_true ((compiled['0'].ctype&& ((\"AsyncFunction\"===compiled['0'].ctype)|| (\"statement\"===compiled['0'].ctype)|| (\"objliteral\"===compiled['0'].ctype))))) {\n                                                    {\n                                                        if (check_true (await (async function(){\n                                                            let __array_op_rval__251=compiled['0'].has_lisp_globals;\n                                                             if (__array_op_rval__251 instanceof Function){\n                                                                return await __array_op_rval__251() \n                                                            } else {\n                                                                return [__array_op_rval__251]\n                                                            }\n                                                        })())){\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new AsyncFunction(\"Environment\",(\"{ return \"+ compiled['1']+ \"} \"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__253=compiled['1'];\n                                                                     if (__array_op_rval__253 instanceof Function){\n                                                                        return await __array_op_rval__253(Environment) \n                                                                    } else {\n                                                                        return [__array_op_rval__253,Environment]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        } else {\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new AsyncFunction((\"{ return \"+ compiled['1']+ \"}\"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__255=compiled['1'];\n                                                                     if (__array_op_rval__255 instanceof Function){\n                                                                        return await __array_op_rval__255() \n                                                                    } else {\n                                                                        return [__array_op_rval__255]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        }\n                                                    }\n                                                } else if (check_true ((compiled['0'].ctype&& (\"Function\"===compiled['0'].ctype)))) {\n                                                    {\n                                                        if (check_true (await (async function(){\n                                                            let __array_op_rval__256=compiled['0'].has_lisp_globals;\n                                                             if (__array_op_rval__256 instanceof Function){\n                                                                return await __array_op_rval__256() \n                                                            } else {\n                                                                return [__array_op_rval__256]\n                                                            }\n                                                        })())){\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new Function(\"Environment\",(\"{ return \"+ compiled['1']+ \"} \"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__258=compiled['1'];\n                                                                     if (__array_op_rval__258 instanceof Function){\n                                                                        return await __array_op_rval__258(Environment) \n                                                                    } else {\n                                                                        return [__array_op_rval__258,Environment]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        } else {\n                                                            {\n                                                                await async function(){\n                                                                    compiled[1]=new Function((\"{ return \"+ compiled['1']+ \"}\"));\n                                                                    return compiled;\n                                                                    \n                                                                }();\n                                                                return await (async function(){\n                                                                    let __array_op_rval__260=compiled['1'];\n                                                                     if (__array_op_rval__260 instanceof Function){\n                                                                        return await __array_op_rval__260() \n                                                                    } else {\n                                                                        return [__array_op_rval__260]\n                                                                    }\n                                                                })()\n                                                            }\n                                                        }\n                                                    }\n                                                } else {\n                                                    return compiled['1']\n                                                }\n                                            } () \n                                        })()\n                                    } catch (__exception__244) {\n                                        if (__exception__244 instanceof Error) {\n                                            let e=__exception__244;\n                                            {\n                                                {\n                                                    if (check_true (true)){\n                                                        {\n                                                            let details={\n                                                                error:e.name,message:e.message,expanded_source:await (await get_global(\"pretty_print\"))(await (async function(){\n                                                                     return await (await get_global(\"detokenize\"))(precompiled_assembly) \n                                                                })()),compiled:compiled['1']\n                                                            };\n                                                            ;\n                                                            console.log(\"Syntax Error: \",details);\n                                                            await async function(){\n                                                                e[\"details\"]=details;\n                                                                return e;\n                                                                \n                                                            }()\n                                                        }\n                                                    };\n                                                    if (check_true ((opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4)))){\n                                                        {\n                                                            if (check_true (e.details)){\n                                                                await env_log(\"caught error: \",e.details)\n                                                            } else {\n                                                                await env_log(\"caught error: \",e.name,e.message,e)\n                                                            }\n                                                        }\n                                                    };\n                                                    if (check_true ((false&& (await sub_type(e)===\"SyntaxError\")&& (opts.log_errors|| (Environment.context.scope.__VERBOSITY__>4))))){\n                                                        await console.log(compiled['1'])\n                                                    };\n                                                    if (check_true (opts.error_report)){\n                                                        {\n                                                            await (async function(){\n                                                                let __array_op_rval__262=opts.error_report;\n                                                                 if (__array_op_rval__262 instanceof Function){\n                                                                    return await __array_op_rval__262(await (async function(){\n                                                                        if (check_true (e.details)){\n                                                                            return e.details\n                                                                        } else {\n                                                                            return {\n                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack\n                                                                            }\n                                                                        }\n                                                                    })()) \n                                                                } else {\n                                                                    return [__array_op_rval__262,await (async function(){\n                                                                        if (check_true (e.details)){\n                                                                            return e.details\n                                                                        } else {\n                                                                            return {\n                                                                                error:e.name,message:e.message,form:null,parent_forms:null,invalid:true,text:e.stack\n                                                                            }\n                                                                        }\n                                                                    })()]\n                                                                }\n                                                            })()\n                                                        }\n                                                    };\n                                                    result=e;\n                                                    if (check_true ((await not(opts.catch_errors)|| (ctx&& ctx.in_try)))){\n                                                        {\n                                                            throw result;\n                                                            \n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    };\n                                    return result\n                                }\n                            }\n                        } ()\n                    }],[\"evaluate\",async function(expression,ctx,opts) {\n                        return await async function(){\n                            if (check_true ((namespace===active_namespace))) {\n                                return await evaluate_local(expression,ctx,opts)\n                            } else if (check_true ((namespace===\"core\"))) {\n                                return await (async function() {\n                                    {\n                                         let __call_target__=children[active_namespace], __call_method__=\"evaluate\";\n                                        return await __call_target__[__call_method__].call(__call_target__,expression,ctx,opts)\n                                    } \n                                })()\n                            }\n                        } ()\n                    }],[\"eval_struct\",async function(lisp_struct,ctx,opts) {\n                        let rval;\n                        rval=null;\n                        if (check_true (lisp_struct instanceof Function)){\n                            rval=await (async function(){\n                                let __array_op_rval__267=lisp_struct;\n                                 if (__array_op_rval__267 instanceof Function){\n                                    return await __array_op_rval__267() \n                                } else {\n                                    return [__array_op_rval__267]\n                                }\n                            })()\n                        } else {\n                            rval=await (async function(){\n                                 return await evaluate(lisp_struct,ctx,await add({\n                                    json_in:true\n                                },(opts|| new Object()))) \n                            })()\n                        };\n                        return rval\n                    }],[\"set_compiler\",async function(compiler_function) {\n                        let new_ops;\n                        new_ops=await (async function(){\n                            let __array_op_rval__271=compiler_function;\n                             if (__array_op_rval__271 instanceof Function){\n                                return await __array_op_rval__271([],{\n                                    special_operators:true,env:Environment\n                                }) \n                            } else {\n                                return [__array_op_rval__271,[],{\n                                    special_operators:true,env:Environment\n                                }]\n                            }\n                        })();\n                        if (check_true (await is_set_ques_(new_ops))){\n                            {\n                                compiler_operators=new_ops;\n                                compiler=compiler_function;\n                                await async function(){\n                                    Environment.global_ctx.scope[\"compiler\"]=compiler;\n                                    return Environment.global_ctx.scope;\n                                    \n                                }();\n                                await (await get_global(\"register_feature\"))(\"compiler\")\n                            }\n                        } else {\n                            {\n                                await console.error(\"Invalid compiler function: invalid operators returned. Not installing.\");\n                                throw new EvalError(\"Invalid compiler function\");\n                                \n                            }\n                        };\n                        return compiler\n                    }],[\"clone\",async function(val) {\n                            if (check_true ((val===Environment))){\n                                return Environment\n                            } else {\n                                return await clone(val,0,Environment)\n                            }\n                        }],[\"eval\",async function(expression) {\n                        return await (async function(){\n                            let __array_op_rval__141=expression;\n                             if (__array_op_rval__141 instanceof Function){\n                                return await __array_op_rval__141() \n                            } else {\n                                return [__array_op_rval__141]\n                            }\n                        })()\n                    }],[\"add_escape_encoding\",async function(text) {        if (check_true ((text instanceof String || typeof text==='string'))){            let chars;            let acc;            chars=(text).split(\"\");            acc=[];            await (async function() {                let __for_body__3=async function(c) {                     return  await async function(){                        if (check_true( ((await c[\"charCodeAt\"].call(c,0)===34)))) {                            (acc).push(await String.fromCharCode(92));                             return  (acc).push(c)                        } else  {                             return (acc).push(c)                        }                    } ()                };                let __array__4=[],__elements__2=chars;                let __BREAK__FLAG__=false;                for(let __iter__1 in __elements__2) {                    __array__4.push(await __for_body__3(__elements__2[__iter__1]));                    if(__BREAK__FLAG__) {                         __array__4.pop();                        break;                                            }                }return __array__4;                             })();             return  (acc).join(\"\")        } else {              return text        }    }],[\"get_outside_global\",function get_outside_global(refname) {  try {    let tfn = new Function(\"{ if (typeof \" + refname + \" === 'undefined') { return undefined } else { return \"+refname+\" } }\");    return tfn();  } catch (ex) {    return undefined;  }}],[\"as_lisp\",lisp_writer],[\"lisp_writer\",lisp_writer],[\"clone_to_new\",async function(options) {\n                        let new_env;\n                        let my_children;\n                        let my_children_declarations;\n                        new_env=null;\n                        my_children=null;\n                        my_children_declarations=null;\n                        await env_log(namespace,\"cloning: # children: \",await length(children));\n                        new_env=await (async function(){\n                             return await dlisp_env({\n                                env:await (async function(){\n                                     return await clone(Environment) \n                                })(),children:await (async function(){\n                                     return await clone(children) \n                                })(),children_declarations:await (async function(){\n                                     return await clone(children_declarations) \n                                })()\n                            }) \n                        })();\n                        await env_log(namespace,\"constructed: \",await new_env[\"id\"]());\n                        return new_env\n                    }],[\"save_env\",async function(options) {\n                        let new_env;\n                        let my_children;\n                        let env_constructor;\n                        let dcomps;\n                        let version_tag;\n                        let build_time;\n                        let build_headers;\n                        let child_env;\n                        let want_buffer;\n                        let comp_buffer;\n                        let sorted_dependencies;\n                        let child_export_order;\n                        let preserve_imports;\n                        let include_source;\n                        let exports;\n                        let src;\n                        let target_insertion_path;\n                        let output_path;\n                        new_env=null;\n                        my_children=null;\n                        env_constructor=null;\n                        dcomps=await (async function(){\n                             return await (await get_global(\"date_components\"))(new Date()) \n                        })();\n                        options=(options|| new Object());\n                        version_tag=await (async function(){\n                            if (check_true (await not(await blank_ques_(opts.version_tag)))){\n                                return opts.version_tag\n                            } else {\n                                return (await (async function(){\n                                    let __array_op_rval__328=dcomps.year;\n                                     if (__array_op_rval__328 instanceof Function){\n                                        return await __array_op_rval__328(dcomps.month,dcomps.day,dcomps.hour,dcomps.minute) \n                                    } else {\n                                        return [__array_op_rval__328,dcomps.month,dcomps.day,dcomps.hour,dcomps.minute]\n                                    }\n                                })()).join(\".\")\n                            }\n                        })();\n                        build_time=await (async function(){\n                             return await (await get_global(\"formatted_date\"))(new Date()) \n                        })();\n                        build_headers=[];\n                        child_env=null;\n                        want_buffer=(options.want_buffer|| false);\n                        comp_buffer=null;\n                        sorted_dependencies=await (async function(){\n                             return await (await get_global(\"sort_dependencies\"))() \n                        })();\n                        child_export_order=null;\n                        preserve_imports=await (async function(){\n                            if (check_true ((options&& (options.preserve_imports===false)))){\n                                return false\n                            } else {\n                                return true\n                            }\n                        })();\n                        include_source=false;\n                        exports=[];\n                        src=await (async function(){\n                            if (check_true (await Environment[\"get_global\"].call(Environment,\"*env_skeleton*\",null))){\n                                return await clone(await Environment[\"get_global\"].call(Environment,\"*env_skeleton*\"))\n                            } else {\n                                return await (await get_global(\"reader\"))(await (async function(){\n                                     return await (await get_global(\"read_text_file\"))(\"./src/environment.lisp\") \n                                })())\n                            }\n                        })();\n                        target_insertion_path=null;\n                        output_path=null;\n                        if (check_true (Environment.global_ctx.scope[\"*env_skeleton*\"])){\n                            {\n                                await (await get_global(\"register_feature\"))(\"*env_skeleton*\")\n                            }\n                        };\n                        target_insertion_path=await first(await (async function(){\n                             return await (await get_global(\"findpaths\"))(await (async function(){\n                                 return \"=:included_globals\" \n                            })(),src) \n                        })());\n                        if (check_true (await not((target_insertion_path instanceof Array)))){\n                            throw new EvalError(\"Unable to find the first included_globals symbol\");\n                            \n                        };\n                        target_insertion_path=await conj(await chop(target_insertion_path),[2]);\n                        if (check_true (options.include_source)){\n                            {\n                                include_source=true\n                            }\n                        };\n                        await env_log(namespace,\"cloning: # children: \",await length(children));\n                        await env_log(namespace,\"preserve_imports: \",preserve_imports);\n                        exports=await export_symbol_set(await (async function(){\n                            if (check_true (options.do_not_include)){\n                                return {\n                                    do_not_include:options.do_not_include\n                                }\n                            }\n                        })());\n                        child_export_order=await (async function(){\n                            let __collector;\n                            let __result;\n                            let __action;\n                            __collector=[];\n                            __result=null;\n                            __action=async function(cname) {\n                                if (check_true (await not((cname===\"core\")))){\n                                    {\n                                        return await (async function(){\n                                            let __array_op_rval__329=cname;\n                                             if (__array_op_rval__329 instanceof Function){\n                                                return await __array_op_rval__329(children[cname]) \n                                            } else {\n                                                return [__array_op_rval__329,children[cname]]\n                                            }\n                                        })()\n                                    }\n                                }\n                            };\n                            ;\n                            await (async function() {\n                                let __for_body__332=async function(__item) {\n                                    __result=await __action(__item);\n                                    if (check_true (__result)){\n                                        return (__collector).push(__result)\n                                    }\n                                };\n                                let __array__333=[],__elements__331=sorted_dependencies.namespaces;\n                                let __BREAK__FLAG__=false;\n                                for(let __iter__330 in __elements__331) {\n                                    __array__333.push(await __for_body__332(__elements__331[__iter__330]));\n                                    if(__BREAK__FLAG__) {\n                                         __array__333.pop();\n                                        break;\n                                        \n                                    }\n                                }return __array__333;\n                                 \n                            })();\n                            return __collector\n                        })();\n                        await console.log(\"save_env: child_export_order: \",await (async function(){\n                             return await (await get_global(\"each\"))(child_export_order,0) \n                        })());\n                        my_children=await to_object(await (async function(){\n                            let __collector;\n                            let __result;\n                            let __action;\n                            __collector=[];\n                            __result=null;\n                            __action=async function(child) {\n                                if (check_true (await resolve_path(await (async function(){\n                                    let __array_op_rval__334=child['0'];\n                                     if (__array_op_rval__334 instanceof Function){\n                                        return await __array_op_rval__334(\"serialize_with_image\") \n                                    } else {\n                                        return [__array_op_rval__334,\"serialize_with_image\"]\n                                    }\n                                })(),children_declarations))){\n                                    {\n                                        await env_log(\"checking \",namespace,\"checking for: \",await add(child['0'],\"/*on_serialization*\"));\n                                        if (check_true (await not(((typeof await add(child['0'],\"/*on_serialization*\")===\"undefined\")|| (await Environment[\"get_global\"].call(Environment,await add(child['0'],\"/*on_serialization*\"),ReferenceError)===ReferenceError))))){\n                                            {\n                                                await child['1'][\"evaluate\"].call(child['1'],(\"(\"+ child['0']+ \"/*on_serialization*)\"))\n                                            }\n                                        };\n                                        child_env=await child['1'][\"compile\"].call(child['1'],await child['1'][\"export_symbol_set\"].call(child['1'],await add(new Object(),await (async function(){\n                                            if (check_true (options.do_not_include)){\n                                                return {\n                                                    do_not_include:await (async function(){\n                                                        let comps;\n                                                        comps=null;\n                                                        {\n                                                            let ____collector__335= async function(){\n                                                                return []\n                                                            };\n                                                            let ____result__336= async function(){\n                                                                return null\n                                                            };\n                                                            let ____action__337= async function(){\n                                                                return async function(symbol) {\n                                                                    return await async function(){\n                                                                        if (check_true (await contains_ques_(\"/\",symbol))) {\n                                                                            {\n                                                                                comps=(symbol).split(\"/\");\n                                                                                if (check_true ((comps['0']===child['0']))){\n                                                                                    return comps['1']\n                                                                                }\n                                                                            }\n                                                                        } else {\n                                                                            return symbol\n                                                                        }\n                                                                    } ()\n                                                                }\n                                                            };\n                                                            {\n                                                                let __collector=await ____collector__335();\n                                                                ;\n                                                                let __result=await ____result__336();\n                                                                ;\n                                                                let __action=await ____action__337();\n                                                                ;\n                                                                ;\n                                                                await (async function() {\n                                                                    let __for_body__340=async function(__item) {\n                                                                        __result=await __action(__item);\n                                                                        if (check_true (__result)){\n                                                                            return (__collector).push(__result)\n                                                                        }\n                                                                    };\n                                                                    let __array__341=[],__elements__339=options.do_not_include;\n                                                                    let __BREAK__FLAG__=false;\n                                                                    for(let __iter__338 in __elements__339) {\n                                                                        __array__341.push(await __for_body__340(__elements__339[__iter__338]));\n                                                                        if(__BREAK__FLAG__) {\n                                                                             __array__341.pop();\n                                                                            break;\n                                                                            \n                                                                        }\n                                                                    }return __array__341;\n                                                                     \n                                                                })();\n                                                                return __collector\n                                                            }\n                                                        }\n                                                    })()\n                                                }\n                                            } else {\n                                                return new Object()\n                                            }\n                                        })(),{\n                                            no_compiler:true\n                                        })),{\n                                            throw_on_error:true\n                                        });\n                                        return await (async function(){\n                                            let __array_op_rval__342=child['0'];\n                                             if (__array_op_rval__342 instanceof Function){\n                                                return await __array_op_rval__342(await (async function(){\n                                                     return [[\"=:quotel\",child['1'].definitions],await (async function(){\n                                                         return [\"=:quotel\",await (async function(){\n                                                             return [\"=:javascript\",child_env] \n                                                        })()] \n                                                    })()] \n                                                })()) \n                                            } else {\n                                                return [__array_op_rval__342,await (async function(){\n                                                     return [[\"=:quotel\",child['1'].definitions],await (async function(){\n                                                         return [\"=:quotel\",await (async function(){\n                                                             return [\"=:javascript\",child_env] \n                                                        })()] \n                                                    })()] \n                                                })()]\n                                            }\n                                        })()\n                                    }\n                                }\n                            };\n                            ;\n                            await (async function() {\n                                let __for_body__345=async function(__item) {\n                                    __result=await __action(__item);\n                                    if (check_true (__result)){\n                                        return (__collector).push(__result)\n                                    }\n                                };\n                                let __array__346=[],__elements__344=child_export_order;\n                                let __BREAK__FLAG__=false;\n                                for(let __iter__343 in __elements__344) {\n                                    __array__346.push(await __for_body__345(__elements__344[__iter__343]));\n                                    if(__BREAK__FLAG__) {\n                                         __array__346.pop();\n                                        break;\n                                        \n                                    }\n                                }return __array__346;\n                                 \n                            })();\n                            return __collector\n                        })());\n                        await (await get_global(\"set_path\"))(target_insertion_path,src,await (async function(){\n                             return [\"=:fn\",[],await to_object(await (async function(){\n                                 return [[\"definitions\",await (async function(){\n                                     return [\"=:quote\",await (async function(){\n                                        if (check_true (options.do_not_include)){\n                                            return await to_object(await (async function(){\n                                                let __collector;\n                                                let __result;\n                                                let __action;\n                                                __collector=[];\n                                                __result=null;\n                                                __action=async function(defset) {\n                                                    if (check_true (await not(await contains_ques_(defset['0'],options.do_not_include)))){\n                                                        return await (async function(){\n                                                            let __array_op_rval__347=defset['0'];\n                                                             if (__array_op_rval__347 instanceof Function){\n                                                                return await __array_op_rval__347(defset['1']) \n                                                            } else {\n                                                                return [__array_op_rval__347,defset['1']]\n                                                            }\n                                                        })()\n                                                    }\n                                                };\n                                                ;\n                                                await (async function() {\n                                                    let __for_body__350=async function(__item) {\n                                                        __result=await __action(__item);\n                                                        if (check_true (__result)){\n                                                            return (__collector).push(__result)\n                                                        }\n                                                    };\n                                                    let __array__351=[],__elements__349=await pairs(Environment.definitions);\n                                                    let __BREAK__FLAG__=false;\n                                                    for(let __iter__348 in __elements__349) {\n                                                        __array__351.push(await __for_body__350(__elements__349[__iter__348]));\n                                                        if(__BREAK__FLAG__) {\n                                                             __array__351.pop();\n                                                            break;\n                                                            \n                                                        }\n                                                    }return __array__351;\n                                                     \n                                                })();\n                                                return __collector\n                                            })())\n                                        } else {\n                                            return await clone(Environment.definitions)\n                                        }\n                                    })()] \n                                })()],[\"declarations\",await (async function(){\n                                     return await clone(Environment.declarations) \n                                })()],[\"config\",await (async function(){\n                                    let exp_conf;\n                                    exp_conf=await (async function(){\n                                         return await clone(Environment.global_ctx.scope[\"*env_config*\"]) \n                                    })();\n                                    if (check_true (await not(preserve_imports))){\n                                        {\n                                            await async function(){\n                                                exp_conf[\"imports\"]=new Object();\n                                                return exp_conf;\n                                                \n                                            }()\n                                        }\n                                    };\n                                    if (check_true (options.features)){\n                                        {\n                                            await async function(){\n                                                exp_conf[\"features\"]=options.features;\n                                                return exp_conf;\n                                                \n                                            }()\n                                        }\n                                    };\n                                    return exp_conf\n                                })()],[\"imports\",await (async function(){\n                                    if (check_true (preserve_imports)){\n                                        return await to_object(await (async function() {\n                                            let __for_body__356=async function(imp_source) {\n                                                return await (async function(){\n                                                    let __array_op_rval__358=imp_source.symbol;\n                                                     if (__array_op_rval__358 instanceof Function){\n                                                        return await __array_op_rval__358({\n                                                            initializer:await (async function(){\n                                                                 return [\"=:javascript\",\"new function () { return \",imp_source.symbol,\" }\"] \n                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace\n                                                        }) \n                                                    } else {\n                                                        return [__array_op_rval__358,{\n                                                            initializer:await (async function(){\n                                                                 return [\"=:javascript\",\"new function () { return \",imp_source.symbol,\" }\"] \n                                                            })(),symbol:imp_source.symbol,namespace:imp_source.namespace\n                                                        }]\n                                                    }\n                                                })()\n                                            };\n                                            let __array__357=[],__elements__355=await values((await resolve_path([\"*env_config*\",\"imports\"],Environment.global_ctx.scope)|| new Object()));\n                                            let __BREAK__FLAG__=false;\n                                            for(let __iter__354 in __elements__355) {\n                                                __array__357.push(await __for_body__356(__elements__355[__iter__354]));\n                                                if(__BREAK__FLAG__) {\n                                                     __array__357.pop();\n                                                    break;\n                                                    \n                                                }\n                                            }return __array__357;\n                                             \n                                        })())\n                                    } else {\n                                        return new Object()\n                                    }\n                                })()],[\"symbols\",await (async function(){\n                                     return [\"=:javascript\",await compile(await to_object(exports),{\n                                        throw_on_error:true\n                                    })] \n                                })()],[\"children_declarations\",await (async function(){\n                                     return [\"=:fn\",[],await clone(children_declarations)] \n                                })()],[\"child_load_order\",await (async function(){\n                                     return await (await get_global(\"each\"))(child_export_order,0) \n                                })()],[\"children\",my_children]] \n                            })())] \n                        })());\n                        output_path=await (async function(){\n                            if (check_true (options.want_buffer)){\n                                return null\n                            } else {\n                                return (options.save_as|| await resolve_path([\"*env_config*\",\"export\",\"save_path\"],Environment.global_ctx.scope))\n                            }\n                        })();\n                        if (check_true (output_path instanceof Function)){\n                            output_path=await (async function(){\n                                let __array_op_rval__359=output_path;\n                                 if (__array_op_rval__359 instanceof Function){\n                                    return await __array_op_rval__359() \n                                } else {\n                                    return [__array_op_rval__359]\n                                }\n                            })()\n                        };\n                        if (check_true ((await not((output_path instanceof String || typeof output_path==='string'))&& output_path))){\n                            throw new EvalError(\"invalid name for target for saving the environment.  Must be a string or function\");\n                            \n                        };\n                        return await async function(){\n                            if (check_true ((want_buffer|| (output_path&& await ends_with_ques_(\".js\",output_path))))) {\n                                {\n                                    (build_headers).push((\"// Build Time: \"+ build_time));\n                                    (build_headers).push((\"// Version: \"+ version_tag));\n                                    (build_headers).push((\"export const DLISP_ENV_VERSION='\"+ version_tag+ \"';\"));\n                                    await env_log(\"saving to: \",output_path);\n                                    return await (await get_global(\"compile_buffer\"))(src,\"init_dlisp\",{\n                                        namespace:namespace,toplevel:true,include_boilerplate:false,verbose:false,bundle:true,want_buffer:want_buffer,imports:await (async function(){\n                                            if (check_true (preserve_imports)){\n                                                return await resolve_path([\"*env_config*\",\"imports\"],Environment.global_ctx.scope)\n                                            }\n                                        })(),js_headers:await (async function(){\n                                             return [await (await get_global(\"show\"))(check_true),await (async function(){\n                                                 return await (await get_global(\"show\"))(get_next_environment_id) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(get_outside_global) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(subtype) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(lisp_writer) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(clone) \n                                            })(),await (async function(){\n                                                 return await (await get_global(\"show\"))(LispSyntaxError) \n                                            })()] \n                                        })(),bundle_options:{\n                                            default_namespace:await resolve_path([\"*env_config*\",\"export\",\"default_namespace\"],Environment.global_ctx.scope)\n                                        },output_file:output_path,include_source:(options.include_source|| await resolve_path([\"*env_config*\",\"export\",\"include_source\"],Environment.global_ctx.scope)),build_headers:build_headers\n                                    })\n                                }\n                            } else if (check_true ((output_path&& await ends_with_ques_(\".lisp\",output_path)))) {\n                                return await (await get_global(\"write_text_file\"))(output_path,await JSON.stringify(src,null,4))\n                            } else {\n                                return src\n                            }\n                        } ()\n                    }],[\"null\",null],[\"is_Response?\",function(value) {\n        return (value instanceof Response)\n    }],[\"get_content_type\",function(obj) {\n        return  (obj && obj[\"headers\"])[\"get\"].call((obj && obj[\"headers\"]),\"content-type\")\n    }],[\"send_http\",async function(method,url,data,headers) {\n    if (check_true (((method instanceof String || typeof method==='string')&& (url instanceof String || typeof url==='string')))){\n        {\n            let response;\n            headers=await (await Environment.get_global(\"add\"))(await ( async function(){\n                let __obj__1=new Object();\n                __obj__1[\"Content-Type\"]=\"application/json\";\n                return __obj__1;\n                \n            })(),await (async function(){\n                if (check_true ((headers instanceof Object))){\n                    return headers\n                } else {\n                    return new Object()\n                }\n            })());\n            response=await fetch(url,{\n                method:method,mode:\"cors\",cache:\"no-cache\",credentials:\"same-origin\",headers:headers,redirect:\"follow\",referrerPolicy:\"no-referrer\",body:await (async function(){\n                    if (check_true (((headers && headers[\"Content-Type\"])===\"application/json\"))){\n                        return await JSON.stringify(data)\n                    } else {\n                        return data\n                    }\n                })()\n            });\n            return response\n        }\n    } else {\n        throw new SyntaxError(\"send_http requires a method string and a url string\");\n        \n    }\n}],[\"response_handler\",async function(response,options) {\n    if (check_true (((response && response[\"status\"])===200))){\n        return await async function(){\n            if (check_true ((options && options[\"raw_response\"]))) {\n                return response\n            } else if (check_true ((await (await Environment.get_global(\"get_content_type\"))(response)===\"application/json\"))) {\n                return await response[\"json\"]()\n            } else if (check_true (await (await Environment.get_global(\"starts_with?\"))(await (await Environment.get_global(\"get_content_type\"))(response),\"text/\"))) {\n                return await response[\"text\"]()\n            } else {\n                return await response[\"blob\"]()\n            }\n        } ()\n    } else {\n        return response\n    }\n}],[\"post\",async function(url,data,options) {\n    let response;\n    response=null;\n    response=await (await Environment.get_global(\"send_http\"))(\"POST\",url,data,(options && options[\"headers\"]));\n    return await (await Environment.get_global(\"response_handler\"))(response,options)\n}],[\"put\",async function(url,data,options) {\n    let response;\n    response=null;\n    response=await (await Environment.get_global(\"send_http\"))(\"PUT\",url,data,(options && options[\"headers\"]));\n    return await (await Environment.get_global(\"response_handler\"))(response,options)\n}],[\"get\",async function(url,options) {\n    let response;\n    let headers;\n    response=null;\n    options=(options|| new Object());\n    headers=await (await Environment.get_global(\"add\"))(await ( async function(){\n        let __obj__2=new Object();\n        __obj__2[\"Content-Type\"]=\"application/json\";\n        return __obj__2;\n        \n    })(),await (async function(){\n        if (check_true ((headers instanceof Object))){\n            return headers\n        } else {\n            return new Object()\n        }\n    })());\n    response=await fetch(url,await (await Environment.get_global(\"add\"))({\n        method:\"GET\",mode:\"cors\",cache:\"no-cache\",credentials:\"same-origin\",redirect:\"follow\",referrerPolicy:\"no-referrer\"\n    },await (async function(){\n        if (check_true ((options instanceof Object))){\n            return options\n        } else {\n            return new Object()\n        }\n    })()));\n    return await (await Environment.get_global(\"response_handler\"))(response,options)\n}],[\"send_files\",async function(url,file_object,options) {\n    let files;\n    let idx;\n    let form_data;\n    let response;\n    options=await (async function(){\n        if (check_true ((options instanceof Object))){\n            return options\n        } else {\n            return new Object()\n        }\n    })();\n    files=await (async function(){\n        if (check_true ((file_object instanceof Array))){\n            return file_object\n        } else {\n            return await (async function(){\n                let __array_op_rval__3=file_object;\n                 if (__array_op_rval__3 instanceof Function){\n                    return await __array_op_rval__3() \n                } else {\n                    return [__array_op_rval__3]\n                }\n            })()\n        }\n    })();\n    idx=0;\n    form_data=new FormData();\n    response=null;\n    await (async function() {\n        let __for_body__6=async function(file) {\n            await form_data[\"append\"].call(form_data,(\"file\"+ idx),file,(file && file.name));\n            return idx+=1\n        };\n        let __array__7=[],__elements__5=files;\n        let __BREAK__FLAG__=false;\n        for(let __iter__4 in __elements__5) {\n            __array__7.push(await __for_body__6(__elements__5[__iter__4]));\n            if(__BREAK__FLAG__) {\n                 __array__7.pop();\n                break;\n                \n            }\n        }return __array__7;\n         \n    })();\n    response=await fetch(url,{\n        method:\"POST\",mode:\"cors\",cache:\"no-cache\",credentials:\"same-origin\",redirect:\"follow\",referrerPolicy:\"no-referrer\",body:form_data\n    });\n    return await (await Environment.get_global(\"response_handler\"))(response,options)\n}],[\"data_to_file\",async function(name,data,content_type,last_modified) {\n    if (check_true (data)){\n        {\n            let ctype;\n            let enc_data;\n            ctype=await (async function(){\n                 return await async function(){\n                    if (check_true (((content_type==null)&& (data instanceof String || typeof data==='string')))) {\n                        return \"text/plain\"\n                    } else if (check_true ((await (await Environment.get_global(\"not\"))((data instanceof Object))&& (content_type==null)))) {\n                        return \"text/plain\"\n                    } else if (check_true ((content_type instanceof String || typeof content_type==='string'))) {\n                        return content_type\n                    } else if (check_true ((data instanceof Object))) {\n                        return \"application/json\"\n                    } else {\n                        throw new TypeError(\"data_to_file: Invalid content_type argument - must be string\");\n                        \n                    }\n                } () \n            })();\n            enc_data=await (async function(){\n                 return await async function(){\n                    if (check_true (await (await Environment.get_global(\"starts_with?\"))(\"text\",ctype))) {\n                        return await (async function(){\n                            let __array_op_rval__8=data;\n                             if (__array_op_rval__8 instanceof Function){\n                                return await __array_op_rval__8() \n                            } else {\n                                return [__array_op_rval__8]\n                            }\n                        })()\n                    } else if (check_true ((\"application/json\"===ctype))) {\n                        return [await JSON.stringify(data)]\n                    } else {\n                        return [new Blob(await (async function(){\n                            let __array_op_rval__9=data;\n                             if (__array_op_rval__9 instanceof Function){\n                                return await __array_op_rval__9() \n                            } else {\n                                return [__array_op_rval__9]\n                            }\n                        })())]\n                    }\n                } () \n            })();\n            return new File(enc_data,(name|| \"unnamed\"),await (await Environment.get_global(\"add\"))(new Object(),{\n                type:ctype\n            },await (async function(){\n                if (check_true (await (await Environment.get_global(\"is_number?\"))(last_modified))){\n                    return {\n                        last_modified:last_modified\n                    }\n                } else {\n                    return new Object()\n                }\n            })()))\n        }\n    } else {\n        throw new TypeError(\"data_to_file: nil or undefined value provided\");\n        \n    }\n}],[\"list_files\",async function(path) {\n    let rval;\n    rval=await (async function(){\n         return await (await Environment.get_global(\"http/get\"))((\"/files/\"+ path)) \n    })();\n    if (check_true ((rval instanceof Response))){\n        throw new Error((rval && rval[\"statusText\"]));\n        \n    } else {\n        return await async function(){\n            if (check_true (((rval && rval[\"rval\"])===\"OK\"))) {\n                return (rval && rval.entries)\n            } else {\n                return rval\n            }\n        } ()\n    }\n}],[\"create_websocket\",async function(uri,options) {\n    let ws;\n    let on_close;\n    let on_open;\n    let on_message;\n    let on_error;\n    options=(options|| new Object());\n    ws=new WebSocket(uri);\n    on_close=await (async function(){\n        if (check_true ((options && options[\"on_close\"]))){\n            return (options && options[\"on_close\"])\n        } else {\n            return null\n        }\n    })();\n    on_open=((options && options[\"on_open\"])|| null);\n    on_message=((options && options[\"on_message\"])|| async function(e) {\n        return await console.log((e && e[\"data\"]))\n    });\n    on_error=((options && options[\"on_error\"])|| async function(e) {\n        return await console.error(\"ERROR: \",(e && e[\"data\"]))\n    });\n    if (check_true (on_open)){\n        {\n            await async function(){\n                ws[\"onopen\"]=on_open;\n                return ws;\n                \n            }()\n        }\n    };\n    if (check_true (on_close)){\n        {\n            await async function(){\n                ws[\"onclose\"]=on_close;\n                return ws;\n                \n            }()\n        }\n    };\n    if (check_true (on_message)){\n        {\n            await async function(){\n                ws[\"onmessage\"]=on_message;\n                return ws;\n                \n            }()\n        }\n    };\n    if (check_true (on_error)){\n        {\n            await async function(){\n                ws[\"onerror\"]=on_error;\n                return ws;\n                \n            }()\n        }\n    };\n    return ws\n}],[\"send_to_ws\",async function(ws,data) {\n    return await ws[\"send\"].call(ws,await (async function(){\n        if (check_true ((data instanceof Object))){\n            return await JSON.stringify(data)\n        } else {\n            return data\n        }\n    })())\n}],[\"close_ws\",async function(ws) {\n    return await ws[\"close\"]()\n}],[\"load\",async function(filename) {\n    if (check_true (((filename instanceof String || typeof filename==='string')&& await (await Environment.get_global(\"not\"))(await (await Environment.get_global(\"blank?\"))(filename))))){\n        {\n            let evaluator;\n            evaluator=await Environment[\"get_namespace_handle\"].call(Environment,await (await Environment.get_global(\"current_namespace\"))());\n            await (await Environment.get_global(\"assert\"))(evaluator,\"load cannot get current namespace evaluator\");\n            return await evaluator[\"evaluate\"].call(evaluator,await (async function(){\n                 return await (await Environment.get_global(\"fetch_text\"))((\"/files/\"+ filename)) \n            })(),null,{\n                source_name:filename\n            })\n        }\n    }\n}]]"] 
        })()] 
    })()
}
}
};
;
let imps=null;
;
let rehydrated_children=false;
;
if (check_true ((included_globals&& (namespace==="core")))){
    {
        try {
            included_globals=await included_globals()
        } catch (__exception__286) {
            if (__exception__286 instanceof Error) {
                let e=__exception__286;
                {
                    await console.error("ERROR: ",e)
                }
            }
        };
        if (check_true (await resolve_path(["symbols","compiler"],included_globals))){
            {
                await async function(){
                    Environment.global_ctx.scope["compiler"]=await resolve_path(["symbols","compiler"],included_globals);
                    return Environment.global_ctx.scope;
                    
                }();
                compiler=Environment.global_ctx.scope.compiler
            }
        };
        if (check_true ((included_globals["config"] instanceof Object))){
            {
                await async function(){
                    Environment.global_ctx.scope["*env_config*"]=included_globals.config;
                    return Environment.global_ctx.scope;
                    
                }()
            }
        };
        if (check_true ((included_globals["imports"] instanceof Object))){
            {
                imps=included_globals["imports"];
                if (check_true (imps)){
                    {
                        await (async function() {
                            let __for_body__291=async function(imp_source) {
                                return await async function(){
                                    if (check_true ((imp_source.namespace===namespace))) {
                                        {
                                            return await async function(){
                                                Environment.global_ctx.scope[imp_source.symbol]=imp_source.initializer;
                                                return Environment.global_ctx.scope;
                                                
                                            }()
                                        }
                                    }
                                } ()
                            };
                            let __array__292=[],__elements__290=await values(imps);
                            let __BREAK__FLAG__=false;
                            for(let __iter__289 in __elements__290) {
                                __array__292.push(await __for_body__291(__elements__290[__iter__289]));
                                if(__BREAK__FLAG__) {
                                     __array__292.pop();
                                    break;
                                    
                                }
                            }return __array__292;
                             
                        })()
                    }
                }
            }
        };
        if (check_true ((included_globals["symbols"] instanceof Object))){
            {
                await (async function() {
                    let __for_body__296=async function(symset) {
                        if (check_true ((null==Environment.global_ctx.scope[symset['0']]))){
                            {
                                return await async function(){
                                    Environment.global_ctx.scope[symset['0']]=symset['1'];
                                    return Environment.global_ctx.scope;
                                    
                                }()
                            }
                        }
                    };
                    let __array__297=[],__elements__295=await pairs(included_globals.symbols);
                    let __BREAK__FLAG__=false;
                    for(let __iter__294 in __elements__295) {
                        __array__297.push(await __for_body__296(__elements__295[__iter__294]));
                        if(__BREAK__FLAG__) {
                             __array__297.pop();
                            break;
                            
                        }
                    }return __array__297;
                     
                })()
            }
        };
        if (check_true ((included_globals["definitions"] instanceof Object))){
            {
                await (async function() {
                    let __for_body__301=async function(symset) {
                        if (check_true ((null==Environment.definitions[symset['0']]))){
                            {
                                return await async function(){
                                    Environment.definitions[symset['0']]=symset['1'];
                                    return Environment.definitions;
                                    
                                }()
                            }
                        }
                    };
                    let __array__302=[],__elements__300=await pairs(included_globals.definitions);
                    let __BREAK__FLAG__=false;
                    for(let __iter__299 in __elements__300) {
                        __array__302.push(await __for_body__301(__elements__300[__iter__299]));
                        if(__BREAK__FLAG__) {
                             __array__302.pop();
                            break;
                            
                        }
                    }return __array__302;
                     
                })()
            }
        };
        if (check_true ((included_globals["declarations"] instanceof Object))){
            {
                await (async function() {
                    let __for_body__306=async function(symset) {
                        if (check_true ((null==Environment.declarations[symset['0']]))){
                            {
                                return await async function(){
                                    Environment.declarations[symset['0']]=await (async function(){
                                         return "=:symset.1" 
                                    })();
                                    return Environment.declarations;
                                    
                                }()
                            }
                        }
                    };
                    let __array__307=[],__elements__305=await pairs(included_globals.declarations);
                    let __BREAK__FLAG__=false;
                    for(let __iter__304 in __elements__305) {
                        __array__307.push(await __for_body__306(__elements__305[__iter__304]));
                        if(__BREAK__FLAG__) {
                             __array__307.pop();
                            break;
                            
                        }
                    }return __array__307;
                     
                })()
            }
        };
        if (check_true (Environment.global_ctx.scope["compiler"])){
            {
                await set_compiler(Environment.global_ctx.scope["compiler"])
            }
        };
        if (check_true ((included_globals["children"] instanceof Object))){
            {
                rehydrated_children=true;
                await (async function() {
                    let __for_body__311=async function(childset) {
                        return await (await get_global("create_namespace"))(childset['0'],await (async function(){
                            if (check_true (included_globals.children_declarations[childset['0']])){
                                return included_globals.children_declarations[childset['0']]
                            } else {
                                return new Object()
                            }
                        })(),true)
                    };
                    let __array__312=[],__elements__310=await pairs(included_globals.children);
                    let __BREAK__FLAG__=false;
                    for(let __iter__309 in __elements__310) {
                        __array__312.push(await __for_body__311(__elements__310[__iter__309]));
                        if(__BREAK__FLAG__) {
                             __array__312.pop();
                            break;
                            
                        }
                    }return __array__312;
                     
                })()
            }
        }
    }
};
let clone_to_new=async function(options) {
    let new_env;
    let my_children;
    let my_children_declarations;
    new_env=null;
    my_children=null;
    my_children_declarations=null;
    await env_log(namespace,"cloning: # children: ",await length(children));
    new_env=await (async function(){
         return await dlisp_env({
            env:await (async function(){
                 return await clone(Environment) 
            })(),children:await (async function(){
                 return await clone(children) 
            })(),children_declarations:await (async function(){
                 return await clone(children_declarations) 
            })()
        }) 
    })();
    await env_log(namespace,"constructed: ",await new_env["id"]());
    return new_env
};
;
let export_symbol_set=async function(options) {
    let __collector;
    let __result;
    let __action;
    __collector=[];
    __result=null;
    __action=async function(symset) {
        return await async function(){
            if (check_true ((options&& options.no_compiler&& (symset['0']==="compiler")))) {
                return null
            } else if (check_true (await starts_with_ques_("$",symset['0']))) {
                return null
            } else if (check_true ((await resolve_path(await (async function(){
                let __array_op_rval__313=symset['0'];
                 if (__array_op_rval__313 instanceof Function){
                    return await __array_op_rval__313("serialize_with_image") 
                } else {
                    return [__array_op_rval__313,"serialize_with_image"]
                }
            })(),Environment.definitions)===false))) {
                return null
            } else if (check_true ((options&& options.do_not_include&& await contains_ques_(symset['0'],options.do_not_include)))) {
                return null
            } else if (check_true ((symset['0']==="*env_skeleton*"))) {
                return await (async function(){
                    let __array_op_rval__314=symset['0'];
                     if (__array_op_rval__314 instanceof Function){
                        return await __array_op_rval__314(await (async function(){
                             return ["=:quotel",Environment.global_ctx.scope["*env_skeleton*"]] 
                        })()) 
                    } else {
                        return [__array_op_rval__314,await (async function(){
                             return ["=:quotel",Environment.global_ctx.scope["*env_skeleton*"]] 
                        })()]
                    }
                })()
            } else if (check_true (await resolve_path(await (async function(){
                let __array_op_rval__315=symset['0'];
                 if (__array_op_rval__315 instanceof Function){
                    return await __array_op_rval__315("initializer") 
                } else {
                    return [__array_op_rval__315,"initializer"]
                }
            })(),Environment.definitions))) {
                {
                    return await (async function(){
                        let __array_op_rval__316=symset['0'];
                         if (__array_op_rval__316 instanceof Function){
                            return await __array_op_rval__316(await (async function(){
                                 return ["=:quotel","placeholder"] 
                            })()) 
                        } else {
                            return [__array_op_rval__316,await (async function(){
                                 return ["=:quotel","placeholder"] 
                            })()]
                        }
                    })()
                }
            } else if (check_true (await (async function(){
                 return await is_regex_ques_(symset['1']) 
            })())) {
                return await (async function(){
                    let __array_op_rval__317=symset['0'];
                     if (__array_op_rval__317 instanceof Function){
                        return await __array_op_rval__317(await (async function(){
                             return ["=:javascript",await (async function(){
                                 return ("/"+ await add(symset['1'].source)+ "/"+ symset['1'].flags) 
                            })()] 
                        })()) 
                    } else {
                        return [__array_op_rval__317,await (async function(){
                             return ["=:javascript",await (async function(){
                                 return ("/"+ await add(symset['1'].source)+ "/"+ symset['1'].flags) 
                            })()] 
                        })()]
                    }
                })()
            } else if (check_true (await (async function(){
                 return await is_date_ques_(symset['1']) 
            })())) {
                return await (async function(){
                    let __array_op_rval__318=symset['0'];
                     if (__array_op_rval__318 instanceof Function){
                        return await __array_op_rval__318(await (async function(){
                             return ["=:javascript",await (async function(){
                                 return ("new Date(\""+ await add(await symset['1']["toJSON"](),"\")")) 
                            })()] 
                        })()) 
                    } else {
                        return [__array_op_rval__318,await (async function(){
                             return ["=:javascript",await (async function(){
                                 return ("new Date(\""+ await add(await symset['1']["toJSON"](),"\")")) 
                            })()] 
                        })()]
                    }
                })()
            } else if (check_true ((null===symset['1']))) {
                return await (async function(){
                    let __array_op_rval__319=symset['0'];
                     if (__array_op_rval__319 instanceof Function){
                        return await __array_op_rval__319(await (async function(){
                             return "=:nil" 
                        })()) 
                    } else {
                        return [__array_op_rval__319,await (async function(){
                             return "=:nil" 
                        })()]
                    }
                })()
            } else if (check_true ((undefined===symset['1']))) {
                return await (async function(){
                    let __array_op_rval__320=symset['0'];
                     if (__array_op_rval__320 instanceof Function){
                        return await __array_op_rval__320(await (async function(){
                             return "=:undefined" 
                        })()) 
                    } else {
                        return [__array_op_rval__320,await (async function(){
                             return "=:undefined" 
                        })()]
                    }
                })()
            } else if (check_true ((symset['1'] instanceof String || typeof symset['1']==='string'))) {
                {
                    return await (async function(){
                        let __array_op_rval__321=symset['0'];
                         if (__array_op_rval__321 instanceof Function){
                            return await __array_op_rval__321(await (async function(){
                                 return await (await get_global("env_encode_string"))(symset['1']) 
                            })()) 
                        } else {
                            return [__array_op_rval__321,await (async function(){
                                 return await (await get_global("env_encode_string"))(symset['1']) 
                            })()]
                        }
                    })()
                }
            } else {
                return await (async function(){
                    let __array_op_rval__322=symset['0'];
                     if (__array_op_rval__322 instanceof Function){
                        return await __array_op_rval__322(symset['1']) 
                    } else {
                        return [__array_op_rval__322,symset['1']]
                    }
                })()
            }
        } ()
    };
    ;
    await (async function() {
        let __for_body__325=async function(__item) {
            __result=await __action(__item);
            if (check_true (__result)){
                return (__collector).push(__result)
            }
        };
        let __array__326=[],__elements__324=await pairs(await (async function(){
             return await clone(Environment.global_ctx.scope) 
        })());
        let __BREAK__FLAG__=false;
        for(let __iter__323 in __elements__324) {
            __array__326.push(await __for_body__325(__elements__324[__iter__323]));
            if(__BREAK__FLAG__) {
                 __array__326.pop();
                break;
                
            }
        }return __array__326;
         
    })();
    return __collector
};
;
let save_env=async function(options) {
    let new_env;
    let my_children;
    let env_constructor;
    let dcomps;
    let version_tag;
    let build_time;
    let build_headers;
    let child_env;
    let want_buffer;
    let comp_buffer;
    let sorted_dependencies;
    let child_export_order;
    let preserve_imports;
    let include_source;
    let exports;
    let src;
    let target_insertion_path;
    let output_path;
    new_env=null;
    my_children=null;
    env_constructor=null;
    dcomps=await (async function(){
         return await (await get_global("date_components"))(new Date()) 
    })();
    options=(options|| new Object());
    version_tag=await (async function(){
        if (check_true (await not(await blank_ques_(opts.version_tag)))){
            return opts.version_tag
        } else {
            return (await (async function(){
                let __array_op_rval__327=dcomps.year;
                 if (__array_op_rval__327 instanceof Function){
                    return await __array_op_rval__327(dcomps.month,dcomps.day,dcomps.hour,dcomps.minute) 
                } else {
                    return [__array_op_rval__327,dcomps.month,dcomps.day,dcomps.hour,dcomps.minute]
                }
            })()).join(".")
        }
    })();
    build_time=await (async function(){
         return await (await get_global("formatted_date"))(new Date()) 
    })();
    build_headers=[];
    child_env=null;
    want_buffer=(options.want_buffer|| false);
    comp_buffer=null;
    sorted_dependencies=await (async function(){
         return await (await get_global("sort_dependencies"))() 
    })();
    child_export_order=null;
    preserve_imports=await (async function(){
        if (check_true ((options&& (options.preserve_imports===false)))){
            return false
        } else {
            return true
        }
    })();
    include_source=false;
    exports=[];
    src=await (async function(){
        if (check_true (await Environment["get_global"].call(Environment,"*env_skeleton*",null))){
            return await clone(await Environment["get_global"].call(Environment,"*env_skeleton*"))
        } else {
            return await (await get_global("reader"))(await (async function(){
                 return await (await get_global("read_text_file"))("./src/environment.lisp") 
            })())
        }
    })();
    target_insertion_path=null;
    output_path=null;
    if (check_true (Environment.global_ctx.scope["*env_skeleton*"])){
        {
            await (await get_global("register_feature"))("*env_skeleton*")
        }
    };
    target_insertion_path=await first(await (async function(){
         return await (await get_global("findpaths"))(await (async function(){
             return "=:included_globals" 
        })(),src) 
    })());
    if (check_true (await not((target_insertion_path instanceof Array)))){
        throw new EvalError("Unable to find the first included_globals symbol");
        
    };
    target_insertion_path=await conj(await chop(target_insertion_path),[2]);
    if (check_true (options.include_source)){
        {
            include_source=true
        }
    };
    await env_log(namespace,"cloning: # children: ",await length(children));
    await env_log(namespace,"preserve_imports: ",preserve_imports);
    exports=await export_symbol_set(await (async function(){
        if (check_true (options.do_not_include)){
            return {
                do_not_include:options.do_not_include
            }
        }
    })());
    child_export_order=await (async function(){
        let __collector;
        let __result;
        let __action;
        __collector=[];
        __result=null;
        __action=async function(cname) {
            if (check_true (await not((cname==="core")))){
                {
                    return await (async function(){
                        let __array_op_rval__328=cname;
                         if (__array_op_rval__328 instanceof Function){
                            return await __array_op_rval__328(children[cname]) 
                        } else {
                            return [__array_op_rval__328,children[cname]]
                        }
                    })()
                }
            }
        };
        ;
        await (async function() {
            let __for_body__331=async function(__item) {
                __result=await __action(__item);
                if (check_true (__result)){
                    return (__collector).push(__result)
                }
            };
            let __array__332=[],__elements__330=sorted_dependencies.namespaces;
            let __BREAK__FLAG__=false;
            for(let __iter__329 in __elements__330) {
                __array__332.push(await __for_body__331(__elements__330[__iter__329]));
                if(__BREAK__FLAG__) {
                     __array__332.pop();
                    break;
                    
                }
            }return __array__332;
             
        })();
        return __collector
    })();
    await console.log("save_env: child_export_order: ",await (async function(){
         return await (await get_global("each"))(child_export_order,0) 
    })());
    my_children=await to_object(await (async function(){
        let __collector;
        let __result;
        let __action;
        __collector=[];
        __result=null;
        __action=async function(child) {
            if (check_true (await resolve_path(await (async function(){
                let __array_op_rval__333=child['0'];
                 if (__array_op_rval__333 instanceof Function){
                    return await __array_op_rval__333("serialize_with_image") 
                } else {
                    return [__array_op_rval__333,"serialize_with_image"]
                }
            })(),children_declarations))){
                {
                    await env_log("checking ",namespace,"checking for: ",await add(child['0'],"/*on_serialization*"));
                    if (check_true (await not(((typeof await add(child['0'],"/*on_serialization*")==="undefined")|| (await Environment["get_global"].call(Environment,await add(child['0'],"/*on_serialization*"),ReferenceError)===ReferenceError))))){
                        {
                            await child['1']["evaluate"].call(child['1'],("("+ child['0']+ "/*on_serialization*)"))
                        }
                    };
                    child_env=await child['1']["compile"].call(child['1'],await child['1']["export_symbol_set"].call(child['1'],await add(new Object(),await (async function(){
                        if (check_true (options.do_not_include)){
                            return {
                                do_not_include:await (async function(){
                                    let comps;
                                    comps=null;
                                    {
                                        let ____collector__334= async function(){
                                            return []
                                        };
                                        let ____result__335= async function(){
                                            return null
                                        };
                                        let ____action__336= async function(){
                                            return async function(symbol) {
                                                return await async function(){
                                                    if (check_true (await contains_ques_("/",symbol))) {
                                                        {
                                                            comps=(symbol).split("/");
                                                            if (check_true ((comps['0']===child['0']))){
                                                                return comps['1']
                                                            }
                                                        }
                                                    } else {
                                                        return symbol
                                                    }
                                                } ()
                                            }
                                        };
                                        {
                                            let __collector=await ____collector__334();
                                            ;
                                            let __result=await ____result__335();
                                            ;
                                            let __action=await ____action__336();
                                            ;
                                            ;
                                            await (async function() {
                                                let __for_body__339=async function(__item) {
                                                    __result=await __action(__item);
                                                    if (check_true (__result)){
                                                        return (__collector).push(__result)
                                                    }
                                                };
                                                let __array__340=[],__elements__338=options.do_not_include;
                                                let __BREAK__FLAG__=false;
                                                for(let __iter__337 in __elements__338) {
                                                    __array__340.push(await __for_body__339(__elements__338[__iter__337]));
                                                    if(__BREAK__FLAG__) {
                                                         __array__340.pop();
                                                        break;
                                                        
                                                    }
                                                }return __array__340;
                                                 
                                            })();
                                            return __collector
                                        }
                                    }
                                })()
                            }
                        } else {
                            return new Object()
                        }
                    })(),{
                        no_compiler:true
                    })),{
                        throw_on_error:true
                    });
                    return await (async function(){
                        let __array_op_rval__341=child['0'];
                         if (__array_op_rval__341 instanceof Function){
                            return await __array_op_rval__341(await (async function(){
                                 return [["=:quotel",child['1'].definitions],await (async function(){
                                     return ["=:quotel",await (async function(){
                                         return ["=:javascript",child_env] 
                                    })()] 
                                })()] 
                            })()) 
                        } else {
                            return [__array_op_rval__341,await (async function(){
                                 return [["=:quotel",child['1'].definitions],await (async function(){
                                     return ["=:quotel",await (async function(){
                                         return ["=:javascript",child_env] 
                                    })()] 
                                })()] 
                            })()]
                        }
                    })()
                }
            }
        };
        ;
        await (async function() {
            let __for_body__344=async function(__item) {
                __result=await __action(__item);
                if (check_true (__result)){
                    return (__collector).push(__result)
                }
            };
            let __array__345=[],__elements__343=child_export_order;
            let __BREAK__FLAG__=false;
            for(let __iter__342 in __elements__343) {
                __array__345.push(await __for_body__344(__elements__343[__iter__342]));
                if(__BREAK__FLAG__) {
                     __array__345.pop();
                    break;
                    
                }
            }return __array__345;
             
        })();
        return __collector
    })());
    await (await get_global("set_path"))(target_insertion_path,src,await (async function(){
         return ["=:fn",[],await to_object(await (async function(){
             return [["definitions",await (async function(){
                 return ["=:quote",await (async function(){
                    if (check_true (options.do_not_include)){
                        return await to_object(await (async function(){
                            let __collector;
                            let __result;
                            let __action;
                            __collector=[];
                            __result=null;
                            __action=async function(defset) {
                                if (check_true (await not(await contains_ques_(defset['0'],options.do_not_include)))){
                                    return await (async function(){
                                        let __array_op_rval__346=defset['0'];
                                         if (__array_op_rval__346 instanceof Function){
                                            return await __array_op_rval__346(defset['1']) 
                                        } else {
                                            return [__array_op_rval__346,defset['1']]
                                        }
                                    })()
                                }
                            };
                            ;
                            await (async function() {
                                let __for_body__349=async function(__item) {
                                    __result=await __action(__item);
                                    if (check_true (__result)){
                                        return (__collector).push(__result)
                                    }
                                };
                                let __array__350=[],__elements__348=await pairs(Environment.definitions);
                                let __BREAK__FLAG__=false;
                                for(let __iter__347 in __elements__348) {
                                    __array__350.push(await __for_body__349(__elements__348[__iter__347]));
                                    if(__BREAK__FLAG__) {
                                         __array__350.pop();
                                        break;
                                        
                                    }
                                }return __array__350;
                                 
                            })();
                            return __collector
                        })())
                    } else {
                        return await clone(Environment.definitions)
                    }
                })()] 
            })()],["declarations",await (async function(){
                 return await clone(Environment.declarations) 
            })()],["config",await (async function(){
                let exp_conf;
                exp_conf=await (async function(){
                     return await clone(Environment.global_ctx.scope["*env_config*"]) 
                })();
                if (check_true (await not(preserve_imports))){
                    {
                        await async function(){
                            exp_conf["imports"]=new Object();
                            return exp_conf;
                            
                        }()
                    }
                };
                if (check_true (options.features)){
                    {
                        await async function(){
                            exp_conf["features"]=options.features;
                            return exp_conf;
                            
                        }()
                    }
                };
                return exp_conf
            })()],["imports",await (async function(){
                if (check_true (preserve_imports)){
                    return await to_object(await (async function() {
                        let __for_body__355=async function(imp_source) {
                            return await (async function(){
                                let __array_op_rval__357=imp_source.symbol;
                                 if (__array_op_rval__357 instanceof Function){
                                    return await __array_op_rval__357({
                                        initializer:await (async function(){
                                             return ["=:javascript","new function () { return ",imp_source.symbol," }"] 
                                        })(),symbol:imp_source.symbol,namespace:imp_source.namespace
                                    }) 
                                } else {
                                    return [__array_op_rval__357,{
                                        initializer:await (async function(){
                                             return ["=:javascript","new function () { return ",imp_source.symbol," }"] 
                                        })(),symbol:imp_source.symbol,namespace:imp_source.namespace
                                    }]
                                }
                            })()
                        };
                        let __array__356=[],__elements__354=await values((await resolve_path(["*env_config*","imports"],Environment.global_ctx.scope)|| new Object()));
                        let __BREAK__FLAG__=false;
                        for(let __iter__353 in __elements__354) {
                            __array__356.push(await __for_body__355(__elements__354[__iter__353]));
                            if(__BREAK__FLAG__) {
                                 __array__356.pop();
                                break;
                                
                            }
                        }return __array__356;
                         
                    })())
                } else {
                    return new Object()
                }
            })()],["symbols",await (async function(){
                 return ["=:javascript",await compile(await to_object(exports),{
                    throw_on_error:true
                })] 
            })()],["children_declarations",await (async function(){
                 return ["=:fn",[],await clone(children_declarations)] 
            })()],["child_load_order",await (async function(){
                 return await (await get_global("each"))(child_export_order,0) 
            })()],["children",my_children]] 
        })())] 
    })());
    output_path=await (async function(){
        if (check_true (options.want_buffer)){
            return null
        } else {
            return (options.save_as|| await resolve_path(["*env_config*","export","save_path"],Environment.global_ctx.scope))
        }
    })();
    if (check_true (output_path instanceof Function)){
        output_path=await (async function(){
            let __array_op_rval__358=output_path;
             if (__array_op_rval__358 instanceof Function){
                return await __array_op_rval__358() 
            } else {
                return [__array_op_rval__358]
            }
        })()
    };
    if (check_true ((await not((output_path instanceof String || typeof output_path==='string'))&& output_path))){
        throw new EvalError("invalid name for target for saving the environment.  Must be a string or function");
        
    };
    return await async function(){
        if (check_true ((want_buffer|| (output_path&& await ends_with_ques_(".js",output_path))))) {
            {
                (build_headers).push(("// Build Time: "+ build_time));
                (build_headers).push(("// Version: "+ version_tag));
                (build_headers).push(("export const DLISP_ENV_VERSION='"+ version_tag+ "';"));
                await env_log("saving to: ",output_path);
                return await (await get_global("compile_buffer"))(src,"init_dlisp",{
                    namespace:namespace,toplevel:true,include_boilerplate:false,verbose:false,bundle:true,want_buffer:want_buffer,imports:await (async function(){
                        if (check_true (preserve_imports)){
                            return await resolve_path(["*env_config*","imports"],Environment.global_ctx.scope)
                        }
                    })(),js_headers:await (async function(){
                         return [await (await get_global("show"))(check_true),await (async function(){
                             return await (await get_global("show"))(get_next_environment_id) 
                        })(),await (async function(){
                             return await (await get_global("show"))(get_outside_global) 
                        })(),await (async function(){
                             return await (await get_global("show"))(subtype) 
                        })(),await (async function(){
                             return await (await get_global("show"))(lisp_writer) 
                        })(),await (async function(){
                             return await (await get_global("show"))(clone) 
                        })(),await (async function(){
                             return await (await get_global("show"))(LispSyntaxError) 
                        })()] 
                    })(),bundle_options:{
                        default_namespace:await resolve_path(["*env_config*","export","default_namespace"],Environment.global_ctx.scope)
                    },output_file:output_path,include_source:(options.include_source|| await resolve_path(["*env_config*","export","include_source"],Environment.global_ctx.scope)),build_headers:build_headers
                })
            }
        } else if (check_true ((output_path&& await ends_with_ques_(".lisp",output_path)))) {
            return await (await get_global("write_text_file"))(output_path,await JSON.stringify(src,null,4))
        } else {
            return src
        }
    } ()
};
;
let reader=async function(text,opts) {    return await async function(){        if (check_true ((undefined==text))) {
            throw new EvalError(("reader: received undefined, text must be a string."));
            
        } else if (check_true (await (await Environment.get_global("not"))((text instanceof String || typeof text==='string')))) {
            throw new EvalError(("reader: received "+ await (await Environment.get_global("sub_type"))(text)+ ": text must be a string."));
            
        } else {
            {
                let output_structure;
                let idx;
                let error_collector;
                let symbol_collector;
                let throw_on_error;
                let line_number;
                let column_number;
                let source_name;
                let len;
                let debugmode;
                let in_buffer;
                let in_code;
                let in_quotes;
                let in_long_text;
                let in_comment;
                let in_single_quote;
                let reading_object;
                let mode;
                let symbol_start;
                let cpath;
                let ctx;
                let last_final_column_num;
                let symbol_receiver;
                let add_symbol;
                let local_text;
                let position;
                let read_table;
                let get_char;
                let error;
                let handle_escape_char;
                let process_word;
                let registered_stop_char;
                let handler_stack;
                let handler;
                let c;
                let next_c;
                let depth;
                let stop;
                let read_block;
                output_structure=[];
                idx=-1;
                error_collector=[];
                symbol_collector=new Object();
                throw_on_error=await (await Environment.get_global("not"))((opts && opts["suppress_throw_on_error"]));
                line_number=0;
                column_number=0;
                source_name=await (async function(){
                    if (check_true ((opts && opts["source_name"]))){
                        return (opts && opts["source_name"])
                    } else {
                        return "anonymous"
                    }
                })();
                opts=(opts|| new Object());
                len=(await (await Environment.get_global("length"))(text)- 1);
                debugmode=await (async function(){
                     return await async function(){
                        if (check_true ((opts && opts["verbose"]))) {
                            return true
                        } else if (check_true (((opts && opts["verbose"])===false))) {
                            return false
                        } else if (check_true (((await Environment.get_global("__VERBOSITY__"))>6))) {
                            return true
                        } else {
                            return false
                        }
                    } () 
                })();
                in_buffer=(text).split("");
                in_code=0;
                in_quotes=1;
                in_long_text=2;
                in_comment=3;
                in_single_quote=4;
                reading_object=false;
                mode=in_code;
                symbol_start=null;
                cpath=[];
                ctx={
                    scope:{
                        op_chain:[]
                    },parent:null
                };
                last_final_column_num=0;
                symbol_receiver=await (async function(){
                    if (check_true ((opts && opts["symbol_receiver"]) instanceof Function)){
                        return (opts && opts["symbol_receiver"])
                    }
                })();
                add_symbol=async function(symbol,_ctx) {
                    if (check_true (await (await Environment.get_global("not"))(await (await Environment.get_global("ends_with?"))(":",symbol)))){
                        {
                            {
                                let ccol;
                                let cline;
                                let real_sym;
                                ccol=await (async function(){
                                    if (check_true ((column_number===0))){
                                        return (last_final_column_num- (symbol && symbol.length))
                                    } else {
                                        return (column_number- (symbol && symbol.length))
                                    }
                                })();
                                cline=await (async function(){
                                    if (check_true ((column_number===0))){
                                        return (line_number- 1)
                                    } else {
                                        return line_number
                                    }
                                })();
                                real_sym=await (await Environment.get_global("first"))((symbol).split("."));
                                if (check_true ((null==symbol_collector[real_sym]))){
                                    return await async function(){
                                        symbol_collector[real_sym]=await (async function(){
                                             return [await (async function(){
                                                let __array_op_rval__2=cline;
                                                 if (__array_op_rval__2 instanceof Function){
                                                    return await __array_op_rval__2(ccol,await (async function(){
                                                        if (check_true (_ctx)){
                                                            return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                        } else {
                                                            return null
                                                        }
                                                    })(),await (await Environment.get_global("but_last"))(cpath)) 
                                                } else {
                                                    return [__array_op_rval__2,ccol,await (async function(){
                                                        if (check_true (_ctx)){
                                                            return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                        } else {
                                                            return null
                                                        }
                                                    })(),await (await Environment.get_global("but_last"))(cpath)]
                                                }
                                            })()] 
                                        })();
                                        return symbol_collector;
                                        
                                    }()
                                } else {
                                    return (symbol_collector[real_sym]).push(await (async function(){
                                        let __array_op_rval__3=cline;
                                         if (__array_op_rval__3 instanceof Function){
                                            return await __array_op_rval__3(ccol,await (async function(){
                                                if (check_true (_ctx)){
                                                    return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                } else {
                                                    return null
                                                }
                                            })(),await (await Environment.get_global("but_last"))(cpath)) 
                                        } else {
                                            return [__array_op_rval__3,ccol,await (async function(){
                                                if (check_true (_ctx)){
                                                    return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain")
                                                } else {
                                                    return null
                                                }
                                            })(),await (await Environment.get_global("but_last"))(cpath)]
                                        }
                                    })())
                                }
                            }
                        }
                    }
                };
                local_text=async function() {
                    let start;
                    let end;
                    start=await Math.max(0,(idx- 10));
                    end=await Math.min(await (await Environment.get_global("length"))(in_buffer),(idx+ 10));
                    return (await (await Environment.get_global("slice"))(in_buffer,start,end)).join("")
                };
                position=async function(offset) {
                    return ("line: "+ line_number+ " column: "+ await (async function(){
                        if (check_true (offset)){
                            return (column_number+ offset)
                        } else {
                            return column_number
                        }
                    })())
                };
                read_table=await (await Environment.get_global("add"))(new Object(),await (async function(){
                    if (check_true ((opts && opts["read_table_entries"]))){
                        return (opts && opts["read_table_entries"])
                    } else {
                        return new Object()
                    }
                })(),await ( async function(){
                    let __obj__4=new Object();
                    __obj__4["("]=[")",async function(block,_ctx) {
                        return block
                    }];
                    __obj__4["["]=["]",async function(block,_ctx) {
                        return block
                    }];
                    __obj__4["{"]=["}",async function(block,_ctx) {
                        let obj;
                        let __idx__5= async function(){
                            return -1
                        };
                        let key_mode;
                        let need_colon;
                        let value_mode;
                        let key;
                        let value;
                        let cpos;
                        let state;
                        let block_length;
                        {
                            obj=new Object();
                            let idx=await __idx__5();
                            ;
                            key_mode=0;
                            need_colon=1;
                            value_mode=2;
                            key=null;
                            value=null;
                            cpos=null;
                            state=key_mode;
                            block_length=(await (await Environment.get_global("length"))(block)- 1);
                            reading_object=false;
                            await (async function(){
                                 let __test_condition__6=async function() {
                                    return (idx<block_length)
                                };
                                let __body_ref__7=async function() {
                                    idx+=1;
                                    key=block[idx];
                                    if (check_true (((key instanceof Array)&& ((key && key.length)===2)&& ((key && key["0"])==="=:quotem")&& ((key && key["1"]) instanceof String || typeof (key && key["1"])==='string')))){
                                        {
                                            key=(key && key["1"])
                                        }
                                    };
                                    if (check_true (((key instanceof String || typeof key==='string')&& await (await Environment.get_global("starts_with?"))("=:",key)&& (await (await Environment.get_global("length"))(key)>2)))){
                                        key=await key["substr"].call(key,2)
                                    };
                                    return await async function(){
                                        if (check_true (await (await Environment.get_global("blank?"))(key))) {
                                            return await error("missing object key",("blank or nil key: "+ block[idx]))
                                        } else if (check_true (await (await Environment.get_global("is_number?"))(key))) {
                                            {
                                                idx+=1;
                                                return await async function(){
                                                    obj[key]=block[idx];
                                                    return obj;
                                                    
                                                }()
                                            }
                                        } else if (check_true (((key instanceof String || typeof key==='string')&& await (await Environment.get_global("contains?"))(":",key)&& await (await Environment.get_global("not"))(await (await Environment.get_global("ends_with?"))(":",key))))) {
                                            {
                                                cpos=await key["indexOf"].call(key,":");
                                                value=await key["substr"].call(key,(cpos+ 1));
                                                key=await key["substr"].call(key,0,cpos);
                                                value=await process_word((value).split(""),0,_ctx);
                                                return await async function(){
                                                    obj[key]=value;
                                                    return obj;
                                                    
                                                }()
                                            }
                                        } else {
                                            {
                                                idx+=1;
                                                if (check_true (await (await Environment.get_global("ends_with?"))(":",key))){
                                                    key=await (await Environment.get_global("chop"))(key)
                                                } else {
                                                    {
                                                        if (check_true ((block[idx]===":"))){
                                                            idx+=1
                                                        } else {
                                                            await error("missing colon",("expected colon for: "+ key))
                                                        }
                                                    }
                                                };
                                                return await async function(){
                                                    obj[key]=block[idx];
                                                    return obj;
                                                    
                                                }()
                                            }
                                        }
                                    } ()
                                };
                                let __BREAK__FLAG__=false;
                                while(await __test_condition__6()) {
                                     await __body_ref__7();
                                     if(__BREAK__FLAG__) {
                                         break;
                                        
                                    }
                                } ;
                                
                            })();
                            return obj
                        }
                    },async function() {
                        return reading_object=true
                    }];
                    __obj__4["\""]=["\"",async function(block) {
                        return ["quotes",block]
                    }];
                    return __obj__4;
                    
                })());
                get_char=async function(pos) {
                    return in_buffer[pos]
                };
                error=async function(type,message,offset) {
                    if (check_true (throw_on_error)){
                        throw new LispSyntaxError({
                            message:message,position:await position(offset),pos:{
                                line:line_number,column:(column_number+ (offset|| 0))
                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                        });
                        
                    } else {
                        if (check_true ((opts && opts["on_error"]) instanceof Function)){
                            {
                                return await (async function(){
                                    let __array_op_rval__11=(opts && opts["on_error"]);
                                     if (__array_op_rval__11 instanceof Function){
                                        return await __array_op_rval__11({
                                            message:message,position:await position(offset),pos:{
                                                line:line_number,column:(column_number+ (offset|| 0))
                                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                                        }) 
                                    } else {
                                        return [__array_op_rval__11,{
                                            message:message,position:await position(offset),pos:{
                                                line:line_number,column:(column_number+ (offset|| 0))
                                            },depth:depth,local_text:await local_text(),source_name:source_name,type:type
                                        }]
                                    }
                                })()
                            }
                        }
                    }
                };
                handle_escape_char=async function(c) {
                    let ccode;
                    ccode=await c["charCodeAt"].call(c,0);
                    return await async function(){
                        if (check_true ((ccode===34))) {
                            return c
                        } else if (check_true ((ccode===92))) {
                            return c
                        } else if (check_true ((c==="t"))) {
                            return await String.fromCharCode(9)
                        } else if (check_true ((c==="n"))) {
                            return await String.fromCharCode(10)
                        } else if (check_true ((c==="r"))) {
                            return await String.fromCharCode(13)
                        } else if (check_true ((c==="f"))) {
                            return c
                        } else if (check_true ((c==="b"))) {
                            return c
                        } else {
                            return c
                        }
                    } ()
                };
                process_word=async function(word_acc,backtick_mode,_ctx) {
                    let word;
                    let word_as_number;
                    word=(word_acc).join("");
                    word_as_number=await Number(word);
                    if (check_true (debugmode)){
                        {
                            await console.log("process_word: ",word,word_as_number,backtick_mode)
                        }
                    };
                    return await async function(){
                        if (check_true (("true"===word))) {
                            return true
                        } else if (check_true (("false"===word))) {
                            return false
                        } else if (check_true ((":"===word))) {
                            return word
                        } else if (check_true ((",@"===word))) {
                            return "=$,@"
                        } else if (check_true (((",#"===word)|| ("##"===word)))) {
                            return "=:##"
                        } else if (check_true (("=$,@"===word))) {
                            return "=$,@"
                        } else if (check_true (("=:##"===word))) {
                            return "=:##"
                        } else if (check_true (await isNaN(word_as_number))) {
                            {
                                return await async function(){
                                    if (check_true ((word==="=:"))) {
                                        {
                                            return "=:"
                                        }
                                    } else if (check_true (((backtick_mode===0)&& await (await Environment.get_global("ends_with?"))(")",word)))) {
                                        {
                                            await error("trailing character","unexpected trailing parenthesis 2");
                                            return ""
                                        }
                                    } else if (check_true (((backtick_mode===0)&& await (await Environment.get_global("ends_with?"))("]",word)))) {
                                        {
                                            await error("trailing character","unexpected trailing bracket 2");
                                            return ""
                                        }
                                    } else if (check_true (await (await Environment.get_global("contains?"))(word,await (async function(){
                                         return ["=:(",await (async function(){
                                             return "=:)" 
                                        })(),await (async function(){
                                             return "=:'" 
                                        })()] 
                                    })()))) {
                                        {
                                            return word
                                        }
                                    } else if (check_true ((backtick_mode===1))) {
                                        return word
                                    } else {
                                        {
                                            if (check_true (symbol_receiver)){
                                                {
                                                    await add_symbol(word,_ctx)
                                                }
                                            };
                                            return await (await Environment.get_global("add"))(await (async function(){
                                                 return "=:" 
                                            })(),word)
                                        }
                                    }
                                } ()
                            }
                        } else if (check_true (await (await Environment.get_global("is_number?"))(word_as_number))) {
                            return word_as_number
                        } else {
                            {
                                console.log("reader: ",await position()," what is this?",word,word_acc,await local_text());
                                return word
                            }
                        }
                    } ()
                };
                registered_stop_char=null;
                handler_stack=[];
                handler=null;
                c=null;
                next_c=null;
                depth=0;
                stop=false;
                read_block=async function(_depth,_ctx) {
                    let acc;
                    let word_acc;
                    let operator;
                    let old_ctx;
                    let backtick_mode;
                    let escape_mode;
                    let last_c;
                    let block_return;
                    acc=[];
                    word_acc=[];
                    operator=null;
                    old_ctx=null;
                    backtick_mode=0;
                    escape_mode=0;
                    last_c=null;
                    _ctx=_ctx;
                    block_return=null;
                    depth=_depth;
                    await (async function(){
                         let __test_condition__12=async function() {
                            return (await (await Environment.get_global("not"))(stop)&& (idx<len))
                        };
                        let __body_ref__13=async function() {
                            idx+=1;
                            escape_mode=await Math.max(0,(escape_mode- 1));
                            c=await get_char(idx);
                            next_c=await get_char((idx+ 1));
                            if (check_true ((c==="\n"))){
                                {
                                    line_number+=1;
                                    last_final_column_num=column_number;
                                    column_number=0
                                }
                            };
                            if (check_true (debugmode)){
                                {
                                    await console.log(_depth,"  ",c," ",next_c," ",mode,"",escape_mode," ",await (await Environment.get_global("as_lisp"))(acc),await (await Environment.get_global("as_lisp"))(word_acc),(acc && acc.length),(cpath).join("."))
                                }
                            };
                            await async function(){
                                if (check_true (((next_c===undefined)&& await (await Environment.get_global("not"))((await (async function(){
                                    let __targ__14=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__14){
                                         return(__targ__14)[0]
                                    } 
                                })()===undefined))&& (await (await Environment.get_global("not"))((c===await (async function(){
                                    let __targ__15=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__15){
                                         return(__targ__15)[0]
                                    } 
                                })()))|| ((handler_stack && handler_stack.length)>1))))) {
                                    return await error("premature end",("premature end: expected: "+ await (async function(){
                                        let __targ__16=await (await Environment.get_global("last"))(handler_stack);
                                        if (__targ__16){
                                             return(__targ__16)[0]
                                        } 
                                    })()))
                                } else if (check_true (((next_c===undefined)&& (mode===in_quotes)&& await (await Environment.get_global("not"))((await c["charCodeAt"]()===34))))) {
                                    await error("premature end","premature end: expected: \"")
                                } else if (check_true (((next_c===undefined)&& (mode===in_long_text)&& await (await Environment.get_global("not"))((c==="|"))))) {
                                    await error("premature end","premature end: expected: |")
                                } else if (check_true (((mode===in_code)&& (_depth===1)&& (next_c===")")&& (c===")")))) {
                                    {
                                        await error("trailing character","unexpected trailing parenthesis")
                                    }
                                }
                            } ();
                            await async function(){
                                if (check_true (((c==="\n")&& (mode===in_comment)))) {
                                    {
                                        mode=in_code;
                                        return __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((92===await c["charCodeAt"].call(c,0))&& (mode===in_long_text)))) {
                                    {
                                        (word_acc).push(c);
                                        (word_acc).push(c)
                                    }
                                } else if (check_true (((mode>0)&& (escape_mode===1)&& (92===await c["charCodeAt"].call(c,0))))) {
                                    {
                                        (word_acc).push(c)
                                    }
                                } else if (check_true (((mode>0)&& (92===await c["charCodeAt"].call(c,0))))) {
                                    {
                                        escape_mode=2
                                    }
                                } else if (check_true (((mode>0)&& (escape_mode===1)))) {
                                    {
                                        (word_acc).push(await handle_escape_char(c))
                                    }
                                } else if (check_true (((mode===in_long_text)&& (escape_mode===0)&& (c==="|")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_quotes)&& (escape_mode===0)&& (c==="\"")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_single_quote)&& (escape_mode===0)&& (c==="'")))) {
                                    {
                                        acc=await (await Environment.get_global("add"))((word_acc).join(""));
                                        word_acc=[];
                                        mode=in_code;
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((c==="|")&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_long_text;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                block_return=await (async function(){
                                                     return ["=:quotem",block_return] 
                                                })();
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true (((c==="\"")&& (escape_mode===0)&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_quotes;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true (((c==="'")&& (escape_mode===0)&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_single_quote;
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        if (check_true ((backtick_mode===1))){
                                            {
                                                backtick_mode=0
                                            }
                                        };
                                        (acc).push(block_return)
                                    }
                                } else if (check_true ((mode===in_comment))) {
                                    false
                                } else if (check_true (((c===";")&& (mode===in_code)))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        mode=in_comment;
                                        await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx)
                                    }
                                } else if (check_true (((mode===in_code)&& (await (await Environment.get_global("length"))(handler_stack)>0)&& (c===await (async function(){
                                    let __targ__17=await (await Environment.get_global("last"))(handler_stack);
                                    if (__targ__17){
                                         return(__targ__17)[0]
                                    } 
                                })())))) {
                                    {
                                        __BREAK__FLAG__=true;
                                        return
                                    }
                                } else if (check_true (((mode===in_code)&& read_table[c]&& await (await Environment.get_global("first"))(read_table[c])))) {
                                    {
                                        if (check_true (await (async function(){
                                            let __targ__18=read_table[c];
                                            if (__targ__18){
                                                 return(__targ__18)[2]
                                            } 
                                        })())){
                                            {
                                                handler=await (async function(){
                                                    let __targ__19=read_table[c];
                                                    if (__targ__19){
                                                         return(__targ__19)[2]
                                                    } 
                                                })();
                                                await (async function(){
                                                    let __array_op_rval__20=handler;
                                                     if (__array_op_rval__20 instanceof Function){
                                                        return await __array_op_rval__20() 
                                                    } else {
                                                        return [__array_op_rval__20]
                                                    }
                                                })();
                                                handler=null
                                            }
                                        };
                                        (handler_stack).push(read_table[c]);
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                                                backtick_mode=0;
                                                word_acc=[]
                                            }
                                        };
                                        old_ctx=_ctx;
                                        _ctx=await (async function(){
                                             return await (await Environment.get_global("new_ctx"))(_ctx) 
                                        })();
                                        (cpath).push(0);
                                        block_return=await read_block(await (await Environment.get_global("add"))(_depth,1),_ctx);
                                        handler=await (async function(){
                                            let __targ__21=(handler_stack).pop();
                                            if (__targ__21){
                                                 return(__targ__21)[1]
                                            } 
                                        })();
                                        block_return=await (async function(){
                                            let __array_op_rval__22=handler;
                                             if (__array_op_rval__22 instanceof Function){
                                                return await __array_op_rval__22(block_return,_ctx) 
                                            } else {
                                                return [__array_op_rval__22,block_return,_ctx]
                                            }
                                        })();
                                        (cpath).pop();
                                        _ctx=old_ctx;
                                        if (check_true (await (await Environment.get_global("not"))((undefined===block_return)))){
                                            {
                                                if (check_true ((backtick_mode===1))){
                                                    {
                                                        block_return=await (async function(){
                                                             return ["=:quotem",block_return] 
                                                        })();
                                                        backtick_mode=0
                                                    }
                                                };
                                                (acc).push(block_return)
                                            }
                                        }
                                    }
                                } else if (check_true (((mode===in_code)&& (c==="`")))) {
                                    {
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                (acc).push(await process_word(word_acc,null,_ctx));
                                                word_acc=[]
                                            }
                                        };
                                        backtick_mode=1
                                    }
                                } else if (check_true (((mode===in_code)&& (c===":")&& ((word_acc && word_acc.length)===0)&& ((acc && acc.length)>0)&& (await (await Environment.get_global("last"))(acc) instanceof String || typeof await (await Environment.get_global("last"))(acc)==='string')))) {
                                    (acc).push(await (await Environment.get_global("add"))((acc).pop(),":"))
                                } else if (check_true (((mode===in_code)&& (last_c===",")&& ((c==="#")|| (c==="@"))))) {
                                    {
                                        (word_acc).push(c);
                                        (acc).push(await process_word(word_acc,null,_ctx));
                                        word_acc=[]
                                    }
                                } else if (check_true (((mode===in_code)&& ((c===" ")|| (await c["charCodeAt"].call(c,0)===10)|| (await c["charCodeAt"].call(c,0)===9)|| ((c===",")&& await (await Environment.get_global("not"))((next_c==="@"))&& await (await Environment.get_global("not"))((next_c==="#"))))))) {
                                    {
                                        if (check_true ((((acc && acc.length)===0)&& ((word_acc && word_acc.length)>0)))){
                                            {
                                                await async function(){
                                                    let __target_obj__23=(_ctx && _ctx["scope"]);
                                                    __target_obj__23["op_chain"]=await (await Environment.get_global("conj"))(await (async function(){
                                                         return await (await Environment.get_global("getf_ctx"))(_ctx,"op_chain") 
                                                    })(),(word_acc).join(""));
                                                    return __target_obj__23;
                                                    
                                                }()
                                            }
                                        };
                                        if (check_true (((word_acc && word_acc.length)>0))){
                                            {
                                                if (check_true ((backtick_mode===1))){
                                                    {
                                                        (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                                                        backtick_mode=0
                                                    }
                                                } else {
                                                    (acc).push(await process_word(word_acc,null,_ctx))
                                                };
                                                word_acc=[]
                                            }
                                        };
                                        (cpath).pop();
                                        (cpath).push(await (await Environment.get_global("length"))(acc))
                                    }
                                } else if (check_true (((mode===in_code)&& (await c["charCodeAt"].call(c,0)===13)))) {
                                    false
                                } else {
                                    {
                                        (word_acc).push(c)
                                    }
                                }
                            } ();
                            column_number+=1;
                            return last_c=c
                        };
                        let __BREAK__FLAG__=false;
                        while(await __test_condition__12()) {
                             await __body_ref__13();
                             if(__BREAK__FLAG__) {
                                 break;
                                
                            }
                        } ;
                        
                    })();
                    if (check_true (((word_acc && word_acc.length)>0))){
                        {
                            (acc).push(await process_word(word_acc,backtick_mode,_ctx));
                            word_acc=[]
                        }
                    };
                    return acc
                };
                if (check_true (debugmode)){
                    {
                        await console.log("read->",in_buffer);
                        await console.log("D  CHAR NC "," M","ESC","ACC","WORDACC","ACCL")
                    }
                };
                output_structure=await read_block(0,ctx);
                if (check_true (debugmode)){
                    {
                        await console.log("read<-",await (async function(){
                             return await clone(output_structure) 
                        })())
                    }
                };
                if (check_true ((opts && opts["symbol_receiver"]))){
                    {
                        await (async function(){
                            let __array_op_rval__24=(opts && opts["symbol_receiver"]);
                             if (__array_op_rval__24 instanceof Function){
                                return await __array_op_rval__24({
                                    source_name:source_name,symbols:symbol_collector
                                }) 
                            } else {
                                return [__array_op_rval__24,{
                                    source_name:source_name,symbols:symbol_collector
                                }]
                            }
                        })()
                    }
                };
                if (check_true (((output_structure instanceof Array)&& (await (await Environment.get_global("length"))(output_structure)>1)))){
                    {
                        (output_structure).unshift(await (async function(){
                             return "=:iprogn" 
                        })());
                        return await (await Environment.get_global("first"))(await (async function(){
                            let __array_op_rval__25=output_structure;
                             if (__array_op_rval__25 instanceof Function){
                                return await __array_op_rval__25() 
                            } else {
                                return [__array_op_rval__25]
                            }
                        })())
                    }
                } else {
                    return await (await Environment.get_global("first"))(output_structure)
                }
            }
        }
    } ()
};
let add_escape_encoding=async function(text) {        if (check_true ((text instanceof String || typeof text==='string'))){            let chars;            let acc;            chars=(text).split("");            acc=[];            await (async function() {                let __for_body__3=async function(c) {                     return  await async function(){                        if (check_true( ((await c["charCodeAt"].call(c,0)===34)))) {                            (acc).push(await String.fromCharCode(92));                             return  (acc).push(c)                        } else  {                             return (acc).push(c)                        }                    } ()                };                let __array__4=[],__elements__2=chars;                let __BREAK__FLAG__=false;                for(let __iter__1 in __elements__2) {                    __array__4.push(await __for_body__3(__elements__2[__iter__1]));                    if(__BREAK__FLAG__) {                         __array__4.pop();                        break;                                            }                }return __array__4;                             })();             return  (acc).join("")        } else {              return text        }    };
let do_deferred_splice=async function(tree) {    let rval;
    let idx;
    let tval;
    let deferred_operator;
    rval=null;
    idx=0;
    tval=null;
    deferred_operator=(["=","$","&","!"]).join("");
    return await async function(){
        if (check_true ((tree instanceof Array))) {
            {
                rval=[];
                await (async function(){
                     let __test_condition__21=async function() {
                        return (idx<(tree && tree.length))
                    };
                    let __body_ref__22=async function() {
                        tval=tree[idx];
                        if (check_true ((tval===deferred_operator))){
                            {
                                idx+=1;
                                tval=tree[idx];
                                rval=await rval["concat"].call(rval,await (async function(){
                                     return await do_deferred_splice(tval) 
                                })())
                            }
                        } else {
                            (rval).push(await (async function(){
                                 return await do_deferred_splice(tval) 
                            })())
                        };
                        return idx+=1
                    };
                    let __BREAK__FLAG__=false;
                    while(await __test_condition__21()) {
                         await __body_ref__22();
                         if(__BREAK__FLAG__) {
                             break;
                            
                        }
                    } ;
                    
                })();
                return rval
            }
        } else if (check_true ((tree instanceof Object))) {
            {
                rval=new Object();
                await (async function() {
                    let __for_body__25=async function(pset) {
                        return await async function(){
                            rval[(pset && pset["0"])]=await (async function(){
                                 return await do_deferred_splice((pset && pset["1"])) 
                            })();
                            return rval;
                            
                        }()
                    };
                    let __array__26=[],__elements__24=await (await Environment.get_global("pairs"))(tree);
                    let __BREAK__FLAG__=false;
                    for(let __iter__23 in __elements__24) {
                        __array__26.push(await __for_body__25(__elements__24[__iter__23]));
                        if(__BREAK__FLAG__) {
                             __array__26.pop();
                            break;
                            
                        }
                    }return __array__26;
                     
                })();
                return rval
            }
        } else {
            return tree
        }
    } ()
};
let safe_access=async function(token,ctx,sanitizer_fn) {    let comps;
    let acc;
    let acc_full;
    let pos;
    let rval;
    comps=null;
    acc=[];
    acc_full=[];
    pos=null;
    rval=null;
    comps=((token && token.name)).split(".");
    if (check_true (((comps && comps.length)===1))){
        return (token && token.name)
    } else {
        {
            await async function(){
                comps[0]=await (async function(){
                    let __array_op_rval__205=sanitizer_fn;
                     if (__array_op_rval__205 instanceof Function){
                        return await __array_op_rval__205((comps && comps["0"])) 
                    } else {
                        return [__array_op_rval__205,(comps && comps["0"])]
                    }
                })();
                return comps;
                
            }();
            await (async function(){
                 let __test_condition__206=async function() {
                    return ((comps && comps.length)>0)
                };
                let __body_ref__207=async function() {
                    (acc).push((comps).shift());
                    return (acc_full).push(await (async function(){
                         return await (await Environment.get_global("expand_dot_accessor"))((acc).join("."),ctx) 
                    })())
                };
                let __BREAK__FLAG__=false;
                while(await __test_condition__206()) {
                     await __body_ref__207();
                     if(__BREAK__FLAG__) {
                         break;
                        
                    }
                } ;
                
            })();
            rval=await (await Environment.get_global("flatten"))(["(",(acc_full).join(" && "),")"]);
            return rval
        }
    }
};
;
let as_lisp=function(obj,depth,max_depth) {
    return  lisp_writer(obj,depth,max_depth,Environment)
};
;
let read_lisp=reader;
;
await async function(){
    Environment.global_ctx.scope["eval"]=eval_exp;
    Environment.global_ctx.scope["reader"]=reader;
    Environment.global_ctx.scope["add_escape_encoding"]=add_escape_encoding;
    Environment.global_ctx.scope["get_outside_global"]=get_outside_global;
    Environment.global_ctx.scope["as_lisp"]=lisp_writer;
    Environment.global_ctx.scope["lisp_writer"]=lisp_writer;
    Environment.global_ctx.scope["clone_to_new"]=clone_to_new;
    Environment.global_ctx.scope["save_env"]=save_env;
    Environment.global_ctx.scope["null"]=null;
    return Environment.global_ctx.scope;
    
}();
if (check_true ((namespace==="core"))){
    {
        await async function(){
            Environment.global_ctx.scope["namespace_declarations"]=function() {
                return children_declarations
            };
            Environment.global_ctx.scope["set_namespace_declaration"]=function(namespace,key,value) {
                return  ( get_global("set_path"))( ( function(){
                    let __array_op_rval__361=namespace;
                     if (__array_op_rval__361 instanceof Function){
                        return  __array_op_rval__361(key) 
                    } else {
                        return [__array_op_rval__361,key]
                    }
                })(),children_declarations,value)
            };
            return Environment.global_ctx.scope;
            
        }()
    }
};
let inlines=await (async function(){
    if (check_true (parent_environment)){
        return await add(new Object(),parent_environment.inlines,await (async function(){
            if (check_true (opts.inlines)){
                return opts.inlines
            } else {
                return new Object()
            }
        })())
    } else {
        return await add(new Object(),await (async function(){
            if (check_true (opts.inlines)){
                return opts.inlines
            } else {
                return new Object()
            }
        })(),await ( async function(){
            let __obj__362=new Object();
            __obj__362["pop"]=async function(args) {
                return ["(",args['0'],")",".","pop()"]
            };
            __obj__362["push"]=async function(args) {
                return ["(",args['0'],")",".push","(",args['1'],")"]
            };
            __obj__362["chomp"]=async function(args) {
                return ["(",args['0'],")",".substr","(",0,",","(",args['0'],".length","-",1,")",")"]
            };
            __obj__362["join"]=async function(args) {
                if (check_true ((args.length===1))){
                    return ["(",args['0'],")",".join","('')"]
                } else {
                    return ["(",args['1'],")",".join","(",args['0'],")"]
                }
            };
            __obj__362["take"]=async function(args) {
                return ["(",args['0'],")",".shift","()"]
            };
            __obj__362["prepend"]=async function(args) {
                return ["(",args['0'],")",".unshift","(",args['1'],")"]
            };
            __obj__362["trim"]=async function(args) {
                return ["(",args['0'],")",".trim()"]
            };
            __obj__362["lowercase"]=async function(args) {
                return ["(",args['0'],")",".toLowerCase()"]
            };
            __obj__362["uppercase"]=async function(args) {
                return ["(",args['0'],")",".toUpperCase()"]
            };
            __obj__362["islice"]=async function(args) {
                return await async function(){
                    if (check_true ((args.length===3))) {
                        return ["(",args['0'],")",".slice(",args['1'],",",args['2'],")"]
                    } else if (check_true ((args.length===2))) {
                        return ["(",args['0'],")",".slice(",args['1'],")"]
                    } else {
                        throw new SyntaxError("slice requires 2 or 3 arguments");
                        
                    }
                } ()
            };
            __obj__362["split_by"]=async function(args) {
                return ["(",args['1'],")",".split","(",args['0'],")"]
            };
            __obj__362["bindf"]=async function(args) {
                return await (async function(){
                    let __array_op_rval__363=args['0'];
                     if (__array_op_rval__363 instanceof Function){
                        return await __array_op_rval__363(".bind(",args['1'],")") 
                    } else {
                        return [__array_op_rval__363,".bind(",args['1'],")"]
                    }
                })()
            };
            __obj__362["is_array?"]=async function(args) {
                return ["(",args['0']," instanceof Array",")"]
            };
            __obj__362["is_object?"]=async function(args) {
                return ["(",args['0']," instanceof Object",")"]
            };
            __obj__362["is_string?"]=async function(args) {
                return ["(",args['0']," instanceof String || typeof ",args['0'],"===","'string'",")"]
            };
            __obj__362["is_function?"]=async function(args) {
                return await (async function(){
                    let __array_op_rval__364=args['0'];
                     if (__array_op_rval__364 instanceof Function){
                        return await __array_op_rval__364(" instanceof Function") 
                    } else {
                        return [__array_op_rval__364," instanceof Function"]
                    }
                })()
            };
            __obj__362["is_element?"]=async function(args) {
                return await (async function(){
                    let __array_op_rval__365=args['0'];
                     if (__array_op_rval__365 instanceof Function){
                        return await __array_op_rval__365(" instanceof Element") 
                    } else {
                        return [__array_op_rval__365," instanceof Element"]
                    }
                })()
            };
            __obj__362["log"]=async function(args) {
                return ["console.log","(",await (async function(){
                     return await map(async function(val,idx,tl) {
                        if (check_true ((idx<(tl- 1)))){
                            return await (async function(){
                                let __array_op_rval__366=val;
                                 if (__array_op_rval__366 instanceof Function){
                                    return await __array_op_rval__366(",") 
                                } else {
                                    return [__array_op_rval__366,","]
                                }
                            })()
                        } else {
                            return await (async function(){
                                let __array_op_rval__367=val;
                                 if (__array_op_rval__367 instanceof Function){
                                    return await __array_op_rval__367() 
                                } else {
                                    return [__array_op_rval__367]
                                }
                            })()
                        }
                    },args) 
                })(),")"]
            };
            __obj__362["reverse"]=async function(args) {
                return ["(",args['0'],")",".slice(0).reverse()"]
            };
            __obj__362["int"]=async function(args) {
                return await async function(){
                    if (check_true ((args.length===1))) {
                        return ["parseInt(",args['0'],")"]
                    } else if (check_true ((args.length===2))) {
                        return ["parseInt(",args['0'],",",args['1'],")"]
                    } else {
                        throw new "SyntaxError"(("invalid number of arguments to int: received "+ args.length));
                        
                    }
                } ()
            };
            __obj__362["float"]=async function(args) {
                return ["parseFloat(",args['0'],")"]
            };
            return __obj__362;
            
        })())
    }
})();
;
await async function(){
    Environment["eval"]=eval_struct;
    Environment["identify"]=subtype;
    Environment["meta_for_symbol"]=meta_for_symbol;
    Environment["set_compiler"]=set_compiler;
    Environment["read_lisp"]=reader;
    Environment["as_lisp"]=as_lisp;
    Environment["symbols"]=symbols;
    Environment["inlines"]=inlines;
    Environment["clone_to_new"]=clone_to_new;
    Environment["export_symbol_set"]=export_symbol_set;
    Environment["save_env"]=save_env;
    Environment["special_operators"]=special_operators;
    Environment["definitions"]=Environment.definitions;
    Environment["declarations"]=Environment.declarations;
    Environment["get_namespace_handle"]=get_namespace_handle;
    Environment["compile"]=compile;
    Environment["evaluate"]=evaluate;
    Environment["evaluate_local"]=evaluate_local;
    Environment["do_deferred_splice"]=do_deferred_splice;
    Environment["id"]=async function() {
        return id
    };
    Environment["set_check_external_env"]=async function(state) {
        check_external_env_default=state;
        return check_external_env_default
    };
    Environment["check_external_env"]=async function() {
        return check_external_env_default
    };
    return Environment;
    
}();
in_boot=false;
let sys_init=Environment.global_ctx.scope["*system_initializer*"];
;
let init=Environment.global_ctx.scope["*initializer*"];
;
if (check_true ((opts.default_namespace&& await not((compiler===unset_compiler))&& children[opts.default_namespace]))){
    {
        await (await get_global("set_namespace"))(opts.default_namespace)
    }
};
if (check_true ((namespace==="core"))){
    {
        let env_ready=Environment.global_ctx.scope["*on_environment_ready*"];
        ;
        await (async function() {
            let __for_body__371=async function(symname) {
                {
                    let it;
                    it=(await not((included_globals&& included_globals.imports[symname]))&& await resolve_path(await (async function(){
                        let __array_op_rval__373=symname;
                         if (__array_op_rval__373 instanceof Function){
                            return await __array_op_rval__373("initializer") 
                        } else {
                            return [__array_op_rval__373,"initializer"]
                        }
                    })(),Environment.definitions));
                    if (check_true (it)){
                        {
                            try {
                                return await async function(){
                                    Environment.global_ctx.scope[symname]=await (async function(){
                                         return await eval_struct(it,new Object(),{
                                            throw_on_error:true
                                        }) 
                                    })();
                                    return Environment.global_ctx.scope;
                                    
                                }()
                            } catch (__exception__374) {
                                if (__exception__374 instanceof Error) {
                                    let e=__exception__374;
                                    {
                                        {
                                            return await console.error("core environment cannot initialize: ",symname,"error:",e)
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        return 
                    }
                }
            };
            let __array__372=[],__elements__370=await keys(Environment.definitions);
            let __BREAK__FLAG__=false;
            for(let __iter__369 in __elements__370) {
                __array__372.push(await __for_body__371(__elements__370[__iter__369]));
                if(__BREAK__FLAG__) {
                     __array__372.pop();
                    break;
                    
                }
            }return __array__372;
             
        })();
        if (check_true (sys_init)){
            {
                (await Environment.eval(await async function(){
                    return sys_init
                }(),null))
            }
        };
        if (check_true ((rehydrated_children&& (included_globals["children"] instanceof Object)))){
            {
                await (async function() {
                    let __for_body__378=async function(childname) {
                        if (check_true (included_globals.children[childname])){
                            {
                                let childset=await (async function(){
                                    let __array_op_rval__380=childname;
                                     if (__array_op_rval__380 instanceof Function){
                                        return await __array_op_rval__380(included_globals.children[childname]) 
                                    } else {
                                        return [__array_op_rval__380,included_globals.children[childname]]
                                    }
                                })();
                                ;
                                let childenv=children[childset['0']];
                                ;
                                let imported_defs=childset['1']['0'];
                                ;
                                if (check_true ((included_globals["imports"] instanceof Object))){
                                    {
                                        imps=included_globals["imports"];
                                        if (check_true (imps)){
                                            {
                                                await (async function() {
                                                    let __for_body__383=async function(imp_source) {
                                                        if (check_true (children[imp_source.namespace])){
                                                            {
                                                                return await set_global((""+ imp_source.namespace+ "/"+ imp_source.symbol),imp_source.initializer)
                                                            }
                                                        }
                                                    };
                                                    let __array__384=[],__elements__382=await values(imps);
                                                    let __BREAK__FLAG__=false;
                                                    for(let __iter__381 in __elements__382) {
                                                        __array__384.push(await __for_body__383(__elements__382[__iter__381]));
                                                        if(__BREAK__FLAG__) {
                                                             __array__384.pop();
                                                            break;
                                                            
                                                        }
                                                    }return __array__384;
                                                     
                                                })()
                                            }
                                        }
                                    }
                                };
                                try {
                                    await async function(){
                                        childset['1'][1]=await childenv["eval"].call(childenv,childset['1']['1'],{
                                            throw_on_error:true
                                        });
                                        return childset['1'];
                                        
                                    }();
                                    return await (async function() {
                                        let __for_body__389=async function(symset) {
                                            if (check_true ((null==await resolve_path(await (async function(){
                                                let __array_op_rval__391=childset['0'];
                                                 if (__array_op_rval__391 instanceof Function){
                                                    return await __array_op_rval__391("context","scope",symset['0']) 
                                                } else {
                                                    return [__array_op_rval__391,"context","scope",symset['0']]
                                                }
                                            })(),children)))){
                                                {
                                                    if (check_true (imported_defs[symset['0']])){
                                                        {
                                                            await (await get_global("set_path"))(await (async function(){
                                                                let __array_op_rval__392=childset['0'];
                                                                 if (__array_op_rval__392 instanceof Function){
                                                                    return await __array_op_rval__392("definitions",symset['0']) 
                                                                } else {
                                                                    return [__array_op_rval__392,"definitions",symset['0']]
                                                                }
                                                            })(),children,imported_defs[symset['0']])
                                                        }
                                                    };
                                                    {
                                                        let it;
                                                        it=await resolve_path(await (async function(){
                                                            let __array_op_rval__393=childset['0'];
                                                             if (__array_op_rval__393 instanceof Function){
                                                                return await __array_op_rval__393("definitions",symset['0'],"initializer") 
                                                            } else {
                                                                return [__array_op_rval__393,"definitions",symset['0'],"initializer"]
                                                            }
                                                        })(),children);
                                                        if (check_true (it)){
                                                            {
                                                                try {
                                                                    return await (await get_global("set_path"))(await (async function(){
                                                                        let __array_op_rval__395=childset['0'];
                                                                         if (__array_op_rval__395 instanceof Function){
                                                                            return await __array_op_rval__395("context","scope",symset['0']) 
                                                                        } else {
                                                                            return [__array_op_rval__395,"context","scope",symset['0']]
                                                                        }
                                                                    })(),children,await childenv["eval"].call(childenv,it))
                                                                } catch (__exception__394) {
                                                                    if (__exception__394 instanceof Error) {
                                                                        let e=__exception__394;
                                                                        {
                                                                            return await console.error("env: unable to evaluate: symbol: ",symset['0'],e)
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            return await (await get_global("set_path"))(await (async function(){
                                                                let __array_op_rval__396=childset['0'];
                                                                 if (__array_op_rval__396 instanceof Function){
                                                                    return await __array_op_rval__396("context","scope",symset['0']) 
                                                                } else {
                                                                    return [__array_op_rval__396,"context","scope",symset['0']]
                                                                }
                                                            })(),children,symset['1'])
                                                        }
                                                    }
                                                }
                                            }
                                        };
                                        let __array__390=[],__elements__388=childset['1']['1'];
                                        let __BREAK__FLAG__=false;
                                        for(let __iter__387 in __elements__388) {
                                            __array__390.push(await __for_body__389(__elements__388[__iter__387]));
                                            if(__BREAK__FLAG__) {
                                                 __array__390.pop();
                                                break;
                                                
                                            }
                                        }return __array__390;
                                         
                                    })()
                                } catch (__exception__385) {
                                    if (__exception__385 instanceof Error) {
                                        let e=__exception__385;
                                        {
                                            return await console.error("env: unable to load namespace: ",await (async function(){
                                                 return await clone(childset) 
                                            })())
                                        }
                                    }
                                }
                            }
                        }
                    };
                    let __array__379=[],__elements__377=(included_globals.child_load_order|| []);
                    let __BREAK__FLAG__=false;
                    for(let __iter__376 in __elements__377) {
                        __array__379.push(await __for_body__378(__elements__377[__iter__376]));
                        if(__BREAK__FLAG__) {
                             __array__379.pop();
                            break;
                            
                        }
                    }return __array__379;
                     
                })()
            }
        };
        if (check_true (init)){
            {
                (await Environment.eval(await async function(){
                    return init
                }(),null))
            }
        };
        debugger;
        ;
        await (async function() {
            let __for_body__399=async function(child) {
                return await child["evaluate_local"].call(child,("(try (progn (debug) (if (prop Environment.global_ctx.scope `*system_initializer*) (eval (prop Environment.global_ctx.scope `*system_initializer*))) (if (prop Environment.global_ctx.scope `*initializer*) (eval  (prop Environment.global_ctx.scope `*initializer*)))) (catch Error (e) (progn (console.error *namespace* \"ERROR on initialization:\" e))))"),null,{
                    log_errors:true
                })
            };
            let __array__400=[],__elements__398=await values(children);
            let __BREAK__FLAG__=false;
            for(let __iter__397 in __elements__398) {
                __array__400.push(await __for_body__399(__elements__398[__iter__397]));
                if(__BREAK__FLAG__) {
                     __array__400.pop();
                    break;
                    
                }
            }return __array__400;
             
        })();
        if (check_true (await not(opts.no_start_on_ready))){
            if (check_true (env_ready)){
                {
                    (await Environment.eval(await async function(){
                        return env_ready
                    }(),null))
                }
            }
        }
    }
};
return Environment
};
return globalThis;

}();
return globalThis[symname]
}
}
}
}
await init_dlisp();
let env = await dlisp_env({"default_namespace":"user"}); 

 globalThis.in_starter=true; 

</script> <script id='ace_editor'  type='text/javascript'  charset='utf-8'>/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (require, exports, module) params
 */

(function() {

var ACE_NAMESPACE = "ace";

var global = (function() { return this; })();
if (!global && typeof window != "undefined") global = window; // strict mode


if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
    return;


var define = function(module, deps, payload) {
    if (typeof module !== "string") {
        if (define.original)
            define.original.apply(this, arguments);
        else {
            console.error("dropping module because define wasn\'t a string.");
            console.trace();
        }
        return;
    }
    if (arguments.length == 2)
        payload = deps;
    if (!define.modules[module]) {
        define.payloads[module] = payload;
        define.modules[module] = null;
    }
};

define.modules = {};
define.payloads = {};

/**
 * Get at functionality define()ed using the function above
 */
var _require = function(parentId, module, callback) {
    if (typeof module === "string") {
        var payload = lookup(parentId, module);
        if (payload != undefined) {
            callback && callback();
            return payload;
        }
    } else if (Object.prototype.toString.call(module) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined && require.original)
                return;
            params.push(dep);
        }
        return callback && callback.apply(null, params) || true;
    }
};

var require = function(module, callback) {
    var packagedModule = _require("", module, callback);
    if (packagedModule == undefined && require.original)
        return require.original.apply(this, arguments);
    return packagedModule;
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;

        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    return moduleName;
};

/**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */
var lookup = function(parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);

    var module = define.modules[moduleName];
    if (!module) {
        module = define.payloads[moduleName];
        if (typeof module === 'function') {
            var exports = {};
            var mod = {
                id: moduleName,
                uri: '',
                exports: exports,
                packaged: true
            };

            var req = function(module, callback) {
                return _require(moduleName, module, callback);
            };

            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
        }
        module = define.modules[moduleName] = exports || module;
    }
    return module;
};

function exportAce(ns) {
    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
        define.original = root.define;
        root.define = define;
        root.define.packaged = true;
    }

    if (!root.require || !root.require.packaged) {
        require.original = root.require;
        root.require = require;
        root.require.packaged = true;
    }
}

exportAce(ACE_NAMESPACE);

})();

ace.define("ace/lib/es6-shim",["require","exports","module"], function(require, exports, module){function defineProp(obj, name, val) {
    Object.defineProperty(obj, name, {
        value: val,
        enumerable: false,
        writable: true,
        configurable: true
    });
}
if (!String.prototype.startsWith) {
    defineProp(String.prototype, "startsWith", function (searchString, position) {
        position = position || 0;
        return this.lastIndexOf(searchString, position) === position;
    });
}
if (!String.prototype.endsWith) {
    defineProp(String.prototype, "endsWith", function (searchString, position) {
        var subjectString = this;
        if (position === undefined || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    });
}
if (!String.prototype.repeat) {
    defineProp(String.prototype, "repeat", function (count) {
        var result = "";
        var string = this;
        while (count > 0) {
            if (count & 1)
                result += string;
            if ((count >>= 1))
                string += string;
        }
        return result;
    });
}
if (!String.prototype.includes) {
    defineProp(String.prototype, "includes", function (str, position) {
        return this.indexOf(str, position) != -1;
    });
}
if (!Object.assign) {
    Object.assign = function (target) {
        if (target === undefined || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                Object.keys(source).forEach(function (key) {
                    output[key] = source[key];
                });
            }
        }
        return output;
    };
}
if (!Object.values) {
    Object.values = function (o) {
        return Object.keys(o).map(function (k) {
            return o[k];
        });
    };
}
if (!Array.prototype.find) {
    defineProp(Array.prototype, "find", function (predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for (var k = 0; k < len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
                return kValue;
            }
        }
    });
}
if (!Array.prototype.findIndex) {
    defineProp(Array.prototype, "findIndex", function (predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for (var k = 0; k < len; k++) {
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) {
                return k;
            }
        }
    });
}
if (!Array.prototype.includes) {
    defineProp(Array.prototype, "includes", function (item, position) {
        return this.indexOf(item, position) != -1;
    });
}
if (!Array.prototype.fill) {
    defineProp(Array.prototype, "fill", function (value) {
        var O = this;
        var len = O.length >>> 0;
        var start = arguments[1];
        var relativeStart = start >> 0;
        var k = relativeStart < 0
            ? Math.max(len + relativeStart, 0)
            : Math.min(relativeStart, len);
        var end = arguments[2];
        var relativeEnd = end === undefined ? len : end >> 0;
        var final = relativeEnd < 0
            ? Math.max(len + relativeEnd, 0)
            : Math.min(relativeEnd, len);
        while (k < final) {
            O[k] = value;
            k++;
        }
        return O;
    });
}
if (!Array.of) {
    defineProp(Array, "of", function () {
        return Array.prototype.slice.call(arguments);
    });
}

});

ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/es6-shim"], function(require, exports, module){// vim:set ts=4 sts=4 sw=4 st:
"use strict";
require("./es6-shim");

});

ace.define("ace/lib/lang",["require","exports","module"], function(require, exports, module){"use strict";
exports.last = function (a) {
    return a[a.length - 1];
};
exports.stringReverse = function (string) {
    return string.split("").reverse().join("");
};
exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;
        if (count >>= 1)
            string += string;
    }
    return result;
};
var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;
exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};
exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};
exports.copyObject = function (obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};
exports.copyArray = function (array) {
    var copy = [];
    for (var i = 0, l = array.length; i < l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else
            copy[i] = array[i];
    }
    return copy;
};
exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};
exports.arrayToMap = function (arr) {
    var map = {};
    for (var i = 0; i < arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;
};
exports.createMap = function (props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function (array, value) {
    for (var i = 0; i <= array.length; i++) {
        if (value === array[i]) {
            array.splice(i, 1);
        }
    }
};
exports.escapeRegExp = function (str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};
exports.escapeHTML = function (str) {
    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};
exports.getMatchOffsets = function (string, regExp) {
    var matches = [];
    string.replace(regExp, function (str) {
        matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
        });
    });
    return matches;
};
exports.deferredCall = function (fcn) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var deferred = function (timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };
    deferred.schedule = deferred;
    deferred.call = function () {
        this.cancel();
        fcn();
        return deferred;
    };
    deferred.cancel = function () {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    deferred.isPending = function () {
        return timer;
    };
    return deferred;
};
exports.delayedCall = function (fcn, defaultTimeout) {
    var timer = null;
    var callback = function () {
        timer = null;
        fcn();
    };
    var _self = function (timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.delay = function (timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;
    _self.call = function () {
        this.cancel();
        fcn();
    };
    _self.cancel = function () {
        timer && clearTimeout(timer);
        timer = null;
    };
    _self.isPending = function () {
        return timer;
    };
    return _self;
};

});

ace.define("ace/lib/oop",["require","exports","module"], function(require, exports, module){"use strict";
exports.inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};
exports.mixin = function (obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};
exports.implement = function (proto, mixin) {
    exports.mixin(proto, mixin);
};

});

ace.define("ace/lib/useragent",["require","exports","module"], function(require, exports, module){"use strict";
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};
exports.getOS = function () {
    if (exports.isMac) {
        return exports.OS.MAC;
    }
    else if (exports.isLinux) {
        return exports.OS.LINUX;
    }
    else {
        return exports.OS.WINDOWS;
    }
};
var _navigator = typeof navigator == "object" ? navigator : {};
var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
var ua = _navigator.userAgent || "";
var appName = _navigator.appName || "";
exports.isWin = (os == "win");
exports.isMac = (os == "mac");
exports.isLinux = (os == "linux");
exports.isIE =
    (appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0)
        ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1])
        : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie
exports.isOldIE = exports.isIE && exports.isIE < 9;
exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);
exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;
exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
exports.isAndroid = ua.indexOf("Android") >= 0;
exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
if (exports.isIOS)
    exports.isMac = true;
exports.isMobile = exports.isIOS || exports.isAndroid;

});

ace.define("ace/lib/dom",["require","exports","module","ace/lib/useragent"], function(require, exports, module){"use strict";
var useragent = require("./useragent");
var XHTML_NS = "http://www.w3.org/1999/xhtml";
exports.buildDom = function buildDom(arr, parent, refs) {
    if (typeof arr == "string" && arr) {
        var txt = document.createTextNode(arr);
        if (parent)
            parent.appendChild(txt);
        return txt;
    }
    if (!Array.isArray(arr)) {
        if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
        return arr;
    }
    if (typeof arr[0] != "string" || !arr[0]) {
        var els = [];
        for (var i = 0; i < arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch && els.push(ch);
        }
        return els;
    }
    var el = document.createElement(arr[0]);
    var options = arr[1];
    var childIndex = 1;
    if (options && typeof options == "object" && !Array.isArray(options))
        childIndex = 2;
    for (var i = childIndex; i < arr.length; i++)
        buildDom(arr[i], el, refs);
    if (childIndex == 2) {
        Object.keys(options).forEach(function (n) {
            var val = options[n];
            if (n === "class") {
                el.className = Array.isArray(val) ? val.join(" ") : val;
            }
            else if (typeof val == "function" || n == "value" || n[0] == "$") {
                el[n] = val;
            }
            else if (n === "ref") {
                if (refs)
                    refs[val] = el;
            }
            else if (n === "style") {
                if (typeof val == "string")
                    el.style.cssText = val;
            }
            else if (val != null) {
                el.setAttribute(n, val);
            }
        });
    }
    if (parent)
        parent.appendChild(el);
    return el;
};
exports.getDocumentHead = function (doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
};
exports.createElement = function (tag, ns) {
    return document.createElementNS ?
        document.createElementNS(ns || XHTML_NS, tag) :
        document.createElement(tag);
};
exports.removeChildren = function (element) {
    element.innerHTML = "";
};
exports.createTextNode = function (textContent, element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createTextNode(textContent);
};
exports.createFragment = function (element) {
    var doc = element ? element.ownerDocument : document;
    return doc.createDocumentFragment();
};
exports.hasCssClass = function (el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};
exports.addCssClass = function (el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};
exports.removeCssClass = function (el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};
exports.toggleCssClass = function (el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if (add)
        classes.push(name);
    el.className = classes.join(" ");
    return add;
};
exports.setCssClass = function (node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    }
    else {
        exports.removeCssClass(node, className);
    }
};
exports.hasCssString = function (id, doc) {
    var index = 0, sheets;
    doc = doc || document;
    if ((sheets = doc.querySelectorAll("style"))) {
        while (index < sheets.length) {
            if (sheets[index++].id === id) {
                return true;
            }
        }
    }
};
exports.removeElementById = function (id, doc) {
    doc = doc || document;
    if (doc.getElementById(id)) {
        doc.getElementById(id).remove();
    }
};
var strictCSP;
var cssCache = [];
exports.useStrictCSP = function (value) {
    strictCSP = value;
    if (value == false)
        insertPendingStyles();
    else if (!cssCache)
        cssCache = [];
};
function insertPendingStyles() {
    var cache = cssCache;
    cssCache = null;
    cache && cache.forEach(function (item) {
        importCssString(item[0], item[1]);
    });
}
function importCssString(cssText, id, target) {
    if (typeof document == "undefined")
        return;
    if (cssCache) {
        if (target) {
            insertPendingStyles();
        }
        else if (target === false) {
            return cssCache.push([cssText, id]);
        }
    }
    if (strictCSP)
        return;
    var container = target;
    if (!target || !target.getRootNode) {
        container = document;
    }
    else {
        container = target.getRootNode();
        if (!container || container == target)
            container = document;
    }
    var doc = container.ownerDocument || container;
    if (id && exports.hasCssString(id, container))
        return null;
    if (id)
        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
    var style = exports.createElement("style");
    style.appendChild(doc.createTextNode(cssText));
    if (id)
        style.id = id;
    if (container == doc)
        container = exports.getDocumentHead(doc);
    container.insertBefore(style, container.firstChild);
}
exports.importCssString = importCssString;
exports.importCssStylsheet = function (uri, doc) {
    exports.buildDom(["link", { rel: "stylesheet", href: uri }], exports.getDocumentHead(doc));
};
exports.scrollbarWidth = function (doc) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";
    var outer = exports.createElement("ace_outer");
    var style = outer.style;
    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";
    outer.appendChild(inner);
    var body = (doc && doc.documentElement) || (document && document.documentElement);
    if (!body)
        return 0;
    body.appendChild(outer);
    var noScrollbar = inner.offsetWidth;
    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;
    if (noScrollbar === withScrollbar) {
        withScrollbar = outer.clientWidth;
    }
    body.removeChild(outer);
    return noScrollbar - withScrollbar;
};
exports.computedStyle = function (element, style) {
    return window.getComputedStyle(element, "") || {};
};
exports.setStyle = function (styles, property, value) {
    if (styles[property] !== value) {
        styles[property] = value;
    }
};
exports.HAS_CSS_ANIMATION = false;
exports.HAS_CSS_TRANSFORMS = false;
exports.HI_DPI = useragent.isWin
    ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5
    : true;
if (useragent.isChromeOS)
    exports.HI_DPI = false;
if (typeof document !== "undefined") {
    var div = document.createElement("div");
    if (exports.HI_DPI && div.style.transform !== undefined)
        exports.HAS_CSS_TRANSFORMS = true;
    if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
        exports.HAS_CSS_ANIMATION = true;
    div = null;
}
if (exports.HAS_CSS_TRANSFORMS) {
    exports.translate = function (element, tx, ty) {
        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
    };
}
else {
    exports.translate = function (element, tx, ty) {
        element.style.top = Math.round(ty) + "px";
        element.style.left = Math.round(tx) + "px";
    };
}

});

ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(require, exports, module){/*
 * based on code from:
 *
 * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
"use strict";
var dom = require("./dom");
exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};
exports.loadScript = function (path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');
    s.src = path;
    head.appendChild(s);
    s.onload = s.onreadystatechange = function (_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};
exports.qualifyURL = function (url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
};

});

ace.define("ace/lib/event_emitter",["require","exports","module"], function(require, exports, module){"use strict";
var EventEmitter = {};
var stopPropagation = function () { this.propagationStopped = true; };
var preventDefault = function () { this.defaultPrevented = true; };
EventEmitter._emit =
    EventEmitter._dispatchEvent = function (eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
            return;
        if (typeof e != "object" || !e)
            e = {};
        if (!e.type)
            e.type = eventName;
        if (!e.stopPropagation)
            e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
            e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
            listeners[i](e, this);
            if (e.propagationStopped)
                break;
        }
        if (defaultHandler && !e.defaultPrevented)
            return defaultHandler(e, this);
    };
EventEmitter._signal = function (eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0; i < listeners.length; i++)
        listeners[i](e, this);
};
EventEmitter.once = function (eventName, callback) {
    var _self = this;
    this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
    });
    if (!callback) {
        return new Promise(function (resolve) {
            callback = resolve;
        });
    }
};
EventEmitter.setDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = { _disabled_: {} };
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    }
    else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};
EventEmitter.on =
    EventEmitter.addEventListener = function (eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
            listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
            listeners[capturing ? "unshift" : "push"](callback);
        return callback;
    };
EventEmitter.off =
    EventEmitter.removeListener =
        EventEmitter.removeEventListener = function (eventName, callback) {
            this._eventRegistry = this._eventRegistry || {};
            var listeners = this._eventRegistry[eventName];
            if (!listeners)
                return;
            var index = listeners.indexOf(callback);
            if (index !== -1)
                listeners.splice(index, 1);
        };
EventEmitter.removeAllListeners = function (eventName) {
    if (!eventName)
        this._eventRegistry = this._defaultHandlers = undefined;
    if (this._eventRegistry)
        this._eventRegistry[eventName] = undefined;
    if (this._defaultHandlers)
        this._defaultHandlers[eventName] = undefined;
};
exports.EventEmitter = EventEmitter;

});

ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module){"no use strict";
var oop = require("./oop");
var EventEmitter = require("./event_emitter").EventEmitter;
var optionsProvider = {
    setOptions: function (optList) {
        Object.keys(optList).forEach(function (key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function (optionNames) {
        var result = {};
        if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function (key) {
                return !options[key].hidden;
            });
        }
        else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function (key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function (name, value) {
        if (this["$" + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function (name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};
function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}
function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function () { throw e; });
}
var AppConfig = function () {
    this.$defaultOptions = {};
};
(function () {
    oop.implement(this, EventEmitter);
    this.defineOptions = function (obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};
        Object.keys(options).forEach(function (key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = { forwardTo: opt };
            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);
        return this;
    };
    this.resetOptions = function (obj) {
        Object.keys(obj.$options).forEach(function (key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    };
    this.setDefaultValue = function (path, name, value) {
        if (!path) {
            for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                    break;
            if (!this.$defaultOptions[path][name])
                return false;
        }
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    };
    this.setDefaultValues = function (path, optionHash) {
        Object.keys(optionHash).forEach(function (key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    };
    this.warn = warn;
    this.reportError = reportError;
}).call(AppConfig.prototype);
exports.AppConfig = AppConfig;

});

ace.define("ace/theme/textmate.css",["require","exports","module"], function(require, exports, module){module.exports = ".ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC\") right repeat-y;\n}\n";

});

ace.define("ace/theme/textmate",["require","exports","module","ace/theme/textmate.css","ace/lib/dom"], function(require, exports, module){"use strict";
exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = require("./textmate.css");
exports.$id = "ace/theme/textmate";
var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);

});

ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/dom","ace/lib/app_config","ace/theme/textmate"], function(require, exports, module){"no use strict";
var lang = require("./lib/lang");
var oop = require("./lib/oop");
var net = require("./lib/net");
var dom = require("./lib/dom");
var AppConfig = require("./lib/app_config").AppConfig;
module.exports = exports = new AppConfig();
var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {},
    loadWorkerFromBlob: true,
    sharedPopups: false,
    useStrictCSP: null
};
exports.get = function (key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);
    return options[key];
};
exports.set = function (key, value) {
    if (options.hasOwnProperty(key))
        options[key] = value;
    else if (this.setDefaultValue("", key, value) == false)
        throw new Error("Unknown config key: " + key);
    if (key == "useStrictCSP")
        dom.useStrictCSP(value);
};
exports.all = function () {
    return lang.copyObject(options);
};
exports.$modes = {};
exports.moduleUrl = function (name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];
    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }
    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    }
    else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};
exports.setModuleUrl = function (name, subst) {
    return options.$moduleUrls[name] = subst;
};
var loader = function (moduleName, cb) {
    if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
        return cb(null, require("./theme/textmate"));
    return console.error("loader is not configured");
};
exports.setLoader = function (cb) {
    loader = cb;
};
exports.dynamicModules = Object.create(null);
exports.$loading = {};
exports.loadModule = function (moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }
    var load = function (module) {
        if (module && !exports.$loading[moduleName])
            return onLoad && onLoad(module);
        if (!exports.$loading[moduleName])
            exports.$loading[moduleName] = [];
        exports.$loading[moduleName].push(onLoad);
        if (exports.$loading[moduleName].length > 1)
            return;
        var afterLoad = function () {
            loader(moduleName, function (err, module) {
                exports._emit("load.module", { name: moduleName, module: module });
                var listeners = exports.$loading[moduleName];
                exports.$loading[moduleName] = null;
                listeners.forEach(function (onLoad) {
                    onLoad && onLoad(module);
                });
            });
        };
        if (!exports.get("packaged"))
            return afterLoad();
        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
        reportErrorIfPathIsNotConfigured();
    };
    if (exports.dynamicModules[moduleName]) {
        exports.dynamicModules[moduleName]().then(function (module) {
            if (module.default) {
                load(module.default);
            }
            else {
                load(module);
            }
        });
    }
    else {
        try {
            module = require(moduleName);
        }
        catch (e) { }
        load(module);
    }
};
exports.setModuleLoader = function (moduleName, onLoad) {
    exports.dynamicModules[moduleName] = onLoad;
};
var reportErrorIfPathIsNotConfigured = function () {
    if (!options.basePath && !options.workerPath
        && !options.modePath && !options.themePath
        && !Object.keys(options.$moduleUrls).length) {
        console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
        reportErrorIfPathIsNotConfigured = function () { };
    }
};
exports.version = "1.15.3";

});

ace.define("ace/loader_build",["require","exports","module","ace/lib/fixoldbrowsers","ace/config"], function(require, exports, module) {
"use strict";

require("./lib/fixoldbrowsers");
var config = require("./config");
config.setLoader(function(moduleName, cb) {
    require([moduleName], function(module) {
        cb(null, module);
    });
});

var global = (function() {
    return this || typeof window != "undefined" && window;
})();

module.exports = function(ace) {
    config.init = init;
    ace.require = require;

    if (typeof define === "function")
        ace.define = define;
};
init(true);function init(packaged) {

    if (!global || !global.document)
        return;
    
    config.set("packaged", packaged || require.packaged || module.packaged || (global.define && define.packaged));

    var scriptOptions = {};
    var scriptUrl = "";
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript && currentScript.ownerDocument || document;
    
    if (currentScript && currentScript.src) {
        scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
    }
    
    var scripts = currentDocument.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute("src");
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
            config.set(key, scriptOptions[key]);
}

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}
});

ace.define("ace/lib/keys",["require","exports","module","ace/lib/oop"], function(require, exports, module){/*! @license
==========================================================================
SproutCore -- JavaScript Application Framework
copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.

For more information about SproutCore, visit http://www.sproutcore.com


==========================================================================
@license */
"use strict";
var oop = require("./oop");
var Keys = (function () {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',
            91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'
        },
        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option": 2, "shift": 4,
            "super": 8, "meta": 8, "command": 8, "cmd": 8,
            "control": 1
        },
        FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            96: "Numpad0",
            97: "Numpad1",
            98: "Numpad2",
            99: "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
            32: ' ', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5',
            54: '6', 55: '7', 56: '8', 57: '9', 59: ';', 61: '=', 65: 'a',
            66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h',
            73: 'i', 74: 'j', 75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o',
            80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't', 85: 'u', 86: 'v',
            87: 'w', 88: 'x', 89: 'y', 90: 'z', 107: '+', 109: '-', 110: '.',
            186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
            219: '[', 220: '\\', 221: ']', 222: "'", 111: '/', 106: '*'
        }
    };
    ret.PRINTABLE_KEYS[173] = '-';
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];
    (function () {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i = Math.pow(2, mods.length); i--;) {
            ret.KEY_MODS[i] = mods.filter(function (x) {
                return i & ret.KEY_MODS[x];
            }).join("-") + "-";
        }
    })();
    ret.KEY_MODS[0] = "";
    ret.KEY_MODS[-1] = "input-";
    return ret;
})();
oop.mixin(exports, Keys);
exports.keyCodeToString = function (keyCode) {
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};

});

ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module){"use strict";
var keys = require("./keys");
var useragent = require("./useragent");
var pressedKeys = null;
var ts = 0;
var activeListenerOptions;
function detectListenerOptionsSupport() {
    activeListenerOptions = false;
    try {
        document.createComment("").addEventListener("test", function () { }, {
            get passive() {
                activeListenerOptions = { passive: false };
            }
        });
    }
    catch (e) { }
}
function getListenerOptions() {
    if (activeListenerOptions == undefined)
        detectListenerOptionsSupport();
    return activeListenerOptions;
}
function EventListener(elem, type, callback) {
    this.elem = elem;
    this.type = type;
    this.callback = callback;
}
EventListener.prototype.destroy = function () {
    removeListener(this.elem, this.type, this.callback);
    this.elem = this.type = this.callback = undefined;
};
var addListener = exports.addListener = function (elem, type, callback, destroyer) {
    elem.addEventListener(type, callback, getListenerOptions());
    if (destroyer)
        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
};
var removeListener = exports.removeListener = function (elem, type, callback) {
    elem.removeEventListener(type, callback, getListenerOptions());
};
exports.stopEvent = function (e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};
exports.stopPropagation = function (e) {
    if (e.stopPropagation)
        e.stopPropagation();
};
exports.preventDefault = function (e) {
    if (e.preventDefault)
        e.preventDefault();
};
exports.getButton = function (e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;
    return e.button;
};
exports.capture = function (el, eventHandler, releaseCaptureHandler) {
    var ownerDocument = el && el.ownerDocument || document;
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);
        removeListener(ownerDocument, "mousemove", eventHandler);
        removeListener(ownerDocument, "mouseup", onMouseUp);
        removeListener(ownerDocument, "dragstart", onMouseUp);
    }
    addListener(ownerDocument, "mousemove", eventHandler);
    addListener(ownerDocument, "mouseup", onMouseUp);
    addListener(ownerDocument, "dragstart", onMouseUp);
    return onMouseUp;
};
exports.addMouseWheelListener = function (el, callback, destroyer) {
    addListener(el, "wheel", function (e) {
        var factor = 0.15;
        var deltaX = e.deltaX || 0;
        var deltaY = e.deltaY || 0;
        switch (e.deltaMode) {
            case e.DOM_DELTA_PIXEL:
                e.wheelX = deltaX * factor;
                e.wheelY = deltaY * factor;
                break;
            case e.DOM_DELTA_LINE:
                var linePixels = 15;
                e.wheelX = deltaX * linePixels;
                e.wheelY = deltaY * linePixels;
                break;
            case e.DOM_DELTA_PAGE:
                var pagePixels = 150;
                e.wheelX = deltaX * pagePixels;
                e.wheelY = deltaY * pagePixels;
                break;
        }
        callback(e);
    }, destroyer);
};
exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName, destroyer) {
    var clicks = 0;
    var startX, startY, timer;
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };
    function onMousedown(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        }
        else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        }
        else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function () { timer = null; }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        e._clicks = clicks;
        eventHandler[callbackName]("mousedown", e);
        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
        elements = [elements];
    elements.forEach(function (el) {
        addListener(el, "mousedown", onMousedown, destroyer);
    });
};
var getModifierHash = function (e) {
    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
};
exports.getModifierString = function (e) {
    return keys.KEY_MODS[getModifierHash(e)];
};
function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);
    if (!useragent.isMac && pressedKeys) {
        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            }
            else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }
    if (!hashId && keyCode === 13) {
        var location = "location" in e ? e.location : e.keyLocation;
        if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    return callback(e, hashId, keyCode);
}
exports.addCommandKeyListener = function (el, callback, destroyer) {
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function (e) {
            lastKeyDownKeyCode = e.keyCode;
        }, destroyer);
        addListener(el, "keypress", function (e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        }, destroyer);
    }
    else {
        var lastDefaultPrevented = null;
        addListener(el, "keydown", function (e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        }, destroyer);
        addListener(el, "keypress", function (e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        }, destroyer);
        addListener(el, "keyup", function (e) {
            pressedKeys[e.keyCode] = null;
        }, destroyer);
        if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
        }
    }
};
function resetPressedKeys() {
    pressedKeys = Object.create(null);
}
if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function (callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + (postMessageId++);
        var listener = function (e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                removeListener(win, "message", listener);
                callback();
            }
        };
        addListener(win, "message", listener);
        win.postMessage(messageName, "*");
    };
}
exports.$idleBlocked = false;
exports.onIdle = function (cb, timeout) {
    return setTimeout(function handler() {
        if (!exports.$idleBlocked) {
            cb();
        }
        else {
            setTimeout(handler, 100);
        }
    }, timeout);
};
exports.$idleBlockId = null;
exports.blockIdle = function (delay) {
    if (exports.$idleBlockId)
        clearTimeout(exports.$idleBlockId);
    exports.$idleBlocked = true;
    exports.$idleBlockId = setTimeout(function () {
        exports.$idleBlocked = false;
    }, delay || 100);
};
exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame
    || window.oRequestAnimationFrame);
if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function (callback) {
        setTimeout(callback, 17);
    };

});

ace.define("ace/range",["require","exports","module"], function(require, exports, module){"use strict";
var comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function (startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };
    this.end = {
        row: endRow,
        column: endColumn
    };
};
(function () {
    this.isEqual = function (range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function () {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };
    this.contains = function (row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function (range) {
        var cmp, end = range.end, start = range.start;
        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            }
            else if (cmp == 0) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else if (cmp == -1) {
            return -2;
        }
        else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            }
            else if (cmp == 1) {
                return 42;
            }
            else {
                return 0;
            }
        }
    };
    this.comparePoint = function (p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function (range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function (range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function (row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function (row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function (row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        }
        else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function (row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        }
        else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function (row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    this.compare = function (row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }
        if (row < this.start.row)
            return -1;
        if (row > this.end.row)
            return 1;
        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;
        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;
        return 0;
    };
    this.compareStart = function (row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function (row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function (row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        }
        else if (this.start.row == row && this.start.column == column) {
            return -1;
        }
        else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function (firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = { row: lastRow + 1, column: 0 };
        else if (this.end.row < firstRow)
            var end = { row: firstRow, column: 0 };
        if (this.start.row > lastRow)
            var start = { row: lastRow + 1, column: 0 };
        else if (this.start.row < firstRow)
            var start = { row: firstRow, column: 0 };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function (row, column) {
        var cmp = this.compare(row, column);
        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = { row: row, column: column };
        else
            var end = { row: row, column: column };
        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.isEmpty = function () {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function () {
        return (this.start.row !== this.end.row);
    };
    this.clone = function () {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function () {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function (session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);
        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    };
    this.moveBy = function (row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };
}).call(Range.prototype);
Range.fromPoints = function (start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;
Range.comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
exports.Range = Range;

});

ace.define("ace/clipboard",["require","exports","module"], function(require, exports, module){"use strict";
var $cancelT;
module.exports = {
    lineMode: false,
    pasteCancelled: function () {
        if ($cancelT && $cancelT > Date.now() - 50)
            return true;
        return $cancelT = false;
    },
    cancel: function () {
        $cancelT = Date.now();
    }
};

});

ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/clipboard","ace/lib/keys"], function(require, exports, module){"use strict";
var event = require("../lib/event");
var useragent = require("../lib/useragent");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var clipboard = require("../clipboard");
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE = useragent.isIE;
var HAS_FOCUS_ARGS = useragent.isChrome > 63;
var MAX_LINE_LENGTH = 400;
var KEYS = require("../lib/keys");
var MODS = KEYS.KEY_MODS;
var isIOS = useragent.isIOS;
var valueResetRegex = isIOS ? /\s/ : /\n/;
var isMobile = useragent.isMobile;
var TextInput = function (parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";
    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);
    text.style.opacity = "0";
    parentNode.insertBefore(text, parentNode.firstChild);
    var copied = false;
    var pasted = false;
    var inComposition = false;
    var sendingText = false;
    var tempStyle = '';
    if (!isMobile)
        text.style.fontSize = "1px";
    var commandMode = false;
    var ignoreFocusEvents = false;
    var lastValue = "";
    var lastSelectionStart = 0;
    var lastSelectionEnd = 0;
    var lastRestoreEnd = 0;
    try {
        var isFocused = document.activeElement === text;
    }
    catch (e) { }
    this.setAriaOptions = function (options) {
        if (options.activeDescendant) {
            text.setAttribute("aria-haspopup", "true");
            text.setAttribute("aria-autocomplete", "list");
            text.setAttribute("aria-activedescendant", options.activeDescendant);
        }
        else {
            text.setAttribute("aria-haspopup", "false");
            text.setAttribute("aria-autocomplete", "both");
            text.removeAttribute("aria-activedescendant");
        }
        if (options.role) {
            text.setAttribute("role", options.role);
        }
    };
    this.setAriaOptions({ role: "textbox" });
    event.addListener(text, "blur", function (e) {
        if (ignoreFocusEvents)
            return;
        host.onBlur(e);
        isFocused = false;
    }, host);
    event.addListener(text, "focus", function (e) {
        if (ignoreFocusEvents)
            return;
        isFocused = true;
        if (useragent.isEdge) {
            try {
                if (!document.hasFocus())
                    return;
            }
            catch (e) { }
        }
        host.onFocus(e);
        if (useragent.isEdge)
            setTimeout(resetSelection);
        else
            resetSelection();
    }, host);
    this.$focusScroll = false;
    this.focus = function () {
        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return text.focus({ preventScroll: true });
        var top = text.style.top;
        text.style.position = "fixed";
        text.style.top = "0px";
        try {
            var isTransformed = text.getBoundingClientRect().top != 0;
        }
        catch (e) {
            return;
        }
        var ancestors = [];
        if (isTransformed) {
            var t = text.parentElement;
            while (t && t.nodeType == 1) {
                ancestors.push(t);
                t.setAttribute("ace_nocontext", true);
                if (!t.parentElement && t.getRootNode)
                    t = t.getRootNode().host;
                else
                    t = t.parentElement;
            }
        }
        text.focus({ preventScroll: true });
        if (isTransformed) {
            ancestors.forEach(function (p) {
                p.removeAttribute("ace_nocontext");
            });
        }
        setTimeout(function () {
            text.style.position = "";
            if (text.style.top == "0px")
                text.style.top = top;
        }, 0);
    };
    this.blur = function () {
        text.blur();
    };
    this.isFocused = function () {
        return isFocused;
    };
    host.on("beforeEndOperation", function () {
        var curOp = host.curOp;
        var commandName = curOp && curOp.command && curOp.command.name;
        if (commandName == "insertstring")
            return;
        var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
        if (inComposition && isUserAction) {
            lastValue = text.value = "";
            onCompositionEnd();
        }
        resetSelection();
    });
    var resetSelection = isIOS
        ? function (value) {
            if (!isFocused || (copied && !value) || sendingText)
                return;
            if (!value)
                value = "";
            var newValue = "\n ab" + value + "cde fg\n";
            if (newValue != text.value)
                text.value = lastValue = newValue;
            var selectionStart = 4;
            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
                text.setSelectionRange(selectionStart, selectionEnd);
            }
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
        }
        : function () {
            if (inComposition || sendingText)
                return;
            if (!isFocused && !afterContextMenu)
                return;
            inComposition = true;
            var selectionStart = 0;
            var selectionEnd = 0;
            var line = "";
            if (host.session) {
                var selection = host.selection;
                var range = selection.getRange();
                var row = selection.cursor.row;
                selectionStart = range.start.column;
                selectionEnd = range.end.column;
                line = host.session.getLine(row);
                if (range.start.row != row) {
                    var prevLine = host.session.getLine(row - 1);
                    selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
                    selectionEnd += prevLine.length + 1;
                    line = prevLine + "\n" + line;
                }
                else if (range.end.row != row) {
                    var nextLine = host.session.getLine(row + 1);
                    selectionEnd = range.end.row > row + 1 ? nextLine.length : selectionEnd;
                    selectionEnd += line.length + 1;
                    line = line + "\n" + nextLine;
                }
                else if (isMobile && row > 0) {
                    line = "\n" + line;
                    selectionEnd += 1;
                    selectionStart += 1;
                }
                if (line.length > MAX_LINE_LENGTH) {
                    if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                        line = line.slice(0, MAX_LINE_LENGTH);
                    }
                    else {
                        line = "\n";
                        if (selectionStart == selectionEnd) {
                            selectionStart = selectionEnd = 0;
                        }
                        else {
                            selectionStart = 0;
                            selectionEnd = 1;
                        }
                    }
                }
            }
            var newValue = line + "\n\n";
            if (newValue != lastValue) {
                text.value = lastValue = newValue;
                lastSelectionStart = lastSelectionEnd = newValue.length;
            }
            if (afterContextMenu) {
                lastSelectionStart = text.selectionStart;
                lastSelectionEnd = text.selectionEnd;
            }
            if (lastSelectionEnd != selectionEnd
                || lastSelectionStart != selectionStart
                || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
            ) {
                try {
                    text.setSelectionRange(selectionStart, selectionEnd);
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                }
                catch (e) { }
            }
            inComposition = false;
        };
    this.resetSelection = resetSelection;
    if (isFocused)
        host.onFocus();
    var isAllSelected = function (text) {
        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length
            && text.value === lastValue && lastValue
            && text.selectionEnd !== lastSelectionEnd;
    };
    var onSelect = function (e) {
        if (inComposition)
            return;
        if (copied) {
            copied = false;
        }
        else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        }
        else if (isMobile && text.selectionStart != lastSelectionStart) {
            resetSelection();
        }
    };
    var inputHandler = null;
    this.setInputHandler = function (cb) { inputHandler = cb; };
    this.getInputHandler = function () { return inputHandler; };
    var afterContextMenu = false;
    var sendText = function (value, fromInput) {
        if (afterContextMenu)
            afterContextMenu = false;
        if (pasted) {
            resetSelection();
            if (value)
                host.onPaste(value);
            pasted = false;
            return "";
        }
        else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
            var i = 0;
            while (extendLeft > 0 && lastValue[i] == value[i]) {
                i++;
                extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]) {
                i++;
                extendRight--;
            }
            restoreStart -= i - 1;
            restoreEnd -= i - 1;
            var endIndex = inserted.length - i + 1;
            if (endIndex < 0) {
                extendLeft = -endIndex;
                endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                return "";
            sendingText = true;
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
                inserted = "  ";
                shouldReset = true;
            }
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
                host.onTextInput(inserted);
            }
            else {
                host.onTextInput(inserted, {
                    extendLeft: extendLeft,
                    extendRight: extendRight,
                    restoreStart: restoreStart,
                    restoreEnd: restoreEnd
                });
            }
            sendingText = false;
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
        }
    };
    var onInput = function (e) {
        if (inComposition)
            return onCompositionUpdate();
        if (e && e.inputType) {
            if (e.inputType == "historyUndo")
                return host.execCommand("undo");
            if (e.inputType == "historyRedo")
                return host.execCommand("redo");
        }
        var data = text.value;
        var inserted = sendText(data, true);
        if (data.length > MAX_LINE_LENGTH + 100
            || valueResetRegex.test(inserted)
            || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
            resetSelection();
        }
    };
    var handleClipboardData = function (e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
            if (data) {
                return clipboardData.setData(mime, data) !== false;
            }
            else {
                return clipboardData.getData(mime);
            }
        }
        catch (e) {
            if (!forceIEMime)
                return handleClipboardData(e, data, true);
        }
    };
    var doCopy = function (e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);
        if (handleClipboardData(e, data)) {
            if (isIOS) {
                resetSelection(data);
                copied = data;
                setTimeout(function () {
                    copied = false;
                }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        }
        else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function () {
                copied = false;
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };
    var onCut = function (e) {
        doCopy(e, true);
    };
    var onCopy = function (e) {
        doCopy(e, false);
    };
    var onPaste = function (e) {
        var data = handleClipboardData(e);
        if (clipboard.pasteCancelled())
            return;
        if (typeof data == "string") {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };
    event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
    event.addListener(text, "select", onSelect, host);
    event.addListener(text, "input", onInput, host);
    event.addListener(text, "cut", onCut, host);
    event.addListener(text, "copy", onCopy, host);
    event.addListener(text, "paste", onPaste, host);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
        event.addListener(parentNode, "keydown", function (e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                return;
            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        }, host);
    }
    var onCompositionStart = function (e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
        inComposition = {};
        if (commandMode)
            return;
        if (e.data)
            inComposition.useTextareaForIME = false;
        setTimeout(onCompositionUpdate, 0);
        host._signal("compositionStart");
        host.on("mousedown", cancelComposition);
        var range = host.getSelectionRange();
        range.end.row = range.start.row;
        range.end.column = range.start.column;
        inComposition.markerRange = range;
        inComposition.selectionStart = lastSelectionStart;
        host.onCompositionStart(inComposition);
        if (inComposition.useTextareaForIME) {
            lastValue = text.value = "";
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
        }
        else {
            if (text.msGetInputContext)
                inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
                inComposition.context = text.getInputContext();
        }
    };
    var onCompositionUpdate = function () {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        if (commandMode)
            return cancelComposition();
        if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
        }
        else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
                if (inComposition.context) {
                    inComposition.markerRange.start.column = inComposition.selectionStart
                        = inComposition.context.compositionStartOffset;
                }
                inComposition.markerRange.end.column = inComposition.markerRange.start.column
                    + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
        }
    };
    var onCompositionEnd = function (e) {
        if (!host.onCompositionEnd || host.$readOnly)
            return;
        inComposition = false;
        host.onCompositionEnd();
        host.off("mousedown", cancelComposition);
        if (e)
            onInput();
    };
    function cancelComposition() {
        ignoreFocusEvents = true;
        text.blur();
        text.focus();
        ignoreFocusEvents = false;
    }
    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
    function onKeyup(e) {
        if (e.keyCode == 27 && text.value.length < text.selectionStart) {
            if (!inComposition)
                lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
        }
        syncComposition();
    }
    event.addListener(text, "compositionstart", onCompositionStart, host);
    event.addListener(text, "compositionupdate", onCompositionUpdate, host);
    event.addListener(text, "keyup", onKeyup, host);
    event.addListener(text, "keydown", syncComposition, host);
    event.addListener(text, "compositionend", onCompositionEnd, host);
    this.getElement = function () {
        return text;
    };
    this.setCommandMode = function (value) {
        commandMode = value;
        text.readOnly = false;
    };
    this.setReadOnly = function (readOnly) {
        if (!commandMode)
            text.readOnly = readOnly;
    };
    this.setCopyWithEmptySelection = function (value) {
    };
    this.onContextMenu = function (e) {
        afterContextMenu = true;
        resetSelection();
        host._emit("nativecontextmenu", { target: host, domEvent: e });
        this.moveToMouse(e, true);
    };
    this.moveToMouse = function (e, bringToFront) {
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + (useragent.isIE ? "opacity:0.1;" : "")
            + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight - 2;
        var move = function (e) {
            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
        };
        move(e);
        if (e.type != "mousedown")
            return;
        host.renderer.$isMousePressed = true;
        clearTimeout(closeTimeout);
        if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
    };
    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
                host.renderer.$moveTextAreaToCursor();
        }, 0);
    }
    var onContextMenu = function (e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(text, "mouseup", onContextMenu, host);
    event.addListener(text, "mousedown", function (e) {
        e.preventDefault();
        onContextMenuClose();
    }, host);
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
    event.addListener(text, "contextmenu", onContextMenu, host);
    if (isIOS)
        addIosSelectionHandler(parentNode, host, text);
    function addIosSelectionHandler(parentNode, host, text) {
        var typingResetTimeout = null;
        var typing = false;
        text.addEventListener("keydown", function (e) {
            if (typingResetTimeout)
                clearTimeout(typingResetTimeout);
            typing = true;
        }, true);
        text.addEventListener("keyup", function (e) {
            typingResetTimeout = setTimeout(function () {
                typing = false;
            }, 100);
        }, true);
        var detectArrowKeys = function (e) {
            if (document.activeElement !== text)
                return;
            if (typing || inComposition || host.$mouseHandler.isMousePressed)
                return;
            if (copied) {
                return;
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
                key = KEYS.up;
            }
            else if (selectionStart == 1) {
                key = KEYS.home;
            }
            else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
                key = KEYS.end;
            }
            else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                key = KEYS.left;
                modifier = MODS.option;
            }
            else if (selectionStart < lastSelectionStart
                || (selectionStart == lastSelectionStart
                    && lastSelectionEnd != lastSelectionStart
                    && selectionStart == selectionEnd)) {
                key = KEYS.left;
            }
            else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                key = KEYS.down;
            }
            else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                key = KEYS.right;
                modifier = MODS.option;
            }
            else if (selectionEnd > lastSelectionEnd
                || (selectionEnd == lastSelectionEnd
                    && lastSelectionEnd != lastSelectionStart
                    && selectionStart == selectionEnd)) {
                key = KEYS.right;
            }
            if (selectionStart !== selectionEnd)
                modifier |= MODS.shift;
            if (key) {
                var result = host.onCommandKey({}, modifier, key);
                if (!result && host.commands) {
                    key = KEYS.keyCodeToString(key);
                    var command = host.commands.findKeyCommand(modifier, key);
                    if (command)
                        host.execCommand(command);
                }
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
                resetSelection("");
            }
        };
        document.addEventListener("selectionchange", detectArrowKeys);
        host.on("destroy", function () {
            document.removeEventListener("selectionchange", detectArrowKeys);
        });
    }
    this.destroy = function () {
        if (text.parentElement)
            text.parentElement.removeChild(text);
    };
};
exports.TextInput = TextInput;
exports.$setUserAgentForTests = function (_isMobile, _isIOS) {
    isMobile = _isMobile;
    isIOS = _isIOS;
};

});

ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/useragent"], function(require, exports, module){"use strict";
var useragent = require("../lib/useragent");
var DRAG_OFFSET = 0; // pixels
var SCROLL_COOLDOWN_T = 550; // milliseconds
function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;
    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
    exports.forEach(function (x) {
        mouseHandler[x] = this[x];
    }, this);
    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
}
(function () {
    this.onMouseDown = function (ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;
        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
            if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                    ev.preventDefault();
            }
            return;
        }
        this.mousedownEvent.time = Date.now();
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }
        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    };
    this.startSelect = function (pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        if (!this.mousedownEvent)
            return;
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        editor.setStyle("ace_selecting");
        this.setState("select");
    };
    this.select = function () {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);
            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            }
            else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            }
            else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    };
    this.extendSelectionBy = function (unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);
            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            }
            else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            }
            else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            }
            else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
    };
    this.selectEnd =
        this.selectAllEnd =
            this.selectByWordsEnd =
                this.selectByLinesEnd = function () {
                    this.$clickSelection = null;
                    this.editor.unsetStyle("ace_selecting");
                };
    this.focusWait = function () {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();
        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };
    this.onDoubleClick = function (ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;
        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        }
        else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    };
    this.onTripleClick = function (ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        }
        else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    };
    this.onQuadClick = function (ev) {
        var editor = this.editor;
        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    };
    this.onMouseWheel = function (ev) {
        if (ev.getAccelKey())
            return;
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }
        var editor = this.editor;
        if (!this.$lastScroll)
            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
        var prevScroll = this.$lastScroll;
        var t = ev.domEvent.timeStamp;
        var dt = t - prevScroll.t;
        var vx = dt ? ev.wheelX / dt : prevScroll.vx;
        var vy = dt ? ev.wheelY / dt : prevScroll.vy;
        if (dt < SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
        }
        var direction = Math.abs(vx / vy);
        var canScroll = false;
        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
            canScroll = true;
        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
            canScroll = true;
        if (canScroll) {
            prevScroll.allowed = t;
        }
        else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)
                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
            if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
            }
            else {
                prevScroll.allowed = 0;
            }
        }
        prevScroll.t = t;
        prevScroll.vx = vx;
        prevScroll.vy = vy;
        if (canScroll) {
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };
}).call(DefaultHandlers.prototype);
exports.DefaultHandlers = DefaultHandlers;
function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}
function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;
    if (cmp < 0)
        return { cursor: range.start, anchor: range.end };
    else
        return { cursor: range.end, anchor: range.start };
}

});

ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var dom = require("./lib/dom");
var CLASSNAME = "ace_tooltip";
function Tooltip(parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
}
(function () {
    this.$init = function () {
        this.$element = dom.createElement("div");
        this.$element.className = CLASSNAME;
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    };
    this.getElement = function () {
        return this.$element || this.$init();
    };
    this.setText = function (text) {
        this.getElement().textContent = text;
    };
    this.setHtml = function (html) {
        this.getElement().innerHTML = html;
    };
    this.setPosition = function (x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    };
    this.setClassName = function (className) {
        dom.addCssClass(this.getElement(), className);
    };
    this.show = function (text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    };
    this.hide = function () {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.getElement().className = CLASSNAME;
            this.isOpen = false;
        }
    };
    this.getHeight = function () {
        return this.getElement().offsetHeight;
    };
    this.getWidth = function () {
        return this.getElement().offsetWidth;
    };
    this.destroy = function () {
        this.isOpen = false;
        if (this.$element && this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
        }
    };
}).call(Tooltip.prototype);
exports.Tooltip = Tooltip;

});

ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(require, exports, module){"use strict";
var dom = require("../lib/dom");
var oop = require("../lib/oop");
var event = require("../lib/event");
var Tooltip = require("../tooltip").Tooltip;
function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);
    mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);
        if (gutterRegion == "foldWidgets")
            return;
        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;
        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });
    var tooltipTimeout, mouseEvent, tooltipAnnotation;
    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();
        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }
        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join("<br/>");
        tooltip.setHtml(tooltipAnnotation);
        var annotationClassName = annotation.className;
        if (annotationClassName) {
            tooltip.setClassName(annotationClassName.trim());
        }
        tooltip.show();
        editor._signal("showGutterTooltip", tooltip);
        editor.on("mousewheel", hideTooltip);
        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        }
        else {
            var gutterElement = mouseEvent.domEvent.target;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
        }
    }
    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor._signal("hideGutterTooltip", tooltip);
            editor.off("mousewheel", hideTooltip);
        }
    }
    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }
    mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();
        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);
        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function () {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });
    event.addListener(editor.renderer.$gutter, "mouseout", function (e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function () {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    }, editor);
    editor.on("changeSession", hideTooltip);
}
function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
}
oop.inherits(GutterTooltip, Tooltip);
(function () {
    this.setPosition = function (x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    };
}).call(GutterTooltip.prototype);
exports.GutterHandler = GutterHandler;

});

ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module){"use strict";
var event = require("../lib/event");
var useragent = require("../lib/useragent");
var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;
    this.$pos = null;
    this.$inSelection = null;
    this.propagationStopped = false;
    this.defaultPrevented = false;
};
(function () {
    this.stopPropagation = function () {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    this.preventDefault = function () {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    this.stop = function () {
        this.stopPropagation();
        this.preventDefault();
    };
    this.getDocumentPosition = function () {
        if (this.$pos)
            return this.$pos;
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    this.inSelection = function () {
        if (this.$inSelection !== null)
            return this.$inSelection;
        var editor = this.editor;
        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }
        return this.$inSelection;
    };
    this.getButton = function () {
        return event.getButton(this.domEvent);
    };
    this.getShiftKey = function () {
        return this.domEvent.shiftKey;
    };
    this.getAccelKey = useragent.isMac
        ? function () { return this.domEvent.metaKey; }
        : function () { return this.domEvent.ctrlKey; };
}).call(MouseEvent.prototype);

});

ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(require, exports, module){"use strict";
var dom = require("../lib/dom");
var event = require("../lib/event");
var useragent = require("../lib/useragent");
var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;
function DragdropHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var dragImage = dom.createElement("div");
    dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
    dragImage.textContent = "\xa0";
    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
    exports.forEach(function (x) {
        mouseHandler[x] = this[x];
    }, this);
    editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;
    this.onDragStart = function (e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function () {
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();
        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        editor.container.appendChild(dragImage);
        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(function () {
            editor.container.removeChild(dragImage);
        });
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());
        isInternal = true;
        this.setState("drag");
    };
    this.onDragEnd = function (e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };
    this.onDragEnter = function (e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };
    this.onDragOver = function (e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };
    this.onDragLeave = function (e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };
    this.onDrop = function (e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    }
                    else {
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        }
        else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };
    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = { x: x, y: y };
        }
        else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            }
            else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }
    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
            x: {
                left: x - editorRect.left,
                right: editorRect.right - x
            },
            y: {
                top: y - editorRect.top,
                bottom: editorRect.bottom - y
            }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = { row: cursor.row, column: cursor.column };
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        }
        else {
            autoScrollStartTime = null;
        }
    }
    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }
    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }
    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.selection.fromOrientedRange(range);
        if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function () {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }
    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function (type) {
            return type == 'text/plain' || type == 'Text';
        });
    }
    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];
        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        }
        catch (e) { }
        var dropEffect = "none";
        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        return dropEffect;
    }
}
(function () {
    this.dragWait = function () {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };
    this.dragWaitEnd = function () {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };
    this.dragReadyEnd = function (e) {
        this.editor.$resetCursorStyle();
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };
    this.startDrag = function () {
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };
    this.onMouseDrag = function (e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };
    this.onMouseDown = function (e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;
        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            }
            else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
        }
    };
}).call(DragdropHandler.prototype);
function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}
exports.DragdropHandler = DragdropHandler;

});

ace.define("ace/mouse/touch_handler",["require","exports","module","ace/mouse/mouse_event","ace/lib/event","ace/lib/dom"], function(require, exports, module){"use strict";
var MouseEvent = require("./mouse_event").MouseEvent;
var event = require("../lib/event");
var dom = require("../lib/dom");
exports.addTouchListeners = function (el, editor) {
    var mode = "scroll";
    var startX;
    var startY;
    var touchStartT;
    var lastT;
    var longTouchTimer;
    var animationTimer;
    var animationSteps = 0;
    var pos;
    var clickCount = 0;
    var vX = 0;
    var vY = 0;
    var pressed;
    var contextMenu;
    function createContextMenu() {
        var clipboard = window.navigator && window.navigator.clipboard;
        var isOpen = false;
        var updateMenu = function () {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(dom.buildDom(isOpen ? ["span",
                !selected && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
                selected && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
                selected && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
                clipboard && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
                hasUndo && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
                ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
                ["span", { class: "ace_mobile-button", action: "openCommandPallete" }, "Palette"]
            ] : ["span"]), contextMenu.firstChild);
        };
        var handleClick = function (e) {
            var action = e.target.getAttribute("action");
            if (action == "more" || !isOpen) {
                isOpen = !isOpen;
                return updateMenu();
            }
            if (action == "paste") {
                clipboard.readText().then(function (text) {
                    editor.execCommand(action, text);
                });
            }
            else if (action) {
                if (action == "cut" || action == "copy") {
                    if (clipboard)
                        clipboard.writeText(editor.getCopyText());
                    else
                        document.execCommand("copy");
                }
                editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPallete")
                editor.focus();
        };
        contextMenu = dom.buildDom(["div",
            {
                class: "ace_mobile-menu",
                ontouchstart: function (e) {
                    mode = "menu";
                    e.stopPropagation();
                    e.preventDefault();
                    editor.textInput.focus();
                },
                ontouchend: function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    handleClick(e);
                },
                onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
        ], editor.container);
    }
    function showContextMenu() {
        if (!contextMenu)
            createContextMenu();
        var cursor = editor.selection.cursor;
        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
        var scrollLeft = editor.renderer.scrollLeft;
        var rect = editor.container.getBoundingClientRect();
        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
        if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
        }
        else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
        }
        contextMenu.style.display = "";
        contextMenu.firstChild.style.display = "none";
        editor.on("input", hideContextMenu);
    }
    function hideContextMenu(e) {
        if (contextMenu)
            contextMenu.style.display = "none";
        editor.off("input", hideContextMenu);
    }
    function handleLongTap() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        var range = editor.selection.getRange();
        var inSelection = range.contains(pos.row, pos.column);
        if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
        }
        mode = "wait";
        showContextMenu();
    }
    function switchToSelectionMode() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        editor.selection.moveToPosition(pos);
        var range = clickCount >= 2
            ? editor.selection.getLineRange(pos.row)
            : editor.session.getBracketRange(pos);
        if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
        }
        else {
            editor.selection.selectWord();
        }
        mode = "wait";
    }
    event.addListener(el, "contextmenu", function (e) {
        if (!pressed)
            return;
        var textarea = editor.textInput.getElement();
        textarea.focus();
    }, editor);
    event.addListener(el, "touchstart", function (e) {
        var touches = e.touches;
        if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
        }
        pressed = editor.$mouseHandler.isMousePressed = true;
        var h = editor.renderer.layerConfig.lineHeight;
        var w = editor.renderer.layerConfig.lineHeight;
        var t = e.timeStamp;
        lastT = t;
        var touchObj = touches[0];
        var x = touchObj.clientX;
        var y = touchObj.clientY;
        if (Math.abs(startX - x) + Math.abs(startY - y) > h)
            touchStartT = -1;
        startX = e.clientX = x;
        startY = e.clientY = y;
        vX = vY = 0;
        var ev = new MouseEvent(e, editor);
        pos = ev.getDocumentPosition();
        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e.preventDefault();
            e.button = 0;
            switchToSelectionMode();
        }
        else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function (x, y) {
                x = x / w;
                y = y / h - 0.75;
                return x * x + y * y;
            };
            if (e.clientX < rect.left) {
                mode = "zoom";
                return;
            }
            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
            if (diff1 < 3.5 && diff2 < 3.5)
                mode = diff1 > diff2 ? "cursor" : "anchor";
            if (diff2 < 3.5)
                mode = "anchor";
            else if (diff1 < 3.5)
                mode = "cursor";
            else
                mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
        }
        touchStartT = t;
    }, editor);
    event.addListener(el, "touchend", function (e) {
        pressed = editor.$mouseHandler.isMousePressed = false;
        if (animationTimer)
            clearInterval(animationTimer);
        if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
        }
        else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
        }
        else if (mode == "scroll") {
            animate();
            hideContextMenu();
        }
        else {
            showContextMenu();
        }
        clearTimeout(longTouchTimer);
        longTouchTimer = null;
    }, editor);
    event.addListener(el, "touchmove", function (e) {
        if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        }
        var touches = e.touches;
        if (touches.length > 1 || mode == "zoom")
            return;
        var touchObj = touches[0];
        var wheelX = startX - touchObj.clientX;
        var wheelY = startY - touchObj.clientY;
        if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
                mode = "cursor";
            else
                return e.preventDefault();
        }
        startX = touchObj.clientX;
        startY = touchObj.clientY;
        e.clientX = touchObj.clientX;
        e.clientY = touchObj.clientY;
        var t = e.timeStamp;
        var dt = t - lastT;
        lastT = t;
        if (mode == "scroll") {
            var mouseEvent = new MouseEvent(e, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY))
                wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX))
                wheelY = 0;
            if (dt != 0) {
                vX = wheelX / dt;
                vY = wheelY / dt;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
                vX = vY = 0;
            }
        }
        else {
            var ev = new MouseEvent(e, editor);
            var pos = ev.getDocumentPosition();
            if (mode == "cursor")
                editor.selection.moveCursorToPosition(pos);
            else if (mode == "anchor")
                editor.selection.setSelectionAnchor(pos.row, pos.column);
            editor.renderer.scrollCursorIntoView(pos);
            e.preventDefault();
        }
    }, editor);
    function animate() {
        animationSteps += 60;
        animationTimer = setInterval(function () {
            if (animationSteps-- <= 0) {
                clearInterval(animationTimer);
                animationTimer = null;
            }
            if (Math.abs(vX) < 0.01)
                vX = 0;
            if (Math.abs(vY) < 0.01)
                vY = 0;
            if (animationSteps < 20)
                vX = 0.9 * vX;
            if (animationSteps < 20)
                vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
                animationSteps = 0;
        }, 10);
    }
};

});

ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/mouse/touch_handler","ace/config"], function(require, exports, module){"use strict";
var event = require("../lib/event");
var useragent = require("../lib/useragent");
var DefaultHandlers = require("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
var MouseEvent = require("./mouse_event").MouseEvent;
var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
var addTouchListeners = require("./touch_handler").addTouchListeners;
var config = require("../config");
var MouseHandler = function (editor) {
    var _self = this;
    this.editor = editor;
    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);
    var focusEditor = function (e) {
        var windowBlurred = !document.hasFocus || !document.hasFocus()
            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
        if (windowBlurred)
            window.focus();
        editor.focus();
        setTimeout(function () {
            if (!editor.isFocused())
                editor.focus();
        });
    };
    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
    event.addMultiMouseDownListener([
        mouseTarget,
        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
        editor.textInput && editor.textInput.getElement()
    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
    addTouchListeners(editor.container, editor);
    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
    event.addListener(mouseTarget, "mousedown", focusEditor, editor);
    event.addListener(gutterEl, "mousedown", focusEditor, editor);
    if (useragent.isIE && editor.renderer.scrollBarV) {
        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
    }
    editor.on("mousemove", function (e) {
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;
        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;
        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
        }
        else {
            renderer.setCursorStyle("");
        }
    }, editor);
};
(function () {
    this.onMouseEvent = function (name, e) {
        if (!this.editor.session)
            return;
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };
    this.onMouseMove = function (name, e) {
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };
    this.onMouseWheel = function (name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;
        this.editor._emit(name, mouseEvent);
    };
    this.setState = function (state) {
        this.state = state;
    };
    this.captureMouse = function (ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;
        this.isMousePressed = true;
        var editor = this.editor;
        var renderer = this.editor.renderer;
        renderer.$isMousePressed = true;
        var self = this;
        var onMouseMove = function (e) {
            if (!e)
                return;
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();
            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };
        var onCaptureEnd = function (e) {
            editor.off("beforeEndOperation", onOperationEnd);
            clearInterval(timerId);
            if (editor.session)
                onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            self.isMousePressed = renderer.$isMousePressed = false;
            if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
            editor.endOperation();
        };
        var onCaptureInterval = function () {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };
        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function () { onCaptureEnd(ev); });
        }
        var onOperationEnd = function (e) {
            if (!self.releaseMouse)
                return;
            if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self[self.state + "End"] && self[self.state + "End"]();
                self.state = "";
                self.releaseMouse();
            }
        };
        editor.on("beforeEndOperation", onOperationEnd);
        editor.startOperation({ command: { name: "mouse" } });
        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function () {
        var stop = function (e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    };
    this.destroy = function () {
        if (this.releaseMouse)
            this.releaseMouse();
    };
}).call(MouseHandler.prototype);
config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: { initialValue: 2 },
    dragDelay: { initialValue: (useragent.isMac ? 150 : 0) },
    dragEnabled: { initialValue: true },
    focusTimeout: { initialValue: 0 },
    tooltipFollowsMouse: { initialValue: true }
});
exports.MouseHandler = MouseHandler;

});

ace.define("ace/mouse/fold_handler",["require","exports","module","ace/lib/dom"], function(require, exports, module){"use strict";
var dom = require("../lib/dom");
function FoldHandler(editor) {
    editor.on("click", function (e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);
            e.stop();
        }
        var target = e.domEvent && e.domEvent.target;
        if (target && dom.hasCssClass(target, "ace_inline_button")) {
            if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                session.setOption("wrap", !session.getUseWrapMode());
                editor.renderer.scrollCursorIntoView();
            }
        }
    });
    editor.on("gutterclick", function (e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });
    editor.on("gutterdblclick", function (e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;
            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                if (fold) {
                    session.removeFold(fold);
                }
                else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                }
            }
            e.stop();
        }
    });
}
exports.FoldHandler = FoldHandler;

});

ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(require, exports, module){"use strict";
var keyUtil = require("../lib/keys");
var event = require("../lib/event");
var KeyBinding = function (editor) {
    this.$editor = editor;
    this.$data = { editor: editor };
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};
(function () {
    this.setDefaultHandler = function (kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    };
    this.setKeyboardHandler = function (kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;
        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);
        this.addKeyboardHandler(kb, 1);
    };
    this.addKeyboardHandler = function (kb, pos) {
        if (!kb)
            return;
        if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);
        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);
        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    };
    this.removeKeyboardHandler = function (kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    };
    this.getKeyboardHandler = function () {
        return this.$handlers[this.$handlers.length - 1];
    };
    this.getStatusText = function () {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function (h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    };
    this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;
        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
            if (!toExecute || !toExecute.command)
                continue;
            if (toExecute.command == "null") {
                success = true;
            }
            else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 &&
                toExecute.passEvent != true && toExecute.command.passEvent != true) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        if (!success && hashId == -1) {
            toExecute = { command: "insertstring" };
            success = commands.exec("insertstring", this.$editor, keyString);
        }
        if (success && this.$editor._signal)
            this.$editor._signal("keyboardActivity", toExecute);
        return success;
    };
    this.onCommandKey = function (e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };
    this.onTextInput = function (text) {
        return this.$callKeyboardHandlers(-1, text);
    };
}).call(KeyBinding.prototype);
exports.KeyBinding = KeyBinding;

});

ace.define("ace/lib/bidiutil",["require","exports","module"], function(require, exports, module){"use strict";
var ArabicAlefBetIntervalsBegine = ['\u0621', '\u0641'];
var ArabicAlefBetIntervalsEnd = ['\u063A', '\u064a'];
var dir = 0, hiLevel = 0;
var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
var impTab_LTR = [ [0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]
];
var impTab_RTL = [ [2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]
];
var LTR = 0, RTL = 1;
var L = 0;
var R = 1;
var EN = 2;
var AN = 3;
var ON = 4;
var B = 5;
var S = 6;
var AL = 7;
var WS = 8;
var CS = 9;
var ES = 10;
var ET = 11;
var NSM = 12;
var LRE = 13;
var RLE = 14;
var PDF = 15;
var LRO = 16;
var RLO = 17;
var BN = 18;
var UnicodeTBL00 = [
    BN, BN, BN, BN, BN, BN, BN, BN, BN, S, B, S, WS, B, BN, BN,
    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, B, B, B, S,
    WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
    EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, ON,
    ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
    L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, BN,
    BN, BN, BN, BN, BN, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
    BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
    CS, ON, ET, ET, ET, ET, ON, ON, ON, ON, L, ON, ON, BN, ON, ON,
    ET, ET, EN, EN, ON, L, ON, ON, ON, EN, L, ON, ON, ON, ON, ON
];
var UnicodeTBL20 = [
    WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN, L, R,
    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
    ON, ON, ON, ON, ON, ON, ON, ON, WS, B, LRE, RLE, PDF, LRO, RLO, CS,
    ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
    ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
    ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS
];
function _computeLevels(chars, levels, len, charTypes) {
    var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
    if (!charTypes) {
        for (i = 0, charTypes = []; i < len; i++) {
            charTypes[i] = _getCharacterType(chars[i]);
        }
    }
    hiLevel = dir;
    lastArabic = false;
    hasUBAT_AL = false;
    hasUBAT_B = false;
    hasUBAT_S = false;
    for (ix = 0; ix < len; ix++) {
        prevState = newState;
        classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
        newState = impTab[prevState][newClass];
        action = newState & 0xF0;
        newState &= 0x0F;
        levels[ix] = newLevel = impTab[newState][5];
        if (action > 0) {
            if (action == 0x10) {
                for (i = condPos; i < ix; i++) {
                    levels[i] = 1;
                }
                condPos = -1;
            }
            else {
                condPos = -1;
            }
        }
        cond = impTab[newState][6];
        if (cond) {
            if (condPos == -1) {
                condPos = ix;
            }
        }
        else {
            if (condPos > -1) {
                for (i = condPos; i < ix; i++) {
                    levels[i] = newLevel;
                }
                condPos = -1;
            }
        }
        if (charTypes[ix] == B) {
            levels[ix] = 0;
        }
        hiLevel |= newLevel;
    }
    if (hasUBAT_S) {
        for (i = 0; i < len; i++) {
            if (charTypes[i] == S) {
                levels[i] = dir;
                for (var j = i - 1; j >= 0; j--) {
                    if (charTypes[j] == WS) {
                        levels[j] = dir;
                    }
                    else {
                        break;
                    }
                }
            }
        }
    }
}
function _invertLevel(lev, levels, _array) {
    if (hiLevel < lev) {
        return;
    }
    if (lev == 1 && dir == RTL && !hasUBAT_B) {
        _array.reverse();
        return;
    }
    var len = _array.length, start = 0, end, lo, hi, tmp;
    while (start < len) {
        if (levels[start] >= lev) {
            end = start + 1;
            while (end < len && levels[end] >= lev) {
                end++;
            }
            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
                tmp = _array[lo];
                _array[lo] = _array[hi];
                _array[hi] = tmp;
            }
            start = end;
        }
        start++;
    }
}
function _getCharClass(chars, types, classes, ix) {
    var cType = types[ix], wType, nType, len, i;
    switch (cType) {
        case L:
        case R:
            lastArabic = false;
        case ON:
        case AN:
            return cType;
        case EN:
            return lastArabic ? AN : EN;
        case AL:
            lastArabic = true;
            hasUBAT_AL = true;
            return R;
        case WS:
            return ON;
        case CS:
            if (ix < 1 || (ix + 1) >= types.length ||
                ((wType = classes[ix - 1]) != EN && wType != AN) ||
                ((nType = types[ix + 1]) != EN && nType != AN)) {
                return ON;
            }
            if (lastArabic) {
                nType = AN;
            }
            return nType == wType ? nType : ON;
        case ES:
            wType = ix > 0 ? classes[ix - 1] : B;
            if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN) {
                return EN;
            }
            return ON;
        case ET:
            if (ix > 0 && classes[ix - 1] == EN) {
                return EN;
            }
            if (lastArabic) {
                return ON;
            }
            i = ix + 1;
            len = types.length;
            while (i < len && types[i] == ET) {
                i++;
            }
            if (i < len && types[i] == EN) {
                return EN;
            }
            return ON;
        case NSM:
            len = types.length;
            i = ix + 1;
            while (i < len && types[i] == NSM) {
                i++;
            }
            if (i < len) {
                var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
                wType = types[i];
                if (rtlCandidate && (wType == R || wType == AL)) {
                    return R;
                }
            }
            if (ix < 1 || (wType = types[ix - 1]) == B) {
                return ON;
            }
            return classes[ix - 1];
        case B:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
        case S:
            hasUBAT_S = true;
            return ON;
        case LRE:
        case RLE:
        case LRO:
        case RLO:
        case PDF:
            lastArabic = false;
        case BN:
            return ON;
    }
}
function _getCharacterType(ch) {
    var uc = ch.charCodeAt(0), hi = uc >> 8;
    if (hi == 0) {
        return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
    }
    else if (hi == 5) {
        return (/[\u0591-\u05f4]/.test(ch) ? R : L);
    }
    else if (hi == 6) {
        if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
            return NSM;
        else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
            return AN;
        else if (uc == 0x066A)
            return ET;
        else if (/[\u06f0-\u06f9]/.test(ch))
            return EN;
        else
            return AL;
    }
    else if (hi == 0x20 && uc <= 0x205F) {
        return UnicodeTBL20[uc & 0xFF];
    }
    else if (hi == 0xFE) {
        return (uc >= 0xFE70 ? AL : ON);
    }
    return ON;
}
function _isArabicDiacritics(ch) {
    return (ch >= '\u064b' && ch <= '\u0655');
}
exports.L = L;
exports.R = R;
exports.EN = EN;
exports.ON_R = 3;
exports.AN = 4;
exports.R_H = 5;
exports.B = 6;
exports.RLE = 7;
exports.DOT = "\xB7";
exports.doBidiReorder = function (text, textCharTypes, isRtl) {
    if (text.length < 2)
        return {};
    var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
    dir = isRtl ? RTL : LTR;
    _computeLevels(chars, levels, chars.length, textCharTypes);
    for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
        ;
    _invertLevel(2, levels, logicalFromVisual);
    _invertLevel(1, levels, logicalFromVisual);
    for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
        if (textCharTypes[i] === AN) {
            levels[i] = exports.AN;
        }
        else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE)
            || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
            levels[i] = exports.ON_R;
        }
        else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
            levels[i - 1] = levels[i] = exports.R_H;
            i++;
        }
    }
    if (chars[chars.length - 1] === exports.DOT)
        levels[chars.length - 1] = exports.B;
    if (chars[0] === '\u202B')
        levels[0] = exports.RLE;
    for (var i = 0; i < logicalFromVisual.length; i++) {
        bidiLevels[i] = levels[logicalFromVisual[i]];
    }
    return { 'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels };
};
exports.hasBidiCharacters = function (text, textCharTypes) {
    var ret = false;
    for (var i = 0; i < text.length; i++) {
        textCharTypes[i] = _getCharacterType(text.charAt(i));
        if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
            ret = true;
    }
    return ret;
};
exports.getVisualFromLogicalIdx = function (logIdx, rowMap) {
    for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
        if (rowMap.logicalFromVisual[i] == logIdx)
            return i;
    }
    return 0;
};

});

ace.define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang"], function(require, exports, module){"use strict";
var bidiUtil = require("./lib/bidiutil");
var lang = require("./lib/lang");
var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
var BidiHandler = function (session) {
    this.session = session;
    this.bidiMap = {};
    this.currentRow = null;
    this.bidiUtil = bidiUtil;
    this.charWidths = [];
    this.EOL = "\xAC";
    this.showInvisibles = true;
    this.isRtlDir = false;
    this.$isRtl = false;
    this.line = "";
    this.wrapIndent = 0;
    this.EOF = "\xB6";
    this.RLE = "\u202B";
    this.contentWidth = 0;
    this.fontMetrics = null;
    this.rtlLineOffset = 0;
    this.wrapOffset = 0;
    this.isMoveLeftOperation = false;
    this.seenBidi = bidiRE.test(session.getValue());
};
(function () {
    this.isBidiRow = function (screenRow, docRow, splitIndex) {
        if (!this.seenBidi)
            return false;
        if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
        }
        return this.bidiMap.bidiLevels;
    };
    this.onChange = function (delta) {
        if (!this.seenBidi) {
            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
            }
        }
        else {
            this.currentRow = null;
        }
    };
    this.getDocumentRow = function () {
        var docRow = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index >= 0)
                docRow = this.session.$docRowCache[index];
        }
        return docRow;
    };
    this.getSplitIndex = function () {
        var splitIndex = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                    break;
                prevIndex = currentIndex;
                splitIndex++;
            }
        }
        else {
            splitIndex = this.currentRow;
        }
        return splitIndex;
    };
    this.updateRowLine = function (docRow, splitIndex) {
        if (docRow === undefined)
            docRow = this.getDocumentRow();
        var isLastRow = (docRow === this.session.getLength() - 1), endOfLine = isLastRow ? this.EOF : this.EOL;
        this.wrapIndent = 0;
        this.line = this.session.getLine(docRow);
        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
        if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
                if (splitIndex === undefined)
                    splitIndex = this.getSplitIndex();
                if (splitIndex > 0 && splits.length) {
                    this.wrapIndent = splits.indent;
                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                    this.line = (splitIndex < splits.length) ?
                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :
                        this.line.substring(splits[splits.length - 1]);
                }
                else {
                    this.line = this.line.substring(0, splits[splitIndex]);
                }
                if (splitIndex == splits.length) {
                    this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;
                }
            }
        }
        else {
            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
        }
        var session = this.session, shift = 0, size;
        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function (ch, i) {
            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
        });
        if (this.isRtlDir) {
            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;
            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
        }
    };
    this.updateBidiMap = function () {
        var textCharTypes = [];
        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
            this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
        }
        else {
            this.bidiMap = {};
        }
    };
    this.markAsDirty = function () {
        this.currentRow = null;
    };
    this.updateCharacterWidths = function (fontMetrics) {
        if (this.characterWidth === fontMetrics.$characterSize.width)
            return;
        this.fontMetrics = fontMetrics;
        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
        var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");
        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
        this.currentRow = null;
    };
    this.setShowInvisibles = function (showInvisibles) {
        this.showInvisibles = showInvisibles;
        this.currentRow = null;
    };
    this.setEolChar = function (eolChar) {
        this.EOL = eolChar;
    };
    this.setContentWidth = function (width) {
        this.contentWidth = width;
    };
    this.isRtlLine = function (row) {
        if (this.$isRtl)
            return true;
        if (row != undefined)
            return (this.session.getLine(row).charAt(0) == this.RLE);
        else
            return this.isRtlDir;
    };
    this.setRtlDirection = function (editor, isRtlDir) {
        var cursor = editor.getCursorPosition();
        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({ column: 0, row: row }, editor.session.$bidiHandler.RLE);
        }
    };
    this.getPosLeft = function (col) {
        col -= this.wrapIndent;
        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;
        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;
        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
            visualIdx++;
        for (var i = 0; i < visualIdx; i++) {
            left += this.charWidths[levels[i]];
        }
        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))
            left += this.charWidths[levels[visualIdx]];
        if (this.wrapIndent)
            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        if (this.isRtlDir)
            left += this.rtlLineOffset;
        return left;
    };
    this.getSelections = function (startCol, endCol) {
        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
        if (this.wrapIndent)
            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
            if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
            }
            else if (!isSelected && isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
        }
        if (isSelected && (visIdx === levels.length)) {
            selections.push({ left: selectionStart, width: offset - selectionStart });
        }
        if (this.isRtlDir) {
            for (var i = 0; i < selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
            }
        }
        return selections;
    };
    this.offsetToCol = function (posX) {
        if (this.isRtlDir)
            posX -= this.rtlLineOffset;
        var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
        if (this.wrapIndent)
            posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;
        while (posX > offset + charWidth / 2) {
            offset += charWidth;
            if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
        }
        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)) {
            if (posX < offset)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }
        else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)) {
            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                : this.bidiMap.logicalFromVisual[visualIdx - 1]);
        }
        else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
            || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))) {
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
        }
        else {
            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }
        if (logicalIdx === 0 && this.isRtlDir)
            logicalIdx++;
        return (logicalIdx + this.wrapIndent);
    };
}).call(BidiHandler.prototype);
exports.BidiHandler = BidiHandler;

});

ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Selection = function (session) {
    this.session = session;
    this.doc = session.getDocument();
    this.clearSelection();
    this.cursor = this.lead = this.doc.createAnchor(0, 0);
    this.anchor = this.doc.createAnchor(0, 0);
    this.$silent = false;
    var self = this;
    this.cursor.on("change", function (e) {
        self.$cursorChanged = true;
        if (!self.$silent)
            self._emit("changeCursor");
        if (!self.$isEmpty && !self.$silent)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });
    this.anchor.on("change", function () {
        self.$anchorChanged = true;
        if (!self.$isEmpty && !self.$silent)
            self._emit("changeSelection");
    });
};
(function () {
    oop.implement(this, EventEmitter);
    this.isEmpty = function () {
        return this.$isEmpty || (this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column);
    };
    this.isMultiLine = function () {
        return !this.$isEmpty && this.anchor.row != this.cursor.row;
    };
    this.getCursor = function () {
        return this.lead.getPosition();
    };
    this.setAnchor = function (row, column) {
        this.$isEmpty = false;
        this.anchor.setPosition(row, column);
    };
    this.setSelectionAnchor = this.setAnchor;
    this.getAnchor = function () {
        if (this.$isEmpty)
            return this.getSelectionLead();
        return this.anchor.getPosition();
    };
    this.getSelectionAnchor = this.getAnchor;
    this.getSelectionLead = function () {
        return this.lead.getPosition();
    };
    this.isBackwards = function () {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };
    this.getRange = function () {
        var anchor = this.anchor;
        var lead = this.lead;
        if (this.$isEmpty)
            return Range.fromPoints(lead, lead);
        return this.isBackwards()
            ? Range.fromPoints(lead, anchor)
            : Range.fromPoints(anchor, lead);
    };
    this.clearSelection = function () {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };
    this.selectAll = function () {
        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
    };
    this.setRange =
        this.setSelectionRange = function (range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
        };
    this.$setSelection = function (anchorRow, anchorColumn, cursorRow, cursorColumn) {
        if (this.$silent)
            return;
        var wasEmpty = this.$isEmpty;
        var wasMultiselect = this.inMultiSelectMode;
        this.$silent = true;
        this.$cursorChanged = this.$anchorChanged = false;
        this.anchor.setPosition(anchorRow, anchorColumn);
        this.cursor.setPosition(cursorRow, cursorColumn);
        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
        this.$silent = false;
        if (this.$cursorChanged)
            this._emit("changeCursor");
        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
            this._emit("changeSelection");
    };
    this.$moveSelection = function (mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);
        mover.call(this);
    };
    this.selectTo = function (row, column) {
        this.$moveSelection(function () {
            this.moveCursorTo(row, column);
        });
    };
    this.selectToPosition = function (pos) {
        this.$moveSelection(function () {
            this.moveCursorToPosition(pos);
        });
    };
    this.moveTo = function (row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };
    this.moveToPosition = function (pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    };
    this.selectUp = function () {
        this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function () {
        this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function () {
        this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function () {
        this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function () {
        this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function () {
        this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function () {
        this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function () {
        this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function () {
        this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function () {
        this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function (row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };
    this.selectWord = function () {
        this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function () {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };
    this.getLineRange = function (row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;
        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        }
        else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function () {
        this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function () {
        this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function () {
        this.moveCursorBy(1, 0);
    };
    this.wouldMoveIntoSoftTab = function (cursor, tabSize, direction) {
        var start = cursor.column;
        var end = cursor.column + tabSize;
        if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
        }
        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
    };
    this.moveCursorLeft = function () {
        var cursor = this.lead.getPosition(), fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        }
        else if (cursor.column === 0) {
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
            }
            else {
                this.moveCursorBy(0, -1);
            }
        }
    };
    this.moveCursorRight = function () {
        var cursor = this.lead.getPosition(), fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
            }
            else {
                this.moveCursorBy(0, 1);
            }
        }
    };
    this.moveCursorLineStart = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function () {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }
        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function () {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function () {
        this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        if (this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        if (this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }
        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }
        var leftOfCursor = lang.stringReverse(str);
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }
        if (this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
    };
    this.$shortWordEndIndex = function (rightOfCursor) {
        var index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;
        tokenRe.lastIndex = 0;
        if (this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        }
        else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index++;
            if (index < 1) {
                tokenRe.lastIndex = 0;
                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        }
                        else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;
        return index;
    };
    this.moveCursorShortWordRight = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);
        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));
            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }
        var index = this.$shortWordEndIndex(rightOfCursor);
        this.moveCursorTo(row, column + index);
    };
    this.moveCursorShortWordLeft = function () {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);
        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));
            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }
        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);
        return this.moveCursorTo(row, column - index);
    };
    this.moveCursorWordRight = function () {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };
    this.moveCursorWordLeft = function () {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function (rows, chars) {
        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
        var offsetX;
        if (chars === 0) {
            if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                }
                else {
                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
            }
            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }
        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
            var widget = this.session.lineWidgets[this.lead.row];
            if (rows < 0)
                rows -= widget.rowsAbove || 0;
            else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
        }
        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function (position) {
        this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function (row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }
        this.$keepDesiredColumnOnChange = true;
        var line = this.session.getLine(row);
        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
            else
                column = column + 1;
        }
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;
        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function () {
        this.lead.detach();
        this.anchor.detach();
    };
    this.fromOrientedRange = function (range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };
    this.toOrientedRange = function (range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        }
        else {
            range = r;
        }
        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };
    this.getRangeOfMovements = function (func) {
        var start = this.getCursor();
        try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
        }
        catch (e) {
            return Range.fromPoints(start, start);
        }
        finally {
            this.moveCursorToPosition(start);
        }
    };
    this.toJSON = function () {
        if (this.rangeCount) {
            var data = this.ranges.map(function (r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        }
        else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };
    this.fromJSON = function (data) {
        if (data.start == undefined) {
            if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--;) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            }
            else {
                data = data[0];
            }
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };
    this.isEqual = function (data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);
        for (var i = this.ranges.length; i--;) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    };
}).call(Selection.prototype);
exports.Selection = Selection;

});

ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(require, exports, module){"use strict";
var config = require("./config");
var MAX_TOKEN_COUNT = 2000;
var Tokenizer = function (rules) {
    this.states = rules;
    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = { defaultToken: "text" };
        var flag = "g";
        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive && flag.indexOf("i") === -1)
                flag += "i";
            if (rule.unicode && flag.indexOf("u") === -1)
                flag += "u";
            if (rule.regex == null)
                continue;
            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                }
                else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                        rule: rule,
                        groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                }
                else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            }
            else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }
            if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                }
                else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule); // flag will be known only at the very end
            }
            mapping[matchTotal] = i;
            matchTotal += matchcount;
            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
                rule.onMatch = null;
        }
        if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
        }
        splitterRurles.forEach(function (rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);
        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
};
(function () {
    this.$setMaxTokenCount = function (m) {
        MAX_TOKEN_COUNT = m | 0;
    };
    this.$applyToken = function (str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === "string")
            return [{ type: types, value: str }];
        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    };
    this.$arrayTokens = function (str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };
    this.removeCapturingGroups = function (src) {
        var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function (x, y) { return y ? "(?:" : x; });
        return r;
    };
    this.createSplitterRegexp = function (src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                    inChClass = square != "]";
                }
                else if (square) {
                    inChClass = true;
                }
                else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index + 1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                }
                else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack;
                        lastCapture.start = index;
                    }
                }
                return m;
            });
            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        if (src.charAt(0) != "^")
            src = "^" + src;
        if (src.charAt(src.length - 1) != "$")
            src += "$";
        return new RegExp(src, (flag || "").replace("g", ""));
    };
    this.getLineTokens = function (line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
            }
        }
        else
            var stack = [];
        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;
        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;
        var token = { type: null, value: "" };
        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;
            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                }
                else {
                    if (token.type)
                        tokens.push(token);
                    token = { type: type, value: skipped };
                }
            }
            for (var i = 0; i < match.length - 2; i++) {
                if (match[i + 1] === undefined)
                    continue;
                rule = state[mapping[i]];
                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack, line);
                else
                    type = rule.token;
                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    }
                    else {
                        currentState = rule.next(currentState, stack);
                    }
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                    lastIndex = index;
                break;
            }
            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    }
                    else {
                        if (token.type)
                            tokens.push(token);
                        token = { type: type, value: value };
                    }
                }
                else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = { type: null, value: "" };
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }
            if (lastIndex == line.length)
                break;
            lastIndex = index;
            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 500),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }
        if (token.type)
            tokens.push(token);
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens: tokens,
            state: stack.length ? stack : currentState
        };
    };
    this.reportError = config.reportError;
}).call(Tokenizer.prototype);
exports.Tokenizer = Tokenizer;

});

ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(require, exports, module){"use strict";
var lang = require("../lib/lang");
var TextHighlightRules = function () {
    this.$rules = {
        "start": [{
                token: "empty_line",
                regex: '^$'
            }, {
                defaultToken: "text"
            }]
    };
};
(function () {
    this.addRules = function (rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next == "string") {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                        rule.nextState = prefix + rule.nextState;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };
    this.getRules = function () {
        return this.$rules;
    };
    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        }
        else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }
        this.addRules(embedRules, prefix);
        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }
        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };
    this.getEmbeds = function () {
        return this.$embeds;
    };
    var pushState = function (currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function (currentState, stack) {
        stack.shift();
        return stack.shift() || "start";
    };
    this.normalizeRules = function () {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                    toInsert = rule;
                    rule = {};
                }
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName) {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                }
                else if (next == "pop") {
                    rule.next = popState;
                }
                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }
                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        }
                        else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                var includeName = typeof rule == "string" ? rule : rule.include;
                if (includeName) {
                    if (Array.isArray(includeName))
                        toInsert = includeName.map(function (x) { return rules[x]; });
                    else
                        toInsert = rules[includeName];
                }
                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function (x) { return !x.next; });
                    state.splice.apply(state, args);
                    i--;
                }
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };
    this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        this.$keywordList = [];
        Object.keys(map).forEach(function (className) {
            var a = map[className];
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--;) {
                var word = list[i];
                this.$keywordList.push(word);
                if (ignoreCase)
                    word = word.toLowerCase();
                keywords[word] = className;
            }
        }, this);
        map = null;
        return ignoreCase
            ? function (value) { return keywords[value.toLowerCase()] || defaultToken; }
            : function (value) { return keywords[value] || defaultToken; };
    };
    this.getKeywords = function () {
        return this.$keywords;
    };
}).call(TextHighlightRules.prototype);
exports.TextHighlightRules = TextHighlightRules;

});

ace.define("ace/mode/behaviour",["require","exports","module"], function(require, exports, module){"use strict";
var Behaviour = function () {
    this.$behaviours = {};
};
(function () {
    this.add = function (name, action, callback) {
        switch (undefined) {
            case this.$behaviours:
                this.$behaviours = {};
            case this.$behaviours[name]:
                this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    };
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    };
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    };
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        }
        else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    };
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        }
        else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    };
}).call(Behaviour.prototype);
exports.Behaviour = Behaviour;

});

ace.define("ace/token_iterator",["require","exports","module","ace/range"], function(require, exports, module){"use strict";
var Range = require("./range").Range;
var TokenIterator = function (session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);
    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};
(function () {
    this.stepBackward = function () {
        this.$tokenIndex -= 1;
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
        return this.$rowTokens[this.$tokenIndex];
    };
    this.stepForward = function () {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
        return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };
    this.getCurrentTokenRow = function () {
        return this.$row;
    };
    this.getCurrentTokenColumn = function () {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        return column;
    };
    this.getCurrentTokenPosition = function () {
        return { row: this.$row, column: this.getCurrentTokenColumn() };
    };
    this.getCurrentTokenRange = function () {
        var token = this.$rowTokens[this.$tokenIndex];
        var column = this.getCurrentTokenColumn();
        return new Range(this.$row, column, this.$row, column + token.value.length);
    };
}).call(TokenIterator.prototype);
exports.TokenIterator = TokenIterator;

});

ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");
var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
var context;
var contextCache = {};
var defaultQuotes = { '"': '"', "'": "'" };
var initContext = function (editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = { rangeCount: editor.multiSelect.rangeCount };
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};
var getWrapped = function (selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
            0,
            selection.start.column + 1,
            rowDiff,
            selection.end.column + (rowDiff ? 0 : 1)
        ]
    };
};
var CstyleBehaviour = function (options) {
    this.add("braces", "insertion", function (state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            }
            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                }
                else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        }
        else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
        else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');
                if (!openBracePos)
                    return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            }
            else if (closing) {
                var next_indent = this.$getIndent(line);
            }
            else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();
            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        }
        else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });
    this.add("braces", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            }
            else {
                context.maybeInsertedBrackets--;
            }
        }
    });
    this.add("parens", "insertion", function (state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            }
            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        }
        else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });
    this.add("parens", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });
    this.add("brackets", "insertion", function (state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            }
            else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        }
        else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });
    this.add("brackets", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });
    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
                return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            }
            else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column - 1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;
                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                    if (pair && /string\.end/.test(rightToken.type))
                        pair = false;
                }
                else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(leftChar);
                    if (isWordBefore || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    var charBefore = line[cursor.column - 2];
                    if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
                        return null;
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1, 1]
                };
            }
        }
    });
    this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });
};
CstyleBehaviour.isSaneInsertion = function (editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};
CstyleBehaviour.$matchTokenType = function (token, types) {
    return types.indexOf(token.type || token) > -1;
};
CstyleBehaviour.recordAutoInsert = function (editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};
CstyleBehaviour.recordMaybeInsert = function (editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};
CstyleBehaviour.isAutoInsertedClosing = function (cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};
CstyleBehaviour.isMaybeInsertedClosing = function (cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};
CstyleBehaviour.popAutoInsertedClosing = function () {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};
CstyleBehaviour.clearMaybeInsertedClosing = function () {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};
oop.inherits(CstyleBehaviour, Behaviour);
exports.CstyleBehaviour = CstyleBehaviour;

});

ace.define("ace/unicode",["require","exports","module"], function(require, exports, module){"use strict";
var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
var code = 0;
var str = [];
for (var i = 0; i < wordChars.length; i += 2) {
    str.push(code += wordChars[i]);
    if (wordChars[i + 1])
        str.push(45, code += wordChars[i + 1]);
}
exports.wordChars = String.fromCharCode.apply(null, str);

});

ace.define("ace/mode/text",["require","exports","module","ace/config","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(require, exports, module){"use strict";
var config = require("../config");
var Tokenizer = require("../tokenizer").Tokenizer;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var unicode = require("../unicode");
var lang = require("../lib/lang");
var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;
var Mode = function () {
    this.HighlightRules = TextHighlightRules;
};
(function () {
    this.$defaultBehaviour = new CstyleBehaviour();
    this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
    this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
    this.getTokenizer = function () {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };
    this.lineCommentStart = "";
    this.blockComment = "";
    this.toggleCommentLines = function (state, session, startRow, endRow) {
        var doc = session.doc;
        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;
        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function (line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                    doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                }
            };
            var uncomment = function (line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function (line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === "comment")
                        return true;
                }
            };
        }
        else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
            }
            else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function (line, i) {
                var m = line.match(regexpStart);
                if (!m)
                    return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function (line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
                    else
                        doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                }
            };
            var testRemove = function (line, i) {
                return regexpStart.test(line);
            };
            var shouldInsertSpace = function (line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
            };
        }
        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }
        var minEmptyLength = Infinity;
        iter(function (line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            }
            else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });
        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }
        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
        iter(shouldRemove ? uncomment : comment);
    };
    this.toggleBlockComment = function (state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;
        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        }
        else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };
    this.getNextLineIndent = function (state, line, tab) {
        return this.$getIndent(line);
    };
    this.checkOutdent = function (state, line, input) {
        return false;
    };
    this.autoOutdent = function (state, doc, row) {
    };
    this.$getIndent = function (line) {
        return line.match(/^\s*/)[0];
    };
    this.createWorker = function (session) {
        return null;
    };
    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                var Mode = mapping[i];
                var id = Mode.prototype.$id;
                var mode = config.$modes[id];
                if (!mode)
                    config.$modes[id] = mode = new Mode();
                if (!config.$modes[i])
                    config.$modes[i] = mode;
                this.$embeds.push(i);
                this.$modes[i] = mode;
            }
        }
        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent",
            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];
        for (var i = 0; i < delegations.length; i++) {
            (function (scope) {
                var functionName = delegations[i];
                var defaultHandler = scope[functionName];
                scope[delegations[i]] = function () {
                    return this.$delegator(functionName, arguments, defaultHandler);
                };
            }(this));
        }
    };
    this.$delegator = function (method, args, defaultHandler) {
        var state = args[0] || "start";
        if (typeof state != "string") {
            if (Array.isArray(state[2])) {
                var language = state[2][state[2].length - 1];
                var mode = this.$modes[language];
                if (mode)
                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
        }
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]])
                continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };
    this.transformAction = function (state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };
    this.getKeywords = function (append) {
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };
    this.$createKeywordList = function () {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };
    this.getCompletions = function (state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function (word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };
    this.$id = "ace/mode/text";
}).call(Mode.prototype);
exports.Mode = Mode;

});

ace.define("ace/apply_delta",["require","exports","module"], function(require, exports, module){"use strict";
function throwDeltaError(delta, errorText) {
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}
function positionInDocument(docLines, position) {
    return position.row >= 0 && position.row < docLines.length &&
        position.column >= 0 && position.column <= docLines[position.row].length;
}
function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end)
        throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}
exports.applyDelta = function (docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            }
            else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            }
            else {
                docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
    }
};

});

ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Anchor = exports.Anchor = function (doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};
(function () {
    oop.implement(this, EventEmitter);
    this.getPosition = function () {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function () {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function (delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;
        if (delta.start.row > this.row)
            return;
        var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function (row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        }
        else {
            pos = this.$clipPositionToDocument(row, column);
        }
        if (this.row == pos.row && this.column == pos.column)
            return;
        var old = {
            row: this.row,
            column: this.column
        };
        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function () {
        this.document.off("change", this.$onChange);
    };
    this.attach = function (doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function (row, column) {
        var pos = {};
        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        if (column < 0)
            pos.column = 0;
        return pos;
    };
}).call(Anchor.prototype);

});

ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var applyDelta = require("./apply_delta").applyDelta;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;
var Document = function (textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
        this.$lines = [""];
    }
    else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
    }
    else {
        this.insert({ row: 0, column: 0 }, textOrLines);
    }
};
(function () {
    oop.implement(this, EventEmitter);
    this.setValue = function (text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({ row: 0, column: 0 }, text || "");
    };
    this.getValue = function () {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function (row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
        this.$split = function (text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    }
    else {
        this.$split = function (text) {
            return text.split(/\r\n|\r|\n/);
        };
    }
    this.$detectNewLine = function (text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function () {
        switch (this.$newLineMode) {
            case "windows":
                return "\r\n";
            case "unix":
                return "\n";
            default:
                return this.$autoNewLine || "\n";
        }
    };
    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function (newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;
        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function () {
        return this.$newLineMode;
    };
    this.isNewLine = function (text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function (row) {
        return this.$lines[row] || "";
    };
    this.getLines = function (firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function () {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function () {
        return this.$lines.length;
    };
    this.getTextRange = function (range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function (range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        }
        else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function (row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function (firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function (position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function (position, text) {
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function (position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        return this.clonePos(end);
    };
    this.clippedPos = function (row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        }
        else if (row < 0) {
            row = 0;
        }
        else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return { row: row, column: column };
    };
    this.clonePos = function (pos) {
        return { row: pos.row, column: pos.column };
    };
    this.pos = function (row, column) {
        return { row: row, column: column };
    };
    this.$clipPosition = function (position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        }
        else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function (row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
        }
        else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({ row: row, column: column }, lines);
    };
    this.insertMergedLines = function (position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        return this.clonePos(end);
    };
    this.remove = function (range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({ start: start, end: end })
        });
        return this.clonePos(start);
    };
    this.removeInLine = function (row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({ start: start, end: end })
        }, true);
        return this.clonePos(start);
    };
    this.removeFullLines = function (firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine = lastRow < this.getLength() - 1;
        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function (row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };
    this.replace = function (range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;
        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        return end;
    };
    this.applyDeltas = function (deltas) {
        for (var i = 0; i < deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function (deltas) {
        for (var i = deltas.length - 1; i >= 0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function (delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        if (isInsert && delta.lines.length > 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
        }
    };
    this.$safeApplyDelta = function (delta) {
        var docLength = this.$lines.length;
        if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength
            || delta.action == "insert" && delta.start.row <= docLength) {
            this.applyDelta(delta);
        }
    };
    this.$splitAndapplyLargeDelta = function (delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row;
        var column = delta.start.column;
        for (var from = 0, to = 0; from < l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    this.revertDelta = function (delta) {
        this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function (index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return { row: i, column: index + lines[i].length + newlineLength };
        }
        return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
    };
    this.positionToIndex = function (pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;
        return index + pos.column;
    };
}).call(Document.prototype);
exports.Document = Document;

});

ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var BackgroundTokenizer = function (tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;
    var self = this;
    this.$worker = function () {
        if (!self.running) {
            return;
        }
        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;
        var startLine = currentLine;
        while (self.lines[currentLine])
            currentLine++;
        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);
            processedLines++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                self.running = setTimeout(self.$worker, 20);
                break;
            }
        }
        self.currentLine = currentLine;
        if (endLine == -1)
            endLine = currentLine;
        if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};
(function () {
    oop.implement(this, EventEmitter);
    this.setTokenizer = function (tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];
        this.start(0);
    };
    this.setDocument = function (doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];
        this.stop();
    };
    this.fireUpdateEvent = function (firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", { data: data });
    };
    this.start = function (startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);
        this.stop();
        this.running = setTimeout(this.$worker, 700);
    };
    this.scheduleStart = function () {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    };
    this.$updateOnChange = function (delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;
        if (len === 0) {
            this.lines[startRow] = null;
        }
        else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        }
        else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }
        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
        this.stop();
    };
    this.stop = function () {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };
    this.getTokens = function (row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function (row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    };
    this.$tokenizeRow = function (row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];
        var data = this.tokenizer.getLineTokens(line, state, row);
        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        }
        else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }
        return this.lines[row] = data.tokens;
    };
    this.cleanup = function () {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.removeAllListeners();
    };
}).call(BackgroundTokenizer.prototype);
exports.BackgroundTokenizer = BackgroundTokenizer;

});

ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module){"use strict";
var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;
var SearchHighlight = function (regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
};
(function () {
    this.MAX_RANGES = 500;
    this.setRegexp = function (regExp) {
        if (this.regExp + "" == regExp + "")
            return;
        this.regExp = regExp;
        this.cache = [];
    };
    this.update = function (html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;
        var renderedMarkerRanges = {};
        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function (match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }
            for (var j = ranges.length; j--;) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString])
                    continue;
                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
            }
        }
    };
}).call(SearchHighlight.prototype);
exports.SearchHighlight = SearchHighlight;

});

ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(require, exports, module){"use strict";
var Range = require("../range").Range;
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    }
    else {
        folds = this.folds = [folds];
    }
    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
    this.start = this.range.start;
    this.end = this.range.end;
    this.folds.forEach(function (fold) {
        fold.setFoldLine(this);
    }, this);
}
(function () {
    this.shiftRow = function (shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function (fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    };
    this.addFold = function (fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function (a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
            }
            else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        }
        else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        }
        else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        }
        else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    };
    this.containsRow = function (row) {
        return row >= this.start.row && row <= this.end.row;
    };
    this.walk = function (callback, endRow, endColumn) {
        var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }
        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];
            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }
            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
                return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    };
    this.getNextFoldTo = function (row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            }
            else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    };
    this.addRemoveChars = function (row, column, len) {
        var ret = this.getNextFoldTo(row, column), fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row) {
                window.console && window.console.log(row, column, fold);
            }
            else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    };
    this.split = function (row, column) {
        var pos = this.getNextFoldTo(row, column);
        if (!pos || pos.kind == "inside")
            return null;
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);
        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    };
    this.merge = function (foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    };
    this.toString = function () {
        var ret = [this.range.toString() + ": ["];
        this.folds.forEach(function (fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    };
    this.idxToPosition = function (idx) {
        var lastFoldEndColumn = 0;
        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];
            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }
            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }
            lastFoldEndColumn = fold.end.column;
        }
        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    };
}).call(FoldLine.prototype);
exports.FoldLine = FoldLine;

});

ace.define("ace/range_list",["require","exports","module","ace/range"], function(require, exports, module){"use strict";
var Range = require("./range").Range;
var comparePoints = Range.comparePoints;
var RangeList = function () {
    this.ranges = [];
    this.$bias = 1;
};
(function () {
    this.comparePoints = comparePoints;
    this.pointIndex = function (pos, excludeEdges, startIndex) {
        var list = this.ranges;
        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;
            return -i - 1;
        }
        return -i - 1;
    };
    this.add = function (range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };
    this.addList = function (list) {
        var removed = [];
        for (var i = list.length; i--;) {
            removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
    };
    this.substractPoint = function (pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges.splice(i, 1);
    };
    this.merge = function () {
        var removed = [];
        var list = this.ranges;
        list = list.sort(function (a, b) {
            return comparePoints(a.start, b.start);
        });
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;
            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;
            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }
            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        this.ranges = list;
        return removed;
    };
    this.contains = function (row, column) {
        return this.pointIndex({ row: row, column: column }) >= 0;
    };
    this.containsPoint = function (pos) {
        return this.pointIndex(pos) >= 0;
    };
    this.rangeAtPoint = function (pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    };
    this.clipRows = function (startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];
        var startIndex = this.pointIndex({ row: startRow, column: 0 });
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;
        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };
    this.removeAll = function () {
        return this.ranges.splice(0, this.ranges.length);
    };
    this.attach = function (session) {
        if (this.session)
            this.detach();
        this.session = session;
        this.onChange = this.$onChange.bind(this);
        this.session.on('change', this.onChange);
    };
    this.detach = function () {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    };
    this.$onChange = function (delta) {
        var start = delta.start;
        var end = delta.end;
        var startRow = start.row;
        var endRow = end.row;
        var ranges = this.ranges;
        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row >= startRow)
                break;
        }
        if (delta.action == "insert") {
            var lineDif = endRow - startRow;
            var colDiff = -start.column + end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > startRow)
                    break;
                if (r.start.row == startRow && r.start.column >= start.column) {
                    if (r.start.column == start.column && this.$bias <= 0) {
                    }
                    else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                    if (r.end.column == start.column && this.$bias < 0) {
                        continue;
                    }
                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                        if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                            r.end.column -= colDiff;
                    }
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                }
            }
        }
        else {
            var lineDif = startRow - endRow;
            var colDiff = start.column - end.column;
            for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > endRow)
                    break;
                if (r.end.row < endRow
                    && (startRow < r.end.row
                        || startRow == r.end.row && start.column < r.end.column)) {
                    r.end.row = startRow;
                    r.end.column = start.column;
                }
                else if (r.end.row == endRow) {
                    if (r.end.column <= end.column) {
                        if (lineDif || r.end.column > start.column) {
                            r.end.column = start.column;
                            r.end.row = start.row;
                        }
                    }
                    else {
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
                else if (r.end.row > endRow) {
                    r.end.row += lineDif;
                }
                if (r.start.row < endRow
                    && (startRow < r.start.row
                        || startRow == r.start.row && start.column < r.start.column)) {
                    r.start.row = startRow;
                    r.start.column = start.column;
                }
                else if (r.start.row == endRow) {
                    if (r.start.column <= end.column) {
                        if (lineDif || r.start.column > start.column) {
                            r.start.column = start.column;
                            r.start.row = start.row;
                        }
                    }
                    else {
                        r.start.column += colDiff;
                        r.start.row += lineDif;
                    }
                }
                else if (r.start.row > endRow) {
                    r.start.row += lineDif;
                }
            }
        }
        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };
}).call(RangeList.prototype);
exports.RangeList = RangeList;

});

ace.define("ace/edit_session/fold",["require","exports","module","ace/range_list","ace/lib/oop"], function(require, exports, module){"use strict";
var RangeList = require("../range_list").RangeList;
var oop = require("../lib/oop");
var Fold = exports.Fold = function (range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;
    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};
oop.inherits(Fold, RangeList);
(function () {
    this.toString = function () {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };
    this.setFoldLine = function (foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function (fold) {
            fold.setFoldLine(foldLine);
        });
    };
    this.clone = function () {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function (subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };
    this.addSubFold = function (fold) {
        if (this.range.isEqual(fold))
            return;
        consumeRange(fold, this.start);
        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];
        var firstConsumed = 0;
        if (cmp == 0) {
            if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
            else
                firstConsumed = 1;
        }
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        if (cmp == 0)
            j++;
        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
        for (var k = firstConsumed; k < last; k++) {
            fold.addSubFold(consumedFolds[k]);
        }
        fold.setFoldLine(this.foldLine);
        return fold;
    };
    this.restoreRange = function (range) {
        return restoreRange(range, this.start);
    };
}).call(Fold.prototype);
function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(require, exports, module){"use strict";
var Range = require("../range").Range;
var FoldLine = require("./fold_line").FoldLine;
var Fold = require("./fold").Fold;
var TokenIterator = require("../token_iterator").TokenIterator;
function Folding() {
    this.getFoldAt = function (row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;
        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                    continue;
                }
                else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                    continue;
                }
                return folds[i];
            }
        }
    };
    this.getFoldsInRange = function (range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];
        start.column += 1;
        end.column -= 1;
        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                continue;
            }
            else if (cmp == -2) {
                break;
            }
            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                }
                else if (cmp == 2) {
                    continue;
                }
                else 
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;
        return foundFolds;
    };
    this.getFoldsInRangeList = function (ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function (range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        }
        else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    };
    this.getAllFolds = function () {
        var folds = [];
        var foldLines = this.$foldData;
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);
        return folds;
    };
    this.getFoldStringAt = function (row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;
        var lastFold = {
            end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };
    this.getFoldLine = function (docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            }
            else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };
    this.getNextFoldLine = function (docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };
    this.getFoldedRowCount = function (first, last) {
        var foldData = this.$foldData, rowCount = last - first + 1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
            if (end >= last) {
                if (start < last) {
                    if (start >= first)
                        rowCount -= last - start;
                    else
                        rowCount = 0; // in one fold
                }
                break;
            }
            else if (end >= first) {
                if (start >= first) // fold inside range
                    rowCount -= end - start;
                else
                    rowCount -= end - first + 1;
            }
        }
        return rowCount;
    };
    this.$addFoldLine = function (foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function (a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };
    this.addFold = function (placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);
        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);
        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            this.removeFolds(folds);
            if (!fold.collapseChildren) {
                folds.forEach(function (subFold) {
                    fold.addSubFold(subFold);
                });
            }
        }
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            }
            else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            }
            else if (endRow <= foldLine.start.row) {
                break;
            }
        }
        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "add" });
        return fold;
    };
    this.addFolds = function (folds) {
        folds.forEach(function (fold) {
            this.addFold(fold);
        }, this);
    };
    this.removeFold = function (fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;
        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        }
        else 
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        }
        else 
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        }
        else 
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        }
        else 
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }
        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "remove" });
    };
    this.removeFolds = function (folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }
        cloneFolds.forEach(function (fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };
    this.expandFold = function (fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function (subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
        }
        fold.subFolds = [];
    };
    this.expandFolds = function (folds) {
        folds.forEach(function (fold) {
            this.expandFold(fold);
        }, this);
    };
    this.unfold = function (location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null)
                expandInner = true;
        }
        else if (typeof location == "number") {
            range = new Range(location, 0, location, this.getLine(location).length);
        }
        else if ("row" in location) {
            range = Range.fromPoints(location, location);
        }
        else if (Array.isArray(location)) {
            folds = [];
            location.forEach(function (range) {
                folds = folds.concat(this.unfold(range));
            }, this);
            return folds;
        }
        else {
            range = location;
        }
        folds = this.getFoldsInRangeList(range);
        var outermostFolds = folds;
        while (folds.length == 1
            && Range.comparePoints(folds[0].start, range.start) < 0
            && Range.comparePoints(folds[0].end, range.end) > 0) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
        }
        if (expandInner != false) {
            this.removeFolds(folds);
        }
        else {
            this.expandFolds(folds);
        }
        if (outermostFolds.length)
            return outermostFolds;
    };
    this.isRowFolded = function (docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };
    this.getRowFoldEnd = function (docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };
    this.getRowFoldStart = function (docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };
    this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = "";
        foldLine.walk(function (placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
                textLine += placeholder;
            }
            else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };
    this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        }
        else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
        }
    };
    this.$cloneFoldData = function () {
        var fd = [];
        fd = this.$foldData.map(function (foldLine) {
            var folds = foldLine.folds.map(function (fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });
        return fd;
    };
    this.toggleFold = function (tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;
        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
                this.expandFold(fold);
                return;
            }
            else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                }
                else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            }
            else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;
                range.start.column++;
            }
            else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        }
        else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            }
            else if (folds.length == 1) {
                fold = folds[0];
            }
        }
        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }
        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }
        this.addFold(placeholder, range);
    };
    this.getCommentFoldRange = function (row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type = token && token.type;
        if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
                type += "|doc-start";
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token && re.test(token.type) && !/^comment.end/.test(token.type));
                token = iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + (/^comment.start/.test(token.type) ? token.value.length : 2);
            iterator = new TokenIterator(this, row, column);
            if (dir != -1) {
                var lastRow = -1;
                do {
                    token = iterator.stepForward();
                    if (lastRow == -1) {
                        var state = this.getState(iterator.$row);
                        if (!re.test(state))
                            lastRow = iterator.$row;
                    }
                    else if (iterator.$row > lastRow) {
                        break;
                    }
                } while (token && re.test(token.type) && !/^comment.start/.test(token.type));
                token = iterator.stepBackward();
            }
            else
                token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            if (!/^comment.end/.test(token.type)) {
                range.end.column += token.value.length - 2;
            }
            return range;
        }
    };
    this.foldAll = function (startRow, endRow, depth, test) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;
            if (test && !test(row))
                continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow) {
                row = range.end.row;
                range.collapseChildren = depth;
                this.addFold("...", range);
            }
        }
    };
    this.foldToLevel = function (level) {
        this.foldAll();
        while (level-- > 0)
            this.unfold(null, false);
    };
    this.foldAllComments = function () {
        var session = this;
        this.foldAll(null, null, null, function (row) {
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token.type == "text" && /^\s+$/.test(token.value))
                    continue;
                if (/comment/.test(token.type))
                    return true;
                return false;
            }
        });
    };
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function (style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        if (this.$foldStyle == style)
            return;
        this.$foldStyle = style;
        if (style == "manual")
            this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };
    this.$setFolding = function (foldMode) {
        if (this.$foldMode == foldMode)
            return;
        this.$foldMode = foldMode;
        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };
    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};
        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);
            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }
        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    };
    this.onFoldWidgetClick = function (row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };
    this.$toggleFoldWidget = function (row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);
        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return fold;
        }
        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
            }
        }
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        }
        else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        }
        else if (range) {
            if (options.all)
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        return range;
    };
    this.toggleFoldWidget = function (toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        if (range)
            return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
                this.removeFold(fold);
            }
            else {
                this.addFold("...", range);
            }
        }
    };
    this.updateFoldWidgets = function (delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        }
        else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
        }
        else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    this.tokenizerUpdateFoldWidgets = function (e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    };
}
exports.Folding = Folding;

});

ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(require, exports, module){"use strict";
var TokenIterator = require("../token_iterator").TokenIterator;
var Range = require("../range").Range;
function BracketMatch() {
    this.findMatchingBracket = function (position, chr) {
        if (position.column == 0)
            return null;
        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
        if (charBeforeCursor == "")
            return null;
        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;
        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };
    this.getBracketRange = function (pos) {
        var line = this.getLine(pos.row);
        var before = true, range;
        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = { row: pos.row, column: pos.column + 1 };
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;
        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        }
        else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        return range;
    };
    this.getMatchingBracketRanges = function (pos, isBackwards) {
        var line = this.getLine(pos.row);
        var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
        var chr = !isBackwards && line.charAt(pos.column - 1);
        var match = chr && chr.match(bracketsRegExp);
        if (!match) {
            chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);
            pos = {
                row: pos.row,
                column: pos.column + 1
            };
            match = chr && chr.match(bracketsRegExp);
        }
        if (!match)
            return null;
        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)
            : this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
            return [startRange];
        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
        return [startRange, endRange];
    };
    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{",
        "<": ">",
        ">": "<"
    };
    this.$findOpeningBracket = function (bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        if (!typeRe) {
            typeRe = new RegExp("(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        while (true) {
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return { row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn() };
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
                break;
            value = token.value;
            valueIndex = value.length - 1;
        }
        return null;
    };
    this.$findClosingBracket = function (bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        if (!typeRe) {
            typeRe = new RegExp("(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();
        while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return { row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn() };
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
                break;
            valueIndex = 0;
        }
        return null;
    };
    this.getMatchingTags = function (pos) {
        var iterator = new TokenIterator(this, pos.row, pos.column);
        var token = this.$findTagName(iterator);
        if (!token)
            return;
        var prevToken = iterator.stepBackward();
        if (prevToken.value === '<') {
            return this.$findClosingTag(iterator, token);
        }
        else {
            return this.$findOpeningTag(iterator, token);
        }
    };
    this.$findTagName = function (iterator) {
        var token = iterator.getCurrentToken();
        var found = false;
        var backward = false;
        if (token && token.type.indexOf('tag-name') === -1) {
            do {
                if (backward)
                    token = iterator.stepBackward();
                else
                    token = iterator.stepForward();
                if (token) {
                    if (token.value === "/>") {
                        backward = true;
                    }
                    else if (token.type.indexOf('tag-name') !== -1) {
                        found = true;
                    }
                }
            } while (token && !found);
        }
        return token;
    };
    this.$findClosingTag = function (iterator, token) {
        var prevToken;
        var currentTag = token.value;
        var tag = token.value;
        var depth = 0;
        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
        token = iterator.stepForward();
        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
        var foundOpenTagEnd = false;
        do {
            prevToken = token;
            token = iterator.stepForward();
            if (token) {
                if (token.value === '>' && !foundOpenTagEnd) {
                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`
                    foundOpenTagEnd = true;
                }
                if (token.type.indexOf('tag-name') !== -1) {
                    currentTag = token.value;
                    if (tag === currentTag) {
                        if (prevToken.value === '<') {
                            depth++;
                        }
                        else if (prevToken.value === '</') {
                            depth--;
                            if (depth < 0) { //found closing tag
                                iterator.stepBackward();
                                var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2); //Range for </
                                token = iterator.stepForward();
                                var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                                token = iterator.stepForward();
                                if (token && token.value === '>') {
                                    var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
                                }
                                else {
                                    return;
                                }
                            }
                        }
                    }
                }
                else if (tag === currentTag && token.value === '/>') { // self-closing tag
                    depth--;
                    if (depth < 0) { //found self-closing tag end
                        var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                        var closeTagName = closeTagStart;
                        var closeTagEnd = closeTagName;
                        var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                    }
                }
            }
        } while (token && depth >= 0);
        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };
    this.$findOpeningTag = function (iterator, token) {
        var prevToken = iterator.getCurrentToken();
        var tag = token.value;
        var depth = 0;
        var startRow = iterator.getCurrentTokenRow();
        var startColumn = iterator.getCurrentTokenColumn();
        var endColumn = startColumn + 2;
        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </
        iterator.stepForward();
        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
        token = iterator.stepForward();
        if (!token || token.value !== ">")
            return;
        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
        iterator.stepBackward();
        iterator.stepBackward();
        do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;
            prevToken = iterator.stepBackward();
            if (token) {
                if (token.type.indexOf('tag-name') !== -1) {
                    if (tag === token.value) {
                        if (prevToken.value === '<') {
                            depth++;
                            if (depth > 0) { //found opening tag
                                var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                                var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for <
                                do {
                                    token = iterator.stepForward();
                                } while (token && token.value !== '>');
                                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
                            }
                        }
                        else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                }
                else if (token.value === '/>') { // self-closing tag
                    var stepCount = 0;
                    var tmpToken = prevToken;
                    while (tmpToken) {
                        if (tmpToken.type.indexOf('tag-name') !== -1 && tmpToken.value === tag) {
                            depth--;
                            break;
                        }
                        else if (tmpToken.value === '<') {
                            break;
                        }
                        tmpToken = iterator.stepBackward();
                        stepCount++;
                    }
                    for (var i = 0; i < stepCount; i++) {
                        iterator.stepForward();
                    }
                }
            }
        } while (prevToken && depth <= 0);
        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        }
    };
}
exports.BracketMatch = BracketMatch;

});

ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var lang = require("./lib/lang");
var BidiHandler = require("./bidihandler").BidiHandler;
var config = require("./config");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Selection = require("./selection").Selection;
var TextMode = require("./mode/text").Mode;
var Range = require("./range").Range;
var Document = require("./document").Document;
var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
var SearchHighlight = require("./search_highlight").SearchHighlight;
var EditSession = function (text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;
    this.$foldData = [];
    this.id = "session" + (++EditSession.$uid);
    this.$foldData.toString = function () {
        return this.join("\n");
    };
    this.bgTokenizer = new BackgroundTokenizer((new TextMode()).getTokenizer(), this);
    var _self = this;
    this.bgTokenizer.on("update", function (e) {
        _self._signal("tokenizerUpdate", e);
    });
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);
    if (typeof text != "object" || !text.getLine)
        text = new Document(text);
    this.setDocument(text);
    this.selection = new Selection(this);
    this.$bidiHandler = new BidiHandler(this);
    config.resetOptions(this);
    this.setMode(mode);
    config._signal("session", this);
    this.destroyed = false;
};
EditSession.$uid = 0;
(function () {
    oop.implement(this, EventEmitter);
    this.setDocument = function (doc) {
        if (this.doc)
            this.doc.off("change", this.$onChange);
        this.doc = doc;
        doc.on("change", this.$onChange, true);
        this.bgTokenizer.setDocument(this.getDocument());
        this.resetCaches();
    };
    this.getDocument = function () {
        return this.doc;
    };
    this.$resetRowCache = function (docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };
    this.$getRowCacheIndex = function (cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;
        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];
            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }
        return low - 1;
    };
    this.resetCaches = function () {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (!this.destroyed)
            this.bgTokenizer.start(0);
    };
    this.onChangeFold = function (e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };
    this.onChange = function (delta) {
        this.$modified = true;
        this.$bidiHandler.onChange(delta);
        this.$resetRowCache(delta.start.row);
        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager) {
            if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                    action: "removeFolds",
                    folds: removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
            }
            this.$undoManager.add(delta, this.mergeUndoDeltas);
            this.mergeUndoDeltas = true;
            this.$informUndoManager.schedule();
        }
        this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
    };
    this.setValue = function (text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);
        this.$resetRowCache(0);
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    };
    this.getValue =
        this.toString = function () {
            return this.doc.getValue();
        };
    this.getSelection = function () {
        return this.selection;
    };
    this.getState = function (row) {
        return this.bgTokenizer.getState(row);
    };
    this.getTokens = function (row) {
        return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function (row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
        }
        else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };
    this.setUndoManager = function (undoManager) {
        this.$undoManager = undoManager;
        if (this.$informUndoManager)
            this.$informUndoManager.cancel();
        if (undoManager) {
            var self = this;
            undoManager.addSession(this);
            this.$syncInformUndoManager = function () {
                self.$informUndoManager.cancel();
                self.mergeUndoDeltas = false;
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        }
        else {
            this.$syncInformUndoManager = function () { };
        }
    };
    this.markUndoGroup = function () {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };
    this.$defaultUndoManager = {
        undo: function () { },
        redo: function () { },
        hasUndo: function () { },
        hasRedo: function () { },
        reset: function () { },
        add: function () { },
        addSelection: function () { },
        startNewGroup: function () { },
        addSession: function () { }
    };
    this.getUndoManager = function () {
        return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function () {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        }
        else {
            return "\t";
        }
    };
    this.setUseSoftTabs = function (val) {
        this.setOption("useSoftTabs", val);
    };
    this.getUseSoftTabs = function () {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function (tabSize) {
        this.setOption("tabSize", tabSize);
    };
    this.getTabSize = function () {
        return this.$tabSize;
    };
    this.isTabStop = function (position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    };
    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
    };
    this.getNavigateWithinSoftTabs = function () {
        return this.$navigateWithinSoftTabs;
    };
    this.$overwrite = false;
    this.setOverwrite = function (overwrite) {
        this.setOption("overwrite", overwrite);
    };
    this.getOverwrite = function () {
        return this.$overwrite;
    };
    this.toggleOverwrite = function () {
        this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function (row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    };
    this.removeGutterDecoration = function (row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    };
    this.getBreakpoints = function () {
        return this.$breakpoints;
    };
    this.setBreakpoints = function (rows) {
        this.$breakpoints = [];
        for (var i = 0; i < rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoints = function () {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    };
    this.setBreakpoint = function (row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoint = function (row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.addMarker = function (range, clazz, type, inFront) {
        var id = this.$markerId++;
        var marker = {
            range: range,
            type: type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz: clazz,
            inFront: !!inFront,
            id: id
        };
        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        }
        else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }
        return id;
    };
    this.addDynamicMarker = function (marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;
        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        }
        else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }
        return marker;
    };
    this.removeMarker = function (markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;
        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        delete (markers[markerId]);
        this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
    };
    this.getMarkers = function (inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };
    this.highlight = function (re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function (startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";
        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    };
    this.setAnnotations = function (annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    };
    this.getAnnotations = function () {
        return this.$annotations || [];
    };
    this.clearAnnotations = function () {
        this.setAnnotations([]);
    };
    this.$detectNewLine = function (text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        }
        else {
            this.$autoNewLine = "\n";
        }
    };
    this.getWordRange = function (row, column) {
        var line = this.getLine(row);
        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);
        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);
        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;
        var start = column;
        if (start > 0) {
            do {
                start--;
            } while (start >= 0 && line.charAt(start).match(re));
            start++;
        }
        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }
        return new Range(row, start, row, end);
    };
    this.getAWordRange = function (row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);
        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };
    this.setNewLineMode = function (newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function () {
        return this.doc.getNewLineMode();
    };
    this.setUseWorker = function (useWorker) { this.setOption("useWorker", useWorker); };
    this.getUseWorker = function () { return this.$useWorker; };
    this.onReloadTokenizer = function (e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    };
    this.$modes = config.$modes;
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function (mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        }
        else {
            path = mode || "ace/mode/text";
        }
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();
        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        this.$modeId = path;
        config.loadModule(["mode", path], function (m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            }
            else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };
    this.$onChangeMode = function (mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode)
            return;
        var oldMode = this.$mode;
        this.$mode = mode;
        this.$stopWorker();
        if (this.$useWorker)
            this.$startWorker();
        var tokenizer = mode.getTokenizer();
        if (tokenizer.on !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.on("update", onReloadTokenizer);
        }
        this.bgTokenizer.setTokenizer(tokenizer);
        this.bgTokenizer.setDocument(this.getDocument());
        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;
        if (!$isPlaceholder) {
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode", { oldMode: oldMode, mode: mode });
        }
    };
    this.$stopWorker = function () {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    };
    this.$startWorker = function () {
        try {
            this.$worker = this.$mode.createWorker(this);
        }
        catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    };
    this.getMode = function () {
        return this.$mode;
    };
    this.$scrollTop = 0;
    this.setScrollTop = function (scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;
        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    };
    this.getScrollTop = function () {
        return this.$scrollTop;
    };
    this.$scrollLeft = 0;
    this.setScrollLeft = function (scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;
        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    };
    this.getScrollLeft = function () {
        return this.$scrollLeft;
    };
    this.getScreenWidth = function () {
        this.$computeWidth();
        if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };
    this.getLineWidgetMaxWidth = function () {
        if (this.lineWidgetsWidth != null)
            return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function (w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    };
    this.$computeWidth = function (force) {
        if (this.$modified || force) {
            this.$modified = false;
            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;
            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];
                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };
    this.getLine = function (row) {
        return this.doc.getLine(row);
    };
    this.getLines = function (firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function () {
        return this.doc.getLength();
    };
    this.getTextRange = function (range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function (position, text) {
        return this.doc.insert(position, text);
    };
    this.remove = function (range) {
        return this.doc.remove(range);
    };
    this.removeFullLines = function (firstRow, lastRow) {
        return this.doc.removeFullLines(firstRow, lastRow);
    };
    this.undoChanges = function (deltas, dontSelect) {
        if (!deltas.length)
            return;
        this.$fromUndo = true;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
            }
            else if (delta.folds) {
                this.addFolds(delta.folds);
            }
        }
        if (!dontSelect && this.$undoSelect) {
            if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
        }
        this.$fromUndo = false;
    };
    this.redoChanges = function (deltas, dontSelect) {
        if (!deltas.length)
            return;
        this.$fromUndo = true;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
            }
        }
        if (!dontSelect && this.$undoSelect) {
            if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
            else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
        }
        this.$fromUndo = false;
    };
    this.setUndoSelect = function (enable) {
        this.$undoSelect = enable;
    };
    this.$getUndoSelection = function (deltas, isUndo) {
        function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }
        var range, point;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (!delta.start)
                continue; // skip folds
            if (!range) {
                if (isInsert(delta)) {
                    range = Range.fromPoints(delta.start, delta.end);
                }
                else {
                    range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
            }
            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
            }
            else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
            }
        }
        return range;
    };
    this.replace = function (range, text) {
        return this.doc.replace(range, text);
    };
    this.moveText = function (fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);
        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }
        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function (x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }
        return toRange;
    };
    this.indentRows = function (startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row = startRow; row <= endRow; row++)
            this.doc.insertInLine({ row: row, column: 0 }, indentString);
    };
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();
        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            }
            else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };
    this.$moveLines = function (firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0)
                return 0;
            var diff = row - firstRow;
        }
        else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength() - 1)
                return 0;
            var diff = row - lastRow;
        }
        else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }
        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function (x) {
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });
        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow + diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    };
    this.moveLinesUp = function (firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function (firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function (firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };
    this.$clipRowToDocument = function (row) {
        return Math.max(0, Math.min(row, this.doc.getLength() - 1));
    };
    this.$clipColumnToRow = function (row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };
    this.$clipPositionToDocument = function (row, column) {
        column = Math.max(0, column);
        if (row < 0) {
            row = 0;
            column = 0;
        }
        else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
            }
            else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }
        return {
            row: row,
            column: column
        };
    };
    this.$clipRangeToDocument = function (range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        }
        else {
            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
        }
        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        }
        else {
            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
        }
        return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min: null,
        max: null
    };
    this.setUseWrapMode = function (useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }
            this._signal("changeWrapMode");
        }
    };
    this.getUseWrapMode = function () {
        return this.$useWrapMode;
    };
    this.setWrapLimitRange = function (min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    };
    this.adjustWrapLimit = function (desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = { min: $printMargin, max: $printMargin };
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    };
    this.$constrainWrapLimit = function (wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);
        if (max)
            wrapLimit = Math.min(max, wrapLimit);
        return wrapLimit;
    };
    this.getWrapLimit = function () {
        return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function () {
        return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
        };
    };
    this.$updateInternalDataOnChange = function (delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;
        this.$updating = true;
        if (len != 0) {
            if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);
                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }
                lastRow = firstRow;
            }
            else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    }
                    else 
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        }
        else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }
        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;
        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);
        return removedFolds;
    };
    this.$updateRowLengthCache = function (firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };
    this.$updateWrapData = function (firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;
        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
            }
            else {
                tokens = [];
                foldLine.walk(function (placeholder, row, column, lastColumn) {
                    var walkTokens;
                    if (placeholder != null) {
                        walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                        walkTokens[0] = PLACEHOLDER_START;
                        for (var i = 1; i < walkTokens.length; i++) {
                            walkTokens[i] = PLACEHOLDER_BODY;
                        }
                    }
                    else {
                        walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                    }
                    tokens = tokens.concat(walkTokens);
                }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };
    var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
    this.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }
        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;
        var isCode = this.$wrapAsCode;
        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            var len = screenPos - lastSplit;
            for (var i = lastSplit; i < screenPos; i++) {
                var ch = tokens[i];
                if (ch === 12 || ch === 2)
                    len -= 1;
            }
            if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        break;
                    }
                }
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }
                if (split == tokens.length) {
                    break; // Breaks the while-loop.
                }
                addSplit(split);
                continue;
            }
            var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split--;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split--;
                }
            }
            else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split--;
                }
            }
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    };
    this.$getDisplayTokens = function (str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;
        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            else if (c == 32) {
                arr.push(SPACE);
            }
            else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            }
            else {
                arr.push(CHAR);
            }
        }
        return arr;
    };
    this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;
        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            }
            else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }
        return [screenColumn, column];
    };
    this.lineWidgets = null;
    this.getRowLength = function (row) {
        var h = 1;
        if (this.lineWidgets)
            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        if (!this.$useWrapMode || !this.$wrapData[row])
            return h;
        else
            return this.$wrapData[row].length + h;
    };
    this.getRowLineCount = function (row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        }
        else {
            return this.$wrapData[row].length + 1;
        }
    };
    this.getRowWrapIndent = function (screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
        }
        else {
            return 0;
        }
    };
    this.getScreenLastRowColumn = function (screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function (docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function (row) {
        if (!this.$useWrapMode) {
            return undefined;
        }
        else {
            return this.$wrapData[row];
        }
    };
    this.getScreenTabSize = function (screenColumn) {
        return this.$tabSize - (screenColumn % this.$tabSize | 0);
    };
    this.screenToDocumentRow = function (screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };
    this.screenToDocumentColumn = function (screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function (screenRow, screenColumn, offsetX) {
        if (screenRow < 0)
            return { row: 0, column: 0 };
        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;
        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        }
        else {
            var doCache = !l;
        }
        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            }
            else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row + 1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }
            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }
        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        }
        else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        }
        else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                column = splits[splitIndex];
                if (splitIndex > 0 && splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }
        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
            screenColumn = this.$bidiHandler.offsetToCol(offsetX);
        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;
        if (foldLine)
            return foldLine.idxToPosition(docColumn);
        return { row: docRow, column: docColumn };
    };
    this.documentToScreenPosition = function (docRow, docColumn) {
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);
        docRow = pos.row;
        docColumn = pos.column;
        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }
        var rowEnd, row = 0;
        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        }
        else {
            var doCache = !l;
        }
        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            else {
                rowEnd = row + 1;
            }
            screenRow += this.getRowLength(row);
            row = rowEnd;
            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }
        var textLine = "";
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        }
        else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
        }
        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
            screenRow += this.lineWidgets[row].rowsAbove;
        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    };
    this.documentToScreenColumn = function (row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function (docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function () {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        }
        else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row : Infinity;
            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row > foldStart) {
                    row = fold.end.row + 1;
                    fold = this.$foldData[i++];
                    foldStart = fold ? fold.start.row : Infinity;
                }
            }
        }
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();
        return screenRows;
    };
    this.$setFontMetrics = function (fm) {
        if (!this.$enableVarChar)
            return;
        this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
                return [0, 0];
            if (!maxScreenColumn)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                if (c === "\t") {
                    screenColumn += this.getScreenTabSize(screenColumn);
                }
                else {
                    screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }
            return [screenColumn, column];
        };
    };
    this.destroy = function () {
        if (!this.destroyed) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer.cleanup();
            this.destroyed = true;
        }
        this.$stopWorker();
        this.removeAllListeners();
        if (this.doc) {
            this.doc.off("change", this.$onChange);
        }
        this.selection.detach();
    };
    this.isFullWidth = isFullWidth;
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
            c >= 0x11A3 && c <= 0x11A7 ||
            c >= 0x11FA && c <= 0x11FF ||
            c >= 0x2329 && c <= 0x232A ||
            c >= 0x2E80 && c <= 0x2E99 ||
            c >= 0x2E9B && c <= 0x2EF3 ||
            c >= 0x2F00 && c <= 0x2FD5 ||
            c >= 0x2FF0 && c <= 0x2FFB ||
            c >= 0x3000 && c <= 0x303E ||
            c >= 0x3041 && c <= 0x3096 ||
            c >= 0x3099 && c <= 0x30FF ||
            c >= 0x3105 && c <= 0x312D ||
            c >= 0x3131 && c <= 0x318E ||
            c >= 0x3190 && c <= 0x31BA ||
            c >= 0x31C0 && c <= 0x31E3 ||
            c >= 0x31F0 && c <= 0x321E ||
            c >= 0x3220 && c <= 0x3247 ||
            c >= 0x3250 && c <= 0x32FE ||
            c >= 0x3300 && c <= 0x4DBF ||
            c >= 0x4E00 && c <= 0xA48C ||
            c >= 0xA490 && c <= 0xA4C6 ||
            c >= 0xA960 && c <= 0xA97C ||
            c >= 0xAC00 && c <= 0xD7A3 ||
            c >= 0xD7B0 && c <= 0xD7C6 ||
            c >= 0xD7CB && c <= 0xD7FB ||
            c >= 0xF900 && c <= 0xFAFF ||
            c >= 0xFE10 && c <= 0xFE19 ||
            c >= 0xFE30 && c <= 0xFE52 ||
            c >= 0xFE54 && c <= 0xFE66 ||
            c >= 0xFE68 && c <= 0xFE6B ||
            c >= 0xFF01 && c <= 0xFF60 ||
            c >= 0xFFE0 && c <= 0xFFE6;
    }
}).call(EditSession.prototype);
require("./edit_session/folding").Folding.call(EditSession.prototype);
require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        set: function (value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;
            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            }
            else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function () {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },
    wrapMethod: {
        set: function (val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            }
        },
        initialValue: "auto"
    },
    indentedSoftWrap: {
        set: function () {
            if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
            }
        },
        initialValue: true
    },
    firstLineNumber: {
        set: function () { this._signal("changeBreakpoint"); },
        initialValue: 1
    },
    useWorker: {
        set: function (useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: { initialValue: true },
    tabSize: {
        set: function (tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
                this.$modified = true;
                this.$rowLengthCache = [];
                this.$tabSize = tabSize;
                this._signal("changeTabSize");
            }
        },
        initialValue: 4,
        handlesSet: true
    },
    navigateWithinSoftTabs: { initialValue: false },
    foldStyle: {
        set: function (val) { this.setFoldStyle(val); },
        handlesSet: true
    },
    overwrite: {
        set: function (val) { this._signal("changeOverwrite"); },
        initialValue: false
    },
    newLineMode: {
        set: function (val) { this.doc.setNewLineMode(val); },
        get: function () { return this.doc.getNewLineMode(); },
        handlesSet: true
    },
    mode: {
        set: function (val) { this.setMode(val); },
        get: function () { return this.$modeId; },
        handlesSet: true
    }
});
exports.EditSession = EditSession;

});

ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(require, exports, module){"use strict";
var lang = require("./lib/lang");
var oop = require("./lib/oop");
var Range = require("./range").Range;
var Search = function () {
    this.$options = {};
};
(function () {
    this.set = function (options) {
        oop.mixin(this.$options, options);
        return this;
    };
    this.getOptions = function () {
        return lang.copyObject(this.$options);
    };
    this.setOptions = function (options) {
        this.$options = options;
    };
    this.find = function (session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;
        var firstRange = null;
        iterator.forEach(function (sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec && options.start && options.start.start
                && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                firstRange = null;
                return false;
            }
            return true;
        });
        return firstRange;
    };
    this.findAll = function (session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);
        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();
        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;
                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex) {
                    continue;
                }
                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                if (len > 2)
                    row = row + len - 2;
            }
        }
        else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }
        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.end.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
                i++;
            var endRow = range.end.row - range.start.row;
            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
                j--;
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }
        return ranges;
    };
    this.replace = function (input, replacement) {
        var options = this.$options;
        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;
        if (!re)
            return;
        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--;) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }
        return replacement;
    };
    this.$assembleRegExp = function (options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;
        var needle = options.needle;
        if (!options.needle)
            return options.re = false;
        if (!options.regExp)
            needle = lang.escapeRegExp(needle);
        if (options.wholeWord)
            needle = addWordBoundary(needle, options);
        var modifier = options.caseSensitive ? "gm" : "gmi";
        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);
        try {
            var re = new RegExp(needle, modifier);
        }
        catch (e) {
            re = false;
        }
        return options.re = re;
    };
    this.$assembleMultilineRegExp = function (needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++)
            try {
                re.push(new RegExp(parts[i], modifier));
            }
            catch (e) {
                return false;
            }
        return re;
    };
    this.$matchIterator = function (session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;
        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];
        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;
        if (backwards) {
            var forEach = function (callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row--; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
            };
        }
        else {
            var forEach = function (callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row = row + 1; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
            };
        }
        if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function (row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength())
                    return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1)
                    return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(startRow + i);
                    if (line.search(re[i]) == -1)
                        return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset)
                    return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                    return true;
            };
        }
        else if (backwards) {
            var forEachInLine = function (row, endIndex, callback) {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while ((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (!length) {
                        if (last >= line.length)
                            break;
                        re.lastIndex = last += 1;
                    }
                    if (m.index + length > endIndex)
                        break;
                    matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i >= 0; i -= 2) {
                    var column = matches[i - 1];
                    var length = matches[i];
                    if (callback(row, column, row, column + length))
                        return true;
                }
            };
        }
        else {
            var forEachInLine = function (row, startIndex, callback) {
                var line = session.getLine(row);
                var last;
                var m;
                re.lastIndex = startIndex;
                while ((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (callback(row, last, row, last + length))
                        return true;
                    if (!length) {
                        re.lastIndex = last += 1;
                        if (last >= line.length)
                            return false;
                    }
                }
            };
        }
        return { forEach: forEach };
    };
}).call(Search.prototype);
function addWordBoundary(needle, options) {
    function wordBoundary(c) {
        if (/\w/.test(c) || options.regExp)
            return "\\b";
        return "";
    }
    return wordBoundary(needle[0]) + needle
        + wordBoundary(needle[needle.length - 1]);
}
exports.Search = Search;

});

ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(require, exports, module){"use strict";
var keyUtil = require("../lib/keys");
var useragent = require("../lib/useragent");
var KEY_MODS = keyUtil.KEY_MODS;
function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
}
function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
}
MultiHashHandler.prototype = HashHandler.prototype;
(function () {
    this.addCommand = function (command) {
        if (this.commands[command.name])
            this.removeCommand(command);
        this.commands[command.name] = command;
        if (command.bindKey)
            this._buildKeyHash(command);
    };
    this.removeCommand = function (command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            }
            else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    };
    this.bindKey = function (key, command, position) {
        if (typeof key == "object" && key) {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
        key.split("|").forEach(function (keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function (keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    };
    function getPosition(command) {
        return typeof command == "object" && command.bindKey
            && command.bindKey.position
            || (command.isDefault ? -100 : 0);
    }
    this._addCommandToBinding = function (keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        }
        else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        }
        else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            }
            else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }
            if (typeof position != "number") {
                position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    };
    this.addCommands = function (commands) {
        commands && Object.keys(commands).forEach(function (name) {
            var command = commands[name];
            if (!command)
                return;
            if (typeof command === "string")
                return this.bindKey(command, name);
            if (typeof command === "function")
                command = { exec: command };
            if (typeof command !== "object")
                return;
            if (!command.name)
                command.name = name;
            this.addCommand(command);
        }, this);
    };
    this.removeCommands = function (commands) {
        Object.keys(commands).forEach(function (name) {
            this.removeCommand(commands[name]);
        }, this);
    };
    this.bindKeys = function (keyList) {
        Object.keys(keyList).forEach(function (key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };
    this._buildKeyHash = function (command) {
        this.bindKey(command.bindKey, command);
    };
    this.parseKeys = function (keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) { return x; });
        var key = parts.pop();
        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return { key: key, hashId: -1 };
        else if (parts.length == 1 && parts[0] == "shift")
            return { key: key.toUpperCase(), hashId: -1 };
        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return { key: key, hashId: hashId };
    };
    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    };
    this.handleKeyboard = function (data, hashId, keyString, keyCode) {
        if (keyCode < 0)
            return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }
        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return { command: "null" };
            }
        }
        if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0)
                data.$keyChain = ""; // reset keyChain
        }
        return { command: command };
    };
    this.getStatusText = function (editor, data) {
        return data.$keyChain || "";
    };
}).call(HashHandler.prototype);
exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;

});

ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var CommandManager = function (platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function (e) {
        if (!e.args) {
            return e.command.exec(e.editor, {}, e.event, true);
        }
        return e.command.exec(e.editor, e.args, e.event, false);
    });
};
oop.inherits(CommandManager, MultiHashHandler);
(function () {
    oop.implement(this, EventEmitter);
    this.exec = function (command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--;) {
                if (this.exec(command[i], editor, args))
                    return true;
            }
            return false;
        }
        if (typeof command === "string")
            command = this.commands[command];
        if (!command)
            return false;
        if (editor && editor.$readOnly && !command.readOnly)
            return false;
        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
            return false;
        var e = { editor: editor, command: command, args: args };
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);
        return e.returnValue === false ? false : true;
    };
    this.toggleRecording = function (editor) {
        if (this.$inReplay)
            return;
        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.off("exec", this.$addCommandToMacro);
            if (!this.macro.length)
                this.macro = this.oldMacro;
            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function (e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }
        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    };
    this.replay = function (editor) {
        if (this.$inReplay || !this.macro)
            return;
        if (this.recording)
            return this.toggleRecording(editor);
        try {
            this.$inReplay = true;
            this.macro.forEach(function (x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        }
        finally {
            this.$inReplay = false;
        }
    };
    this.trimMacro = function (m) {
        return m.map(function (x) {
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };
}).call(CommandManager.prototype);
exports.CommandManager = CommandManager;

});

ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(require, exports, module){"use strict";
var lang = require("../lib/lang");
var config = require("../config");
var Range = require("../range").Range;
function bindKey(win, mac) {
    return { win: win, mac: mac };
}
exports.commands = [{
        name: "showSettingsMenu",
        description: "Show settings menu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function (editor) {
            config.loadModule("ace/ext/settings_menu", function (module) {
                module.init(editor);
                editor.showSettingsMenu();
            });
        },
        readOnly: true
    }, {
        name: "goToNextError",
        description: "Go to next error",
        bindKey: bindKey("Alt-E", "F4"),
        exec: function (editor) {
            config.loadModule("ace/ext/error_marker", function (module) {
                module.showErrorMarker(editor, 1);
            });
        },
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "goToPreviousError",
        description: "Go to previous error",
        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
        exec: function (editor) {
            config.loadModule("ace/ext/error_marker", function (module) {
                module.showErrorMarker(editor, -1);
            });
        },
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "selectall",
        description: "Select all",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function (editor) { editor.selectAll(); },
        readOnly: true
    }, {
        name: "centerselection",
        description: "Center selection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function (editor) { editor.centerSelection(); },
        readOnly: true
    }, {
        name: "gotoline",
        description: "Go to line...",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function (editor, line) {
            if (typeof line === "number" && !isNaN(line))
                editor.gotoLine(line);
            editor.prompt({ $type: "gotoLine" });
        },
        readOnly: true
    }, {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function (editor) { editor.session.toggleFold(false); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function (editor) { editor.session.toggleFold(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "toggleFoldWidget",
        description: "Toggle fold widget",
        bindKey: bindKey("F2", "F2"),
        exec: function (editor) { editor.session.toggleFoldWidget(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "toggleParentFoldWidget",
        description: "Toggle parent fold widget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function (editor) { editor.session.toggleFoldWidget(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldall",
        description: "Fold all",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function (editor) { editor.session.foldAll(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldAllComments",
        description: "Fold all comments",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function (editor) { editor.session.foldAllComments(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "foldOther",
        description: "Fold other",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function (editor) {
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "unfoldall",
        description: "Unfold all",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function (editor) { editor.session.unfold(); },
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "findnext",
        description: "Find next",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function (editor) { editor.findNext(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "findprevious",
        description: "Find previous",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function (editor) { editor.findPrevious(); },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
    }, {
        name: "selectOrFindNext",
        description: "Select or find next",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function (editor) {
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findNext();
        },
        readOnly: true
    }, {
        name: "selectOrFindPrevious",
        description: "Select or find previous",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function (editor) {
            if (editor.selection.isEmpty())
                editor.selection.selectWord();
            else
                editor.findPrevious();
        },
        readOnly: true
    }, {
        name: "find",
        description: "Find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function (editor) {
            config.loadModule("ace/ext/searchbox", function (e) { e.Search(editor); });
        },
        readOnly: true
    }, {
        name: "overwrite",
        description: "Overwrite",
        bindKey: "Insert",
        exec: function (editor) { editor.toggleOverwrite(); },
        readOnly: true
    }, {
        name: "selecttostart",
        description: "Select to start",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
        exec: function (editor) { editor.getSelection().selectFileStart(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "gotostart",
        description: "Go to start",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function (editor) { editor.navigateFileStart(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "selectup",
        description: "Select up",
        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
        exec: function (editor) { editor.getSelection().selectUp(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "golineup",
        description: "Go line up",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function (editor, args) { editor.navigateUp(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttoend",
        description: "Select to end",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
        exec: function (editor) { editor.getSelection().selectFileEnd(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "gotoend",
        description: "Go to end",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function (editor) { editor.navigateFileEnd(); },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
    }, {
        name: "selectdown",
        description: "Select down",
        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
        exec: function (editor) { editor.getSelection().selectDown(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "golinedown",
        description: "Go line down",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function (editor, args) { editor.navigateDown(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectwordleft",
        description: "Select word left",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function (editor) { editor.getSelection().selectWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotowordleft",
        description: "Go to word left",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function (editor) { editor.navigateWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttolinestart",
        description: "Select to line start",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
        exec: function (editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotolinestart",
        description: "Go to line start",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function (editor) { editor.navigateLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectleft",
        description: "Select left",
        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
        exec: function (editor) { editor.getSelection().selectLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotoleft",
        description: "Go to left",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function (editor, args) { editor.navigateLeft(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectwordright",
        description: "Select word right",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function (editor) { editor.getSelection().selectWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotowordright",
        description: "Go to word right",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function (editor) { editor.navigateWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selecttolineend",
        description: "Select to line end",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
        exec: function (editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotolineend",
        description: "Go to line end",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function (editor) { editor.navigateLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectright",
        description: "Select right",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function (editor) { editor.getSelection().selectRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "gotoright",
        description: "Go to right",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function (editor, args) { editor.navigateRight(args.times); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectpagedown",
        description: "Select page down",
        bindKey: "Shift-PageDown",
        exec: function (editor) { editor.selectPageDown(); },
        readOnly: true
    }, {
        name: "pagedown",
        description: "Page down",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function (editor) { editor.scrollPageDown(); },
        readOnly: true
    }, {
        name: "gotopagedown",
        description: "Go to page down",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function (editor) { editor.gotoPageDown(); },
        readOnly: true
    }, {
        name: "selectpageup",
        description: "Select page up",
        bindKey: "Shift-PageUp",
        exec: function (editor) { editor.selectPageUp(); },
        readOnly: true
    }, {
        name: "pageup",
        description: "Page up",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function (editor) { editor.scrollPageUp(); },
        readOnly: true
    }, {
        name: "gotopageup",
        description: "Go to page up",
        bindKey: "PageUp",
        exec: function (editor) { editor.gotoPageUp(); },
        readOnly: true
    }, {
        name: "scrollup",
        description: "Scroll up",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function (e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: "scrolldown",
        description: "Scroll down",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function (e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
        readOnly: true
    }, {
        name: "selectlinestart",
        description: "Select line start",
        bindKey: "Shift-Home",
        exec: function (editor) { editor.getSelection().selectLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectlineend",
        description: "Select line end",
        bindKey: "Shift-End",
        exec: function (editor) { editor.getSelection().selectLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "togglerecording",
        description: "Toggle recording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function (editor) { editor.commands.toggleRecording(editor); },
        readOnly: true
    }, {
        name: "replaymacro",
        description: "Replay macro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function (editor) { editor.commands.replay(editor); },
        readOnly: true
    }, {
        name: "jumptomatching",
        description: "Jump to matching",
        bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
        exec: function (editor) { editor.jumpToMatching(); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "selecttomatching",
        description: "Select to matching",
        bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
        exec: function (editor) { editor.jumpToMatching(true); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "expandToMatching",
        description: "Expand to matching",
        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function (editor) { editor.jumpToMatching(true, true); },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
    }, {
        name: "passKeysToBrowser",
        description: "Pass keys to browser",
        bindKey: bindKey(null, null),
        exec: function () { },
        passEvent: true,
        readOnly: true
    }, {
        name: "copy",
        description: "Copy",
        exec: function (editor) {
        },
        readOnly: true
    },
    {
        name: "cut",
        description: "Cut",
        exec: function (editor) {
            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit("cut", range);
            if (!range.isEmpty())
                editor.session.remove(range);
            editor.clearSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "paste",
        description: "Paste",
        exec: function (editor, args) {
            editor.$handlePaste(args);
        },
        scrollIntoView: "cursor"
    }, {
        name: "removeline",
        description: "Remove line",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function (editor) { editor.removeLines(); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
    }, {
        name: "duplicateSelection",
        description: "Duplicate selection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function (editor) { editor.duplicateSelection(); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "sortlines",
        description: "Sort lines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function (editor) { editor.sortLines(); },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
    }, {
        name: "togglecomment",
        description: "Toggle comment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function (editor) { editor.toggleCommentLines(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "toggleBlockComment",
        description: "Toggle block comment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function (editor) { editor.toggleBlockComment(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "modifyNumberUp",
        description: "Modify number up",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function (editor) { editor.modifyNumber(1); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "modifyNumberDown",
        description: "Modify number down",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function (editor) { editor.modifyNumber(-1); },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
    }, {
        name: "replace",
        description: "Replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function (editor) {
            config.loadModule("ace/ext/searchbox", function (e) { e.Search(editor, true); });
        }
    }, {
        name: "undo",
        description: "Undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function (editor) { editor.undo(); }
    }, {
        name: "redo",
        description: "Redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function (editor) { editor.redo(); }
    }, {
        name: "copylinesup",
        description: "Copy lines up",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function (editor) { editor.copyLinesUp(); },
        scrollIntoView: "cursor"
    }, {
        name: "movelinesup",
        description: "Move lines up",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function (editor) { editor.moveLinesUp(); },
        scrollIntoView: "cursor"
    }, {
        name: "copylinesdown",
        description: "Copy lines down",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function (editor) { editor.copyLinesDown(); },
        scrollIntoView: "cursor"
    }, {
        name: "movelinesdown",
        description: "Move lines down",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function (editor) { editor.moveLinesDown(); },
        scrollIntoView: "cursor"
    }, {
        name: "del",
        description: "Delete",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function (editor) { editor.remove("right"); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "backspace",
        description: "Backspace",
        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
        exec: function (editor) { editor.remove("left"); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "cut_or_delete",
        description: "Cut or delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function (editor) {
            if (editor.selection.isEmpty()) {
                editor.remove("left");
            }
            else {
                return false;
            }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolinestart",
        description: "Remove to line start",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function (editor) { editor.removeToLineStart(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolineend",
        description: "Remove to line end",
        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
        exec: function (editor) { editor.removeToLineEnd(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolinestarthard",
        description: "Remove to line start hard",
        bindKey: bindKey("Ctrl-Shift-Backspace", null),
        exec: function (editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removetolineendhard",
        description: "Remove to line end hard",
        bindKey: bindKey("Ctrl-Shift-Delete", null),
        exec: function (editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removewordleft",
        description: "Remove word left",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function (editor) { editor.removeWordLeft(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "removewordright",
        description: "Remove word right",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function (editor) { editor.removeWordRight(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "outdent",
        description: "Outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function (editor) { editor.blockOutdent(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "indent",
        description: "Indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function (editor) { editor.indent(); },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
    }, {
        name: "blockoutdent",
        description: "Block outdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function (editor) { editor.blockOutdent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "blockindent",
        description: "Block indent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function (editor) { editor.blockIndent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
    }, {
        name: "insertstring",
        description: "Insert string",
        exec: function (editor, str) { editor.insert(str); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "inserttext",
        description: "Insert text",
        exec: function (editor, args) {
            editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "splitline",
        description: "Split line",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function (editor) { editor.splitLine(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "transposeletters",
        description: "Transpose letters",
        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
        exec: function (editor) { editor.transposeLetters(); },
        multiSelectAction: function (editor) { editor.transposeSelections(1); },
        scrollIntoView: "cursor"
    }, {
        name: "touppercase",
        description: "To uppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function (editor) { editor.toUpperCase(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "tolowercase",
        description: "To lowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function (editor) { editor.toLowerCase(); },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "autoindent",
        description: "Auto Indent",
        bindKey: bindKey(null, null),
        exec: function (editor) { editor.autoIndent(); },
        multiSelectAction: "forEachLine",
        scrollIntoView: "animate"
    }, {
        name: "expandtoline",
        description: "Expand to line",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function (editor) {
            var range = editor.selection.getRange();
            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "openlink",
        bindKey: bindKey("Ctrl+F3", "F3"),
        exec: function (editor) { editor.openLink(); }
    }, {
        name: "joinlines",
        description: "Join lines",
        bindKey: bindKey(null, null),
        exec: function (editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);
            for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                if (curLine.length !== 0) {
                    curLine = " " + curLine;
                }
                insertLine += curLine;
            }
            if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
                insertLine += editor.session.doc.getNewLineCharacter();
            }
            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
            if (selectedCount > 0) {
                editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            }
            else {
                firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
                editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
        },
        multiSelectAction: "forEach",
        readOnly: true
    }, {
        name: "invertSelection",
        description: "Invert selection",
        bindKey: bindKey(null, null),
        exec: function (editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
                ranges = [editor.selection.getRange()];
            }
            for (var i = 0; i < ranges.length; i++) {
                if (i == (ranges.length - 1)) {
                    if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                        newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                    }
                }
                if (i === 0) {
                    if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                        newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                    }
                }
                else {
                    newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                }
            }
            editor.exitMultiSelectMode();
            editor.clearSelection();
            for (var i = 0; i < newRanges.length; i++) {
                editor.selection.addRange(newRanges[i], false);
            }
        },
        readOnly: true,
        scrollIntoView: "none"
    }, {
        name: "addLineAfter",
        description: "Add new line after the current line",
        exec: function (editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert("\n");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "addLineBefore",
        description: "Add new line before the current line",
        exec: function (editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert("\n");
            if (cursor.row === 0)
                editor.navigateUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
    }, {
        name: "openCommandPallete",
        description: "Open command palette",
        bindKey: bindKey("F1", "F1"),
        exec: function (editor) {
            editor.prompt({ $type: "commands" });
        },
        readOnly: true
    }, {
        name: "modeSelect",
        description: "Change language mode...",
        bindKey: bindKey(null, null),
        exec: function (editor) {
            editor.prompt({ $type: "modes" });
        },
        readOnly: true
    }];
for (var i = 1; i < 9; i++) {
    exports.commands.push({
        name: "foldToLevel" + i,
        description: "Fold To Level " + i,
        level: i,
        exec: function (editor) { editor.session.foldToLevel(this.level); },
        scrollIntoView: "center",
        readOnly: true
    });
}

});

ace.define("ace/line_widgets",["require","exports","module","ace/lib/dom"], function(require, exports, module){"use strict";
var dom = require("./lib/dom");
function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);
    this.session.on("change", this.updateOnChange);
    this.session.on("changeFold", this.updateOnFold);
    this.session.on("changeEditor", this.$onChangeEditor);
}
(function () {
    this.getRowLength = function (row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        }
        else {
            return this.$wrapData[row].length + 1 + h;
        }
    };
    this.$getWidgetScreenLength = function () {
        var screenRows = 0;
        this.lineWidgets.forEach(function (w) {
            if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
        });
        return screenRows;
    };
    this.$onChangeEditor = function (e) {
        this.attach(e.editor);
    };
    this.attach = function (editor) {
        if (editor && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();
        if (this.editor == editor)
            return;
        this.detach();
        this.editor = editor;
        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    };
    this.detach = function (e) {
        var editor = this.editor;
        if (!editor)
            return;
        this.editor = null;
        editor.widgetManager = null;
        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function (w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };
    this.updateOnFold = function (e, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e.action)
            return;
        var fold = e.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e.action == "add";
        for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
            if (hide) {
                if (!lineWidgets[start])
                    lineWidgets[start] = lineWidgets[end];
                else
                    lineWidgets[end].hidden = hide;
            }
            else {
                if (lineWidgets[start] == lineWidgets[end])
                    lineWidgets[start] = undefined;
                lineWidgets[end].hidden = hide;
            }
        }
    };
    this.updateOnChange = function (delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;
        if (len === 0) {
        }
        else if (delta.action == "remove") {
            var removed = lineWidgets.splice(startRow + 1, len);
            if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
            }
            removed.forEach(function (w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        }
        else {
            var args = new Array(len);
            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                    startRow++;
            }
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };
    this.$updateRows = function () {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var noWidgets = true;
        lineWidgets.forEach(function (w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                    w.$oldWidget.row = i;
                    w = w.$oldWidget;
                }
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };
    this.$registerLineWidget = function (w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
        var old = this.session.lineWidgets[w.row];
        if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
            }
        }
        this.session.lineWidgets[w.row] = w;
        return w;
    };
    this.addLineWidget = function (w) {
        this.$registerLineWidget(w);
        w.session = this.session;
        if (!this.editor)
            return w;
        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.text && !w.el) {
            w.el = dom.createElement("div");
            w.el.textContent = w.text;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            if (w.className) {
                dom.addCssClass(w.el, w.className);
            }
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
            if (!w.coverGutter) {
                w.el.style.zIndex = 3;
            }
            if (w.pixelHeight == null) {
                w.pixelHeight = w.el.offsetHeight;
            }
        }
        if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        }
        var fold = this.session.getFoldAt(w.row, 0);
        w.$fold = fold;
        if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
            else
                w.hidden = true;
        }
        this.session._emit("changeFold", { data: { start: { row: w.row } } });
        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w);
        return w;
    };
    this.removeLineWidget = function (w) {
        w._inDocument = false;
        w.session = null;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy)
            try {
                w.editor.destroy();
            }
            catch (e) { }
        if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                    this.onWidgetChanged(w.$oldWidget);
            }
            else {
                while (w1) {
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
        }
        this.session._emit("changeFold", { data: { start: { row: w.row } } });
        this.$updateRows();
    };
    this.getWidgetsAtRow = function (row) {
        var lineWidgets = this.session.lineWidgets;
        var w = lineWidgets && lineWidgets[row];
        var list = [];
        while (w) {
            list.push(w);
            w = w.$oldWidget;
        }
        return list;
    };
    this.onWidgetChanged = function (w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    };
    this.measureWidgets = function (e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        if (!changedWidgets || !changedWidgets.length)
            return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el)
                continue;
            if (w.session != this.session)
                continue;
            if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                    continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            w.h = w.el.offsetHeight;
            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", { data: { start: { row: min } } });
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };
    this.renderWidgets = function (e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        while (first > 0 && !lineWidgets[first])
            first--;
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;
        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el)
                continue;
            if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
            }
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }
            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            }
            else {
                w.el.style.right = "";
            }
        }
    };
}).call(LineWidgets.prototype);
exports.LineWidgets = LineWidgets;

});

ace.define("ace/editor",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator","ace/line_widgets","ace/clipboard"], function(require, exports, module){"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var oop = require("./lib/oop");
var dom = require("./lib/dom");
var lang = require("./lib/lang");
var useragent = require("./lib/useragent");
var TextInput = require("./keyboard/textinput").TextInput;
var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
var FoldHandler = require("./mouse/fold_handler").FoldHandler;
var KeyBinding = require("./keyboard/keybinding").KeyBinding;
var EditSession = require("./edit_session").EditSession;
var Search = require("./search").Search;
var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var CommandManager = require("./commands/command_manager").CommandManager;
var defaultCommands = require("./commands/default_commands").commands;
var config = require("./config");
var TokenIterator = require("./token_iterator").TokenIterator;
var LineWidgets = require("./line_widgets").LineWidgets;
var clipboard = require("./clipboard");
var Editor = function (renderer, session, options) {
    this.$toDestroy = [];
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;
    this.id = "editor" + (++Editor.$uid);
    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    if (typeof document == "object") {
        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
    }
    this.keyBinding = new KeyBinding(this);
    this.$search = new Search().set({
        wrap: true
    });
    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);
    this.$initOperationListeners();
    this._$emitInputEvent = lang.delayedCall(function () {
        this._signal("input", {});
        if (this.session && !this.session.destroyed)
            this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    this.on("change", function (_, _self) {
        _self._$emitInputEvent.schedule(31);
    });
    this.setSession(session || options && options.session || new EditSession(""));
    config.resetOptions(this);
    if (options)
        this.setOptions(options);
    config._signal("editor", this);
};
Editor.$uid = 0;
(function () {
    oop.implement(this, EventEmitter);
    this.$initOperationListeners = function () {
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);
        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
        this.on("change", function () {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.docChanged = true;
        }.bind(this), true);
        this.on("changeSelection", function () {
            if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
            }
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };
    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function (commandEvent) {
        if (this.curOp) {
            if (!commandEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commandEvent) {
            this.previousCommand = null;
            commandEvent = {};
        }
        this.$opResetTimer.schedule();
        this.curOp = this.session.curOp = {
            command: commandEvent.command || {},
            args: commandEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        this.curOp.selectionBefore = this.selection.toJSON();
    };
    this.endOperation = function (e) {
        if (this.curOp && this.session) {
            if (e && e.returnValue === false || !this.session)
                return (this.curOp = null);
            if (e == true && this.curOp.command && this.curOp.command.name == "mouse")
                return;
            this._signal("beforeEndOperation");
            if (!this.curOp)
                return;
            var command = this.curOp.command;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case "center-animate":
                        scrollIntoView = "animate";
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            var sel = this.selection.toJSON();
            this.curOp.selectionAfter = sel;
            this.$lastSel = this.selection.toJSON();
            this.session.getUndoManager().addSelection(sel);
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };
    this.$mergeableCommands = ["backspace", "del", "insertstring"];
    this.$historyTracker = function (e) {
        if (!this.$mergeUndoDeltas)
            return;
        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;
            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
            this.mergeNextCommand = true;
        }
        else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }
        if (this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000) {
            shouldMerge = false; // the sequence is too long
        }
        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function (keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function (module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        }
        else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    };
    this.getKeyboardHandler = function () {
        return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function (session) {
        if (this.session == session)
            return;
        if (this.curOp)
            this.endOperation();
        this.curOp = {};
        var oldSession = this.session;
        if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
        }
        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.onChangeMode();
            this.onCursorChange();
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        }
        else {
            this.selection = null;
            this.renderer.setSession(session);
        }
        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });
        this.curOp = null;
        oldSession && oldSession._signal("changeEditor", { oldEditor: this });
        session && session._signal("changeEditor", { editor: this });
        if (session && !session.destroyed)
            session.bgTokenizer.scheduleStart();
    };
    this.getSession = function () {
        return this.session;
    };
    this.setValue = function (val, cursorPos) {
        this.session.doc.setValue(val);
        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();
        return val;
    };
    this.getValue = function () {
        return this.session.getValue();
    };
    this.getSelection = function () {
        return this.selection;
    };
    this.resize = function (force) {
        this.renderer.onResize(force);
    };
    this.setTheme = function (theme, cb) {
        this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function () {
        return this.renderer.getTheme();
    };
    this.setStyle = function (style) {
        this.renderer.setStyle(style);
    };
    this.unsetStyle = function (style) {
        this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
        return this.getOption("fontSize") ||
            dom.computedStyle(this.container).fontSize;
    };
    this.setFontSize = function (size) {
        this.setOption("fontSize", size);
    };
    this.$highlightBrackets = function () {
        if (this.$highlightPending) {
            return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function () {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || session.destroyed)
                return;
            if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function (id) {
                    session.removeMarker(id);
                });
                session.$bracketHighlight = null;
            }
            var pos = self.getCursorPosition();
            var handler = self.getKeyboardHandler();
            var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self);
            var ranges = session.getMatchingBracketRanges(pos, isBackwards);
            if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                    var tagNamesRanges = session.getMatchingTags(pos);
                    if (tagNamesRanges)
                        ranges = [tagNamesRanges.openTagName, tagNamesRanges.closeTagName];
                }
            }
            if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self.session);
            if (!ranges) {
                if (self.getHighlightIndentGuides())
                    self.renderer.$textLayer.$highlightIndentGuide();
                return;
            }
            var markerType = "ace_bracket";
            if (!Array.isArray(ranges)) {
                ranges = [ranges];
            }
            else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
            }
            if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
            }
            session.$bracketHighlight = {
                ranges: ranges,
                markerIds: ranges.map(function (range) {
                    return session.addMarker(range, markerType, "text");
                })
            };
            if (self.getHighlightIndentGuides())
                self.renderer.$textLayer.$highlightIndentGuide();
        }, 50);
    };
    this.focus = function () {
        this.textInput.focus();
    };
    this.isFocused = function () {
        return this.textInput.isFocused();
    };
    this.blur = function () {
        this.textInput.blur();
    };
    this.onFocus = function (e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    };
    this.onBlur = function (e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    };
    this.$cursorChange = function () {
        this.renderer.updateCursor();
        this.$highlightBrackets();
        this.$updateHighlightActiveLine();
    };
    this.onDocumentChange = function (delta) {
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);
        this._signal("change", delta);
        this.$cursorChange();
    };
    this.onTokenizerUpdate = function (e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };
    this.onScrollTopChange = function () {
        this.renderer.scrollToY(this.session.getScrollTop());
    };
    this.onScrollLeftChange = function () {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function () {
        this.$cursorChange();
        this._signal("changeSelection");
    };
    this.$updateHighlightActiveLine = function () {
        var session = this.getSession();
        var highlight;
        if (this.$highlightActiveLine) {
            if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }
        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        }
        else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        }
        else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    };
    this.onSelectionChange = function (e) {
        var session = this.session;
        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;
        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        }
        else {
            this.$updateHighlightActiveLine();
        }
        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);
        this._signal("changeSelection");
    };
    this.$getSelectionHighLightRegexp = function () {
        var session = this.session;
        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;
        var startColumn = selection.start.column;
        var endColumn = selection.end.column;
        var line = session.getLine(selection.start.row);
        var needle = line.substring(startColumn, endColumn);
        if (needle.length > 5000 || !/[\w\d]/.test(needle))
            return;
        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });
        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
        if (!re.test(wordWithBoundary))
            return;
        return re;
    };
    this.onChangeFrontMarker = function () {
        this.renderer.updateFrontMarkers();
    };
    this.onChangeBackMarker = function () {
        this.renderer.updateBackMarkers();
    };
    this.onChangeBreakpoint = function () {
        this.renderer.updateBreakpoints();
    };
    this.onChangeAnnotation = function () {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };
    this.onChangeMode = function (e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    };
    this.onChangeWrapLimit = function () {
        this.renderer.updateFull();
    };
    this.onChangeWrapMode = function () {
        this.renderer.onResize(true);
    };
    this.onChangeFold = function () {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
    };
    this.getSelectedText = function () {
        return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function () {
        var text = this.getSelectedText();
        var nl = this.session.doc.getNewLineCharacter();
        var copyLine = false;
        if (!text && this.$copyWithEmptySelection) {
            copyLine = true;
            var ranges = this.selection.getAllRanges();
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (i && ranges[i - 1].start.row == range.start.row)
                    continue;
                text += this.session.getLine(range.start.row) + nl;
            }
        }
        var e = { text: text };
        this._signal("copy", e);
        clipboard.lineMode = copyLine ? e.text : false;
        return e.text;
    };
    this.onCopy = function () {
        this.commands.exec("copy", this);
    };
    this.onCut = function () {
        this.commands.exec("cut", this);
    };
    this.onPaste = function (text, event) {
        var e = { text: text, event: event };
        this.commands.exec("paste", this, e);
    };
    this.$handlePaste = function (e) {
        if (typeof e == "string")
            e = { text: e };
        this._signal("paste", e);
        var text = e.text;
        var lineMode = text === clipboard.lineMode;
        var session = this.session;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
            else
                this.insert(text);
        }
        else if (lineMode) {
            this.selection.rangeList.ranges.forEach(function (range) {
                session.insert({ row: range.start.row, column: 0 }, text);
            });
        }
        else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
            if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);
            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    session.remove(range);
                session.insert(range.start, lines[i]);
            }
        }
    };
    this.execCommand = function (command, args) {
        return this.commands.exec(command, this, args);
    };
    this.insert = function (text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();
        if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    if (!this.inVirtualSelectionMode) {
                        this.session.mergeUndoDeltas = false;
                        this.mergeNextCommand = false;
                    }
                }
                text = transform.text;
            }
        }
        if (text == "\t")
            text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }
        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();
        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        session.insert(cursor, text);
        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
            }
            else { // Transform relative to the current row.
                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
            }
        }
        if (this.$enableAutoIndent) {
            if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
            }
            if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
        }
    };
    this.autoIndent = function () {
        var session = this.session;
        var mode = session.getMode();
        var startRow, endRow;
        if (this.selection.isEmpty()) {
            startRow = 0;
            endRow = session.doc.getLength() - 1;
        }
        else {
            var selectedRange = this.getSelectionRange();
            startRow = selectedRange.start.row;
            endRow = selectedRange.end.row;
        }
        var prevLineState = "";
        var prevLine = "";
        var lineIndent = "";
        var line, currIndent, range;
        var tab = session.getTabString();
        for (var row = startRow; row <= endRow; row++) {
            if (row > 0) {
                prevLineState = session.getState(row - 1);
                prevLine = session.getLine(row - 1);
                lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
            }
            line = session.getLine(row);
            currIndent = mode.$getIndent(line);
            if (lineIndent !== currIndent) {
                if (currIndent.length > 0) {
                    range = new Range(row, 0, row, currIndent.length);
                    session.remove(range);
                }
                if (lineIndent.length > 0) {
                    session.insert({ row: row, column: 0 }, lineIndent);
                }
            }
            mode.autoOutdent(prevLineState, session, row);
        }
    };
    this.onTextInput = function (text, composition) {
        if (!composition)
            return this.keyBinding.onTextInput(text);
        this.startOperation({ command: { name: "insertstring" } });
        var applyComposition = this.applyComposition.bind(this, text, composition);
        if (this.selection.rangeCount)
            this.forEachSelection(applyComposition);
        else
            applyComposition();
        this.endOperation();
    };
    this.applyComposition = function (text, composition) {
        if (composition.extendLeft || composition.extendRight) {
            var r = this.selection.getRange();
            r.start.column -= composition.extendLeft;
            r.end.column += composition.extendRight;
            if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
            }
            this.selection.setRange(r);
            if (!text && !r.isEmpty())
                this.remove();
        }
        if (text || !this.selection.isEmpty())
            this.insert(text, true);
        if (composition.restoreStart || composition.restoreEnd) {
            var r = this.selection.getRange();
            r.start.column -= composition.restoreStart;
            r.end.column -= composition.restoreEnd;
            this.selection.setRange(r);
        }
    };
    this.onCommandKey = function (e, hashId, keyCode) {
        return this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function (overwrite) {
        this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function () {
        return this.session.getOverwrite();
    };
    this.toggleOverwrite = function () {
        this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function (speed) {
        this.setOption("scrollSpeed", speed);
    };
    this.getScrollSpeed = function () {
        return this.getOption("scrollSpeed");
    };
    this.setDragDelay = function (dragDelay) {
        this.setOption("dragDelay", dragDelay);
    };
    this.getDragDelay = function () {
        return this.getOption("dragDelay");
    };
    this.setSelectionStyle = function (val) {
        this.setOption("selectionStyle", val);
    };
    this.getSelectionStyle = function () {
        return this.getOption("selectionStyle");
    };
    this.setHighlightActiveLine = function (shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    };
    this.getHighlightActiveLine = function () {
        return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function (shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };
    this.getHighlightGutterLine = function () {
        return this.getOption("highlightGutterLine");
    };
    this.setHighlightSelectedWord = function (shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    };
    this.getHighlightSelectedWord = function () {
        return this.$highlightSelectedWord;
    };
    this.setAnimatedScroll = function (shouldAnimate) {
        this.renderer.setAnimatedScroll(shouldAnimate);
    };
    this.getAnimatedScroll = function () {
        return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function (showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function () {
        return this.renderer.getShowInvisibles();
    };
    this.setDisplayIndentGuides = function (display) {
        this.renderer.setDisplayIndentGuides(display);
    };
    this.getDisplayIndentGuides = function () {
        return this.renderer.getDisplayIndentGuides();
    };
    this.setHighlightIndentGuides = function (highlight) {
        this.renderer.setHighlightIndentGuides(highlight);
    };
    this.getHighlightIndentGuides = function () {
        return this.renderer.getHighlightIndentGuides();
    };
    this.setShowPrintMargin = function (showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function () {
        return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function (showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function () {
        return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function (readOnly) {
        this.setOption("readOnly", readOnly);
    };
    this.getReadOnly = function () {
        return this.getOption("readOnly");
    };
    this.setBehavioursEnabled = function (enabled) {
        this.setOption("behavioursEnabled", enabled);
    };
    this.getBehavioursEnabled = function () {
        return this.getOption("behavioursEnabled");
    };
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    };
    this.getWrapBehavioursEnabled = function () {
        return this.getOption("wrapBehavioursEnabled");
    };
    this.setShowFoldWidgets = function (show) {
        this.setOption("showFoldWidgets", show);
    };
    this.getShowFoldWidgets = function () {
        return this.getOption("showFoldWidgets");
    };
    this.setFadeFoldWidgets = function (fade) {
        this.setOption("fadeFoldWidgets", fade);
    };
    this.getFadeFoldWidgets = function () {
        return this.getOption("fadeFoldWidgets");
    };
    this.remove = function (dir) {
        if (this.selection.isEmpty()) {
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }
        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }
        this.session.remove(range);
        this.clearSelection();
    };
    this.removeWordRight = function () {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeWordLeft = function () {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineStart = function () {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();
        if (this.selection.isEmpty())
            this.selection.selectLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineEnd = function () {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();
        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }
        this.session.remove(range);
        this.clearSelection();
    };
    this.splitLine = function () {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }
        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };
    this.setGhostText = function (text, position) {
        if (!this.session.widgetManager) {
            this.session.widgetManager = new LineWidgets(this.session);
            this.session.widgetManager.attach(this);
        }
        this.renderer.setGhostText(text, position);
    };
    this.removeGhostText = function () {
        if (!this.session.widgetManager)
            return;
        this.renderer.removeGhostText();
    };
    this.transposeLetters = function () {
        if (!this.selection.isEmpty()) {
            return;
        }
        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;
        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column - 1);
            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
        }
        else {
            swap = line.charAt(column - 1) + line.charAt(column - 2);
            range = new Range(cursor.row, column - 2, cursor.row, column);
        }
        this.session.replace(range, swap);
        this.session.selection.moveToPosition(range.end);
    };
    this.toLowerCase = function () {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function () {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.indent = function () {
        var session = this.session;
        var range = this.getSelectionRange();
        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        }
        else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);
        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        }
        else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    };
    this.blockIndent = function () {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    };
    this.blockOutdent = function () {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function () {
        var rows = this.$getSelectedRows();
        var session = this.session;
        var lines = [];
        for (var i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));
        lines.sort(function (a, b) {
            if (a.toLowerCase() < b.toLowerCase())
                return -1;
            if (a.toLowerCase() > b.toLowerCase())
                return 1;
            return 0;
        });
        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i - rows.first]);
        }
    };
    this.toggleCommentLines = function () {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };
    this.toggleBlockComment = function () {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function (row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;
        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if (m.index <= column && m.index + m[0].length >= column) {
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index + m[0].length
                };
                return number;
            }
        }
        return null;
    };
    this.modifyNumber = function (amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column - 1, row, column);
        var c = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;
                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);
                if (fp !== nr.end && column < fp) {
                    amount *= Math.pow(10, nr.end - column - 1);
                }
                else {
                    amount *= Math.pow(10, nr.end - column);
                }
                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
            }
        }
        else {
            this.toggleWord();
        }
    };
    this.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
    ];
    this.toggleWord = function () {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        this.selection.selectWord();
        var currentState = this.getSelectedText();
        var currWordStart = this.selection.getWordRange().start.column;
        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\s/);
        var delta = column - currWordStart - 1;
        if (delta < 0)
            delta = 0;
        var curLength = 0, itLength = 0;
        var that = this;
        if (currentState.match(/[A-Za-z0-9_]+/)) {
            wordParts.forEach(function (item, i) {
                itLength = curLength + item.length;
                if (delta >= curLength && delta <= itLength) {
                    currentState = item;
                    that.selection.clearSelection();
                    that.moveCursorTo(row, curLength + currWordStart);
                    that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
            });
        }
        var wordPairs = this.$toggleWordPairs;
        var reg;
        for (var i = 0; i < wordPairs.length; i++) {
            var item = wordPairs[i];
            for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp('^\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\s?$', 'i'));
                if (firstCondition) {
                    var secondCondition = currentState.match(new RegExp('([_]|^|\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\s)', 'g'));
                    if (secondCondition) {
                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {
                            var res = item[negate];
                            if (result.toUpperCase() == result) {
                                res = res.toUpperCase();
                            }
                            else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                            }
                            return res;
                        });
                        this.insert(reg);
                        reg = "";
                    }
                }
            }
        }
    };
    this.findLinkAt = function (row, column) {
        var e_1, _a;
        var line = this.session.getLine(row);
        var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
        var columnPosition = column;
        if (columnPosition < 0)
            columnPosition = 0;
        var previousPosition = 0, currentPosition = 0, match;
        try {
            for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
                var item = wordParts_1_1.value;
                currentPosition = previousPosition + item.length;
                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                    if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                        match = item.replace(/[\s:.,'";}\]]+$/, "");
                        break;
                    }
                }
                previousPosition = currentPosition;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return match;
    };
    this.openLink = function () {
        var cursor = this.selection.getCursor();
        var url = this.findLinkAt(cursor.row, cursor.column);
        if (url)
            window.open(url, '_blank');
        return url != null;
    };
    this.removeLines = function () {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    };
    this.duplicateSelection = function () {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        }
        else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;
            sel.setSelectionRange(range, reverse);
        }
    };
    this.moveLinesDown = function () {
        this.$moveLines(1, false);
    };
    this.moveLinesUp = function () {
        this.$moveLines(-1, false);
    };
    this.moveText = function (range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function () {
        this.$moveLines(-1, true);
    };
    this.copyLinesDown = function () {
        this.$moveLines(1, true);
    };
    this.$moveLines = function (dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1)
                moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        }
        else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff)
                        ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1)
                    rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy)
                    diff = 0;
                totalDiff += diff;
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    };
    this.$getSelectedRows = function (range) {
        range = (range || this.getSelectionRange()).collapseRows();
        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };
    this.onCompositionStart = function (compositionState) {
        this.renderer.showComposition(compositionState);
    };
    this.onCompositionUpdate = function (text) {
        this.renderer.setCompositionText(text);
    };
    this.onCompositionEnd = function () {
        this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function () {
        return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function () {
        return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function (row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function (row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function () {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };
    this.$moveByPage = function (dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);
        if (select === true) {
            this.selection.$moveSelection(function () {
                this.moveCursorBy(rows, 0);
            });
        }
        else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        var scrollTop = renderer.scrollTop;
        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);
        renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function () {
        this.$moveByPage(1, true);
    };
    this.selectPageUp = function () {
        this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function () {
        this.$moveByPage(1, false);
    };
    this.gotoPageUp = function () {
        this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function () {
        this.$moveByPage(1);
    };
    this.scrollPageUp = function () {
        this.$moveByPage(-1);
    };
    this.scrollToRow = function (row) {
        this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function (line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function () {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function () {
        return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function () {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function () {
        return this.selection.getRange();
    };
    this.selectAll = function () {
        this.selection.selectAll();
    };
    this.clearSelection = function () {
        this.selection.clearSelection();
    };
    this.moveCursorTo = function (row, column) {
        this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function (pos) {
        this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function (select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var tokenCount = 0;
        if (prevToken && prevToken.type.indexOf('tag-name') !== -1) {
            prevToken = iterator.stepBackward();
        }
        var token = prevToken || iterator.stepForward();
        if (!token)
            return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };
        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }
                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }
                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;
                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                            break;
                    }
                }
            }
            else if (token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }
                if (prevToken.value === '<' && tokenCount > 1) {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }
            if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);
        if (!matchType)
            return;
        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column)
                    < 2)
                    range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (!token || token.type.indexOf('tag-name') === -1)
                return;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
            if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                    if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                        range = tagsRanges.closeTag;
                        pos = range.start;
                    }
                    else {
                        range = tagsRanges.openTag;
                        if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column
                            === cursor.column)
                            pos = range.end;
                        else
                            pos = range.start;
                    }
                }
            }
            pos = pos || range.start;
        }
        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                }
                else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                }
                else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            }
            else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    };
    this.gotoLine = function (lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({ row: lineNumber - 1, column: column || 0 });
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function (row, column) {
        this.selection.moveTo(row, column);
    };
    this.navigateUp = function (times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function (times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function (times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };
    this.navigateRight = function (times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };
    this.navigateLineStart = function () {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };
    this.navigateLineEnd = function () {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };
    this.navigateFileEnd = function () {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };
    this.navigateFileStart = function () {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };
    this.navigateWordRight = function () {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };
    this.navigateWordLeft = function () {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };
    this.replace = function (replacement, options) {
        if (options)
            this.$search.set(options);
        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;
        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        this.selection.setSelectionRange(range);
        this.renderer.scrollSelectionIntoView(range.start, range.end);
        return replaced;
    };
    this.replaceAll = function (replacement, options) {
        if (options) {
            this.$search.set(options);
        }
        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;
        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);
        for (var i = ranges.length - 1; i >= 0; --i) {
            if (this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }
        this.selection.setSelectionRange(selection);
        return replaced;
    };
    this.$tryReplace = function (range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        }
        else {
            return null;
        }
    };
    this.getLastSearchOptions = function () {
        return this.$search.getOptions();
    };
    this.find = function (needle, options, animate) {
        if (!options)
            options = {};
        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);
        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({ needle: needle });
        }
        this.$search.set(options);
        if (!options.start)
            this.$search.set({ start: range });
        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };
    this.findNext = function (options, animate) {
        this.find({ skipCurrent: true, backwards: false }, options, animate);
    };
    this.findPrevious = function (options, animate) {
        this.find(options, { skipCurrent: true, backwards: true }, animate);
    };
    this.revealRange = function (range, animate) {
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function () {
        this.session.getUndoManager().undo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function () {
        this.session.getUndoManager().redo(this.session);
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function () {
        if (this.$toDestroy) {
            this.$toDestroy.forEach(function (el) {
                el.destroy();
            });
            this.$toDestroy = null;
        }
        if (this.$mouseHandler)
            this.$mouseHandler.destroy();
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session)
            this.session.destroy();
        if (this._$emitInputEvent)
            this._$emitInputEvent.cancel();
        this.removeAllListeners();
    };
    this.setAutoScrollEditorIntoView = function (enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function () {
            shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function () {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function () {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                }
                else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                }
                else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function (enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
        };
    };
    this.$resetCursorStyle = function () {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    };
    this.prompt = function (message, options, callback) {
        var editor = this;
        config.loadModule("ace/ext/prompt", function (module) {
            module.prompt(editor, message, options, callback);
        });
    };
}).call(Editor.prototype);
config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function (style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", { data: style });
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function () { this.$updateHighlightActiveLine(); },
        initialValue: true
    },
    highlightSelectedWord: {
        set: function (shouldHighlight) { this.$onSelectionChange(); },
        initialValue: true
    },
    readOnly: {
        set: function (readOnly) {
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
        },
        initialValue: false
    },
    copyWithEmptySelection: {
        set: function (value) {
            this.textInput.setCopyWithEmptySelection(value);
        },
        initialValue: false
    },
    cursorStyle: {
        set: function (val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: { initialValue: true },
    wrapBehavioursEnabled: { initialValue: true },
    enableAutoIndent: { initialValue: true },
    autoScrollEditorIntoView: {
        set: function (val) { this.setAutoScrollEditorIntoView(val); }
    },
    keyboardHandler: {
        set: function (val) { this.setKeyboardHandler(val); },
        get: function () { return this.$keybindingId; },
        handlesSet: true
    },
    value: {
        set: function (val) { this.session.setValue(val); },
        get: function () { return this.getValue(); },
        handlesSet: true,
        hidden: true
    },
    session: {
        set: function (val) { this.setSession(val); },
        get: function () { return this.session; },
        handlesSet: true,
        hidden: true
    },
    showLineNumbers: {
        set: function (show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        },
        initialValue: true
    },
    relativeLineNumbers: {
        set: function (value) {
            if (this.$showLineNumbers && value)
                relativeNumberRenderer.attach(this);
            else
                relativeNumberRenderer.detach(this);
        }
    },
    placeholder: {
        set: function (message) {
            if (!this.$updatePlaceholder) {
                this.$updatePlaceholder = function () {
                    var value = this.session && (this.renderer.$composition || this.getValue());
                    if (value && this.renderer.placeholderNode) {
                        this.renderer.off("afterRender", this.$updatePlaceholder);
                        dom.removeCssClass(this.container, "ace_hasPlaceholder");
                        this.renderer.placeholderNode.remove();
                        this.renderer.placeholderNode = null;
                    }
                    else if (!value && !this.renderer.placeholderNode) {
                        this.renderer.on("afterRender", this.$updatePlaceholder);
                        dom.addCssClass(this.container, "ace_hasPlaceholder");
                        var el = dom.createElement("div");
                        el.className = "ace_placeholder";
                        el.textContent = this.$placeholder || "";
                        this.renderer.placeholderNode = el;
                        this.renderer.content.appendChild(this.renderer.placeholderNode);
                    }
                    else if (!value && this.renderer.placeholderNode) {
                        this.renderer.placeholderNode.textContent = this.$placeholder || "";
                    }
                }.bind(this);
                this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
        }
    },
    customScrollbar: "renderer",
    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    displayIndentGuides: "renderer",
    highlightIndentGuides: "renderer",
    showGutter: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",
    hasCssTransforms: "renderer",
    maxPixelHeight: "renderer",
    useTextareaForIME: "renderer",
    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimeout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",
    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    navigateWithinSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
});
var relativeNumberRenderer = {
    getText: function (session, row) {
        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? "\xb7" : ""))) + "";
    },
    getWidth: function (session, lastLineNumber, config) {
        return Math.max(lastLineNumber.toString().length, (config.lastRow + 1).toString().length, 2) * config.characterWidth;
    },
    update: function (e, editor) {
        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
    },
    attach: function (editor) {
        editor.renderer.$gutterLayer.$renderer = this;
        editor.on("changeSelection", this.update);
        this.update(null, editor);
    },
    detach: function (editor) {
        if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
        editor.off("changeSelection", this.update);
        this.update(null, editor);
    }
};
exports.Editor = Editor;

});

ace.define("ace/undomanager",["require","exports","module","ace/range"], function(require, exports, module){"use strict";
var UndoManager = function () {
    this.$maxRev = 0;
    this.$fromUndo = false;
    this.$undoDepth = Infinity;
    this.reset();
};
(function () {
    this.addSession = function (session) {
        this.$session = session;
    };
    this.add = function (delta, allowMerge, session) {
        if (this.$fromUndo)
            return;
        if (delta == this.$lastDelta)
            return;
        if (!this.$keepRedoStack)
            this.$redoStack.length = 0;
        if (allowMerge === false || !this.lastDeltas) {
            this.lastDeltas = [];
            var undoStackLength = this.$undoStack.length;
            if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
            }
            this.$undoStack.push(this.lastDeltas);
            delta.id = this.$rev = ++this.$maxRev;
        }
        if (delta.action == "remove" || delta.action == "insert")
            this.$lastDelta = delta;
        this.lastDeltas.push(delta);
    };
    this.addSelection = function (selection, rev) {
        this.selections.push({
            value: selection,
            rev: rev || this.$rev
        });
    };
    this.startNewGroup = function () {
        this.lastDeltas = null;
        return this.$rev;
    };
    this.markIgnored = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
        var stack = this.$undoStack;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id <= from)
                break;
            if (delta.id < to)
                delta.ignore = true;
        }
        this.lastDeltas = null;
    };
    this.getSelection = function (rev, after) {
        var stack = this.selections;
        for (var i = stack.length; i--;) {
            var selection = stack[i];
            if (selection.rev < rev) {
                if (after)
                    selection = stack[i + 1];
                return selection;
            }
        }
    };
    this.getRevision = function () {
        return this.$rev;
    };
    this.getDeltas = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
        var stack = this.$undoStack;
        var end = null, start = 0;
        for (var i = stack.length; i--;) {
            var delta = stack[i][0];
            if (delta.id < to && !end)
                end = i + 1;
            if (delta.id <= from) {
                start = i + 1;
                break;
            }
        }
        return stack.slice(start, end);
    };
    this.getChangedRanges = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
    };
    this.getChangedLines = function (from, to) {
        if (to == null)
            to = this.$rev + 1;
    };
    this.undo = function (session, dontSelect) {
        this.lastDeltas = null;
        var stack = this.$undoStack;
        if (!rearrangeUndoStack(stack, stack.length))
            return;
        if (!session)
            session = this.$session;
        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
            this.$redoStack = [];
        this.$fromUndo = true;
        var deltaSet = stack.pop();
        var undoSelectionRange = null;
        if (deltaSet) {
            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
            this.$redoStack.push(deltaSet);
            this.$syncRev();
        }
        this.$fromUndo = false;
        return undoSelectionRange;
    };
    this.redo = function (session, dontSelect) {
        this.lastDeltas = null;
        if (!session)
            session = this.$session;
        this.$fromUndo = true;
        if (this.$redoStackBaseRev != this.$rev) {
            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
            rebaseRedoStack(this.$redoStack, diff);
            this.$redoStackBaseRev = this.$rev;
            this.$redoStack.forEach(function (x) {
                x[0].id = ++this.$maxRev;
            }, this);
        }
        var deltaSet = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltaSet) {
            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
            this.$undoStack.push(deltaSet);
            this.$syncRev();
        }
        this.$fromUndo = false;
        return redoSelectionRange;
    };
    this.$syncRev = function () {
        var stack = this.$undoStack;
        var nextDelta = stack[stack.length - 1];
        var id = nextDelta && nextDelta[0].id || 0;
        this.$redoStackBaseRev = id;
        this.$rev = id;
    };
    this.reset = function () {
        this.lastDeltas = null;
        this.$lastDelta = null;
        this.$undoStack = [];
        this.$redoStack = [];
        this.$rev = 0;
        this.mark = 0;
        this.$redoStackBaseRev = this.$rev;
        this.selections = [];
    };
    this.canUndo = function () {
        return this.$undoStack.length > 0;
    };
    this.canRedo = function () {
        return this.$redoStack.length > 0;
    };
    this.bookmark = function (rev) {
        if (rev == undefined)
            rev = this.$rev;
        this.mark = rev;
    };
    this.isAtBookmark = function () {
        return this.$rev === this.mark;
    };
    this.toJSON = function () {
    };
    this.fromJSON = function () {
    };
    this.hasUndo = this.canUndo;
    this.hasRedo = this.canRedo;
    this.isClean = this.isAtBookmark;
    this.markClean = this.bookmark;
    this.$prettyPrint = function (delta) {
        if (delta)
            return stringifyDelta(delta);
        return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
    };
}).call(UndoManager.prototype);
function rearrangeUndoStack(stack, pos) {
    for (var i = pos; i--;) {
        var deltaSet = stack[i];
        if (deltaSet && !deltaSet[0].ignore) {
            while (i < pos - 1) {
                var swapped = swapGroups(stack[i], stack[i + 1]);
                stack[i] = swapped[0];
                stack[i + 1] = swapped[1];
                i++;
            }
            return true;
        }
    }
}
var Range = require("./range").Range;
var cmp = Range.comparePoints;
var comparePoints = Range.comparePoints;
function $updateMarkers(delta) {
    var isInsert = delta.action == "insert";
    var start = delta.start;
    var end = delta.end;
    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
    if (isInsert)
        end = start;
    for (var i in this.marks) {
        var point = this.marks[i];
        var cmp = comparePoints(point, start);
        if (cmp < 0) {
            continue; // delta starts after the range
        }
        if (cmp === 0) {
            if (isInsert) {
                if (point.bias == 1) {
                    cmp = 1;
                }
                else {
                    point.bias == -1;
                    continue;
                }
            }
        }
        var cmp2 = isInsert ? cmp : comparePoints(point, end);
        if (cmp2 > 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
        }
        if (!isInsert && cmp2 <= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp2 === 0)
                point.bias = 1;
        }
    }
}
function clonePos(pos) {
    return { row: pos.row, column: pos.column };
}
function cloneDelta(d) {
    return {
        start: clonePos(d.start),
        end: clonePos(d.end),
        action: d.action,
        lines: d.lines.slice()
    };
}
function stringifyDelta(d) {
    d = d || this;
    if (Array.isArray(d)) {
        return d.map(stringifyDelta).join("\n");
    }
    var type = "";
    if (d.action) {
        type = d.action == "insert" ? "+" : "-";
        type += "[" + d.lines + "]";
    }
    else if (d.value) {
        if (Array.isArray(d.value)) {
            type = d.value.map(stringifyRange).join("\n");
        }
        else {
            type = stringifyRange(d.value);
        }
    }
    if (d.start) {
        type += stringifyRange(d);
    }
    if (d.id || d.rev) {
        type += "\t(" + (d.id || d.rev) + ")";
    }
    return type;
}
function stringifyRange(r) {
    return r.start.row + ":" + r.start.column
        + "=>" + r.end.row + ":" + r.end.column;
}
function swap(d1, d2) {
    var i1 = d1.action == "insert";
    var i2 = d2.action == "insert";
    if (i1 && i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        }
        else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        }
        else {
            return null;
        }
    }
    else if (i1 && !i2) {
        if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
        }
        else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        }
        else {
            return null;
        }
    }
    else if (!i1 && i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        }
        else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, +1);
        }
        else {
            return null;
        }
    }
    else if (!i1 && !i2) {
        if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, +1);
        }
        else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
        }
        else {
            return null;
        }
    }
    return [d2, d1];
}
function swapGroups(ds1, ds2) {
    for (var i = ds1.length; i--;) {
        for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i], ds2[j])) {
                while (i < ds1.length) {
                    while (j--) {
                        swap(ds2[j], ds1[i]);
                    }
                    j = ds2.length;
                    i++;
                }
                return [ds1, ds2];
            }
        }
    }
    ds1.selectionBefore = ds2.selectionBefore =
        ds1.selectionAfter = ds2.selectionAfter = null;
    return [ds2, ds1];
}
function xform(d1, c1) {
    var i1 = d1.action == "insert";
    var i2 = c1.action == "insert";
    if (i1 && i2) {
        if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
        }
        else {
            shift(d1, c1, 1);
        }
    }
    else if (i1 && !i2) {
        if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
        }
        else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, +1);
        }
        else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, +1);
        }
    }
    else if (!i1 && i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        }
        else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, +1);
        }
        else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, +1);
        }
    }
    else if (!i1 && !i2) {
        if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
        }
        else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
        }
        else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
                before = d1;
                d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
                after = splitDelta(d1, c1.end);
            }
            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
                d1.lines = after.lines;
                d1.start = after.start;
                d1.end = after.end;
                after = d1;
            }
            return [c1, before, after].filter(Boolean);
        }
    }
    return [c1, d1];
}
function shift(d1, d2, dir) {
    shiftPos(d1.start, d2.start, d2.end, dir);
    shiftPos(d1.end, d2.start, d2.end, dir);
}
function shiftPos(pos, start, end, dir) {
    if (pos.row == (dir == 1 ? start : end).row) {
        pos.column += dir * (end.column - start.column);
    }
    pos.row += dir * (end.row - start.row);
}
function splitDelta(c, pos) {
    var lines = c.lines;
    var end = c.end;
    c.end = clonePos(pos);
    var rowsBefore = c.end.row - c.start.row;
    var otherLines = lines.splice(rowsBefore, lines.length);
    var col = rowsBefore ? pos.column : pos.column - c.start.column;
    lines.push(otherLines[0].substring(0, col));
    otherLines[0] = otherLines[0].substr(col);
    var rest = {
        start: clonePos(pos),
        end: end,
        lines: otherLines,
        action: c.action
    };
    return rest;
}
function moveDeltasByOne(redoStack, d) {
    d = cloneDelta(d);
    for (var j = redoStack.length; j--;) {
        var deltaSet = redoStack[j];
        for (var i = 0; i < deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
                if (xformed[2]) {
                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                    i++;
                }
                else if (!xformed[1]) {
                    deltaSet.splice(i, 1);
                    i--;
                }
            }
        }
        if (!deltaSet.length) {
            redoStack.splice(j, 1);
        }
    }
    return redoStack;
}
function rebaseRedoStack(redoStack, deltaSets) {
    for (var i = 0; i < deltaSets.length; i++) {
        var deltas = deltaSets[i];
        for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
        }
    }
}
exports.UndoManager = UndoManager;

});

ace.define("ace/layer/lines",["require","exports","module","ace/lib/dom"], function(require, exports, module){"use strict";
var dom = require("../lib/dom");
var Lines = function (element, canvasHeight) {
    this.element = element;
    this.canvasHeight = canvasHeight || 500000;
    this.element.style.height = (this.canvasHeight * 2) + "px";
    this.cells = [];
    this.cellCache = [];
    this.$offsetCoefficient = 0;
};
(function () {
    this.moveContainer = function (config) {
        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);
    };
    this.pageChanged = function (oldConfig, newConfig) {
        return (Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==
            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight));
    };
    this.computeLineTop = function (row, config, session) {
        var screenTop = config.firstRowScreen * config.lineHeight;
        var screenPage = Math.floor(screenTop / this.canvasHeight);
        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
        return lineTop - (screenPage * this.canvasHeight);
    };
    this.computeLineHeight = function (row, config, session) {
        return config.lineHeight * session.getRowLineCount(row);
    };
    this.getLength = function () {
        return this.cells.length;
    };
    this.get = function (index) {
        return this.cells[index];
    };
    this.shift = function () {
        this.$cacheCell(this.cells.shift());
    };
    this.pop = function () {
        this.$cacheCell(this.cells.pop());
    };
    this.push = function (cell) {
        if (Array.isArray(cell)) {
            this.cells.push.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            this.element.appendChild(fragment);
        }
        else {
            this.cells.push(cell);
            this.element.appendChild(cell.element);
        }
    };
    this.unshift = function (cell) {
        if (Array.isArray(cell)) {
            this.cells.unshift.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
            }
            if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
            else
                this.element.appendChild(fragment);
        }
        else {
            this.cells.unshift(cell);
            this.element.insertAdjacentElement("afterbegin", cell.element);
        }
    };
    this.last = function () {
        if (this.cells.length)
            return this.cells[this.cells.length - 1];
        else
            return null;
    };
    this.$cacheCell = function (cell) {
        if (!cell)
            return;
        cell.element.remove();
        this.cellCache.push(cell);
    };
    this.createCell = function (row, config, session, initElement) {
        var cell = this.cellCache.pop();
        if (!cell) {
            var element = dom.createElement("div");
            if (initElement)
                initElement(element);
            this.element.appendChild(element);
            cell = {
                element: element,
                text: "",
                row: row
            };
        }
        cell.row = row;
        return cell;
    };
}).call(Lines.prototype);
exports.Lines = Lines;

});

ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/layer/lines"], function(require, exports, module){"use strict";
var dom = require("../lib/dom");
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var Lines = require("./lines").Lines;
var Gutter = function (parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    this.gutterWidth = 0;
    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);
    this.$lines = new Lines(this.element);
    this.$lines.$offsetCoefficient = 1;
};
(function () {
    oop.implement(this, EventEmitter);
    this.setSession = function (session) {
        if (this.session)
            this.session.off("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    };
    this.addGutterDecoration = function (row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function (row, className) {
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    };
    this.setAnnotations = function (annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [] };
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);
            var type = annotation.type;
            var className = annotation.className;
            if (className)
                rowInfo.className = className;
            else if (type == "error")
                rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
                rowInfo.className = " ace_info";
        }
    };
    this.$updateAnnotations = function (delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
        }
        else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
        }
        else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };
    this.update = function (config) {
        this.config = config;
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
        session.getLength() - 1);
        this.oldLastRow = lastRow;
        this.config = config;
        this.$lines.moveContainer(config);
        this.$updateCursorRow();
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                    this.$lines.pop();
                break;
            }
            cell = this.$lines.get(++index);
            if (cell) {
                cell.row = row;
            }
            else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
            }
            this.$renderCell(cell, config, fold, row);
            row++;
        }
        this._signal("afterRender");
        this.$updateGutterWidth(config);
    };
    this.$updateGutterWidth = function (config) {
        var session = this.session;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
        if (this.$fixedWidth || session.$useWrapMode)
            lastLineText = session.getLength() + firstLineNumber - 1;
        var gutterWidth = gutterRenderer
            ? gutterRenderer.getWidth(session, lastLineText, config)
            : lastLineText.toString().length * config.characterWidth;
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.parentNode.style.width =
                this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._signal("changeGutterWidth", gutterWidth);
        }
    };
    this.$updateCursorRow = function () {
        if (!this.$highlightGutterLine)
            return;
        var position = this.session.selection.getCursor();
        if (this.$cursorRow === position.row)
            return;
        this.$cursorRow = position.row;
    };
    this.updateLineHighlight = function () {
        if (!this.$highlightGutterLine)
            return;
        var row = this.session.selection.cursor.row;
        this.$cursorRow = row;
        if (this.$cursorCell && this.$cursorCell.row == row)
            return;
        if (this.$cursorCell)
            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
        var cells = this.$lines.cells;
        this.$cursorCell = null;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                    var fold = this.session.getFoldLine(this.$cursorRow);
                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                        cell = cells[i - 1];
                    else
                        break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
            }
        }
    };
    this.scrollLines = function (config) {
        var oldConfig = this.config;
        this.config = config;
        this.$updateCursorRow();
        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
        this.$lines.moveContainer(config);
        var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
        this.session.getLength() - 1);
        var oldLastRow = this.oldLastRow;
        this.oldLastRow = lastRow;
        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);
        if (lastRow < oldConfig.firstRow)
            return this.update(config);
        if (oldConfig.firstRow < config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
        if (oldLastRow > lastRow)
            for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
                this.$lines.pop();
        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
        }
        if (lastRow > oldLastRow) {
            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
        }
        this.updateLineHighlight();
        this._signal("afterRender");
        this.$updateGutterWidth(config);
    };
    this.$renderLines = function (config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;
            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
            this.$renderCell(cell, config, foldLine, row);
            fragment.push(cell);
            row++;
        }
        return fragment;
    };
    this.$renderCell = function (cell, config, fold, row) {
        var element = cell.element;
        var session = this.session;
        var textNode = element.childNodes[0];
        var foldWidget = element.childNodes[1];
        var firstLineNumber = session.$firstLineNumber;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var gutterRenderer = session.gutterRenderer || this.$renderer;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
        var className = "ace_gutter-cell ";
        if (this.$highlightGutterLine) {
            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row)) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                    if (this.$cursorCell)
                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                    this.$cursorCell = cell;
                }
            }
        }
        if (breakpoints[row])
            className += breakpoints[row];
        if (decorations[row])
            className += decorations[row];
        if (this.$annotations[row])
            className += this.$annotations[row].className;
        if (element.className != className)
            element.className = className;
        if (foldWidgets) {
            var c = foldWidgets[row];
            if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
        }
        if (c) {
            var className = "ace_fold-widget ace_" + c;
            if (c == "start" && row == foldStart && row < fold.end.row)
                className += " ace_closed";
            else
                className += " ace_open";
            if (foldWidget.className != className)
                foldWidget.className = className;
            var foldHeight = config.lineHeight + "px";
            dom.setStyle(foldWidget.style, "height", foldHeight);
            dom.setStyle(foldWidget.style, "display", "inline-block");
        }
        else {
            if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
            }
        }
        var text = (gutterRenderer
            ? gutterRenderer.getText(session, row)
            : row + firstLineNumber).toString();
        if (text !== textNode.data) {
            textNode.data = text;
        }
        dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
        dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
        cell.text = text;
        return cell;
    };
    this.$fixedWidth = false;
    this.$highlightGutterLine = true;
    this.$renderer = "";
    this.setHighlightGutterLine = function (highlightGutterLine) {
        this.$highlightGutterLine = highlightGutterLine;
    };
    this.$showLineNumbers = true;
    this.$renderer = "";
    this.setShowLineNumbers = function (show) {
        this.$renderer = !show && {
            getWidth: function () { return 0; },
            getText: function () { return ""; }
        };
    };
    this.getShowLineNumbers = function () {
        return this.$showLineNumbers;
    };
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function (show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");
        this.$showFoldWidgets = show;
        this.$padding = null;
    };
    this.getShowFoldWidgets = function () {
        return this.$showFoldWidgets;
    };
    this.$computePadding = function () {
        if (!this.element.firstChild)
            return { left: 0, right: 0 };
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)
            + (parseInt(style.paddingLeft) || 0) + 1;
        this.$padding.right = (parseInt(style.borderRightWidth) || 0)
            + (parseInt(style.paddingRight) || 0);
        return this.$padding;
    };
    this.getRegion = function (point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    };
}).call(Gutter.prototype);
function onCreateCell(element) {
    var textNode = document.createTextNode('');
    element.appendChild(textNode);
    var foldWidget = dom.createElement("span");
    element.appendChild(foldWidget);
    return element;
}
exports.Gutter = Gutter;

});

ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(require, exports, module){"use strict";
var Range = require("../range").Range;
var dom = require("../lib/dom");
var Marker = function (parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};
(function () {
    this.$padding = 0;
    this.setPadding = function (padding) {
        this.$padding = padding;
    };
    this.setSession = function (session) {
        this.session = session;
    };
    this.setMarkers = function (markers) {
        this.markers = markers;
    };
    this.elt = function (className, css) {
        var x = this.i != -1 && this.element.childNodes[this.i];
        if (!x) {
            x = document.createElement("div");
            this.element.appendChild(x);
            this.i = -1;
        }
        else {
            this.i++;
        }
        x.style.cssText = css;
        x.className = className;
    };
    this.update = function (config) {
        if (!config)
            return;
        this.config = config;
        this.i = 0;
        var html;
        for (var key in this.markers) {
            var marker = this.markers[key];
            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }
            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty())
                continue;
            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            }
            else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            }
            else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            }
            else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            }
            else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
        }
        if (this.i != -1) {
            while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
        }
    };
    this.$getTop = function (row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };
    function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0;
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br"
                + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
        }
    };
    this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";
        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
            var range1 = range.clone();
            range1.end.row = range1.start.row;
            range1.end.column = this.session.getLine(range1.start.row).length;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
        }
        else {
            this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;" + "right:0;" + "top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
        }
        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
            var range1 = range.clone();
            range1.start.row = range1.end.row;
            range1.start.column = 0;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
        }
        else {
            top = this.$getTop(range.end.row, config);
            var width = range.end.column * config.characterWidth;
            this.elt(clazz + " ace_br12", "height:" + height + "px;" +
                "width:" + width + "px;" +
                "top:" + top + "px;" +
                "left:" + padding + "px;" + (extraStyle || ""));
        }
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
        this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;" +
            "right:0;" +
            "top:" + top + "px;" +
            "left:" + padding + "px;" + (extraStyle || ""));
    };
    this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
        if (this.session.$bidiHandler.isBidiRow(range.start.row))
            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;
        this.elt(clazz, "height:" + height + "px;" +
            "width:" + width + "px;" +
            "top:" + top + "px;" +
            "left:" + left + "px;" + (extraStyle || ""));
    };
    this.drawBidiSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
        selections.forEach(function (selection) {
            this.elt(clazz, "height:" + height + "px;" +
                "width:" + (selection.width + (extraLength || 0)) + "px;" +
                "top:" + top + "px;" +
                "left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
        }, this);
    };
    this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;
        this.elt(clazz, "height:" + height + "px;" +
            "top:" + top + "px;" +
            "left:0;right:0;" + (extraStyle || ""));
    };
    this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        this.elt(clazz, "height:" + height + "px;" +
            "top:" + top + "px;" +
            "left:0;right:0;" + (extraStyle || ""));
    };
}).call(Marker.prototype);
exports.Marker = Marker;

});

ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/layer/lines","ace/lib/event_emitter"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var Lines = require("./lines").Lines;
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var Text = function (parentEl) {
    this.dom = dom;
    this.element = this.dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
    this.$lines = new Lines(this.element);
};
(function () {
    oop.implement(this, EventEmitter);
    this.EOF_CHAR = "\xB6";
    this.EOL_CHAR_LF = "\xAC";
    this.EOL_CHAR_CRLF = "\xa4";
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = "\u2014"; //"\u21E5";
    this.SPACE_CHAR = "\xB7";
    this.$padding = 0;
    this.MAX_LINE_LENGTH = 10000;
    this.$updateEolChar = function () {
        var doc = this.session.doc;
        var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    };
    this.setPadding = function (padding) {
        this.$padding = padding;
        this.element.style.margin = "0 " + padding + "px";
    };
    this.getLineHeight = function () {
        return this.$fontMetrics.$characterSize.height || 0;
    };
    this.getCharacterWidth = function () {
        return this.$fontMetrics.$characterSize.width || 0;
    };
    this.$setFontMetrics = function (measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function (e) {
            this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    };
    this.checkForSizeChanges = function () {
        this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function () {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function (session) {
        this.session = session;
        if (session)
            this.$computeTabString();
    };
    this.showInvisibles = false;
    this.showSpaces = false;
    this.showTabs = false;
    this.showEOL = false;
    this.setShowInvisibles = function (showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;
        this.showInvisibles = showInvisibles;
        if (typeof showInvisibles == "string") {
            this.showSpaces = /tab/i.test(showInvisibles);
            this.showTabs = /space/i.test(showInvisibles);
            this.showEOL = /eol/i.test(showInvisibles);
        }
        else {
            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
        }
        this.$computeTabString();
        return true;
    };
    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function (display) {
        if (this.displayIndentGuides == display)
            return false;
        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };
    this.$highlightIndentGuides = true;
    this.setHighlightIndentGuides = function (highlight) {
        if (this.$highlightIndentGuides === highlight)
            return false;
        this.$highlightIndentGuides = highlight;
        return highlight;
    };
    this.$tabStrings = [];
    this.onChangeTabSize =
        this.$computeTabString = function () {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i < tabSize + 1; i++) {
                if (this.showTabs) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_tab";
                    span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                    tabStr.push(span);
                }
                else {
                    tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
                }
            }
            if (this.displayIndentGuides) {
                this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                var className = "ace_indent-guide";
                var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
                var spaceContent = this.showSpaces
                    ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize)
                    : lang.stringRepeat(" ", this.tabSize);
                var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
                var tabContent = this.showTabs
                    ? lang.stringRepeat(this.TAB_CHAR, this.tabSize)
                    : spaceContent;
                var span = this.dom.createElement("span");
                span.className = className + spaceClass;
                span.textContent = spaceContent;
                this.$tabStrings[" "] = span;
                var span = this.dom.createElement("span");
                span.className = className + tabClass;
                span.textContent = tabContent;
                this.$tabStrings["\t"] = span;
            }
        };
    this.updateLines = function (config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            return this.update(config);
        }
        this.config = config;
        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);
        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;
        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                }
                else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx++;
        }
        var heightChanged = false;
        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > last)
                break;
            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                if (heightChanged)
                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
                var height = (config.lineHeight * this.session.getRowLength(row)) + "px";
                if (lineElement.style.height != height) {
                    heightChanged = true;
                    lineElement.style.height = height;
                }
            }
            row++;
        }
        if (heightChanged) {
            while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
            }
        }
    };
    this.scrollLines = function (config) {
        var oldConfig = this.config;
        this.config = config;
        if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
        this.$lines.moveContainer(config);
        var lastRow = config.lastRow;
        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
        if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);
        if (lastRow < oldConfig.firstRow)
            return this.update(config);
        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);
        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);
        if (oldConfig.firstRow < config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
        if (oldConfig.lastRow > config.lastRow)
            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                this.$lines.pop();
        if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
        }
        if (config.lastRow > oldConfig.lastRow) {
            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
        }
        this.$highlightIndentGuide();
    };
    this.$renderLinesFragment = function (config, firstRow, lastRow) {
        var fragment = [];
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;
            var line = this.$lines.createCell(row, config, this.session);
            var lineEl = line.element;
            this.dom.removeChildren(lineEl);
            dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
            dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
            if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
            }
            else {
                lineEl.className = "ace_line";
            }
            fragment.push(line);
            row++;
        }
        return fragment;
    };
    this.update = function (config) {
        this.$lines.moveContainer(config);
        this.config = config;
        var firstRow = config.firstRow;
        var lastRow = config.lastRow;
        var lines = this.$lines;
        while (lines.getLength())
            lines.pop();
        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
    };
    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };
    this.$renderToken = function (parent, screenColumn, token, value) {
        var self = this;
        var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
        var valueFragment = this.dom.createFragment(this.element);
        var m;
        var i = 0;
        while (m = re.exec(value)) {
            var tab = m[1];
            var simpleSpace = m[2];
            var controlCharacter = m[3];
            var cjkSpace = m[4];
            var cjk = m[5];
            if (!self.showSpaces && simpleSpace)
                continue;
            var before = i != m.index ? value.slice(i, m.index) : "";
            i = m.index + m[0].length;
            if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
            }
            if (tab) {
                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);
                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
            }
            else if (simpleSpace) {
                if (self.showSpaces) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_space";
                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);
                    valueFragment.appendChild(span);
                }
                else {
                    valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
                }
            }
            else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
            }
            else if (cjkSpace) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = self.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self.showSpaces ? self.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
            }
            else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = (self.config.characterWidth * 2) + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
            }
        }
        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var span = this.dom.createElement("span");
            if (token.type == "fold")
                span.style.width = (token.value.length * this.config.characterWidth) + "px";
            span.className = classes;
            span.appendChild(valueFragment);
            parent.appendChild(span);
        }
        else {
            parent.appendChild(valueFragment);
        }
        return screenColumn + value.length;
    };
    this.renderIndentGuide = function (parent, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            var count = cols / this.tabSize;
            for (var i = 0; i < count; i++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        }
        else if (value[0] == "\t") {
            for (var i = 0; i < cols; i++) {
                parent.appendChild(this.$tabStrings["\t"].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
        }
        this.$highlightIndentGuide();
        return value;
    };
    this.$highlightIndentGuide = function () {
        if (!this.$highlightIndentGuides || !this.displayIndentGuides)
            return;
        this.$highlightIndentGuideMarker = {
            indentLevel: undefined,
            start: undefined,
            end: undefined,
            dir: undefined
        };
        var lines = this.session.doc.$lines;
        if (!lines)
            return;
        var cursor = this.session.selection.getCursor();
        var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
        var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
        this.$highlightIndentGuideMarker = {
            indentLevel: elementIndentLevel,
            start: cursor.row
        };
        var bracketHighlight = this.session.$bracketHighlight;
        if (bracketHighlight) {
            var ranges = this.session.$bracketHighlight.ranges;
            for (var i = 0; i < ranges.length; i++) {
                if (cursor.row !== ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.end = ranges[i].start.row;
                    if (cursor.row > ranges[i].start.row) {
                        this.$highlightIndentGuideMarker.dir = -1;
                    }
                    else {
                        this.$highlightIndentGuideMarker.dir = 1;
                    }
                    break;
                }
            }
        }
        if (!this.$highlightIndentGuideMarker.end) {
            if (lines[cursor.row] !== '' && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i = cursor.row + 1; i < lines.length; i++) {
                    var line = lines[i];
                    var currentIndent = /^\s*/.exec(line)[0].length;
                    if (line !== '') {
                        this.$highlightIndentGuideMarker.end = i;
                        if (currentIndent <= initialIndent)
                            break;
                    }
                }
            }
        }
        this.$renderHighlightIndentGuide();
    };
    this.$clearActiveIndentGuide = function () {
        var cells = this.$lines.cells;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            var childNodes = cell.element.childNodes;
            if (childNodes.length > 0) {
                for (var j = 0; j < childNodes.length; j++) {
                    if (childNodes[j].classList && childNodes[j].classList.contains("ace_indent-guide-active")) {
                        childNodes[j].classList.remove("ace_indent-guide-active");
                        break;
                    }
                }
            }
        }
    };
    this.$setIndentGuideActive = function (cell, indentLevel) {
        var line = this.session.doc.getLine(cell.row);
        if (line !== "") {
            var childNodes = cell.element.childNodes;
            if (childNodes) {
                var node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide"))
                    node.classList.add("ace_indent-guide-active");
            }
        }
    };
    this.$renderHighlightIndentGuide = function () {
        if (!this.$lines)
            return;
        var cells = this.$lines.cells;
        this.$clearActiveIndentGuide();
        var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
        if (indentLevel !== 0) {
            if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i = 0; i < cells.length; i++) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start
                        + 1) {
                        if (cell.row >= this.$highlightIndentGuideMarker.end)
                            break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
            else {
                for (var i = cells.length - 1; i >= 0; i--) {
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                        if (cell.row <= this.$highlightIndentGuideMarker.end)
                            break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
        }
    };
    this.$createLineElement = function (parent) {
        var lineEl = this.dom.createElement("div");
        lineEl.className = "ace_line";
        lineEl.style.height = this.config.lineHeight + "px";
        return lineEl;
    };
    this.$renderWrappedLine = function (parent, tokens, splits) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;
        var lineEl = this.$createLineElement();
        parent.appendChild(lineEl);
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }
            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
            }
            else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                    value = value.substring(splitChars - chars);
                    chars = splitChars;
                    lineEl = this.$createLineElement();
                    parent.appendChild(lineEl);
                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element));
                    split++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                }
            }
        }
        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
            this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
    };
    this.$renderSimpleLine = function (parent, tokens) {
        var screenColumn = 0;
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                    continue;
            }
            if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
            screenColumn = this.$renderToken(parent, screenColumn, token, value);
        }
    };
    this.$renderOverflowMessage = function (parent, screenColumn, token, value, hide) {
        token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
        var overflowEl = this.dom.createElement("span");
        overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
        overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
        parent.appendChild(overflowEl);
    };
    this.$renderLine = function (parent, row, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);
        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);
        var lastLineEl = parent;
        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
            }
            else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                    lastLineEl = this.$createLineElement();
                    parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
            }
        }
        else if (this.$useLineGroups()) {
            lastLineEl = this.$createLineElement();
            parent.appendChild(lastLineEl);
        }
        if (this.showEOL && lastLineEl) {
            if (foldLine)
                row = foldLine.end.row;
            var invisibleEl = this.dom.createElement("span");
            invisibleEl.className = "ace_invisible ace_invisible_eol";
            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
            lastLineEl.appendChild(invisibleEl);
        }
    };
    this.$getFoldLineTokens = function (row, foldLine) {
        var session = this.session;
        var renderTokens = [];
        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;
                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                if (value.length > (to - from))
                    value = value.substring(0, to - from);
                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });
                col = from + value.length;
                idx += 1;
            }
            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                }
                else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }
        var tokens = session.getTokens(row);
        foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            }
            else {
                if (isNewRow)
                    tokens = session.getTokens(row);
                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
        return renderTokens;
    };
    this.$useLineGroups = function () {
        return this.session.getUseWrapMode();
    };
    this.destroy = function () { };
}).call(Text.prototype);
exports.Text = Text;

});

ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(require, exports, module){"use strict";
var dom = require("../lib/dom");
var Cursor = function (parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);
    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;
    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
    this.$updateCursors = this.$updateOpacity.bind(this);
};
(function () {
    this.$updateOpacity = function (val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--;)
            dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
    };
    this.$startCssAnimation = function () {
        var cursors = this.cursors;
        for (var i = cursors.length; i--;)
            cursors[i].style.animationDuration = this.blinkInterval + "ms";
        this.$isAnimating = true;
        setTimeout(function () {
            if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
            }
        }.bind(this));
    };
    this.$stopCssAnimation = function () {
        this.$isAnimating = false;
        dom.removeCssClass(this.element, "ace_animate-blinking");
    };
    this.$padding = 0;
    this.setPadding = function (padding) {
        this.$padding = padding;
    };
    this.setSession = function (session) {
        this.session = session;
    };
    this.setBlinking = function (blinking) {
        if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };
    this.setBlinkInterval = function (blinkInterval) {
        if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };
    this.setSmoothBlinking = function (smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.restartTimer();
        }
    };
    this.addCursor = function () {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };
    this.removeCursor = function () {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };
    this.hideCursor = function () {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };
    this.showCursor = function () {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };
    this.restartTimer = function () {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        this.$stopCssAnimation();
        if (this.smoothBlinking) {
            this.$isSmoothBlinking = false;
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        update(true);
        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
            this.$stopCssAnimation();
            return;
        }
        if (this.smoothBlinking) {
            this.$isSmoothBlinking = true;
            setTimeout(function () {
                if (this.$isSmoothBlinking) {
                    dom.addCssClass(this.element, "ace_smooth-blinking");
                }
            }.bind(this));
        }
        if (dom.HAS_CSS_ANIMATION) {
            this.$startCssAnimation();
        }
        else {
            var blink = function () {
                this.timeoutId = setTimeout(function () {
                    update(false);
                }, 0.6 * this.blinkInterval);
            }.bind(this);
            this.intervalId = setInterval(function () {
                update(true);
                blink();
            }, this.blinkInterval);
            blink();
        }
    };
    this.getPixelPosition = function (position, onScreen) {
        if (!this.config || !this.session)
            return { left: 0, top: 0 };
        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : pos.column * this.config.characterWidth);
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;
        return { left: cursorLeft, top: cursorTop };
    };
    this.isCursorInView = function (pixelPos, config) {
        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
    };
    this.update = function (config) {
        this.config = config;
        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;
        if (selections === undefined || selections.length === 0) {
            selections = [{ cursor: null }];
        }
        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                pixelPos.top < 0) && i > 1) {
                continue;
            }
            var element = this.cursors[cursorIndex++] || this.addCursor();
            var style = element.style;
            if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                    dom.setStyle(style, "display", "none");
                }
                else {
                    dom.setStyle(style, "display", "block");
                    dom.translate(element, pixelPos.left, pixelPos.top);
                    dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                    dom.setStyle(style, "height", config.lineHeight + "px");
                }
            }
            else {
                this.drawCursor(element, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();
        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };
    this.drawCursor = null;
    this.$setOverwrite = function (overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    };
    this.destroy = function () {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };
}).call(Cursor.prototype);
exports.Cursor = Cursor;

});

ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var MAX_SCROLL_H = 0x8000;
var ScrollBar = function (parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.inner.textContent = "\xa0";
    this.element.appendChild(this.inner);
    parent.appendChild(this.element);
    this.setVisible(false);
    this.skipEvent = false;
    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
};
(function () {
    oop.implement(this, EventEmitter);
    this.setVisible = function (isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;
    renderer.$scrollbarWidth =
        this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
        this.element.style.width = (this.width || 15) + 5 + "px";
    this.$minWidth = 0;
};
oop.inherits(VScrollBar, ScrollBar);
(function () {
    this.classSuffix = '-v';
    this.onScroll = function () {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", { data: this.scrollTop });
        }
        this.skipEvent = false;
    };
    this.getWidth = function () {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    };
    this.setHeight = function (height) {
        this.element.style.height = height + "px";
    };
    this.setInnerHeight =
        this.setScrollHeight = function (height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
                this.coeff = MAX_SCROLL_H / height;
                height = MAX_SCROLL_H;
            }
            else if (this.coeff != 1) {
                this.coeff = 1;
            }
            this.inner.style.height = height + "px";
        };
    this.setScrollTop = function (scrollTop) {
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
        }
    };
}).call(VScrollBar.prototype);
var HScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
        this.element.style.height = (this.height || 15) + 5 + "px";
};
oop.inherits(HScrollBar, ScrollBar);
(function () {
    this.classSuffix = '-h';
    this.onScroll = function () {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", { data: this.scrollLeft });
        }
        this.skipEvent = false;
    };
    this.getHeight = function () {
        return this.isVisible ? this.height : 0;
    };
    this.setWidth = function (width) {
        this.element.style.width = width + "px";
    };
    this.setInnerWidth = function (width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollWidth = function (width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollLeft = function (scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };
}).call(HScrollBar.prototype);
exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility
exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;

});

ace.define("ace/scrollbar_custom",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
var ScrollBar = function (parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_sb" + this.classSuffix;
    this.inner = dom.createElement("div");
    this.inner.className = "";
    this.element.appendChild(this.inner);
    this.VScrollWidth = 12;
    this.HScrollHeight = 12;
    parent.appendChild(this.element);
    this.setVisible(false);
    this.skipEvent = false;
    event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
};
(function () {
    oop.implement(this, EventEmitter);
    this.setVisible = function (isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;
    this.parent = parent;
    this.width = this.VScrollWidth;
    this.renderer = renderer;
    this.inner.style.width = this.element.style.width = (this.width || 15) + "px";
    this.$minWidth = 0;
};
oop.inherits(VScrollBar, ScrollBar);
(function () {
    this.classSuffix = '-v';
    oop.implement(this, EventEmitter);
    this.onMouseDown = function (eType, e) {
        if (eType !== "mousedown")
            return;
        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }
        if (e.target === this.inner) {
            var self = this;
            var mousePageY = e.clientY;
            var onMouseMove = function (e) {
                mousePageY = e.clientY;
            };
            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startY = e.clientY;
            var startTop = this.thumbTop;
            var onScrollInterval = function () {
                if (mousePageY === undefined)
                    return;
                var scrollTop = self.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self.scrollTop)
                    return;
                self._emit("scroll", { data: scrollTop });
            };
            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }
        var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
        this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
        return event.preventDefault(e);
    };
    this.getHeight = function () {
        return this.height;
    };
    this.scrollTopFromThumbTop = function (thumbTop) {
        var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
        scrollTop = scrollTop >> 0;
        if (scrollTop < 0) {
            scrollTop = 0;
        }
        else if (scrollTop > this.pageHeight - this.viewHeight) {
            scrollTop = this.pageHeight - this.viewHeight;
        }
        return scrollTop;
    };
    this.getWidth = function () {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    };
    this.setHeight = function (height) {
        this.height = Math.max(0, height);
        this.slideHeight = this.height;
        this.viewHeight = this.height;
        this.setScrollHeight(this.pageHeight, true);
    };
    this.setInnerHeight = this.setScrollHeight = function (height, force) {
        if (this.pageHeight === height && !force)
            return;
        this.pageHeight = height;
        this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
        if (this.thumbHeight > this.slideHeight)
            this.thumbHeight = this.slideHeight;
        if (this.thumbHeight < 15)
            this.thumbHeight = 15;
        this.inner.style.height = this.thumbHeight + "px";
        if (this.scrollTop > (this.pageHeight - this.viewHeight)) {
            this.scrollTop = (this.pageHeight - this.viewHeight);
            if (this.scrollTop < 0)
                this.scrollTop = 0;
            this._emit("scroll", { data: this.scrollTop });
        }
    };
    this.setScrollTop = function (scrollTop) {
        this.scrollTop = scrollTop;
        if (scrollTop < 0)
            scrollTop = 0;
        this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
        this.inner.style.top = this.thumbTop + "px";
    };
}).call(VScrollBar.prototype);
var HScrollBar = function (parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.scrollWidth = 0;
    this.height = this.HScrollHeight;
    this.inner.style.height = this.element.style.height = (this.height || 12) + "px";
    this.renderer = renderer;
};
oop.inherits(HScrollBar, ScrollBar);
(function () {
    this.classSuffix = '-h';
    oop.implement(this, EventEmitter);
    this.onMouseDown = function (eType, e) {
        if (eType !== "mousedown")
            return;
        if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
        }
        if (e.target === this.inner) {
            var self = this;
            var mousePageX = e.clientX;
            var onMouseMove = function (e) {
                mousePageX = e.clientX;
            };
            var onMouseUp = function () {
                clearInterval(timerId);
            };
            var startX = e.clientX;
            var startLeft = this.thumbLeft;
            var onScrollInterval = function () {
                if (mousePageX === undefined)
                    return;
                var scrollLeft = self.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self.scrollLeft)
                    return;
                self._emit("scroll", { data: scrollLeft });
            };
            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
        }
        var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
        this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
        return event.preventDefault(e);
    };
    this.getHeight = function () {
        return this.isVisible ? this.height : 0;
    };
    this.scrollLeftFromThumbLeft = function (thumbLeft) {
        var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
        scrollLeft = scrollLeft >> 0;
        if (scrollLeft < 0) {
            scrollLeft = 0;
        }
        else if (scrollLeft > this.pageWidth - this.viewWidth) {
            scrollLeft = this.pageWidth - this.viewWidth;
        }
        return scrollLeft;
    };
    this.setWidth = function (width) {
        this.width = Math.max(0, width);
        this.element.style.width = this.width + "px";
        this.slideWidth = this.width;
        this.viewWidth = this.width;
        this.setScrollWidth(this.pageWidth, true);
    };
    this.setInnerWidth = this.setScrollWidth = function (width, force) {
        if (this.pageWidth === width && !force)
            return;
        this.pageWidth = width;
        this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
        if (this.thumbWidth > this.slideWidth)
            this.thumbWidth = this.slideWidth;
        if (this.thumbWidth < 15)
            this.thumbWidth = 15;
        this.inner.style.width = this.thumbWidth + "px";
        if (this.scrollLeft > (this.pageWidth - this.viewWidth)) {
            this.scrollLeft = (this.pageWidth - this.viewWidth);
            if (this.scrollLeft < 0)
                this.scrollLeft = 0;
            this._emit("scroll", { data: this.scrollLeft });
        }
    };
    this.setScrollLeft = function (scrollLeft) {
        this.scrollLeft = scrollLeft;
        if (scrollLeft < 0)
            scrollLeft = 0;
        this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
        this.inner.style.left = (this.thumbLeft) + "px";
    };
}).call(HScrollBar.prototype);
exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility
exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;

});

ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(require, exports, module){"use strict";
var event = require("./lib/event");
var RenderLoop = function (onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.$recursionLimit = 2;
    this.window = win || window;
    var _self = this;
    this._flush = function (ts) {
        _self.pending = false;
        var changes = _self.changes;
        if (changes) {
            event.blockIdle(100);
            _self.changes = 0;
            _self.onRender(changes);
        }
        if (_self.changes) {
            if (_self.$recursionLimit-- < 0)
                return;
            _self.schedule();
        }
        else {
            _self.$recursionLimit = 2;
        }
    };
};
(function () {
    this.schedule = function (change) {
        this.changes = this.changes | change;
        if (this.changes && !this.pending) {
            event.nextFrame(this._flush);
            this.pending = true;
        }
    };
    this.clear = function (change) {
        var changes = this.changes;
        this.changes = 0;
        return changes;
    };
}).call(RenderLoop.prototype);
exports.RenderLoop = RenderLoop;

});

ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/lib/useragent","ace/lib/event_emitter"], function(require, exports, module){var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var event = require("../lib/event");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var CHAR_COUNT = 512;
var USE_OBSERVER = typeof ResizeObserver == "function";
var L = 200;
var FontMetrics = exports.FontMetrics = function (parentEl) {
    this.el = dom.createElement("div");
    this.$setMeasureNodeStyles(this.el.style, true);
    this.$main = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$main.style);
    this.$measureNode = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$measureNode.style);
    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);
    this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
    this.$characterSize = { width: 0, height: 0 };
    if (USE_OBSERVER)
        this.$addObserver();
    else
        this.checkForSizeChanges();
};
(function () {
    oop.implement(this, EventEmitter);
    this.$characterSize = { width: 0, height: 0 };
    this.$setMeasureNodeStyles = function (style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";
        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        }
        else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    };
    this.checkForSizeChanges = function (size) {
        if (size === undefined)
            size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", { data: size });
        }
    };
    this.$addObserver = function () {
        var self = this;
        this.$observer = new window.ResizeObserver(function (e) {
            self.checkForSizeChanges();
        });
        this.$observer.observe(this.$measureNode);
    };
    this.$pollSizeChanges = function () {
        if (this.$pollSizeChangesTimer || this.$observer)
            return this.$pollSizeChangesTimer;
        var self = this;
        return this.$pollSizeChangesTimer = event.onIdle(function cb() {
            self.checkForSizeChanges();
            event.onIdle(cb, 500);
        }, 500);
    };
    this.setPolling = function (val) {
        if (val) {
            this.$pollSizeChanges();
        }
        else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    };
    this.$measureSizes = function (node) {
        var size = {
            height: (node || this.$measureNode).clientHeight,
            width: (node || this.$measureNode).clientWidth / CHAR_COUNT
        };
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    };
    this.$measureCharWidth = function (ch) {
        this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    };
    this.getCharacterWidth = function (ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    };
    this.destroy = function () {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$observer)
            this.$observer.disconnect();
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    };
    this.$getZoom = function getZoom(element) {
        if (!element || !element.parentElement)
            return 1;
        return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);
    };
    this.$initTransformMeasureNodes = function () {
        var t = function (t, l) {
            return ["div", {
                    style: "position: absolute;top:" + t + "px;left:" + l + "px;"
                }];
        };
        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
    };
    this.transformCoordinates = function (clientPos, elPos) {
        if (clientPos) {
            var zoom = this.$getZoom(this.el);
            clientPos = mul(1 / zoom, clientPos);
        }
        function solve(l1, l2, r) {
            var det = l1[1] * l2[0] - l1[0] * l2[1];
            return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
            ];
        }
        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }
        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }
        function mul(a, b) { return [a * b[0], a * b[1]]; }
        if (!this.els)
            this.$initTransformMeasureNodes();
        function p(el) {
            var r = el.getBoundingClientRect();
            return [r.left, r.top];
        }
        var a = p(this.els[0]);
        var b = p(this.els[1]);
        var c = p(this.els[2]);
        var d = p(this.els[3]);
        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
        var m1 = mul(1 + h[0], sub(b, a));
        var m2 = mul(1 + h[1], sub(c, a));
        if (elPos) {
            var x = elPos;
            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
            var ut = add(mul(x[0], m1), mul(x[1], m2));
            return add(mul(1 / k / L, ut), a);
        }
        var u = sub(clientPos, a);
        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
        return mul(L, f);
    };
}).call(FontMetrics.prototype);

});

ace.define("ace/css/editor.css",["require","exports","module"], function(require, exports, module){/*
styles = []
for (var i = 1; i < 16; i++) {
    styles.push(".ace_br" + i + "{" + (
        ["top-left", "top-right", "bottom-right", "bottom-left"]
    ).map(function(x, j) {
        return i & (1<<j) ? "border-" + x + "-radius: 3px;" : ""
    }).filter(Boolean).join(" ") + "}")
}
styles.join("\\n")
*/
module.exports = "\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n\n\n.ace_editor {\n    position: relative;\n    overflow: hidden;\n    padding: 0;\n    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\n    direction: ltr;\n    text-align: left;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    box-sizing: border-box;\n    min-width: 100%;\n    contain: style size layout;\n    font-variant-ligatures: no-common-ligatures;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: '';\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    contain: style size layout;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left:after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n    pointer-events: none;\n}\n\n.ace_gutter-cell {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell.ace_error {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\n    background-position: 2px center;\n}\n.ace_dark .ace_gutter-cell.ace_info {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\n}\n\n.ace_scrollbar {\n    contain: strict;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    contain: strict;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\n    white-space: pre!important;\n}\n.ace_text-input.ace_composition {\n    background: transparent;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n}\n.ace_composition_placeholder { color: transparent }\n.ace_composition_marker { \n    border-bottom: 1px solid;\n    position: absolute;\n    border-radius: 0;\n    margin-top: 1px;\n}\n\n[ace_nocontext=true] {\n    transform: none!important;\n    filter: none!important;\n    clip-path: none!important;\n    mask : none!important;\n    contain: none!important;\n    perspective: none!important;\n    mix-blend-mode: initial!important;\n    z-index: auto;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n    height: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n    position: absolute;\n    height: 1000000px;\n    width: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\n    contain: style size layout;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n}\n\n.ace_hidpi .ace_text-layer,\n.ace_hidpi .ace_gutter-layer,\n.ace_hidpi .ace_content,\n.ace_hidpi .ace_gutter {\n    contain: strict;\n    will-change: transform;\n}\n.ace_hidpi .ace_text-layer > .ace_line, \n.ace_hidpi .ace_text-layer > .ace_line_group {\n    contain: strict;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\n    opacity: 0;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    transition: opacity 0.18s;\n}\n\n.ace_animate-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: step-end;\n    animation-name: blink-ace-animate;\n    animation-iteration-count: infinite;\n}\n\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: ease-in-out;\n    animation-name: blink-ace-animate-smooth;\n}\n    \n@keyframes blink-ace-animate {\n    from, to { opacity: 1; }\n    60% { opacity: 0; }\n}\n\n@keyframes blink-ace-animate-smooth {\n    from, to { opacity: 1; }\n    45% { opacity: 1; }\n    60% { opacity: 0; }\n    85% { opacity: 0; }\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_error_bracket {\n    position: absolute;\n    border-bottom: 1px solid #DE5555;\n    border-radius: 0;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\n        url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\n}\n\n.ace_tooltip {\n    background-color: #FFF;\n    background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    max-width: 100%;\n    padding: 3px 4px;\n    position: fixed;\n    z-index: 999999;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n}\n\n.ace_folding-enabled > .ace_gutter-cell {\n    padding-right: 13px;\n}\n\n.ace_fold-widget {\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_inline_button {\n    border: 1px solid lightgray;\n    display: inline-block;\n    margin: -1px 8px;\n    padding: 0 5px;\n    pointer-events: auto;\n    cursor: pointer;\n}\n.ace_inline_button:hover {\n    border-color: gray;\n    background: rgba(200,200,200,0.2);\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n.ace_mobile-menu {\n    position: absolute;\n    line-height: 1.5;\n    border-radius: 4px;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    background: white;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #dcdcdc;\n    color: black;\n}\n.ace_dark > .ace_mobile-menu {\n    background: #333;\n    color: #ccc;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #444;\n\n}\n.ace_mobile-button {\n    padding: 2px;\n    cursor: pointer;\n    overflow: hidden;\n}\n.ace_mobile-button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_mobile-button:active {\n    background-color: #ddd;\n}\n\n.ace_placeholder {\n    font-family: arial;\n    transform: scale(0.9);\n    transform-origin: left;\n    white-space: pre;\n    opacity: 0.7;\n    margin: 0 10px;\n}\n\n.ace_ghost_text {\n    opacity: 0.5;\n    font-style: italic;\n}";

});

ace.define("ace/layer/decorators",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event_emitter"], function(require, exports, module){"use strict";
var dom = require("../lib/dom");
var oop = require("../lib/oop");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var Decorator = function (parent, renderer) {
    this.canvas = dom.createElement("canvas");
    this.renderer = renderer;
    this.pixelRatio = 1;
    this.maxHeight = renderer.layerConfig.maxHeight;
    this.lineHeight = renderer.layerConfig.lineHeight;
    this.canvasHeight = parent.parent.scrollHeight;
    this.heightRatio = this.canvasHeight / this.maxHeight;
    this.canvasWidth = parent.width;
    this.minDecorationHeight = (2 * this.pixelRatio) | 0;
    this.halfMinDecorationHeight = (this.minDecorationHeight / 2) | 0;
    this.canvas.width = this.canvasWidth;
    this.canvas.height = this.canvasHeight;
    this.canvas.style.top = 0 + "px";
    this.canvas.style.right = 0 + "px";
    this.canvas.style.zIndex = 7 + "px";
    this.canvas.style.position = "absolute";
    this.colors = {};
    this.colors.dark = {
        "error": "rgba(255, 18, 18, 1)",
        "warning": "rgba(18, 136, 18, 1)",
        "info": "rgba(18, 18, 136, 1)"
    };
    this.colors.light = {
        "error": "rgb(255,51,51)",
        "warning": "rgb(32,133,72)",
        "info": "rgb(35,68,138)"
    };
    parent.element.appendChild(this.canvas);
};
(function () {
    oop.implement(this, EventEmitter);
    this.$updateDecorators = function (config) {
        var colors = (this.renderer.theme.isDark === true) ? this.colors.dark : this.colors.light;
        if (config) {
            this.maxHeight = config.maxHeight;
            this.lineHeight = config.lineHeight;
            this.canvasHeight = config.height;
            var allLineHeight = (config.lastRow + 1) * this.lineHeight;
            if (allLineHeight < this.canvasHeight) {
                this.heightRatio = 1;
            }
            else {
                this.heightRatio = this.canvasHeight / this.maxHeight;
            }
        }
        var ctx = this.canvas.getContext("2d");
        function compare(a, b) {
            if (a.priority < b.priority)
                return -1;
            if (a.priority > b.priority)
                return 1;
            return 0;
        }
        var annotations = this.renderer.session.$annotations;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (annotations) {
            var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
            };
            annotations.forEach(function (item) {
                item.priority = priorities[item.type] || null;
            });
            annotations = annotations.sort(compare);
            var foldData = this.renderer.session.$foldData;
            for (var i = 0; i < annotations.length; i++) {
                var row = annotations[i].row;
                var compensateFold = this.compensateFoldRows(row, foldData);
                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y1 = Math.round(((row - compensateFold) * this.lineHeight * this.heightRatio));
                var y2 = Math.round((((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio));
                var height = y2 - y1;
                if (height < this.minDecorationHeight) {
                    var yCenter = ((y1 + y2) / 2) | 0;
                    if (yCenter < this.halfMinDecorationHeight) {
                        yCenter = this.halfMinDecorationHeight;
                    }
                    else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {
                        yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                    }
                    y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                    y2 = Math.round(yCenter + this.halfMinDecorationHeight);
                }
                ctx.fillStyle = colors[annotations[i].type] || null;
                ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);
            }
        }
        var cursor = this.renderer.session.selection.getCursor();
        if (cursor) {
            var compensateFold = this.compensateFoldRows(cursor.row, foldData);
            var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, currentY, this.canvasWidth, 2);
        }
    };
    this.compensateFoldRows = function (row, foldData) {
        var compensateFold = 0;
        if (foldData && foldData.length > 0) {
            for (var j = 0; j < foldData.length; j++) {
                if (row > foldData[j].start.row && row < foldData[j].end.row) {
                    compensateFold += row - foldData[j].start.row;
                }
                else if (row >= foldData[j].end.row) {
                    compensateFold += foldData[j].end.row - foldData[j].start.row;
                }
            }
        }
        return compensateFold;
    };
}.call(Decorator.prototype));
exports.Decorator = Decorator;

});

ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/scrollbar_custom","ace/scrollbar_custom","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter","ace/css/editor.css","ace/layer/decorators","ace/lib/useragent"], function(require, exports, module){"use strict";
var oop = require("./lib/oop");
var dom = require("./lib/dom");
var config = require("./config");
var GutterLayer = require("./layer/gutter").Gutter;
var MarkerLayer = require("./layer/marker").Marker;
var TextLayer = require("./layer/text").Text;
var CursorLayer = require("./layer/cursor").Cursor;
var HScrollBar = require("./scrollbar").HScrollBar;
var VScrollBar = require("./scrollbar").VScrollBar;
var HScrollBarCustom = require("./scrollbar_custom").HScrollBar;
var VScrollBarCustom = require("./scrollbar_custom").VScrollBar;
var RenderLoop = require("./renderloop").RenderLoop;
var FontMetrics = require("./layer/font_metrics").FontMetrics;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var editorCss = require("./css/editor.css");
var Decorator = require("./layer/decorators").Decorator;
var useragent = require("./lib/useragent");
var HIDE_TEXTAREA = useragent.isIE;
dom.importCssString(editorCss, "ace_editor.css", false);
var VirtualRenderer = function (container, theme) {
    var _self = this;
    this.container = container || dom.createElement("div");
    dom.addCssClass(this.container, "ace_editor");
    if (dom.HI_DPI)
        dom.addCssClass(this.container, "ace_hidpi");
    this.setTheme(theme);
    if (config.get("useStrictCSP") == null)
        config.set("useStrictCSP", false);
    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);
    this.$gutter.setAttribute("aria-hidden", true);
    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);
    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);
    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
    this.$markerBack = new MarkerLayer(this.content);
    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;
    this.$markerFront = new MarkerLayer(this.content);
    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;
    this.scrollBar =
        this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.on("scroll", function (e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.on("scroll", function (e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.cursorPos = {
        row: 0,
        column: 0
    };
    this.$fontMetrics = new FontMetrics(this.container);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.on("changeCharacterSize", function (e) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize", e);
    });
    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };
    this.layerConfig = {
        width: 1,
        padding: 0,
        firstRow: 0,
        firstRowScreen: 0,
        lastRow: 0,
        lineHeight: 0,
        characterWidth: 0,
        minHeight: 1,
        maxHeight: 1,
        offset: 0,
        height: 1,
        gutterOffset: 1
    };
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };
    this.margin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };
    this.$keepTextAreaAtCursor = !useragent.isIOS;
    this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
    this.$loop.schedule(this.CHANGE_FULL);
    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._signal("renderer", this);
};
(function () {
    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;
    oop.implement(this, EventEmitter);
    this.updateCharacterSize = function () {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }
        this.layerConfig.characterWidth =
            this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
            this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
        dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
    };
    this.setSession = function (session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);
        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;
        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    };
    this.updateLines = function (firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;
        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;
            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };
    this.onChangeNewLineMode = function () {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
    };
    this.onChangeTabSize = function () {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };
    this.updateText = function () {
        this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function (force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function () {
        this.$textLayer.checkForSizeChanges();
    };
    this.$changes = 0;
    this.$updateSizeAsync = function () {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    this.onResize = function (force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;
        if (force)
            this.$gutterLayer.$padding = null;
        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);
        if (this.resizing)
            this.resizing = 0;
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        if (this.$customScrollbar) {
            this.$updateCustomScrollbar(true);
        }
    };
    this.$updateCachedSize = function (force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;
            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.setHeight(size.scrollerHeight);
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
            changes = changes | this.CHANGE_SCROLL;
        }
        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            this.gutterWidth = gutterWidth;
            dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
            dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
            dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
            var right = this.scrollBarV.getWidth() + "px";
            dom.setStyle(this.scrollBarH.element.style, "right", right);
            dom.setStyle(this.scroller.style, "right", right);
            dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
            this.scrollBarH.setWidth(size.scrollerWidth);
            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
            }
        }
        size.$dirty = !width || !height;
        if (changes)
            this._signal("resize", oldSize);
        return changes;
    };
    this.onGutterResize = function (width) {
        var gutterWidth = this.$showGutter ? width : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        }
        else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        }
        else {
            this.$computeLayerConfig();
        }
    };
    this.adjustWrapLimit = function () {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function (shouldAnimate) {
        this.setOption("animatedScroll", shouldAnimate);
    };
    this.getAnimatedScroll = function () {
        return this.$animatedScroll;
    };
    this.setShowInvisibles = function (showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function () {
        return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function () {
        return this.getOption("displayIndentGuides");
    };
    this.setDisplayIndentGuides = function (display) {
        this.setOption("displayIndentGuides", display);
    };
    this.getHighlightIndentGuides = function () {
        return this.getOption("highlightIndentGuides");
    };
    this.setHighlightIndentGuides = function (highlight) {
        this.setOption("highlightIndentGuides", highlight);
    };
    this.setShowPrintMargin = function (showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    };
    this.getShowPrintMargin = function () {
        return this.getOption("showPrintMargin");
    };
    this.setPrintMarginColumn = function (showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
    };
    this.getPrintMarginColumn = function () {
        return this.getOption("printMarginColumn");
    };
    this.getShowGutter = function () {
        return this.getOption("showGutter");
    };
    this.setShowGutter = function (show) {
        return this.setOption("showGutter", show);
    };
    this.getFadeFoldWidgets = function () {
        return this.getOption("fadeFoldWidgets");
    };
    this.setFadeFoldWidgets = function (show) {
        this.setOption("fadeFoldWidgets", show);
    };
    this.setHighlightGutterLine = function (shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };
    this.getHighlightGutterLine = function () {
        return this.getOption("highlightGutterLine");
    };
    this.$updatePrintMargin = function () {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;
        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }
        var style = this.$printMarginEl.style;
        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    };
    this.getContainerElement = function () {
        return this.container;
    };
    this.getMouseEventTarget = function () {
        return this.scroller;
    };
    this.getTextAreaContainer = function () {
        return this.container;
    };
    this.$moveTextAreaToCursor = function () {
        if (this.$isMousePressed)
            return;
        var style = this.textarea.style;
        var composition = this.$composition;
        if (!this.$keepTextAreaAtCursor && !composition) {
            dom.translate(this.textarea, -100, 0);
            return;
        }
        var pixelPos = this.$cursorLayer.$pixelPos;
        if (!pixelPos)
            return;
        if (composition && composition.markerRange)
            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
        var config = this.layerConfig;
        var posTop = pixelPos.top;
        var posLeft = pixelPos.left;
        posTop -= config.offset;
        var h = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;
        if (posTop < 0 || posTop > config.height - h) {
            dom.translate(this.textarea, 0, 0);
            return;
        }
        var w = 1;
        var maxTop = this.$size.height - h;
        if (!composition) {
            posTop += this.lineHeight;
        }
        else {
            if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);
            }
            else {
                posTop += this.lineHeight + 2;
            }
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;
        posLeft += this.gutterWidth + this.margin.left;
        dom.setStyle(style, "height", h + "px");
        dom.setStyle(style, "width", w + "px");
        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
    };
    this.getFirstVisibleRow = function () {
        return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function () {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function () {
        var config = this.layerConfig;
        var lastRow = config.lastRow;
        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
            return lastRow - 1;
        return lastRow;
    };
    this.getLastVisibleRow = function () {
        return this.layerConfig.lastRow;
    };
    this.$padding = null;
    this.setPadding = function (padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };
    this.setScrollMargin = function (top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top | 0;
        sm.bottom = bottom | 0;
        sm.right = right | 0;
        sm.left = left | 0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    };
    this.setMargin = function (top, bottom, left, right) {
        var sm = this.margin;
        sm.top = top | 0;
        sm.bottom = bottom | 0;
        sm.right = right | 0;
        sm.left = left | 0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
        this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function () {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function () {
        return this.$vScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };
    this.$updateScrollBarV = function () {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function () {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    this.$frozen = false;
    this.freeze = function () {
        this.$frozen = true;
    };
    this.unfreeze = function () {
        this.$frozen = false;
    };
    this.$renderChanges = function (changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return;
        }
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        this._signal("beforeRender", changes);
        if (this.session && this.session.$bidiHandler)
            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
        var config = this.layerConfig;
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL) {
            changes |= this.$computeLayerConfig() | this.$loop.clear();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st > 0) {
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            var width = config.width + 2 * this.$padding + "px";
            var height = config.minHeight + "px";
            dom.setStyle(this.content.style, "width", width);
            dom.setStyle(this.content.style, "height", height);
        }
        if (changes & this.CHANGE_H_SCROLL) {
            dom.translate(this.content, -this.scrollLeft, -config.offset);
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & this.CHANGE_FULL) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }
        if (changes & this.CHANGE_SCROLL) {
            this.$changedLines = null;
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);
            if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                    this.$gutterLayer.update(config);
                else
                    this.$gutterLayer.scrollLines(config);
            }
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
        }
        if (changes & this.CHANGE_TEXT) {
            this.$changedLines = null;
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        else if (changes & this.CHANGE_CURSOR) {
            if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config);
            if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config);
            }
        }
        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
        }
        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }
        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }
        this._signal("afterRender", changes);
    };
    this.$autosize = function () {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;
        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
        var vScroll = !hideScrollbars && height > maxHeight;
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            this._signal("autosize");
        }
    };
    this.$computeLayerConfig = function () {
        var session = this.session;
        var size = this.$size;
        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;
        var longestLine = this.$getLongestLine();
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);
        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();
        var minHeight = size.scrollerHeight + this.lineHeight;
        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;
        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }
        var offset = this.scrollTop % this.lineHeight;
        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }
        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;
        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
            firstRowHeight;
        offset = this.scrollTop - firstRowScreen * lineHeight;
        var changes = 0;
        if (this.layerConfig.width != longestLine || hScrollChanged)
            changes = this.CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }
        this.layerConfig = {
            width: longestLine,
            padding: this.$padding,
            firstRow: firstRow,
            firstRowScreen: firstRowScreen,
            lastRow: lastRow,
            lineHeight: lineHeight,
            characterWidth: this.characterWidth,
            minHeight: minHeight,
            maxHeight: maxHeight,
            offset: offset,
            gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height: this.$size.scrollerHeight
        };
        if (this.session.$bidiHandler)
            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
        return changes;
    };
    this.$updateLines = function () {
        if (!this.$changedLines)
            return;
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;
        var layerConfig = this.layerConfig;
        if (firstRow > layerConfig.lastRow + 1) {
            return;
        }
        if (lastRow < layerConfig.firstRow) {
            return;
        }
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };
    this.$getLongestLine = function () {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;
        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function () {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function () {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function (row, className) {
        this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function (row, className) {
        this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function (rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function (annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function () {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function () {
        this.$cursorLayer.hideCursor();
    };
    this.showCursor = function () {
        this.$cursorLayer.showCursor();
    };
    this.scrollSelectionIntoView = function (anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
            return;
        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var newLeft = pos.left;
        var newTop = pos.top;
        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
        if (this.$scrollAnimation) {
            this.$stopAnimation = true;
        }
        var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        if (currentTop + topMargin > newTop) {
            if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
            if (newTop === 0)
                newTop = -this.scrollMargin.top;
            this.session.setScrollTop(newTop);
        }
        else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
            if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
        }
        var currentLeft = this.scrollLeft;
        var twoCharsWidth = 2 * this.layerConfig.characterWidth;
        if (newLeft - twoCharsWidth < currentLeft) {
            newLeft -= twoCharsWidth;
            if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
            }
            this.session.setScrollLeft(newLeft);
        }
        else {
            newLeft += twoCharsWidth;
            if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
            }
            else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
            }
        }
    };
    this.getScrollTop = function () {
        return this.session.getScrollTop();
    };
    this.getScrollLeft = function () {
        return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function () {
        return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function () {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function (row) {
        this.session.setScrollTop(row * this.lineHeight);
    };
    this.alignCursor = function (cursor, alignment) {
        if (typeof cursor == "number")
            cursor = { row: cursor, column: 0 };
        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);
        this.session.setScrollTop(offset);
        return offset;
    };
    this.STEPS = 8;
    this.$calcSteps = function (fromValue, toValue) {
        var i = 0;
        var l = this.STEPS;
        var steps = [];
        var func = function (t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };
        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
        return steps;
    };
    this.scrollToLine = function (line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;
        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };
    this.animateScrolling = function (fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;
        if (fromValue == toValue)
            return;
        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };
        clearInterval(this.$timer);
        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        function endAnimation() {
            _self.$timer = clearInterval(_self.$timer);
            _self.$scrollAnimation = null;
            _self.$stopAnimation = false;
            callback && callback();
        }
        this.$timer = setInterval(function () {
            if (_self.$stopAnimation) {
                endAnimation();
                return;
            }
            if (!_self.session)
                return clearInterval(_self.$timer);
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            }
            else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            }
            else {
                endAnimation();
            }
        }, 10);
    };
    this.scrollToY = function (scrollTop) {
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };
    this.scrollToX = function (scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function (x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(x);
    };
    this.scrollBy = function (deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function (deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
            return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
            return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
            return true;
    };
    this.pixelToScreenCoordinates = function (x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = { top: 0, left: 0 };
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        }
        else {
            canvasPos = this.scroller.getBoundingClientRect();
        }
        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
        return { row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX: offsetX };
    };
    this.screenToTextCoordinates = function (x, y) {
        var canvasPos;
        if (this.$hasCssTransforms) {
            canvasPos = { top: 0, left: 0 };
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
        }
        else {
            canvasPos = this.scroller.getBoundingClientRect();
        }
        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
    };
    this.textToScreenCoordinates = function (row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);
        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : Math.round(pos.column * this.characterWidth));
        var y = pos.row * this.lineHeight;
        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };
    this.visualizeFocus = function () {
        dom.addCssClass(this.container, "ace_focus");
    };
    this.visualizeBlur = function () {
        dom.removeCssClass(this.container, "ace_focus");
    };
    this.showComposition = function (composition) {
        this.$composition = composition;
        if (!composition.cssText) {
            composition.cssText = this.textarea.style.cssText;
        }
        if (composition.useTextareaForIME == undefined)
            composition.useTextareaForIME = this.$useTextareaForIME;
        if (this.$useTextareaForIME) {
            dom.addCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = "";
            this.$moveTextAreaToCursor();
            this.$cursorLayer.element.style.display = "none";
        }
        else {
            composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
        }
    };
    this.setCompositionText = function (text) {
        var cursor = this.session.selection.cursor;
        this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
        this.$moveTextAreaToCursor();
    };
    this.hideComposition = function () {
        if (!this.$composition)
            return;
        if (this.$composition.markerId)
            this.session.removeMarker(this.$composition.markerId);
        dom.removeCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = this.$composition.cssText;
        var cursor = this.session.selection.cursor;
        this.removeExtraToken(cursor.row, cursor.column);
        this.$composition = null;
        this.$cursorLayer.element.style.display = "";
    };
    this.setGhostText = function (text, position) {
        var cursor = this.session.selection.cursor;
        var insertPosition = position || { row: cursor.row, column: cursor.column };
        this.removeGhostText();
        var textLines = text.split("\n");
        this.addToken(textLines[0], "ghost_text", insertPosition.row, insertPosition.column);
        this.$ghostText = {
            text: text,
            position: {
                row: insertPosition.row,
                column: insertPosition.column
            }
        };
        if (textLines.length > 1) {
            this.$ghostTextWidget = {
                text: textLines.slice(1).join("\n"),
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text"
            };
            this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
        }
    };
    this.removeGhostText = function () {
        if (!this.$ghostText)
            return;
        var position = this.$ghostText.position;
        this.removeExtraToken(position.row, position.column);
        if (this.$ghostTextWidget) {
            this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
            this.$ghostTextWidget = null;
        }
        this.$ghostText = null;
    };
    this.addToken = function (text, type, row, column) {
        var session = this.session;
        session.bgTokenizer.lines[row] = null;
        var newToken = { type: type, value: text };
        var tokens = session.getTokens(row);
        if (column == null) {
            tokens.push(newToken);
        }
        else {
            var l = 0;
            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                l += token.value.length;
                if (column <= l) {
                    var diff = token.value.length - (l - column);
                    var before = token.value.slice(0, diff);
                    var after = token.value.slice(diff);
                    tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                    break;
                }
            }
        }
        this.updateLines(row, row);
    };
    this.removeExtraToken = function (row, column) {
        this.updateLines(row, row);
    };
    this.setTheme = function (theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent('themeChange', { theme: theme });
        if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        }
        else {
            afterLoad(theme);
        }
        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module || !module.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
            if (module.$id)
                _self.$themeId = module.$id;
            dom.importCssString(module.cssText, module.cssClass, _self.container);
            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
            var padding = "padding" in module ? module.padding
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
            _self.$theme = module.cssClass;
            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }
            _self._dispatchEvent('themeLoaded', { theme: module });
            cb && cb();
        }
    };
    this.getTheme = function () {
        return this.$themeId;
    };
    this.setStyle = function (style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function (style) {
        dom.removeCssClass(this.container, style);
    };
    this.setCursorStyle = function (style) {
        dom.setStyle(this.scroller.style, "cursor", style);
    };
    this.setMouseCursor = function (cursorStyle) {
        dom.setStyle(this.scroller.style, "cursor", cursorStyle);
    };
    this.attachToShadowRoot = function () {
        dom.importCssString(editorCss, "ace_editor.css", this.container);
    };
    this.destroy = function () {
        this.freeze();
        this.$fontMetrics.destroy();
        this.$cursorLayer.destroy();
        this.removeAllListeners();
        this.container.textContent = "";
    };
    this.$updateCustomScrollbar = function (val) {
        var _self = this;
        this.$horizScroll = this.$vScroll = null;
        this.scrollBarV.element.remove();
        this.scrollBarH.element.remove();
        if (this.$scrollDecorator) {
            delete this.$scrollDecorator;
        }
        if (val === true) {
            this.scrollBarV = new VScrollBarCustom(this.container, this);
            this.scrollBarH = new HScrollBarCustom(this.container, this);
            this.scrollBarV.setHeight(this.$size.scrollerHeight);
            this.scrollBarH.setWidth(this.$size.scrollerWidth);
            this.scrollBarV.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            this.$scrollDecorator = new Decorator(this.scrollBarV, this);
            this.$scrollDecorator.$updateDecorators();
        }
        else {
            this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function (e) {
                if (!_self.$scrollAnimation)
                    _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
        }
    };
}).call(VirtualRenderer.prototype);
config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: { initialValue: false },
    showInvisibles: {
        set: function (value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function () { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function () { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function (val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function () {
            return this.$showPrintMargin && this.$printMarginColumn;
        }
    },
    showGutter: {
        set: function (show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function (show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function (show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function (show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightIndentGuides: {
        set: function (show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
                this.$textLayer.$highlightIndentGuide();
            }
            else {
                this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function (shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    hScrollBarAlwaysVisible: {
        set: function (val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function (val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize: {
        set: function (size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function (name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function (val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function (val) {
            if (!(this.$minLines < 0x1ffffffffffff))
                this.$minLines = 0;
            this.updateFull();
        }
    },
    maxPixelHeight: {
        set: function (val) {
            this.updateFull();
        },
        initialValue: 0
    },
    scrollPastEnd: {
        set: function (val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function (val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    customScrollbar: {
        set: function (val) {
            this.$updateCustomScrollbar(val);
        },
        initialValue: false
    },
    theme: {
        set: function (val) { this.setTheme(val); },
        get: function () { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    },
    hasCssTransforms: {},
    useTextareaForIME: {
        initialValue: !useragent.isMobile && !useragent.isIE
    }
});
exports.VirtualRenderer = VirtualRenderer;

});

ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var net = require("../lib/net");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var config = require("../config");

function $workerBlob(workerUrl) {
    var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
    try {
        return new Blob([script], {"type": "application/javascript"});
    } catch (e) { // Backwards-compatibility
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob("application/javascript");
    }
}

function createWorker(workerUrl) {
    if (typeof Worker == "undefined")
        return { postMessage: function() {}, terminate: function() {} };
    if (config.get("loadWorkerFromBlob")) {
        var blob = $workerBlob(workerUrl);
        var URL = window.URL || window.webkitURL;
        var blobURL = URL.createObjectURL(blob);
        return new Worker(blobURL);
    }
    return new Worker(workerUrl);
}

var WorkerClient = function(worker) {
    if (!worker.postMessage)
        worker = this.$createWorkerFromOldConfig.apply(this, arguments);

    this.$worker = worker;
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
        if (require.nameToUrl && !require.toUrl)
            require.toUrl = require.nameToUrl;

        if (config.get("packaged") || !require.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod, "worker");
        } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));

            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
                tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
        }

        this.$worker = createWorker(workerUrl);
        if (importScripts) {
            this.send("importScripts", importScripts);
        }
        this.$worker.postMessage({
            init : true,
            tlns : tlns,
            module : mod,
            classname : classname
        });
        return this.$worker;
    };

    this.onMessage = function(e) {
        var msg = e.data;
        switch (msg.type) {
            case "event":
                this._signal(msg.name, {data: msg.data});
                break;
            case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
            case "error":
                this.reportError(msg.data);
                break;
            case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;
        }
    };
    
    this.reportError = function(err) {
        window.console && console.error && console.error(err);
    };

    this.$normalizePath = function(path) {
        return net.qualifyURL(path);
    };

    this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
            this.$doc.off("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            if (data.data && data.data.err)
                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};
                this.$worker && this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {
            console.error(ex.stack);
        }
    };

    this.attachToDocument = function(doc) {
        if (this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener, true);
    };

    this.changeListener = function(delta) {
        if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
        else
            this.deltaQueue.push(delta.start, delta.end);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
        } else
            this.emit("change", {data: q});
    };

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);

    var messageBuffer = [];
    var workerClient = new WorkerClient({
        messageBuffer: messageBuffer,
        terminate: function() {},
        postMessage: function(e) {
            messageBuffer.push(e);
            if (!main) return;
            if (emitSync)
                setTimeout(processNext);
            else
                processNext();
        }
    });

    workerClient.setEmitSync = function(val) { emitSync = val; };

    var processNext = function() {
        var msg = messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        workerClient.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (messageBuffer.length)
            processNext();
    });

    return workerClient;
};

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;
exports.createWorker = createWorker;


});

ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(require, exports, module){"use strict";
var Range = require("./range").Range;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var oop = require("./lib/oop");
var PlaceHolder = function (session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate, true);
    this.$others = others;
    this.$onCursorChange = function () {
        setTimeout(function () {
            _self.onCursorChange();
        });
    };
    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
    this.$undoStackDepth = undoStack.length;
    this.setup();
    session.selection.on("changeCursor", this.$onCursorChange);
};
(function () {
    oop.implement(this, EventEmitter);
    this.setup = function () {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();
        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function (other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    this.showOtherMarkers = function () {
        if (this.othersActive)
            return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function (anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
        });
    };
    this.hideOtherMarkers = function () {
        if (!this.othersActive)
            return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };
    this.onUpdate = function (delta) {
        if (this.$updating)
            return this.updateAnchors(delta);
        var range = delta;
        if (range.start.row !== range.end.row)
            return;
        if (range.start.row !== this.pos.row)
            return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;
        this.updateAnchors(delta);
        if (inMainRange)
            this.length += lengthDiff;
        if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
            }
            else if (delta.action === 'remove') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
        }
        this.$updating = false;
        this.updateMarkers();
    };
    this.updateAnchors = function (delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--;)
            this.others[i].onChange(delta);
        this.updateMarkers();
    };
    this.updateMarkers = function () {
        if (this.$updating)
            return;
        var _self = this;
        var session = this.session;
        var updateMarker = function (pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--;)
            updateMarker(this.others[i], this.othersClass);
    };
    this.onCursorChange = function (event) {
        if (this.$updating || !this.session)
            return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        }
        else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };
    this.detach = function () {
        this.session.removeMarker(this.pos && this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.off("change", this.$onUpdate);
        this.session.selection.off("changeCursor", this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
    };
    this.cancel = function () {
        if (this.$undoStackDepth === -1)
            return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(this.session, true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    };
}).call(PlaceHolder.prototype);
exports.PlaceHolder = PlaceHolder;

});

ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(require, exports, module){var event = require("../lib/event");
var useragent = require("../lib/useragent");
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}
function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    if (ctrl && useragent.isMac)
        button = ev.button;
    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    if (button !== 0)
        return;
    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));
    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function (e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
    }
    else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        }
        else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
        }
    }
    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }
    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging
        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }
        var oldRange = selection.rangeList.rangeAtPoint(pos);
        editor.inVirtualSelectionMode = true;
        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function () {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                }
                else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
        });
    }
    else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;
        var initialRange;
        var rectSel = [];
        var blockSelect = function () {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
        };
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        }
        else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
        else
            selection.moveToPosition(pos);
        screenCursor = { row: -1, column: -1 };
        var onMouseSelectionEnd = function (e) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
        };
        var onSelectionInterval = blockSelect;
        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function () { onSelectionInterval(); }, 20);
        return e.preventDefault();
    }
}
exports.onMouseDown = onMouseDown;

});

ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(require, exports, module){// commands to enter multiselect mode
exports.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function (editor) { editor.selectMoreLines(-1); },
        bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function (editor) { editor.selectMoreLines(1); },
        bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function (editor) { editor.selectMoreLines(-1, true); },
        bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function (editor) { editor.selectMoreLines(1, true); },
        bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function (editor) { editor.selectMore(-1); },
        bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function (editor) { editor.selectMore(1); },
        bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function (editor) { editor.selectMore(-1, true); },
        bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function (editor) { editor.selectMore(1, true); },
        bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
        scrollIntoView: "cursor",
        readOnly: true
    }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split selection into lines",
        exec: function (editor) {
            if (editor.multiSelect.rangeCount > 1)
                editor.multiSelect.joinSelections();
            else
                editor.multiSelect.splitIntoLines();
        },
        bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
        readOnly: true
    }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function (editor) { editor.multiSelect.splitIntoLines(); },
        readOnly: true
    }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function (editor) { editor.alignCursors(); },
        bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
        scrollIntoView: "cursor"
    }, {
        name: "findAll",
        description: "Find all",
        exec: function (editor) { editor.findAll(); },
        bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
        scrollIntoView: "cursor",
        readOnly: true
    }];
exports.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function (editor) { editor.exitMultiSelectMode(); },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function (editor) { return editor && editor.inMultiSelectMode; }
    }];
var HashHandler = require("../keyboard/hash_handler").HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(require, exports, module){var RangeList = require("./range_list").RangeList;
var Range = require("./range").Range;
var Selection = require("./selection").Selection;
var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
var event = require("./lib/event");
var lang = require("./lib/lang");
var commands = require("./commands/multi_select_commands");
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
var Search = require("./search").Search;
var search = new Search();
function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}
var EditSession = require("./edit_session").EditSession;
(function () {
    this.getSelectionMarkers = function () {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);
(function () {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function (range, $blockChangeEvents) {
        if (!range)
            return;
        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }
        if (!range.cursor)
            range.cursor = range.end;
        var removed = this.rangeList.add(range);
        this.$onAddRange(range);
        if (removed.length)
            this.$onRemoveRange(removed);
        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }
        return $blockChangeEvents || this.fromOrientedRange(range);
    };
    this.toSingleRange = function (range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);
        range && this.fromOrientedRange(range);
    };
    this.substractPoint = function (pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };
    this.mergeOverlappingRanges = function () {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
    };
    this.$onAddRange = function (range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", { range: range });
    };
    this.$onRemoveRange = function (removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }
        for (var i = removed.length; i--;) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }
        this._signal("removeRange", { ranges: removed });
        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }
        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function () {
        if (this.rangeList)
            return;
        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };
    this.getAllRanges = function () {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };
    this.splitIntoLines = function () {
        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
        var newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
                newRanges.push(range.clone());
            }
            else {
                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                while (++row < endRow)
                    newRanges.push(this.getLineRange(row, true));
                newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 && !this.isBackwards())
                newRanges = newRanges.reverse();
        }
        this.toSingleRange();
        for (var i = newRanges.length; i--;)
            this.addRange(newRanges[i]);
    };
    this.joinSelections = function () {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);
        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
    };
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        }
        else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };
    this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];
        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
        }
        else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
        }
        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        }
        else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }
        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;
        if (startRow == endRow)
            includeEmptyLines = true;
        var docEnd;
        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }
        if (yBackwards)
            rectSel.reverse();
        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }
        return rectSel;
    };
}).call(Selection.prototype);
var Editor = require("./editor").Editor;
(function () {
    this.updateSelectionMarkers = function () {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function (orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };
    this.removeSelectionMarker = function (range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };
    this.removeSelectionMarkers = function (ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--;) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };
    this.$onAddRange = function (e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.$onRemoveRange = function (e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.$onMultiSelect = function (e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;
        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.$onSingleSelect = function (e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;
        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };
    this.$onMultiSelectExec = function (e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        }
        else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        }
        else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        }
        else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        }
        else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    };
    this.forEachSelection = function (cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};
        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();
        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
        return result;
    };
    this.exitMultiSelectMode = function () {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };
    this.getSelectedText = function () {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        }
        else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };
    this.$checkMultiselectChange = function (e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
                this.multiSelect.mergeOverlappingRanges();
        }
    };
    this.findAll = function (needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;
        var selection = this.multiSelect;
        if (!additive)
            selection.toSingleRange(ranges[0]);
        for (var i = ranges.length; i--;)
            selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
        return ranges.length;
    };
    this.selectMoreLines = function (dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;
        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        }
        else {
            var anchor = lead;
        }
        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        }
        else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }
        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        }
        else {
            if (skip)
                var toRemove = range.cursor;
        }
        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function (dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;
        for (var i = all.length; i--;) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();
        var words = [];
        for (var i = all.length; i--;) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }
        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());
        for (var i = all.length; i--;) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
        sel.fromOrientedRange(sel.ranges[0]);
    };
    this.selectMore = function (dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;
        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);
        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function () {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function (r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);
                if (fr < 0)
                    fr = 0;
                if (lr >= max)
                    lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        }
        else {
            sameRowRanges.forEach(function (r) {
                sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function (r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;
                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function (r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };
    this.$reAlignText = function (lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;
        return lines.map(function (line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];
            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;
            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;
            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }
        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}
exports.onSessionChange = function (e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;
    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
    }
    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
    }
    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);
    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);
    addAltCursorListeners(editor);
}
function addAltCursorListeners(editor) {
    if (!editor.textInput)
        return;
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function (e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        }
        else if (altCursor) {
            reset();
        }
    }, editor);
    event.addListener(el, "keyup", reset, editor);
    event.addListener(el, "blur", reset, editor);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
        }
    }
}
exports.MultiSelect = MultiSelect;
require("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
        set: function (val) {
            MultiSelect(this);
            if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
            }
            else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function (val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});

});

ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(require, exports, module){"use strict";
var Range = require("../../range").Range;
var FoldMode = exports.FoldMode = function () { };
(function () {
    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function (session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
            && this.foldingStopMarker
            && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        return null;
    };
    this.indentationBlock = function (session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;
        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        while (++row < maxRow) {
            var level = session.getLine(row).search(re);
            if (level == -1)
                continue;
            if (level <= startLevel) {
                var token = session.getTokenAt(row, 0);
                if (!token || token.type !== "string")
                    break;
            }
            endRow = row;
        }
        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };
    this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
        var start = { row: row, column: column + 1 };
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;
        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);
        if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };
    this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
        var end = { row: row, column: column };
        var start = session.$findOpeningBracket(bracket, end);
        if (!start)
            return;
        start.column++;
        end.column--;
        return Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});

ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(require, exports, module){"use strict";
var LineWidgets = require("../line_widgets").LineWidgets;
var dom = require("../lib/dom");
var Range = require("../range").Range;
function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;
    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }
    return -(first + 1);
}
function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;
    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}
exports.showErrorMarker = function (editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
        return w.type == "errorMarker";
    })[0];
    if (oldWidget) {
        oldWidget.destroy();
    }
    else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    }
    else if (oldWidget) {
        return;
    }
    else {
        gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    var w = {
        row: pos.row,
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");
    el.appendChild(dom.createElement("div"));
    var kb = function (_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return { command: "null" };
        }
    };
    w.destroy = function () {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    editor.session.widgetManager.addLineWidget(w);
    w.el.onmousedown = editor.focus.bind(editor);
    editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
};
dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);

});

ace.define("ace/ace",["require","exports","module","ace/lib/dom","ace/lib/event","ace/range","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config","ace/loader_build"], function(require, exports, module){/**
 * The main class required to set up an Ace instance in the browser.
 *
 * @class Ace
 **/
"use strict";
require("./loader_build")(exports)
var dom = require("./lib/dom");
var event = require("./lib/event");
var Range = require("./range").Range;
var Editor = require("./editor").Editor;
var EditSession = require("./edit_session").EditSession;
var UndoManager = require("./undomanager").UndoManager;
var Renderer = require("./virtual_renderer").VirtualRenderer;
require("./worker/worker_client");
require("./keyboard/hash_handler");
require("./placeholder");
require("./multi_select");
require("./mode/folding/fold_mode");
require("./theme/textmate");
require("./ext/error_marker");
exports.config = require("./config");
exports.edit = function (el, options) {
    if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }
    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;
    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    }
    else if (el) {
        value = el.textContent;
        el.innerHTML = "";
    }
    var doc = exports.createEditSession(value);
    var editor = new Editor(new Renderer(el), doc, options);
    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode)
        env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function () {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};
exports.createEditSession = function (text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
};
exports.Range = Range;
exports.Editor = Editor;
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
exports.VirtualRenderer = Renderer;
exports.version = exports.config.version;

});            (function() {
                ace.require(["ace/ace"], function(a) {
                    if (a) {
                        a.config.init(true);
                        a.define = ace.define;
                    }
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                    window.ace["default"] = window.ace;
                    if (typeof module == "object" && typeof exports == "object" && module) {
                        module.exports = window.ace;
                    }
                });
            })();
        </script> <script id='lz_string'  type='text/javascript'  charset='utf-8'>// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (typeof define === 'function' && define.amd) {
  define(function () { return LZString; });
} else if( typeof module !== 'undefined' && module != null ) {
  module.exports = LZString
} else if( typeof angular !== 'undefined' && angular != null ) {
  angular.module('LZString', [])
  .factory('LZString', function () {
    return LZString;
  });
}
</script> <script id='ext_language_tools'  type='text/javascript'  charset='utf-8'>ace.define("ace/snippets",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event_emitter","ace/lib/lang","ace/range","ace/range_list","ace/keyboard/hash_handler","ace/tokenizer","ace/clipboard","ace/editor"],function(e,t,n){"use strict";function p(e){var t=(new Date).toLocaleString("en-us",e);return t.length==1?"0"+t:t}var r=e("./lib/dom"),i=e("./lib/oop"),s=e("./lib/event_emitter").EventEmitter,o=e("./lib/lang"),u=e("./range").Range,a=e("./range_list").RangeList,f=e("./keyboard/hash_handler").HashHandler,l=e("./tokenizer").Tokenizer,c=e("./clipboard"),h={CURRENT_WORD:function(e){return e.session.getTextRange(e.session.getWordRange())},SELECTION:function(e,t,n){var r=e.session.getTextRange();return n?r.replace(/\n\r?([ \t]*\S)/g,"\n"+n+"$1"):r},CURRENT_LINE:function(e){return e.session.getLine(e.getCursorPosition().row)},PREV_LINE:function(e){return e.session.getLine(e.getCursorPosition().row-1)},LINE_INDEX:function(e){return e.getCursorPosition().row},LINE_NUMBER:function(e){return e.getCursorPosition().row+1},SOFT_TABS:function(e){return e.session.getUseSoftTabs()?"YES":"NO"},TAB_SIZE:function(e){return e.session.getTabSize()},CLIPBOARD:function(e){return c.getText&&c.getText()},FILENAME:function(e){return/[^/\\]*$/.exec(this.FILEPATH(e))[0]},FILENAME_BASE:function(e){return/[^/\\]*$/.exec(this.FILEPATH(e))[0].replace(/\.[^.]*$/,"")},DIRECTORY:function(e){return this.FILEPATH(e).replace(/[^/\\]*$/,"")},FILEPATH:function(e){return"/not implemented.txt"},WORKSPACE_NAME:function(){return"Unknown"},FULLNAME:function(){return"Unknown"},BLOCK_COMMENT_START:function(e){var t=e.session.$mode||{};return t.blockComment&&t.blockComment.start||""},BLOCK_COMMENT_END:function(e){var t=e.session.$mode||{};return t.blockComment&&t.blockComment.end||""},LINE_COMMENT:function(e){var t=e.session.$mode||{};return t.lineCommentStart||""},CURRENT_YEAR:p.bind(null,{year:"numeric"}),CURRENT_YEAR_SHORT:p.bind(null,{year:"2-digit"}),CURRENT_MONTH:p.bind(null,{month:"numeric"}),CURRENT_MONTH_NAME:p.bind(null,{month:"long"}),CURRENT_MONTH_NAME_SHORT:p.bind(null,{month:"short"}),CURRENT_DATE:p.bind(null,{day:"2-digit"}),CURRENT_DAY_NAME:p.bind(null,{weekday:"long"}),CURRENT_DAY_NAME_SHORT:p.bind(null,{weekday:"short"}),CURRENT_HOUR:p.bind(null,{hour:"2-digit",hour12:!1}),CURRENT_MINUTE:p.bind(null,{minute:"2-digit"}),CURRENT_SECOND:p.bind(null,{second:"2-digit"})};h.SELECTED_TEXT=h.SELECTION;var d=function(){this.snippetMap={},this.snippetNameMap={}};(function(){i.implement(this,s),this.getTokenizer=function(){return d.$tokenizer||this.createTokenizer()},this.createTokenizer=function(){function e(e){return e=e.substr(1),/^\d+$/.test(e)?[{tabstopId:parseInt(e,10)}]:[{text:e}]}function t(e){return"(?:[^\\\\"+e+"]|\\\\.)"}var n={regex:"/("+t("/")+"+)/",onMatch:function(e,t,n){var r=n[0];return r.fmtString=!0,r.guard=e.slice(1,-1),r.flag="",""},next:"formatString"};return d.$tokenizer=new l({start:[{regex:/\\./,onMatch:function(e,t,n){var r=e[1];return r=="}"&&n.length?e=r:"`$\\".indexOf(r)!=-1&&(e=r),[e]}},{regex:/}/,onMatch:function(e,t,n){return[n.length?n.shift():e]}},{regex:/\$(?:\d+|\w+)/,onMatch:e},{regex:/\$\{[\dA-Z_a-z]+/,onMatch:function(t,n,r){var i=e(t.substr(1));return r.unshift(i[0]),i},next:"snippetVar"},{regex:/\n/,token:"newline",merge:!1}],snippetVar:[{regex:"\\|"+t("\\|")+"*\\|",onMatch:function(e,t,n){var r=e.slice(1,-1).replace(/\\[,|\\]|,/g,function(e){return e.length==2?e[1]:"\0"}).split("\0").map(function(e){return{value:e}});return n[0].choices=r,[r[0]]},next:"start"},n,{regex:"([^:}\\\\]|\\\\.)*:?",token:"",next:"start"}],formatString:[{regex:/:/,onMatch:function(e,t,n){return n.length&&n[0].expectElse?(n[0].expectElse=!1,n[0].ifEnd={elseEnd:n[0]},[n[0].ifEnd]):":"}},{regex:/\\./,onMatch:function(e,t,n){var r=e[1];return r=="}"&&n.length?e=r:"`$\\".indexOf(r)!=-1?e=r:r=="n"?e="\n":r=="t"?e="	":"ulULE".indexOf(r)!=-1&&(e={changeCase:r,local:r>"a"}),[e]}},{regex:"/\\w*}",onMatch:function(e,t,n){var r=n.shift();return r&&(r.flag=e.slice(1,-1)),this.next=r&&r.tabstopId?"start":"",[r||e]},next:"start"},{regex:/\$(?:\d+|\w+)/,onMatch:function(e,t,n){return[{text:e.slice(1)}]}},{regex:/\${\w+/,onMatch:function(e,t,n){var r={text:e.slice(2)};return n.unshift(r),[r]},next:"formatStringVar"},{regex:/\n/,token:"newline",merge:!1},{regex:/}/,onMatch:function(e,t,n){var r=n.shift();return this.next=r&&r.tabstopId?"start":"",[r||e]},next:"start"}],formatStringVar:[{regex:/:\/\w+}/,onMatch:function(e,t,n){var r=n[0];return r.formatFunction=e.slice(2,-1),[n.shift()]},next:"formatString"},n,{regex:/:[\?\-+]?/,onMatch:function(e,t,n){e[1]=="+"&&(n[0].ifEnd=n[0]),e[1]=="?"&&(n[0].expectElse=!0)},next:"formatString"},{regex:"([^:}\\\\]|\\\\.)*:?",token:"",next:"formatString"}]}),d.$tokenizer},this.tokenizeTmSnippet=function(e,t){return this.getTokenizer().getLineTokens(e,t).tokens.map(function(e){return e.value||e})},this.getVariableValue=function(e,t,n){if(/^\d+$/.test(t))return(this.variables.__||{})[t]||"";if(/^[A-Z]\d+$/.test(t))return(this.variables[t[0]+"__"]||{})[t.substr(1)]||"";t=t.replace(/^TM_/,"");if(!this.variables.hasOwnProperty(t))return"";var r=this.variables[t];return typeof r=="function"&&(r=this.variables[t](e,t,n)),r==null?"":r},this.variables=h,this.tmStrFormat=function(e,t,n){if(!t.fmt)return e;var r=t.flag||"",i=t.guard;i=new RegExp(i,r.replace(/[^gim]/g,""));var s=typeof t.fmt=="string"?this.tokenizeTmSnippet(t.fmt,"formatString"):t.fmt,o=this,u=e.replace(i,function(){var e=o.variables.__;o.variables.__=[].slice.call(arguments);var t=o.resolveVariables(s,n),r="E";for(var i=0;i<t.length;i++){var u=t[i];if(typeof u=="object"){t[i]="";if(u.changeCase&&u.local){var a=t[i+1];a&&typeof a=="string"&&(u.changeCase=="u"?t[i]=a[0].toUpperCase():t[i]=a[0].toLowerCase(),t[i+1]=a.substr(1))}else u.changeCase&&(r=u.changeCase)}else r=="U"?t[i]=u.toUpperCase():r=="L"&&(t[i]=u.toLowerCase())}return o.variables.__=e,t.join("")});return u},this.tmFormatFunction=function(e,t,n){return t.formatFunction=="upcase"?e.toUpperCase():t.formatFunction=="downcase"?e.toLowerCase():e},this.resolveVariables=function(e,t){function f(t){var n=e.indexOf(t,s+1);n!=-1&&(s=n)}var n=[],r="",i=!0;for(var s=0;s<e.length;s++){var o=e[s];if(typeof o=="string"){n.push(o),o=="\n"?(i=!0,r=""):i&&(r=/^\t*/.exec(o)[0],i=/\S/.test(o));continue}if(!o)continue;i=!1;if(o.fmtString){var u=e.indexOf(o,s+1);u==-1&&(u=e.length),o.fmt=e.slice(s+1,u),s=u}if(o.text){var a=this.getVariableValue(t,o.text,r)+"";o.fmtString&&(a=this.tmStrFormat(a,o,t)),o.formatFunction&&(a=this.tmFormatFunction(a,o,t)),a&&!o.ifEnd?(n.push(a),f(o)):!a&&o.ifEnd&&f(o.ifEnd)}else o.elseEnd?f(o.elseEnd):o.tabstopId!=null?n.push(o):o.changeCase!=null&&n.push(o)}return n},this.insertSnippetForSelection=function(e,t){function f(e){var t=[];for(var n=0;n<e.length;n++){var r=e[n];if(typeof r=="object"){if(a[r.tabstopId])continue;var i=e.lastIndexOf(r,n-1);r=t[i]||{tabstopId:r.tabstopId}}t[n]=r}return t}var n=e.getCursorPosition(),r=e.session.getLine(n.row),i=e.session.getTabString(),s=r.match(/^\s*/)[0];n.column<s.length&&(s=s.slice(0,n.column)),t=t.replace(/\r/g,"");var o=this.tokenizeTmSnippet(t);o=this.resolveVariables(o,e),o=o.map(function(e){return e=="\n"?e+s:typeof e=="string"?e.replace(/\t/g,i):e});var u=[];o.forEach(function(e,t){if(typeof e!="object")return;var n=e.tabstopId,r=u[n];r||(r=u[n]=[],r.index=n,r.value="",r.parents={});if(r.indexOf(e)!==-1)return;e.choices&&!r.choices&&(r.choices=e.choices),r.push(e);var i=o.indexOf(e,t+1);if(i===-1)return;var s=o.slice(t+1,i),a=s.some(function(e){return typeof e=="object"});a&&!r.value?r.value=s:s.length&&(!r.value||typeof r.value!="string")&&(r.value=s.join(""))}),u.forEach(function(e){e.length=0});var a={};for(var l=0;l<o.length;l++){var c=o[l];if(typeof c!="object")continue;var h=c.tabstopId,p=u[h],d=o.indexOf(c,l+1);if(a[h]){a[h]===c&&(delete a[h],Object.keys(a).forEach(function(e){p.parents[e]=!0}));continue}a[h]=c;var m=p.value;typeof m!="string"?m=f(m):c.fmt&&(m=this.tmStrFormat(m,c,e)),o.splice.apply(o,[l+1,Math.max(0,d-l)].concat(m,c)),p.indexOf(c)===-1&&p.push(c)}var g=0,y=0,b="";o.forEach(function(e){if(typeof e=="string"){var t=e.split("\n");t.length>1?(y=t[t.length-1].length,g+=t.length-1):y+=e.length,b+=e}else e&&(e.start?e.end={row:g,column:y}:e.start={row:g,column:y})});var w=e.getSelectionRange(),E=e.session.replace(w,b),S=new v(e),x=e.inVirtualSelectionMode&&e.selection.index;S.addTabstops(u,w.start,E,x)},this.insertSnippet=function(e,t){var n=this;if(e.inVirtualSelectionMode)return n.insertSnippetForSelection(e,t);e.forEachSelection(function(){n.insertSnippetForSelection(e,t)},null,{keepOrder:!0}),e.tabstopManager&&e.tabstopManager.tabNext()},this.$getScope=function(e){var t=e.session.$mode.$id||"";t=t.split("/").pop();if(t==="html"||t==="php"){t==="php"&&!e.session.$mode.inlinePhp&&(t="html");var n=e.getCursorPosition(),r=e.session.getState(n.row);typeof r=="object"&&(r=r[0]),r.substring&&(r.substring(0,3)=="js-"?t="javascript":r.substring(0,4)=="css-"?t="css":r.substring(0,4)=="php-"&&(t="php"))}return t},this.getActiveScopes=function(e){var t=this.$getScope(e),n=[t],r=this.snippetMap;return r[t]&&r[t].includeScopes&&n.push.apply(n,r[t].includeScopes),n.push("_"),n},this.expandWithTab=function(e,t){var n=this,r=e.forEachSelection(function(){return n.expandSnippetForSelection(e,t)},null,{keepOrder:!0});return r&&e.tabstopManager&&e.tabstopManager.tabNext(),r},this.expandSnippetForSelection=function(e,t){var n=e.getCursorPosition(),r=e.session.getLine(n.row),i=r.substring(0,n.column),s=r.substr(n.column),o=this.snippetMap,u;return this.getActiveScopes(e).some(function(e){var t=o[e];return t&&(u=this.findMatchingSnippet(t,i,s)),!!u},this),u?t&&t.dryRun?!0:(e.session.doc.removeInLine(n.row,n.column-u.replaceBefore.length,n.column+u.replaceAfter.length),this.variables.M__=u.matchBefore,this.variables.T__=u.matchAfter,this.insertSnippetForSelection(e,u.content),this.variables.M__=this.variables.T__=null,!0):!1},this.findMatchingSnippet=function(e,t,n){for(var r=e.length;r--;){var i=e[r];if(i.startRe&&!i.startRe.test(t))continue;if(i.endRe&&!i.endRe.test(n))continue;if(!i.startRe&&!i.endRe)continue;return i.matchBefore=i.startRe?i.startRe.exec(t):[""],i.matchAfter=i.endRe?i.endRe.exec(n):[""],i.replaceBefore=i.triggerRe?i.triggerRe.exec(t)[0]:"",i.replaceAfter=i.endTriggerRe?i.endTriggerRe.exec(n)[0]:"",i}},this.snippetMap={},this.snippetNameMap={},this.register=function(e,t){function s(e){return e&&!/^\^?\(.*\)\$?$|^\\b$/.test(e)&&(e="(?:"+e+")"),e||""}function u(e,t,n){return e=s(e),t=s(t),n?(e=t+e,e&&e[e.length-1]!="$"&&(e+="$")):(e+=t,e&&e[0]!="^"&&(e="^"+e)),new RegExp(e)}function a(e){e.scope||(e.scope=t||"_"),t=e.scope,n[t]||(n[t]=[],r[t]={});var s=r[t];if(e.name){var a=s[e.name];a&&i.unregister(a),s[e.name]=e}n[t].push(e),e.prefix&&(e.tabTrigger=e.prefix),!e.content&&e.body&&(e.content=Array.isArray(e.body)?e.body.join("\n"):e.body),e.tabTrigger&&!e.trigger&&(!e.guard&&/^\w/.test(e.tabTrigger)&&(e.guard="\\b"),e.trigger=o.escapeRegExp(e.tabTrigger));if(!e.trigger&&!e.guard&&!e.endTrigger&&!e.endGuard)return;e.startRe=u(e.trigger,e.guard,!0),e.triggerRe=new RegExp(e.trigger),e.endRe=u(e.endTrigger,e.endGuard,!0),e.endTriggerRe=new RegExp(e.endTrigger)}var n=this.snippetMap,r=this.snippetNameMap,i=this;e||(e=[]),Array.isArray(e)?e.forEach(a):Object.keys(e).forEach(function(t){a(e[t])}),this._signal("registerSnippets",{scope:t})},this.unregister=function(e,t){function i(e){var i=r[e.scope||t];if(i&&i[e.name]){delete i[e.name];var s=n[e.scope||t],o=s&&s.indexOf(e);o>=0&&s.splice(o,1)}}var n=this.snippetMap,r=this.snippetNameMap;e.content?i(e):Array.isArray(e)&&e.forEach(i)},this.parseSnippetFile=function(e){e=e.replace(/\r/g,"");var t=[],n={},r=/^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm,i;while(i=r.exec(e)){if(i[1])try{n=JSON.parse(i[1]),t.push(n)}catch(s){}if(i[4])n.content=i[4].replace(/^\t/gm,""),t.push(n),n={};else{var o=i[2],u=i[3];if(o=="regex"){var a=/\/((?:[^\/\\]|\\.)*)|$/g;n.guard=a.exec(u)[1],n.trigger=a.exec(u)[1],n.endTrigger=a.exec(u)[1],n.endGuard=a.exec(u)[1]}else o=="snippet"?(n.tabTrigger=u.match(/^\S*/)[0],n.name||(n.name=u)):o&&(n[o]=u)}}return t},this.getSnippetByName=function(e,t){var n=this.snippetNameMap,r;return this.getActiveScopes(t).some(function(t){var i=n[t];return i&&(r=i[e]),!!r},this),r}}).call(d.prototype);var v=function(e){if(e.tabstopManager)return e.tabstopManager;e.tabstopManager=this,this.$onChange=this.onChange.bind(this),this.$onChangeSelection=o.delayedCall(this.onChangeSelection.bind(this)).schedule,this.$onChangeSession=this.onChangeSession.bind(this),this.$onAfterExec=this.onAfterExec.bind(this),this.attach(e)};(function(){this.attach=function(e){this.index=0,this.ranges=[],this.tabstops=[],this.$openTabstops=null,this.selectedTabstop=null,this.editor=e,this.editor.on("change",this.$onChange),this.editor.on("changeSelection",this.$onChangeSelection),this.editor.on("changeSession",this.$onChangeSession),this.editor.commands.on("afterExec",this.$onAfterExec),this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler)},this.detach=function(){this.tabstops.forEach(this.removeTabstopMarkers,this),this.ranges=null,this.tabstops=null,this.selectedTabstop=null,this.editor.removeListener("change",this.$onChange),this.editor.removeListener("changeSelection",this.$onChangeSelection),this.editor.removeListener("changeSession",this.$onChangeSession),this.editor.commands.removeListener("afterExec",this.$onAfterExec),this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler),this.editor.tabstopManager=null,this.editor=null},this.onChange=function(e){var t=e.action[0]=="r",n=this.selectedTabstop||{},r=n.parents||{},i=(this.tabstops||[]).slice();for(var s=0;s<i.length;s++){var o=i[s],u=o==n||r[o.index];o.rangeList.$bias=u?0:1;if(e.action=="remove"&&o!==n){var a=o.parents&&o.parents[n.index],f=o.rangeList.pointIndex(e.start,a);f=f<0?-f-1:f+1;var l=o.rangeList.pointIndex(e.end,a);l=l<0?-l-1:l-1;var c=o.rangeList.ranges.slice(f,l);for(var h=0;h<c.length;h++)this.removeRange(c[h])}o.rangeList.$onChange(e)}var p=this.editor.session;!this.$inChange&&t&&p.getLength()==1&&!p.getValue()&&this.detach()},this.updateLinkedFields=function(){var e=this.selectedTabstop;if(!e||!e.hasLinkedRanges||!e.firstNonLinked)return;this.$inChange=!0;var n=this.editor.session,r=n.getTextRange(e.firstNonLinked);for(var i=0;i<e.length;i++){var s=e[i];if(!s.linked)continue;var o=s.original,u=t.snippetManager.tmStrFormat(r,o,this.editor);n.replace(s,u)}this.$inChange=!1},this.onAfterExec=function(e){e.command&&!e.command.readOnly&&this.updateLinkedFields()},this.onChangeSelection=function(){if(!this.editor)return;var e=this.editor.selection.lead,t=this.editor.selection.anchor,n=this.editor.selection.isEmpty();for(var r=0;r<this.ranges.length;r++){if(this.ranges[r].linked)continue;var i=this.ranges[r].contains(e.row,e.column),s=n||this.ranges[r].contains(t.row,t.column);if(i&&s)return}this.detach()},this.onChangeSession=function(){this.detach()},this.tabNext=function(e){var t=this.tabstops.length,n=this.index+(e||1);n=Math.min(Math.max(n,1),t),n==t&&(n=0),this.selectTabstop(n),n===0&&this.detach()},this.selectTabstop=function(e){this.$openTabstops=null;var t=this.tabstops[this.index];t&&this.addTabstopMarkers(t),this.index=e,t=this.tabstops[this.index];if(!t||!t.length)return;this.selectedTabstop=t;var n=t.firstNonLinked||t;t.choices&&(n.cursor=n.start);if(!this.editor.inVirtualSelectionMode){var r=this.editor.multiSelect;r.toSingleRange(n);for(var i=0;i<t.length;i++){if(t.hasLinkedRanges&&t[i].linked)continue;r.addRange(t[i].clone(),!0)}}else this.editor.selection.fromOrientedRange(n);this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler),this.selectedTabstop&&this.selectedTabstop.choices&&this.editor.execCommand("startAutocomplete",{matches:this.selectedTabstop.choices})},this.addTabstops=function(e,t,n){var r=this.useLink||!this.editor.getOption("enableMultiselect");this.$openTabstops||(this.$openTabstops=[]);if(!e[0]){var i=u.fromPoints(n,n);g(i.start,t),g(i.end,t),e[0]=[i],e[0].index=0}var s=this.index,o=[s+1,0],f=this.ranges;e.forEach(function(e,n){var i=this.$openTabstops[n]||e;for(var s=0;s<e.length;s++){var l=e[s],c=u.fromPoints(l.start,l.end||l.start);m(c.start,t),m(c.end,t),c.original=l,c.tabstop=i,f.push(c),i!=e?i.unshift(c):i[s]=c,l.fmtString||i.firstNonLinked&&r?(c.linked=!0,i.hasLinkedRanges=!0):i.firstNonLinked||(i.firstNonLinked=c)}i.firstNonLinked||(i.hasLinkedRanges=!1),i===e&&(o.push(i),this.$openTabstops[n]=i),this.addTabstopMarkers(i),i.rangeList=i.rangeList||new a,i.rangeList.$bias=0,i.rangeList.addList(i)},this),o.length>2&&(this.tabstops.length&&o.push(o.splice(2,1)[0]),this.tabstops.splice.apply(this.tabstops,o))},this.addTabstopMarkers=function(e){var t=this.editor.session;e.forEach(function(e){e.markerId||(e.markerId=t.addMarker(e,"ace_snippet-marker","text"))})},this.removeTabstopMarkers=function(e){var t=this.editor.session;e.forEach(function(e){t.removeMarker(e.markerId),e.markerId=null})},this.removeRange=function(e){var t=e.tabstop.indexOf(e);t!=-1&&e.tabstop.splice(t,1),t=this.ranges.indexOf(e),t!=-1&&this.ranges.splice(t,1),t=e.tabstop.rangeList.ranges.indexOf(e),t!=-1&&e.tabstop.splice(t,1),this.editor.session.removeMarker(e.markerId),e.tabstop.length||(t=this.tabstops.indexOf(e.tabstop),t!=-1&&this.tabstops.splice(t,1),this.tabstops.length||this.detach())},this.keyboardHandler=new f,this.keyboardHandler.bindKeys({Tab:function(e){if(t.snippetManager&&t.snippetManager.expandWithTab(e))return;e.tabstopManager.tabNext(1),e.renderer.scrollCursorIntoView()},"Shift-Tab":function(e){e.tabstopManager.tabNext(-1),e.renderer.scrollCursorIntoView()},Esc:function(e){e.tabstopManager.detach()}})}).call(v.prototype);var m=function(e,t){e.row==0&&(e.column+=t.column),e.row+=t.row},g=function(e,t){e.row==t.row&&(e.column-=t.column),e.row-=t.row};r.importCssString(".ace_snippet-marker {    -moz-box-sizing: border-box;    box-sizing: border-box;    background: rgba(194, 193, 208, 0.09);    border: 1px dotted rgba(211, 208, 235, 0.62);    position: absolute;}","snippets.css",!1),t.snippetManager=new d;var y=e("./editor").Editor;(function(){this.insertSnippet=function(e,n){return t.snippetManager.insertSnippet(this,e,n)},this.expandSnippet=function(e){return t.snippetManager.expandWithTab(this,e)}}).call(y.prototype)}),ace.define("ace/autocomplete/popup",["require","exports","module","ace/virtual_renderer","ace/editor","ace/range","ace/lib/event","ace/lib/lang","ace/lib/dom"],function(e,t,n){"use strict";var r=e("../virtual_renderer").VirtualRenderer,i=e("../editor").Editor,s=e("../range").Range,o=e("../lib/event"),u=e("../lib/lang"),a=e("../lib/dom"),f=function(e){var t=new r(e);t.$maxLines=4;var n=new i(t);return n.setHighlightActiveLine(!1),n.setShowPrintMargin(!1),n.renderer.setShowGutter(!1),n.renderer.setHighlightGutterLine(!1),n.$mouseHandler.$focusTimeout=0,n.$highlightTagPending=!0,n},l=function(e){var t=a.createElement("div"),n=new f(t);e&&e.appendChild(t),t.style.display="none",n.renderer.content.style.cursor="default",n.renderer.setStyle("ace_autocomplete"),n.setOption("displayIndentGuides",!1),n.setOption("dragDelay",150);var r=function(){};n.focus=r,n.$isFocused=!0,n.renderer.$cursorLayer.restartTimer=r,n.renderer.$cursorLayer.element.style.opacity=0,n.renderer.$maxLines=8,n.renderer.$keepTextAreaAtCursor=!1,n.setHighlightActiveLine(!1),n.session.highlight(""),n.session.$searchHighlight.clazz="ace_highlight-marker",n.on("mousedown",function(e){var t=e.getDocumentPosition();n.selection.moveToPosition(t),c.start.row=c.end.row=t.row,e.stop()});var i,l=new s(-1,0,-1,Infinity),c=new s(-1,0,-1,Infinity);c.id=n.session.addMarker(c,"ace_active-line","fullLine"),n.setSelectOnHover=function(e){e?l.id&&(n.session.removeMarker(l.id),l.id=null):l.id=n.session.addMarker(l,"ace_line-hover","fullLine")},n.setSelectOnHover(!1),n.on("mousemove",function(e){if(!i){i=e;return}if(i.x==e.x&&i.y==e.y)return;i=e,i.scrollTop=n.renderer.scrollTop;var t=i.getDocumentPosition().row;l.start.row!=t&&(l.id||n.setRow(t),p(t))}),n.renderer.on("beforeRender",function(){if(i&&l.start.row!=-1){i.$pos=null;var e=i.getDocumentPosition().row;l.id||n.setRow(e),p(e,!0)}}),n.renderer.on("afterRender",function(){var e=n.getRow(),t=n.renderer.$textLayer,r=t.element.childNodes[e-t.config.firstRow];r!==t.selectedNode&&t.selectedNode&&a.removeCssClass(t.selectedNode,"ace_selected"),t.selectedNode=r,r&&a.addCssClass(r,"ace_selected")});var h=function(){p(-1)},p=function(e,t){e!==l.start.row&&(l.start.row=l.end.row=e,t||n.session._emit("changeBackMarker"),n._emit("changeHoverMarker"))};n.getHoveredRow=function(){return l.start.row},o.addListener(n.container,"mouseout",h),n.on("hide",h),n.on("changeSelection",h),n.session.doc.getLength=function(){return n.data.length},n.session.doc.getLine=function(e){var t=n.data[e];return typeof t=="string"?t:t&&t.value||""};var d=n.session.bgTokenizer;return d.$tokenizeRow=function(e){function s(e,n){e&&r.push({type:(t.className||"")+(n||""),value:e})}var t=n.data[e],r=[];if(!t)return r;typeof t=="string"&&(t={value:t});var i=t.caption||t.value||t.name,o=i.toLowerCase(),u=(n.filterText||"").toLowerCase(),a=0,f=0;for(var l=0;l<=u.length;l++)if(l!=f&&(t.matchMask&1<<l||l==u.length)){var c=u.slice(f,l);f=l;var h=o.indexOf(c,a);if(h==-1)continue;s(i.slice(a,h),""),a=h+c.length,s(i.slice(h,a),"completion-highlight")}return s(i.slice(a,i.length),""),t.meta&&r.push({type:"completion-meta",value:t.meta}),t.message&&r.push({type:"completion-message",value:t.message}),r},d.$updateOnChange=r,d.start=r,n.session.$computeWidth=function(){return this.screenWidth=0},n.isOpen=!1,n.isTopdown=!1,n.autoSelect=!0,n.filterText="",n.data=[],n.setData=function(e,t){n.filterText=t||"",n.setValue(u.stringRepeat("\n",e.length),-1),n.data=e||[],n.setRow(0)},n.getData=function(e){return n.data[e]},n.getRow=function(){return c.start.row},n.setRow=function(e){e=Math.max(this.autoSelect?0:-1,Math.min(this.data.length,e)),c.start.row!=e&&(n.selection.clearSelection(),c.start.row=c.end.row=e||0,n.session._emit("changeBackMarker"),n.moveCursorTo(e||0,0),n.isOpen&&n._signal("select"))},n.on("changeSelection",function(){n.isOpen&&n.setRow(n.selection.lead.row),n.renderer.scrollCursorIntoView()}),n.hide=function(){this.container.style.display="none",this._signal("hide"),n.isOpen=!1},n.show=function(e,t,r){var s=this.container,o=window.innerHeight,u=window.innerWidth,a=this.renderer,f=a.$maxLines*t*1.4,l=e.top+this.$borderSize,c=l>o/2&&!r;c&&l+t+f>o?(a.$maxPixelHeight=l-2*this.$borderSize,s.style.top="",s.style.bottom=o-l+"px",n.isTopdown=!1):(l+=t,a.$maxPixelHeight=o-l-.2*t,s.style.top=l+"px",s.style.bottom="",n.isTopdown=!0),s.style.display="";var h=e.left;h+s.offsetWidth>u&&(h=u-s.offsetWidth),s.style.left=h+"px",this._signal("show"),i=null,n.isOpen=!0},n.goTo=function(e){var t=this.getRow(),n=this.session.getLength()-1;switch(e){case"up":t=t<=0?n:t-1;break;case"down":t=t>=n?-1:t+1;break;case"start":t=0;break;case"end":t=n}this.setRow(t)},n.getTextLeftOffset=function(){return this.$borderSize+this.renderer.$padding+this.$imageSize},n.$imageSize=0,n.$borderSize=1,n};a.importCssString(".ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {    background-color: #CAD6FA;    z-index: 1;}.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {    background-color: #3a674e;}.ace_editor.ace_autocomplete .ace_line-hover {    border: 1px solid #abbffe;    margin-top: -1px;    background: rgba(233,233,253,0.4);    position: absolute;    z-index: 2;}.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {    border: 1px solid rgba(109, 150, 13, 0.8);    background: rgba(58, 103, 78, 0.62);}.ace_completion-meta {    opacity: 0.5;    margin: 0.9em;}.ace_completion-message {    color: blue;}.ace_editor.ace_autocomplete .ace_completion-highlight{    color: #2d69c7;}.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{    color: #93ca12;}.ace_editor.ace_autocomplete {    width: 300px;    z-index: 200000;    border: 1px lightgray solid;    position: fixed;    box-shadow: 2px 3px 5px rgba(0,0,0,.2);    line-height: 1.4;    background: #fefefe;    color: #111;}.ace_dark.ace_editor.ace_autocomplete {    border: 1px #484747 solid;    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);    line-height: 1.4;    background: #25282c;    color: #c1c1c1;}","autocompletion.css",!1),t.AcePopup=l,t.$singleLineEditor=f}),ace.define("ace/autocomplete/util",["require","exports","module"],function(e,t,n){"use strict";t.parForEach=function(e,t,n){var r=0,i=e.length;i===0&&n();for(var s=0;s<i;s++)t(e[s],function(e,t){r++,r===i&&n(e,t)})};var r=/[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;t.retrievePrecedingIdentifier=function(e,t,n){n=n||r;var i=[];for(var s=t-1;s>=0;s--){if(!n.test(e[s]))break;i.push(e[s])}return i.reverse().join("")},t.retrieveFollowingIdentifier=function(e,t,n){n=n||r;var i=[];for(var s=t;s<e.length;s++){if(!n.test(e[s]))break;i.push(e[s])}return i},t.getCompletionPrefix=function(e){var t=e.getCursorPosition(),n=e.session.getLine(t.row),r;return e.completers.forEach(function(e){e.identifierRegexps&&e.identifierRegexps.forEach(function(e){!r&&e&&(r=this.retrievePrecedingIdentifier(n,t.column,e))}.bind(this))}.bind(this)),r||this.retrievePrecedingIdentifier(n,t.column)}}),ace.define("ace/autocomplete",["require","exports","module","ace/keyboard/hash_handler","ace/autocomplete/popup","ace/autocomplete/util","ace/lib/lang","ace/lib/dom","ace/snippets","ace/config"],function(e,t,n){"use strict";var r=e("./keyboard/hash_handler").HashHandler,i=e("./autocomplete/popup").AcePopup,s=e("./autocomplete/util"),o=e("./lib/lang"),u=e("./lib/dom"),a=e("./snippets").snippetManager,f=e("./config"),l=function(){this.autoInsert=!1,this.autoSelect=!0,this.exactMatch=!1,this.gatherCompletionsId=0,this.keyboardHandler=new r,this.keyboardHandler.bindKeys(this.commands),this.blurListener=this.blurListener.bind(this),this.changeListener=this.changeListener.bind(this),this.mousedownListener=this.mousedownListener.bind(this),this.mousewheelListener=this.mousewheelListener.bind(this),this.changeTimer=o.delayedCall(function(){this.updateCompletions(!0)}.bind(this)),this.tooltipTimer=o.delayedCall(this.updateDocTooltip.bind(this),50)};(function(){this.$init=function(){return this.popup=new i(document.body||document.documentElement),this.popup.on("click",function(e){this.insertMatch(),e.stop()}.bind(this)),this.popup.focus=this.editor.focus.bind(this.editor),this.popup.on("show",this.tooltipTimer.bind(null,null)),this.popup.on("select",this.tooltipTimer.bind(null,null)),this.popup.on("changeHoverMarker",this.tooltipTimer.bind(null,null)),this.popup},this.getPopup=function(){return this.popup||this.$init()},this.openPopup=function(e,t,n){this.popup||this.$init(),this.popup.autoSelect=this.autoSelect,this.popup.setData(this.completions.filtered,this.completions.filterText),e.keyBinding.addKeyboardHandler(this.keyboardHandler);var r=e.renderer;this.popup.setRow(this.autoSelect?0:-1);if(!n){this.popup.setTheme(e.getTheme()),this.popup.setFontSize(e.getFontSize());var i=r.layerConfig.lineHeight,s=r.$cursorLayer.getPixelPosition(this.base,!0);s.left-=this.popup.getTextLeftOffset();var o=e.container.getBoundingClientRect();s.top+=o.top-r.layerConfig.offset,s.left+=o.left-e.renderer.scrollLeft,s.left+=r.gutterWidth,this.popup.show(s,i)}else n&&!t&&this.detach();this.changeTimer.cancel()},this.detach=function(){this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler),this.editor.off("changeSelection",this.changeListener),this.editor.off("blur",this.blurListener),this.editor.off("mousedown",this.mousedownListener),this.editor.off("mousewheel",this.mousewheelListener),this.changeTimer.cancel(),this.hideDocTooltip(),this.gatherCompletionsId+=1,this.popup&&this.popup.isOpen&&this.popup.hide(),this.base&&this.base.detach(),this.activated=!1,this.completions=this.base=null},this.changeListener=function(e){var t=this.editor.selection.lead;(t.row!=this.base.row||t.column<this.base.column)&&this.detach(),this.activated?this.changeTimer.schedule():this.detach()},this.blurListener=function(e){var t=document.activeElement,n=this.editor.textInput.getElement(),r=e.relatedTarget&&this.tooltipNode&&this.tooltipNode.contains(e.relatedTarget),i=this.popup&&this.popup.container;t!=n&&t.parentNode!=i&&!r&&t!=this.tooltipNode&&e.relatedTarget!=n&&this.detach()},this.mousedownListener=function(e){this.detach()},this.mousewheelListener=function(e){this.detach()},this.goTo=function(e){this.popup.goTo(e)},this.insertMatch=function(e,t){e||(e=this.popup.getData(this.popup.getRow()));if(!e)return!1;var n=this.completions;this.editor.startOperation({command:{name:"insertMatch"}});if(e.completer&&e.completer.insertMatch)e.completer.insertMatch(this.editor,e);else{if(n.filterText){var r=this.editor.selection.getAllRanges();for(var i=0,s;s=r[i];i++)s.start.column-=n.filterText.length,this.editor.session.remove(s)}e.snippet?a.insertSnippet(this.editor,e.snippet):this.editor.execCommand("insertstring",e.value||e)}this.completions==n&&this.detach(),this.editor.endOperation()},this.commands={Up:function(e){e.completer.goTo("up")},Down:function(e){e.completer.goTo("down")},"Ctrl-Up|Ctrl-Home":function(e){e.completer.goTo("start")},"Ctrl-Down|Ctrl-End":function(e){e.completer.goTo("end")},Esc:function(e){e.completer.detach()},Return:function(e){return e.completer.insertMatch()},"Shift-Return":function(e){e.completer.insertMatch(null,{deleteSuffix:!0})},Tab:function(e){var t=e.completer.insertMatch();if(!!t||!!e.tabstopManager)return t;e.completer.goTo("down")},PageUp:function(e){e.completer.popup.gotoPageUp()},PageDown:function(e){e.completer.popup.gotoPageDown()}},this.gatherCompletions=function(e,t){var n=e.getSession(),r=e.getCursorPosition(),i=s.getCompletionPrefix(e);this.base=n.doc.createAnchor(r.row,r.column-i.length),this.base.$insertRight=!0;var o=[],u=e.completers.length;return e.completers.forEach(function(a,f){a.getCompletions(e,n,r,i,function(n,r){!n&&r&&(o=o.concat(r)),t(null,{prefix:s.getCompletionPrefix(e),matches:o,finished:--u===0})})}),!0},this.showPopup=function(e,t){this.editor&&this.detach(),this.activated=!0,this.editor=e,e.completer!=this&&(e.completer&&e.completer.detach(),e.completer=this),e.on("changeSelection",this.changeListener),e.on("blur",this.blurListener),e.on("mousedown",this.mousedownListener),e.on("mousewheel",this.mousewheelListener),this.updateCompletions(!1,t)},this.updateCompletions=function(e,t){if(e&&this.base&&this.completions){var n=this.editor.getCursorPosition(),r=this.editor.session.getTextRange({start:this.base,end:n});if(r==this.completions.filterText)return;this.completions.setFilter(r);if(!this.completions.filtered.length)return this.detach();if(this.completions.filtered.length==1&&this.completions.filtered[0].value==r&&!this.completions.filtered[0].snippet)return this.detach();this.openPopup(this.editor,r,e);return}if(t&&t.matches){var n=this.editor.getSelectionRange().start;return this.base=this.editor.session.doc.createAnchor(n.row,n.column),this.base.$insertRight=!0,this.completions=new c(t.matches),this.openPopup(this.editor,"",e)}var i=this.gatherCompletionsId,s=function(e){if(!e.finished)return;return this.detach()}.bind(this),o=function(t){var n=t.prefix,r=t.matches;this.completions=new c(r),this.exactMatch&&(this.completions.exactMatch=!0),this.completions.setFilter(n);var i=this.completions.filtered;if(!i.length)return s(t);if(i.length==1&&i[0].value==n&&!i[0].snippet)return s(t);if(this.autoInsert&&i.length==1&&t.finished)return this.insertMatch(i[0]);this.openPopup(this.editor,n,e)}.bind(this),u=!0,a=null;this.gatherCompletions(this.editor,function(e,t){var n=t.prefix,r=t&&t.matches;if(!r||!r.length)return s(t);if(n.indexOf(t.prefix)!==0||i!=this.gatherCompletionsId)return;if(u){a=t;return}o(t)}.bind(this)),u=!1;if(a){var f=a;a=null,o(f)}},this.cancelContextMenu=function(){this.editor.$mouseHandler.cancelContextMenu()},this.updateDocTooltip=function(){var e=this.popup,t=e.data,n=t&&(t[e.getHoveredRow()]||t[e.getRow()]),r=null;if(!n||!this.editor||!this.popup.isOpen)return this.hideDocTooltip();this.editor.completers.some(function(e){return e.getDocTooltip&&(r=e.getDocTooltip(n)),r}),!r&&typeof n!="string"&&(r=n),typeof r=="string"&&(r={docText:r});if(!r||!r.docHTML&&!r.docText)return this.hideDocTooltip();this.showDocTooltip(r)},this.showDocTooltip=function(e){this.tooltipNode||(this.tooltipNode=u.createElement("div"),this.tooltipNode.className="ace_tooltip ace_doc-tooltip",this.tooltipNode.style.margin=0,this.tooltipNode.style.pointerEvents="auto",this.tooltipNode.tabIndex=-1,this.tooltipNode.onblur=this.blurListener.bind(this),this.tooltipNode.onclick=this.onTooltipClick.bind(this));var t=this.tooltipNode;e.docHTML?t.innerHTML=e.docHTML:e.docText&&(t.textContent=e.docText),t.parentNode||document.body.appendChild(t);var n=this.popup,r=n.container.getBoundingClientRect();t.style.top=n.container.style.top,t.style.bottom=n.container.style.bottom,t.style.display="block",window.innerWidth-r.right<320?r.left<320?n.isTopdown?(t.style.top=r.bottom+"px",t.style.left=r.left+"px",t.style.right="",t.style.bottom=""):(t.style.top=n.container.offsetTop-t.offsetHeight+"px",t.style.left=r.left+"px",t.style.right="",t.style.bottom=""):(t.style.right=window.innerWidth-r.left+"px",t.style.left=""):(t.style.left=r.right+1+"px",t.style.right="")},this.hideDocTooltip=function(){this.tooltipTimer.cancel();if(!this.tooltipNode)return;var e=this.tooltipNode;!this.editor.isFocused()&&document.activeElement==e&&this.editor.focus(),this.tooltipNode=null,e.parentNode&&e.parentNode.removeChild(e)},this.onTooltipClick=function(e){var t=e.target;while(t&&t!=this.tooltipNode){if(t.nodeName=="A"&&t.href){t.rel="noreferrer",t.target="_blank";break}t=t.parentNode}},this.destroy=function(){this.detach();if(this.popup){this.popup.destroy();var e=this.popup.container;e&&e.parentNode&&e.parentNode.removeChild(e)}this.editor&&this.editor.completer==this&&this.editor.completer==null,this.popup=null}}).call(l.prototype),l.for=function(e){return e.completer?e.completer:(f.get("sharedPopups")?(l.$shared||(l.$sharedInstance=new l),e.completer=l.$sharedInstance):(e.completer=new l,e.once("destroy",function(e,t){t.completer.destroy()})),e.completer)},l.startCommand={name:"startAutocomplete",exec:function(e,t){var n=l.for(e);n.autoInsert=!1,n.autoSelect=!0,n.showPopup(e,t),n.cancelContextMenu()},bindKey:"Ctrl-Space|Ctrl-Shift-Space|Alt-Space"};var c=function(e,t){this.all=e,this.filtered=e,this.filterText=t||"",this.exactMatch=!1};(function(){this.setFilter=function(e){if(e.length>this.filterText&&e.lastIndexOf(this.filterText,0)===0)var t=this.filtered;else var t=this.all;this.filterText=e,t=this.filterCompletions(t,this.filterText),t=t.sort(function(e,t){return t.exactMatch-e.exactMatch||t.$score-e.$score||(e.caption||e.value).localeCompare(t.caption||t.value)});var n=null;t=t.filter(function(e){var t=e.snippet||e.caption||e.value;return t===n?!1:(n=t,!0)}),this.filtered=t},this.filterCompletions=function(e,t){var n=[],r=t.toUpperCase(),i=t.toLowerCase();e:for(var s=0,o;o=e[s];s++){var u=o.caption||o.value||o.snippet;if(!u)continue;var a=-1,f=0,l=0,c,h;if(this.exactMatch){if(t!==u.substr(0,t.length))continue e}else{var p=u.toLowerCase().indexOf(i);if(p>-1)l=p;else for(var d=0;d<t.length;d++){var v=u.indexOf(i[d],a+1),m=u.indexOf(r[d],a+1);c=v>=0?m<0||v<m?v:m:m;if(c<0)continue e;h=c-a-1,h>0&&(a===-1&&(l+=10),l+=h,f|=1<<d),a=c}}o.matchMask=f,o.exactMatch=l?0:1,o.$score=(o.score||0)-l,n.push(o)}return n}}).call(c.prototype),t.Autocomplete=l,t.FilteredList=c}),ace.define("ace/autocomplete/text_completer",["require","exports","module","ace/range"],function(e,t,n){function s(e,t){var n=e.getTextRange(r.fromPoints({row:0,column:0},t));return n.split(i).length-1}function o(e,t){var n=s(e,t),r=e.getValue().split(i),o=Object.create(null),u=r[n];return r.forEach(function(e,t){if(!e||e===u)return;var i=Math.abs(n-t),s=r.length-i;o[e]?o[e]=Math.max(s,o[e]):o[e]=s}),o}var r=e("../range").Range,i=/[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;t.getCompletions=function(e,t,n,r,i){var s=o(t,n),u=Object.keys(s);i(null,u.map(function(e){return{caption:e,value:e,score:s[e],meta:"local"}}))}}),ace.define("ace/ext/language_tools",["require","exports","module","ace/snippets","ace/autocomplete","ace/config","ace/lib/lang","ace/autocomplete/util","ace/autocomplete/text_completer","ace/editor","ace/config"],function(e,t,n){"use strict";var r=e("../snippets").snippetManager,i=e("../autocomplete").Autocomplete,s=e("../config"),o=e("../lib/lang"),u=e("../autocomplete/util"),a=e("../autocomplete/text_completer"),f={getCompletions:function(e,t,n,r,i){if(t.$mode.completer)return t.$mode.completer.getCompletions(e,t,n,r,i);var s=e.session.getState(n.row),o=t.$mode.getCompletions(s,t,n,r);i(null,o)}},l=function(e){var t={};return e.replace(/\${(\d+)(:(.*?))?}/g,function(e,n,r,i){return t[n]=i||""}).replace(/\$(\d+?)/g,function(e,n){return t[n]})},c={getCompletions:function(e,t,n,i,s){var o=[],u=t.getTokenAt(n.row,n.column);u&&u.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/)?o.push("html-tag"):o=r.getActiveScopes(e);var a=r.snippetMap,f=[];o.forEach(function(e){var t=a[e]||[];for(var n=t.length;n--;){var r=t[n],i=r.name||r.tabTrigger;if(!i)continue;f.push({caption:i,snippet:r.content,meta:r.tabTrigger&&!r.name?r.tabTrigger+"\u21e5 ":"snippet",type:"snippet"})}},this),s(null,f)},getDocTooltip:function(e){e.type=="snippet"&&!e.docHTML&&(e.docHTML=["<b>",o.escapeHTML(e.caption),"</b>","<hr></hr>",o.escapeHTML(l(e.snippet))].join(""))}},h=[c,a,f];t.setCompleters=function(e){h.length=0,e&&h.push.apply(h,e)},t.addCompleter=function(e){h.push(e)},t.textCompleter=a,t.keyWordCompleter=f,t.snippetCompleter=c;var p={name:"expandSnippet",exec:function(e){return r.expandWithTab(e)},bindKey:"Tab"},d=function(e,t){v(t.session.$mode)},v=function(e){typeof e=="string"&&(e=s.$modes[e]);if(!e)return;r.files||(r.files={}),m(e.$id,e.snippetFileId),e.modes&&e.modes.forEach(v)},m=function(e,t){if(!t||!e||r.files[e])return;r.files[e]={},s.loadModule(t,function(t){if(!t)return;r.files[e]=t,!t.snippets&&t.snippetText&&(t.snippets=r.parseSnippetFile(t.snippetText)),r.register(t.snippets||[],t.scope),t.includeScopes&&(r.snippetMap[t.scope].includeScopes=t.includeScopes,t.includeScopes.forEach(function(e){v("ace/mode/"+e)}))})},g=function(e){var t=e.editor,n=t.completer&&t.completer.activated;if(e.command.name==="backspace")n&&!u.getCompletionPrefix(t)&&t.completer.detach();else if(e.command.name==="insertstring"){var r=u.getCompletionPrefix(t);if(r&&!n){var s=i.for(t);s.autoInsert=!1,s.showPopup(t)}}},y=e("../editor").Editor;e("../config").defineOptions(y.prototype,"editor",{enableBasicAutocompletion:{set:function(e){e?(this.completers||(this.completers=Array.isArray(e)?e:h),this.commands.addCommand(i.startCommand)):this.commands.removeCommand(i.startCommand)},value:!1},enableLiveAutocompletion:{set:function(e){e?(this.completers||(this.completers=Array.isArray(e)?e:h),this.commands.on("afterExec",g)):this.commands.removeListener("afterExec",g)},value:!1},enableSnippets:{set:function(e){e?(this.commands.addCommand(p),this.on("changeMode",d),d(null,this)):(this.commands.removeCommand(p),this.off("changeMode",d))},value:!1}})});                (function() {
                    ace.require(["ace/ext/language_tools"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='ext_searchbox'  type='text/javascript'  charset='utf-8'>ace.define("ace/ext/searchbox",["require","exports","module","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/keyboard/hash_handler","ace/lib/keys"], function(require, exports, module) {
"use strict";

var dom = require("../lib/dom");
var lang = require("../lib/lang");
var event = require("../lib/event");
var searchboxCss = "\
.ace_search {\
background-color: #ddd;\
color: #666;\
border: 1px solid #cbcbcb;\
border-top: 0 none;\
overflow: hidden;\
margin: 0;\
padding: 4px 6px 0 4px;\
position: absolute;\
top: 0;\
z-index: 99;\
white-space: normal;\
}\
.ace_search.left {\
border-left: 0 none;\
border-radius: 0px 0px 5px 0px;\
left: 0;\
}\
.ace_search.right {\
border-radius: 0px 0px 0px 5px;\
border-right: 0 none;\
right: 0;\
}\
.ace_search_form, .ace_replace_form {\
margin: 0 20px 4px 0;\
overflow: hidden;\
line-height: 1.9;\
}\
.ace_replace_form {\
margin-right: 0;\
}\
.ace_search_form.ace_nomatch {\
outline: 1px solid red;\
}\
.ace_search_field {\
border-radius: 3px 0 0 3px;\
background-color: white;\
color: black;\
border: 1px solid #cbcbcb;\
border-right: 0 none;\
outline: 0;\
padding: 0;\
font-size: inherit;\
margin: 0;\
line-height: inherit;\
padding: 0 6px;\
min-width: 17em;\
vertical-align: top;\
min-height: 1.8em;\
box-sizing: content-box;\
}\
.ace_searchbtn {\
border: 1px solid #cbcbcb;\
line-height: inherit;\
display: inline-block;\
padding: 0 6px;\
background: #fff;\
border-right: 0 none;\
border-left: 1px solid #dcdcdc;\
cursor: pointer;\
margin: 0;\
position: relative;\
color: #666;\
}\
.ace_searchbtn:last-child {\
border-radius: 0 3px 3px 0;\
border-right: 1px solid #cbcbcb;\
}\
.ace_searchbtn:disabled {\
background: none;\
cursor: default;\
}\
.ace_searchbtn:hover {\
background-color: #eef1f6;\
}\
.ace_searchbtn.prev, .ace_searchbtn.next {\
padding: 0px 0.7em\
}\
.ace_searchbtn.prev:after, .ace_searchbtn.next:after {\
content: \"\";\
border: solid 2px #888;\
width: 0.5em;\
height: 0.5em;\
border-width:  2px 0 0 2px;\
display:inline-block;\
transform: rotate(-45deg);\
}\
.ace_searchbtn.next:after {\
border-width: 0 2px 2px 0 ;\
}\
.ace_searchbtn_close {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\
border-radius: 50%;\
border: 0 none;\
color: #656565;\
cursor: pointer;\
font: 16px/16px Arial;\
padding: 0;\
height: 14px;\
width: 14px;\
top: 9px;\
right: 7px;\
position: absolute;\
}\
.ace_searchbtn_close:hover {\
background-color: #656565;\
background-position: 50% 100%;\
color: white;\
}\
.ace_button {\
margin-left: 2px;\
cursor: pointer;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
overflow: hidden;\
opacity: 0.7;\
border: 1px solid rgba(100,100,100,0.23);\
padding: 1px;\
box-sizing:    border-box!important;\
color: black;\
}\
.ace_button:hover {\
background-color: #eee;\
opacity:1;\
}\
.ace_button:active {\
background-color: #ddd;\
}\
.ace_button.checked {\
border-color: #3399ff;\
opacity:1;\
}\
.ace_search_options{\
margin-bottom: 3px;\
text-align: right;\
-webkit-user-select: none;\
-moz-user-select: none;\
-o-user-select: none;\
-ms-user-select: none;\
user-select: none;\
clear: both;\
}\
.ace_search_counter {\
float: left;\
font-family: arial;\
padding: 0 8px;\
}";
var HashHandler = require("../keyboard/hash_handler").HashHandler;
var keyUtil = require("../lib/keys");

var MAX_COUNT = 999;

dom.importCssString(searchboxCss, "ace_searchbox", false);

var SearchBox = function(editor, range, showReplaceForm) {
    var div = dom.createElement("div");
    dom.buildDom(["div", {class:"ace_search right"},
        ["span", {action: "hide", class: "ace_searchbtn_close"}],
        ["div", {class: "ace_search_form"},
            ["input", {class: "ace_search_field", placeholder: "Search for", spellcheck: "false"}],
            ["span", {action: "findPrev", class: "ace_searchbtn prev"}, "\u200b"],
            ["span", {action: "findNext", class: "ace_searchbtn next"}, "\u200b"],
            ["span", {action: "findAll", class: "ace_searchbtn", title: "Alt-Enter"}, "All"]
        ],
        ["div", {class: "ace_replace_form"},
            ["input", {class: "ace_search_field", placeholder: "Replace with", spellcheck: "false"}],
            ["span", {action: "replaceAndFindNext", class: "ace_searchbtn"}, "Replace"],
            ["span", {action: "replaceAll", class: "ace_searchbtn"}, "All"]
        ],
        ["div", {class: "ace_search_options"},
            ["span", {action: "toggleReplace", class: "ace_button", title: "Toggle Replace mode",
                style: "float:left;margin-top:-2px;padding:0 5px;"}, "+"],
            ["span", {class: "ace_search_counter"}],
            ["span", {action: "toggleRegexpMode", class: "ace_button", title: "RegExp Search"}, ".*"],
            ["span", {action: "toggleCaseSensitive", class: "ace_button", title: "CaseSensitive Search"}, "Aa"],
            ["span", {action: "toggleWholeWords", class: "ace_button", title: "Whole Word Search"}, "\\b"],
            ["span", {action: "searchInSelection", class: "ace_button", title: "Search In Selection"}, "S"]
        ]
    ], div);
    this.element = div.firstChild;
    
    this.setSession = this.setSession.bind(this);

    this.$init();
    this.setEditor(editor);
    dom.importCssString(searchboxCss, "ace_searchbox", editor.container);
};

(function() {
    this.setEditor = function(editor) {
        editor.searchBox = this;
        editor.renderer.scroller.appendChild(this.element);
        this.editor = editor;
    };
    
    this.setSession = function(e) {
        this.searchRange = null;
        this.$syncOptions(true);
    };

    this.$initElements = function(sb) {
        this.searchBox = sb.querySelector(".ace_search_form");
        this.replaceBox = sb.querySelector(".ace_replace_form");
        this.searchOption = sb.querySelector("[action=searchInSelection]");
        this.replaceOption = sb.querySelector("[action=toggleReplace]");
        this.regExpOption = sb.querySelector("[action=toggleRegexpMode]");
        this.caseSensitiveOption = sb.querySelector("[action=toggleCaseSensitive]");
        this.wholeWordOption = sb.querySelector("[action=toggleWholeWords]");
        this.searchInput = this.searchBox.querySelector(".ace_search_field");
        this.replaceInput = this.replaceBox.querySelector(".ace_search_field");
        this.searchCounter = sb.querySelector(".ace_search_counter");
    };
    
    this.$init = function() {
        var sb = this.element;
        
        this.$initElements(sb);
        
        var _this = this;
        event.addListener(sb, "mousedown", function(e) {
            setTimeout(function(){
                _this.activeInput.focus();
            }, 0);
            event.stopPropagation(e);
        });
        event.addListener(sb, "click", function(e) {
            var t = e.target || e.srcElement;
            var action = t.getAttribute("action");
            if (action && _this[action])
                _this[action]();
            else if (_this.$searchBarKb.commands[action])
                _this.$searchBarKb.commands[action].exec(_this);
            event.stopPropagation(e);
        });

        event.addCommandKeyListener(sb, function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            var command = _this.$searchBarKb.findKeyCommand(hashId, keyString);
            if (command && command.exec) {
                command.exec(_this);
                event.stopEvent(e);
            }
        });

        this.$onChange = lang.delayedCall(function() {
            _this.find(false, false);
        });

        event.addListener(this.searchInput, "input", function() {
            _this.$onChange.schedule(20);
        });
        event.addListener(this.searchInput, "focus", function() {
            _this.activeInput = _this.searchInput;
            _this.searchInput.value && _this.highlight();
        });
        event.addListener(this.replaceInput, "focus", function() {
            _this.activeInput = _this.replaceInput;
            _this.searchInput.value && _this.highlight();
        });
    };
    this.$closeSearchBarKb = new HashHandler([{
        bindKey: "Esc",
        name: "closeSearchBar",
        exec: function(editor) {
            editor.searchBox.hide();
        }
    }]);
    this.$searchBarKb = new HashHandler();
    this.$searchBarKb.bindKeys({
        "Ctrl-f|Command-f": function(sb) {
            var isReplace = sb.isReplace = !sb.isReplace;
            sb.replaceBox.style.display = isReplace ? "" : "none";
            sb.replaceOption.checked = false;
            sb.$syncOptions();
            sb.searchInput.focus();
        },
        "Ctrl-H|Command-Option-F": function(sb) {
            if (sb.editor.getReadOnly())
                return;
            sb.replaceOption.checked = true;
            sb.$syncOptions();
            sb.replaceInput.focus();
        },
        "Ctrl-G|Command-G": function(sb) {
            sb.findNext();
        },
        "Ctrl-Shift-G|Command-Shift-G": function(sb) {
            sb.findPrev();
        },
        "esc": function(sb) {
            setTimeout(function() { sb.hide();});
        },
        "Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replace();
            sb.findNext();
        },
        "Shift-Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replace();
            sb.findPrev();
        },
        "Alt-Return": function(sb) {
            if (sb.activeInput == sb.replaceInput)
                sb.replaceAll();
            sb.findAll();
        },
        "Tab": function(sb) {
            (sb.activeInput == sb.replaceInput ? sb.searchInput : sb.replaceInput).focus();
        }
    });

    this.$searchBarKb.addCommands([{
        name: "toggleRegexpMode",
        bindKey: {win: "Alt-R|Alt-/", mac: "Ctrl-Alt-R|Ctrl-Alt-/"},
        exec: function(sb) {
            sb.regExpOption.checked = !sb.regExpOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "toggleCaseSensitive",
        bindKey: {win: "Alt-C|Alt-I", mac: "Ctrl-Alt-R|Ctrl-Alt-I"},
        exec: function(sb) {
            sb.caseSensitiveOption.checked = !sb.caseSensitiveOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "toggleWholeWords",
        bindKey: {win: "Alt-B|Alt-W", mac: "Ctrl-Alt-B|Ctrl-Alt-W"},
        exec: function(sb) {
            sb.wholeWordOption.checked = !sb.wholeWordOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "toggleReplace",
        exec: function(sb) {
            sb.replaceOption.checked = !sb.replaceOption.checked;
            sb.$syncOptions();
        }
    }, {
        name: "searchInSelection",
        exec: function(sb) {
            sb.searchOption.checked = !sb.searchRange;
            sb.setSearchRange(sb.searchOption.checked && sb.editor.getSelectionRange());
            sb.$syncOptions();
        }
    }]);
    
    this.setSearchRange = function(range) {
        this.searchRange = range;
        if (range) {
            this.searchRangeMarker = this.editor.session.addMarker(range, "ace_active-line");
        } else if (this.searchRangeMarker) {
            this.editor.session.removeMarker(this.searchRangeMarker);
            this.searchRangeMarker = null;
        }
    };

    this.$syncOptions = function(preventScroll) {
        dom.setCssClass(this.replaceOption, "checked", this.searchRange);
        dom.setCssClass(this.searchOption, "checked", this.searchOption.checked);
        this.replaceOption.textContent = this.replaceOption.checked ? "-" : "+";
        dom.setCssClass(this.regExpOption, "checked", this.regExpOption.checked);
        dom.setCssClass(this.wholeWordOption, "checked", this.wholeWordOption.checked);
        dom.setCssClass(this.caseSensitiveOption, "checked", this.caseSensitiveOption.checked);
        var readOnly = this.editor.getReadOnly();
        this.replaceOption.style.display = readOnly ? "none" : "";
        this.replaceBox.style.display = this.replaceOption.checked && !readOnly ? "" : "none";
        this.find(false, false, preventScroll);
    };

    this.highlight = function(re) {
        this.editor.session.highlight(re || this.editor.$search.$options.re);
        this.editor.renderer.updateBackMarkers();
    };
    this.find = function(skipCurrent, backwards, preventScroll) {
        var range = this.editor.find(this.searchInput.value, {
            skipCurrent: skipCurrent,
            backwards: backwards,
            wrap: true,
            regExp: this.regExpOption.checked,
            caseSensitive: this.caseSensitiveOption.checked,
            wholeWord: this.wholeWordOption.checked,
            preventScroll: preventScroll,
            range: this.searchRange
        });
        var noMatch = !range && this.searchInput.value;
        dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
        this.editor._emit("findSearchBox", { match: !noMatch });
        this.highlight();
        this.updateCounter();
    };
    this.updateCounter = function() {
        var editor = this.editor;
        var regex = editor.$search.$options.re;
        var all = 0;
        var before = 0;
        if (regex) {
            var value = this.searchRange
                ? editor.session.getTextRange(this.searchRange)
                : editor.getValue();
            
            var offset = editor.session.doc.positionToIndex(editor.selection.anchor);
            if (this.searchRange)
                offset -= editor.session.doc.positionToIndex(this.searchRange.start);
                
            var last = regex.lastIndex = 0;
            var m;
            while ((m = regex.exec(value))) {
                all++;
                last = m.index;
                if (last <= offset)
                    before++;
                if (all > MAX_COUNT)
                    break;
                if (!m[0]) {
                    regex.lastIndex = last += 1;
                    if (last >= value.length)
                        break;
                }
            }
        }
        this.searchCounter.textContent = before + " of " + (all > MAX_COUNT ? MAX_COUNT + "+" : all);
    };
    this.findNext = function() {
        this.find(true, false);
    };
    this.findPrev = function() {
        this.find(true, true);
    };
    this.findAll = function(){
        var range = this.editor.findAll(this.searchInput.value, {            
            regExp: this.regExpOption.checked,
            caseSensitive: this.caseSensitiveOption.checked,
            wholeWord: this.wholeWordOption.checked
        });
        var noMatch = !range && this.searchInput.value;
        dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
        this.editor._emit("findSearchBox", { match: !noMatch });
        this.highlight();
        this.hide();
    };
    this.replace = function() {
        if (!this.editor.getReadOnly())
            this.editor.replace(this.replaceInput.value);
    };    
    this.replaceAndFindNext = function() {
        if (!this.editor.getReadOnly()) {
            this.editor.replace(this.replaceInput.value);
            this.findNext();
        }
    };
    this.replaceAll = function() {
        if (!this.editor.getReadOnly())
            this.editor.replaceAll(this.replaceInput.value);
    };

    this.hide = function() {
        this.active = false;
        this.setSearchRange(null);
        this.editor.off("changeSession", this.setSession);
        
        this.element.style.display = "none";
        this.editor.keyBinding.removeKeyboardHandler(this.$closeSearchBarKb);
        this.editor.focus();
    };
    this.show = function(value, isReplace) {
        this.active = true;
        this.editor.on("changeSession", this.setSession);
        this.element.style.display = "";
        this.replaceOption.checked = isReplace;
        
        if (value)
            this.searchInput.value = value;
        
        this.searchInput.focus();
        this.searchInput.select();

        this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb);
        
        this.$syncOptions(true);
    };

    this.isFocused = function() {
        var el = document.activeElement;
        return el == this.searchInput || el == this.replaceInput;
    };
}).call(SearchBox.prototype);

exports.SearchBox = SearchBox;

exports.Search = function(editor, isReplace) {
    var sb = editor.searchBox || new SearchBox(editor);
    sb.show(editor.session.getTextRange(), isReplace);
};

});                (function() {
                    ace.require(["ace/ext/searchbox"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='ext_split'  type='text/javascript'  charset='utf-8'>ace.define("ace/split",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/editor","ace/virtual_renderer","ace/edit_session"], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var Editor = require("./editor").Editor;
var Renderer = require("./virtual_renderer").VirtualRenderer;
var EditSession = require("./edit_session").EditSession;


var Split = function(container, theme, splits) {
    this.BELOW = 1;
    this.BESIDE = 0;

    this.$container = container;
    this.$theme = theme;
    this.$splits = 0;
    this.$editorCSS = "";
    this.$editors = [];
    this.$orientation = this.BESIDE;

    this.setSplits(splits || 1);
    this.$cEditor = this.$editors[0];


    this.on("focus", function(editor) {
        this.$cEditor = editor;
    }.bind(this));
};

(function(){

    oop.implement(this, EventEmitter);

    this.$createEditor = function() {
        var el = document.createElement("div");
        el.className = this.$editorCSS;
        el.style.cssText = "position: absolute; top:0px; bottom:0px";
        this.$container.appendChild(el);
        var editor = new Editor(new Renderer(el, this.$theme));

        editor.on("focus", function() {
            this._emit("focus", editor);
        }.bind(this));

        this.$editors.push(editor);
        editor.setFontSize(this.$fontSize);
        return editor;
    };

    this.setSplits = function(splits) {
        var editor;
        if (splits < 1) {
            throw "The number of splits have to be > 0!";
        }

        if (splits == this.$splits) {
            return;
        } else if (splits > this.$splits) {
            while (this.$splits < this.$editors.length && this.$splits < splits) {
                editor = this.$editors[this.$splits];
                this.$container.appendChild(editor.container);
                editor.setFontSize(this.$fontSize);
                this.$splits ++;
            }
            while (this.$splits < splits) {
                this.$createEditor();
                this.$splits ++;
            }
        } else {
            while (this.$splits > splits) {
                editor = this.$editors[this.$splits - 1];
                this.$container.removeChild(editor.container);
                this.$splits --;
            }
        }
        this.resize();
    };
    this.getSplits = function() {
        return this.$splits;
    };
    this.getEditor = function(idx) {
        return this.$editors[idx];
    };
    this.getCurrentEditor = function() {
        return this.$cEditor;
    };
    this.focus = function() {
        this.$cEditor.focus();
    };
    this.blur = function() {
        this.$cEditor.blur();
    };
    this.setTheme = function(theme) {
        this.$editors.forEach(function(editor) {
            editor.setTheme(theme);
        });
    };
    this.setKeyboardHandler = function(keybinding) {
        this.$editors.forEach(function(editor) {
            editor.setKeyboardHandler(keybinding);
        });
    };
    this.forEach = function(callback, scope) {
        this.$editors.forEach(callback, scope);
    };


    this.$fontSize = "";
    this.setFontSize = function(size) {
        this.$fontSize = size;
        this.forEach(function(editor) {
           editor.setFontSize(size);
        });
    };

    this.$cloneSession = function(session) {
        var s = new EditSession(session.getDocument(), session.getMode());

        var undoManager = session.getUndoManager();
        s.setUndoManager(undoManager);
        s.setTabSize(session.getTabSize());
        s.setUseSoftTabs(session.getUseSoftTabs());
        s.setOverwrite(session.getOverwrite());
        s.setBreakpoints(session.getBreakpoints());
        s.setUseWrapMode(session.getUseWrapMode());
        s.setUseWorker(session.getUseWorker());
        s.setWrapLimitRange(session.$wrapLimitRange.min,
                            session.$wrapLimitRange.max);
        s.$foldData = session.$cloneFoldData();

        return s;
    };
    this.setSession = function(session, idx) {
        var editor;
        if (idx == null) {
            editor = this.$cEditor;
        } else {
            editor = this.$editors[idx];
        }
        var isUsed = this.$editors.some(function(editor) {
           return editor.session === session;
        });

        if (isUsed) {
            session = this.$cloneSession(session);
        }
        editor.setSession(session);
        return session;
    };
    this.getOrientation = function() {
        return this.$orientation;
    };
    this.setOrientation = function(orientation) {
        if (this.$orientation == orientation) {
            return;
        }
        this.$orientation = orientation;
        this.resize();
    };
    this.resize = function() {
        var width = this.$container.clientWidth;
        var height = this.$container.clientHeight;
        var editor;

        if (this.$orientation == this.BESIDE) {
            var editorWidth = width / this.$splits;
            for (var i = 0; i < this.$splits; i++) {
                editor = this.$editors[i];
                editor.container.style.width = editorWidth + "px";
                editor.container.style.top = "0px";
                editor.container.style.left = i * editorWidth + "px";
                editor.container.style.height = height + "px";
                editor.resize();
            }
        } else {
            var editorHeight = height / this.$splits;
            for (var i = 0; i < this.$splits; i++) {
                editor = this.$editors[i];
                editor.container.style.width = width + "px";
                editor.container.style.top = i * editorHeight + "px";
                editor.container.style.left = "0px";
                editor.container.style.height = editorHeight + "px";
                editor.resize();
            }
        }
    };

}).call(Split.prototype);

exports.Split = Split;
});

ace.define("ace/ext/split",["require","exports","module","ace/split"], function(require, exports, module) {
"use strict";
module.exports = require("../split");

});                (function() {
                    ace.require(["ace/ext/split"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='mode_css'  type='text/javascript'  charset='utf-8'>ace.define("ace/mode/css_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var supportType = exports.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|max-zoom|min-height|min-width|min-zoom|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|user-select|user-zoom|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero|zoom";
var supportConstantColor = exports.supportConstantColor = "aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen";
var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

var numRe = exports.numRe = "\\-?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+))";
var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
var pseudoClasses  = exports.pseudoClasses =  "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";

var CssHighlightRules = function() {

    var keywordMapper = this.createKeywordMapper({
        "support.function": supportFunction,
        "support.constant": supportConstant,
        "support.type": supportType,
        "support.constant.color": supportConstantColor,
        "support.constant.fonts": supportConstantFonts
    }, "text", true);

    this.$rules = {
        "start" : [{
            include : ["strings", "url", "comments"]
        }, {
            token: "paren.lparen",
            regex: "\\{",
            next:  "ruleset"
        }, {
            token: "paren.rparen",
            regex: "\\}"
        }, {
            token: "string",
            regex: "@(?!viewport)",
            next:  "media"
        }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
        }, {
            token: "keyword",
            regex: "%"
        }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
        }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
        }, {
            token : "constant.numeric",
            regex : numRe
        }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
        }, {
            caseInsensitive: true
        }],

        "media": [{
            include : ["strings", "url", "comments"]
        }, {
            token: "paren.lparen",
            regex: "\\{",
            next:  "start"
        }, {
            token: "paren.rparen",
            regex: "\\}",
            next:  "start"
        }, {
            token: "string",
            regex: ";",
            next:  "start"
        }, {
            token: "keyword",
            regex: "(?:media|supports|document|charset|import|namespace|media|supports|document"
                + "|page|font|keyframes|viewport|counter-style|font-feature-values"
                + "|swash|ornaments|annotation|stylistic|styleset|character-variant)"
        }],

        "comments" : [{
            token: "comment", // multi line comment
            regex: "\\/\\*",
            push: [{
                token : "comment",
                regex : "\\*\\/",
                next : "pop"
            }, {
                defaultToken : "comment"
            }]
        }],

        "ruleset" : [{
            regex : "-(webkit|ms|moz|o)-",
            token : "text"
        }, {
            token : "punctuation.operator",
            regex : "[:;]"
        }, {
            token : "paren.rparen",
            regex : "\\}",
            next : "start"
        }, {
            include : ["strings", "url", "comments"]
        }, {
            token : ["constant.numeric", "keyword"],
            regex : "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vmax|vmin|vm|vw|%)"
        }, {
            token : "constant.numeric",
            regex : numRe
        }, {
            token : "constant.numeric",  // hex6 color
            regex : "#[a-f0-9]{6}"
        }, {
            token : "constant.numeric", // hex3 color
            regex : "#[a-f0-9]{3}"
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
            regex : pseudoElements
        }, {
            token : ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
            regex : pseudoClasses
        }, {
            include: "url"
        }, {
            token : keywordMapper,
            regex : "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
        }, {
            caseInsensitive: true
        }],

        url: [{
            token : "support.function",
            regex : "(?:url(:?-prefix)?|domain|regexp)\\(",
            push: [{
                token : "support.function",
                regex : "\\)",
                next : "pop"
            }, {
                defaultToken: "string"
            }]
        }],

        strings: [{
            token : "string.start",
            regex : "'",
            push : [{
                token : "string.end",
                regex : "'|$",
                next: "pop"
            }, {
                include : "escapes"
            }, {
                token : "constant.language.escape",
                regex : /\\$/,
                consumeLineEnd: true
            }, {
                defaultToken: "string"
            }]
        }, {
            token : "string.start",
            regex : '"',
            push : [{
                token : "string.end",
                regex : '"|$',
                next: "pop"
            }, {
                include : "escapes"
            }, {
                token : "constant.language.escape",
                regex : /\\$/,
                consumeLineEnd: true
            }, {
                defaultToken: "string"
            }]
        }],
        escapes: [{
            token : "constant.language.escape",
            regex : /\\([a-fA-F\d]{1,6}|[^a-fA-F\d])/
        }]

    };

    this.normalizeRules();
};

oop.inherits(CssHighlightRules, TextHighlightRules);

exports.CssHighlightRules = CssHighlightRules;

});

ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

ace.define("ace/mode/css_completions",["require","exports","module"], function(require, exports, module) {
"use strict";

var propertyMap = {
    "background": {"#$0": 1},
    "background-color": {"#$0": 1, "transparent": 1, "fixed": 1},
    "background-image": {"url('/$0')": 1},
    "background-repeat": {"repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1},
    "background-position": {"bottom":2, "center":2, "left":2, "right":2, "top":2, "inherit":2},
    "background-attachment": {"scroll": 1, "fixed": 1},
    "background-size": {"cover": 1, "contain": 1},
    "background-clip": {"border-box": 1, "padding-box": 1, "content-box": 1},
    "background-origin": {"border-box": 1, "padding-box": 1, "content-box": 1},
    "border": {"solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1},
    "border-color": {"#$0": 1},
    "border-style": {"solid":2, "dashed":2, "dotted":2, "double":2, "groove":2, "hidden":2, "inherit":2, "inset":2, "none":2, "outset":2, "ridged":2},
    "border-collapse": {"collapse": 1, "separate": 1},
    "bottom": {"px": 1, "em": 1, "%": 1},
    "clear": {"left": 1, "right": 1, "both": 1, "none": 1},
    "color": {"#$0": 1, "rgb(#$00,0,0)": 1},
    "cursor": {"default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1},
    "display": {"none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1},
    "empty-cells": {"show": 1, "hide": 1},
    "float": {"left": 1, "right": 1, "none": 1},
    "font-family": {"Arial":2,"Comic Sans MS":2,"Consolas":2,"Courier New":2,"Courier":2,"Georgia":2,"Monospace":2,"Sans-Serif":2, "Segoe UI":2,"Tahoma":2,"Times New Roman":2,"Trebuchet MS":2,"Verdana": 1},
    "font-size": {"px": 1, "em": 1, "%": 1},
    "font-weight": {"bold": 1, "normal": 1},
    "font-style": {"italic": 1, "normal": 1},
    "font-variant": {"normal": 1, "small-caps": 1},
    "height": {"px": 1, "em": 1, "%": 1},
    "left": {"px": 1, "em": 1, "%": 1},
    "letter-spacing": {"normal": 1},
    "line-height": {"normal": 1},
    "list-style-type": {"none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1},
    "margin": {"px": 1, "em": 1, "%": 1},
    "margin-right": {"px": 1, "em": 1, "%": 1},
    "margin-left": {"px": 1, "em": 1, "%": 1},
    "margin-top": {"px": 1, "em": 1, "%": 1},
    "margin-bottom": {"px": 1, "em": 1, "%": 1},
    "max-height": {"px": 1, "em": 1, "%": 1},
    "max-width": {"px": 1, "em": 1, "%": 1},
    "min-height": {"px": 1, "em": 1, "%": 1},
    "min-width": {"px": 1, "em": 1, "%": 1},
    "overflow": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
    "overflow-x": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
    "overflow-y": {"hidden": 1, "visible": 1, "auto": 1, "scroll": 1},
    "padding": {"px": 1, "em": 1, "%": 1},
    "padding-top": {"px": 1, "em": 1, "%": 1},
    "padding-right": {"px": 1, "em": 1, "%": 1},
    "padding-bottom": {"px": 1, "em": 1, "%": 1},
    "padding-left": {"px": 1, "em": 1, "%": 1},
    "page-break-after": {"auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1},
    "page-break-before": {"auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1},
    "position": {"absolute": 1, "relative": 1, "fixed": 1, "static": 1},
    "right": {"px": 1, "em": 1, "%": 1},
    "table-layout": {"fixed": 1, "auto": 1},
    "text-decoration": {"none": 1, "underline": 1, "line-through": 1, "blink": 1},
    "text-align": {"left": 1, "right": 1, "center": 1, "justify": 1},
    "text-transform": {"capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1},
    "top": {"px": 1, "em": 1, "%": 1},
    "vertical-align": {"top": 1, "bottom": 1},
    "visibility": {"hidden": 1, "visible": 1},
    "white-space": {"nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1},
    "width": {"px": 1, "em": 1, "%": 1},
    "word-spacing": {"normal": 1},
    "filter": {"alpha(opacity=$0100)": 1},

    "text-shadow": {"$02px 2px 2px #777": 1},
    "text-overflow": {"ellipsis-word": 1, "clip": 1, "ellipsis": 1},
    "-moz-border-radius": 1,
    "-moz-border-radius-topright": 1,
    "-moz-border-radius-bottomright": 1,
    "-moz-border-radius-topleft": 1,
    "-moz-border-radius-bottomleft": 1,
    "-webkit-border-radius": 1,
    "-webkit-border-top-right-radius": 1,
    "-webkit-border-top-left-radius": 1,
    "-webkit-border-bottom-right-radius": 1,
    "-webkit-border-bottom-left-radius": 1,
    "-moz-box-shadow": 1,
    "-webkit-box-shadow": 1,
    "transform": {"rotate($00deg)": 1, "skew($00deg)": 1},
    "-moz-transform": {"rotate($00deg)": 1, "skew($00deg)": 1},
    "-webkit-transform": {"rotate($00deg)": 1, "skew($00deg)": 1 }
};

var CssCompletions = function() {

};

(function() {

    this.completionsDefined = false;

    this.defineCompletions = function() {
        if (document) {
            var style = document.createElement('c').style;

            for (var i in style) {
                if (typeof style[i] !== 'string')
                    continue;

                var name = i.replace(/[A-Z]/g, function(x) {
                    return '-' + x.toLowerCase();
                });

                if (!propertyMap.hasOwnProperty(name))
                    propertyMap[name] = 1;
            }
        }

        this.completionsDefined = true;
    };

    this.getCompletions = function(state, session, pos, prefix) {
        if (!this.completionsDefined) {
            this.defineCompletions();
        }

        if (state==='ruleset' || session.$mode.$id == "ace/mode/scss") {
            var line = session.getLine(pos.row).substr(0, pos.column);
            if (/:[^;]+$/.test(line)) {
                /([\w\-]+):[^:]*$/.test(line);

                return this.getPropertyValueCompletions(state, session, pos, prefix);
            } else {
                return this.getPropertyCompletions(state, session, pos, prefix);
            }
        }

        return [];
    };

    this.getPropertyCompletions = function(state, session, pos, prefix) {
        var properties = Object.keys(propertyMap);
        return properties.map(function(property){
            return {
                caption: property,
                snippet: property + ': $0;',
                meta: "property",
                score: 1000000
            };
        });
    };

    this.getPropertyValueCompletions = function(state, session, pos, prefix) {
        var line = session.getLine(pos.row).substr(0, pos.column);
        var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];

        if (!property)
            return [];
        var values = [];
        if (property in propertyMap && typeof propertyMap[property] === "object") {
            values = Object.keys(propertyMap[property]);
        }
        return values.map(function(value){
            return {
                caption: value,
                snippet: value,
                meta: "property value",
                score: 1000000
            };
        });
    };

}).call(CssCompletions.prototype);

exports.CssCompletions = CssCompletions;
});

ace.define("ace/mode/behaviour/css",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/mode/behaviour/cstyle","ace/token_iterator"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;

var CssBehaviour = function () {

    this.inherit(CstyleBehaviour);

    this.add("colon", "insertion", function (state, action, editor, session, text) {
        if (text === ':' && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === ':') {
                    return {
                       text: '',
                       selection: [1, 1]
                    };
                }
                if (/^(\s+[^;]|\s*$)/.test(line.substring(cursor.column))) {
                    return {
                       text: ':;',
                       selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("colon", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === ';') {
                    range.end.column ++;
                    return range;
                }
            }
        }
    });

    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
        if (text === ';' && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ';') {
                return {
                   text: '',
                   selection: [1, 1]
                };
            }
        }
    });

    this.add("!important", "insertion", function (state, action, editor, session, text) {
        if (text === '!' && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);

            if (/^\s*(;|}|$)/.test(line.substring(cursor.column))) {
                return {
                    text: '!important',
                    selection: [10, 10]
                };
            }
        }
    });

};
oop.inherits(CssBehaviour, CstyleBehaviour);

exports.CssBehaviour = CssBehaviour;
});

ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {
    
    this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
    
        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }
    
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
    
        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart
    
        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});

ace.define("ace/mode/css",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/css_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/css_completions","ace/mode/behaviour/css","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CssCompletions = require("./css_completions").CssCompletions;
var CssBehaviour = require("./behaviour/css").CssBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = CssHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CssBehaviour();
    this.$completer = new CssCompletions();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.foldingRules = "cStyle";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        var match = line.match(/^.*\{\s*$/);
        if (match) {
            indent += tab;
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.getCompletions = function(state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(e) {
            session.setAnnotations(e.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/css";
    this.snippetFileId = "ace/snippets/css";
}).call(Mode.prototype);

exports.Mode = Mode;

});                (function() {
                    ace.require(["ace/mode/css"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='mode_javascript'  type='text/javascript'  charset='utf-8'>ace.define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var DocCommentHighlightRules = function() {
    this.$rules = {
        "start" : [ {
            token : "comment.doc.tag",
            regex : "@[\\w\\d_]+" // TODO: fix email addresses
        }, 
        DocCommentHighlightRules.getTagRule(),
        {
            defaultToken : "comment.doc",
            caseInsensitive: true
        }]
    };
};

oop.inherits(DocCommentHighlightRules, TextHighlightRules);

DocCommentHighlightRules.getTagRule = function(start) {
    return {
        token : "comment.doc.tag.storage.type",
        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
};

DocCommentHighlightRules.getStartRule = function(start) {
    return {
        token : "comment.doc", // doc comment
        regex : "\\/\\*(?=\\*)",
        next  : start
    };
};

DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token : "comment.doc", // closing comment
        regex : "\\*\\/",
        next  : start
    };
};


exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

ace.define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";

var JavaScriptHighlightRules = function(options) {
    var keywordMapper = this.createKeywordMapper({
        "variable.language":
            "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
            "Namespace|QName|XML|XMLList|"                                             + // E4X
            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
            "SyntaxError|TypeError|URIError|"                                          +
            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
            "isNaN|parseFloat|parseInt|"                                               +
            "JSON|Math|"                                                               + // Other
            "this|arguments|prototype|window|document"                                 , // Pseudo
        "keyword":
            "const|yield|import|get|set|async|await|" +
            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
            "if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
            "__parent__|__count__|escape|unescape|with|__proto__|" +
            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
        "storage.type":
            "const|let|var|function",
        "constant.language":
            "null|Infinity|NaN|undefined",
        "support.function":
            "alert",
        "constant.language.boolean": "true|false"
    }, "identifier");
    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";

    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
        "u[0-9a-fA-F]{4}|" + // unicode
        "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
        "[0-2][0-7]{0,2}|" + // oct
        "3[0-7][0-7]?|" + // oct
        "[4-7][0-7]?|" + //oct
        ".)";

    this.$rules = {
        "no_regex" : [
            DocCommentHighlightRules.getStartRule("doc-start"),
            comments("no_regex"),
            {
                token : "string",
                regex : "'(?=.)",
                next  : "qstring"
            }, {
                token : "string",
                regex : '"(?=.)',
                next  : "qqstring"
            }, {
                token : "constant.numeric", // hexadecimal, octal and binary
                regex : /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
            }, {
                token : "constant.numeric", // decimal integers and floats
                regex : /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
            }, {
                token : [
                    "storage.type", "punctuation.operator", "support.function",
                    "punctuation.operator", "entity.name.function", "text","keyword.operator"
                ],
                regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
                    "text", "paren.lparen"
                ],
                regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "punctuation.operator",
                    "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "text", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : "keyword",
                regex : "from(?=\\s*('|\"))"
            }, {
                token : "keyword",
                regex : "(?:" + kwBeforeRe + ")\\b",
                next : "start"
            }, {
                token : ["support.constant"],
                regex : /that\b/
            }, {
                token : ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
            }, {
                token : keywordMapper,
                regex : identifierRe
            }, {
                token : "punctuation.operator",
                regex : /[.](?![.])/,
                next  : "property"
            }, {
                token : "storage.type",
                regex : /=>/,
                next  : "start"
            }, {
                token : "keyword.operator",
                regex : /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                next  : "start"
            }, {
                token : "punctuation.operator",
                regex : /[?:,;.]/,
                next  : "start"
            }, {
                token : "paren.lparen",
                regex : /[\[({]/,
                next  : "start"
            }, {
                token : "paren.rparen",
                regex : /[\])}]/
            }, {
                token: "comment",
                regex: /^#!.*$/
            }
        ],
        property: [{
                token : "text",
                regex : "\\s+"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : "punctuation.operator",
                regex : /[.](?![.])/
            }, {
                token : "support.function",
                regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
            }, {
                token : "support.function.dom",
                regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
            }, {
                token :  "support.constant",
                regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
            }, {
                token : "identifier",
                regex : identifierRe
            }, {
                regex: "",
                token: "empty",
                next: "no_regex"
            }
        ],
        "start": [
            DocCommentHighlightRules.getStartRule("doc-start"),
            comments("start"),
            {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
            }, {
                token : "text",
                regex : "\\s+|^$",
                next : "start"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "regex": [
            {
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
            }, {
                token : "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                token : "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token : "constant.language.delimiter",
                regex: /\|/
            }, {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp"
            }
        ],
        "regex_character_class": [
            {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
            }, {
                token: "constant.language.escape",
                regex: "-"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp.charachterclass"
            }
        ],
        "function_arguments": [
            {
                token: "variable.parameter",
                regex: identifierRe
            }, {
                token: "punctuation.operator",
                regex: "[, ]+"
            }, {
                token: "punctuation.operator",
                regex: "$"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "qqstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                consumeLineEnd  : true
            }, {
                token : "string",
                regex : '"|$',
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ],
        "qstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                consumeLineEnd  : true
            }, {
                token : "string",
                regex : "'|$",
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ]
    };


    if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
            regex: "[{}]", onMatch: function(val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                    stack.unshift("start", state);
                }
                else if (val == "}" && stack.length) {
                    stack.shift();
                    this.next = stack.shift();
                    if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                        return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
            },
            nextState: "start"
        }, {
            token : "string.quasi.start",
            regex : /`/,
            push  : [{
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "paren.quasi.start",
                regex : /\${/,
                push  : "start"
            }, {
                token : "string.quasi.end",
                regex : /`/,
                next  : "pop"
            }, {
                defaultToken: "string.quasi"
            }]
        });

        if (!options || options.jsx != false)
            JSX.call(this);
    }

    this.embedRules(DocCommentHighlightRules, "doc-",
        [ DocCommentHighlightRules.getEndRule("no_regex") ]);

    this.normalizeRules();
};

oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

function JSX() {
    var tagRegex = identifierRe.replace("\\d", "\\d\\-");
    var jsxTag = {
        onMatch : function(val, state, stack) {
            var offset = val.charAt(1) == "/" ? 2 : 1;
            if (offset == 1) {
                if (state != this.nextState)
                    stack.unshift(this.next, this.nextState, 0);
                else
                    stack.unshift(this.next);
                stack[2]++;
            } else if (offset == 2) {
                if (state == this.nextState) {
                    stack[1]--;
                    if (!stack[1] || stack[1] < 0) {
                        stack.shift();
                        stack.shift();
                    }
                }
            }
            return [{
                type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                value: val.slice(0, offset)
            }, {
                type: "meta.tag.tag-name.xml",
                value: val.substr(offset)
            }];
        },
        regex : "</?" + tagRegex + "",
        next: "jsxAttributes",
        nextState: "jsx"
    };
    this.$rules.start.unshift(jsxTag);
    var jsxJsRule = {
        regex: "{",
        token: "paren.quasi.start",
        push: "start"
    };
    this.$rules.jsx = [
        jsxJsRule,
        jsxTag,
        {include : "reference"},
        {defaultToken: "string"}
    ];
    this.$rules.jsxAttributes = [{
        token : "meta.tag.punctuation.tag-close.xml",
        regex : "/?>",
        onMatch : function(value, currentState, stack) {
            if (currentState == stack[0])
                stack.shift();
            if (value.length == 2) {
                if (stack[0] == this.nextState)
                    stack[1]--;
                if (!stack[1] || stack[1] < 0) {
                    stack.splice(0, 2);
                }
            }
            this.next = stack[0] || "start";
            return [{type: this.token, value: value}];
        },
        nextState: "jsx"
    },
    jsxJsRule,
    comments("jsxAttributes"),
    {
        token : "entity.other.attribute-name.xml",
        regex : tagRegex
    }, {
        token : "keyword.operator.attribute-equals.xml",
        regex : "="
    }, {
        token : "text.tag-whitespace.xml",
        regex : "\\s+"
    }, {
        token : "string.attribute-value.xml",
        regex : "'",
        stateName : "jsx_attr_q",
        push : [
            {token : "string.attribute-value.xml", regex: "'", next: "pop"},
            {include : "reference"},
            {defaultToken : "string.attribute-value.xml"}
        ]
    }, {
        token : "string.attribute-value.xml",
        regex : '"',
        stateName : "jsx_attr_qq",
        push : [
            {token : "string.attribute-value.xml", regex: '"', next: "pop"},
            {include : "reference"},
            {defaultToken : "string.attribute-value.xml"}
        ]
    },
    jsxTag
    ];
    this.$rules.reference = [{
        token : "constant.language.escape.reference.xml",
        regex : "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
    }];
}

function comments(next) {
    return [
        {
            token : "comment", // multi line comment
            regex : /\/\*/,
            next: [
                DocCommentHighlightRules.getTagRule(),
                {token : "comment", regex : "\\*\\/", next : next || "pop"},
                {defaultToken : "comment", caseInsensitive: true}
            ]
        }, {
            token : "comment",
            regex : "\\/\\/",
            next: [
                DocCommentHighlightRules.getTagRule(),
                {token : "comment", regex : "$|^", next : next || "pop"},
                {defaultToken : "comment", caseInsensitive: true}
            ]
        }
    ];
}
exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
});

ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {
    
    this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
    
        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }
    
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
    
        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart
    
        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});

ace.define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = JavaScriptHighlightRules;
    
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.lineCommentStart = "//";
    this.blockComment = {start: "/*", end: "*/"};
    this.$quotes = {'"': '"', "'": "'", "`": "`"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start" || state == "no_regex") {
            var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
            if (match) {
                indent += tab;
            }
        } else if (state == "doc-start") {
            if (endState == "start" || endState == "no_regex") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());

        worker.on("annotate", function(results) {
            session.setAnnotations(results.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/javascript";
    this.snippetFileId = "ace/snippets/javascript";
}).call(Mode.prototype);

exports.Mode = Mode;
});                (function() {
                    ace.require(["ace/mode/javascript"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='mode_json'  type='text/javascript'  charset='utf-8'>ace.define("ace/mode/json_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"],function(e,t,n){"use strict";var r=e("../lib/oop"),i=e("./text_highlight_rules").TextHighlightRules,s=function(){this.$rules={start:[{token:"variable",regex:'["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'},{token:"string",regex:'"',next:"string"},{token:"constant.numeric",regex:"0[xX][0-9a-fA-F]+\\b"},{token:"constant.numeric",regex:"[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"},{token:"constant.language.boolean",regex:"(?:true|false)\\b"},{token:"text",regex:"['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"},{token:"comment",regex:"\\/\\/.*$"},{token:"comment.start",regex:"\\/\\*",next:"comment"},{token:"paren.lparen",regex:"[[({]"},{token:"paren.rparen",regex:"[\\])}]"},{token:"text",regex:"\\s+"}],string:[{token:"constant.language.escape",regex:/\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/},{token:"string",regex:'"|$',next:"start"},{defaultToken:"string"}],comment:[{token:"comment.end",regex:"\\*\\/",next:"start"},{defaultToken:"comment"}]}};r.inherits(s,i),t.JsonHighlightRules=s}),ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"],function(e,t,n){"use strict";var r=e("../range").Range,i=function(){};(function(){this.checkOutdent=function(e,t){return/^\s+$/.test(e)?/^\s*\}/.test(t):!1},this.autoOutdent=function(e,t){var n=e.getLine(t),i=n.match(/^(\s*\})/);if(!i)return 0;var s=i[1].length,o=e.findMatchingBracket({row:t,column:s});if(!o||o.row==t)return 0;var u=this.$getIndent(e.getLine(o.row));e.replace(new r(t,0,t,s-1),u)},this.$getIndent=function(e){return e.match(/^\s*/)[0]}}).call(i.prototype),t.MatchingBraceOutdent=i}),ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"],function(e,t,n){"use strict";var r=e("../../lib/oop"),i=e("../../range").Range,s=e("./fold_mode").FoldMode,o=t.FoldMode=function(e){e&&(this.foldingStartMarker=new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/,"|"+e.start)),this.foldingStopMarker=new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/,"|"+e.end)))};r.inherits(o,s),function(){this.foldingStartMarker=/([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/,this.foldingStopMarker=/^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/,this.singleLineBlockCommentRe=/^\s*(\/\*).*\*\/\s*$/,this.tripleStarBlockCommentRe=/^\s*(\/\*\*\*).*\*\/\s*$/,this.startRegionRe=/^\s*(\/\*|\/\/)#?region\b/,this._getFoldWidgetBase=this.getFoldWidget,this.getFoldWidget=function(e,t,n){var r=e.getLine(n);if(this.singleLineBlockCommentRe.test(r)&&!this.startRegionRe.test(r)&&!this.tripleStarBlockCommentRe.test(r))return"";var i=this._getFoldWidgetBase(e,t,n);return!i&&this.startRegionRe.test(r)?"start":i},this.getFoldWidgetRange=function(e,t,n,r){var i=e.getLine(n);if(this.startRegionRe.test(i))return this.getCommentRegionBlock(e,i,n);var s=i.match(this.foldingStartMarker);if(s){var o=s.index;if(s[1])return this.openingBracketBlock(e,s[1],n,o);var u=e.getCommentFoldRange(n,o+s[0].length,1);return u&&!u.isMultiLine()&&(r?u=this.getSectionRange(e,n):t!="all"&&(u=null)),u}if(t==="markbegin")return;var s=i.match(this.foldingStopMarker);if(s){var o=s.index+s[0].length;return s[1]?this.closingBracketBlock(e,s[1],n,o):e.getCommentFoldRange(n,o,-1)}},this.getSectionRange=function(e,t){var n=e.getLine(t),r=n.search(/\S/),s=t,o=n.length;t+=1;var u=t,a=e.getLength();while(++t<a){n=e.getLine(t);var f=n.search(/\S/);if(f===-1)continue;if(r>f)break;var l=this.getFoldWidgetRange(e,"all",t);if(l){if(l.start.row<=s)break;if(l.isMultiLine())t=l.end.row;else if(r==f)break}u=t}return new i(s,o,u,e.getLine(u).length)},this.getCommentRegionBlock=function(e,t,n){var r=t.search(/\s*$/),s=e.getLength(),o=n,u=/^\s*(?:\/\*|\/\/|--)#?(end)?region\b/,a=1;while(++n<s){t=e.getLine(n);var f=u.exec(t);if(!f)continue;f[1]?a--:a++;if(!a)break}var l=n;if(l>o)return new i(o,r,l,t.length)}}.call(o.prototype)}),ace.define("ace/mode/json",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/json_highlight_rules","ace/mode/matching_brace_outdent","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle","ace/worker/worker_client"],function(e,t,n){"use strict";var r=e("../lib/oop"),i=e("./text").Mode,s=e("./json_highlight_rules").JsonHighlightRules,o=e("./matching_brace_outdent").MatchingBraceOutdent,u=e("./behaviour/cstyle").CstyleBehaviour,a=e("./folding/cstyle").FoldMode,f=e("../worker/worker_client").WorkerClient,l=function(){this.HighlightRules=s,this.$outdent=new o,this.$behaviour=new u,this.foldingRules=new a};r.inherits(l,i),function(){this.lineCommentStart="//",this.blockComment={start:"/*",end:"*/"},this.getNextLineIndent=function(e,t,n){var r=this.$getIndent(t);if(e=="start"){var i=t.match(/^.*[\{\(\[]\s*$/);i&&(r+=n)}return r},this.checkOutdent=function(e,t,n){return this.$outdent.checkOutdent(t,n)},this.autoOutdent=function(e,t,n){this.$outdent.autoOutdent(t,n)},this.createWorker=function(e){var t=new f(["ace"],"ace/mode/json_worker","JsonWorker");return t.attachToDocument(e.getDocument()),t.on("annotate",function(t){e.setAnnotations(t.data)}),t.on("terminate",function(){e.clearAnnotations()}),t},this.$id="ace/mode/json"}.call(l.prototype),t.Mode=l});                (function() {
                    ace.require(["ace/mode/json"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='mode_juno'  type='text/javascript'  charset='utf-8'>ace.define("ace/mode/juno_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;



var JunoHighlightRules = function() {
  console.log("JunoHighlightrules: called..");
  var builtinFunctions = ('MAX_SAFE_INTEGER LispSyntaxError sub_type __VERBOSITY__ int float values '+
			  'pairs keys take prepend first last length conj reverse map bind to_object '+
			  'to_array slice rest second third chop chomp not push pop list flatten '+
			  'jslambda join lowercase uppercase log split split_by is_object? is_array? '+
			  'is_number? is_function? is_set? is_element? is_string? is_nil? is_regex? '+
			  'is_date? ends_with? starts_with? delete_prop blank? contains? make_set '+
			  'meta_for_symbol describe undefine eval_exp indirect_new range add '+
			  'merge_objects index_of resolve_path min_value max_value interlace trim ' +
			  'assert unquotify or_args special_operators defclog NOT_FOUND ' +
			  'check_external_env_default *namespace* pending_ns_loads pend_load load_pends '+
			  'symbols set_global get_global symbol_definition compile env_log '+
			  'evaluate_local evaluate eval_struct built_ins set_compiler clone *env_config* '+
			  'create_namespace set_namespace delete_namespace namespaces current_namespace '+
			  'eval reader add_escape_encoding get_outside_global as_lisp lisp_writer clone_to_new '+
			  'save_env null defmacro read_lisp desym desym_ref deref when if_compile_time_defined '+
			  'defexternal defun defun_sync macroexpand macroexpand_nq check_type get_object_path '+
			  'do_deferred_splice define defbinding define_env type destructure_list '+
			  'destructuring_bind split_by_recurse reduce bind_function is_reference? scan_str '+
			  'remove_prop object_methods expand_dot_accessor getf_ctx setf_ctx set_path minmax '+
			  'gen_multiples path_multiply splice_in_return_a splice_in_return_b aif ifa '+
			  'map_range range_inc HSV_to_RGB color_for_number flatten_ctx identify_symbols unless '+
			  'use_quoted_initializer random_int resolve_multi_path symbol_tree except_nil each '+
			  'replace cl_encode_string path_to_js_syntax first_is_upper_case? safe_access_2 '+
			  'safe_access compile_to_js evaluate_compiled_source form_structure '+
			  'validate_form_structure *compiler_syntax_rules* compiler_source_chain '+
			  'compiler_syntax_validation describe_all is_value? sort and* or* either is_symbol? '+
			  'get_function_args findpaths warn success in_background show export_symbols '+
			  'register_feature uniq time_in_millis defns use_ns bind_and_call save_locally '+
			  'fetch_text import system_date_format system_date_formatter tzoffset date_components '+
			  'formatted_date *LANGUAGE* dtext nth use_symbols use_unique_symbols compiler '+
			  'read_text_file readline_mod streams repl set_repl repl_config $ $$ $$$ '+
			  'prop set_prop Environment push pop list ');

    var keywords = ('throw try defvar typeof instanceof == < > <= >= eq return yield jslambda cond apply ' +
		    'defglobal do fn if let new function progn javascript catch evaluate eval call -> import '+
		    'dynamic_import quote for_each for_with declare');

    var buildinConstants = ("true false nil");

    var keywordMapperInternal = this.createKeywordMapper({
        "keyword": keywords,
        "constant.language": buildinConstants,
        "support.function": builtinFunctions
    }, "identifier", false, " ");

  
  var keywordMapper = function(e) {
    //let rval=keywordMapperInternal(e);
    var $keywordMapper = globalThis.env.get_global("keyword_mapper",null);
    if ($keywordMapper) {
      return $keywordMapper(e);
    } else return "identifier"; // just default to an identifier if the keywordMapper isn't available
  }
    this.$rules = {
        "start" : [
            {
                token : "comment",
                regex : ";.*$"
            }, {
                token : keywordMapper,
                regex : "[*a-zA-Z_$][a-zA-Z0-9_$\\-*?]*"
            }, {
                token : "keyword", //parens
                regex : "[\\(|\\)]"
            }, {
                token : "keyword", //lists
                regex : "[\\'\\(]"
            }, {
                token : "keyword", //vectors
                regex : "[\\[|\\]]"
            }, {
                token : "keyword", //sets and maps
                regex : "[\\{|\\}|\\#\\{|\\#\\}]"
            }, {
                    token : "keyword", // ampersands
                    regex : '[\\&]'
            },  {
                token : "constant.numeric", // hex
                regex : "0[xX][0-9a-fA-F]+\\b"
            }, {
                token : "constant.numeric", // float
                regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
            }, /*{
                token : "constant.language",
                regex : '[!|\\$|%|&|\\*|\\-\\-|\\-|\\+\\+|\\+||=|!=|<=|>=|<>|<|>|!|&&]'
            },*/  {
                token : "string", // single line
                regex : '"',
                next: "string"
            }, {
                token : "constant", // symbol
                regex : /:[^()\[\]{}'"\^%`,;\s]+/
            }, {
                token : "string.regexp", //Regular Expressions
                regex : '/#"(?:\\.|(?:\\")|[^""\n])*"/g'
            }

        ],
        "string" : [
            {
                token : "constant.language.escape",
                regex : "\\\\.|\\\\$"
            }, {
                token : "string",
                regex : '[^"\\\\]+'
            }, {
                token : "string",
                regex : '"',
                next : "start"
            }
        ]
    };
};

oop.inherits(JunoHighlightRules, TextHighlightRules);

exports.JunoHighlightRules = JunoHighlightRules;
});

ace.define("ace/mode/matching_parens_outdent",["require","exports","module","ace/range"], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;

var MatchingParensOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\)/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\))/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        console.log("junomode: autoOutdent: indent: ", indent);
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
      var match = line.match(/^(\s+)/);
      console.log("junomode: getIndent: match: ",match,"line: ",line);
        if (match) {
            return match[1];
        }

        return "";
    };

}).call(MatchingParensOutdent.prototype);

exports.MatchingParensOutdent = MatchingParensOutdent;
});

ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {
    
    this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
    
        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }
    
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
    
        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart
    
        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});


ace.define("ace/mode/juno",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/juno_highlight_rules","ace/mode/matching_parens_outdent","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var JunoHighlightRules = require("./juno_highlight_rules").JunoHighlightRules;
var MatchingParensOutdent = require("./matching_parens_outdent").MatchingParensOutdent;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = JunoHighlightRules;
    this.$outdent = new MatchingParensOutdent();
    this.$behaviour = this.$defaultBehaviour;
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.lineCommentStart = ";";
    this.minorIndentFunctions = ["defun", "defun-sync", "defmacro", "define", "when", "let", "destructuring_bind", "while","for_each","fn","lambda","progn","do","reduce","reduce_sync"];
    this.env = globalThis.env;  /* handle to the Juno environment */
    
    this.$toIndent = function(str) {        
        let rval=str.split('').map(function(ch) {
            if (/\s/.exec(ch)) {
                return ch;
            } else {
                return ' ';
            }
        }).join('');      
      return rval;
    };

    // Indentation is handled externally in the Lisp 
    this.$calculateIndent = function(line, tab) {
      //var baseIndent = this.$getIndent(line);
      //var delta = 0;
      //var isParen, ch;
      //var currentControl = globalThis.env.get_global("$current_control");
      //var formatHandler = currentControl["options"]["format_handler"];
      return "";
      
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$calculateIndent(line, tab);
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.$id = "ace/mode/juno";
    // this.snippetFileId = "ace/snippets/juno";
}).call(Mode.prototype);





exports.Mode = Mode;
});                (function() {
                    ace.require(["ace/mode/juno"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            
</script> <script id='mode_markdown'  type='text/javascript'  charset='utf-8'>ace.define("ace/mode/css_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text_highlight_rules"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var supportType = exports.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|max-zoom|min-height|min-width|min-zoom|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|user-select|user-zoom|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
var supportFunction = exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
var supportConstant = exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|flex-end|flex-start|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero|zoom";
var supportConstantColor = exports.supportConstantColor = "aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen";
var supportConstantFonts = exports.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";
var numRe = exports.numRe = "\\-?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+))";
var pseudoElements = exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
var pseudoClasses = exports.pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";
var CssHighlightRules = function () {
    var keywordMapper = this.createKeywordMapper({
        "support.function": supportFunction,
        "support.constant": supportConstant,
        "support.type": supportType,
        "support.constant.color": supportConstantColor,
        "support.constant.fonts": supportConstantFonts
    }, "text", true);
    this.$rules = {
        "start": [{
                include: ["strings", "url", "comments"]
            }, {
                token: "paren.lparen",
                regex: "\\{",
                next: "ruleset"
            }, {
                token: "paren.rparen",
                regex: "\\}"
            }, {
                token: "string",
                regex: "@(?!viewport)",
                next: "media"
            }, {
                token: "keyword",
                regex: "#[a-z0-9-_]+"
            }, {
                token: "keyword",
                regex: "%"
            }, {
                token: "variable",
                regex: "\\.[a-z0-9-_]+"
            }, {
                token: "string",
                regex: ":[a-z0-9-_]+"
            }, {
                token: "constant.numeric",
                regex: numRe
            }, {
                token: "constant",
                regex: "[a-z0-9-_]+"
            }, {
                caseInsensitive: true
            }],
        "media": [{
                include: ["strings", "url", "comments"]
            }, {
                token: "paren.lparen",
                regex: "\\{",
                next: "start"
            }, {
                token: "paren.rparen",
                regex: "\\}",
                next: "start"
            }, {
                token: "string",
                regex: ";",
                next: "start"
            }, {
                token: "keyword",
                regex: "(?:media|supports|document|charset|import|namespace|media|supports|document"
                    + "|page|font|keyframes|viewport|counter-style|font-feature-values"
                    + "|swash|ornaments|annotation|stylistic|styleset|character-variant)"
            }],
        "comments": [{
                token: "comment",
                regex: "\\/\\*",
                push: [{
                        token: "comment",
                        regex: "\\*\\/",
                        next: "pop"
                    }, {
                        defaultToken: "comment"
                    }]
            }],
        "ruleset": [{
                regex: "-(webkit|ms|moz|o)-",
                token: "text"
            }, {
                token: "punctuation.operator",
                regex: "[:;]"
            }, {
                token: "paren.rparen",
                regex: "\\}",
                next: "start"
            }, {
                include: ["strings", "url", "comments"]
            }, {
                token: ["constant.numeric", "keyword"],
                regex: "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vmax|vmin|vm|vw|%)"
            }, {
                token: "constant.numeric",
                regex: numRe
            }, {
                token: "constant.numeric",
                regex: "#[a-f0-9]{6}"
            }, {
                token: "constant.numeric",
                regex: "#[a-f0-9]{3}"
            }, {
                token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
                regex: pseudoElements
            }, {
                token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
                regex: pseudoClasses
            }, {
                include: "url"
            }, {
                token: keywordMapper,
                regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
            }, {
                caseInsensitive: true
            }],
        url: [{
                token: "support.function",
                regex: "(?:url(:?-prefix)?|domain|regexp)\\(",
                push: [{
                        token: "support.function",
                        regex: "\\)",
                        next: "pop"
                    }, {
                        defaultToken: "string"
                    }]
            }],
        strings: [{
                token: "string.start",
                regex: "'",
                push: [{
                        token: "string.end",
                        regex: "'|$",
                        next: "pop"
                    }, {
                        include: "escapes"
                    }, {
                        token: "constant.language.escape",
                        regex: /\\$/,
                        consumeLineEnd: true
                    }, {
                        defaultToken: "string"
                    }]
            }, {
                token: "string.start",
                regex: '"',
                push: [{
                        token: "string.end",
                        regex: '"|$',
                        next: "pop"
                    }, {
                        include: "escapes"
                    }, {
                        token: "constant.language.escape",
                        regex: /\\$/,
                        consumeLineEnd: true
                    }, {
                        defaultToken: "string"
                    }]
            }],
        escapes: [{
                token: "constant.language.escape",
                regex: /\\([a-fA-F\d]{1,6}|[^a-fA-F\d])/
            }]
    };
    this.normalizeRules();
};
oop.inherits(CssHighlightRules, TextHighlightRules);
exports.CssHighlightRules = CssHighlightRules;

});

ace.define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var DocCommentHighlightRules = function () {
    this.$rules = {
        "start": [{
                token: "comment.doc.tag",
                regex: "@[\\w\\d_]+" // TODO: fix email addresses
            },
            DocCommentHighlightRules.getTagRule(),
            {
                defaultToken: "comment.doc",
                caseInsensitive: true
            }]
    };
};
oop.inherits(DocCommentHighlightRules, TextHighlightRules);
DocCommentHighlightRules.getTagRule = function (start) {
    return {
        token: "comment.doc.tag.storage.type",
        regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
};
DocCommentHighlightRules.getStartRule = function (start) {
    return {
        token: "comment.doc",
        regex: "\\/\\*(?=\\*)",
        next: start
    };
};
DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token: "comment.doc",
        regex: "\\*\\/",
        next: start
    };
};
exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

ace.define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var DocCommentHighlightRules = require("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*";
var JavaScriptHighlightRules = function (options) {
    var keywordMapper = this.createKeywordMapper({
        "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|Symbol|" + // Constructors
            "Namespace|QName|XML|XMLList|" + // E4X
            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" +
            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" +
            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + // Errors
            "SyntaxError|TypeError|URIError|" +
            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
            "isNaN|parseFloat|parseInt|" +
            "JSON|Math|" + // Other
            "this|arguments|prototype|window|document",
        "keyword": "const|yield|import|get|set|async|await|" +
            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
            "if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
            "__parent__|__count__|escape|unescape|with|__proto__|" +
            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static|constructor",
        "storage.type": "const|let|var|function",
        "constant.language": "null|Infinity|NaN|undefined",
        "support.function": "alert",
        "constant.language.boolean": "true|false"
    }, "identifier");
    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
        "u[0-9a-fA-F]{4}|" + // unicode
        "u{[0-9a-fA-F]{1,6}}|" + // es6 unicode
        "[0-2][0-7]{0,2}|" + // oct
        "3[0-7][0-7]?|" + // oct
        "[4-7][0-7]?|" + //oct
        ".)";
    this.$rules = {
        "no_regex": [
            DocCommentHighlightRules.getStartRule("doc-start"),
            comments("no_regex"),
            {
                token: "string",
                regex: "'(?=.)",
                next: "qstring"
            }, {
                token: "string",
                regex: '"(?=.)',
                next: "qqstring"
            }, {
                token: "constant.numeric",
                regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
            }, {
                token: "constant.numeric",
                regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
            }, {
                token: [
                    "storage.type", "punctuation.operator", "support.function",
                    "punctuation.operator", "entity.name.function", "text", "keyword.operator"
                ],
                regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                next: "function_arguments"
            }, {
                token: [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function\\*?)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token: [
                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
                    "text", "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function\\*?)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token: [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function\\*?)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token: [
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex: "(function\\*?)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token: [
                    "entity.name.function", "text", "punctuation.operator",
                    "text", "storage.type", "text", "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function\\*?)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token: [
                    "text", "text", "storage.type", "text", "paren.lparen"
                ],
                regex: "(:)(\\s*)(function\\*?)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token: "keyword",
                regex: "from(?=\\s*('|\"))"
            }, {
                token: "keyword",
                regex: "(?:" + kwBeforeRe + ")\\b",
                next: "start"
            }, {
                token: "support.constant",
                regex: /that\b/
            }, {
                token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
            }, {
                token: keywordMapper,
                regex: identifierRe
            }, {
                token: "punctuation.operator",
                regex: /[.](?![.])/,
                next: "property"
            }, {
                token: "storage.type",
                regex: /=>/,
                next: "start"
            }, {
                token: "keyword.operator",
                regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
                next: "start"
            }, {
                token: "punctuation.operator",
                regex: /[?:,;.]/,
                next: "start"
            }, {
                token: "paren.lparen",
                regex: /[\[({]/,
                next: "start"
            }, {
                token: "paren.rparen",
                regex: /[\])}]/
            }, {
                token: "comment",
                regex: /^#!.*$/
            }
        ],
        property: [{
                token: "text",
                regex: "\\s+"
            }, {
                token: [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function\\*?)(?:(\\s+)(\\w+))?(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token: "punctuation.operator",
                regex: /[.](?![.])/
            }, {
                token: "support.function",
                regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|lter|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward|rEach)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
            }, {
                token: "support.function.dom",
                regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
            }, {
                token: "support.constant",
                regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
            }, {
                token: "identifier",
                regex: identifierRe
            }, {
                regex: "",
                token: "empty",
                next: "no_regex"
            }
        ],
        "start": [
            DocCommentHighlightRules.getStartRule("doc-start"),
            comments("start"),
            {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
            }, {
                token: "text",
                regex: "\\s+|^$",
                next: "start"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "regex": [
            {
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
            }, {
                token: "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                token: "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token: "constant.language.delimiter",
                regex: /\|/
            }, {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp"
            }
        ],
        "regex_character_class": [
            {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
            }, {
                token: "constant.language.escape",
                regex: "-"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp.charachterclass"
            }
        ],
        "default_parameter": [
            {
                token: "string",
                regex: "'(?=.)",
                push: [
                    {
                        token: "string",
                        regex: "'|$",
                        next: "pop"
                    }, {
                        include: "qstring"
                    }
                ]
            }, {
                token: "string",
                regex: '"(?=.)',
                push: [
                    {
                        token: "string",
                        regex: '"|$',
                        next: "pop"
                    }, {
                        include: "qqstring"
                    }
                ]
            }, {
                token: "constant.language",
                regex: "null|Infinity|NaN|undefined"
            }, {
                token: "constant.numeric",
                regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
            }, {
                token: "constant.numeric",
                regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
            }, {
                token: "punctuation.operator",
                regex: ",",
                next: "function_arguments"
            }, {
                token: "text",
                regex: "\\s+"
            }, {
                token: "punctuation.operator",
                regex: "$"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "function_arguments": [
            comments("function_arguments"),
            {
                token: "variable.parameter",
                regex: identifierRe
            }, {
                token: "punctuation.operator",
                regex: ","
            }, {
                token: "text",
                regex: "\\s+"
            }, {
                token: "punctuation.operator",
                regex: "$"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "qqstring": [
            {
                token: "constant.language.escape",
                regex: escapedRe
            }, {
                token: "string",
                regex: "\\\\$",
                consumeLineEnd: true
            }, {
                token: "string",
                regex: '"|$',
                next: "no_regex"
            }, {
                defaultToken: "string"
            }
        ],
        "qstring": [
            {
                token: "constant.language.escape",
                regex: escapedRe
            }, {
                token: "string",
                regex: "\\\\$",
                consumeLineEnd: true
            }, {
                token: "string",
                regex: "'|$",
                next: "no_regex"
            }, {
                defaultToken: "string"
            }
        ]
    };
    if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
            regex: "[{}]", onMatch: function (val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                    stack.unshift("start", state);
                }
                else if (val == "}" && stack.length) {
                    stack.shift();
                    this.next = stack.shift();
                    if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                        return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
            },
            nextState: "start"
        }, {
            token: "string.quasi.start",
            regex: /`/,
            push: [{
                    token: "constant.language.escape",
                    regex: escapedRe
                }, {
                    token: "paren.quasi.start",
                    regex: /\${/,
                    push: "start"
                }, {
                    token: "string.quasi.end",
                    regex: /`/,
                    next: "pop"
                }, {
                    defaultToken: "string.quasi"
                }]
        }, {
            token: ["variable.parameter", "text"],
            regex: "(" + identifierRe + ")(\\s*)(?=\\=>)"
        }, {
            token: "paren.lparen",
            regex: "(\\()(?=.+\\s*=>)",
            next: "function_arguments"
        }, {
            token: "variable.language",
            regex: "(?:(?:(?:Weak)?(?:Set|Map))|Promise)\\b"
        });
        this.$rules["function_arguments"].unshift({
            token: "keyword.operator",
            regex: "=",
            next: "default_parameter"
        }, {
            token: "keyword.operator",
            regex: "\\.{3}"
        });
        this.$rules["property"].unshift({
            token: "support.function",
            regex: "(findIndex|repeat|startsWith|endsWith|includes|isSafeInteger|trunc|cbrt|log2|log10|sign|then|catch|"
                + "finally|resolve|reject|race|any|all|allSettled|keys|entries|isInteger)\\b(?=\\()"
        }, {
            token: "constant.language",
            regex: "(?:MAX_SAFE_INTEGER|MIN_SAFE_INTEGER|EPSILON)\\b"
        });
        if (!options || options.jsx != false)
            JSX.call(this);
    }
    this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);
    this.normalizeRules();
};
oop.inherits(JavaScriptHighlightRules, TextHighlightRules);
function JSX() {
    var tagRegex = identifierRe.replace("\\d", "\\d\\-");
    var jsxTag = {
        onMatch: function (val, state, stack) {
            var offset = val.charAt(1) == "/" ? 2 : 1;
            if (offset == 1) {
                if (state != this.nextState)
                    stack.unshift(this.next, this.nextState, 0);
                else
                    stack.unshift(this.next);
                stack[2]++;
            }
            else if (offset == 2) {
                if (state == this.nextState) {
                    stack[1]--;
                    if (!stack[1] || stack[1] < 0) {
                        stack.shift();
                        stack.shift();
                    }
                }
            }
            return [{
                    type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
                    value: val.slice(0, offset)
                }, {
                    type: "meta.tag.tag-name.xml",
                    value: val.substr(offset)
                }];
        },
        regex: "</?" + tagRegex + "",
        next: "jsxAttributes",
        nextState: "jsx"
    };
    this.$rules.start.unshift(jsxTag);
    var jsxJsRule = {
        regex: "{",
        token: "paren.quasi.start",
        push: "start"
    };
    this.$rules.jsx = [
        jsxJsRule,
        jsxTag,
        { include: "reference" },
        { defaultToken: "string" }
    ];
    this.$rules.jsxAttributes = [{
            token: "meta.tag.punctuation.tag-close.xml",
            regex: "/?>",
            onMatch: function (value, currentState, stack) {
                if (currentState == stack[0])
                    stack.shift();
                if (value.length == 2) {
                    if (stack[0] == this.nextState)
                        stack[1]--;
                    if (!stack[1] || stack[1] < 0) {
                        stack.splice(0, 2);
                    }
                }
                this.next = stack[0] || "start";
                return [{ type: this.token, value: value }];
            },
            nextState: "jsx"
        },
        jsxJsRule,
        comments("jsxAttributes"),
        {
            token: "entity.other.attribute-name.xml",
            regex: tagRegex
        }, {
            token: "keyword.operator.attribute-equals.xml",
            regex: "="
        }, {
            token: "text.tag-whitespace.xml",
            regex: "\\s+"
        }, {
            token: "string.attribute-value.xml",
            regex: "'",
            stateName: "jsx_attr_q",
            push: [
                { token: "string.attribute-value.xml", regex: "'", next: "pop" },
                { include: "reference" },
                { defaultToken: "string.attribute-value.xml" }
            ]
        }, {
            token: "string.attribute-value.xml",
            regex: '"',
            stateName: "jsx_attr_qq",
            push: [
                { token: "string.attribute-value.xml", regex: '"', next: "pop" },
                { include: "reference" },
                { defaultToken: "string.attribute-value.xml" }
            ]
        },
        jsxTag
    ];
    this.$rules.reference = [{
            token: "constant.language.escape.reference.xml",
            regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
        }];
}
function comments(next) {
    return [
        {
            token: "comment",
            regex: /\/\*/,
            next: [
                DocCommentHighlightRules.getTagRule(),
                { token: "comment", regex: "\\*\\/", next: next || "pop" },
                { defaultToken: "comment", caseInsensitive: true }
            ]
        }, {
            token: "comment",
            regex: "\\/\\/",
            next: [
                DocCommentHighlightRules.getTagRule(),
                { token: "comment", regex: "$|^", next: next || "pop" },
                { defaultToken: "comment", caseInsensitive: true }
            ]
        }
    ];
}
exports.JavaScriptHighlightRules = JavaScriptHighlightRules;

});

ace.define("ace/mode/xml_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var XmlHighlightRules = function (normalize) {
    var tagRegex = "[_:a-zA-Z\xc0-\uffff][-_:.a-zA-Z0-9\xc0-\uffff]*";
    this.$rules = {
        start: [
            { token: "string.cdata.xml", regex: "<\\!\\[CDATA\\[", next: "cdata" },
            {
                token: ["punctuation.instruction.xml", "keyword.instruction.xml"],
                regex: "(<\\?)(" + tagRegex + ")", next: "processing_instruction"
            },
            { token: "comment.start.xml", regex: "<\\!--", next: "comment" },
            {
                token: ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                regex: "(<\\!)(DOCTYPE)(?=[\\s])", next: "doctype", caseInsensitive: true
            },
            { include: "tag" },
            { token: "text.end-tag-open.xml", regex: "</" },
            { token: "text.tag-open.xml", regex: "<" },
            { include: "reference" },
            { defaultToken: "text.xml" }
        ],
        processing_instruction: [{
                token: "entity.other.attribute-name.decl-attribute-name.xml",
                regex: tagRegex
            }, {
                token: "keyword.operator.decl-attribute-equals.xml",
                regex: "="
            }, {
                include: "whitespace"
            }, {
                include: "string"
            }, {
                token: "punctuation.xml-decl.xml",
                regex: "\\?>",
                next: "start"
            }],
        doctype: [
            { include: "whitespace" },
            { include: "string" },
            { token: "xml-pe.doctype.xml", regex: ">", next: "start" },
            { token: "xml-pe.xml", regex: "[-_a-zA-Z0-9:]+" },
            { token: "punctuation.int-subset", regex: "\\[", push: "int_subset" }
        ],
        int_subset: [{
                token: "text.xml",
                regex: "\\s+"
            }, {
                token: "punctuation.int-subset.xml",
                regex: "]",
                next: "pop"
            }, {
                token: ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
                regex: "(<\\!)(" + tagRegex + ")",
                push: [{
                        token: "text",
                        regex: "\\s+"
                    },
                    {
                        token: "punctuation.markup-decl.xml",
                        regex: ">",
                        next: "pop"
                    },
                    { include: "string" }]
            }],
        cdata: [
            { token: "string.cdata.xml", regex: "\\]\\]>", next: "start" },
            { token: "text.xml", regex: "\\s+" },
            { token: "text.xml", regex: "(?:[^\\]]|\\](?!\\]>))+" }
        ],
        comment: [
            { token: "comment.end.xml", regex: "-->", next: "start" },
            { defaultToken: "comment.xml" }
        ],
        reference: [{
                token: "constant.language.escape.reference.xml",
                regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
            }],
        attr_reference: [{
                token: "constant.language.escape.reference.attribute-value.xml",
                regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
            }],
        tag: [{
                token: ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
                regex: "(?:(<)|(</))((?:" + tagRegex + ":)?" + tagRegex + ")",
                next: [
                    { include: "attributes" },
                    { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }
                ]
            }],
        tag_whitespace: [
            { token: "text.tag-whitespace.xml", regex: "\\s+" }
        ],
        whitespace: [
            { token: "text.whitespace.xml", regex: "\\s+" }
        ],
        string: [{
                token: "string.xml",
                regex: "'",
                push: [
                    { token: "string.xml", regex: "'", next: "pop" },
                    { defaultToken: "string.xml" }
                ]
            }, {
                token: "string.xml",
                regex: '"',
                push: [
                    { token: "string.xml", regex: '"', next: "pop" },
                    { defaultToken: "string.xml" }
                ]
            }],
        attributes: [{
                token: "entity.other.attribute-name.xml",
                regex: tagRegex
            }, {
                token: "keyword.operator.attribute-equals.xml",
                regex: "="
            }, {
                include: "tag_whitespace"
            }, {
                include: "attribute_value"
            }],
        attribute_value: [{
                token: "string.attribute-value.xml",
                regex: "'",
                push: [
                    { token: "string.attribute-value.xml", regex: "'", next: "pop" },
                    { include: "attr_reference" },
                    { defaultToken: "string.attribute-value.xml" }
                ]
            }, {
                token: "string.attribute-value.xml",
                regex: '"',
                push: [
                    { token: "string.attribute-value.xml", regex: '"', next: "pop" },
                    { include: "attr_reference" },
                    { defaultToken: "string.attribute-value.xml" }
                ]
            }]
    };
    if (this.constructor === XmlHighlightRules)
        this.normalizeRules();
};
(function () {
    this.embedTagRules = function (HighlightRules, prefix, tag) {
        this.$rules.tag.unshift({
            token: ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
            regex: "(<)(" + tag + "(?=\\s|>|$))",
            next: [
                { include: "attributes" },
                { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: prefix + "start" }
            ]
        });
        this.$rules[tag + "-end"] = [
            { include: "attributes" },
            { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start",
                onMatch: function (value, currentState, stack) {
                    stack.splice(0);
                    return this.token;
                } }
        ];
        this.embedRules(HighlightRules, prefix, [{
                token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                regex: "(</)(" + tag + "(?=\\s|>|$))",
                next: tag + "-end"
            }, {
                token: "string.cdata.xml",
                regex: "<\\!\\[CDATA\\["
            }, {
                token: "string.cdata.xml",
                regex: "\\]\\]>"
            }]);
    };
}).call(TextHighlightRules.prototype);
oop.inherits(XmlHighlightRules, TextHighlightRules);
exports.XmlHighlightRules = XmlHighlightRules;

});

ace.define("ace/mode/html_highlight_rules",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/css_highlight_rules","ace/mode/javascript_highlight_rules","ace/mode/xml_highlight_rules"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var XmlHighlightRules = require("./xml_highlight_rules").XmlHighlightRules;
var tagMap = lang.createMap({
    a: 'anchor',
    button: 'form',
    form: 'form',
    img: 'image',
    input: 'form',
    label: 'form',
    option: 'form',
    script: 'script',
    select: 'form',
    textarea: 'form',
    style: 'style',
    table: 'table',
    tbody: 'table',
    td: 'table',
    tfoot: 'table',
    th: 'table',
    tr: 'table'
});
var HtmlHighlightRules = function () {
    XmlHighlightRules.call(this);
    this.addRules({
        attributes: [{
                include: "tag_whitespace"
            }, {
                token: "entity.other.attribute-name.xml",
                regex: "[-_a-zA-Z0-9:.]+"
            }, {
                token: "keyword.operator.attribute-equals.xml",
                regex: "=",
                push: [{
                        include: "tag_whitespace"
                    }, {
                        token: "string.unquoted.attribute-value.html",
                        regex: "[^<>='\"`\\s]+",
                        next: "pop"
                    }, {
                        token: "empty",
                        regex: "",
                        next: "pop"
                    }]
            }, {
                include: "attribute_value"
            }],
        tag: [{
                token: function (start, tag) {
                    var group = tagMap[tag];
                    return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml",
                        "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
                },
                regex: "(</?)([-_a-zA-Z0-9:.]+)",
                next: "tag_stuff"
            }],
        tag_stuff: [
            { include: "attributes" },
            { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }
        ]
    });
    this.embedTagRules(CssHighlightRules, "css-", "style");
    this.embedTagRules(new JavaScriptHighlightRules({ jsx: false }).getRules(), "js-", "script");
    if (this.constructor === HtmlHighlightRules)
        this.normalizeRules();
};
oop.inherits(HtmlHighlightRules, XmlHighlightRules);
exports.HtmlHighlightRules = HtmlHighlightRules;

});

ace.define("ace/mode/markdown_highlight_rules",["require","exports","module","ace/config","ace/lib/oop","ace/lib/lang","ace/mode/text_highlight_rules","ace/mode/html_highlight_rules"], function(require, exports, module){"use strict";
var modes = require("../config").$modes;
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;
var escaped = function (ch) {
    return "(?:[^" + lang.escapeRegExp(ch) + "\\\\]|\\\\.)*";
};
var MarkdownHighlightRules = function () {
    HtmlHighlightRules.call(this);
    var codeBlockStartRule = {
        token: "support.function",
        regex: /^\s*(```+[^`]*|~~~+[^~]*)$/,
        onMatch: function (value, state, stack, line) {
            var m = value.match(/^(\s*)([`~]+)(.*)/);
            var language = /[\w-]+|$/.exec(m[3])[0];
            if (!modes[language])
                language = "";
            stack.unshift("githubblock", [], [m[1], m[2], language], state);
            return this.token;
        },
        next: "githubblock"
    };
    var codeBlockRules = [{
            token: "support.function",
            regex: ".*",
            onMatch: function (value, state, stack, line) {
                var embedState = stack[1];
                var indent = stack[2][0];
                var endMarker = stack[2][1];
                var language = stack[2][2];
                var m = /^(\s*)(`+|~+)\s*$/.exec(value);
                if (m && m[1].length < indent.length + 3
                    && m[2].length >= endMarker.length && m[2][0] == endMarker[0]) {
                    stack.splice(0, 3);
                    this.next = stack.shift();
                    return this.token;
                }
                this.next = "";
                if (language && modes[language]) {
                    var data = modes[language].getTokenizer().getLineTokens(value, embedState.slice(0));
                    stack[1] = data.state;
                    return data.tokens;
                }
                return this.token;
            }
        }];
    this.$rules["start"].unshift({
        token: "empty_line",
        regex: '^$',
        next: "allowBlock"
    }, {
        token: "markup.heading.1",
        regex: "^=+(?=\\s*$)"
    }, {
        token: "markup.heading.2",
        regex: "^\\-+(?=\\s*$)"
    }, {
        token: function (value) {
            return "markup.heading." + value.length;
        },
        regex: /^#{1,6}(?=\s|$)/,
        next: "header"
    }, codeBlockStartRule, {
        token: "string.blockquote",
        regex: "^\\s*>\\s*(?:[*+-]|\\d+\\.)?\\s+",
        next: "blockquote"
    }, {
        token: "constant",
        regex: "^ {0,3}(?:(?:\\* ?){3,}|(?:\\- ?){3,}|(?:\\_ ?){3,})\\s*$",
        next: "allowBlock"
    }, {
        token: "markup.list",
        regex: "^\\s{0,3}(?:[*+-]|\\d+\\.)\\s+",
        next: "listblock-start"
    }, {
        include: "basic"
    });
    this.addRules({
        "basic": [{
                token: "constant.language.escape",
                regex: /\\[\\`*_{}\[\]()#+\-.!]/
            }, {
                token: "support.function",
                regex: "(`+)(.*?[^`])(\\1)"
            }, {
                token: ["text", "constant", "text", "url", "string", "text"],
                regex: "^([ ]{0,3}\\[)([^\\]]+)(\\]:\\s*)([^ ]+)(\\s*(?:[\"][^\"]+[\"])?(\\s*))$"
            }, {
                token: ["text", "string", "text", "constant", "text"],
                regex: "(\\[)(" + escaped("]") + ")(\\]\\s*\\[)(" + escaped("]") + ")(\\])"
            }, {
                token: ["text", "string", "text", "markup.underline", "string", "text"],
                regex: "(\\!?\\[)(" + // [
                    escaped("]") + // link text or alt text
                    ")(\\]\\()" + // ](
                    '((?:[^\\)\\s\\\\]|\\\\.|\\s(?=[^"]))*)' + // href or image
                    '(\\s*"' + escaped('"') + '"\\s*)?' + // "title"
                    "(\\))" // )
            }, {
                token: "string.strong",
                regex: "([*]{2}|[_]{2}(?=\\S))(.*?\\S[*_]*)(\\1)"
            }, {
                token: "string.emphasis",
                regex: "([*]|[_](?=\\S))(.*?\\S[*_]*)(\\1)"
            }, {
                token: ["text", "url", "text"],
                regex: "(<)(" +
                    "(?:https?|ftp|dict):[^'\">\\s]+" +
                    "|" +
                    "(?:mailto:)?[-.\\w]+\\@[-a-z0-9]+(?:\\.[-a-z0-9]+)*\\.[a-z]+" +
                    ")(>)"
            }],
        "allowBlock": [
            { token: "support.function", regex: "^ {4}.+", next: "allowBlock" },
            { token: "empty_line", regex: '^$', next: "allowBlock" },
            { token: "empty", regex: "", next: "start" }
        ],
        "header": [{
                regex: "$",
                next: "start"
            }, {
                include: "basic"
            }, {
                defaultToken: "heading"
            }],
        "listblock-start": [{
                token: "support.variable",
                regex: /(?:\[[ x]\])?/,
                next: "listblock"
            }],
        "listblock": [{
                token: "empty_line",
                regex: "^$",
                next: "start"
            }, {
                token: "markup.list",
                regex: "^\\s{0,3}(?:[*+-]|\\d+\\.)\\s+",
                next: "listblock-start"
            }, {
                include: "basic", noEscape: true
            },
            codeBlockStartRule,
            {
                defaultToken: "list" //do not use markup.list to allow stling leading `*` differntly
            }],
        "blockquote": [{
                token: "empty_line",
                regex: "^\\s*$",
                next: "start"
            }, {
                token: "string.blockquote",
                regex: "^\\s*>\\s*(?:[*+-]|\\d+\\.)?\\s+",
                next: "blockquote"
            }, {
                include: "basic", noEscape: true
            }, {
                defaultToken: "string.blockquote"
            }],
        "githubblock": codeBlockRules
    });
    this.normalizeRules();
};
oop.inherits(MarkdownHighlightRules, TextHighlightRules);
exports.MarkdownHighlightRules = MarkdownHighlightRules;

});

ace.define("ace/mode/folding/markdown",["require","exports","module","ace/lib/oop","ace/mode/folding/fold_mode","ace/range"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var BaseFoldMode = require("./fold_mode").FoldMode;
var Range = require("../../range").Range;
var FoldMode = exports.FoldMode = function () { };
oop.inherits(FoldMode, BaseFoldMode);
(function () {
    this.foldingStartMarker = /^(?:[=-]+\s*$|#{1,6} |`{3})/;
    this.getFoldWidget = function (session, foldStyle, row) {
        var line = session.getLine(row);
        if (!this.foldingStartMarker.test(line))
            return "";
        if (line[0] == "`") {
            if (session.bgTokenizer.getState(row) == "start")
                return "end";
            return "start";
        }
        return "start";
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        var line = session.getLine(row);
        var startColumn = line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        if (!line.match(this.foldingStartMarker))
            return;
        if (line[0] == "`") {
            if (session.bgTokenizer.getState(row) !== "start") {
                while (++row < maxRow) {
                    line = session.getLine(row);
                    if (line[0] == "`" & line.substring(0, 3) == "```")
                        break;
                }
                return new Range(startRow, startColumn, row, 0);
            }
            else {
                while (row-- > 0) {
                    line = session.getLine(row);
                    if (line[0] == "`" & line.substring(0, 3) == "```")
                        break;
                }
                return new Range(row, line.length, startRow, 0);
            }
        }
        var token;
        function isHeading(row) {
            token = session.getTokens(row)[0];
            return token && token.type.lastIndexOf(heading, 0) === 0;
        }
        var heading = "markup.heading";
        function getLevel() {
            var ch = token.value[0];
            if (ch == "=")
                return 6;
            if (ch == "-")
                return 5;
            return 7 - token.value.search(/[^#]|$/);
        }
        if (isHeading(row)) {
            var startHeadingLevel = getLevel();
            while (++row < maxRow) {
                if (!isHeading(row))
                    continue;
                var level = getLevel();
                if (level >= startHeadingLevel)
                    break;
            }
            endRow = row - (!token || ["=", "-"].indexOf(token.value[0]) == -1 ? 1 : 2);
            if (endRow > startRow) {
                while (endRow > startRow && /^\s*$/.test(session.getLine(endRow)))
                    endRow--;
            }
            if (endRow > startRow) {
                var endColumn = session.getLine(endRow).length;
                return new Range(startRow, startColumn, endRow, endColumn);
            }
        }
    };
}).call(FoldMode.prototype);

});

ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(require, exports, module){"use strict";
var Range = require("../range").Range;
var MatchingBraceOutdent = function () { };
(function () {
    this.checkOutdent = function (line, input) {
        if (!/^\s+$/.test(line))
            return false;
        return /^\s*\}/.test(input);
    };
    this.autoOutdent = function (doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
            return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({ row: row, column: column });
        if (!openBracePos || openBracePos.row == row)
            return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
    };
    this.$getIndent = function (line) {
        return line.match(/^\s*/)[0];
    };
}).call(MatchingBraceOutdent.prototype);
exports.MatchingBraceOutdent = MatchingBraceOutdent;

});

ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;
var FoldMode = exports.FoldMode = function (commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
    }
};
oop.inherits(FoldMode, BaseFoldMode);
(function () {
    this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function (session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart
        return fw;
    };
    this.getFoldWidgetRange = function (session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;
            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                }
                else if (foldStyle != "all")
                    range = null;
            }
            return range;
        }
        if (foldStyle === "markbegin")
            return;
        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;
            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);
            return session.getCommentFoldRange(row, i, -1);
        }
    };
    this.getSectionRange = function (session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                }
                else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                }
                else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function (session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m)
                continue;
            if (m[1])
                depth--;
            else
                depth++;
            if (!depth)
                break;
        }
        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };
}).call(FoldMode.prototype);

});

ace.define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var JavaScriptHighlightRules = require("./javascript_highlight_rules").JavaScriptHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;
var Mode = function () {
    this.HighlightRules = JavaScriptHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);
(function () {
    this.lineCommentStart = "//";
    this.blockComment = { start: "/*", end: "*/" };
    this.$quotes = { '"': '"', "'": "'", "`": "`" };
    this.getNextLineIndent = function (state, line, tab) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;
        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
            return indent;
        }
        if (state == "start" || state == "no_regex") {
            var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
            if (match) {
                indent += tab;
            }
        }
        else if (state == "doc-start") {
            if (endState == "start" || endState == "no_regex") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }
        return indent;
    };
    this.checkOutdent = function (state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };
    this.autoOutdent = function (state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };
    this.createWorker = function (session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());
        worker.on("annotate", function (results) {
            session.setAnnotations(results.data);
        });
        worker.on("terminate", function () {
            session.clearAnnotations();
        });
        return worker;
    };
    this.$id = "ace/mode/javascript";
    this.snippetFileId = "ace/snippets/javascript";
}).call(Mode.prototype);
exports.Mode = Mode;

});

ace.define("ace/mode/css_completions",["require","exports","module"], function(require, exports, module){"use strict";
var propertyMap = {
    "background": { "#$0": 1 },
    "background-color": { "#$0": 1, "transparent": 1, "fixed": 1 },
    "background-image": { "url('/$0')": 1 },
    "background-repeat": { "repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1 },
    "background-position": { "bottom": 2, "center": 2, "left": 2, "right": 2, "top": 2, "inherit": 2 },
    "background-attachment": { "scroll": 1, "fixed": 1 },
    "background-size": { "cover": 1, "contain": 1 },
    "background-clip": { "border-box": 1, "padding-box": 1, "content-box": 1 },
    "background-origin": { "border-box": 1, "padding-box": 1, "content-box": 1 },
    "border": { "solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1 },
    "border-color": { "#$0": 1 },
    "border-style": { "solid": 2, "dashed": 2, "dotted": 2, "double": 2, "groove": 2, "hidden": 2, "inherit": 2, "inset": 2, "none": 2, "outset": 2, "ridged": 2 },
    "border-collapse": { "collapse": 1, "separate": 1 },
    "bottom": { "px": 1, "em": 1, "%": 1 },
    "clear": { "left": 1, "right": 1, "both": 1, "none": 1 },
    "color": { "#$0": 1, "rgb(#$00,0,0)": 1 },
    "cursor": { "default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1 },
    "display": { "none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1 },
    "empty-cells": { "show": 1, "hide": 1 },
    "float": { "left": 1, "right": 1, "none": 1 },
    "font-family": { "Arial": 2, "Comic Sans MS": 2, "Consolas": 2, "Courier New": 2, "Courier": 2, "Georgia": 2, "Monospace": 2, "Sans-Serif": 2, "Segoe UI": 2, "Tahoma": 2, "Times New Roman": 2, "Trebuchet MS": 2, "Verdana": 1 },
    "font-size": { "px": 1, "em": 1, "%": 1 },
    "font-weight": { "bold": 1, "normal": 1 },
    "font-style": { "italic": 1, "normal": 1 },
    "font-variant": { "normal": 1, "small-caps": 1 },
    "height": { "px": 1, "em": 1, "%": 1 },
    "left": { "px": 1, "em": 1, "%": 1 },
    "letter-spacing": { "normal": 1 },
    "line-height": { "normal": 1 },
    "list-style-type": { "none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1 },
    "margin": { "px": 1, "em": 1, "%": 1 },
    "margin-right": { "px": 1, "em": 1, "%": 1 },
    "margin-left": { "px": 1, "em": 1, "%": 1 },
    "margin-top": { "px": 1, "em": 1, "%": 1 },
    "margin-bottom": { "px": 1, "em": 1, "%": 1 },
    "max-height": { "px": 1, "em": 1, "%": 1 },
    "max-width": { "px": 1, "em": 1, "%": 1 },
    "min-height": { "px": 1, "em": 1, "%": 1 },
    "min-width": { "px": 1, "em": 1, "%": 1 },
    "overflow": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
    "overflow-x": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
    "overflow-y": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
    "padding": { "px": 1, "em": 1, "%": 1 },
    "padding-top": { "px": 1, "em": 1, "%": 1 },
    "padding-right": { "px": 1, "em": 1, "%": 1 },
    "padding-bottom": { "px": 1, "em": 1, "%": 1 },
    "padding-left": { "px": 1, "em": 1, "%": 1 },
    "page-break-after": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
    "page-break-before": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
    "position": { "absolute": 1, "relative": 1, "fixed": 1, "static": 1 },
    "right": { "px": 1, "em": 1, "%": 1 },
    "table-layout": { "fixed": 1, "auto": 1 },
    "text-decoration": { "none": 1, "underline": 1, "line-through": 1, "blink": 1 },
    "text-align": { "left": 1, "right": 1, "center": 1, "justify": 1 },
    "text-transform": { "capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1 },
    "top": { "px": 1, "em": 1, "%": 1 },
    "vertical-align": { "top": 1, "bottom": 1 },
    "visibility": { "hidden": 1, "visible": 1 },
    "white-space": { "nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1 },
    "width": { "px": 1, "em": 1, "%": 1 },
    "word-spacing": { "normal": 1 },
    "filter": { "alpha(opacity=$0100)": 1 },
    "text-shadow": { "$02px 2px 2px #777": 1 },
    "text-overflow": { "ellipsis-word": 1, "clip": 1, "ellipsis": 1 },
    "-moz-border-radius": 1,
    "-moz-border-radius-topright": 1,
    "-moz-border-radius-bottomright": 1,
    "-moz-border-radius-topleft": 1,
    "-moz-border-radius-bottomleft": 1,
    "-webkit-border-radius": 1,
    "-webkit-border-top-right-radius": 1,
    "-webkit-border-top-left-radius": 1,
    "-webkit-border-bottom-right-radius": 1,
    "-webkit-border-bottom-left-radius": 1,
    "-moz-box-shadow": 1,
    "-webkit-box-shadow": 1,
    "transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
    "-moz-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
    "-webkit-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 }
};
var CssCompletions = function () {
};
(function () {
    this.completionsDefined = false;
    this.defineCompletions = function () {
        if (document) {
            var style = document.createElement('c').style;
            for (var i in style) {
                if (typeof style[i] !== 'string')
                    continue;
                var name = i.replace(/[A-Z]/g, function (x) {
                    return '-' + x.toLowerCase();
                });
                if (!propertyMap.hasOwnProperty(name))
                    propertyMap[name] = 1;
            }
        }
        this.completionsDefined = true;
    };
    this.getCompletions = function (state, session, pos, prefix) {
        if (!this.completionsDefined) {
            this.defineCompletions();
        }
        if (state === 'ruleset' || session.$mode.$id == "ace/mode/scss") {
            var line = session.getLine(pos.row).substr(0, pos.column);
            var inParens = /\([^)]*$/.test(line);
            if (inParens) {
                line = line.substr(line.lastIndexOf('(') + 1);
            }
            if (/:[^;]+$/.test(line)) {
                /([\w\-]+):[^:]*$/.test(line);
                return this.getPropertyValueCompletions(state, session, pos, prefix);
            }
            else {
                return this.getPropertyCompletions(state, session, pos, prefix, inParens);
            }
        }
        return [];
    };
    this.getPropertyCompletions = function (state, session, pos, prefix, skipSemicolon) {
        skipSemicolon = skipSemicolon || false;
        var properties = Object.keys(propertyMap);
        return properties.map(function (property) {
            return {
                caption: property,
                snippet: property + ': $0' + (skipSemicolon ? '' : ';'),
                meta: "property",
                score: 1000000
            };
        });
    };
    this.getPropertyValueCompletions = function (state, session, pos, prefix) {
        var line = session.getLine(pos.row).substr(0, pos.column);
        var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];
        if (!property)
            return [];
        var values = [];
        if (property in propertyMap && typeof propertyMap[property] === "object") {
            values = Object.keys(propertyMap[property]);
        }
        return values.map(function (value) {
            return {
                caption: value,
                snippet: value,
                meta: "property value",
                score: 1000000
            };
        });
    };
}).call(CssCompletions.prototype);
exports.CssCompletions = CssCompletions;

});

ace.define("ace/mode/behaviour/css",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/mode/behaviour/cstyle","ace/token_iterator"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var CstyleBehaviour = require("./cstyle").CstyleBehaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var CssBehaviour = function () {
    this.inherit(CstyleBehaviour);
    this.add("colon", "insertion", function (state, action, editor, session, text) {
        if (text === ':' && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === ':') {
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
                if (/^(\s+[^;]|\s*$)/.test(line.substring(cursor.column))) {
                    return {
                        text: ':;',
                        selection: [1, 1]
                    };
                }
            }
        }
    });
    this.add("colon", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
                token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar === ';') {
                    range.end.column++;
                    return range;
                }
            }
        }
    });
    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
        if (text === ';' && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ';') {
                return {
                    text: '',
                    selection: [1, 1]
                };
            }
        }
    });
    this.add("!important", "insertion", function (state, action, editor, session, text) {
        if (text === '!' && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            if (/^\s*(;|}|$)/.test(line.substring(cursor.column))) {
                return {
                    text: '!important',
                    selection: [10, 10]
                };
            }
        }
    });
};
oop.inherits(CssBehaviour, CstyleBehaviour);
exports.CssBehaviour = CssBehaviour;

});

ace.define("ace/mode/css",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/css_highlight_rules","ace/mode/matching_brace_outdent","ace/worker/worker_client","ace/mode/css_completions","ace/mode/behaviour/css","ace/mode/folding/cstyle"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var CssHighlightRules = require("./css_highlight_rules").CssHighlightRules;
var MatchingBraceOutdent = require("./matching_brace_outdent").MatchingBraceOutdent;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var CssCompletions = require("./css_completions").CssCompletions;
var CssBehaviour = require("./behaviour/css").CssBehaviour;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;
var Mode = function () {
    this.HighlightRules = CssHighlightRules;
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CssBehaviour();
    this.$completer = new CssCompletions();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);
(function () {
    this.foldingRules = "cStyle";
    this.blockComment = { start: "/*", end: "*/" };
    this.getNextLineIndent = function (state, line, tab) {
        var indent = this.$getIndent(line);
        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
            return indent;
        }
        var match = line.match(/^.*\{\s*$/);
        if (match) {
            indent += tab;
        }
        return indent;
    };
    this.checkOutdent = function (state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };
    this.autoOutdent = function (state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };
    this.getCompletions = function (state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };
    this.createWorker = function (session) {
        var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
        worker.attachToDocument(session.getDocument());
        worker.on("annotate", function (e) {
            session.setAnnotations(e.data);
        });
        worker.on("terminate", function () {
            session.clearAnnotations();
        });
        return worker;
    };
    this.$id = "ace/mode/css";
    this.snippetFileId = "ace/snippets/css";
}).call(Mode.prototype);
exports.Mode = Mode;

});

ace.define("ace/mode/behaviour/xml",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var Behaviour = require("../behaviour").Behaviour;
var TokenIterator = require("../../token_iterator").TokenIterator;
var lang = require("../../lib/lang");
function is(token, type) {
    return token && token.type.lastIndexOf(type + ".xml") > -1;
}
var XmlBehaviour = function () {
    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            var quote = text;
            var selected = session.doc.getTextRange(editor.getSelectionRange());
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return {
                    text: quote + selected + quote,
                    selection: false
                };
            }
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (rightChar == quote && (is(token, "attribute-value") || is(token, "string"))) {
                return {
                    text: "",
                    selection: [1, 1]
                };
            }
            if (!token)
                token = iterator.stepBackward();
            if (!token)
                return;
            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                token = iterator.stepBackward();
            }
            var rightSpace = !rightChar || rightChar.match(/\s/);
            if (is(token, "attribute-equals") && (rightSpace || rightChar == '>') || (is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?'))) {
                return {
                    text: quote + quote,
                    selection: [1, 1]
                };
            }
        }
    });
    this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });
    this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
        if (text == '>') {
            var position = editor.getSelectionRange().start;
            var iterator = new TokenIterator(session, position.row, position.column);
            var token = iterator.getCurrentToken() || iterator.stepBackward();
            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
                return;
            if (is(token, "reference.attribute-value"))
                return;
            if (is(token, "attribute-value")) {
                var tokenEndColumn = iterator.getCurrentTokenColumn() + token.value.length;
                if (position.column < tokenEndColumn)
                    return;
                if (position.column == tokenEndColumn) {
                    var nextToken = iterator.stepForward();
                    if (nextToken && is(nextToken, "attribute-value"))
                        return;
                    iterator.stepBackward();
                }
            }
            if (/^\s*>/.test(session.getLine(position.row).slice(position.column)))
                return;
            while (!is(token, "tag-name")) {
                token = iterator.stepBackward();
                if (token.value == "<") {
                    token = iterator.stepForward();
                    break;
                }
            }
            var tokenRow = iterator.getCurrentTokenRow();
            var tokenColumn = iterator.getCurrentTokenColumn();
            if (is(iterator.stepBackward(), "end-tag-open"))
                return;
            var element = token.value;
            if (tokenRow == position.row)
                element = element.substring(0, position.column - tokenColumn);
            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
                return;
            return {
                text: ">" + "</" + element + ">",
                selection: [1, 1]
            };
        }
    });
    this.add("autoindent", "insertion", function (state, action, editor, session, text) {
        if (text == "\n") {
            var cursor = editor.getCursorPosition();
            var line = session.getLine(cursor.row);
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.type.indexOf("tag-close") !== -1) {
                if (token.value == "/>")
                    return;
                while (token && token.type.indexOf("tag-name") === -1) {
                    token = iterator.stepBackward();
                }
                if (!token) {
                    return;
                }
                var tag = token.value;
                var row = iterator.getCurrentTokenRow();
                token = iterator.stepBackward();
                if (!token || token.type.indexOf("end-tag") !== -1) {
                    return;
                }
                if (this.voidElements && !this.voidElements[tag]) {
                    var nextToken = session.getTokenAt(cursor.row, cursor.column + 1);
                    var line = session.getLine(row);
                    var nextIndent = this.$getIndent(line);
                    var indent = nextIndent + session.getTabString();
                    if (nextToken && nextToken.value === "</") {
                        return {
                            text: "\n" + indent + "\n" + nextIndent,
                            selection: [1, indent.length, 1, indent.length]
                        };
                    }
                    else {
                        return {
                            text: "\n" + indent
                        };
                    }
                }
            }
        }
    });
};
oop.inherits(XmlBehaviour, Behaviour);
exports.XmlBehaviour = XmlBehaviour;

});

ace.define("ace/mode/folding/mixed",["require","exports","module","ace/lib/oop","ace/mode/folding/fold_mode"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var BaseFoldMode = require("./fold_mode").FoldMode;
var FoldMode = exports.FoldMode = function (defaultMode, subModes) {
    this.defaultMode = defaultMode;
    this.subModes = subModes;
};
oop.inherits(FoldMode, BaseFoldMode);
(function () {
    this.$getMode = function (state) {
        if (typeof state != "string")
            state = state[0];
        for (var key in this.subModes) {
            if (state.indexOf(key) === 0)
                return this.subModes[key];
        }
        return null;
    };
    this.$tryMode = function (state, session, foldStyle, row) {
        var mode = this.$getMode(state);
        return (mode ? mode.getFoldWidget(session, foldStyle, row) : "");
    };
    this.getFoldWidget = function (session, foldStyle, row) {
        return (this.$tryMode(session.getState(row - 1), session, foldStyle, row) ||
            this.$tryMode(session.getState(row), session, foldStyle, row) ||
            this.defaultMode.getFoldWidget(session, foldStyle, row));
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        var mode = this.$getMode(session.getState(row - 1));
        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.$getMode(session.getState(row));
        if (!mode || !mode.getFoldWidget(session, foldStyle, row))
            mode = this.defaultMode;
        return mode.getFoldWidgetRange(session, foldStyle, row);
    };
}).call(FoldMode.prototype);

});

ace.define("ace/mode/folding/xml",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;
var FoldMode = exports.FoldMode = function (voidElements, optionalEndTags) {
    BaseFoldMode.call(this);
    this.voidElements = voidElements || {};
    this.optionalEndTags = oop.mixin({}, this.voidElements);
    if (optionalEndTags)
        oop.mixin(this.optionalEndTags, optionalEndTags);
};
oop.inherits(FoldMode, BaseFoldMode);
var Tag = function () {
    this.tagName = "";
    this.closing = false;
    this.selfClosing = false;
    this.start = { row: 0, column: 0 };
    this.end = { row: 0, column: 0 };
};
function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}
(function () {
    this.getFoldWidget = function (session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);
        if (!tag)
            return this.getCommentFoldWidget(session, row);
        if (tag.closing || (!tag.tagName && tag.selfClosing))
            return foldStyle === "markbeginend" ? "end" : "";
        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
            return "";
        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
            return "";
        return "start";
    };
    this.getCommentFoldWidget = function (session, row) {
        if (/comment/.test(session.getState(row)) && /<!-/.test(session.getLine(row)))
            return "start";
        return "";
    };
    this._getFirstTagInLine = function (session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (is(token, "tag-open")) {
                tag.end.column = tag.start.column + token.value.length;
                tag.closing = is(token, "end-tag-open");
                token = tokens[++i];
                if (!token)
                    return null;
                tag.tagName = token.value;
                tag.end.column += token.value.length;
                for (i++; i < tokens.length; i++) {
                    token = tokens[i];
                    tag.end.column += token.value.length;
                    if (is(token, "tag-close")) {
                        tag.selfClosing = token.value == '/>';
                        break;
                    }
                }
                return tag;
            }
            else if (is(token, "tag-close")) {
                tag.selfClosing = token.value == '/>';
                return tag;
            }
            tag.start.column += token.value.length;
        }
        return null;
    };
    this._findEndTagInLine = function (session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            column += token.value.length;
            if (column < startColumn)
                continue;
            if (is(token, "end-tag-open")) {
                token = tokens[i + 1];
                if (token && token.value == tagName)
                    return true;
            }
        }
        return false;
    };
    this.getFoldWidgetRange = function (session, foldStyle, row) {
        var tags = session.getMatchingTags({ row: row, column: 0 });
        if (tags) {
            return new Range(tags.openTag.end.row, tags.openTag.end.column, tags.closeTag.start.row, tags.closeTag.start.column);
        }
        else {
            return this.getCommentFoldWidget(session, row)
                && session.getCommentFoldRange(row, session.getLine(row).length);
        }
    };
}).call(FoldMode.prototype);

});

ace.define("ace/mode/folding/html",["require","exports","module","ace/lib/oop","ace/mode/folding/mixed","ace/mode/folding/xml","ace/mode/folding/cstyle"], function(require, exports, module){"use strict";
var oop = require("../../lib/oop");
var MixedFoldMode = require("./mixed").FoldMode;
var XmlFoldMode = require("./xml").FoldMode;
var CStyleFoldMode = require("./cstyle").FoldMode;
var FoldMode = exports.FoldMode = function (voidElements, optionalTags) {
    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {
        "js-": new CStyleFoldMode(),
        "css-": new CStyleFoldMode()
    });
};
oop.inherits(FoldMode, MixedFoldMode);

});

ace.define("ace/mode/html_completions",["require","exports","module","ace/token_iterator"], function(require, exports, module){"use strict";
var TokenIterator = require("../token_iterator").TokenIterator;
var commonAttributes = [
    "accesskey",
    "class",
    "contenteditable",
    "contextmenu",
    "dir",
    "draggable",
    "dropzone",
    "hidden",
    "id",
    "inert",
    "itemid",
    "itemprop",
    "itemref",
    "itemscope",
    "itemtype",
    "lang",
    "spellcheck",
    "style",
    "tabindex",
    "title",
    "translate"
];
var eventAttributes = [
    "onabort",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextmenu",
    "oncuechange",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmousedown",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onmousewheel",
    "onpause",
    "onplay",
    "onplaying",
    "onprogress",
    "onratechange",
    "onreset",
    "onscroll",
    "onseeked",
    "onseeking",
    "onselect",
    "onshow",
    "onstalled",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "onvolumechange",
    "onwaiting"
];
var globalAttributes = commonAttributes.concat(eventAttributes);
var attributeMap = {
    "a": { "href": 1, "target": { "_blank": 1, "top": 1 }, "ping": 1, "rel": { "nofollow": 1, "alternate": 1, "author": 1, "bookmark": 1, "help": 1, "license": 1, "next": 1, "noreferrer": 1, "prefetch": 1, "prev": 1, "search": 1, "tag": 1 }, "media": 1, "hreflang": 1, "type": 1 },
    "abbr": {},
    "address": {},
    "area": { "shape": 1, "coords": 1, "href": 1, "hreflang": 1, "alt": 1, "target": 1, "media": 1, "rel": 1, "ping": 1, "type": 1 },
    "article": { "pubdate": 1 },
    "aside": {},
    "audio": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
    "b": {},
    "base": { "href": 1, "target": 1 },
    "bdi": {},
    "bdo": {},
    "blockquote": { "cite": 1 },
    "body": { "onafterprint": 1, "onbeforeprint": 1, "onbeforeunload": 1, "onhashchange": 1, "onmessage": 1, "onoffline": 1, "onpopstate": 1, "onredo": 1, "onresize": 1, "onstorage": 1, "onundo": 1, "onunload": 1 },
    "br": {},
    "button": { "autofocus": 1, "disabled": { "disabled": 1 }, "form": 1, "formaction": 1, "formenctype": 1, "formmethod": 1, "formnovalidate": 1, "formtarget": 1, "name": 1, "value": 1, "type": { "button": 1, "submit": 1 } },
    "canvas": { "width": 1, "height": 1 },
    "caption": {},
    "cite": {},
    "code": {},
    "col": { "span": 1 },
    "colgroup": { "span": 1 },
    "command": { "type": 1, "label": 1, "icon": 1, "disabled": 1, "checked": 1, "radiogroup": 1, "command": 1 },
    "data": {},
    "datalist": {},
    "dd": {},
    "del": { "cite": 1, "datetime": 1 },
    "details": { "open": 1 },
    "dfn": {},
    "dialog": { "open": 1 },
    "div": {},
    "dl": {},
    "dt": {},
    "em": {},
    "embed": { "src": 1, "height": 1, "width": 1, "type": 1 },
    "fieldset": { "disabled": 1, "form": 1, "name": 1 },
    "figcaption": {},
    "figure": {},
    "footer": {},
    "form": { "accept-charset": 1, "action": 1, "autocomplete": 1, "enctype": { "multipart/form-data": 1, "application/x-www-form-urlencoded": 1 }, "method": { "get": 1, "post": 1 }, "name": 1, "novalidate": 1, "target": { "_blank": 1, "top": 1 } },
    "h1": {},
    "h2": {},
    "h3": {},
    "h4": {},
    "h5": {},
    "h6": {},
    "head": {},
    "header": {},
    "hr": {},
    "html": { "manifest": 1 },
    "i": {},
    "iframe": { "name": 1, "src": 1, "height": 1, "width": 1, "sandbox": { "allow-same-origin": 1, "allow-top-navigation": 1, "allow-forms": 1, "allow-scripts": 1 }, "seamless": { "seamless": 1 } },
    "img": { "alt": 1, "src": 1, "height": 1, "width": 1, "usemap": 1, "ismap": 1 },
    "input": {
        "type": { "text": 1, "password": 1, "hidden": 1, "checkbox": 1, "submit": 1, "radio": 1, "file": 1, "button": 1, "reset": 1, "image": 31, "color": 1, "date": 1, "datetime": 1, "datetime-local": 1, "email": 1, "month": 1, "number": 1, "range": 1, "search": 1, "tel": 1, "time": 1, "url": 1, "week": 1 },
        "accept": 1, "alt": 1, "autocomplete": { "on": 1, "off": 1 }, "autofocus": { "autofocus": 1 }, "checked": { "checked": 1 }, "disabled": { "disabled": 1 }, "form": 1, "formaction": 1, "formenctype": { "application/x-www-form-urlencoded": 1, "multipart/form-data": 1, "text/plain": 1 }, "formmethod": { "get": 1, "post": 1 }, "formnovalidate": { "formnovalidate": 1 }, "formtarget": { "_blank": 1, "_self": 1, "_parent": 1, "_top": 1 }, "height": 1, "list": 1, "max": 1, "maxlength": 1, "min": 1, "multiple": { "multiple": 1 }, "name": 1, "pattern": 1, "placeholder": 1, "readonly": { "readonly": 1 }, "required": { "required": 1 }, "size": 1, "src": 1, "step": 1, "width": 1, "files": 1, "value": 1
    },
    "ins": { "cite": 1, "datetime": 1 },
    "kbd": {},
    "keygen": { "autofocus": 1, "challenge": { "challenge": 1 }, "disabled": { "disabled": 1 }, "form": 1, "keytype": { "rsa": 1, "dsa": 1, "ec": 1 }, "name": 1 },
    "label": { "form": 1, "for": 1 },
    "legend": {},
    "li": { "value": 1 },
    "link": { "href": 1, "hreflang": 1, "rel": { "stylesheet": 1, "icon": 1 }, "media": { "all": 1, "screen": 1, "print": 1 }, "type": { "text/css": 1, "image/png": 1, "image/jpeg": 1, "image/gif": 1 }, "sizes": 1 },
    "main": {},
    "map": { "name": 1 },
    "mark": {},
    "math": {},
    "menu": { "type": 1, "label": 1 },
    "meta": { "http-equiv": { "content-type": 1 }, "name": { "description": 1, "keywords": 1 }, "content": { "text/html; charset=UTF-8": 1 }, "charset": 1 },
    "meter": { "value": 1, "min": 1, "max": 1, "low": 1, "high": 1, "optimum": 1 },
    "nav": {},
    "noscript": { "href": 1 },
    "object": { "param": 1, "data": 1, "type": 1, "height": 1, "width": 1, "usemap": 1, "name": 1, "form": 1, "classid": 1 },
    "ol": { "start": 1, "reversed": 1 },
    "optgroup": { "disabled": 1, "label": 1 },
    "option": { "disabled": 1, "selected": 1, "label": 1, "value": 1 },
    "output": { "for": 1, "form": 1, "name": 1 },
    "p": {},
    "param": { "name": 1, "value": 1 },
    "pre": {},
    "progress": { "value": 1, "max": 1 },
    "q": { "cite": 1 },
    "rp": {},
    "rt": {},
    "ruby": {},
    "s": {},
    "samp": {},
    "script": { "charset": 1, "type": { "text/javascript": 1 }, "src": 1, "defer": 1, "async": 1 },
    "select": { "autofocus": 1, "disabled": 1, "form": 1, "multiple": { "multiple": 1 }, "name": 1, "size": 1, "readonly": { "readonly": 1 } },
    "small": {},
    "source": { "src": 1, "type": 1, "media": 1 },
    "span": {},
    "strong": {},
    "style": { "type": 1, "media": { "all": 1, "screen": 1, "print": 1 }, "scoped": 1 },
    "sub": {},
    "sup": {},
    "svg": {},
    "table": { "summary": 1 },
    "tbody": {},
    "td": { "headers": 1, "rowspan": 1, "colspan": 1 },
    "textarea": { "autofocus": { "autofocus": 1 }, "disabled": { "disabled": 1 }, "form": 1, "maxlength": 1, "name": 1, "placeholder": 1, "readonly": { "readonly": 1 }, "required": { "required": 1 }, "rows": 1, "cols": 1, "wrap": { "on": 1, "off": 1, "hard": 1, "soft": 1 } },
    "tfoot": {},
    "th": { "headers": 1, "rowspan": 1, "colspan": 1, "scope": 1 },
    "thead": {},
    "time": { "datetime": 1 },
    "title": {},
    "tr": {},
    "track": { "kind": 1, "src": 1, "srclang": 1, "label": 1, "default": 1 },
    "section": {},
    "summary": {},
    "u": {},
    "ul": {},
    "var": {},
    "video": { "src": 1, "autobuffer": 1, "autoplay": { "autoplay": 1 }, "loop": { "loop": 1 }, "controls": { "controls": 1 }, "width": 1, "height": 1, "poster": 1, "muted": { "muted": 1 }, "preload": { "auto": 1, "metadata": 1, "none": 1 } },
    "wbr": {}
};
var elements = Object.keys(attributeMap);
function is(token, type) {
    return token.type.lastIndexOf(type + ".xml") > -1;
}
function findTagName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token && !is(token, "tag-name")) {
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}
function findAttributeName(session, pos) {
    var iterator = new TokenIterator(session, pos.row, pos.column);
    var token = iterator.getCurrentToken();
    while (token && !is(token, "attribute-name")) {
        token = iterator.stepBackward();
    }
    if (token)
        return token.value;
}
var HtmlCompletions = function () {
};
(function () {
    this.getCompletions = function (state, session, pos, prefix) {
        var token = session.getTokenAt(pos.row, pos.column);
        if (!token)
            return [];
        if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open"))
            return this.getTagCompletions(state, session, pos, prefix);
        if (is(token, "tag-whitespace") || is(token, "attribute-name"))
            return this.getAttributeCompletions(state, session, pos, prefix);
        if (is(token, "attribute-value"))
            return this.getAttributeValueCompletions(state, session, pos, prefix);
        var line = session.getLine(pos.row).substr(0, pos.column);
        if (/&[a-z]*$/i.test(line))
            return this.getHTMLEntityCompletions(state, session, pos, prefix);
        return [];
    };
    this.getTagCompletions = function (state, session, pos, prefix) {
        return elements.map(function (element) {
            return {
                value: element,
                meta: "tag",
                score: 1000000
            };
        });
    };
    this.getAttributeCompletions = function (state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        if (!tagName)
            return [];
        var attributes = globalAttributes;
        if (tagName in attributeMap) {
            attributes = attributes.concat(Object.keys(attributeMap[tagName]));
        }
        return attributes.map(function (attribute) {
            return {
                caption: attribute,
                snippet: attribute + '="$0"',
                meta: "attribute",
                score: 1000000
            };
        });
    };
    this.getAttributeValueCompletions = function (state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        var attributeName = findAttributeName(session, pos);
        if (!tagName)
            return [];
        var values = [];
        if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === "object") {
            values = Object.keys(attributeMap[tagName][attributeName]);
        }
        return values.map(function (value) {
            return {
                caption: value,
                snippet: value,
                meta: "attribute value",
                score: 1000000
            };
        });
    };
    this.getHTMLEntityCompletions = function (state, session, pos, prefix) {
        var values = ['Aacute;', 'aacute;', 'Acirc;', 'acirc;', 'acute;', 'AElig;', 'aelig;', 'Agrave;', 'agrave;', 'alefsym;', 'Alpha;', 'alpha;', 'amp;', 'and;', 'ang;', 'Aring;', 'aring;', 'asymp;', 'Atilde;', 'atilde;', 'Auml;', 'auml;', 'bdquo;', 'Beta;', 'beta;', 'brvbar;', 'bull;', 'cap;', 'Ccedil;', 'ccedil;', 'cedil;', 'cent;', 'Chi;', 'chi;', 'circ;', 'clubs;', 'cong;', 'copy;', 'crarr;', 'cup;', 'curren;', 'Dagger;', 'dagger;', 'dArr;', 'darr;', 'deg;', 'Delta;', 'delta;', 'diams;', 'divide;', 'Eacute;', 'eacute;', 'Ecirc;', 'ecirc;', 'Egrave;', 'egrave;', 'empty;', 'emsp;', 'ensp;', 'Epsilon;', 'epsilon;', 'equiv;', 'Eta;', 'eta;', 'ETH;', 'eth;', 'Euml;', 'euml;', 'euro;', 'exist;', 'fnof;', 'forall;', 'frac12;', 'frac14;', 'frac34;', 'frasl;', 'Gamma;', 'gamma;', 'ge;', 'gt;', 'hArr;', 'harr;', 'hearts;', 'hellip;', 'Iacute;', 'iacute;', 'Icirc;', 'icirc;', 'iexcl;', 'Igrave;', 'igrave;', 'image;', 'infin;', 'int;', 'Iota;', 'iota;', 'iquest;', 'isin;', 'Iuml;', 'iuml;', 'Kappa;', 'kappa;', 'Lambda;', 'lambda;', 'lang;', 'laquo;', 'lArr;', 'larr;', 'lceil;', 'ldquo;', 'le;', 'lfloor;', 'lowast;', 'loz;', 'lrm;', 'lsaquo;', 'lsquo;', 'lt;', 'macr;', 'mdash;', 'micro;', 'middot;', 'minus;', 'Mu;', 'mu;', 'nabla;', 'nbsp;', 'ndash;', 'ne;', 'ni;', 'not;', 'notin;', 'nsub;', 'Ntilde;', 'ntilde;', 'Nu;', 'nu;', 'Oacute;', 'oacute;', 'Ocirc;', 'ocirc;', 'OElig;', 'oelig;', 'Ograve;', 'ograve;', 'oline;', 'Omega;', 'omega;', 'Omicron;', 'omicron;', 'oplus;', 'or;', 'ordf;', 'ordm;', 'Oslash;', 'oslash;', 'Otilde;', 'otilde;', 'otimes;', 'Ouml;', 'ouml;', 'para;', 'part;', 'permil;', 'perp;', 'Phi;', 'phi;', 'Pi;', 'pi;', 'piv;', 'plusmn;', 'pound;', 'Prime;', 'prime;', 'prod;', 'prop;', 'Psi;', 'psi;', 'quot;', 'radic;', 'rang;', 'raquo;', 'rArr;', 'rarr;', 'rceil;', 'rdquo;', 'real;', 'reg;', 'rfloor;', 'Rho;', 'rho;', 'rlm;', 'rsaquo;', 'rsquo;', 'sbquo;', 'Scaron;', 'scaron;', 'sdot;', 'sect;', 'shy;', 'Sigma;', 'sigma;', 'sigmaf;', 'sim;', 'spades;', 'sub;', 'sube;', 'sum;', 'sup;', 'sup1;', 'sup2;', 'sup3;', 'supe;', 'szlig;', 'Tau;', 'tau;', 'there4;', 'Theta;', 'theta;', 'thetasym;', 'thinsp;', 'THORN;', 'thorn;', 'tilde;', 'times;', 'trade;', 'Uacute;', 'uacute;', 'uArr;', 'uarr;', 'Ucirc;', 'ucirc;', 'Ugrave;', 'ugrave;', 'uml;', 'upsih;', 'Upsilon;', 'upsilon;', 'Uuml;', 'uuml;', 'weierp;', 'Xi;', 'xi;', 'Yacute;', 'yacute;', 'yen;', 'Yuml;', 'yuml;', 'Zeta;', 'zeta;', 'zwj;', 'zwnj;'];
        return values.map(function (value) {
            return {
                caption: value,
                snippet: value,
                meta: "html entity",
                score: 1000000
            };
        });
    };
}).call(HtmlCompletions.prototype);
exports.HtmlCompletions = HtmlCompletions;

});

ace.define("ace/mode/html",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text","ace/mode/javascript","ace/mode/css","ace/mode/html_highlight_rules","ace/mode/behaviour/xml","ace/mode/folding/html","ace/mode/html_completions","ace/worker/worker_client"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextMode = require("./text").Mode;
var JavaScriptMode = require("./javascript").Mode;
var CssMode = require("./css").Mode;
var HtmlHighlightRules = require("./html_highlight_rules").HtmlHighlightRules;
var XmlBehaviour = require("./behaviour/xml").XmlBehaviour;
var HtmlFoldMode = require("./folding/html").FoldMode;
var HtmlCompletions = require("./html_completions").HtmlCompletions;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "menuitem", "param", "source", "track", "wbr"];
var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];
var Mode = function (options) {
    this.fragmentContext = options && options.fragmentContext;
    this.HighlightRules = HtmlHighlightRules;
    this.$behaviour = new XmlBehaviour();
    this.$completer = new HtmlCompletions();
    this.createModeDelegates({
        "js-": JavaScriptMode,
        "css-": CssMode
    });
    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));
};
oop.inherits(Mode, TextMode);
(function () {
    this.blockComment = { start: "<!--", end: "-->" };
    this.voidElements = lang.arrayToMap(voidElements);
    this.getNextLineIndent = function (state, line, tab) {
        return this.$getIndent(line);
    };
    this.checkOutdent = function (state, line, input) {
        return false;
    };
    this.getCompletions = function (state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
    };
    this.createWorker = function (session) {
        if (this.constructor != Mode)
            return;
        var worker = new WorkerClient(["ace"], "ace/mode/html_worker", "Worker");
        worker.attachToDocument(session.getDocument());
        if (this.fragmentContext)
            worker.call("setOptions", [{ context: this.fragmentContext }]);
        worker.on("error", function (e) {
            session.setAnnotations(e.data);
        });
        worker.on("terminate", function () {
            session.clearAnnotations();
        });
        return worker;
    };
    this.$id = "ace/mode/html";
    this.snippetFileId = "ace/snippets/html";
}).call(Mode.prototype);
exports.Mode = Mode;

});

ace.define("ace/mode/sh_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var reservedKeywords = exports.reservedKeywords = ('!|{|}|case|do|done|elif|else|' +
    'esac|fi|for|if|in|then|until|while|' +
    '&|;|export|local|read|typeset|unset|' +
    'elif|select|set|function|declare|readonly');
var languageConstructs = exports.languageConstructs = ('[|]|alias|bg|bind|break|builtin|' +
    'cd|command|compgen|complete|continue|' +
    'dirs|disown|echo|enable|eval|exec|' +
    'exit|fc|fg|getopts|hash|help|history|' +
    'jobs|kill|let|logout|popd|printf|pushd|' +
    'pwd|return|set|shift|shopt|source|' +
    'suspend|test|times|trap|type|ulimit|' +
    'umask|unalias|wait');
var ShHighlightRules = function () {
    var keywordMapper = this.createKeywordMapper({
        "keyword": reservedKeywords,
        "support.function.builtin": languageConstructs,
        "invalid.deprecated": "debugger"
    }, "identifier");
    var integer = "(?:(?:[1-9]\\d*)|(?:0))";
    var fraction = "(?:\\.\\d+)";
    var intPart = "(?:\\d+)";
    var pointFloat = "(?:(?:" + intPart + "?" + fraction + ")|(?:" + intPart + "\\.))";
    var exponentFloat = "(?:(?:" + pointFloat + "|" + intPart + ")" + ")";
    var floatNumber = "(?:" + exponentFloat + "|" + pointFloat + ")";
    var fileDescriptor = "(?:&" + intPart + ")";
    var variableName = "[a-zA-Z_][a-zA-Z0-9_]*";
    var variable = "(?:" + variableName + "(?==))";
    var builtinVariable = "(?:\\$(?:SHLVL|\\$|\\!|\\?))";
    var func = "(?:" + variableName + "\\s*\\(\\))";
    this.$rules = {
        "start": [{
                token: "constant",
                regex: /\\./
            }, {
                token: ["text", "comment"],
                regex: /(^|\s)(#.*)$/
            }, {
                token: "string.start",
                regex: '"',
                push: [{
                        token: "constant.language.escape",
                        regex: /\\(?:[$`"\\]|$)/
                    }, {
                        include: "variables"
                    }, {
                        token: "keyword.operator",
                        regex: /`/ // TODO highlight `
                    }, {
                        token: "string.end",
                        regex: '"',
                        next: "pop"
                    }, {
                        defaultToken: "string"
                    }]
            }, {
                token: "string",
                regex: "\\$'",
                push: [{
                        token: "constant.language.escape",
                        regex: /\\(?:[abeEfnrtv\\'"]|x[a-fA-F\d]{1,2}|u[a-fA-F\d]{4}([a-fA-F\d]{4})?|c.|\d{1,3})/
                    }, {
                        token: "string",
                        regex: "'",
                        next: "pop"
                    }, {
                        defaultToken: "string"
                    }]
            }, {
                regex: "<<<",
                token: "keyword.operator"
            }, {
                stateName: "heredoc",
                regex: "(<<-?)(\\s*)(['\"`]?)([\\w\\-]+)(['\"`]?)",
                onMatch: function (value, currentState, stack) {
                    var next = value[2] == '-' ? "indentedHeredoc" : "heredoc";
                    var tokens = value.split(this.splitRegex);
                    stack.push(next, tokens[4]);
                    return [
                        { type: "constant", value: tokens[1] },
                        { type: "text", value: tokens[2] },
                        { type: "string", value: tokens[3] },
                        { type: "support.class", value: tokens[4] },
                        { type: "string", value: tokens[5] }
                    ];
                },
                rules: {
                    heredoc: [{
                            onMatch: function (value, currentState, stack) {
                                if (value === stack[1]) {
                                    stack.shift();
                                    stack.shift();
                                    this.next = stack[0] || "start";
                                    return "support.class";
                                }
                                this.next = "";
                                return "string";
                            },
                            regex: ".*$",
                            next: "start"
                        }],
                    indentedHeredoc: [{
                            token: "string",
                            regex: "^\t+"
                        }, {
                            onMatch: function (value, currentState, stack) {
                                if (value === stack[1]) {
                                    stack.shift();
                                    stack.shift();
                                    this.next = stack[0] || "start";
                                    return "support.class";
                                }
                                this.next = "";
                                return "string";
                            },
                            regex: ".*$",
                            next: "start"
                        }]
                }
            }, {
                regex: "$",
                token: "empty",
                next: function (currentState, stack) {
                    if (stack[0] === "heredoc" || stack[0] === "indentedHeredoc")
                        return stack[0];
                    return currentState;
                }
            }, {
                token: ["keyword", "text", "text", "text", "variable"],
                regex: /(declare|local|readonly)(\s+)(?:(-[fixar]+)(\s+))?([a-zA-Z_][a-zA-Z0-9_]*\b)/
            }, {
                token: "variable.language",
                regex: builtinVariable
            }, {
                token: "variable",
                regex: variable
            }, {
                include: "variables"
            }, {
                token: "support.function",
                regex: func
            }, {
                token: "support.function",
                regex: fileDescriptor
            }, {
                token: "string",
                start: "'", end: "'"
            }, {
                token: "constant.numeric",
                regex: floatNumber
            }, {
                token: "constant.numeric",
                regex: integer + "\\b"
            }, {
                token: keywordMapper,
                regex: "[a-zA-Z_][a-zA-Z0-9_]*\\b"
            }, {
                token: "keyword.operator",
                regex: "\\+|\\-|\\*|\\*\\*|\\/|\\/\\/|~|<|>|<=|=>|=|!=|[%&|`]"
            }, {
                token: "punctuation.operator",
                regex: ";"
            }, {
                token: "paren.lparen",
                regex: "[\\[\\(\\{]"
            }, {
                token: "paren.rparen",
                regex: "[\\]]"
            }, {
                token: "paren.rparen",
                regex: "[\\)\\}]",
                next: "pop"
            }],
        variables: [{
                token: "variable",
                regex: /(\$)(\w+)/
            }, {
                token: ["variable", "paren.lparen"],
                regex: /(\$)(\()/,
                push: "start"
            }, {
                token: ["variable", "paren.lparen", "keyword.operator", "variable", "keyword.operator"],
                regex: /(\$)(\{)([#!]?)(\w+|[*@#?\-$!0_])(:[?+\-=]?|##?|%%?|,,?\/|\^\^?)?/,
                push: "start"
            }, {
                token: "variable",
                regex: /\$[*@#?\-$!0_]/
            }, {
                token: ["variable", "paren.lparen"],
                regex: /(\$)(\{)/,
                push: "start"
            }]
    };
    this.normalizeRules();
};
oop.inherits(ShHighlightRules, TextHighlightRules);
exports.ShHighlightRules = ShHighlightRules;

});

ace.define("ace/mode/sh",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/sh_highlight_rules","ace/range","ace/mode/folding/cstyle","ace/mode/behaviour/cstyle"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var ShHighlightRules = require("./sh_highlight_rules").ShHighlightRules;
var Range = require("../range").Range;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var Mode = function () {
    this.HighlightRules = ShHighlightRules;
    this.foldingRules = new CStyleFoldMode();
    this.$behaviour = new CstyleBehaviour();
};
oop.inherits(Mode, TextMode);
(function () {
    this.lineCommentStart = "#";
    this.getNextLineIndent = function (state, line, tab) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
            return indent;
        }
        if (state == "start") {
            var match = line.match(/^.*[\{\(\[:]\s*$/);
            if (match) {
                indent += tab;
            }
        }
        return indent;
    };
    var outdents = {
        "pass": 1,
        "return": 1,
        "raise": 1,
        "break": 1,
        "continue": 1
    };
    this.checkOutdent = function (state, line, input) {
        if (input !== "\r\n" && input !== "\r" && input !== "\n")
            return false;
        var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;
        if (!tokens)
            return false;
        do {
            var last = tokens.pop();
        } while (last && (last.type == "comment" || (last.type == "text" && last.value.match(/^\s+$/))));
        if (!last)
            return false;
        return (last.type == "keyword" && outdents[last.value]);
    };
    this.autoOutdent = function (state, doc, row) {
        row += 1;
        var indent = this.$getIndent(doc.getLine(row));
        var tab = doc.getTabString();
        if (indent.slice(-tab.length) == tab)
            doc.remove(new Range(row, indent.length - tab.length, row, indent.length));
    };
    this.$id = "ace/mode/sh";
    this.snippetFileId = "ace/snippets/sh";
}).call(Mode.prototype);
exports.Mode = Mode;

});

ace.define("ace/mode/xml",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/mode/text","ace/mode/xml_highlight_rules","ace/mode/behaviour/xml","ace/mode/folding/xml","ace/worker/worker_client"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var lang = require("../lib/lang");
var TextMode = require("./text").Mode;
var XmlHighlightRules = require("./xml_highlight_rules").XmlHighlightRules;
var XmlBehaviour = require("./behaviour/xml").XmlBehaviour;
var XmlFoldMode = require("./folding/xml").FoldMode;
var WorkerClient = require("../worker/worker_client").WorkerClient;
var Mode = function () {
    this.HighlightRules = XmlHighlightRules;
    this.$behaviour = new XmlBehaviour();
    this.foldingRules = new XmlFoldMode();
};
oop.inherits(Mode, TextMode);
(function () {
    this.voidElements = lang.arrayToMap([]);
    this.blockComment = { start: "<!--", end: "-->" };
    this.createWorker = function (session) {
        var worker = new WorkerClient(["ace"], "ace/mode/xml_worker", "Worker");
        worker.attachToDocument(session.getDocument());
        worker.on("error", function (e) {
            session.setAnnotations(e.data);
        });
        worker.on("terminate", function () {
            session.clearAnnotations();
        });
        return worker;
    };
    this.$id = "ace/mode/xml";
}).call(Mode.prototype);
exports.Mode = Mode;

});

ace.define("ace/mode/markdown",["require","exports","module","ace/lib/oop","ace/mode/behaviour/cstyle","ace/mode/text","ace/mode/markdown_highlight_rules","ace/mode/folding/markdown","ace/mode/javascript","ace/mode/html","ace/mode/sh","ace/mode/sh","ace/mode/xml","ace/mode/css"], function(require, exports, module){"use strict";
var oop = require("../lib/oop");
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
var TextMode = require("./text").Mode;
var MarkdownHighlightRules = require("./markdown_highlight_rules").MarkdownHighlightRules;
var MarkdownFoldMode = require("./folding/markdown").FoldMode;
var Mode = function () {
    this.HighlightRules = MarkdownHighlightRules;
    this.createModeDelegates({
        javascript: require("./javascript").Mode,
        html: require("./html").Mode,
        bash: require("./sh").Mode,
        sh: require("./sh").Mode,
        xml: require("./xml").Mode,
        css: require("./css").Mode
    });
    this.foldingRules = new MarkdownFoldMode();
    this.$behaviour = new CstyleBehaviour({ braces: true });
};
oop.inherits(Mode, TextMode);
(function () {
    this.type = "text";
    this.blockComment = { start: "<!--", end: "-->" };
    this.$quotes = { '"': '"', "`": "`" };
    this.getNextLineIndent = function (state, line, tab) {
        if (state == "listblock") {
            var match = /^(\s*)(?:([-+*])|(\d+)\.)(\s+)/.exec(line);
            if (!match)
                return "";
            var marker = match[2];
            if (!marker)
                marker = parseInt(match[3], 10) + 1 + ".";
            return match[1] + marker + match[4];
        }
        else {
            return this.$getIndent(line);
        }
    };
    this.$id = "ace/mode/markdown";
    this.snippetFileId = "ace/snippets/markdown";
}).call(Mode.prototype);
exports.Mode = Mode;

});                (function() {
                    ace.require(["ace/mode/markdown"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='mode_plain_text'  type='text/javascript'  charset='utf-8'>ace.define("ace/mode/plain_text",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/text_highlight_rules","ace/mode/behaviour"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
var Behaviour = require("./behaviour").Behaviour;

var Mode = function() {
    this.HighlightRules = TextHighlightRules;
    this.$behaviour = new Behaviour();
};

oop.inherits(Mode, TextMode);

(function() {
    this.type = "text";
    this.getNextLineIndent = function(state, line, tab) {
        return '';
    };
    this.$id = "ace/mode/plain_text";
}).call(Mode.prototype);

exports.Mode = Mode;
});                (function() {
                    ace.require(["ace/mode/plain_text"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='mode_sh'  type='text/javascript'  charset='utf-8'>ace.define("ace/mode/sh_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var reservedKeywords = exports.reservedKeywords = (
        '!|{|}|case|do|done|elif|else|'+
        'esac|fi|for|if|in|then|until|while|'+
        '&|;|export|local|read|typeset|unset|'+
        'elif|select|set|function|declare|readonly'
    );

var languageConstructs = exports.languageConstructs = (
    '[|]|alias|bg|bind|break|builtin|'+
     'cd|command|compgen|complete|continue|'+
     'dirs|disown|echo|enable|eval|exec|'+
     'exit|fc|fg|getopts|hash|help|history|'+
     'jobs|kill|let|logout|popd|printf|pushd|'+
     'pwd|return|set|shift|shopt|source|'+
     'suspend|test|times|trap|type|ulimit|'+
     'umask|unalias|wait'
);

var ShHighlightRules = function() {
    var keywordMapper = this.createKeywordMapper({
        "keyword": reservedKeywords,
        "support.function.builtin": languageConstructs,
        "invalid.deprecated": "debugger"
    }, "identifier");

    var integer = "(?:(?:[1-9]\\d*)|(?:0))";

    var fraction = "(?:\\.\\d+)";
    var intPart = "(?:\\d+)";
    var pointFloat = "(?:(?:" + intPart + "?" + fraction + ")|(?:" + intPart + "\\.))";
    var exponentFloat = "(?:(?:" + pointFloat + "|" +  intPart + ")" + ")";
    var floatNumber = "(?:" + exponentFloat + "|" + pointFloat + ")";
    var fileDescriptor = "(?:&" + intPart + ")";

    var variableName = "[a-zA-Z_][a-zA-Z0-9_]*";
    var variable = "(?:" + variableName + "(?==))";

    var builtinVariable = "(?:\\$(?:SHLVL|\\$|\\!|\\?))";

    var func = "(?:" + variableName + "\\s*\\(\\))";

    this.$rules = {
        "start" : [{
            token : "constant",
            regex : /\\./
        }, {
            token : ["text", "comment"],
            regex : /(^|\s)(#.*)$/
        }, {
            token : "string.start",
            regex : '"',
            push : [{
                token : "constant.language.escape",
                regex : /\\(?:[$`"\\]|$)/
            }, {
                include : "variables"
            }, {
                token : "keyword.operator",
                regex : /`/ // TODO highlight `
            }, {
                token : "string.end",
                regex : '"',
                next: "pop"
            }, {
                defaultToken: "string"
            }]
        }, {
            token : "string",
            regex : "\\$'",
            push : [{
                token : "constant.language.escape",
                regex : /\\(?:[abeEfnrtv\\'"]|x[a-fA-F\d]{1,2}|u[a-fA-F\d]{4}([a-fA-F\d]{4})?|c.|\d{1,3})/
            }, {
                token : "string",
                regex : "'",
                next: "pop"
            }, {
                defaultToken: "string"
            }]
        }, {
            regex : "<<<",
            token : "keyword.operator"
        }, {
            stateName: "heredoc",
            regex : "(<<-?)(\\s*)(['\"`]?)([\\w\\-]+)(['\"`]?)",
            onMatch : function(value, currentState, stack) {
                var next = value[2] == '-' ? "indentedHeredoc" : "heredoc";
                var tokens = value.split(this.splitRegex);
                stack.push(next, tokens[4]);
                return [
                    {type:"constant", value: tokens[1]},
                    {type:"text", value: tokens[2]},
                    {type:"string", value: tokens[3]},
                    {type:"support.class", value: tokens[4]},
                    {type:"string", value: tokens[5]}
                ];
            },
            rules: {
                heredoc: [{
                    onMatch:  function(value, currentState, stack) {
                        if (value === stack[1]) {
                            stack.shift();
                            stack.shift();
                            this.next = stack[0] || "start";
                            return "support.class";
                        }
                        this.next = "";
                        return "string";
                    },
                    regex: ".*$",
                    next: "start"
                }],
                indentedHeredoc: [{
                    token: "string",
                    regex: "^\t+"
                }, {
                    onMatch:  function(value, currentState, stack) {
                        if (value === stack[1]) {
                            stack.shift();
                            stack.shift();
                            this.next = stack[0] || "start";
                            return "support.class";
                        }
                        this.next = "";
                        return "string";
                    },
                    regex: ".*$",
                    next: "start"
                }]
            }
        }, {
            regex : "$",
            token : "empty",
            next : function(currentState, stack) {
                if (stack[0] === "heredoc" || stack[0] === "indentedHeredoc")
                    return stack[0];
                return currentState;
            }
        }, {
            token : ["keyword", "text", "text", "text", "variable"],
            regex : /(declare|local|readonly)(\s+)(?:(-[fixar]+)(\s+))?([a-zA-Z_][a-zA-Z0-9_]*\b)/
        }, {
            token : "variable.language",
            regex : builtinVariable
        }, {
            token : "variable",
            regex : variable
        }, {
            include : "variables"
        }, {
            token : "support.function",
            regex : func
        }, {
            token : "support.function",
            regex : fileDescriptor
        }, {
            token : "string",           // ' string
            start : "'", end : "'"
        }, {
            token : "constant.numeric", // float
            regex : floatNumber
        }, {
            token : "constant.numeric", // integer
            regex : integer + "\\b"
        }, {
            token : keywordMapper,
            regex : "[a-zA-Z_][a-zA-Z0-9_]*\\b"
        }, {
            token : "keyword.operator",
            regex : "\\+|\\-|\\*|\\*\\*|\\/|\\/\\/|~|<|>|<=|=>|=|!=|[%&|`]"
        }, {
            token : "punctuation.operator",
            regex : ";"
        }, {
            token : "paren.lparen",
            regex : "[\\[\\(\\{]"
        }, {
            token : "paren.rparen",
            regex : "[\\]]"
        }, {
            token : "paren.rparen",
            regex : "[\\)\\}]",
            next : "pop"
        }],
        variables: [{
            token : "variable",
            regex : /(\$)(\w+)/
        }, {
            token : ["variable", "paren.lparen"],
            regex : /(\$)(\()/,
            push : "start"
        }, {
            token : ["variable", "paren.lparen", "keyword.operator", "variable", "keyword.operator"],
            regex : /(\$)(\{)([#!]?)(\w+|[*@#?\-$!0_])(:[?+\-=]?|##?|%%?|,,?\/|\^\^?)?/,
            push : "start"
        }, {
            token : "variable",
            regex : /\$[*@#?\-$!0_]/
        }, {
            token : ["variable", "paren.lparen"],
            regex : /(\$)(\{)/,
            push : "start"
        }]
    };
    
    this.normalizeRules();
};

oop.inherits(ShHighlightRules, TextHighlightRules);

exports.ShHighlightRules = ShHighlightRules;
});

ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(require, exports, module) {
"use strict";

var oop = require("../../lib/oop");
var Range = require("../../range").Range;
var BaseFoldMode = require("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {
    
    this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
    this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
    this._getFoldWidgetBase = this.getFoldWidget;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
    
        if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
                return "";
        }
    
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
    
        if (!fw && this.startRegionRe.test(line))
            return "start"; // lineCommentRegionStart
    
        return fw;
    };

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        
        if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
        
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };
    this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
            line = session.getLine(row);
            var m = re.exec(line);
            if (!m) continue;
            if (m[1]) depth--;
            else depth++;

            if (!depth) break;
        }

        var endRow = row;
        if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
        }
    };

}).call(FoldMode.prototype);

});

ace.define("ace/mode/sh",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/sh_highlight_rules","ace/range","ace/mode/folding/cstyle","ace/mode/behaviour/cstyle"], function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextMode = require("./text").Mode;
var ShHighlightRules = require("./sh_highlight_rules").ShHighlightRules;
var Range = require("../range").Range;
var CStyleFoldMode = require("./folding/cstyle").FoldMode;
var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;

var Mode = function() {
    this.HighlightRules = ShHighlightRules;
    this.foldingRules = new CStyleFoldMode();
    this.$behaviour = new CstyleBehaviour();
};
oop.inherits(Mode, TextMode);

(function() {

   
    this.lineCommentStart = "#";

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start") {
            var match = line.match(/^.*[\{\(\[:]\s*$/);
            if (match) {
                indent += tab;
            }
        }

        return indent;
    };

    var outdents = {
        "pass": 1,
        "return": 1,
        "raise": 1,
        "break": 1,
        "continue": 1
    };

    this.checkOutdent = function(state, line, input) {
        if (input !== "\r\n" && input !== "\r" && input !== "\n")
            return false;

        var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;

        if (!tokens)
            return false;
        do {
            var last = tokens.pop();
        } while (last && (last.type == "comment" || (last.type == "text" && last.value.match(/^\s+$/))));

        if (!last)
            return false;

        return (last.type == "keyword" && outdents[last.value]);
    };

    this.autoOutdent = function(state, doc, row) {

        row += 1;
        var indent = this.$getIndent(doc.getLine(row));
        var tab = doc.getTabString();
        if (indent.slice(-tab.length) == tab)
            doc.remove(new Range(row, indent.length-tab.length, row, indent.length));
    };

    this.$id = "ace/mode/sh";
    this.snippetFileId = "ace/snippets/sh";
}).call(Mode.prototype);

exports.Mode = Mode;
});                (function() {
                    ace.require(["ace/mode/sh"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='theme_chrome'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/chrome",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-chrome";
exports.cssText = ".ace-chrome .ace_gutter {\
background: #ebebeb;\
color: #333;\
overflow : hidden;\
}\
.ace-chrome .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-chrome {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-chrome .ace_cursor {\
color: black;\
}\
.ace-chrome .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-chrome .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-chrome .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-chrome .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-chrome .ace_invalid {\
background-color: rgb(153, 0, 0);\
color: white;\
}\
.ace-chrome .ace_fold {\
}\
.ace-chrome .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-chrome .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-chrome .ace_support.ace_type,\
.ace-chrome .ace_support.ace_class\
.ace-chrome .ace_support.ace_other {\
color: rgb(109, 121, 222);\
}\
.ace-chrome .ace_variable.ace_parameter {\
font-style:italic;\
color:#FD971F;\
}\
.ace-chrome .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-chrome .ace_comment {\
color: #236e24;\
}\
.ace-chrome .ace_comment.ace_doc {\
color: #236e24;\
}\
.ace-chrome .ace_comment.ace_doc.ace_tag {\
color: #236e24;\
}\
.ace-chrome .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-chrome .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-chrome .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-chrome .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-chrome .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-chrome .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-chrome .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-chrome .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-chrome .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-chrome .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-chrome .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-chrome .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-chrome .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-chrome .ace_storage,\
.ace-chrome .ace_keyword,\
.ace-chrome .ace_meta.ace_tag {\
color: rgb(147, 15, 128);\
}\
.ace-chrome .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-chrome .ace_string {\
color: #1A1AA6;\
}\
.ace-chrome .ace_entity.ace_other.ace_attribute-name {\
color: #994409;\
}\
.ace-chrome .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/chrome"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='theme_cobalt'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/cobalt",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = true;
exports.cssClass = "ace-cobalt";
exports.cssText = ".ace-cobalt .ace_gutter {\
background: #011e3a;\
color: rgb(128,145,160)\
}\
.ace-cobalt .ace_print-margin {\
width: 1px;\
background: #555555\
}\
.ace-cobalt {\
background-color: #002240;\
color: var(--editor-text-color)\
}\
.ace-cobalt .ace_cursor {\
color: #FFFFFF\
}\
.ace-cobalt .ace_marker-layer .ace_selection {\
background: rgba(179, 101, 57, 0.75)\
}\
.ace-cobalt.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #002240;\
}\
.ace-cobalt .ace_marker-layer .ace_step {\
background: rgb(127, 111, 19)\
}\
.ace-cobalt .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid var(--matching-paren-outline-color);\
background: var(--matching-paren-color);\
}\
.ace-cobalt .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.35)\
}\
.ace-cobalt .ace_gutter-active-line {\
background-color: rgba(0, 0, 0, 0.35)\
}\
.ace-cobalt .ace_marker-layer .ace_selected-word {\
border: 1px solid rgba(179, 101, 57, 0.75);\
background-color: var(--editor-selected-word-bg-color);\
}\
.ace-cobalt .ace_invisible {\
color: rgba(255, 255, 255, 0.15)\
}\
.ace-cobalt .ace_keyword,\
.ace-cobalt .ace_meta {\
color: #FF9D00\
}\
.ace-cobalt .ace_constant,\
.ace-cobalt .ace_constant.ace_character,\
.ace-cobalt .ace_constant.ace_character.ace_escape,\
.ace-cobalt .ace_constant.ace_other {\
color: #FF628C\
}\
.ace-cobalt .ace_invalid {\
color: #F8F8F8;\
background-color: #800F00\
}\
.ace-cobalt .ace_support {\
color: #80FFBB\
}\
.ace-cobalt .ace_support.ace_constant {\
color: #EB939A\
}\
.ace-cobalt .ace_fold {\
background-color: #FF9D00;\
border-color: #FFFFFF\
}\
.ace-cobalt .ace_function {\
color: #e0ebff\
}\
.ace-cobalt .ace_asyncfunction {\
color: #ffecae\
}\
.ace-cobalt .ace_storage {\
color: #FFEE80\
}\
.ace-cobalt .ace_entity {\
color: #FFDD00\
}\
.ace-cobalt .ace_string {\
color: #3AD900\
}\
.ace-cobalt .ace_string.ace_regexp {\
color: #80FFC2\
}\
.ace-cobalt .ace_comment { color: #0088FF }\
.ace-cobalt .ace_heading,\
.ace-cobalt .ace_markup.ace_heading {\
color: #C8E4FD;\
background-color: #001221\
}\
.ace-cobalt .ace_list,\
.ace-cobalt .ace_markup.ace_list {\
background-color: #130D26\
}\
.ace-cobalt .ace_variable {\
color: #CCCCCC\
}\
.ace-cobalt .ace_variable.ace_language {\
color: #FF80E1\
}\
.ace-cobalt .ace_meta.ace_tag {\
color: #9EFFFF\
}\
.ace-cobalt .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHCLSvkPAAP3AgSDTRd4AAAAAElFTkSuQmCC) right repeat-y\
}\
";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/cobalt"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            
</script> <script id='theme_crimson_editor'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/crimson_editor",["require","exports","module","ace/lib/dom"], function(require, exports, module) {
exports.isDark = false;
exports.cssText = ".ace-crimson-editor .ace_gutter {\
background: #ebebeb;\
color: #333;\
overflow : hidden;\
}\
.ace-crimson-editor .ace_gutter-layer {\
width: 100%;\
text-align: right;\
}\
.ace-crimson-editor .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-crimson-editor {\
background-color: #FFFFFF;\
color: rgb(64, 64, 64);\
}\
.ace-crimson-editor .ace_cursor {\
color: black;\
}\
.ace-crimson-editor .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-crimson-editor .ace_identifier {\
color: black;\
}\
.ace-crimson-editor .ace_keyword {\
color: blue;\
}\
.ace-crimson-editor .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-crimson-editor .ace_constant.ace_language {\
color: rgb(255, 156, 0);\
}\
.ace-crimson-editor .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-crimson-editor .ace_invalid {\
text-decoration: line-through;\
color: rgb(224, 0, 0);\
}\
.ace-crimson-editor .ace_fold {\
}\
.ace-crimson-editor .ace_support.ace_function {\
color: rgb(192, 0, 0);\
}\
.ace-crimson-editor .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-crimson-editor .ace_support.ace_type,\
.ace-crimson-editor .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-crimson-editor .ace_keyword.ace_operator {\
color: rgb(49, 132, 149);\
}\
.ace-crimson-editor .ace_string {\
color: rgb(128, 0, 128);\
}\
.ace-crimson-editor .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-crimson-editor .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-crimson-editor .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-crimson-editor .ace_constant.ace_numeric {\
color: rgb(0, 0, 64);\
}\
.ace-crimson-editor .ace_variable {\
color: rgb(0, 64, 128);\
}\
.ace-crimson-editor .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-crimson-editor .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-crimson-editor .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-crimson-editor .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-crimson-editor .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-crimson-editor .ace_marker-layer .ace_active-line {\
background: rgb(232, 242, 254);\
}\
.ace-crimson-editor .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-crimson-editor .ace_meta.ace_tag {\
color:rgb(28, 2, 255);\
}\
.ace-crimson-editor .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-crimson-editor .ace_string.ace_regex {\
color: rgb(192, 0, 192);\
}\
.ace-crimson-editor .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}";

exports.cssClass = "ace-crimson-editor";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/crimson_editor"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='theme_dracula'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/dracula",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = true;
exports.cssClass = "ace-dracula";
exports.cssText = "\
.ace-dracula .ace_gutter {\
background: #282a36;\
color: rgb(144,145,148)\
}\
.ace-dracula .ace_print-margin {\
width: 1px;\
background: #44475a\
}\
.ace-dracula {\
background-color: #282a36;\
color: #f8f8f2\
}\
.ace-dracula .ace_cursor {\
color: #f8f8f0\
}\
.ace-dracula .ace_marker-layer .ace_selection {\
background: #44475a\
}\
.ace-dracula.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #282a36;\
border-radius: 2px\
}\
.ace-dracula .ace_marker-layer .ace_step {\
background: rgb(198, 219, 174)\
}\
.ace-dracula .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #a29709\
}\
.ace-dracula .ace_marker-layer .ace_active-line {\
background: #44475a\
}\
.ace-dracula .ace_gutter-active-line {\
background-color: #44475a\
}\
.ace-dracula .ace_marker-layer .ace_selected-word {\
box-shadow: 0px 0px 0px 1px #a29709;\
border-radius: 3px;\
}\
.ace-dracula .ace_fold {\
background-color: #50fa7b;\
border-color: #f8f8f2\
}\
.ace-dracula .ace_keyword {\
color: #ff79c6\
}\
.ace-dracula .ace_constant.ace_language {\
color: #bd93f9\
}\
.ace-dracula .ace_constant.ace_numeric {\
color: #bd93f9\
}\
.ace-dracula .ace_constant.ace_character {\
color: #bd93f9\
}\
.ace-dracula .ace_constant.ace_character.ace_escape {\
color: #ff79c6\
}\
.ace-dracula .ace_constant.ace_other {\
color: #bd93f9\
}\
.ace-dracula .ace_support.ace_function {\
color: #8be9fd\
}\
.ace-dracula .ace_support.ace_constant {\
color: #6be5fd\
}\
.ace-dracula .ace_support.ace_class {\
font-style: italic;\
color: #66d9ef\
}\
.ace-dracula .ace_support.ace_type {\
font-style: italic;\
color: #66d9ef\
}\
.ace-dracula .ace_storage {\
color: #ff79c6\
}\
.ace-dracula .ace_storage.ace_type {\
font-style: italic;\
color: #8be9fd\
}\
.ace-dracula .ace_invalid {\
color: #F8F8F0;\
background-color: #ff79c6\
}\
.ace-dracula .ace_invalid.ace_deprecated {\
color: #F8F8F0;\
background-color: #bd93f9\
}\
.ace-dracula .ace_string {\
color: #f1fa8c\
}\
.ace-dracula .ace_comment {\
color: #6272a4\
}\
.ace-dracula .ace_variable {\
color: #50fa7b\
}\
.ace-dracula .ace_variable.ace_parameter {\
font-style: italic;\
color: #ffb86c\
}\
.ace-dracula .ace_entity.ace_other.ace_attribute-name {\
color: #50fa7b\
}\
.ace-dracula .ace_entity.ace_name.ace_function {\
color: #50fa7b\
}\
.ace-dracula .ace_entity.ace_name.ace_tag {\
color: #ff79c6\
}\
.ace-dracula .ace_invisible {\
color: #626680;\
}\
.ace-dracula .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHB3d/8PAAOIAdULw8qMAAAAAElFTkSuQmCC) right repeat-y\
}";
exports.$selectionColorConflict = true;

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/dracula"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='theme_earth_tones'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/earth_tones",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-earth_tones";
exports.cssText = "\
.ace-earth_tones .ace_gutter {\
background: var(--editor-gutter-bg-color);\
color: var(--editor-gutter-color);\
}\
.ace-earth_tones .ace_print-margin {\
width: 1px;\
background: var(--editor-bg-color);\
}\
.ace-earth_tones {\
background-color: var(--editor-bg-color);\
color: var(--editor-text-color);\
}\
.ace-earth_tones .ace_cursor {\
color: var(--editor-cursor-color);\
}\
.ace-earth_tones .ace_marker-layer .ace_selection {\
background: var(--editor-selected-bg-color);\
}\
.ace-earth_tones.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px var(--editor-bg-color);\
}\
.ace-earth_tones .ace_marker-layer .ace_step {\
background: var(--editor-step-bg-color);\
}\
.ace-earth_tones .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid var(--matching-paren-outline-color);\
background: var(--matching-paren-color);\
}\
.ace-earth_tones .ace_marker-layer .ace_active-line {\
background: var(--editor-active-line-bg)\
}\
.ace-earth_tones .ace_gutter-active-line {\
background-color: var(--editor-active-line-gutter-bg-color);\
}\
.ace-earth_tones .ace_marker-layer .ace_selected-word {\
border: 1px solid var(--editor-selected-bg-color);\
background-color: var(--editor-selected-word-bg-color);\
box-shadow: 0px 0px 2px 2px #0000001F;\
}\
.ace-earth_tones .ace_invisible {\
color: var(--editor-invisible-color)\
}\
.ace-earth_tones .ace_fold {\
border-color: var(--editor-invisible-color)\
}\
.ace-earth_tones .ace_constant{color:var(--editor-constant-color);}\
.ace-earth_tones .ace_constant.ace_numeric{color:var(--editor-numeric-color);}\
.ace-earth_tones .ace_support{color:var(--editor-support-color);}\
.ace-earth_tones .ace_function{color:var(--editor-function-color);}\
.ace-earth_tones .ace_asyncfunction{color:var(--editor-asyncfunction-color);}\
.ace-earth_tones .ace_constant{color:var(--editor-constant-color);}\
.ace-earth_tones .ace_storage{color:var(--editor-storage-color);}\
.ace-earth_tones .ace_invalid.ace_illegal{color:var(--editor-illegal-color);\
background-color:var(--editor-illegal-bg-color);}\
.ace-earth_tones .ace_invalid.ace_deprecated{text-decoration:underline;\
font-style:italic;\
color:var(--editor-deprecated-color);\
background-color:var(--editor-deprecated-bg-color);}\
.ace-earth_tones .ace_string{color:var(--editor-string-color);}\
.ace-earth_tones .ace_string.ace_regexp{color:var(--editor-regex-color);\
background-color:var(--editor-regex-bg-color);}\
.ace-earth_tones .ace_comment{color:var(--editor-comment-color);}\
.ace-earth_tones .ace_variable{var(--editor-variable-color);}\
.ace-earth_tones .ace_meta.ace_tag{color:#005273;}\
.ace-earth_tones .ace_markup.ace_heading{color:var(--editor-heading-color);\
background-color:var(--editor-heading-bg-color);}\
.ace-earth_tones .ace_markup.ace_list{color:var(--editor-list-color);}\
.ace-earth_tones .ace_keyword{color:var(--editor-keyword-color);}\
.ace-earth_tones .ace_identifier{color:var(--editor-identifier-color);}\
";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});

(function() {
  ace.require(["ace/theme/earth_tones"], function(m) {
    if (typeof module == "object" && typeof exports == "object" && module) {
      module.exports = m;
    }
  });
})();
            
</script> <script id='theme_gruvbox'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/gruvbox",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = true;
exports.cssClass = "ace-gruvbox";
exports.cssText = ".ace-gruvbox .ace_gutter-active-line {\
background-color: #3C3836;\
}\
.ace-gruvbox {\
color: #EBDAB4;\
background-color: #1D2021;\
}\
.ace-gruvbox .ace_invisible {\
color: #504945;\
}\
.ace-gruvbox .ace_marker-layer .ace_selection {\
background: rgba(179, 101, 57, 0.75)\
}\
.ace-gruvbox.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #002240;\
}\
.ace-gruvbox .ace_keyword {\
color: #8ec07c;\
}\
.ace-gruvbox .ace_comment {\
font-style: italic;\
color: #928375;\
}\
.ace-gruvbox .ace-statement {\
color: red;\
}\
.ace-gruvbox .ace_variable {\
color: #84A598;\
}\
.ace-gruvbox .ace_variable.ace_language {\
color: #D2879B;\
}\
.ace-gruvbox .ace_constant {\
color: #C2859A;\
}\
.ace-gruvbox .ace_constant.ace_language {\
color: #C2859A;\
}\
.ace-gruvbox .ace_constant.ace_numeric {\
color: #C2859A;\
}\
.ace-gruvbox .ace_string {\
color: #B8BA37;\
}\
.ace-gruvbox .ace_support {\
color: #F9BC41;\
}\
.ace-gruvbox .ace_support.ace_function {\
color: #F84B3C;\
}\
.ace-gruvbox .ace_storage {\
color: #8FBF7F;\
}\
.ace-gruvbox .ace_keyword.ace_operator {\
color: #EBDAB4;\
}\
.ace-gruvbox .ace_punctuation.ace_operator {\
color: yellow;\
}\
.ace-gruvbox .ace_marker-layer .ace_active-line {\
background: #3C3836;\
}\
.ace-gruvbox .ace_marker-layer .ace_selected-word {\
border-radius: 4px;\
border: 8px solid #3f475d;\
}\
.ace-gruvbox .ace_print-margin {\
width: 5px;\
background: #3C3836;\
}\
.ace-gruvbox .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNQUFD4z6Crq/sfAAuYAuYl+7lfAAAAAElFTkSuQmCC\") right repeat-y;\
}";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);

});                (function() {
                    ace.require(["ace/theme/gruvbox"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='theme_idle_fingers'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/idle_fingers",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = true;
exports.cssClass = "ace-idle-fingers";
exports.cssText = ".ace-idle-fingers .ace_gutter {\
background: #3b3b3b;\
color: rgb(153,153,153)\
}\
.ace-idle-fingers .ace_print-margin {\
width: 1px;\
background: #3b3b3b\
}\
.ace-idle-fingers {\
background-color: var(--editor-bg-color);\
color: var(--editor-text-color)\
}\
.ace-idle-fingers .ace_cursor {\
color: #91FF00\
}\
.ace-idle-fingers .ace_marker-layer .ace_selection {\
background: var(--editor-selected-bg-color)\
}\
.ace-idle-fingers.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #323232;\
}\
.ace-idle-fingers .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-idle-fingers .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid var(--matching-paren-outline-color);\
color: var(--matching-paren-color);\
}\
.ace-idle-fingers .ace_marker-layer .ace_active-line {\
background: #353637\
}\
.ace-idle-fingers .ace_gutter-active-line {\
background-color: #353637\
}\
.ace-idle-fingers .ace_marker-layer .ace_selected-word {\
border: 1px solid rgba(90, 100, 126, 0.88);\
background: var(--editor-selected-word-bg-color)\
}\
.ace-idle-fingers .ace_invisible {\
color: #404040\
}\
.ace-idle-fingers .ace_keyword,\
.ace-idle-fingers .ace_meta {\
color: #CC7833\
}\
.ace-idle-fingers .ace_constant,\
.ace-idle-fingers .ace_constant.ace_character,\
.ace-idle-fingers .ace_constant.ace_character.ace_escape,\
.ace-idle-fingers .ace_constant.ace_other,\
.ace-idle-fingers .ace_support.ace_constant {\
color: #6C99BB\
}\
.ace-idle-fingers .ace_invalid {\
color: #FFFFFF;\
background-color: #FF0000\
}\
.ace-idle-fingers .ace_fold {\
background-color: #CC7833;\
border-color: #FFFFFF\
}\
.ace-idle-fingers .ace_function {\
color: #e3b5b5\
}\
.ace-idle-fingers .ace_asyncfunction {\
color: #e6e7bb\
}\
.ace-idle-fingers .ace_variable.ace_parameter {\
font-style: italic\
}\
.ace-idle-fingers .ace_string {\
color: #A5C261\
}\
.ace-idle-fingers .ace_string.ace_regexp {\
color: #CCCC33\
}\
.ace-idle-fingers .ace_comment {color: #BC9458}\
.ace-idle-fingers .ace_meta.ace_tag {\
color: #FFE5BB\
}\
.ace-idle-fingers .ace_entity.ace_name {\
color: #FFC66D\
}\
.ace-idle-fingers .ace_collab.ace_user1 {\
color: #323232;\
background-color: #FFF980\
}\
.ace-idle-fingers .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMwMjLyZYiPj/8PAAreAwAI1+g0AAAAAElFTkSuQmCC) right repeat-y\
}";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/idle_fingers"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            
</script> <script id='theme_juno_light'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/juno_light",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-juno_light";
exports.cssText = "\
.ace-juno_light .ace_gutter {\
background: var(--editor-gutter-bg-color);\
color: var(--editor-gutter-color);\
}\
.ace-juno_light .ace_print-margin {\
width: 1px;\
background: var(--editor-bg-color);\
}\
.ace-juno_light {\
background-color: var(--editor-bg-color);\
color: var(--editor-text-color);\
}\
.ace-juno_light .ace_cursor {\
color: var(--editor-cursor-color);\
}\
.ace-juno_light .ace_marker-layer .ace_selection {\
background: var(--editor-selected-bg-color);\
}\
.ace-juno_light.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px var(--editor-bg-color);\
}\
.ace-juno_light .ace_marker-layer .ace_step {\
background: var(--editor-step-bg-color);\
}\
.ace-juno_light .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid var(--matching-paren-outline-color);\
background: var(--matching-paren-color);\
}\
.ace-juno_light .ace_marker-layer .ace_active-line {\
background: var(--editor-active-line-bg)\
}\
.ace-juno_light .ace_gutter-active-line {\
background-color: var(--editor-active-line-gutter-bg-color);\
}\
.ace-juno_light .ace_marker-layer .ace_selected-word {\
border: 1px solid var(--editor-selected-bg-color);\
background: var(--editor-selected-word-bg-color);\
}\
.ace-juno_light .ace_invisible {\
color: var(--editor-invisible-color)\
}\
.ace-juno_light .ace_fold {\
border-color: var(--editor-invisible-color)\
}\
.ace-juno_light .ace_constant{color:var(--editor-constant-color);}\
.ace-juno_light .ace_constant.ace_numeric{color:var(--editor-numeric-color);}\
.ace-juno_light .ace_support{color:var(--editor-support-color);}\
.ace-juno_light .ace_function{color:var(--editor-function-color);}\
.ace-juno_light .ace_asyncfunction{color:var(--editor-asyncfunction-color);}\
.ace-juno_light .ace_constant{color:var(--editor-constant-color);}\
.ace-juno_light .ace_storage{color:var(--editor-storage-color);}\
.ace-juno_light .ace_invalid.ace_illegal{color:var(--editor-illegal-color);\
background-color:var(--editor-illegal-bg-color);}\
.ace-juno_light .ace_invalid.ace_deprecated{text-decoration:underline;\
font-style:italic;\
color:var(--editor-deprecated-color);\
background-color:var(--editor-deprecated-bg-color);}\
.ace-juno_light .ace_string{color:var(--editor-string-color);}\
.ace-juno_light .ace_string.ace_regexp{color:var(--editor-regex-color);\
background-color:var(--editor-regex-bg-color);}\
.ace-juno_light .ace_comment{color:var(--editor-comment-color);}\
.ace-juno_light .ace_variable{var(--editor-variable-color);}\
.ace-juno_light .ace_meta.ace_tag{color:#005273;}\
.ace-juno_light .ace_markup.ace_heading{color:var(--editor-heading-color);\
background-color:var(--editor-heading-bg-color);}\
.ace-juno_light .ace_markup.ace_list{color:var(--editor-list-color);}\
.ace-juno_light .ace_keyword{color:var(--editor-keyword-color);}\
.ace-juno_light .ace_identifier{color:var(--editor-identifier-color);}\
";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});

(function() {
  ace.require(["ace/theme/juno_light"], function(m) {
    if (typeof module == "object" && typeof exports == "object" && module) {
      module.exports = m;
    }
  });
})();
            
</script> <script id='theme_katzenmilch'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/katzenmilch",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-katzenmilch";
exports.cssText = ".ace-katzenmilch .ace_gutter,\
.ace-katzenmilch .ace_gutter {\
background: #e8e8e8;\
color: #333\
}\
.ace-katzenmilch .ace_print-margin {\
width: 1px;\
background: #e8e8e8\
}\
.ace-katzenmilch {\
background-color: #f3f2f3;\
color: rgba(15, 0, 9, 1.0)\
}\
.ace-katzenmilch .ace_cursor {\
border-left: 2px solid #100011\
}\
.ace-katzenmilch .ace_overwrite-cursors .ace_cursor {\
border-left: 0px;\
border-bottom: 1px solid #100011\
}\
.ace-katzenmilch .ace_marker-layer .ace_selection {\
background: rgba(100, 5, 208, 0.27)\
}\
.ace-katzenmilch.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #f3f2f3;\
}\
.ace-katzenmilch .ace_marker-layer .ace_step {\
background: rgb(198, 219, 174)\
}\
.ace-katzenmilch .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgba(0, 0, 0, 0.33);\
}\
.ace-katzenmilch .ace_marker-layer .ace_active-line {\
background: rgb(232, 242, 254)\
}\
.ace-katzenmilch .ace_gutter-active-line {\
background-color: rgb(232, 242, 254)\
}\
.ace-katzenmilch .ace_marker-layer .ace_selected-word {\
border: 1px solid rgba(100, 5, 208, 0.27)\
}\
.ace-katzenmilch .ace_invisible {\
color: #BFBFBF\
}\
.ace-katzenmilch .ace_fold {\
background-color: rgba(2, 95, 73, 0.97);\
border-color: rgba(15, 0, 9, 1.0)\
}\
.ace-katzenmilch .ace_keyword {\
color: #674Aa8;\
rbackground-color: rgba(163, 170, 216, 0.055)\
}\
.ace-katzenmilch .ace_constant.ace_language {\
color: #7D7e52;\
rbackground-color: rgba(189, 190, 130, 0.059)\
}\
.ace-katzenmilch .ace_constant.ace_numeric {\
color: rgba(79, 130, 123, 0.93);\
rbackground-color: rgba(119, 194, 187, 0.059)\
}\
.ace-katzenmilch .ace_constant.ace_character,\
.ace-katzenmilch .ace_constant.ace_other {\
color: rgba(2, 95, 105, 1.0);\
rbackground-color: rgba(127, 34, 153, 0.063)\
}\
.ace-katzenmilch .ace_support.ace_function {\
color: #9D7e62;\
rbackground-color: rgba(189, 190, 130, 0.039)\
}\
.ace-katzenmilch .ace_support.ace_class {\
color: rgba(239, 106, 167, 1.0);\
rbackground-color: rgba(239, 106, 167, 0.063)\
}\
.ace-katzenmilch .ace_storage {\
color: rgba(123, 92, 191, 1.0);\
rbackground-color: rgba(139, 93, 223, 0.051)\
}\
.ace-katzenmilch .ace_invalid {\
color: #DFDFD5;\
rbackground-color: #CC1B27\
}\
.ace-katzenmilch .ace_string {\
color: #5a5f9b;\
rbackground-color: rgba(170, 175, 219, 0.035)\
}\
.ace-katzenmilch .ace_comment {\
font-style: italic;\
color: rgba(64, 79, 80, 0.67);\
rbackground-color: rgba(95, 15, 255, 0.0078)\
}\
.ace-katzenmilch .ace_entity.ace_name.ace_function,\
.ace-katzenmilch .ace_variable {\
color: rgba(2, 95, 73, 0.97);\
rbackground-color: rgba(34, 255, 73, 0.12)\
}\
.ace-katzenmilch .ace_variable.ace_language {\
color: #316fcf;\
rbackground-color: rgba(58, 175, 255, 0.039)\
}\
.ace-katzenmilch .ace_variable.ace_parameter {\
font-style: italic;\
color: rgba(51, 150, 159, 0.87);\
rbackground-color: rgba(5, 214, 249, 0.043)\
}\
.ace-katzenmilch .ace_entity.ace_other.ace_attribute-name {\
color: rgba(73, 70, 194, 0.93);\
rbackground-color: rgba(73, 134, 194, 0.035)\
}\
.ace-katzenmilch .ace_entity.ace_name.ace_tag {\
color: #3976a2;\
rbackground-color: rgba(73, 166, 210, 0.039)\
}";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/katzenmilch"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='theme_kuroir'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/kuroir",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-kuroir";
exports.cssText = "\
.ace-kuroir .ace_gutter {\
background: #e0e0e0;\
color: #333;\
}\
.ace-kuroir .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-kuroir {\
background-color: #eeeae8;\
color: #363636;\
}\
.ace-kuroir .ace_cursor {\
color: #202020;\
}\
.ace-kuroir .ace_marker-layer .ace_selection {\
background: rgba(245, 170, 0, 0.57);\
}\
.ace-kuroir.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #EEEAE8;\
}\
.ace-kuroir .ace_marker-layer .ace_step {\
background: rgb(198, 219, 174);\
}\
.ace-kuroir .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid var(--matching-paren-outline-color);\
background: var(--matching-paren-color);\
}\
.ace-kuroir .ace_marker-layer .ace_active-line {\
background: rgb(255 255 255 / 38%);\
}\
.ace-kuroir .ace_gutter-active-line {\
background-color: rgb(166 166 166 / 46%);\
}\
.ace-kuroir .ace_marker-layer .ace_selected-word {\
border: 1px solid rgba(245, 170, 0, 0.57);\
}\
.ace-kuroir .ace_invisible {\
color: #BFBFBF\
}\
.ace-kuroir .ace_fold {\
border-color: #363636;\
}\
.ace-kuroir .ace_constant{color:#CD6839;}.ace-kuroir .ace_constant.ace_numeric{color:#9A5925;}.ace-kuroir .ace_support{color:#104E8B;}.ace-kuroir .ace_support.ace_function{color:#005273;}.ace-kuroir .ace_support.ace_constant{color:#CF6A4C;}.ace-kuroir .ace_storage{color:#A52A2A;}.ace-kuroir .ace_invalid.ace_illegal{color:#FD1224;\
background-color:rgba(255, 6, 0, 0.15);}.ace-kuroir .ace_invalid.ace_deprecated{text-decoration:underline;\
font-style:italic;\
color:#FD1732;\
background-color:#EEEAE8;}.ace-kuroir .ace_string{color:#00938d;}.ace-kuroir .ace_string.ace_regexp{color:#417E00;\
background-color:#C9D4BE;}.ace-kuroir .ace_comment{color:rgba(148, 148, 148, 0.91);\
background-color:rgba(220, 220, 220, 0.56);}.ace-kuroir .ace_variable{color:#009ACD;}.ace-kuroir .ace_meta.ace_tag{color:#005273;}.ace-kuroir .ace_markup.ace_heading{color:#B8012D;\
background-color:rgba(191, 97, 51, 0.051);}.ace-kuroir .ace_markup.ace_list{color:#8F5B26;}\
.ace-kuroir .ace_keyword{color:#8b0078;}.ace-kuroir .ace_identifier{color:#9d00b1}\
";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/kuroir"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            
</script> <script id='theme_solarized_dark'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/solarized_dark",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = true;
exports.cssClass = "ace-solarized-dark";
exports.cssText = ".ace-solarized-dark .ace_gutter {\
background: #01313f;\
color: #d0edf7\
}\
.ace-solarized-dark .ace_print-margin {\
width: 1px;\
background: #33555E\
}\
.ace-solarized-dark {\
background-color: #002B36;\
color: #93A1A1\
}\
.ace-solarized-dark .ace_entity.ace_other.ace_attribute-name,\
.ace-solarized-dark .ace_storage {\
color: #93A1A1\
}\
.ace-solarized-dark .ace_cursor,\
.ace-solarized-dark .ace_string.ace_regexp {\
color: #D30102\
}\
.ace-solarized-dark .ace_marker-layer .ace_active-line,\
.ace-solarized-dark .ace_marker-layer .ace_selection {\
background: rgba(255, 255, 255, 0.1)\
}\
.ace-solarized-dark.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #002B36;\
}\
.ace-solarized-dark .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-solarized-dark .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgba(147, 161, 161, 0.50)\
}\
.ace-solarized-dark .ace_gutter-active-line {\
background-color: #0d3440\
}\
.ace-solarized-dark .ace_marker-layer .ace_selected-word {\
border: 1px solid #073642\
}\
.ace-solarized-dark .ace_invisible {\
color: rgba(147, 161, 161, 0.50)\
}\
.ace-solarized-dark .ace_keyword,\
.ace-solarized-dark .ace_meta,\
.ace-solarized-dark .ace_support.ace_class,\
.ace-solarized-dark .ace_support.ace_type {\
color: #859900\
}\
.ace-solarized-dark .ace_constant.ace_character,\
.ace-solarized-dark .ace_constant.ace_other {\
color: #CB4B16\
}\
.ace-solarized-dark .ace_constant.ace_language {\
color: #B58900\
}\
.ace-solarized-dark .ace_constant.ace_numeric {\
color: #D33682\
}\
.ace-solarized-dark .ace_fold {\
background-color: #268BD2;\
border-color: #93A1A1\
}\
.ace-solarized-dark .ace_entity.ace_name.ace_function,\
.ace-solarized-dark .ace_entity.ace_name.ace_tag,\
.ace-solarized-dark .ace_support.ace_function,\
.ace-solarized-dark .ace_variable,\
.ace-solarized-dark .ace_variable.ace_language {\
color: #268BD2\
}\
.ace-solarized-dark .ace_string {\
color: #2AA198\
}\
.ace-solarized-dark .ace_comment {\
font-style: italic;\
color: #657B83\
}\
.ace-solarized-dark .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNg0Db1ZVCxc/sPAAd4AlUHlLenAAAAAElFTkSuQmCC) right repeat-y\
}";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/solarized_dark"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script> <script id='theme_solarized_light'  type='text/javascript'  charset='utf-8'>ace.define("ace/theme/solarized_light",["require","exports","module","ace/lib/dom"], function(require, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-solarized-light";
exports.cssText = ".ace-solarized-light .ace_gutter {\
background: #fbf1d3;\
color: #333\
}\
.ace-solarized-light .ace_print-margin {\
width: 1px;\
background: #e8e8e8\
}\
.ace-solarized-light {\
background-color: #FDF6E3;\
color: #586E75\
}\
.ace-solarized-light .ace_cursor {\
color: #000000\
}\
.ace-solarized-light .ace_marker-layer .ace_selection {\
background: rgba(7, 54, 67, 0.09)\
}\
.ace-solarized-light.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #FDF6E3;\
}\
.ace-solarized-light .ace_marker-layer .ace_step {\
background: rgb(255, 255, 0)\
}\
.ace-solarized-light .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgba(147, 161, 161, 0.50)\
}\
.ace-solarized-light .ace_marker-layer .ace_active-line {\
background: #EEE8D5\
}\
.ace-solarized-light .ace_gutter-active-line {\
background-color : #EDE5C1\
}\
.ace-solarized-light .ace_marker-layer .ace_selected-word {\
border: 1px solid #7f9390\
}\
.ace-solarized-light .ace_invisible {\
color: rgba(147, 161, 161, 0.50)\
}\
.ace-solarized-light .ace_keyword,\
.ace-solarized-light .ace_meta,\
.ace-solarized-light .ace_support.ace_class,\
.ace-solarized-light .ace_support.ace_type {\
color: #859900\
}\
.ace-solarized-light .ace_constant.ace_character,\
.ace-solarized-light .ace_constant.ace_other {\
color: #CB4B16\
}\
.ace-solarized-light .ace_constant.ace_language {\
color: #B58900\
}\
.ace-solarized-light .ace_constant.ace_numeric {\
color: #D33682\
}\
.ace-solarized-light .ace_fold {\
background-color: #268BD2;\
border-color: #586E75\
}\
.ace-solarized-light .ace_entity.ace_name.ace_function,\
.ace-solarized-light .ace_entity.ace_name.ace_tag,\
.ace-solarized-light .ace_support.ace_function,\
.ace-solarized-light .ace_variable,\
.ace-solarized-light .ace_variable.ace_language {\
color: #268BD2\
}\
.ace-solarized-light .ace_storage {\
color: #073642\
}\
.ace-solarized-light .ace_string {\
color: #2AA198\
}\
.ace-solarized-light .ace_string.ace_regexp {\
color: #D30102\
}\
.ace-solarized-light .ace_comment,\
.ace-solarized-light .ace_entity.ace_other.ace_attribute-name {\
color: #93A1A1\
}\
.ace-solarized-light .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHjy8NJ/AAjgA5fzQUmBAAAAAElFTkSuQmCC) right repeat-y\
}";

var dom = require("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass, false);
});                (function() {
                    ace.require(["ace/theme/solarized_light"], function(m) {
                        if (typeof module == "object" && typeof exports == "object" && module) {
                            module.exports = m;
                        }
                    });
                })();
            </script></head> <body style='height: 100vh; overflow: hidden;'><header id='page_header'  style='background: #F3F3F3; display: flex;'/> <div id='lower_right_corner'  style='position: absolute; right: 50px; bottom: 5px; width: 255px;'/></body></html>